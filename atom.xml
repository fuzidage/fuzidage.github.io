<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-02T10:04:34.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>imx6ull裸机-SPI</title>
    <link href="http://example.com/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/"/>
    <id>http://example.com/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/</id>
    <published>2024-05-02T09:33:11.000Z</published>
    <updated>2024-05-02T10:04:34.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-spi-jie-shao">1 SPI介绍</a><ul><li><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</a><ul><li><a href="#1-1-1-te-dian">1.1.1 特点</a></li><li><a href="#1-1-2-kuang-tu">1.1.2 框图</a></li><li><a href="#1-1-3-shi-xu">1.1.3 时序</a></li></ul></li><li><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</a><ul><li><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</a></li><li><a href="#1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</a><ul><li><a href="#1-2-2-1-rxdata">1.2.2.1 RXDATA</a></li><li><a href="#1-2-2-2-txdata">1.2.2.2 TXDATA</a></li><li><a href="#1-2-2-3-conreg">1.2.2.3 CONREG</a></li><li><a href="#1-2-2-4-configreg">1.2.2.4 CONFIGREG</a></li><li><a href="#1-2-2-5-statreg">1.2.2.5 STATREG</a></li><li><a href="#1-2-2-6-periodreg">1.2.2.6 PERIODREG</a></li></ul></li></ul></li><li><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</a></li></ul></li><li><a href="#2-spi-ying-yong">2 SPI 应用</a><ul><li><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</a><ul><li><a href="#2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</a></li><li><a href="#2-1-2-ying-yong-chang-jing">2.1.2 应用场景</a></li><li><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</a></li><li><a href="#2-1-4-dian-qi-te-xing">2.1.4 电器特性</a></li><li><a href="#2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</a></li><li><a href="#2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</a></li><li><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</a></li></ul></li><li><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</a><ul><li><a href="#2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</a></li><li><a href="#2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</a></li><li><a href="#2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</a></li><li><a href="#2-2-4-pwr-mgmt-1-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</a></li></ul></li></ul></li><li><a href="#2-3-dai-ma-jie-xi">2.3 代码解析</a><ul><li><a href="#2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-spi-jie-shao">1 SPI介绍</span><a href="#1-spi-jie-shao" class="header-anchor">#</a></h1><p><a href="https://fuzidage.github.io/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/">s3c2440裸机编程-SPI | Hexo (fuzidage.github.io)</a>有详细介绍SPI协议。</p><h2><span id="1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</span><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao" class="header-anchor">#</a></h2><p>NXP的6ull参考手册第Chapter 20介绍了SPI控制器，<code>Enhanced Configurable SPI (ECSPI)</code> 。</p><h3><span id="1-1-1-te-dian">1.1.1 特点</span><a href="#1-1-1-te-dian" class="header-anchor">#</a></h3><p>①、全双工同步串行接口。<br>②、可配置的主&#x2F;从模式。<br>③、四个硬件片选信号，支持多从机。<br>④、发送和接收都有一个 32x64 的 FIFO。<br>⑤、片选信号 SS&#x2F;CS，时钟信号 SCLK 的极性相位<code>(CPOL,CPHA)</code>可配置。<br>⑥、支持 DMA<br>⑦、SCK最高可以到输入参考时钟高达60Mhz</p><h3><span id="1-1-2-kuang-tu">1.1.2 框图</span><a href="#1-1-2-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/1.png" alt="image"><br>最右边是引脚，SCLK,MISO,MOSI等，上面是外围总线，通过APB总线进行寄存器读写，<code>INTREG,CONREG</code>等等。TXDATA和TXDATA寄存器存放了要发送的数据和接收的收据。<br>时钟源来自<code>Reference Clock or Low Frequency Clock</code>。可选时钟源如下：这里选用<code>ecspi_clk_root</code>。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/2.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/3.png" alt="image"><br>① CSCDR2的ECSPI_CLK_SEL位设置为0，选择出PLL3_SW_CLK 进行8分频作为 ECSPI 根时钟源。PLL3_SW_CLK&#x3D;480MHz,8分频就是60MHz。<br>② CSCDR2 的 ECSPI_CLK_PODF位再次进行分频，ECSPI_CLK_PODF位设置成0，表示2^0分频，也就是1分频。<br>③ 最后ECSPI_CLK_ROOT就为60MHz</p><h3><span id="1-1-3-shi-xu">1.1.3 时序</span><a href="#1-1-3-shi-xu" class="header-anchor">#</a></h3><p>CPOL时钟极性 和CPHA时钟相位组合成了4种模式：</p><pre><code>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</code></pre><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/4.png" alt="image"></p><h2><span id="1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</span><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</span><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng" class="header-anchor">#</a></h3><p><strong>CONREG</strong>[EN]：复位，0表示复位<br><strong>CCM</strong>开启ECSPI时钟<br><strong>CONREG</strong>[EN]：复位，1表示反选复位<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/5.png" alt="image"></p><h3><span id="1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</span><a href="#1-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="1-2-2-1-rxdata">1.2.2.1 RXDATA</span><a href="#1-2-2-1-rxdata" class="header-anchor">#</a></h4><p><strong>RXDATA寄存器</strong>：接收数据寄存器，RR位的状态决定接受数据是否就绪<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/6.png" alt="image"></p><h4><span id="1-2-2-2-txdata">1.2.2.2 TXDATA</span><a href="#1-2-2-2-txdata" class="header-anchor">#</a></h4><p><strong>TXDATA寄存器</strong>:发送数据寄存器，实际传输的位数由相应SPI控制寄存器的BURST_LENGTH位来决定。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/7.png" alt="image"></p><h4><span id="1-2-2-3-conreg">1.2.2.3 CONREG</span><a href="#1-2-2-3-conreg" class="header-anchor">#</a></h4><p><strong>CONREG寄存器</strong>:控制寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/8.png" alt="image"><br><strong>EN</strong>:使能位，1为使能<br><strong>SMC</strong>:为1表示当数据写入TXFIFO时，立即启动SPI突发；这里使用该模式<br><strong>CHANNEL_MODE</strong>：硬件片选模式选择，bit[7:4]分别表示通道3到通道0，这里采用通道0设定为Master mode.因此bit[7:4]配置成1<br><strong>POST_DIVIDER</strong>:后分频，0到15表示2^n次方分频，比如0就是1分频，15就是2^15分频<br><strong>PRE_DIVIDER</strong>:前分频，0到15表示1到16分频<br>前面spi clk的时钟源为ECSPI_CLK_ROOT 60MHz，这里我们用6MHz，因此可以设置POST_DIVIDER&#x3D;0，PRE_DIVIDER&#x3D;9，表示10分频。<br><strong>CHANNEL_SELECT</strong>:通道选择，也就是硬件片选SS选择，这里选择SS0,通道0<br><strong>BURST_LENGTH</strong>：突发访问长度，这里我们用一次突发8bit, 配置成0x7</p><h4><span id="1-2-2-4-configreg">1.2.2.4 CONFIGREG</span><a href="#1-2-2-4-configreg" class="header-anchor">#</a></h4><p><strong>CONFIGREG寄存器</strong>：配置寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/9.png" alt="image"><br><strong>SCLK_PHA</strong>：时钟相位，SCLK_PHA[3:0]分别对应通道3~0，设置为0表示第一个时钟沿采集数据，设置成1表示第二个时钟沿采集数据。（同POL组成4种模式）<br><strong>SCLK_POL</strong>：时钟极性，表示时钟初始空闲时的电平，0为低电平，1为高电平。（同PHA组成4种模式）<br><strong>SS_CTL</strong>:硬件片选的wave form select,这个用不上设置成0<br><strong>SS_POL</strong>：硬件片选的极性选择，用不上设置成0<br><strong>DATA_CTL</strong>：数据线空闲时电平状态，我们设置成0表示高电平<br><strong>SCLK_CTL</strong>：时钟线空闲时电平状态，我们设置成0表示低电平（POL设置了时钟初始空闲时的电平为低电平)<br><strong>HT_LENGTH</strong>: HT Mode不用，无需配置</p><h4><span id="1-2-2-5-statreg">1.2.2.5 STATREG</span><a href="#1-2-2-5-statreg" class="header-anchor">#</a></h4><p><strong>STATREG寄存器</strong>：状态寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/10.png" alt="image"><br><strong>TE</strong>:TXFIFO empty, 为1表示TXFIFO为空，0表示TXFIFO还没空，因此往TXDATA发送数据时，需要先等待TXFIFO为空。<br><strong>RR</strong>: RXFIFO Ready,1表示有数据，0表示数据还没ready.读取RXDATA需要等RXFIFO先ready。</p><h4><span id="1-2-2-6-periodreg">1.2.2.6 PERIODREG</span><a href="#1-2-2-6-periodreg" class="header-anchor">#</a></h4><p><strong>PERIODREG寄存器</strong>：采样周期寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/11.png" alt="image"><br><strong>SAMPLE_ PERIOD</strong>:突发访问时的等待周期，表示等待多少个时钟周期后进行一下次突发访问。我们设置为0x2000。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/12.png" alt="image"><br><strong>CSRC</strong>: 等待周期的单位，0表示以SPI clk为单位, 1表示以low-frequency reference clk 32.768KHz为单位。<br><strong>CSD_CTL</strong>:硬件片选延时，表示片选后多少个时钟周期才可以进行数据传输。（这里不用，我们用软件片选)</p><h2><span id="1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</span><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(ECSPI_Type *base)</span> &#123;</span><br><span class="line"><span class="comment">/* 配置CONREG寄存器</span></span><br><span class="line"><span class="comment"> * bit0 : 1 使能ECSPI</span></span><br><span class="line"><span class="comment"> * bit3 : 1当向TXFIFO写入数据以后立即开启SPI突发。</span></span><br><span class="line"><span class="comment"> * bit[7:4] : 0001 SPI通道0主模式，根据实际情况选择，</span></span><br><span class="line"><span class="comment"> *               开发板上的ICM-20608接在SS0上，所以设置通道0为主模式</span></span><br><span class="line"><span class="comment"> * bit[19:18]:00 选中通道0(其实不需要，因为片选信号我们我们自己控制)</span></span><br><span class="line"><span class="comment"> * bit[31:20]:0x7突发长度为8个bit。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">base-&gt;CONREG = <span class="number">0</span>; <span class="comment">/* 先清除控制寄存器 */</span></span><br><span class="line">base-&gt;CONREG |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">7</span> &lt;&lt; <span class="number">20</span>); <span class="comment">/* 配置CONREG寄存器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ECSPI通道0设置,即设置CONFIGREG寄存器</span></span><br><span class="line"><span class="comment"> * bit0:0 通道0 PHA为0</span></span><br><span class="line"><span class="comment"> * bit4:0 通道0 SCLK高电平有效</span></span><br><span class="line"><span class="comment"> * bit8: 0 通道0片选信号 当SMC为1的时候此位无效</span></span><br><span class="line"><span class="comment"> * bit12：0 通道0 POL为0</span></span><br><span class="line"><span class="comment"> * bit16：0 通道0 数据线空闲时高电平</span></span><br><span class="line"><span class="comment"> * bit20:0 通道0 时钟线空闲时低电平</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">base-&gt;CONFIGREG = <span class="number">0</span>; <span class="comment">/* 设置通道寄存器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * ECSPI通道0设置，设置采样周期</span></span><br><span class="line"><span class="comment"> * bit[14:0] :0X2000  采样等待周期，比如当SPI时钟为10MHz的时候</span></span><br><span class="line"><span class="comment"> *      0X2000就等于1/10000 * 0X2000 = 0.8192ms，也就是连续</span></span><br><span class="line"><span class="comment"> *          读取数据的时候每次之间间隔0.8ms</span></span><br><span class="line"><span class="comment"> * bit15 :  0  采样时钟源为SPI CLK</span></span><br><span class="line"><span class="comment"> * bit[21:16]:  0  片选延时，可设置为0~63</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">base-&gt;PERIODREG = <span class="number">0X2000</span>;<span class="comment">/* 设置采样周期寄存器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ECSPI的SPI时钟配置，SPI的时钟源来源于pll3_sw_clk/8=480/8=60MHz</span></span><br><span class="line"><span class="comment"> * 通过设置CONREG寄存器的PER_DIVIDER(bit[11:8])和POST_DIVEDER(bit[15:12])来</span></span><br><span class="line"><span class="comment"> * 对SPI时钟源分频，获取到我们想要的SPI时钟：</span></span><br><span class="line"><span class="comment"> * SPI CLK = (SourceCLK / PER_DIVIDER) / (2^POST_DIVEDER)</span></span><br><span class="line"><span class="comment"> * 比如我们现在要设置SPI时钟为6MHz，那么PER_DIVEIDER和POST_DEIVIDER设置如下：</span></span><br><span class="line"><span class="comment"> * PER_DIVIDER = 0X9。</span></span><br><span class="line"><span class="comment"> * POST_DIVIDER = 0X0。</span></span><br><span class="line"><span class="comment"> * SPI CLK = 60000000/(0X9 + 1) = 60000000=6MHz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">base-&gt;CONREG &amp;= ~((<span class="number">0XF</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">0XF</span> &lt;&lt; <span class="number">8</span>));<span class="comment">/* 清除PER_DIVDER和POST_DIVEDER以前的设置 */</span></span><br><span class="line">base-&gt;CONREG |= (<span class="number">0X9</span> &lt;&lt; <span class="number">12</span>);<span class="comment">/* 设置SPI CLK = 6MHz */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: SPI通道0发送/接收一个字节的数据</span></span><br><span class="line"><span class="comment"> * @param - base: 要使用的SPI</span></span><br><span class="line"><span class="comment"> * @param - txdata: 要发送的数据</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">spich0_readwrite_byte</span><span class="params">(ECSPI_Type *base, <span class="type">unsigned</span> <span class="type">char</span> txdata)</span> &#123; </span><br><span class="line"><span class="type">uint32_t</span>  spirxdata = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span>  spitxdata = txdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择通道0 */</span></span><br><span class="line">base-&gt;CONREG &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line">base-&gt;CONREG |= (<span class="number">0</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待发送FIFO为空 */</span></span><br><span class="line">base-&gt;TXDATA = spitxdata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待接收FIFO有数据 */</span></span><br><span class="line">spirxdata = base-&gt;RXDATA;</span><br><span class="line"><span class="keyword">return</span> spirxdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="2-spi-ying-yong">2 SPI 应用</span><a href="#2-spi-ying-yong" class="header-anchor">#</a></h1><h2><span id="2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</span><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g" class="header-anchor">#</a></h2><h3><span id="2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</span><a href="#2-1-1-icm-20608-g-gai-shu" class="header-anchor">#</a></h3><p><code>The ICM-20608-G is a 6-axis MotionTracking device that combines a 3-axis gyroscope, and a 3-axis accelerometer in a small 3x3x0.75mm (16-pin LGA) package. The gyroscope has a programmable full-scale range of ±250, ±500, ±1000, and ±2000 degrees/sec. The accelerometer has a user programmable accelerometer full-scale range of ±2g, ±4g, ±8g, and ±16g. Other industry-leading features include on-chip 16-bit ADCs, programmable digital filters, an embedded temperature sensor, and programmable interrupts. The device features I2 C and SPI serial interfaces, a VDD operating range of 1.71 to 3.45V, and a separate digital IO supply, VDDIO from 1.71V to 3.45V. Communication with all registers of the device is performed using either I2 C at 400kHz or SPI at 8MHz.</code><br>1.包含3轴陀螺仪数据和3轴加速度数据。<br>2.陀螺仪和加速度量程可设定，陀螺仪量程可设定位+-250，+-500，+-1000， +-2000角度每秒。加速度同理也可设定量程。<br>3.精度为16bit ADC转换。<br>4.使用I2C&#x2F;SPI接口通信，I2C速率高达400KHz, SPI高达8MHz。</p><h3><span id="2-1-2-ying-yong-chang-jing">2.1.2 应用场景</span><a href="#2-1-2-ying-yong-chang-jing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/13.png" alt="image"></p><h3><span id="2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</span><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/14.png" alt="image"></p><h3><span id="2-1-4-dian-qi-te-xing">2.1.4 电器特性</span><a href="#2-1-4-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/15.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/16.png" alt="image"><br>可以看到FS_SEL，AFS_SEL用来选择陀螺仪和加速度计的量程。举个例子，当角速度量程为+-250时，那么ADC的数据为多少表示为1度呢？已知ADC精度16bit, 数据范围[0,65535], 假如ADC的数据为x, 那么x&#x2F;65636 &#x3D; 1&#x2F;500,算出x&#x3D; 131.272x,对应表格数据中的131。加速度的换算公式也是同理， 当AFS_SEL&#x3D;0时，x&#x2F;65536 &#x3D; 1&#x2F;4， x&#x3D;16384。</p><h3><span id="2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</span><a href="#2-1-5-jiao-liu-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/17.png" alt="image"><br>当用i2c通信，AD0引脚决定i2c从地址是0x68还是0x69。可以看到power-on reset上电时序，需要Valid power-on RESET时间最少0.01ms, 从启动到寄存器读写等11ms。</p><h3><span id="2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</span><a href="#2-1-6-gong-zuo-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/18.png" alt="image"></p><h3><span id="2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</span><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/19.png" alt="image"><br>数据上升沿锁存，下降沿数据发生改变。最大高达8MHz时钟，一次读写需要16个或者更多时钟周期，第一个字节传输寄存器地址，第二个字节传输数据。首字节的首位表示是读还是写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CSN(n)    (n ? gpio_pinwrite(GPIO1, 20, 1) : gpio_pinwrite(GPIO1, 20, 0))   <span class="comment">/* SPI片选信号 */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description  : 写ICM20608指定寄存器</span></span><br><span class="line"><span class="comment"> * @param - reg  : 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @param - value: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_write_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> value)</span> &#123;</span><br><span class="line"><span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment"> * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment"> * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg &amp;= ~<span class="number">0X80</span>;</span><br><span class="line"></span><br><span class="line">ICM20608_CSN(<span class="number">0</span>);<span class="comment">/* 使能SPI传输*/</span></span><br><span class="line">spich0_readwrite_byte(ECSPI3, reg); <span class="comment">/* 发送寄存器地址*/</span> </span><br><span class="line">spich0_readwrite_byte(ECSPI3, value);<span class="comment">/* 发送要写入的值*/</span></span><br><span class="line">ICM20608_CSN(<span class="number">1</span>);<span class="comment">/* 禁止SPI传输*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 读取ICM20608寄存器值</span></span><br><span class="line"><span class="comment"> * @param - reg: 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @return : 读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> reg_val;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment"> * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment"> * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg |= <span class="number">0x80</span>; </span><br><span class="line"></span><br><span class="line">ICM20608_CSN(<span class="number">0</span>);               <span class="comment">/* 使能SPI传输 */</span></span><br><span class="line">spich0_readwrite_byte(ECSPI3, reg);     <span class="comment">/* 发送寄存器地址  */</span> </span><br><span class="line">reg_val = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);<span class="comment">/* 读取寄存器的值 */</span></span><br><span class="line">ICM20608_CSN(<span class="number">1</span>);                <span class="comment">/* 禁止SPI传输 */</span></span><br><span class="line"><span class="keyword">return</span>(reg_val);                <span class="comment">/* 返回读取到的寄存器值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</span><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/20.png" alt="image"><br>ICM-20608-G寄存器的地址和数据都是单字节。</p><h3><span id="2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</span><a href="#2-2-1-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>控制配置寄存器0x1a,0x1b,0x1c,0x1d，设置量程等配置。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/21.png" alt="image"><br>0x19设置分频，不分频，配成0<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/22.png" alt="image"><br>0x1a设置陀螺仪低通滤波带宽BW&#x3D;20Hz，配成0x4.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/23.png" alt="image"><br>0x1b设置gyro量程，配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/24.png" alt="image"><br>0x1c设置加速度计的量程，也配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/25.png" alt="image"><br>0x1d设置加速度计低通滤波BW&#x3D;21.2Hz<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/26.png" alt="image"><br> 0x1e设置low power，配成0，关闭低功耗.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/27.png" alt="image"><br>0x23设置fifo功能，这里配置0x0,禁用fifo.</p><p>设定量程，配置相关参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SMPLRT_DIV0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_CONFIG0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_CONFIG0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_CONFIG0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_CONFIG20x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_LP_MODE_CFG0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FIFO_EN0x23</span></span><br><span class="line">icm20608_write_reg(ICM20_SMPLRT_DIV, <span class="number">0x00</span>); <span class="comment">/* 输出速率是内部采样率*/</span></span><br><span class="line">icm20608_write_reg(ICM20_GYRO_CONFIG, <span class="number">0x18</span>); <span class="comment">/* 陀螺仪±2000dps量程 */</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); <span class="comment">/* 加速度计±16G量程 */</span></span><br><span class="line">icm20608_write_reg(ICM20_CONFIG, <span class="number">0x04</span>); <span class="comment">/* 陀螺仪低通滤波BW=20Hz */</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); <span class="comment">/* 加速度计低通滤波BW=21.2Hz */</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_2, <span class="number">0x00</span>); <span class="comment">/* 打开加速度计和陀螺仪所有轴 */</span></span><br><span class="line">icm20608_write_reg(ICM20_LP_MODE_CFG, <span class="number">0x00</span>); <span class="comment">/* 关闭低功耗 */</span></span><br><span class="line">icm20608_write_reg(ICM20_FIFO_EN, <span class="number">0x00</span>);<span class="comment">/* 关闭FIFO*/</span></span><br></pre></td></tr></table></figure><h3><span id="2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</span><a href="#2-2-2-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p>数据寄存器0x3b<del>0x48表示加速度和陀螺仪数据，可以看到该传感器的寄存器地址都是单字节，ADC精度16bit,因此需要2个寄存器来表示一个轴的坐标数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/28.png" alt="image"><br>0x3b-0x40表示加速度计3轴数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/29.png" alt="image"><br>0x42 温度数据<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/30.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/31.png" alt="image"><br>0x43</del>0x48陀螺仪3轴数据。</p><h3><span id="2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</span><a href="#2-2-3-who-am-i-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/32.png" alt="image"><br>寄存器表示设备ID,默认0xAF.</p><h3><span id="2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</span><a href="#2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi" class="header-anchor">#</a></h3><p>电源管理模式寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/33.png" alt="image"><br>可以看到bit6默认是一个sleep mode, bit7是复位信号，复位后，默认bit6会变成1，进入睡眠模式。Bit4 陀螺仪待机，bit3关闭温度传感器等等都不要开启，设置成0，bit[2:0]时钟选择自动。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/34.png" alt="image"><br>可以看到设置成0，6轴数据全使能</p><p>复位初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_PWR_MGMT_10x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_WHO_AM_I 0x75</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x80</span>);<span class="comment">/* 复位，复位后为0x40,睡眠模式 */</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x01</span>);<span class="comment">/* 关闭睡眠，自动选择时钟 */</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">regvalue = icm20608_read_reg(ICM20_WHO_AM_I);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;icm20608 id = %#X\r\n&quot;</span>, regvalue);</span><br></pre></td></tr></table></figure><h1><span id="2-3-dai-ma-jie-xi">2.3 代码解析</span><a href="#2-3-dai-ma-jie-xi" class="header-anchor">#</a></h1><p>icm20608.h：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ICM20608寄存器 </span></span><br><span class="line"><span class="comment"> *复位后所有寄存器地址都为0，除了</span></span><br><span class="line"><span class="comment"> *Register 107(0X6B) Power Management 1 = 0x40</span></span><br><span class="line"><span class="comment"> *Register 117(0X75) WHO_AM_I = 0xAF或0xAE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_X_GYRO0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_Y_GYRO0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_Z_GYRO0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_X_ACCEL0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_Y_ACCEL0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SELF_TEST_Z_ACCEL0x0F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_XG_OFFS_USRH0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_XG_OFFS_USRL0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_YG_OFFS_USRH0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_YG_OFFS_USRL0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ZG_OFFS_USRH0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ZG_OFFS_USRL0x18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SMPLRT_DIV0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_CONFIG0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_CONFIG0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_CONFIG0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_CONFIG20x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_LP_MODE_CFG0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_WOM_THR0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FIFO_EN0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FSYNC_INT0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_INT_PIN_CFG0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_INT_ENABLE0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_INT_STATUS0x3A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_XOUT_H0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_XOUT_L0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_YOUT_H0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_YOUT_L0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_ZOUT_H0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_ZOUT_L0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_TEMP_OUT_H0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_TEMP_OUT_L0x42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_XOUT_H0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_XOUT_L0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_YOUT_H0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_YOUT_L0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_ZOUT_H0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_GYRO_ZOUT_L0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_SIGNAL_PATH_RESET0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ACCEL_INTEL_CTRL 0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_USER_CTRL0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_PWR_MGMT_10x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_PWR_MGMT_20x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FIFO_COUNTH0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FIFO_COUNTL0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_FIFO_R_W0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_WHO_AM_I 0x75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_XA_OFFSET_H0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_XA_OFFSET_L0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_YA_OFFSET_H0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_YA_OFFSET_L0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ZA_OFFSET_H0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>ICM20_ZA_OFFSET_L 0x7E</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ICM20608结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> &#123;</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_x_adc;<span class="comment">/* 陀螺仪X轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_y_adc;<span class="comment">/* 陀螺仪Y轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_z_adc;<span class="comment">/* 陀螺仪Z轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_x_adc;<span class="comment">/* 加速度计X轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_y_adc;<span class="comment">/* 加速度计Y轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_z_adc;<span class="comment">/* 加速度计Z轴原始值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> temp_adc;<span class="comment">/* 温度原始值 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面是计算得到的实际值，扩大100倍 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_x_act;<span class="comment">/* 陀螺仪X轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_y_act;<span class="comment">/* 陀螺仪Y轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> gyro_z_act;<span class="comment">/* 陀螺仪Z轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_x_act;<span class="comment">/* 加速度计X轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_y_act;<span class="comment">/* 加速度计Y轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> accel_z_act;<span class="comment">/* 加速度计Z轴实际值 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> temp_act;<span class="comment">/* 温度实际值 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> <span class="title">icm20608_dev</span>;</span><span class="comment">/* icm20608设备 */</span></span><br></pre></td></tr></table></figure><p><code>icm20608.h</code>定义了该模块的6轴数据寄存器地址和值。<br> 连续顺序读写模块：前一个字节得写入寄存器地址，然后每次突发读取1字节数据，注意：这里不用每次都发送寄存器地址，顺序访问时，地址自动增长，即可顺序依次访问寄存器。如：向<code>0x00~0x05</code>地址依次发送<code>6 byte</code>数据，<code>icm20608_read_len(0x00, buf, 6)</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">icm20608_read_len</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;  </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址，只有低7位有效,</span></span><br><span class="line"><span class="comment"> * 寄存器地址最高位是读/写标志位读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reg |= <span class="number">0x80</span>; </span><br><span class="line">ICM20608_CSN(<span class="number">0</span>);               <span class="comment">/* 使能SPI传输 */</span></span><br><span class="line">spich0_readwrite_byte(ECSPI3, reg);<span class="comment">/* 发送寄存器地址  */</span>      </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)<span class="comment">/* 顺序读取寄存器的值 */</span></span><br><span class="line">buf[i] = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);</span><br><span class="line">ICM20608_CSN(<span class="number">1</span>);                <span class="comment">/* 禁止SPI传输 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>icm20608_gyro_scaleget()</code>和<code>icm20608_accel_scaleget()</code>是获取陀螺仪和加速度计的最小单位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">icm20608_gyro_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line"><span class="type">float</span> gyroscale;</span><br><span class="line">data = (icm20608_read_reg(ICM20_GYRO_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line"><span class="keyword">switch</span>(data) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">gyroscale = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">gyroscale = <span class="number">65.5</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">gyroscale = <span class="number">32.8</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">gyroscale = <span class="number">16.4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gyroscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 获取加速度计的分辨率</span></span><br><span class="line"><span class="comment"> * @param: 无</span></span><br><span class="line"><span class="comment"> * @return: 获取到的分辨率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">icm20608_accel_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> accelscale;</span><br><span class="line">data = (icm20608_read_reg(ICM20_ACCEL_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line"><span class="keyword">switch</span>(data) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">accelscale = <span class="number">16384</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">accelscale = <span class="number">8192</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">accelscale = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">accelscale = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> accelscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 读取ICM20608的加速度、陀螺仪和温度原始值</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_getdata</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">float</span> gyroscale;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> accescale;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">icm20608_read_len(ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">gyroscale = icm20608_gyro_scaleget();</span><br><span class="line">accescale = icm20608_accel_scaleget();</span><br><span class="line"></span><br><span class="line">icm20608_dev.accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]);</span><br><span class="line">icm20608_dev.accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]);</span><br><span class="line">icm20608_dev.accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]);</span><br><span class="line">icm20608_dev.temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]);</span><br><span class="line">icm20608_dev.gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]);</span><br><span class="line">icm20608_dev.gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">icm20608_dev.gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line"><span class="comment">/* 计算实际值 */</span></span><br><span class="line">icm20608_dev.gyro_x_act = ((<span class="type">float</span>)(icm20608_dev.gyro_x_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">icm20608_dev.gyro_y_act = ((<span class="type">float</span>)(icm20608_dev.gyro_y_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">icm20608_dev.gyro_z_act = ((<span class="type">float</span>)(icm20608_dev.gyro_z_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">icm20608_dev.accel_x_act = ((<span class="type">float</span>)(icm20608_dev.accel_x_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">icm20608_dev.accel_y_act = ((<span class="type">float</span>)(icm20608_dev.accel_y_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">icm20608_dev.accel_z_act = ((<span class="type">float</span>)(icm20608_dev.accel_z_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">icm20608_dev.temp_act = (((<span class="type">float</span>)(icm20608_dev.temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>) * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面设置的陀螺仪和加速度计量程都是拉满的设置的<code>0x18</code>，因此<code>gyroscale</code>读出来就是对应<code>16.4</code>（最小单位），<code>accescale</code>读出来就是对应<code>2048</code>（最小单位）<br>然后读出<code>14 byte</code>数据，组装成short类型数据，16位ADC, 一轴数据刚好16位数据。最后转成人眼直观的实际的陀螺仪和加速度计数据，放大了100倍，放大一百倍目的是为了能够将小数的部分也能记录下来。<br>以陀螺仪为例：量程位<code>+-2000</code>时，换算出16.4为<code>1°</code>。同理以加速度计为例：量程为<code>+-16</code>是，换算出<code>2048</code>为1g。</p><p>可以看到用到了浮点运算，那么IMX6ULL属于armv7,支持硬件浮点运算：执行浮点运算前调用<code>imx6ul_hardfpu_enable()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 使能I.MX6U的硬件NEON和FPU</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">imx6ul_hardfpu_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">uint32_t</span> cpacr;</span><br><span class="line"><span class="type">uint32_t</span> fpexc;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使能NEON和FPU */</span></span><br><span class="line">cpacr = __get_CPACR();</span><br><span class="line">cpacr = (cpacr &amp; ~(CPACR_ASEDIS_Msk | CPACR_D32DIS_Msk))</span><br><span class="line">   |  (<span class="number">3UL</span> &lt;&lt; CPACR_cp10_Pos) | (<span class="number">3UL</span> &lt;&lt; CPACR_cp11_Pos);</span><br><span class="line">__set_CPACR(cpacr);</span><br><span class="line">fpexc = __get_FPEXC();</span><br><span class="line">fpexc |= <span class="number">0x40000000</span>UL;</span><br><span class="line">__set_FPEXC(fpexc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开<code>Cortex-A7 MPCore Technical Reference Manual</code>的<code>4.3.34 Non-Secure Access Control Register</code>介绍：开启硬件NEON和FPU<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/35.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/36.png" alt="image"><br>打开<code>ARM®Architecture Reference Manual ARMv7-A and ARMv7-R edition</code>介绍FPEXC寄存器， bit30置1，使能浮点运算<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/37.png" alt="image"></p><p>打开IM6ULL 参考手册：可见IMX6U支持浮点单元：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/38.png" alt="image"><br>编译选项开启硬件浮点编译：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">`<span class="variable">$(CC)</span> -Wall **-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard -Wa,-mimplicit-it=thumb** -nostdlib -fno-builtin -c -O2  <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span>`</span><br></pre></td></tr></table></figure><h3><span id="2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</span><a href="#2-3-1-ce-shi-xiao-guo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 指定的位置显示小数数据,比如5123，显示为51.23</span></span><br><span class="line"><span class="comment"> * @param - x: X轴位置</span></span><br><span class="line"><span class="comment"> * @param - y : Y轴位置</span></span><br><span class="line"><span class="comment"> * @param - size: 字体大小</span></span><br><span class="line"><span class="comment"> * @param - num : 要显示的数据，实际小数扩大100倍，</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decimals_display</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x, <span class="type">unsigned</span> <span class="type">short</span> y, <span class="type">unsigned</span> <span class="type">char</span> size, <span class="type">signed</span> <span class="type">int</span> num)</span> &#123;</span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> integ; <span class="comment">/* 整数部分 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> fract;<span class="comment">/* 小数部分 */</span></span><br><span class="line"><span class="type">signed</span> <span class="type">int</span> uncomptemp = num; </span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">uncomptemp = -uncomptemp;</span><br><span class="line">integ = uncomptemp / <span class="number">100</span>;</span><br><span class="line">fract = uncomptemp % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;-%d.%d&quot;</span>, integ, fract);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d.%d&quot;</span>, integ, fract);</span><br><span class="line">lcd_fill(x, y, x + <span class="number">60</span>, y + size, tftlcd_dev.backcolor);</span><br><span class="line">lcd_show_string(x, y, <span class="number">60</span>, size, size, buf); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/39.png" alt="image"><br>静止时，有一个z方向的加速度2048，也就是1g,刚好时重力加速度。静止时，陀螺仪几乎没有角速度，因此3轴数据都几乎为0°。</p><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/40.png" alt="image"><br>左右晃动时，陀螺仪数据明显增加。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-spi-jie-shao&quot;&gt;1 SPI介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-imx6ull-spi-kong-zhi-qi-jie-shao&quot;&gt;1.1 </summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="通信协议" scheme="http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>imx6ull裸机-定时器</title>
    <link href="http://example.com/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>http://example.com/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/</id>
    <published>2024-05-02T07:02:23.000Z</published>
    <updated>2024-05-02T09:08:10.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-rtc-ding-shi-qi">1 RTC定时器</a><ul><li><a href="#1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</a></li><li><a href="#1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</a></li><li><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</a></li><li><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</a></li></ul></li><li><a href="#2-pwm-ding-shi-qi">2 PWM定时器</a><ul><li><a href="#2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</a></li><li><a href="#2-2-pwm-kong-zhi-qi">2.2 PWM控制器</a><ul><li><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</a></li><li><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</a></li><li><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</a></li><li><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</a></li><li><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</a></li></ul></li><li><a href="#2-3-ce-shi">2.3 测试</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-rtc-ding-shi-qi">1 RTC定时器</span><a href="#1-rtc-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</span><a href="#1-1-rtc-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>RTC定时器被叫做实时时钟（real time clock）。 CPU内部有很多定时器，像看门狗WDT，PWM定时器，高精度定时器Timer等等, 只在“启动”即“通电时”运行，断电时停止。当然，如果时钟不能连续跟踪时间，则必须手动设置。那么当关机后就没办法自动计数统计时间了。<br>定时器的本质就是计数器，有向上计数，也有向下计数。RTC有一个与主机单独分离的电源，如纽扣电池（备用电池），即使主机电源关闭，它也保持计数定时功能。这也是为什么我们手机关机后时间还能保持准确。再比如以前的老诺基亚手机，拆掉电池就时间不准了，因为rtc电源被切断了，无法在计数，RTC定时器的计数器会被清0，需要手动设置当前时间。<br>RTC一般都是用纽扣电池给外部晶振和电路供电。<br>!<img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p><h2><span id="1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</span><a href="#1-2-rtc-ding-shi-qi-yuan-li" class="header-anchor">#</a></h2><p>以IMX6U芯片的RTC定时器为例，I.MX6U 内部也有 个 RTC 模块，但是不叫作“RTC”，而是叫做“SNVS”。<br>RTC模块结构图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"><br>SNVS 分为两个子模块：SNVS_HP 和 SNVS_LP，也就是高功耗域(SNVS_HP)和低功耗域(SNVS_LP)，这两个域的电源来源如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SNVS_LP：专用的 always-powered-on 电源域，系统主电源和备用电源都可以为其供电。</span><br><span class="line">SNVS_HP：系统(芯片)电源。 </span><br></pre></td></tr></table></figure><p>系统主电源断电以后 SNVS_HP 也会断电，但是在备用电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP 是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着, 也就是low Power Domain是不受系统电源影响。<br>上图各个序号含义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> VDD_HIGH_IN 是系统(芯片)主电源，这个电源会同时供给给 SNVS_HP 和 SNVS_LP。</span><br><span class="line"><span class="number">2.</span> VDD_SNVS_IN 是纽扣电池供电的电源，这个电源只会供给给 SNVS_LP，保证在系统主电源 VDD_HIGH_IN 掉电以后 SNVS_LP 会继续运行。</span><br><span class="line"><span class="number">3.</span> SNVS_HP 部分。</span><br><span class="line"><span class="number">4.</span> SNVS_LP 部分，此部分有个 SRTC，这个就是要使用的 RTC。</span><br></pre></td></tr></table></figure><p>SRTC 需要外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p><h2><span id="1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</span><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SNVS_SRTCMR[<span class="number">14</span>:<span class="number">0</span>]代表SRTC计数器的高<span class="number">15</span>位</span><br><span class="line">SNVS_SRTCLR[<span class="number">31</span>:<span class="number">15</span>]代表SRTC计数器的低<span class="number">17</span>位</span><br><span class="line">注意：是以 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日<span class="number">0</span>点<span class="number">0</span>分<span class="number">0</span>秒为起点，加上经过的总秒数即可得到现在的时间点。 </span><br><span class="line">SNVS_HPCOMR[<span class="number">31</span>], NPSWA_EN位，非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 <span class="number">1</span>。</span><br><span class="line">SNVS_LPCR[<span class="number">0</span>], SRTC_ENV位，使能 STC 计数器。</span><br></pre></td></tr></table></figure><h2><span id="1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</span><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi" class="header-anchor">#</a></h2><p>NXP 官方 SDK 包是针对 I.MX6ULL 编写的，因此文件 MCIMX6Y2.h中的结构体 SNVS_Type 里面的寄存器是不全的，我们需要在其中加入本章实验所需要的寄存器，修改 SNVS_Type 为如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup SNVS_Peripheral_Access_Layer SNVS Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** SNVS - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPLR;                              <span class="comment">/**&lt; SNVS_HP Lock register, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCOMR;                            <span class="comment">/**&lt; SNVS_HP Command register, offset: 0x4 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSICR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVCR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACIVR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTAMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTALR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPMKCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSVCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTGFCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTDCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTAR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCLR;</span><br><span class="line">&#125;SNVS_Type;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相关宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_DAY (86400) <span class="comment">/* 一天86400秒 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_HOUR (3600)<span class="comment">/* 一个小时3600秒 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_MINUTE (60)<span class="comment">/* 一分钟60秒   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_A_YEAR (365)<span class="comment">/* 一年365天 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_START (1970)<span class="comment">/* 开始年份1970年 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_END (2099)<span class="comment">/* 结束年份2099年 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间日期结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;  <span class="comment">/* 范围为:1970 ~ 2099 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> month;  <span class="comment">/* 范围为:1 ~ 12*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> day;    <span class="comment">/* 范围为:1 ~ 31 (不同的月，天数不同).*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hour;   <span class="comment">/* 范围为:0 ~ 23 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> minute; <span class="comment">/* 范围为:0 ~ 59*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> second; <span class="comment">/* 范围为:0 ~ 59*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置HPCOMR寄存器</span></span><br><span class="line"><span class="comment">     * bit[31] 1 : 允许访问SNVS寄存器，一定要置1</span></span><br><span class="line"><span class="comment">     * bit[8]  1 : 此位置1，需要签署NDA协议才能看到此位的详细说明，</span></span><br><span class="line"><span class="comment">     *             这里不置1也没问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SNVS-&gt;HPCOMR |= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> <span class="title">rtcdate</span>;</span></span><br><span class="line">rtcdate.year = <span class="number">2018U</span>;</span><br><span class="line">    rtcdate.month = <span class="number">12U</span>;</span><br><span class="line">    rtcdate.day = <span class="number">13U</span>;</span><br><span class="line">    rtcdate.hour = <span class="number">14U</span>;</span><br><span class="line">    rtcdate.minute = <span class="number">52</span>;</span><br><span class="line">    rtcdate.second = <span class="number">0</span>;</span><br><span class="line">rtc_setDatetime(&amp;rtcdate); <span class="comment">//初始化时间和日期</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">rtc_enable();<span class="comment">//使能RTC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LPCR寄存器bit0置1，使能RTC</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">SNVS-&gt;LPCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>));<span class="comment">//等待使能完成</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * LPCR寄存器bit0置0，关闭RTC</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">SNVS-&gt;LPCR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>);<span class="comment">//等待关闭完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 判断指定年份是否为闰年，闰年条件如下:</span></span><br><span class="line"><span class="comment"> * @param - year: 要判断的年份</span></span><br><span class="line"><span class="comment"> * @return : 1 是闰年，0 不是闰年</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">rtc_isleapyear</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> year)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> value=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">value = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 将时间转换为秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要转换日期和时间。</span></span><br><span class="line"><span class="comment"> * @return : 转换后的秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> days = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> monthdays[] = &#123;<span class="number">0U</span>, <span class="number">0U</span>, <span class="number">31U</span>, <span class="number">59U</span>, <span class="number">90U</span>, <span class="number">120U</span>, <span class="number">151U</span>, <span class="number">181U</span>, <span class="number">212U</span>, <span class="number">243U</span>, <span class="number">273U</span>, <span class="number">304U</span>, <span class="number">334U</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1970</span>; i &lt; datetime-&gt;year; i++) &#123;</span><br><span class="line">days += DAYS_IN_A_YEAR; <span class="comment">/* 平年，每年365天 */</span></span><br><span class="line"><span class="keyword">if</span>(rtc_isleapyear(i)) days += <span class="number">1</span>;<span class="comment">/* 闰年多加一天 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">days += monthdays[datetime-&gt;month];</span><br><span class="line"><span class="keyword">if</span>(rtc_isleapyear(i) &amp;&amp; (datetime-&gt;month &gt;= <span class="number">3</span>)) days += <span class="number">1</span>;<span class="comment">/* 闰年，并且当前月份大于等于3月的话加一天 */</span></span><br><span class="line"></span><br><span class="line">days += datetime-&gt;day - <span class="number">1</span>;</span><br><span class="line">seconds = days * SECONDS_IN_A_DAY + </span><br><span class="line">datetime-&gt;hour * SECONDS_IN_A_HOUR +</span><br><span class="line">datetime-&gt;minute * SECONDS_IN_A_MINUTE +</span><br><span class="line">datetime-&gt;second;</span><br><span class="line"><span class="keyword">return</span> seconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 设置时间和日期</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要设置的日期和时间</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tmp = SNVS-&gt;LPCR; </span><br><span class="line">rtc_disable();<span class="comment">/* 设置寄存器HPRTCMR和HPRTCLR的时候一定要先关闭RTC */</span></span><br><span class="line"><span class="comment">/* 先将时间转换为秒 */</span></span><br><span class="line">seconds = rtc_coverdate_to_seconds(datetime);</span><br><span class="line">SNVS-&gt;LPSRTCMR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &gt;&gt; <span class="number">17</span>); <span class="comment">/* 设置高16位 */</span></span><br><span class="line">SNVS-&gt;LPSRTCLR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &lt;&lt; <span class="number">15</span>); <span class="comment">/* 设置地16位 */</span></span><br><span class="line"><span class="comment">/* 如果此前RTC是打开的在设置完RTC时间以后需要重新打开RTC */</span></span><br><span class="line"><span class="keyword">if</span> (tmp &amp; <span class="number">0x1</span>)</span><br><span class="line">rtc_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 将秒数转换为时间</span></span><br><span class="line"><span class="comment"> * @param - seconds: 要转换的秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 转换后的日期和时间</span></span><br><span class="line"><span class="comment"> * @return : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_convertseconds_to_datetime</span><span class="params">(u64 seconds, <span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">    u64 x;</span><br><span class="line">    u64  secondsRemaining, days;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> daysInYear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个月的天数       */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> daysPerMonth[] = &#123;<span class="number">0U</span>, <span class="number">31U</span>, <span class="number">28U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>&#125;;</span><br><span class="line">    secondsRemaining = seconds; <span class="comment">/* 剩余秒数初始化 */</span></span><br><span class="line">    days = secondsRemaining / SECONDS_IN_A_DAY + <span class="number">1</span>; <span class="comment">/* 根据秒数计算天数,加1是当前天数 */</span></span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY; <span class="comment">/*计算天数以后剩余的秒数 */</span></span><br><span class="line"><span class="comment">/* 计算时、分、秒 */</span></span><br><span class="line">    datetime-&gt;hour = secondsRemaining / SECONDS_IN_A_HOUR;</span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;</span><br><span class="line">    datetime-&gt;minute = secondsRemaining / <span class="number">60</span>;</span><br><span class="line">    datetime-&gt;second = secondsRemaining % SECONDS_IN_A_MINUTE;</span><br><span class="line">    <span class="comment">/* 计算年 */</span></span><br><span class="line">    daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">    datetime-&gt;year = YEAR_RANGE_START;</span><br><span class="line">    <span class="keyword">while</span>(days &gt; daysInYear) &#123;</span><br><span class="line">        <span class="comment">/* 根据天数计算年 */</span></span><br><span class="line">        days -= daysInYear;</span><br><span class="line">        datetime-&gt;year++;</span><br><span class="line">        <span class="comment">/* 处理闰年 */</span></span><br><span class="line">        <span class="keyword">if</span> (!rtc_isleapyear(datetime-&gt;year))</span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">/*闰年，天数加一 */</span></span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*根据剩余的天数计算月份 */</span></span><br><span class="line">    <span class="keyword">if</span>(rtc_isleapyear(datetime-&gt;year)) <span class="comment">/* 如果是闰年的话2月加一天 */</span></span><br><span class="line">        daysPerMonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= <span class="number">12</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (days &lt;= daysPerMonth[x]) &#123;</span><br><span class="line">            datetime-&gt;month = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            days -= daysPerMonth[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    datetime-&gt;day = days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 获取RTC当前秒数</span></span><br><span class="line"><span class="comment"> * @param : 无</span></span><br><span class="line"><span class="comment"> * @return : 当前秒数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">seconds = (SNVS-&gt;LPSRTCMR &lt;&lt; <span class="number">17</span>) | (SNVS-&gt;LPSRTCLR &gt;&gt; <span class="number">15</span>);</span><br><span class="line"><span class="keyword">return</span> seconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description: 获取当前时间</span></span><br><span class="line"><span class="comment"> * @param - datetime: 获取到的时间，日期等参数</span></span><br><span class="line"><span class="comment"> * @return : 无 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line"><span class="comment">//unsigned int seconds = 0;</span></span><br><span class="line">u64 seconds;</span><br><span class="line">seconds = rtc_getseconds();</span><br><span class="line">rtc_convertseconds_to_datetime(seconds, datetime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到RTC定时器是以秒为计时单位的，每过1s SRTC计数器的值加1。<br>首先调用<code>rtc_init</code>初始化并启动，然后调用<code>rtc_setdatetime</code>设定当前日期时间，调用<code>rtc_getdatetime</code>获取当前日期时间，期间会利用<code>rtc_convertseconds_to_datetime</code>把总秒数转换成当前的日期和时间。</p><h1><span id="2-pwm-ding-shi-qi">2 PWM定时器</span><a href="#2-pwm-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</span><a href="#2-1-pwm-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>imx6ull一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO。一路框图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①、此部分是一个选择器，用于选择 PWM 信号的时钟源，一共有三种时钟源：ipg_clk,pg_clk_highfreq 和 ipg_clk_32k。</span><br><span class="line">②、这是一个 <span class="number">12</span> 位的分频器，可以对①中选择的时钟源进行分频。</span><br><span class="line">③、这是 PWM 的 <span class="number">16</span> 位计数器寄存器，保存着 PWM 的计数值。</span><br><span class="line">④、这是 PWM 的 <span class="number">16</span> 位周期寄存器，此寄存器用来控制 PWM 的频率。</span><br><span class="line">⑤、这是 PWM 的 <span class="number">16</span> 位采样寄存器，此寄存器用来控制 PWM 的占空比。</span><br><span class="line">⑥、此部分是 PWM 的中断信号，PWM 是提供中断功能的，如果使能了相应的中断的话就会产生中断。</span><br><span class="line">⑦、此部分是 PWM 对应的输出 IO，产生的 PWM 信号就会从对应的 IO 中输出。</span><br></pre></td></tr></table></figure><h2><span id="2-2-pwm-kong-zhi-qi">2.2 PWM控制器</span><a href="#2-2-pwm-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</span><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi" class="header-anchor">#</a></h3><p>PWM 的 16 位计数器是个上计数器，此计数器会从 0X0000 开始计数，直到计数值等于寄存器PWMx_PWMPR(x&#x3D;1~8)+ 1，然后计数器就会重新从0X0000 开始计数，如此往复。PWMx_PWMPR设置频率。PWM周期公式如下：<br>    PWM_FRE &#x3D; PWM_CLK &#x2F; (PERIOD + 2)<br>    也就是PWMO(Hz) &#x3D; PCLK(Hz) &#x2F; (PERIOD + 2)<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p><p>比如当前PWM_CLK&#x3D;1MHz, 要产生1KHz的PWM，那么PERIOD &#x3D; 1000000&#x2F;1K - 2 &#x3D; 998。,如下设置1000，即可得到PERIOD&#x3D;998，也就是1khz.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setperiod_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> regvalue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(value &lt; <span class="number">2</span>)</span><br><span class="line">regvalue = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">regvalue = value - <span class="number">2</span>;</span><br><span class="line">PWM1-&gt;PWMPR = (regvalue &amp; <span class="number">0XFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</span><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi" class="header-anchor">#</a></h3><p>设置Sample采样寄存器，Sample数据会写入到FIFO中。当计数器的值小于 SAMPLE 的时候输出高电平(或低电平)。当计数器值大于等于 SAMPLE，小于寄存器PWM1_PWMPR 的 PERIO 的时候输出低电平(或高电平)。<br>假如我们要设置 PWM 信号的占空比为 50%，那么就可以将 SAMPLE 设置为(PERIOD + 2) &#x2F; 2 &#x3D; 1000 &#x2F; 2&#x3D;500。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"></p><p>如下设置50，即可得到sample&#x3D;500，也就是占空比50%.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> pwm_duty;<span class="comment">/* 占空比*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> <span class="title">backlight_dev</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setsample_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">PWM1-&gt;PWMSAR = (value &amp; <span class="number">0XFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setduty</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> duty)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> preiod;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> sample;</span><br><span class="line">backlight_dev.pwm_duty = duty;</span><br><span class="line">preiod = PWM1-&gt;PWMPR + <span class="number">2</span>;</span><br><span class="line">sample = preiod * backlight_dev.pwm_duty / <span class="number">100</span>;</span><br><span class="line">pwm1_setsample_value(sample);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</span><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FWM(bit27:<span class="number">26</span>)：FIFO 水位线，用来设置 FIFO 空余位置为多少的时候表示 FIFO 为空。</span><br><span class="line">设置为 <span class="number">0</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">1</span> 的时候 FIFO 为空；</span><br><span class="line">设置为 <span class="number">1</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">2</span> 的时候 FIFO 为空；</span><br><span class="line">设置为 <span class="number">2</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">3</span> 的时候FIFO 为空；</span><br><span class="line">设置为 <span class="number">3</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">4</span> 的时候 FIFO 为空。</span><br><span class="line">STOPEN(bit25)：此位用来设置停止模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在停止模式下PWM 不工作，为 <span class="number">1</span> 的话表示停止模式下激活 PWM。</span><br><span class="line">DOZEN(bit24)：此位用来设置休眠模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在休眠模式下PWM 不工作，为 <span class="number">1</span> 的话表示休眠模式下激活 PWM。</span><br><span class="line">WAITEN(bit23)：此位用来设置等待模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在等待模式下PWM 不工作，为 <span class="number">1</span> 的话表示等待模式下激活 PWM。</span><br><span class="line">DEGEN(bit22)：此位用来设置调试模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在调试模式下PWM 不工作，为 <span class="number">1</span> 的话表示调试模式下激活 PWM。</span><br><span class="line">BCTR(bit21)：字节交换控制位，用来控制 <span class="number">16</span> 位的数据进入 FIFO 的字节顺序。为 <span class="number">0</span> 的时候不进行字节交换，为 <span class="number">1</span> 的时候进行字节交换。</span><br><span class="line">HCRT(bit20)：半字交换控制位，用来决定从 <span class="number">32</span> 位 IP 总线接口传输来的哪个半字数据写入采样寄存器的低 <span class="number">16</span> 位中。</span><br><span class="line">POUTC(bit19:<span class="number">18</span>)：PWM 输出控制控制位，用来设置 PWM 输出模式，</span><br><span class="line">为 <span class="number">0</span> 的时候表示PWM 先输出高电平，当计数器值和采样值相等的话就输出低电平。</span><br><span class="line">为 <span class="number">1</span> 的时候相反，当为 <span class="number">2</span> 或者 <span class="number">3</span> 的时候 PWM 信号不输出。本章我们设置为 <span class="number">0</span>，</span><br><span class="line">也就是一开始输出高电平，当计数器值和采样值相等的话就改为低电平，这样采样值越大高电平时间就越长，占空比就越大。</span><br><span class="line">CLKSRC(bit17:<span class="number">16</span>)：PWM 时钟源选择，</span><br><span class="line">为 <span class="number">0</span> 的话关闭；</span><br><span class="line">为 <span class="number">1</span> 的话选择 ipg_clk 为时钟源；</span><br><span class="line">为 <span class="number">2</span> 的话选择 ipg_clk_highfreq 为时钟源；</span><br><span class="line">为 <span class="number">3</span> 的话选择 ipg_clk_32k 为时钟源。本章我们设置为 <span class="number">1</span>，也就是选择 ipg_clk 为 PWM 的时钟源，因此 PWM 时钟源频率为 <span class="number">66</span>MHz。</span><br><span class="line">PRESCALER(bit15:<span class="number">4</span>)：分频值，可设置为 <span class="number">0</span>~<span class="number">4095</span>，对应着 <span class="number">1</span>~<span class="number">4096</span> 分频。</span><br><span class="line">SWR(bit3)：软件复位，向此位写 <span class="number">1</span> 就复位 PWM，此位是自清零的，当复位完成以后此位会自动清零。</span><br><span class="line">REPEAT(bit2:<span class="number">1</span>)：重复采样设置，此位用来设置 FIFO 中的每个数据能用几次。</span><br><span class="line">可设置 <span class="number">0</span>~<span class="number">3</span>，分别表示 FIFO 中的每个数据能用 <span class="number">1</span>~<span class="number">4</span> 次。本章我们设置为 <span class="number">0</span>，即 FIFO 中的每个数据只能用一次。</span><br><span class="line">EN(bit0)：PWM 使能位，为 <span class="number">1</span> 的时候使能 PWM，为 <span class="number">0</span> 的时候关闭 PWM。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">PWM1-&gt;PWMCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">PWM1-&gt;PWMCR = <span class="number">0</span>;<span class="comment">/* 寄存器先清零 */</span></span><br><span class="line">PWM1-&gt;PWMCR |= (<span class="number">1</span> &lt;&lt; <span class="number">26</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">65</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置PWM周期为1000,那么PWM频率就是1M/1000 = 1KHz。 */</span></span><br><span class="line">pwm1_setperiod_value(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置占空比，默认50%占空比   ,写四次是因为有4个FIFO */</span></span><br><span class="line">backlight_dev.pwm_duty = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pwm1_setduty(backlight_dev.pwm_duty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">GIC_EnableIRQ(PWM1_IRQn);<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">PWM1-&gt;PWMSR = <span class="number">0</span>;<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line"></span><br><span class="line">pwm1_enable();<span class="comment">/* 使能PWM1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">27</span>:<span class="number">26</span>]: <span class="number">01</span>  当FIFO中空余位置大于等于<span class="number">2</span>的时候FIFO空标志值位</span><br><span class="line">bit[<span class="number">25</span>]:<span class="number">0</span>  停止模式下PWM不工作</span><br><span class="line">bit[<span class="number">24</span>]: <span class="number">0</span>  休眠模式下PWM不工作</span><br><span class="line">bit[<span class="number">23</span>]: <span class="number">0</span>   等待模式下PWM不工作</span><br><span class="line">bit[<span class="number">22</span>]: <span class="number">0</span>   调试模式下PWM不工作</span><br><span class="line">it[<span class="number">21</span>]: <span class="number">0</span>   关闭字节交换</span><br><span class="line">bit[<span class="number">20</span>]: <span class="number">0</span>  关闭半字数据交换</span><br><span class="line">bit[<span class="number">19</span>:<span class="number">18</span>]: <span class="number">00</span>  PWM输出引脚在计数器重新计数的时候输出高电平,在计数器计数值达到比较值以后输出低电平</span><br><span class="line">bit[<span class="number">17</span>:<span class="number">16</span>]: <span class="number">01</span>  PWM时钟源选择IPG CLK = <span class="number">66</span>MHz</span><br><span class="line">bit[<span class="number">15</span>:<span class="number">4</span>]: <span class="number">65</span>  分频系数为<span class="number">65</span>+<span class="number">1</span>=<span class="number">66</span>，PWM时钟源 = <span class="number">66</span>MHZ/<span class="number">66</span>=<span class="number">1</span>MHz</span><br><span class="line">bit[<span class="number">3</span>]: <span class="number">0</span>  PWM不复位</span><br><span class="line">bit[<span class="number">2</span>:<span class="number">1</span>]: <span class="number">00</span>  FIFO中的sample数据每个只能使用一次。</span><br><span class="line">bit[<span class="number">0</span>]: <span class="number">0</span>   先关闭PWM，后面再使能</span><br></pre></td></tr></table></figure><h3><span id="2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</span><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"><br><strong>CIE</strong>(bit2)：比较中断使能位，为 1 的时候使能比较中断，为 0 的时候关闭比较中断。<br><strong>RIE</strong>(bit1)：翻转中断使能位，当计数器值等于采样值并回滚到 0X0000 的时候就会产生此中断，为 1 的时候使能翻转中断，为 0 的时候关闭翻转中断。<br><strong>FIE</strong>(bit0)：FIFO 空中断，为 1 的时候使能，为 0 的时候关闭。前面代码写的是使能FIFO空中断.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3><span id="2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</span><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><strong>FWE</strong>(bit6)：FIFO 写错误事件，为 1 的时候表示发生了 FIFO 写错误。<br><strong>CMP</strong>(bit5)：FIFO 比较事件发标志位，为 1 的时候表示发生 FIFO 比较事件。<br><strong>ROV</strong>(bit4)：翻转事件标志位，为 1 的话表示翻转事件发生。<br><strong>FE</strong>(bit3)：FIFO 空标志位，为 1 的时候表示 FIFO 位空。<br><strong>FIFOAV</strong>(bit2:0)：此位记录 FIFO 中的有效数据个数，有效值为 0<del>4，分别表示 FIFO 中有0</del>4 个有效数据</p><p>初始化先清0，中断服务程序读取状态，并且清中断。FIFO 中的采样值每个周期都会少一个，所以需要不断的向 FIFO 中写入采样值，防止其为空。我们可以使能 FIFO 空中断，这样当 FIFO 为空的时候就会触发相应的中断，然后在中断处理函数中向 FIFO 写入采样值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_irqhandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(PWM1-&gt;PWMSR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) <span class="comment">/* FIFO为空中断 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将占空比信息写入到FIFO中,其实就是设置占空比 */</span></span><br><span class="line">pwm1_setduty(backlight_dev.pwm_duty);</span><br><span class="line">PWM1-&gt;PWMSR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">/* 写1清除中断标志位 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">GIC_EnableIRQ(PWM1_IRQn);<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">PWM1-&gt;PWMSR = <span class="number">0</span>;<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line">pwm1_enable();<span class="comment">/* 使能PWM1 */</span></span><br></pre></td></tr></table></figure><h2><span id="2-3-ce-shi">2.3 测试</span><a href="#2-3-ce-shi" class="header-anchor">#</a></h2><p>初始化时设置占空比为50%，测试代码读取按键，每次该按键按下就对占空比加10%，如果占空比超过100%，重新从10%开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">keyvalue = key_getvalue();</span><br><span class="line"><span class="keyword">if</span>(keyvalue == KEY0_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">duty += <span class="number">10</span>;<span class="comment">/* 占空比加10% */</span></span><br><span class="line"><span class="keyword">if</span>(duty &gt; <span class="number">100</span>)<span class="comment">/* 如果占空比超过100%，重新从10%开始 */</span></span><br><span class="line">duty = <span class="number">10</span>;</span><br><span class="line">lcd_shownum(<span class="number">50</span> + <span class="number">72</span>, <span class="number">90</span>, duty, <span class="number">3</span>, <span class="number">16</span>);</span><br><span class="line">pwm1_setduty(duty);<span class="comment">/* 设置占空比 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>占空比10%时亮度波形如下，亮度很暗。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"><br>占空比90%时亮度如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-rtc-ding-shi-qi&quot;&gt;1 RTC定时器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-rtc-ding-shi-qi-jie-shao&quot;&gt;1.1 RTC定</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>imx6ull裸机-ADC</title>
    <link href="http://example.com/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/"/>
    <id>http://example.com/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/</id>
    <published>2024-05-01T10:56:40.000Z</published>
    <updated>2024-05-01T11:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</a><ul><li><a href="#1-1-adcx-cfg-x-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</a></li><li><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</a></li><li><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</a></li><li><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</a></li><li><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</a></li><li><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</a></li></ul></li><li><a href="#2-liu-cheng-dai-ma">2 流程代码</a><ul><li><a href="#2-1-chu-shi-hua">2.1 初始化</a></li><li><a href="#2-2-zi-dong-xiao-zhun">2.2 自动校准</a></li><li><a href="#2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</a></li><li><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</a></li><li><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</span><a href="#1-imx6ull-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</span><a href="#1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/1.jpg" alt="image"><br><strong>OVWREN</strong> (bit16)：数据复写使能位，为 1 的时候使能复写功能，为 0 的时候关闭复写功能。<br><strong>AVGS</strong>(bit15:14)：硬件平均次数，只有当 ADC1_GC 寄存器的 AVGE 位为 1 的时候才有效<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/2.png" alt="image"><br><strong>ADTRG</strong>(bit13)：转换触发选择。为 0 的时候选择软件触发，为 1 的时候，不选择软件触发。<br><strong>REFSEL</strong>(bit12:11)：参考电压选择，为 00 时选择 VREFH&#x2F;VREFL 这两个引脚上的电压为参考电压，正点原子 ALPHA 开发板上 VREFH 为 3.3V，VREFL 为 0V。<br><strong>ADHSC</strong>(bit10)：高速转换使能位，当为 0 时为正常模式，为 1 时为高速模式。<br><strong>ADSTS</strong>(bit9:8)：设置 ADC 的采样周期，与 ADLSMP 位一起决定采样周期：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/3.png" alt="image"><br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/4.png" alt="image"><br><strong>ADLSMP</strong>(bit4)：长采样周期使能位，当值为 0 时为短采样周期模式，为 1 时为长采样周期模式。搭配 ADSTS 位一起控制 ADC 的采样周期。<br><strong>MODE</strong>(bit3:2)：选择转换精度：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/5.png" alt="image"><br><strong>ADICLK</strong>(bit1:0)：输入时钟源选择，为 00 的时候选择 IPG Clock，为 01 的时候选择 IPG Clock&#x2F;2，为 10 的时候无效，为 11 的时候选择呢 ADACK。本教程我们设置为 11，也就是选择ADACK 为 ADC 的时钟源。</p><h2><span id="1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</span><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/6.png" alt="image"><br><strong>CAL</strong>(bit7)：当该位写入 1 时，硬件校准功能将会启动，校准过程中该位会一直保持 1，校准完成后会清 0，校准完成后需要检查一下ADC_GS[CALF]位，确认校准结果。<br><strong>ADCO</strong>(bit6)：连续转换使能位，只有在开启了硬件平均功能时有效，为 0 时只能转换一次或一组，当 ADCO 为 1 时可以连续转换或多组。<br><strong>AVGE</strong>(bit5)：硬件平均使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFE</strong>(bit4)：比较功能使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFGT</strong>(bit3)：配置比较方法，如果为 0 的话就比较转换结果是否小于 ADC_CV 寄存器值，如果为 1 的话就比较装换结果是否大于或等于 ADC_CV 寄存器值。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>DMAEN</strong>(bit1)：DMA 功能使能位，为 0 是关闭，为 1 是开启<br><strong>ADACKEN</strong>(bit0)：异步时钟输出使能位，为 0 是关闭，为 1 时开启</p><h2><span id="1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</span><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/7.png" alt="image"><br><strong>AWKST</strong>(bit2)：异步唤醒中断状态，为 1 时表示发生了异步唤醒中断。为 0 时没有发生异步中断。<br><strong>CALF</strong>(bit1)：校准失败标志位，为 0 的时候表示校准正常完成，为 1 的时候表示校准失败。<br><strong>ADACT</strong>(bit0)：转换活动标志，为 0 的时候表示转换没有进行，为 1 的时候表示正在进行转换。</p><h2><span id="1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</span><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p>COCO0表示转换完成.</p><p><strong>COCO0</strong>(bit0)：每次转换完成此位就会被置 1。</p><h2><span id="1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</span><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/8.png" alt="image"><br><strong>AIEN</strong>(bit7)：转换完成中断控制位，为 1 的时候打开转换完成中断，为 0 的时候关闭。<br><strong>ADCH</strong>(bit4:0)：转换通道选择，可以设置为 00000~01111 分别对应通道 0~15。11001 为内部通道，用于 ADC 自测。</p><h2><span id="1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</span><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/9.png" alt="image"></p><h1><span id="2-liu-cheng-dai-ma">2 流程代码</span><a href="#2-liu-cheng-dai-ma" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、初始化 ADC1_CH1</span><br><span class="line"><span class="comment">//初始化 ADC1_CH1，配置 ADC 位数，时钟源，采样时间等。</span></span><br><span class="line"><span class="number">2</span>、校准 ADC</span><br><span class="line"><span class="comment">//ADC 在使用之前需要校准一次。</span></span><br><span class="line"><span class="number">3</span>、使能 ADC</span><br><span class="line"><span class="comment">//配置好 ADC 以后就可以开启了。</span></span><br><span class="line"><span class="number">4</span>、读取 ADC 值</span><br><span class="line"><span class="comment">//ADC 正常工作以后就可以读取 ADC 值。</span></span><br></pre></td></tr></table></figure><h2><span id="2-1-chu-shi-hua">2.1 初始化</span><a href="#2-1-chu-shi-hua" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc1ch1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC1-&gt;CFG = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;CFG |= (<span class="number">2</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">3</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    ADC1-&gt;GC = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;GC |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* CFG寄存器</span></span><br><span class="line"><span class="comment">     * bit16        0       关闭复写功能</span></span><br><span class="line"><span class="comment">     * bit15:14     00      硬件平均设置为默认值，00的时候4次平均，</span></span><br><span class="line"><span class="comment">     *                      但是得ADC_GC寄存器的AVGE位置1来使能硬件平均</span></span><br><span class="line"><span class="comment">     * bit13        0       软件触发</span></span><br><span class="line"><span class="comment">     * bit12:1      00      参考电压为VREFH/VREFL，也就是3.3V/0V</span></span><br><span class="line"><span class="comment">     * bit10        0       正常转换速度</span></span><br><span class="line"><span class="comment">     * bit9:8       00      采样时间2/12，ADLSMP=0(短采样)的时候为2个周期</span></span><br><span class="line"><span class="comment">     *                      ADLSMP=1(长采样)的时候为12个周期</span></span><br><span class="line"><span class="comment">     * bit7         0       非低功耗模式</span></span><br><span class="line"><span class="comment">     * bit6:5       00      ADC时钟源1分频 </span></span><br><span class="line"><span class="comment">     * bit4         0       短采样</span></span><br><span class="line"><span class="comment">     * bit3:2       10      12位ADC</span></span><br><span class="line"><span class="comment">     * bit1:0       11      ADC时钟源选择ADACK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* GC寄存器</span></span><br><span class="line"><span class="comment">     * bit7     0       先关闭校准功能，后面会校准</span></span><br><span class="line"><span class="comment">     * bit6     0       关闭持续转换</span></span><br><span class="line"><span class="comment">     * bit5     0       关闭硬件平均功能</span></span><br><span class="line"><span class="comment">     * bit4     0       关闭比较功能</span></span><br><span class="line"><span class="comment">     * bit3     0       关闭比较的Greater Than功能</span></span><br><span class="line"><span class="comment">     * bit2     0       关闭比较的Range功能</span></span><br><span class="line"><span class="comment">     * bit1     0       关闭DMA</span></span><br><span class="line"><span class="comment">     * bit0     1       使能ADACK</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure><h2><span id="2-2-zi-dong-xiao-zhun">2.2 自动校准</span><a href="#2-2-zi-dong-xiao-zhun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">adc1_autocalibration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">status_t</span> ret  = kStatus_Success;</span><br><span class="line">ADC1-&gt;GS |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);   <span class="comment">/* 清除CALF位，写1清零 */</span></span><br><span class="line">ADC1-&gt;GC |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">/* 使能校准功能 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 校准完成之前GC寄存器的CAL位会一直为1，直到校准完成此位自动清零 */</span></span><br><span class="line"><span class="keyword">while</span>((ADC1-&gt;GC &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line"><span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">ret = kStatus_Fail;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 校准成功以后HS寄存器的COCO0位会置1 */</span></span><br><span class="line"><span class="keyword">if</span>((ADC1-&gt;HS  &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>) </span><br><span class="line">ret = kStatus_Fail;</span><br><span class="line"><span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line"><span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) </span><br><span class="line">ret = kStatus_Fail;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</span><a href="#2-3-huo-qu-adc-yuan-shi-zhi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getadc_value</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 配置ADC通道1 */</span></span><br><span class="line">ADC1-&gt;HC[<span class="number">0</span>] = <span class="number">0</span>;            <span class="comment">/* 关闭转换结束中断    */</span></span><br><span class="line">ADC1-&gt;HC[<span class="number">0</span>] |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);     <span class="comment">/* 通道1            */</span></span><br><span class="line"><span class="keyword">while</span>((ADC1-&gt;HS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>);  <span class="comment">/* 等待转换完成 */</span></span><br><span class="line"><span class="keyword">return</span> ADC1-&gt;R[<span class="number">0</span>];    <span class="comment">/* 返回ADC值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</span><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_average</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> times)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> temp_val = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> t;</span><br><span class="line"><span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; times; t++)&#123;</span><br><span class="line">temp_val += getadc_value();</span><br><span class="line">delayms(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> temp_val / times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</span><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya" class="header-anchor">#</a></h2><p>由于精度为12 bit, ADC范围为[0, 4095]。同时电压满输出时为3.3v，因此当ADC数据拉满，得到3300mv，也就是3.3v</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_volt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> adcvalue=<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">adcvalue = getadc_average(<span class="number">5</span>);</span><br><span class="line">ret = (<span class="type">float</span>)adcvalue * (<span class="number">3300.0f</span> / <span class="number">4096.0f</span>);    <span class="comment">/* 获取计算后的带小数的实际电压值 */</span></span><br><span class="line"><span class="keyword">return</span>  ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-imx6ull-ji-cun-qi&quot;&gt;1 IMX6ULL寄存器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-adcx-cfg-x-1-2-pei-zhi-ji-cu</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-电阻触摸屏</title>
    <link href="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/"/>
    <id>http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/</id>
    <published>2024-05-01T07:13:12.000Z</published>
    <updated>2024-05-01T10:06:18.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</a><ul><li><a href="#1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</a></li><li><a href="#1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</a></li></ul></li><li><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</a><ul><li><a href="#2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</a></li><li><a href="#2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</a></li><li><a href="#2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</a></li><li><a href="#2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</a><ul><li><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</a></li><li><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</a></li></ul></li></ul></li><li><a href="#3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</a><ul><li><a href="#3-1-normal-conversion-mode">3.1 Normal Conversion Mode</a></li><li><a href="#3-2-separate-x-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</a></li><li><a href="#3-3-auto-sequential-x-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</a></li><li><a href="#3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</a></li></ul></li><li><a href="#4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</a><ul><li><a href="#4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</a></li><li><a href="#4-2-data-ji-cun-qi">4.2 DATA寄存器</a><ul><li><a href="#4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</a></li><li><a href="#4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</a></li></ul></li><li><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</a></li></ul></li><li><a href="#5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</a><ul><li><a href="#5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</a><ul><li><a href="#5-1-1-zhong-duan-yuan">5.1.1 中断源</a></li><li><a href="#5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</a></li><li><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</a></li><li><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</a><ul><li><a href="#5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</a></li><li><a href="#5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</a></li></ul></li></ul></li><li><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</a><ul><li><a href="#5-2-1-chu-shi-hua">5.2.1 初始化</a><ul><li><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</a></li><li><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</a></li><li><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</a></li></ul></li><li><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</a><ul><li><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</a><ul><li><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</a></li><li><a href="#5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</a></li></ul></li><li><a href="#5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</a></li></ul></li></ul></li><li><a href="#5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</a></li><li><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</a><ul><li><a href="#5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</a></li><li><a href="#5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</a><ul><li><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</a><ul><li><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</a></li></ul></li></ul></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</span><a href="#1-dian-zu-hong-mo-ping-yuan-li" class="header-anchor">#</a></h1><p>触摸屏包含上下叠合的两个透明层，一般覆盖在lcd表面，两个透明层是由均匀的电阻介质组成，如下图：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png"></p><p>当触摸屏表面受到的压力（如通过笔尖或手指进行按压）足够大时，顶层与底层之间的薄膜会产生接触，此时会形成x方向和y方向的坐标。那么x，y坐标的值是怎么得来的呢？本质上就是通过ADC转换得来的。</p><p>触摸屏的等效电路可以看成如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg"></p><p>计算触点的X，Y坐标分为如下两步： </p><h2><span id="1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</span><a href="#1-1-ji-suan-y-zuo-biao" class="header-anchor">#</a></h2><p>在Y+电极施加驱动电压Vdrive， Y-电极接地，由于上下两层膜形成触点，X+做为触点的引出端，测量得到接触点的电压，触点电压与Vdrive电压之比等于触点Y坐标与屏高度之比。如下图：</p><h2><span id="1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</span><a href="#1-2-ji-suan-x-zuo-biao" class="header-anchor">#</a></h2><p>在X+电极施加驱动电压Vdrive， X-电极接地，由于上下两层膜形成触点，Y+做为触点的引出端，测量得到接触点的电压，Y+做为引出端测量得到接触点的电压，触点电压与Vdrive电压之比等于触点X坐标与屏宽度之比。如下图：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg"></p><h1><span id="2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</span><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi" class="header-anchor">#</a></h1><h2><span id="2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</span><a href="#2-1-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h2><p>平时的时候上下两层膜并不粘在一起，我们把这种状态称为<strong>“等待中断模式”</strong>， 等效电路如下图的右边那幅图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png"></p><p>s5、s4闭合，s1、s2、s3断开，这个时候Y_ADC&#x2F;XP通过S5接上拉电阻，处于高电平状态,X_ADC&#x2F;YP接地。没法读取x,y坐标。</p><h2><span id="2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</span><a href="#2-2-du-qu-x-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给X方向通电，也就是让S1、S3开关闭合，s2、s4断开，那么当屏幕按下，触点YP的电平就对应x坐标。（XP到XM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png"></p><pre><code>x_adc电压/vcc = x坐标/width, 所以x坐标= width * x_adc电压/vcc</code></pre><h2><span id="2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</span><a href="#2-3-du-qu-y-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给Y方向通电，也就是让S2、S4开关闭合，s1、s3断开，那么当屏幕按下，触点XP的电平就对应y坐标。（YP到YM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png"></p><pre><code>y_adc电压/vcc = Y坐标/height, 所以y坐标= height * y_adc电压/vcc</code></pre><h2><span id="2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</span><a href="#2-4-ts-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>总结一下单次触发TS中断，使用触摸屏的流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 按下触摸屏，产生TS中断</span><br><span class="line"><span class="number">2.</span> 启动ADC(目的是获取x,y方向上的坐标值)</span><br><span class="line"><span class="number">3.</span> ADC转换完成，产生adc中断（adc转换需要一定的时间）</span><br><span class="line"><span class="number">4.</span> ADC中断中来读取x y坐标</span><br><span class="line"><span class="number">5.</span> 松开，结束</span><br></pre></td></tr></table></figure><p>我们知道，现在的手机都是支持屏幕滑动翻页和长按的功能。那么这些功能是如何做到的呢？</p><h3><span id="2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</span><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi" class="header-anchor">#</a></h3><p>如何让触摸屏支持长按或者滑动操作（多次触发TS中断）？</p><p>答案:<strong>定时器</strong>，当长按屏幕，会产生多次TS中断，因此我们需要用定时器来判断，当定时一段时间后，还有TS中断产生，那么我们认为是长按操作，进行中断响应。滑动也是类似的道理，当定时时间到后，如果还有TS中断产生，且坐标发生了改变，就认为是滑动操作。</p><pre><code>&lt;5&gt; 启动定时器&lt;6&gt; 一段时间后，定时器中断发生，判断触摸屏是否仍被按下(是否有定时器中断产生)，如果有就循环上述过程&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;</code></pre><p>可以用如下流程图概括TSC的整个SW flow.</p><h3><span id="2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</span><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png" alt="image"></p><h1><span id="3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</span><a href="#3-hong-mo-ping-jie-kou-mo-shi" class="header-anchor">#</a></h1><h2><span id="3-1-normal-conversion-mode">3.1 Normal Conversion Mode</span><a href="#3-1-normal-conversion-mode" class="header-anchor">#</a></h2><p>正常转换模式，一般情况下可以配置ADCCON和ADCDAT0来读取数据。</p><h2><span id="3-2-separate-x-x2f-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</span><a href="#3-2-separate-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png"><br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png"></p><p>x,y坐标分离转换格式，x坐标会写入ADCDAT0, y坐标会写入ADCDAT1,所以会产生2次中断开分开完成x,y的坐标转换。</p><h2><span id="3-3-auto-sequential-x-x2f-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</span><a href="#3-3-auto-sequential-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p>自动转换模式，当触摸屏按下后，会一次性对x,y方向的坐标进行转换，x坐标会写入ADCDAT0, x坐标会写入ADCDAT1。会产生一次中断进行x,y坐标的自动转换。 </p><h2><span id="3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</span><a href="#3-4-waiting-for-interrupt-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg"></p><p> 等待中断模式 。可以设置rADCTSC&#x3D;0xd3;也就是对应下图寄存器 &#x2F;&#x2F; XP_PU, XP_Dis, XM_Dis, YP_Dis, YM_En.当产生中断信号(INT_TC)后，等待中断模式必须清除.(即XY_PST sets to the No operation Mode).</p><h1><span id="4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</span><a href="#4-hong-mo-ping-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</span><a href="#4-1-ts-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p>电阻触摸屏的原理本质上就是ADC，ADC相关寄存器介绍详见<a href="https://www.cnblogs.com/fuzidage/p/13396987.html">s3c2440裸机-ADC编程</a>或者<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC | Hexo (fuzidage.github.io)</a><br>TSC相比ADC多了一个ADCTSC寄存器，如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg" alt="image"><br>当bit[2]&#x3D;0，normal mode时，那么bit[1:0]需要配置成01或者10进行手工测量x,y.<br>当bit[2]&#x3D;1，auto mode时，那么bit[1:0]需要配置成0,进行自动测量。</p><h2><span id="4-2-data-ji-cun-qi">4.2 DATA寄存器</span><a href="#4-2-data-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</span><a href="#4-2-1-x-zuo-biao-adcdata0" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png" alt="image"></p><h3><span id="4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</span><a href="#4-2-2-y-zuo-biao-adcdata1" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png" alt="image"></p><h2><span id="4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</span><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi" class="header-anchor">#</a></h2><p>这个寄存器可以检测是否有触摸中断产生，是按下触摸屏了，还是松开触摸屏了。<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png" alt="image"></p><h1><span id="5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</span><a href="#5-hong-mo-ping-bian-cheng-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</span><a href="#5-1-adc-zhong-duan-chan-sheng" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png" alt="img"></p><h3><span id="5-1-1-zhong-duan-yuan">5.1.1 中断源</span><a href="#5-1-1-zhong-duan-yuan" class="header-anchor">#</a></h3><p>ADC和TSC共用一个中断源，如下：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png" alt="img"></p><p>SRCPND表示哪个中断源产生了中断请求。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png" alt="img"></p><h3><span id="5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</span><a href="#5-1-2-zhong-duan-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png" alt="img"></p><h3><span id="5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</span><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png" alt="img"></p><h3><span id="5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</span><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi" class="header-anchor">#</a></h3><p>用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png" alt="img"></p><p>从SRCPND寄存器可以读到ADC和TSC复用的同一个中断源，那么如何区分呢？</p><p>可以从SUBSRCPND寄存器配置，如下：</p><h4><span id="5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</span><a href="#5-1-4-1-subsrcpnd-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png" alt="img"></p><p> 当bit 9被置1时，表示TSC中断。那么我们需要打开subsrcmask寄存器：</p><h4><span id="5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</span><a href="#5-1-4-2-intsubmsk-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png" alt="img"></p><p>所以TSC中断的产生流程如下：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png" alt="img"></p><h2><span id="5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</span><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化TSC，ADCTSC寄存器</span><br><span class="line"><span class="number">2.</span> 设定TSC处于“等待中断模式”</span><br><span class="line"><span class="number">3.</span> 使能TSC中断</span><br><span class="line">　　　　　　INTSUBMSK</span><br><span class="line">　　　　　　MSK/MODE</span><br><span class="line"><span class="number">4.</span> 按下，进入TSC中断</span><br><span class="line">　　　　　　进入自动采集转换模式</span><br><span class="line">　　　　　　启动ADC</span><br><span class="line"><span class="number">5.</span> ADC中断</span><br><span class="line">　　　　　　读数据</span><br><span class="line">　　　　　　再次进入”等待中断模式“</span><br><span class="line">　　　　　　启动定时器（为了处理长按或者滑动操作）</span><br><span class="line"><span class="number">6.</span> 定时器中断</span><br><span class="line">　　　　　　若松开，结束</span><br><span class="line">　　　　　　如任然按下，进入步骤<span class="number">4</span>的启动ADC流程</span><br></pre></td></tr></table></figure><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png" alt="img"></p><h3><span id="5-2-1-chu-shi-hua">5.2.1 初始化</span><a href="#5-2-1-chu-shi-hua" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置触摸屏接口:寄存器 */</span></span><br><span class="line">    adc_ts_reg_init();</span><br><span class="line">    <span class="comment">/* 设置中断 */</span></span><br><span class="line">    adc_ts_int_init();</span><br><span class="line">    <span class="comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</span><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>主要是设置预分频，产生ADC clk &#x3D; 1MHz。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">     * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">     * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">     * [2]   : STDBM</span></span><br><span class="line"><span class="comment">     * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    ADCDLY = <span class="number">0xff</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</span><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua" class="header-anchor">#</a></h4><p>为了将中断源开启，这里设置SUBSRCPND 和INTSUBMSK让中断源开启。通过register_irq（）注册中断号和中断服务程AdcTsIntHandle，查表得出中断号为31，这样当硬件产生中断后可以从INTOFFSET区分是哪个中断号。如下图：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_int_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    register_irq(<span class="number">31</span>, AdcTsIntHandle);    <span class="comment">/*31号中断*/</span></span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    INTSUBMSK &amp;= ~((<span class="number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="number">1</span>&lt;&lt;TC_INT_BIT));<span class="comment">//防止屏蔽（SUBMSK）</span></span><br><span class="line">    <span class="comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);//reg_irq已经使能了31中断号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</span><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png" alt="img"></p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png" alt="img"></p><p>进入等待中断模式，YM闭合， YP， XP， XM断开，需要pull up，WAIT_PEN_DOWN表示要等待的是按下中断，当触摸屏按下时就会产生一个TSC irq,反之WAIT_PEN_UP表示要等待的是松开中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_INT_BIT (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_INT_BIT  (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_ADC_TC   (31)</span></span><br><span class="line"><span class="comment">/* ADCTSC&#x27;s bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8) <span class="comment">/*触摸笔按下*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8) <span class="comment">/*触摸笔松开*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)    <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)    <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_down_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待按下模式*/</span> &#123;</span><br><span class="line">ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_up_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待松开模式*/</span> &#123;</span><br><span class="line">ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</span><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h3><p>SUBSRCPND的bit9, bit10可以区分是TC中断还是ADC中断。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*触摸屏中断服务程序*/</span> &#123;</span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">//dat寄存器的第15位判断按下还是松开</span></span><br><span class="line">　　　　<span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　<span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">　　　　<span class="comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span></span><br><span class="line">　　　　enter_wait_pen_up_mode();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT)) <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="comment">// if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT)) /* ADC中断 */</span></span><br><span class="line">　　<span class="comment">// Isr_Adc();</span></span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">　　<span class="comment">//SRCPND = 1&lt;&lt;31;/*在interrupt.c已经清中断了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AdcTsIntHandle函数： 这里先注解掉ADC中断，只检测单独的按下松开触摸屏操作。那当isr处理完后为了能够正常响应下一次中断，需要清中断，否则会一直触发interrupt。</span><br><span class="line">Isr_Tc函数：ADCDAT0 寄存器的第15位判断按下还是松开。那么当按下后，要将控制器进入”等待松开模式“，当松开后，要将控制器配置进入”等待按下模式“。</span><br></pre></td></tr></table></figure><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png" alt="img"></p><h4><span id="5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</span><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao" class="header-anchor">#</a></h4><h5><span id="5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</span><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi" class="header-anchor">#</a></h5><p>Auto(Sequential) X&#x2F;Y Position Conversion Mode。打开TS控制寄存器，也就是ADCTSC寄存器：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png" alt="img"></p><p>让bit[2] &#x3D;1, bit[1:0]&#x3D;00，则会进入auto measurement。如果bit[2]&#x3D;0，则需配置bit[1::0]&#x3D;01 or 10是手动测量x,y坐标。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)        <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)        <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_auto_measure_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　ADCTSC = AUTO_PST | NO_OPR_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5><span id="5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</span><a href="#5-2-2-1-2-qi-dong-adc" class="header-anchor">#</a></h5><p>触摸屏坐标就是通过ADC获取的。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>所以TSC isr程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">/*触摸屏中断服务程序*/</span></span><br><span class="line">      <span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">            enter_wait_pen_down_mode();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">            <span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">            enter_auto_measure_mode();</span><br><span class="line">            <span class="comment">/* 启动ADC */</span></span><br><span class="line">            ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当检测到按下后，需要进入auto measure mode，启动adc，然后就会进行自动坐标转换，转换结束后又会触发ADC中断，再次进入<code>AdcTsIntHandle</code>函数，进而进入<code>Isr_Adc</code>，SUBSRCPND可以区分中断源 。如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT))  <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="comment">/* ADC中断 */</span></span><br><span class="line">　　　　Isr_Adc();</span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道ADC进行坐标转换结束后，那么会产生ADC中断，在<code>Isr_Adc</code>中即可获取我们的x,y坐标数据。由于我们按下后是进入了 “自动测量” 模式，因此那当数据获取完后我们得进入 “等待松开” 模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="type">int</span> x = ADCDAT0;</span><br><span class="line">      <span class="type">int</span> y = ADCDAT1;</span><br><span class="line">      <span class="keyword">if</span> (!(ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))) &#123; <span class="comment">/* 在isr_Tc按下后，如果仍然按下才打印 */</span></span><br><span class="line">            x &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            y &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      enter_wait_pen_up_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能触摸屏的测量过程非常长，那当ADC转换结束后，它已经松开了，这时不应该进行打印出坐标，所以这里在isr_Tc按下后，如果仍然按下才打印。</p><h4><span id="5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</span><a href="#5-2-2-2-adcdly-ji-cun-qi" class="header-anchor">#</a></h4><p>由于触摸屏采样的转换速率问题，按下后需要过一段电压才能稳定下来，那么数据才能稳定可能需要一定的延迟，所以需要配置ADC delay，让ADC慢一点产生中断，也就是等坐标稳定后在通知用户。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png" alt="img"></p><p>ADCDLY就是用来延时ADC启动的时间，让数据稳定后再进行转换。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png" alt="img"></p><p><code>可以看到，进行auto or manual measure 坐标转换的时序要满足：A = Dx,D表示ADCDLY的值。 现在晶振的频率是12Mhz, 那么根据触摸屏规格书我们取A= 5ms，那么D= 0.005s *12*1000000 = 60000，所以ADCDLY配置成60000.</code></p><p>修改前面的<code>adc_ts_reg_init</code>函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">       * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">       * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">       * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">       * [2]   : STDBM</span></span><br><span class="line"><span class="comment">       * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">      <span class="comment">/*  按下触摸屏, 延时一会再发出TC中断</span></span><br><span class="line"><span class="comment">       *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCDLY = <span class="number">60000</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</span><a href="#5-3-ts-hong-mo-ping-ce-shi" class="header-anchor">#</a></h2><p>从左往右依次点击触摸屏，可以看到x坐标没有明显变化，y坐标反而线性变大。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png" alt="img"></p><p>同理，从上往下依次按下触摸屏，可以看到y坐标没有明显变化，x坐标反而线性变大。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png" alt="img"></p><p>这里是由于硬件上xp与yp接反了，ym与xm接反了，如下图：但这里并不影响我们的时候，这里我们软件上可以进行x,y坐标的转换：</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png" alt="img"></p><p>我们软件上可以对x,y轴进行flip， mirror, rotaion旋转等一系列操作即可。比如：</p><p>Case1：ts与lcd吻合</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png" alt="img"></p><p>Case2：ts与lcd相反</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png" alt="img"></p><h2><span id="5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</span><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong" class="header-anchor">#</a></h2><h3><span id="5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</span><a href="#5-4-1-gai-jin-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有讲到在<code>handle_irq_c()</code>中去区分中断源，执行不同的<code>isr</code>。</p><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png" alt="image-20240501173712329"></p><p>那现在通过<code>register_timer</code>注册对应的定时器中断服务程序，<code>timer_irq</code>进行执行不同的定时器中断服务程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_NUM  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL  ((void *)0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*timer_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_desc</span> &#123;</span></span><br><span class="line">　　<span class="type">char</span> *name;</span><br><span class="line">　　timer_func fp;</span><br><span class="line">&#125;timer_desc, *p_timer_desc;</span><br><span class="line"></span><br><span class="line">timer_desc timer_array[TIMER_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">register_timer</span><span class="params">(<span class="type">char</span> *name, timer_func fp)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = name;</span><br><span class="line">　　　　　　timer_array[i].fp   = fp;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_timer</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(timer_array[i].name, name)) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　timer_array[i].fp   = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].fp();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要用timer来进行进行流水灯实验，那么假如点灯函数为:<br><code>Isr_timer_led()&#123;&#125;</code></p><p>那么则只需要在<code>led init</code>的时候进行调用<code>register_timer(“led”, Isr_timer_led)</code>, 那么当时间到后触发定时器中断，便会执行<code>timer_irq</code>.进入<code>Isr_timer_led</code>。</p><h3><span id="5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</span><a href="#5-4-2-chu-shi-hua-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有具体讲解，这里采用PWM定时器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="comment">/* 设置TIMER0的时钟 */</span></span><br><span class="line">　　<span class="comment">/* Timer clk = PCLK / &#123;prescaler value+1&#125; / &#123;divider value&#125;</span></span><br><span class="line"><span class="comment">             = 50000000/(49+1)/16</span></span><br><span class="line"><span class="comment">             = 62500</span></span><br><span class="line"><span class="comment"> 　　*/</span></span><br><span class="line">　　TCFG0 = <span class="number">49</span>;  <span class="comment">/* Prescaler 0 = 49, 用于timer0,1 */</span></span><br><span class="line">　　TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">　　TCFG1 |= <span class="number">3</span>;  <span class="comment">/* MUX0 : 1/16 */</span></span><br><span class="line">　　<span class="comment">/* 设置TIMER0的初值 */</span></span><br><span class="line">　　TCNTB0 = <span class="number">625</span>;  <span class="comment">/* 10Ms中断一次 */</span></span><br><span class="line">　　<span class="comment">/* 加载初值, 启动timer0 */</span></span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);   <span class="comment">/* Update from TCNTB0 &amp; TCMPB0 */</span></span><br><span class="line">　　<span class="comment">/* 设置为自动加载并启动 */</span></span><br><span class="line">　　TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">/* bit0: start, bit3: auto reload */</span></span><br><span class="line">　　<span class="comment">/* 设置中断 */</span></span><br><span class="line">　　register_irq(<span class="number">10</span>, timer_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</span><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong" class="header-anchor">#</a></h4><p>我们之前是2s timer触发一次中断，那如果是要支持触摸屏，我们必须让定时器10ms就触发一次中断。因此需要修改timer_init中的寄存器参数。</p><p>当按下触摸屏会产生TSC中断，然后启动ADC进而产生<code>adc</code>中断的时候，在<code>Isr_Adc</code>函数中进行定时器的设置，检测长按和滑动操作。</p><h5><span id="5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</span><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_status_of_ts_timer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> g_ts_timer_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 每10ms该函数被调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (get_status_of_ts_timer() == <span class="number">0</span>)</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">/* 如果松开 */</span></span><br><span class="line">　　　　ts_timer_disable();</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;  <span class="comment">/* 按下状态 */</span></span><br><span class="line">　　　　<span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">　　　　enter_auto_measure_mode();</span><br><span class="line">　　　　<span class="comment">/* 启动ADC */</span></span><br><span class="line">　　　　ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png" alt="image-20240501174908562"></p><p>来分析一下这个程序的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在touchscreen_init的时候我们先注册了一个timer，然后修改了定时器的产生中断的时间间隔为<span class="number">10</span>ms中断一次，所以touchscreen_timer_irq会每间隔<span class="number">10</span>ms调用一次。没有按下，则touchscreen_timer_irq虽然也有走，但是就直接<span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 然后如果按下触摸屏，产生tsc中断，启动adc，产生adc中断。</span><br><span class="line"></span><br><span class="line">如果产生了adc中断，但是读取状态发现已经松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效。那么要是状态是被按下，则开启ts_timer_enable。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 当使能touchscreen_timer_irq这个定时器中断服务程序后，并且<span class="number">10</span>ms到了touchscreen_timer_irq函数执行生效。</span><br><span class="line"></span><br><span class="line">如果松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效，表示没有长按或者滑动。</span><br><span class="line"></span><br><span class="line">如果任然按下，输出长按或者滑动后的坐标结果。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-dian-zu-hong-mo-ping-yuan-li&quot;&gt;1 电阻触摸屏原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-ji-suan-y-zuo-biao&quot;&gt;</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-LDC</title>
    <link href="http://example.com/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/"/>
    <id>http://example.com/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/</id>
    <published>2024-04-19T09:57:39.000Z</published>
    <updated>2024-04-27T09:30:40.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-lcd-ying-jian-yuan-li">1 LCD硬件原理</a><ul><li><a href="#1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</a></li><li><a href="#1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</a><ul><li><a href="#1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</a></li><li><a href="#1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</a><ul><li><a href="#1-2-2-1-xing-shi-xu">1.2.2.1 行时序</a></li><li><a href="#1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</a></li></ul></li></ul></li><li><a href="#1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</a></li><li><a href="#1-3-lcd-chong-lei">1.3 LCD种类</a></li><li><a href="#1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</a></li></ul></li><li><a href="#2-lcd-kong-zhi-qi">2 LCD控制器</a><ul><li><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</a></li><li><a href="#2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</a><ul><li><a href="#2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</a><ul><li><a href="#2-2-1-1-bswp-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</a><ul><li><a href="#2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</a></li><li><a href="#2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</a></li><li><a href="#2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</a></li></ul></li></ul></li><li><a href="#2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</a><ul><li><a href="#2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</a></li></ul></li><li><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</a></li><li><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</a></li><li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</a></li><li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</a></li><li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</a></li><li><a href="#2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</a></li><li><a href="#2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</a></li></ul></li></ul></li><li><a href="#3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</a><ul><li><a href="#3-1-ruan-jian-kuang-jia">3.1 软件框架</a></li><li><a href="#3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</a><ul><li><a href="#3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</a></li></ul></li><li><a href="#3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</a><ul><li><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1 LCD操作方法-lcd_controller.c</a></li><li><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</a></li></ul></li><li><a href="#3-4-lcd-chu-shi-hua">3.4 LCD初始化</a><ul><li><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</a><ul><li><a href="#3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</a><ul><li><a href="#3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</a></li><li><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</a></li><li><a href="#3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</a></li></ul></li><li><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</a></li><li><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</a></li></ul></li><li><a href="#3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</a></li></ul></li><li><a href="#3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</a><ul><li><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</a><ul><li><a href="#3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</a></li><li><a href="#3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</a></li><li><a href="#3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</a></li><li><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</a></li></ul></li></ul></li><li><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</a><ul><li><a href="#3-6-1-hua-dian">3.6.1 画点</a></li><li><a href="#3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</a></li><li><a href="#3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</a></li><li><a href="#3-6-4-ce-shi">3.6.4 测试</a></li></ul></li><li><a href="#3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</a><ul><li><a href="#3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-lcd-ying-jian-yuan-li">1 LCD硬件原理</span><a href="#1-lcd-ying-jian-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</span><a href="#1-1-lcd-xiang-su-sao-miao" class="header-anchor">#</a></h2><p>里面的每个点就是一个像素点。</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/1.jpg"></p><p>它里面有一个电子枪，一边移动，一边发出各种颜色的光。用动态图表示如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/2.jpg"></p><ol><li><p>电子枪是如何移动的？</p><pre><code> 有一条CLK时钟线与LCD相连，每发出一次CLK(高低电平)，电子枪就移动一个像素。</code></pre></li><li><p>颜色如何确定？</p><pre><code> 由连接LCD的三组线RGB三原色混合而成：R(Red)、G(Green)、B(Blue)确定。</code></pre></li><li><p>电子枪如何得知应跳到下一行？</p><pre><code> 有一条HSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到下一行，该信号叫做行同步信号。</code></pre></li><li><p>电子枪如何得知应跳到原点？</p><pre><code> 有一条VSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到原点，该信号叫做帧同步信号。</code></pre></li><li><p>RGB线上的数据从何而来？</p><pre><code> 内存里面划分一块显存(FrameBuffer)，里面存放了要显示的数据，LCD控制器从里面将数据读出来，通过RGB三组线传给电子枪，电子枪再依次打到显示屏上。</code></pre></li><li><p>前面的信号由谁发给LCD？</p><pre><code> 有S3C2440里面的LCD控制器来控制发出信号。</code></pre></li></ol><h2><span id="1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</span><a href="#1-2-lcd-ying-jian-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/3.png"></p><p>①是时钟信号，每来一个CLK，电子枪就移动一个像素；</p><p>②是用来传输颜色数据；</p><p>③是垂直方向同步信号，FRAME(帧)；</p><p>④是水平方向同步信号，LINE(行)；</p><p>⑤LED+、LED-背光灯电源。</p><p>⑥TSYP、TSXP、TSYM、TSXM是触摸屏信号，暂时不用。</p><p>⑦VM接DE是数据使能</p><h3><span id="1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</span><a href="#1-2-1-rgb-lcd-mo-shi" class="header-anchor">#</a></h3><p>HV模式: HS与VS来控制刷新。比如对于分辨率为1024x600RGB的LCD，LCD控制器发出HS信号后，就会发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个HS信号后，就会发出一个VS信号<br>DE模式：DE信号来控制刷新，比如对于分辨率为1024x600RGB的LCD，LCD控制器发出DE信号后，就要发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个DE信号，刷新完一帧数据</p><h3><span id="1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</span><a href="#1-2-2-lcd-shi-xu-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/4.png" alt="image"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/5.png"></p><p>①从一行最开始的像素开始分析，如上图标号①，DE信号开始有效，电子枪每次在CLK下降沿时从数据线Dn0-Dn7上得到数据（Dn0-Dn7上的数据来源于FrameBuffer，后面会讲），然后发射到显示屏上，然后移动到下一个位置。从<em>1 st pixel</em>到<em>last pixel</em>，就这样从一行的最左边，一直移动到一行的最右边，完成了一行的显示，假设一行有x个pixel。可以看到每发送一个pixel，需要1个时钟周期（1&#x2F;tc）。</p><p>②当打完一行的最后一个数据后，会收到Hsync行同步信号，那么电子枪会跳到下一行，如上图标号②，根据时序图，一个Hsync周期，也就是一行数据刷新时间th, 可以大致分为五部分组成：thp、thb、1&#x2F;tc、thd、thf。<br>    thp:称为脉冲宽度，这个时间不能太短，太短电子枪可能识别不到。<br>    thb:电子枪正确识别到thp后，会从最右端移动最左端，这个移动的时间就是thb，称之为移动时间。<br>    thd：表示显示一行数据的时间<br>    thf：表示显示完最右像素，再过多久Hsync才来。</p><p>③同理，当电子枪移动到最后一行时，就会发送一个Vsync垂直同步信号，让电子枪移动回最上边。如上图标号③，根据时序图，一个Vsync周期，也就是一帧数据刷新时间tv, 可以大致分为：tvp、tvb、tvd、tvf。<br>    tvp:Vsync信号的脉冲宽度<br>    tvb：电子枪从最后一行移动到第一行的移动时间<br>    tvf：表示显示完最后一行像素，再过多久Vsync才来。</p><p> 假设一共有y行，那么LCD的分辨率就是x*y。</p><p>下面是LCD显示配置示意图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/6.png"></p><p>从左往右看，可以看到Total width &#x3D; HSYNC width + HBP + Active width + HFP。当发出一个HSYNC信号后，电子枪就会从最右边花费HBP时长移动到最左边，等到了最右边后，等待HFP时长后下一轮HSYNC信号才会发出。因此，HBP和HFP分别决定了左边和右边的黑框。</p><pre><code> HSYNC是行同步信号的脉冲宽度（低电平有效） HBP表示屏幕左边黑框的宽度（电子枪要花多久才能从最右边移动到最左边）行后肩 Active width表示有效数据宽度 HFP表示屏幕右边黑框的宽度（再过多久HSYNC才会发出）行前肩</code></pre><p>同理从上往下看，Total height &#x3D; Vsync width + VBP + Active width + VFP。当发出一个VSYNC信号后，电子枪就会从最下边花费VBP时长移动到最上边，等到了最下边后，等待VFP时长后下一轮VSYNC信号才会发出。因此，VBP和VFP分别决定了上边和下边的黑框。 中间灰色区域才是有效显示区域。</p><pre><code>VSYNC是帧同步信号的脉冲宽度（低电平有效）VBP表示屏幕上边黑框的宽度（电子枪要花多久才能从最后一行移动到最上面一行）帧后肩Active height表示有效数据高度VFP表示屏幕下边黑框的宽度(再过多久VSYNC才会发出) 帧前肩</code></pre><p>总结：</p><h4><span id="1-2-2-1-xing-shi-xu">1.2.2.1 行时序</span><a href="#1-2-2-1-xing-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/7.png" alt="image"></p><pre><code>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。</code></pre><h4><span id="1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</span><a href="#1-2-2-2-zheng-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/8.png" alt="image"></p><pre><code>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。</code></pre><h2><span id="1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</span><a href="#1-2-framebuffer-he-bpp-gai-nian" class="header-anchor">#</a></h2><p>FrameBuffer是在内存中的一段区域，这段区域专门用来存放颜色数据的。如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/9.png"></p><p>BPP(Bits Per Pixels)表示每个像素占据多少位。 前面的LCD引脚功能图里，有R0-R7、G0-G7、B0-B7，那么每个像素是占据3<em>8&#x3D;24位的，*<em>所以硬件上LCD的BPP是确定的.</em></em></p><p>那么在FrameBuffer中，每个像素在FrameBuffer中，占据多少位BPP(Bits Per Pixels)？</p><p>虽然LCD上的引脚是固定的，但我们使用的时候，可以根据实际情况进行取舍，查看我们的硬件原理图，发现我们的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以每个像素就只占据16位数据。等效连接图如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/10.png"></p><h2><span id="1-3-lcd-chong-lei">1.3 LCD种类</span><a href="#1-3-lcd-chong-lei" class="header-anchor">#</a></h2><p>S3C2440芯片手册介绍了LCD控制器支持TFT和STN两种LCD，我们常用的都是TFT材质的，本开发板采用的就是一款TFT材质的LCD.</p><h2><span id="1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</span><a href="#1-4-lcd-fang-wen-kuang-jia" class="header-anchor">#</a></h2><p>如下图，LCD控制器从SDRAM中的FrameBuffer区域取出颜色数据，发送给电子枪，电子枪按照特定的时钟周期将颜色数据显示在LCD上。<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/11.png"></p><h1><span id="2-lcd-kong-zhi-qi">2 LCD控制器</span><a href="#2-lcd-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</span><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/12.png"></p><p>S3C2440 LCD控制器用于传输视频数据并且生成必要的控制信号，如VFRAME，VLINE，VCLK，VM等。除了控制信号，S3C2440还有视频数据端口，即VD [23：0]。通过设置REGBANK(寄存器组)，LCDCDMA会自动(无需CPU参与)把内存上FrameBuffer里的数据，通过VIDPRCS发送到引脚VD[23:0]数据总线上，再配合VIDEOMUX引脚的控制信号，正确的显示出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REGBANK：具有<span class="number">17</span>个可编程寄存器组和<span class="number">256</span>x16调色板存储器，用于配置LCD控制器。 </span><br><span class="line">TIMEGEN：产生控制信号，例如 VSYNC、HSYNC、VCLK等信号</span><br><span class="line">LCDCDMA：可以自动从FrameBuff中把数据copy出来。</span><br><span class="line">VIDPRCS：从LCDCDMA接收视频数据，将数据输出到VD[<span class="number">23</span>:<span class="number">0</span>]数据总线上。</span><br></pre></td></tr></table></figure><p>总结LCD控制器主要功能如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 取：从内存(FrameBuffer)取出某个像素的数据（之后需要把FrameBuffer地址、BPP、分辨率告诉LCD控制器）</span><br><span class="line"><span class="number">2.</span> 发：配合其它信号把FrameBuffer中的数据发给LCD；（那么需要设置LCD控制器时序、设置引脚极性）</span><br></pre></td></tr></table></figure><h2><span id="2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</span><a href="#2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><h3><span id="2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</span><a href="#2-2-1-shu-ju-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>可以配置寄存器的BSWP、HWSWP来设置Framebuff中的像素存储格式。</p><h4><span id="2-2-1-1-bswp-x2f-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</span><a href="#2-2-1-1-bswp-x2f-hwswp-ji-cun-qi" class="header-anchor">#</a></h4><h5><span id="2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</span><a href="#2-2-2-1-1-24bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/13.png"></p><p>从图中可以看到24bpp的像素，在lcd控制器的VD[7:0]表示BLUE， VD[15:8]表示GREEN，VD[23:16]表示RED。在内存中的FrameBuffer中每一个像素占据4个字节，当BPP24BL&#x3D;0时，低24位为颜色数据，当BPP24BL&#x3D;1时，高24位为颜色数据。</p><h5><span id="2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</span><a href="#2-2-2-1-2-16bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/14.png"></p><p>也可以看到16bpp的像素，在内存中的FrameBuffer中每一个像素占据2个字节，HWSWP用来设置像素数据的存放方式。</p><p>再看下LCD控制器的VD引脚输出情况，可以看到16bpp时分5:6:5和5：5：5：i两种数据格式。当5：6：5模式时，VD[7:3]表示BLUE， VD[15:10]表示Green数据，VD[23:19]表示RED。当5：5:5：i模式时，VD[7:3]表示BLUE， VD[15:11]表示Green，VD[23:19]表示RED。其中i表示透明度。</p><h5><span id="2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</span><a href="#2-2-2-1-3-8bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/15.png"></p><h3><span id="2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</span><a href="#2-2-2-diao-se-ban-ji-cun-qi" class="header-anchor">#</a></h3><p>我们外接的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以LCD上每个像素就只占据16位数据。那么当我们的Frame buffer中是8BPP颜色数据时，是如何把颜色数据填充到LCD上的呢？</p><p><code>用调色板</code></p><p>S3C2440A 中的 TFT LCD 控制器支持 1、2、4 或 8bpp调色显示（伪彩色）和16、24bpp无调色显示（真彩色）。S3C2440A 可以支持 256 色调色板给各种色彩映射的选择，以提供灵活操作给用户。</p><p>假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上，如下图所示：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/16.png"></p><p>那么当8BPP的数据时，就需要用到调色板，调色板里存放了256个16bit的数据，FB(frame buffer)只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，比如从FB中的第0个元素拿到调色板中的第0个16bit数据，再通过电子枪显示出来，如下图所示：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/17.png"></p><p>调色板支持 5:6:5（R:G:B）格式和 5:5:5:I（R:G:B:I）格式。当用户使用5:5:5:I格式时，I表示强度，也就是透明度。I是用作每个RGB 数据的共用 LSB 位，因此 5:5:5:I与R(5+I):G(5+I):B(5+I)格式相同。</p><h4><span id="2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</span><a href="#2-2-2-1-diao-se-ban-ge-shi" class="header-anchor">#</a></h4><p>0x4D000400为调色板起始地址:</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/18.png"></p><h3><span id="2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</span><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/19.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">27</span>:<span class="number">18</span>]为只读数据位，不需要设置；</span><br><span class="line">[<span class="number">17</span>:<span class="number">8</span>]设置CLKVAL(像素时钟频率)，我们使用的是TFT屏，因此采用的公式是VCLK = HCLK / [(CLKVAL+<span class="number">1</span>) x <span class="number">2</span>]，其中HCLK为<span class="number">100</span>M。LCD手册里面Clock cycle的要求范围为<span class="number">5</span><span class="number">-12</span>MHz即可，那么取VCLK=<span class="number">9</span>，根据公式<span class="number">9</span>=<span class="number">100</span>/[(CLKVAL+<span class="number">1</span>)x2],算出CLKVAL≈<span class="number">4.5</span>=<span class="number">5</span>，设置CLKVAL=<span class="number">5</span>。</span><br><span class="line">[<span class="number">7</span>]不用管，默认即可；</span><br><span class="line">[<span class="number">6</span>:<span class="number">5</span>]TFT lcd配置为<span class="number">0b11</span>；</span><br><span class="line">[<span class="number">4</span>:<span class="number">1</span>]设置bpp模式，用户可选</span><br><span class="line">[<span class="number">0</span>]LCD输出使能，先暂时关闭不输出；</span><br></pre></td></tr></table></figure><h3><span id="2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</span><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/20.png"></p><p>s3c2440 LCD控制器时序图如下：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/21.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">31</span>:<span class="number">24</span>] : VBPD = tvb - <span class="number">1</span> （表示显示完最后一行像素，再过多久Vsync才来，表示上边黑框）</span><br><span class="line">[<span class="number">23</span>:<span class="number">14</span>] : LINEVAL = 每帧有多少行 - <span class="number">1</span> </span><br><span class="line">[<span class="number">13</span>:<span class="number">6</span>]  : VFPD = tvf - <span class="number">1</span>（下边黑框）</span><br><span class="line">[<span class="number">5</span>:<span class="number">0</span>]  : VSPW = tvp - <span class="number">1</span> （Vsync信号的脉冲宽度）</span><br></pre></td></tr></table></figure><h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/22.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>:<span class="number">19</span>] : HBPD = thb - <span class="number">1</span>（左边黑框）</span><br><span class="line">[<span class="number">18</span>:<span class="number">8</span>]  : HOZVAL = 每行有多少列 - <span class="number">1</span></span><br><span class="line">[<span class="number">7</span>:<span class="number">0</span>]  : HFPD = thf - <span class="number">1</span> （右边黑框）</span><br></pre></td></tr></table></figure><h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/23.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>:<span class="number">0</span>]: HSPW = thp - <span class="number">1</span> (Hsync信号的脉冲宽度)</span><br></pre></td></tr></table></figure><h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/24.png"></p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/25.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>] : BPP24BL（表示<span class="number">24b</span>pp的数据是大端还是小端）</span><br><span class="line">[<span class="number">11</span>] : FRM565 （数据存放格式）</span><br><span class="line">[<span class="number">10</span>] : INVVCLK（时钟是否反转极性，当配置成<span class="number">0</span>时数据在时钟下降沿被锁存）</span><br><span class="line">[<span class="number">9</span>]  : HSYNC是否反转</span><br><span class="line">[<span class="number">8</span>]  : VSYNC是否反转</span><br><span class="line">[<span class="number">7</span>]  : INVVD, rgb是否反转</span><br><span class="line">[<span class="number">6</span>]  : INVVDEN</span><br><span class="line">[<span class="number">5</span>]  : INVPWREN</span><br><span class="line">[<span class="number">4</span>]  : INVLEND</span><br><span class="line">[<span class="number">3</span>]  : PWREN(LCD_PWREN output signal enable/disable)</span><br><span class="line">[<span class="number">2</span>]  : ENLEND</span><br><span class="line">[<span class="number">1</span>]  : BSWP</span><br><span class="line">[<span class="number">0</span>]  : HWSWP</span><br></pre></td></tr></table></figure><h3><span id="2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</span><a href="#2-2-6-lcdsaddr1-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的起始地址寄存器：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/26.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">29</span>:<span class="number">21</span>] : LCDBANK, A[<span class="number">30</span>:<span class="number">22</span>] of fb</span><br><span class="line">[<span class="number">20</span>:<span class="number">0</span>]  : LCDBASEU, A[<span class="number">21</span>:<span class="number">1</span>] of fb</span><br><span class="line">即[<span class="number">29</span>:<span class="number">0</span>]表示Frame buffer的起始地址的[<span class="number">30</span>:<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><h3><span id="2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</span><a href="#2-2-7-lcdsaddr2-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的结束地址寄存器：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/27.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">0</span>] : LCDBASEL，A[<span class="number">21</span>:<span class="number">1</span>] of end addr,即framebuffer的结束地址。</span><br></pre></td></tr></table></figure><h1><span id="3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</span><a href="#3-lcd-luo-ji-bian-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-ruan-jian-kuang-jia">3.1 软件框架</span><a href="#3-1-ruan-jian-kuang-jia" class="header-anchor">#</a></h2><p>为了让程序更加好扩展，体现出<strong>高内聚、低耦合</strong>的特点，能够兼容各种不同型号的lcd，假如有两款尺寸大小的lcd，如何快速的在两个lcd上切换？</p><p>首先我们抽象出lcd_3.5.c和lcd_4.3.c的共同点，比如都有初始化函数init(),我们可以新建一个lcd.c，然后定义一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_opr</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户不接触lcd_3.5.c和lcd_4.3.c，只需要在lcd.c里通过指针访问对应的结构体的函数，也就调用了不同init():</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/28.jpg" alt="img"></p><p>我们的目的是在LCD显示屏上画线、画圆(geomentry.c)和写字(font.c)其核心是画点(farmebuffer.c)，这些都属于纯软件。此外还需要一个lcd_test.c测试程序提供操作菜单，调用画线、画圆和写字操作。</p><p>往下操作的是LCD相关的内容，不同的LCD，其配置的参数也会不一样，通过lcd_3.5.c或lcd_4.3.c来设置属性参数。</p><p>根据LCD的特性，来设置LCD控制器，首先编写lcd_controller.c，它向上要接收不同LCD的参数，向下要使用这些参数设置对应具体的某一款LCD控制器。</p><p>对于我们开发板，就是s3c2440_lcd_controller.c，假如希望在其它开发板上也实现LCD显示，只需添加相应的代码文件即可。文件自上而下的框架如下：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/29.jpg"></p><h2><span id="3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</span><a href="#3-2-shu-ju-jie-gou-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</span><a href="#3-2-1-lcd-she-bei-jie-gou-ti" class="header-anchor">#</a></h3><p>我们知道LCD的参数属性有：引脚的极性、时序、数据的格式bpp、分辨率等，使用面向对象的思维方式，将这些封装成结构体放在lcd.h中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">NORMAL = <span class="number">0</span>,</span><br><span class="line">INVERT = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NORMAL : 正常极性</span></span><br><span class="line"><span class="comment"> * INVERT : 反转极性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pins_polarity</span> &#123;</span></span><br><span class="line"><span class="type">int</span> vclk;  <span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line"><span class="type">int</span> rgb;   <span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line"><span class="type">int</span> hsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line"><span class="type">int</span> vsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">&#125; pins_polarity, *p_pins_polarity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">time_sequence</span> &#123;</span></span><br><span class="line"><span class="comment">/* 垂直方向 */</span></span><br><span class="line"><span class="type">int</span> tvp; <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line"><span class="type">int</span> tvb; <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line"><span class="type">int</span> tvf; <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line"><span class="comment">/* 水平方向 */</span></span><br><span class="line"><span class="type">int</span> thp; <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line"><span class="type">int</span> thb; <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line"><span class="type">int</span> thf; <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line"><span class="type">int</span> vclk;</span><br><span class="line">&#125; time_sequence, *p_time_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_params</span> &#123;</span></span><br><span class="line"><span class="comment">/* 引脚极性 */</span></span><br><span class="line">pins_polarity pins_pol;</span><br><span class="line"><span class="comment">/* 时序 */</span></span><br><span class="line">time_sequence time_seq;</span><br><span class="line"><span class="comment">/* 分辨率, bpp */</span></span><br><span class="line"><span class="type">int</span> xres;</span><br><span class="line"><span class="type">int</span> yres;</span><br><span class="line"><span class="type">int</span> bpp;</span><br><span class="line"><span class="comment">/* framebuffer的地址 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line">&#125; lcd_params, *p_lcd_params;</span><br></pre></td></tr></table></figure><h2><span id="3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</span><a href="#3-3-cao-zuo-fang-fa-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1  LCD操作方法-lcd_controller.c</span><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c" class="header-anchor">#</a></h3><p>我们知道在c++中是面向对象编程的，那么一个对象就有它的属性和方法，LCD属性我们上面已经定义好了，那么方法我们可以定义一个lcd_controller.c用来控制管理LCD，定义个一个lcd_controller.h, struct lcd_controller结构体放置lcd对象的一些成员函数，即对象的方法，或者称之为对象的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*init)(p_lcd_params plcdparams);</span><br><span class="line">    <span class="type">void</span> (*enable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*disable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*init_palette)(<span class="type">void</span>);</span><br><span class="line">&#125; lcd_controller, *p_lcd_controller;</span><br></pre></td></tr></table></figure><p>那么lcd_controller.c相当于一个管理者，会去选择具体型号的LCD对象去执行具体的成员函数，比如管理s3c2440_lcd_controller.c，它向上接受传入的LCD参数，向下传给具体的LCD控制器。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">    <span class="comment">/* 调用2440的LCD控制器的初始化函数，lcd_controller是一个被选中的对象，即s3c2440_lcd_controller*/</span></span><br><span class="line">    lcd_controller.init(plcdparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在s3c2440_lcd_controller.c再构造一个具体的lcd对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">.name    = xxx,</span><br><span class="line">.init    = xxx,</span><br><span class="line">.enalbe  = xxx,</span><br><span class="line">.disable = xxx,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>lcd_controller.c代码框架如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CONTROLLER_NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> p_lcd_controller p_array_lcd_controller[LCD_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_controller g_p_lcd_controller_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd_controller</span><span class="params">(p_lcd_controller plcdcon)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!p_array_lcd_controller[i]) &#123;</span><br><span class="line">p_array_lcd_controller[i] = plcdcon;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p_array_lcd_controller[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd_controller[i]-&gt;name, name)) &#123;</span><br><span class="line">g_p_lcd_controller_selected = p_array_lcd_controller[i];</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向上: 接收不同LCD的参数</span></span><br><span class="line"><span class="comment"> * 向下: 使用这些参数设置对应的LCD控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line"><span class="comment">/* 调用所选择的LCD控制器的初始化函数 */</span></span><br><span class="line"><span class="keyword">if</span> (g_p_lcd_controller_selected) &#123;</span><br><span class="line">g_p_lcd_controller_selected-&gt;init(plcdparams);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">g_p_lcd_controller_selected-&gt;enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">g_p_lcd_controller_selected-&gt;disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面详细分析lcd_controller.c框架的含义以及作用：</p><ol><li>开始定义了一个p_array_lcd_controller数组和g_p_lcd_controller_selected，p_array_lcd_controller数组表示lcd控制器的集合，g_p_lcd_controller_selected表示被选中的那一个lcd_controller;</li><li>当我们初始化时要先调用register_lcd_controller，select_lcd_controller选中具体的lcd_controller；</li><li>然后才能调用lcd_controller_init初始化具体的lcd_controller，去控制具体型号的lcd。</li></ol><p>同理，也通过lcd.c去管理lcd_4.3.c,思路如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 有一个数组存放各类lcd的参数；</span><br><span class="line">b. 有一个register_lcd给下面的lcd程序来设置数组；</span><br><span class="line">c. 有一个select_lcd，供上层选择某款LCD；</span><br></pre></td></tr></table></figure><h3><span id="3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</span><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c" class="header-anchor">#</a></h3><p>参考前面的lcd_controller.c编辑lcd.c如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_NUM 10</span></span><br><span class="line"><span class="type">static</span> p_lcd_params p_array_lcd[LCD_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_params g_p_lcd_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd</span><span class="params">(p_lcd_params plcd)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!p_array_lcd[i]) &#123;</span><br><span class="line">p_array_lcd[i] = plcd;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p_array_lcd[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd[i]-&gt;name, name)) &#123;</span><br><span class="line">g_p_lcd_selected = p_array_lcd[i];</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-4-lcd-chu-shi-hua">3.4 LCD初始化</span><a href="#3-4-lcd-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</span><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</span><a href="#3-4-1-1-chu-shi-hua-yin-jiao" class="header-anchor">#</a></h4><h5><span id="3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</span><a href="#3-4-1-1-1-bei-guang-yin-jiao" class="header-anchor">#</a></h5><p>我们配置LCD的背光引脚成输出模式：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/30.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPBCON &amp;= ~<span class="number">0x3</span>;</span><br><span class="line">GPBCON |= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure><h5><span id="3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</span><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao" class="header-anchor">#</a></h5><p>然后再配置LCD的控制引脚和数据引脚，LCD控制引脚和数据引脚分别复用了GPC和GPD，如下图所示：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/31.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/32.png"></p><p>设置GPC, GPD均为0xaaaa,aaaa。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LCD专用引脚 */</span></span><br><span class="line">GPCCON = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">GPDCON = <span class="number">0xaaaaaaaa</span>;</span><br></pre></td></tr></table></figure><h5><span id="3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</span><a href="#3-4-1-1-3-pwren-yin-jiao" class="header-anchor">#</a></h5><p>设置GPG4成PWREN引脚</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/33.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/34.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPGCON |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);</span><br></pre></td></tr></table></figure><h4><span id="3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</span><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>前面介绍了LCDCON1，LCDCON2，LCDCON3…LCDSADDR1等寄存器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line"><span class="comment">/* [17:8]: CLKVAL, vclk = HCLK / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment"> *                   如：9   = 100M /[(CLKVAL+1) x 2], 所以CLKVAL = 4.5 = 5</span></span><br><span class="line"><span class="comment"> *                 CLKVAL = 100/vclk/2-1</span></span><br><span class="line"><span class="comment"> * [6:5]: 0b11, tft lcd</span></span><br><span class="line"><span class="comment"> * [4:1]: bpp mode</span></span><br><span class="line"><span class="comment"> * [0]  : LCD video output and the logic enable/disable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> clkval = (<span class="type">double</span>)HCLK/plcdparams-&gt;time_seq.vclk/<span class="number">2</span><span class="number">-1</span>+<span class="number">0.5</span>;</span><br><span class="line"><span class="type">int</span> bppmode = plcdparams-&gt;bpp == <span class="number">8</span>  ? <span class="number">0xb</span> :\</span><br><span class="line">  plcdparams-&gt;bpp == <span class="number">16</span> ? <span class="number">0xc</span> :\</span><br><span class="line">  <span class="number">0xd</span>;  <span class="comment">/* 0xd: 24bpp */</span></span><br><span class="line">LCDCON1 = (clkval&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (bppmode&lt;&lt;<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* [31:24] : VBPD    = tvb - 1</span></span><br><span class="line"><span class="comment"> * [23:14] : LINEVAL = line - 1</span></span><br><span class="line"><span class="comment"> * [13:6]  : VFPD    = tvf - 1</span></span><br><span class="line"><span class="comment"> * [5:0]   : VSPW    = tvp - 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LCDCON2 = ((plcdparams-&gt;time_seq.tvb - <span class="number">1</span>)&lt;&lt;<span class="number">24</span>) | \</span><br><span class="line">            ((plcdparams-&gt;yres - <span class="number">1</span>)&lt;&lt;<span class="number">14</span>)         | \</span><br><span class="line">((plcdparams-&gt;time_seq.tvf - <span class="number">1</span>)&lt;&lt;<span class="number">6</span>)  | \</span><br><span class="line">((plcdparams-&gt;time_seq.tvp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* [25:19] : HBPD = thb - 1</span></span><br><span class="line"><span class="comment"> * [18:8]  : HOZVAL  = 列 - 1</span></span><br><span class="line"><span class="comment"> * [7:0]   : HFPD = thf - 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LCDCON3 =((plcdparams-&gt;time_seq.thb - <span class="number">1</span>)&lt;&lt;<span class="number">19</span>) | \</span><br><span class="line">((plcdparams-&gt;xres - <span class="number">1</span>)&lt;&lt;<span class="number">8</span>)      | \</span><br><span class="line">((plcdparams-&gt;time_seq.thf - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * [7:0]   : HSPW = thp - 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">LCDCON4 =((plcdparams-&gt;time_seq.thp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用来设置引脚极性, 设置16bpp, 设置内存中象素存放的格式</span></span><br><span class="line"><span class="comment">     * [12] : BPP24BL</span></span><br><span class="line"><span class="comment"> * [11] : FRM565, 1-565</span></span><br><span class="line"><span class="comment"> * [10] : INVVCLK, 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment"> * [9]  : HSYNC是否反转</span></span><br><span class="line"><span class="comment"> * [8]  : VSYNC是否反转</span></span><br><span class="line"><span class="comment"> * [7]  : INVVD, rgb是否反转</span></span><br><span class="line"><span class="comment"> * [6]  : INVVDEN</span></span><br><span class="line"><span class="comment"> * [5]  : INVPWREN</span></span><br><span class="line"><span class="comment"> * [4]  : INVLEND</span></span><br><span class="line"><span class="comment"> * [3]  : PWREN, LCD_PWREN output signal enable/disable</span></span><br><span class="line"><span class="comment"> * [2]  : ENLEND</span></span><br><span class="line"><span class="comment"> * [1]  : BSWP</span></span><br><span class="line"><span class="comment"> * [0]  : HWSWP</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">pixelplace = plcdparams-&gt;bpp == <span class="number">24</span> ? (<span class="number">0</span>) : |\</span><br><span class="line">             plcdparams-&gt;bpp == <span class="number">16</span> ? (<span class="number">1</span>) : |\</span><br><span class="line">             (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);  <span class="comment">/* 8bpp */</span></span><br><span class="line">LCDCON5 = (plcdparams-&gt;pins_pol.vclk&lt;&lt;<span class="number">10</span>) |\</span><br><span class="line">          (plcdparams-&gt;pins_pol.rgb&lt;&lt;<span class="number">7</span>)   |\</span><br><span class="line">          (plcdparams-&gt;pins_pol.hsync&lt;&lt;<span class="number">9</span>) |\</span><br><span class="line">          (plcdparams-&gt;pins_pol.vsync&lt;&lt;<span class="number">8</span>) |\</span><br><span class="line">   (plcdparams-&gt;pins_pol.de&lt;&lt;<span class="number">6</span>)    |\</span><br><span class="line">  (plcdparams-&gt;pins_pol.pwren&lt;&lt;<span class="number">5</span>) |\</span><br><span class="line">  (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | pixelplace;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* framebuffer地址 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * [29:21] : LCDBANK, A[30:22] of fb</span></span><br><span class="line"><span class="comment"> * [20:0]  : LCDBASEU, A[21:1] of fb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addr = plcdparams-&gt;fb_base &amp; ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">LCDSADDR1 = (addr &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * [20:0] : LCDBASEL, A[21:1] of end addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addr = plcdparams-&gt;fb_base + plcdparams-&gt;xres*plcdparams-&gt;yres*plcdparams-&gt;bpp/<span class="number">8</span>;</span><br><span class="line">addr &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">addr &amp;= <span class="number">0x1fffff</span>;</span><br><span class="line">LCDSADDR2 = addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</span><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao" class="header-anchor">#</a></h4><p>根据背光电路背光引脚是GPB0，那么配置GPBDAT[0]置1，使能背光引脚，设置LCDCON5和<br>LCDCON1使能power enable和LCD输出，反之。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_enalbe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">GPBDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* pwren    : 给LCD提供AVDD  */</span></span><br><span class="line">LCDCON5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">LCDCON1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="comment">/* pwren: 给LCD提供AVDD  */</span></span><br><span class="line">LCDCON5 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"><span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">LCDCON1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的s3c2440的lcd控制器初始化就编写完了，那么用户只要调用s3c2440_lcd_controller_init去设置LCD的属性即可。下面开始介绍如何设置LCD属性，让LCD控制器能够适应具体型号的LCD。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">.name    = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">.init    = s3c2440_lcd_controller_init,</span><br><span class="line">.enable  = s3c2440_lcd_controller_enalbe,</span><br><span class="line">.disable = s3c2440_lcd_controller_disable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</span><a href="#3-4-2-chu-shi-hua-lcd-she-bei" class="header-anchor">#</a></h3><p>参考AT043TN24 LCD数据手册上的参数性能，见下表：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/35.png"></p><p>配置lcd_params属性如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_FB_BASE 0x33c00000</span></span><br><span class="line">lcd_params lcd_4_3_params = &#123;</span><br><span class="line">.name = <span class="string">&quot;lcd_4.3&quot;</span></span><br><span class="line">.pins_polarity = &#123;</span><br><span class="line">.de    = NORMAL,<span class="comment">/* normal: 高电平时可以传输数据 */</span></span><br><span class="line">.vclk  = NORMAL,<span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">.rgb   = NORMAL,<span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">.hsync = INVERT,    <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">.vsync = INVERT, <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">&#125;,</span><br><span class="line">.time_sequence = &#123;</span><br><span class="line"><span class="comment">/* 垂直方向 */</span></span><br><span class="line">.tvp=<span class="number">10</span>, <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">.tvb=<span class="number">2</span>,  <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">.tvf=<span class="number">2</span>,  <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 水平方向 */</span></span><br><span class="line">.thp=<span class="number">41</span>, <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">.thb=<span class="number">2</span>,  <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">.thf=<span class="number">2</span>,  <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line"></span><br><span class="line">.vclk=<span class="number">9</span>,  <span class="comment">/* MHz */</span></span><br><span class="line">&#125;,</span><br><span class="line">.xres = <span class="number">480</span>,</span><br><span class="line">.yres = <span class="number">272</span>,</span><br><span class="line">.bpp  = <span class="number">16</span>,</span><br><span class="line">.fb_base = LCD_FB_BASE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.de表示数据输出使能引脚，高电平有效，所以配置成NORMAL；</span><br><span class="line">.pwren表示LCD_PWREN引脚，高电平有效；</span><br><span class="line">.vclk表示LCD的时钟，从手册的LCD时序图中可以看到下降沿有效，所以配置NORMAL；</span><br><span class="line">.rgb表示颜色数据的引脚极性，高电平表示<span class="number">1</span>，配置成NORMAL；</span><br><span class="line">.hsync表示行同步信号，normal表示高脉冲，参考手册发现该信号低脉冲有效，所以配置成INVERT；</span><br></pre></td></tr></table></figure><p>什么是高低脉冲？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高脉冲：即从逻辑<span class="number">0</span>变化bai到逻辑du1再变化到逻辑<span class="number">0</span>，如此便是一个高脉zhi冲。在单片机中定义高脉冲就是让某个I/O先输出逻辑<span class="number">0</span>，接着保持一定的时间（延时），再输出逻辑<span class="number">1</span>，同样保持一定的时间（延时），最后再转变输出为逻辑<span class="number">0</span>+延时。</span><br><span class="line">低脉冲：反之</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vsync表示帧同步信号，同.hsync；</span><br><span class="line">.time_sequence时序设置参考上表配置。我们看到thf + thp + thb = <span class="number">2</span> + <span class="number">41</span> +<span class="number">2</span> = <span class="number">45</span> clk &gt; <span class="number">44</span> clk，满足上面的注意事项；</span><br><span class="line">.xres .yres表示分辨率</span><br><span class="line">.bpp表示像素点颜色模式</span><br><span class="line">.fb_base指定frame buffer的基地址</span><br></pre></td></tr></table></figure><p>那么最终LCD初始化函数封装如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 注册LCD,把具体的LCD属性配置下去 */</span></span><br><span class="line">register_lcd(&amp;lcd_4_3_params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册LCD控制器 */</span></span><br><span class="line">register_lcd_controller(&amp;s3c2440_lcd_controller);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择某款LCD */</span></span><br><span class="line">select_lcd(<span class="string">&quot;lcd_4.3&quot;</span>);</span><br><span class="line"><span class="comment">/* 选择某款LCD控制器 */</span></span><br><span class="line">select_lcd_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用LCD的参数, 初始化LCD控制器 */</span></span><br><span class="line">lcd_controller_init(g_p_lcd_selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：我们可以看到，调用的函数都是一些通用型框架型接口，具体的实现本质还得根据硬件本身的特性来配置寄存器来驱动硬件工作。</p><h2><span id="3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</span><a href="#3-5-shi-xian-xian-shi-gong-neng" class="header-anchor">#</a></h2><h3><span id="3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</span><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se" class="header-anchor">#</a></h3><p>想要在LCD上显示出数据，所需步骤如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 初始化LCD</span><br><span class="line">b. 使能LCD</span><br><span class="line">c. 获取LCD参数: fb_base, xres, yres, bpp</span><br><span class="line">d. 往framebuffer中写数据</span><br></pre></td></tr></table></figure><h4><span id="3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</span><a href="#3-5-1-1-chu-shi-hua-lcd" class="header-anchor">#</a></h4><p>前面已详细实现。</p><h4><span id="3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</span><a href="#3-5-1-2-shi-neng-lcd" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_enable</span><span class="params">()</span> &#123;</span><br><span class="line">lcd_controller_enalbe(); <span class="comment">//会间接调用s3c2440_lcd_controller_enalbe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</span><a href="#3-5-1-3-huo-qu-lcd-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</span><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju" class="header-anchor">#</a></h4><p>假设我们初始化配置了BPP&#x3D;16，那么如何让全屏显示红色？</p><p>就需要从framebuffer基地址开始的整个屏幕的像素点都填充红色值。 对于16BPP，RGB&#x3D;565，想显示红色，即[15:11]全为1表示红色，[10:5]全为0表示无绿色，[4:0]全为0表示无蓝色，0b1111100000000000&#x3D;0xF800。<br>以基地址为起点，分别以xres和yres为边界，依次填充颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">short</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">*p++ = <span class="number">0xf800</span>;</span><br></pre></td></tr></table></figure><p>假设我们初始化配置了BPP&#x3D;24 或者BPP &#x3D;32，那么如何让全屏显示红色？</p><p>其实无论是24bpp还是32bpp，在frame buffer中每个像素点都占4 bytes，对于24BPP or 32 bpp，即RGB:888，每个颜色占8位，一共占据24位。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">int</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line"><span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">*p++ = <span class="number">0xff0000</span>;</span><br></pre></td></tr></table></figure><p>当Frame buffer中填满颜色数据时，LCD控制器会参照我们之前的配置将数据填充到LCD显示器上。那前面的24BPP、32BPP是怎样在 只能接收16BPP(硬件上只有16根数据线)的LCD上显示的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是因为在使用<span class="number">24B</span>PP时，发出的<span class="number">8</span>条红色，<span class="number">8</span>条绿色，<span class="number">8</span>条蓝色数据，只用了高<span class="number">5</span>条红色，高<span class="number">6</span>条绿色，高<span class="number">5</span>条蓝色与LCD相连。（前面LCD硬件原理的FrameBuffer和BPP概念有讲）</span><br></pre></td></tr></table></figure><h2><span id="3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</span><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu" class="header-anchor">#</a></h2><h3><span id="3-6-1-hua-dian">3.6.1 画点</span><a href="#3-6-1-hua-dian" class="header-anchor">#</a></h3><p>无论是何种图形，都是基于点来构成的，因此我们需要先实现画点，其他的都是上层的一些数据处理了，像各种图形、甚至色彩鲜艳的图片无非都是一些由点构造出的数据而已。</p><p>我们在在farmebuffer.c实现画点，在geomentry.c实现画线、画圆等几何图形，font.c实现画字。</p><p>那么一个像素点要显示到lcd上，我们要知道它的位置坐标，然后还要知道它的颜色值，假设该像素点的坐标为（x,y）,那么该像素的地址为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（x,y）= fb_base + (xres*(bpp/<span class="number">8</span>))*y +x*bpp/<span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>那么所以在画点前需要先获取lcd参数：fb_base、xres、yres、bpp;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_get_lcd_params</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后画点函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>  *pc;  <span class="comment">/* 8bpp */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pw;  <span class="comment">/* 16bpp */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>   *pdw; <span class="comment">/* 32bpp */</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pixel_base = fb_base + (xres * bpp / <span class="number">8</span>) * y + x * bpp / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (bpp) &#123; <span class="comment">//根据像素不同bpp格式，在Frame buffer中存放方式不一样，但对用户来说，不关心颜色格式，通通当做32位色颜色处理，所以这里需要做格式转换</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">pc = (<span class="type">unsigned</span> <span class="type">char</span> *) pixel_base;</span><br><span class="line">*pc = color;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">pw = (<span class="type">unsigned</span> <span class="type">short</span> *) pixel_base;</span><br><span class="line">*pw = convert32bppto16bpp(color);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">pdw = (<span class="type">unsigned</span> <span class="type">int</span> *) pixel_base;</span><br><span class="line">*pdw = color;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户传入的颜色数据一般都是32bit的，即格式为：0x00RRGGBB。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于<span class="number">8</span>PP，通过的是调色板索引实现的，这个后续再讲解，直接*pc = color即可（这样只取了高<span class="number">8</span>位，低精度的数据就丢了）。</span><br><span class="line">对于<span class="number">16</span>PP，那么需要进行颜色转换后再存放进frame buffer。</span><br><span class="line">对于<span class="number">32</span>PP，大小刚好对应，直接*pc = color即可。</span><br></pre></td></tr></table></figure><h3><span id="3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</span><a href="#3-6-2-32bppto16bpp-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先分别取出RGB，再相应的清除低位数据，实现将RGB888变为RGB565</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">convert32bppto16bpp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rgb)</span> &#123;</span><br><span class="line"><span class="type">int</span> r = (rgb &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="type">int</span> g = (rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="type">int</span> b = rgb &amp; <span class="number">0xff</span>;</span><br><span class="line"><span class="comment">/* rgb565 */</span></span><br><span class="line">r = r &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">g = g &gt;&gt; <span class="number">2</span>;<span class="comment">//取低6位</span></span><br><span class="line">b = b &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line"><span class="keyword">return</span> ((r&lt;&lt;<span class="number">11</span>) | (g&lt;&lt;<span class="number">5</span>) | (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</span><a href="#3-6-3-hua-xian-hua-yuan" class="header-anchor">#</a></h3><p>画圆画线的具体原理不是本主题的重点，这些属于研究算法的范畴了，比如这里就有现成的算法可以用，如这篇博客：<a href="https://blog.csdn.net/p1126500468/article/details/50428613">https://blog.csdn.net/p1126500468/article/details/50428613</a>，里面有画圆画线的函数实现，直接使用就可以了，套用画点的”轮子”就可以了。</p><h3><span id="3-6-4-ce-shi">3.6.4 测试</span><a href="#3-6-4-ce-shi" class="header-anchor">#</a></h3><p>新建一个geometry.c，复制博客中代码，替换里面的描点显示函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 画线 */</span></span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xff0000</span>); <span class="comment">//(0,0) 到（xres - 1, 0）两点间的线</span></span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xffff00</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, yres - <span class="number">1</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff00aa</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff00ef</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff4500</span>);</span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff0780</span>);</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画圆 */</span></span><br><span class="line">draw_circle(xres/<span class="number">2</span>, yres/<span class="number">2</span>, yres/<span class="number">4</span>, <span class="number">0xff00</span>);</span><br></pre></td></tr></table></figure><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/36.jpg"></p><h2><span id="3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</span><a href="#3-7-zi-fu-ku-yi-zhi" class="header-anchor">#</a></h2><p>字符也是由点构成的，一个个点组成的点阵，其实本质上要显示文字就是把字库移植到对应的自己型号相匹配的board上，字库中的每一个字符都是一些点按照对应格式组合成的集合。</p><p>从linux内核源码中随便挑选一个字库文件，比如linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应的很多字库文件。在这里我挑选font_8x16.c，如下图：</p><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/37.png"></p><p>其中8x16表示每个字符所占的像素点的大小，表示每个字符占的大小为长*宽&#x3D;8*16个像素点。</p><p>我们来看下一个字符’A’是如何显示的？从font_8x16.c我们找到字符’A’的数据，如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/38.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/39.png"><br>那么我们如何让font_8x16.c这个字库的数据显示到lcd上呢？font_8x16.c见附件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a. 根据要显示的字符的ascii码作为索引，在fontdata_8x16中得到点阵数据</span></span><br><span class="line"><span class="comment">b. 根据点阵来设置对应象素的颜色</span></span><br><span class="line"><span class="comment">c. 根据点阵的某位决定是否描颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="comment">/* 根据c的ascii码作为索引在fontdata_8x16中得到点阵数据（fontdata_8x16是字库的数据集合）*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *dots = &amp;fontdata_8x16[c * <span class="number">16</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line"><span class="type">int</span> bit;</span><br><span class="line"><span class="comment">/* 根据点阵来设置对应象素的颜色 */</span></span><br><span class="line"><span class="keyword">for</span> (j = y; j &lt; y+<span class="number">16</span>; j++) &#123;</span><br><span class="line">data = *dots++;</span><br><span class="line">bit = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">for</span> (i = x; i &lt; x+<span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="comment">/* 根据点阵的某位决定是否描颜色 */</span></span><br><span class="line"><span class="keyword">if</span> (data &amp; (<span class="number">1</span>&lt;&lt;bit))</span><br><span class="line">fb_put_pixel(i, j, color);</span><br><span class="line">bit--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在font_8x16.c里面，每个字符占据16字节，因此想要根据ascii码找到对应的点阵数据，需要对应的乘16，再取地址，得到该字符的首地址。</p><p>在显示之前，还需要获取LCD参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> fontdata_8x16[];</span><br><span class="line"><span class="comment">/* 获得LCD参数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">font_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</span><a href="#3-7-1-xian-shi-zi-fu-chuan" class="header-anchor">#</a></h3><p>如果想显示字符串，那就在每显示完一个字符后，x轴加8即可，同时考虑是否超出屏幕显示范围进行换行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &quot;abc\n\r123&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_string</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>* str, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    <span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            y = y+<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fb_print_char(x, y, str[i], color);</span><br><span class="line">            x = x+<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= xres) &#123;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">                y = y+<span class="number">16</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-lcd-ying-jian-yuan-li&quot;&gt;1 LCD硬件原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-lcd-xiang-su-sao-miao&quot;&gt;1.1 </summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-SPI</title>
    <link href="http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/"/>
    <id>http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/</id>
    <published>2024-04-18T12:37:17.000Z</published>
    <updated>2024-04-19T05:46:16.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-spi-yuan-li">1 SPI原理</a><ul><li><a href="#1-1-spi-gai-nian">1.1 spi概念</a></li><li><a href="#1-2-ying-ti-kuang-jia">1.2 硬体框架</a></li><li><a href="#1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</a></li><li><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</a></li><li><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</a></li></ul></li><li><a href="#2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</a><ul><li><a href="#2-1-sspsr">2.1 SSPSR</a></li><li><a href="#2-2-sspbuf">2.2 SSPBUF</a></li><li><a href="#2-3-controller">2.3 Controller</a></li></ul></li><li><a href="#3-spi-luo-ji-shi-li">3 SPI裸机示例</a><ul><li><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</a><ul><li><a href="#3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</a></li><li><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</a></li><li><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</a></li><li><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</a></li><li><a href="#3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</a></li></ul></li><li><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</a><ul><li><a href="#3-2-1-fa-song-di-zhi">3.2.1 发送地址</a><ul><li><a href="#3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</a><ul><li><a href="#3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</a></li><li><a href="#3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</a></li></ul></li></ul></li><li><a href="#3-2-2-fa-song-shu-ju">3.2.2 发送数据</a></li></ul></li><li><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</a><ul><li><a href="#3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</a></li><li><a href="#3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</a><ul><li><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</a></li><li><a href="#3-3-2-2-xie-ming-ling">3.3.2.2 写命令</a><ul><li><a href="#3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</a></li></ul></li><li><a href="#3-3-2-3-xie-shu-ju">3.3.2.3 写数据</a></li></ul></li><li><a href="#3-2-3-oled-c">3.2.3 oled.c</a><ul><li><a href="#3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</a></li><li><a href="#3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</a></li></ul></li><li><a href="#3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-spi-yuan-li">1 SPI原理</span><a href="#1-spi-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-spi-gai-nian">1.1 spi概念</span><a href="#1-1-spi-gai-nian" class="header-anchor">#</a></h2><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p><p>特点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高速、同步、全双工、非差分、总线式</span><br><span class="line">主从机通信模式</span><br></pre></td></tr></table></figure><p>优点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">支持全双工通信（SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出）</span><br><span class="line">数据传输速率快（I2c一般只能到100-400Khz, SPI高达上百Mhz）</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据可靠性上有一定的缺陷</span><br></pre></td></tr></table></figure><h2><span id="1-2-ying-ti-kuang-jia">1.2 硬体框架</span><a href="#1-2-ying-ti-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/1.png" alt="img"></p><p>SCK：提供时钟<br>DO:作为数据输出<br>DI:作为数据输入<br>CS0&#x2F;CS1:作为片选</p><p>同一时刻只能有一个SPI设备处于工作状态。因此cs选中谁，谁就和主控通信。</p><h2><span id="1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</span><a href="#1-2-shu-ju-chuan-shu-shi-xu" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/2.png" alt="img"></p><p>这里是一款SPI flash在SCLK上升延采样数据（D7~D0）的示意图。设现在s3c2440传输一个0x56数据给SPI Flash，时序如下：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/3.png" alt="img"></p><p>CS0低选中SPI Flash，配置成模式0， 0x56的二进制就是0b0101 0110，因此在每个SCK时钟周期，DO输出对应的电平。会在<strong>每个时钟周期的上升沿采样DO上的电平</strong>。</p><h2><span id="1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</span><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie" class="header-anchor">#</a></h2><p><strong>KPOL</strong>： (Clock Polarity)（时钟）极性</p><p><strong>CKPHA</strong>： (Clock Phase)（时钟）相位</p><p><strong>SCK</strong>&#x3D;<strong>SCLK</strong>：SPI的时钟</p><p><strong>Leading edge</strong>：前一个边沿</p><p><strong>Trailing edge</strong>：后一个边沿</p><h2><span id="1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</span><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi" class="header-anchor">#</a></h2><p>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平</p><p>CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p><p>两者组合成4种模式：</p><table><thead><tr><th>SPI模式</th><th>CPOL</th><th>CPHA</th><th>空闲状态时钟极性</th><th>采样&#x2F;移位时钟相位</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>低电平</td><td>上升沿采样（锁存）下降沿移位</td></tr><tr><td>1</td><td>0</td><td>1</td><td>低电平</td><td>上升沿移位下降沿采样（锁存）</td></tr><tr><td>2</td><td>1</td><td>0</td><td>高电平</td><td>上升沿移位下降沿采样（锁存）</td></tr><tr><td>3</td><td>1</td><td>1</td><td>高电平</td><td>上升沿采样（锁存）下降沿移位</td></tr></tbody></table><p>4个模式波形对比：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/4.png" alt="img"></p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/5.png" alt="img"></p><p>常用的是<strong>模式0和模式3</strong>，因为它们都是在<strong>上升沿采样数据</strong>.当配置成模式3时，<strong>对于主设备，数据采样在时钟上升沿，数据传送在时钟下降沿****。</strong></p><p><strong>主设备SPI时钟和极性的配置应该由外设来决定；二者的配置应该保持一致，即主设备的SDO同从设备的SDO配置一致，主设备的SDI同从设备的SDI配置一致。即因为主从设备是在SCLK的控制下，同时发送和接收数据，并通过2个双向移位寄存器来交换数据 。</strong></p><p>举个例子，以 CPOL&#x3D;0，CPHA&#x3D;0，模式0为例：空闲CLK为低电平，相位为0，也就是上升延采集数据。由于SPI的全双工可以同时读写，发送MOSI数据为0xD2,接收MISO数据为0x66。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/6.png" alt="img"></p><h1><span id="2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</span><a href="#2-spi-kong-zhi-qi-jie-gou" class="header-anchor">#</a></h1><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/7.png" alt="img"></p><h2><span id="2-1-sspsr">2.1 SSPSR</span><a href="#2-1-sspsr" class="header-anchor">#</a></h2><p>SSPSR：移位寄存器(Shift Register). 根据 SPI 时钟同步信号, 将SSPBUF中的数据一位一位移出去或者收进来。</p><h2><span id="2-2-sspbuf">2.2 SSPBUF</span><a href="#2-2-sspbuf" class="header-anchor">#</a></h2><p>Master 与 Slave 之间交换的数据其实都是移位寄存器从 SSPBUF 里面拷贝的。通过往 SSPBUF 对应的寄存器 (Tx-Data &#x2F; Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF。</p><h2><span id="2-3-controller">2.3 Controller</span><a href="#2-3-controller" class="header-anchor">#</a></h2><p>用来发送控制信号的，像CS，SCK等控制信号。</p><h1><span id="3-spi-luo-ji-shi-li">3 SPI裸机示例</span><a href="#3-spi-luo-ji-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</span><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/8.png" alt="img"></p><p><strong>QG-2864TMBEG01</strong>这款OLED为例，可见它支持Parallel&#x2F;i2c&#x2F;SPI这3种方式对它进行控制，这里仅对它进行SPI控制。它的product Specification见附件。</p><h3><span id="3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</span><a href="#3-1-1-bing-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/9.png" alt="img"></p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/10.png" alt="img"></p><h3><span id="3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</span><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/11.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tr/Tf: 表示spi clk上升/下降延不能超过<span class="number">40</span>ns</span><br><span class="line">Tclkl/Tclkh: 表示spi clk低/高电平持续至少<span class="number">20</span>ns</span><br><span class="line">Tcycle: 表示spi clk一个时钟周期至少<span class="number">100</span>ns</span><br><span class="line">Tdsw/Tdhw: 表示spi data的建立/持续时间至少<span class="number">15</span>ms</span><br><span class="line">Tcss:片选建立时间至少<span class="number">20</span>ns</span><br><span class="line">Tcsh:片选持续时间至少<span class="number">10</span>ns</span><br><span class="line">Tas/Tah:地址建立/持续时间至少<span class="number">15</span>ns</span><br></pre></td></tr></table></figure><h3><span id="3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</span><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/12.png" alt="img"></p><h3><span id="3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</span><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/13.png" alt="img"></p><h3><span id="3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</span><a href="#3-1-5-xiu-mian-huan-xing" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/14.png" alt="img"></p><h2><span id="3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</span><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/15.png" alt="img"></p><p><strong>QG-2864TMBEG01</strong>这款为例，OLED长有128个像素，宽有64个像素，共128*64&#x3D;8,192 像素。每个像素用1bit来表示，为1则亮，为0则灭。所以每一个字节数据Data表示8个像素，Data0~Data1023,如上图。 那要怎么在显存里面存放Data数据。</p><h3><span id="3-2-1-fa-song-di-zhi">3.2.1 发送地址</span><a href="#3-2-1-fa-song-di-zhi" class="header-anchor">#</a></h3><h4><span id="3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</span><a href="#3-2-1-1-ye-page-di-zhi-mo-shi" class="header-anchor">#</a></h4><p>QG-2864TMBEG01 OLED主控有三种地址模式，我们常用的是页地址模式，发送0x20命令，再发送0x02命令，进入页地址模式，如下图：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/16.png" alt="img"></p><p>它把显存的64行分为8页，每页对应8行；选中某页后，再选择某列。因此共用页地址，也就是8行都共用同一个页地址，列地址独立，所以page0<del>page7，col0</del>col127。然后就可以往里面写数据了，每写一个数据，列地址就会加1，一直写到最右端的位置，页地址加1，会自动跳到最左端。通过命令来实现发送页地址和列地址，其中列地址分为两次发送，先发送低字节，再发送高字节。如下图，假设每个字符数据大小为8x16像素，假如第一个字符位置为(page,col)，相邻的右边就是(page,col+8)，写一个字符需要先发8字节，然后跳到下一页坐标就是(page+2,col)，发送8字节数据。一个字符需要2个page*8个col，由于一个像素占1个bit, 所以一个Data占1byte, 一个字符占16 byte。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/17.png" alt="img"></p><h5><span id="3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</span><a href="#3-2-1-1-1-she-zhi-page-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/18.png" alt="img"></p><p>一共就8页，因此X2<del>X0，有3bit足够了。比如选中page0，则x2</del>x0 &#x3D; 000。</p><h5><span id="3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</span><a href="#3-2-1-1-2-she-zhi-col-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/19.png" alt="img"></p><p>分两次发送， 先发送列地址低4位，再发送列地址高4位；</p><h3><span id="3-2-2-fa-song-shu-ju">3.2.2 发送数据</span><a href="#3-2-2-fa-song-shu-ju" class="header-anchor">#</a></h3><p>如何发送一个字符‘A’，显示到OLED。</p><ol><li>取得字模</li></ol><p>这里从网上找了一份8x16的字库。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLEDFONT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLEDFONT_H      </span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> oled_asc2_8x16[<span class="number">95</span>][<span class="number">16</span>]= &#123;</span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">// 0</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//!1</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&quot;2</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//#3</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0xFC</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//$4</span></span><br><span class="line">    &#123;<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x1C</span>,<span class="number">0x03</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//%5</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x27</span>,<span class="number">0x21</span>,<span class="number">0x10</span>&#125;,<span class="comment">//&amp;6</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x16</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#x27;7</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//(8</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x18</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//)9</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//*10</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x1F</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//+11</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xB0</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//,12</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>&#125;,<span class="comment">//-13</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//.14</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">///15</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//016</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//117</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//218</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x48</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//319</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x00</span>&#125;,<span class="comment">//420</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//521</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//622</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//723</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//824</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//925</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//:26</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//;27</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&lt;28</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//=29</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&gt;30</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x48</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x36</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//?31</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0xC8</span>,<span class="number">0x28</span>,<span class="number">0xE8</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x27</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x14</span>,<span class="number">0x0B</span>,<span class="number">0x00</span>&#125;,<span class="comment">//@32</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3C</span>,<span class="number">0x23</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x27</span>,<span class="number">0x38</span>,<span class="number">0x20</span>&#125;,<span class="comment">//A33</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//B34</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;,<span class="comment">//C35</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//D36</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x23</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//E37</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//F38</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x1E</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//G39</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//H40</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//I41</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//J42</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0xC0</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x01</span>,<span class="number">0x26</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//K43</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//L44</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//M45</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//N46</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//O47</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//P48</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x18</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x38</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Q49</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//R50</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//S51</span></span><br><span class="line">    &#123;<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//T52</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//U53</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x78</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x0E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//V54</span></span><br><span class="line">    &#123;<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x3C</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x3C</span>,<span class="number">0x03</span>,<span class="number">0x00</span>&#125;,<span class="comment">//W55</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x68</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x2C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//X56</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0xC8</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Y57</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x38</span>,<span class="number">0x26</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Z58</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//[59</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>&#125;,<span class="comment">//\60</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//]61</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//^62</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>&#125;,<span class="comment">//_63</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//`64</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//a65</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//b66</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x00</span>&#125;,<span class="comment">//c67</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x88</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//d68</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x00</span>&#125;,<span class="comment">//e69</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//f70</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x6B</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x93</span>,<span class="number">0x60</span>,<span class="number">0x00</span>&#125;,<span class="comment">//g71</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//h72</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//i73</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//j74</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x02</span>,<span class="number">0x2D</span>,<span class="number">0x30</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//k75</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//l76</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>&#125;,<span class="comment">//m77</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//n78</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//o79</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0xA1</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//p80</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xA0</span>,<span class="number">0xFF</span>,<span class="number">0x80</span>&#125;,<span class="comment">//q81</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//r82</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x00</span>&#125;,<span class="comment">//s83</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//t84</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//u85</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//v86</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x0F</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//w87</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x2E</span>,<span class="number">0x0E</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//x88</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x81</span>,<span class="number">0x8E</span>,<span class="number">0x70</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//y89</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//z90</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x7C</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>&#125;,<span class="comment">//&#123;91</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//|92</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x7C</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#125;93</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//~94</span></span><br><span class="line">&#125;;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>发送页&#x2F;列地址</p></li><li><p>发送数据</p></li></ol><h2><span id="3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</span><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</span><a href="#3-3-1-ruan-jian-ceng-ci" class="header-anchor">#</a></h3><p>操作OLED，通过三条线(SCK、DO、CS)与OLED相连，这里没有DI是因为s3c2440只会向OLED传数据而不用接收数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_spi.c来实现gpio模拟spi，负责spi通讯。对于OLED，有专门的指令和数据格式，要传输的数据内容。</span><br><span class="line">oled.c这一层来实现，负责组织数据。</span><br></pre></td></tr></table></figure><h3><span id="3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</span><a href="#3-3-2-gpio-spi-c" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/20.png" alt="img"></p><h4><span id="3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</span><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h4><p>上图J3为板子pin2pin到OLED的底座。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPF1作为OLED片选引脚，设置为输出；</span><br><span class="line">GPG4作为OLED的数据(Data)/命令(Command)选择引脚，设置为输出；</span><br><span class="line">GPG5作为SPI的MISO，设置为输入（实际用不到）；</span><br><span class="line">GPG6作为SPI的MOSI，设置为输出；</span><br><span class="line">GPG7作为SPI的时钟CLK，设置为输出；</span><br></pre></td></tr></table></figure><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/21.png" alt="img"></p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/22.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* GPF1 as OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//取消OLED_CSn片选，pull up</span></span><br><span class="line">   <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//取消FLASH_CSn 片选，pull up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-3-2-2-xie-ming-ling">3.3.2.2 写命令</span><a href="#3-3-2-2-xie-ming-ling" class="header-anchor">#</a></h4><p>D&#x2F;C即数据(Data)&#x2F;命令(Command)选择引脚，它为高电平时，OLED即认为收到的是数据；它为低电平时，OLED即认为收到的是命令。先设置为命令模式，再片选OLED，再传输命令，再恢复成原来的模式和取消片选。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/23.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  gpio output default is pull up*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>拉低DC引脚表示要发送是命令；</p></li><li><p>片选</p></li><li><p>发送1byte数据</p></li></ol><h5><span id="3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</span><a href="#3-3-2-2-1-spisendbyte" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/24.png" alt="img"><br>SPISendByte是把一个byte数据从高位往低位依次发送到DO。spi配置模式0， 主控先设置CLK为低，由于是MSB, 先传送高位，然后CLK为高，在CLK这个上升沿,DO的数据被锁存，OLED就读取了一位数据。接着左移一位，传输下一位。通过SPI_Set_CLK()和SPI_Set_DO()配置SCK和DO的时序，用gpio模拟出了spi。至此，SPI初始化和OLED初始化就基本完成了，接下来就是OLED显示部分。</p><p>这里gpio模拟spi传送时主控没有加延时控制SCK的频率，那是由于s3c2440本身cpu运行就很慢，这里不延时也是能满足该款外设的spi传输时序，如果cpu很快，那么需要控制spi时序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔一个SPI时钟，发送1位数据，MSB-高位先出</span></span><br><span class="line"><span class="comment">//这里的SPI时钟并没有指定周期，这就取决于指令执行的速率，指令执行越快，gpio模拟的SPI时钟越快,如下：     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">              SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">              SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">              SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">              val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>取消片选</li><li>DC拉高</li></ol><h4><span id="3-3-2-3-xie-shu-ju">3.3.2.3 写数据</span><a href="#3-3-2-3-xie-shu-ju" class="header-anchor">#</a></h4><p>与写命令同理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span>&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data*/</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(data);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="3-2-3-oled-c">3.2.3 oled.c</span><a href="#3-2-3-oled-c" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</span><a href="#3-2-3-1-chu-shi-hua-oled" class="header-anchor">#</a></h4><p>找到<strong>QG-2864TMBEG01</strong> 的power on sequence-上电时序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</span><a href="#3-2-3-2-qu-dong-xian-shi-oled" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++) &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</span><a href="#3-3-4-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************** gpio_spi.c ****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 用GPIO模拟SPI */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* GPF1 OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);</span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************* oled.c****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio_spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(dat);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPageAddrMode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x20</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line"> </span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPageAddrMode();</span><br><span class="line"> </span><br><span class="line">    OLEDClear();</span><br><span class="line">     </span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAF</span>); <span class="comment">/*display ON*/</span>   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-spi-yuan-li&quot;&gt;1 SPI原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-spi-gai-nian&quot;&gt;1.1 spi概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="通信协议" scheme="http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-I2C</title>
    <link href="http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/"/>
    <id>http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/</id>
    <published>2024-04-18T07:10:45.000Z</published>
    <updated>2024-04-18T12:03:32.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-i2c-yuan-li">1 I2C原理</a><ul><li><a href="#1-1-ying-jian-dian-lu">1.1 硬件电路</a></li><li><a href="#1-2-i2c-xie-yi">1.2 i2c协议</a><ul><li><a href="#1-2-1-s-p-xin-hao">1.2.1 S&#x2F;P信号</a></li><li><a href="#1-2-2-ack-xin-hao">1.2.2 ACK信号</a></li><li><a href="#1-2-3-data-ge-shi">1.2.3 DATA格式</a></li><li><a href="#1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</a></li></ul></li><li><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</a></li><li><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</a></li><li><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</a></li></ul></li><li><a href="#2-i2c-kong-zhi-qi">2 I2C控制器</a><ul><li><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</a></li><li><a href="#2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</a><ul><li><a href="#2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</a></li><li><a href="#2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</a><ul><li><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</a></li><li><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</a></li><li><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</a></li><li><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</a></li></ul></li></ul></li></ul></li><li><a href="#3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</a><ul><li><a href="#3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</a><ul><li><a href="#3-1-1-zhu-fa-master-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</a></li><li><a href="#3-1-2-zhu-shou-master-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</a></li><li><a href="#3-1-3-cong-fa-slave-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</a></li><li><a href="#3-1-4-cong-shou-slave-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</a></li></ul></li></ul></li><li><a href="#4-i2c-cheng-xu-shi-li">4 I2C程序示例</a><ul><li><a href="#4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</a><ul><li><a href="#4-1-1-at24cxx-eeprom">4.1.1 AT24CXX EEPROM</a></li></ul></li><li><a href="#4-2-cheng-xu-kuang-jia">4.2 程序框架</a><ul><li><a href="#4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</a></li><li><a href="#4-2-2-i2c-test-c">4.2.2 i2c_test.c</a></li><li><a href="#4-2-3-at24cxx-c">4.2.3 at24cxx.c</a></li><li><a href="#4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</a></li><li><a href="#4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</a></li><li><a href="#4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</a></li></ul></li><li><a href="#4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</a></li><li><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</a><ul><li><a href="#4-4-1-xie-cao-zuo">4.4.1 写操作</a></li><li><a href="#4-4-2-du-cao-zuo">4.4.2 读操作</a></li></ul></li><li><a href="#4-5-ce-shi">4.5 测试</a><ul><li><a href="#4-5-1-i2c-test-c">4.5.1 i2c_test.c</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-i2c-yuan-li">1 I2C原理</span><a href="#1-i2c-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-ying-jian-dian-lu">1.1 硬件电路</span><a href="#1-1-ying-jian-dian-lu" class="header-anchor">#</a></h2><p>I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/1.png" alt="img"></p><p>SDA（串行数据线）和SCL（串行时钟线）都是双向I&#x2F;O线，需通过上拉电阻接电源VCC．当总线空闲时．两根线都是高电平。</p><p>I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。</p><h2><span id="1-2-i2c-xie-yi">1.2 i2c协议</span><a href="#1-2-i2c-xie-yi" class="header-anchor">#</a></h2><p>传输过程如下：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/2.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 主控发送start讯号(S)</span><br><span class="line"><span class="number">2.</span> 主控发送从设备地址(slave dev addr)</span><br><span class="line"><span class="number">3.</span> 主控发送方向（W/R）</span><br><span class="line"><span class="number">4.</span> 从设备应答（ack）</span><br><span class="line"><span class="number">5.</span> 主控（or从设备）发送数据(data)</span><br><span class="line"><span class="number">6.</span> 从设备（or主控）应答(ack)</span><br><span class="line">...</span><br><span class="line"><span class="number">7.</span> 主控发送停止信号(P)</span><br></pre></td></tr></table></figure><p>s3c2440 一次i2c读写过程:</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/3.png" alt="img"></p><h3><span id="1-2-1-s-x2f-p-xin-hao">1.2.1 S&#x2F;P信号</span><a href="#1-2-1-s-x2f-p-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/4.png" alt="img"></p><p>start信号：SCL是高电平，SDA被主控拉低。<br>stop信号：SCL是高电平，SDA被主控拉高。</p><p>示波器测量出start信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/5.png" alt="img"></p><p>示波器测量出stop信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/6.png" alt="img"></p><h3><span id="1-2-2-ack-xin-hao">1.2.2 ACK信号</span><a href="#1-2-2-ack-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/7.png" alt="img"></p><p>第9个时钟周期，SDA被拉低表示ack讯号。</p><h3><span id="1-2-3-data-ge-shi">1.2.3 DATA格式</span><a href="#1-2-3-data-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/8.png" alt="img"></p><p>用 9个clk传输8bit数据（7bit 从设备地址 + 1bit方向 ），MSB高位先出。第9个clk是ack讯号。</p><h3><span id="1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</span><a href="#1-2-4-shu-ju-you-xiao-xing" class="header-anchor">#</a></h3><p>SDA 线上的数据必须在<strong>SCL高电平周期保持稳定，在 SCL 低电平时才能允许改变</strong>。</p><h2><span id="1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</span><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/9.jpg" alt="img"></p><ol><li>主控发送了S信号；</li><li>发送地址0x34，包含读写位；</li><li>发送数据0x30, 0x00, 0x01共3个字节数据；</li><li>最后SDA被拉高发送P信号。</li></ol><p>这里我是用了带I2C解码的示波器，能将I2C协议解码出来方便调试者阅读分析。</p><h2><span id="1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</span><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li" class="header-anchor">#</a></h2><p>电路设计内部结构使用<strong>开极电路</strong>。如下图：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/10.png" alt="img"></p><p><strong>条件</strong>：</p><ol><li><p>主设备发送时，从设备不发送（通过SCL控制即可，比如让前8个clk主控发送数据到SDA,让第9个clk从设备发送数据到SDA）</p></li><li><p>主设备发送数据时，从设备的“发送引脚”不能影响SDA数据。反之，从设备发送数据时，主设备的”发送引脚”不能影响到SDA数据。那么如何做到？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDA内部电路用三极管，开集电路,原理如下图：</span><br></pre></td></tr></table></figure><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/11.png" alt="img"></p><p>从上图知道：</p><ol><li><p>当A,B都为低电平时，三极管不导通，SDA的电平取决于外部电路，这里SDA有上拉电阻，所以对应高电平；</p></li><li><p>当主控拉高A时，三极管导通，此时SDA接地，电平被拉低</p></li><li><p>同理，当从设备拉高B时，三极管导通，此时SDA接地，电平被拉低</p></li></ol></li></ol><p>那么电平真值表如下：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/12.png" alt="img"></p><p>所以，要实现双向传输：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果要master-&gt; slave进行数据传输，那么让主控驱动三极管，拉低SDA。</span><br><span class="line">如果要slave-&gt; master进行数据传输，那么让从设备驱动三极管，拉低SDA。</span><br><span class="line">否则，都不驱动三极管，SDA一直输出高电平，处于idle状态。</span><br></pre></td></tr></table></figure><p>从下面的例子可以看看数据是怎么传的（实现双向传输）。</p><p>举例：主设备发送（8bit）给从设备:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前 <span class="number">8</span> 个 clk</span><br><span class="line">◼ 从设备不要影响 SDA，从设备不驱动三极管</span><br><span class="line">◼ 主设备决定数据，主设备要发送 <span class="number">1</span> 时不驱动三极管，要发送 <span class="number">0</span> 时驱动三极管</span><br><span class="line">第 <span class="number">9</span> 个 clk，由从设备决定数据</span><br><span class="line">◼ 主设备不驱动三极管</span><br><span class="line">◼ 从设备决定数据，要发出回应信号的话，就驱动三极管让 SDA 变为 <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从这里也可以知道 ACK 信号是低电平从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是 SDA 上要使用上拉电阻的原因。</p><p>为何 SCL 也要使用上拉电阻？在第 9 个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把 SCL 拉低。</p><p>当 SCL 为低电平时候，大家都不应该使用 IIC 总线，只有当 SCL 从低电平变为高电平的时候，IIC 总线才能被使用。当它就绪后，就可以不再驱动三极管，这是上拉电阻把 SCL 变为高电平，其他设备就可以继续使用 I2C 总线了。</p><h2><span id="1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</span><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/13.png" alt="img"></p><p>在<strong>第9个clk 后i2c会产生中断，此时SCL被拉低，表示busy状态</strong>，表示谁都不允许再使用i2c, 然后等到中断处理结束了，也就是处于idle状态了，此时会释放出SCL，那么主控可以继续发送SCL讯号表示可以继续进行i2c通信了。</p><h1><span id="2-i2c-kong-zhi-qi">2 I2C控制器</span><a href="#2-i2c-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</span><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/14.png" alt="img"></p><p>对于写操作，主控作为transmitter,从设备作为receiver。<br>对于读操作，主控作为receiver， 从设备作为transmitter。</p><h2><span id="2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</span><a href="#2-2-s3c2440-i2c-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</span><a href="#2-2-1-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/15.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pclk = <span class="number">50</span>Mhz, 经过prescaler分频，可以得到SCL。</span><br><span class="line"></span><br><span class="line">IICSTAT: 发出S（start）信号或者P(stop)信号。</span><br><span class="line"></span><br><span class="line">Data Bus可以把数据写入IICDS寄存器，然后会自动产生SCL，并且会将<span class="number">8</span>位数据从SDA同步给slave dev，</span><br><span class="line"></span><br><span class="line">在数据发送出去后，在第<span class="number">9</span>个SCL时钟，会受到slave dev的ack应答，可以通过查询IICSTAT来判断是否有ACK回应。</span><br><span class="line"></span><br><span class="line">当slave dev回应ACK后，那么又可以继续发送数据，继续写入据到IICDS。</span><br><span class="line"></span><br><span class="line">当主控想结束，设置IICSTAT发出P信号。</span><br></pre></td></tr></table></figure><h3><span id="2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</span><a href="#2-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</span><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/16.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bit[<span class="number">7</span>]: 对于发送模式，不需要配置ack信号，ack是接收者发送回来的应答。对于接受模式，设置成<span class="number">1</span>，让它在第<span class="number">9</span>个CLK发出ack讯号（拉低sda）。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">6</span>]:SCL时钟源，pclk分频即可</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:中断使能，使用i2c时要去enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>]:中断状态标识 表示中断有没有结束，当该bit读出来是<span class="number">1</span>时，SCL被拉低表示busy，也就是i2c中断还在处理中。当i2c中断处理结束后，可以将该bit 清<span class="number">0</span>，释放出SCL。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>:<span class="number">0</span>]:i2c时钟分频系数配置，SCL时钟 = IICCLK/(IICCON[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4><span id="2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</span><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/17.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">7</span>:<span class="number">6</span>]:模式选择</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:当读的时候，<span class="number">0</span>表示not busy,<span class="number">1</span>表示busy, 当写的时候，<span class="number">0</span>表示写入STOP, <span class="number">1</span>表示写入START</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>] : 数据输出使能，<span class="number">0</span>：表示disable, <span class="number">1</span>表示enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>]:仲裁flag</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">0</span>]:表示i2c总线上的第<span class="number">9</span>个时钟周期有没有ack，<span class="number">1</span>表示有ack, <span class="number">0</span>表示无ack</span><br></pre></td></tr></table></figure><h4><span id="2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</span><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/18.png" alt="img"></p><h4><span id="2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</span><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/19.png" alt="img"></p><h1><span id="3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</span><a href="#3-i2c-du-xie-cao-zuo-liu-cheng" class="header-anchor">#</a></h1><p>The following steps must be executed before any IIC Tx&#x2F;Rx operations.</p><ol><li>Write own slave address on IICADD register, if needed.</li><li>Set IICCON register.<ol><li>Enable interrupt</li><li>Define SCL period</li></ol></li><li>Set IICSTAT to enable Serial Output</li></ol><p>在操作tx,rx前，要先执行以下几步骤：</p><ol><li>IICADD写入从设备地址</li><li>设置IICCON，设置时钟，使能中断</li><li>设置IICSTAT，使能传输</li></ol><h2><span id="3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</span><a href="#3-1-i2c-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p>The S3C2440A IIC-bus interface has four operation modes:<br><strong>— Master transmitter mode</strong><br><strong>— Master receive mode</strong><br><strong>— Slave transmitter mode</strong><br><strong>— Slave receive mode</strong></p><h3><span id="3-1-1-zhu-fa-master-x2f-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</span><a href="#3-1-1-zhu-fa-master-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/20.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master tx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">11</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xF0（使能传输,发S信号，使能tx/rx）</span><br><span class="line">3. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">IICDS = buf</span><br><span class="line">Clear pending bit</span><br><span class="line">数据被发送出去，继续i2c传输</span><br><span class="line"><span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">IICSTAT = <span class="number">0xd0</span></span><br><span class="line">Clear pending bit（IICCON[<span class="number">4</span>]）</span><br><span class="line">Delay一会儿等待停止条件生效</span><br></pre></td></tr></table></figure><h3><span id="3-1-2-zhu-shou-master-x2f-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</span><a href="#3-1-2-zhu-shou-master-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/21.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master rx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">10</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xB0（使能传输）</span><br><span class="line">4. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">Buf = IICDS</span><br><span class="line">Clear pending bit</span><br><span class="line">数据被接受到，继续i2c传输</span><br><span class="line"><span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">IICSTAT = <span class="number">0x90</span></span><br><span class="line">Clear pending bit</span><br><span class="line">Delay一会儿</span><br></pre></td></tr></table></figure><h3><span id="3-1-3-cong-fa-slave-x2f-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</span><a href="#3-1-3-cong-fa-slave-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/22.png" alt="img"></p><h3><span id="3-1-4-cong-shou-slave-x2f-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</span><a href="#3-1-4-cong-shou-slave-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/23.png" alt="img"></p><h1><span id="4-i2c-cheng-xu-shi-li">4 I2C程序示例</span><a href="#4-i2c-cheng-xu-shi-li" class="header-anchor">#</a></h1><h2><span id="4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</span><a href="#4-1-i2c-cong-she-bei-jie-shao" class="header-anchor">#</a></h2><p>IIC控制器只提供了传输数据的能力，至于数据有什么含义，IIC控制器并不知道，数据的含义有外部i2c从设备，我们需要阅读芯片手册，才知道IIC控制器应该发出怎样的数据。</p><h3><span id="4-1-1-at24cxx-eeprom">4.1.1  AT24CXX EEPROM</span><a href="#4-1-1-at24cxx-eeprom" class="header-anchor">#</a></h3><p>AT24Cxx系列EEPROM是由美国Mcrochip公司出品，1-512K位的支持I2C总线数据传送协议的串行CMOS E2PROM。I2c传输规则如下：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/24.png" alt="img"></p><h2><span id="4-2-cheng-xu-kuang-jia">4.2 程序框架</span><a href="#4-2-cheng-xu-kuang-jia" class="header-anchor">#</a></h2><p>我们的程序应该分为两层（IIC设备层，IIC控制器层），框架如下图所示：</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/25.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最上层是i2c_test层，用来对i2c的功能进行测试和验证。</span><br><span class="line"></span><br><span class="line">第2层是i2c设备层，用来对具体某一型号的从设备进行i2c读写。</span><br><span class="line"></span><br><span class="line">第3层是通用i2c控制器层，用来提供对具体某一型号的i2c主控进行管理操作。</span><br><span class="line"></span><br><span class="line">最底层是i2c控制器具体的型号层。</span><br></pre></td></tr></table></figure><p>在通用i2c控制层，我们提供一个统一的接口i2c_transfer，不关使用哪个芯片，他最终都会调用i2c_transfer，来选择某一款I2C控制器，把数据发送出去，或者从I2c设备读到数据。这种层次分明的架构是作为软件开发人员必备的素养和技能。这里也是借鉴了linux内核I2C子系统的模型。</p><h3><span id="4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</span><a href="#4-2-1-i2c-msg-jie-gou-ti" class="header-anchor">#</a></h3><p>我们借鉴Linux I2C子系统的数据结构定义。对于每一次传输的数据都可以用一个i2c_msg结构体来表示。但是，读某个地址的数据时，就要用两个i2c_msg结构体来描述它，因为一个i2c_msg结构体只能描述一个传输方向(读&#x2F;写)，我们读取ac24ccxx某个地址上的数据时，要先写出要读取的地址，然后来读取设备地址上的数据。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/26.png" alt="img"></p><h3><span id="4-2-2-i2c-test-c">4.2.2 i2c_test.c</span><a href="#4-2-2-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 初始化: 选择I2C控制器 */</span></span><br><span class="line">        <span class="comment">/* 提供菜单供测试 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个菜单会调用到at24cxx.c里面的函数进行i2c外设读写。</p><h3><span id="4-2-3-at24cxx-c">4.2.3 at24cxx.c</span><a href="#4-2-3-at24cxx-c" class="header-anchor">#</a></h3><p>定义描述at24cxx外设，并且实现该外设的操作，里面会使用标准的接口i2c_transfer来启动I2C传输。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24CXX_ADDR 0x50</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buf[<span class="number">0</span>] = addr++;</span><br><span class="line">                buf[<span class="number">1</span>] = data[i];</span><br><span class="line">                <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">                msg.addr  = AT24CXX_ADDR;</span><br><span class="line">                msg.flags = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">                msg.len   = <span class="number">2</span>;</span><br><span class="line">                msg.buf   = buf;</span><br><span class="line">                msg.err   = <span class="number">0</span>;</span><br><span class="line">                msg.cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">                err = i2c_transfer(&amp;msg, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">        msg[<span class="number">0</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">0</span>].flags  = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">        msg[<span class="number">0</span>].len   = <span class="number">1</span>;</span><br><span class="line">        msg[<span class="number">0</span>].buf   = &amp;addr;</span><br><span class="line">        msg[<span class="number">0</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">0</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg[<span class="number">1</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">1</span>].lags  = <span class="number">1</span>; <span class="comment">/* read */</span></span><br><span class="line">        msg[<span class="number">1</span>].len   = len;</span><br><span class="line">        msg[<span class="number">1</span>].buf   = data;</span><br><span class="line">        msg[<span class="number">1</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">1</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">        err = i2c_transfer(&amp;msg, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</span><a href="#4-2-4-i2c-controller-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> addr;  <span class="comment">/* 7bits */</span></span><br><span class="line">        <span class="type">int</span> flags;  <span class="comment">/* 0 - write, 1 - read */</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> cnt_transferred;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">&#125;i2c_msg, *p_i2c_msg;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_controller</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*<span class="type">int</span>)(<span class="type">void</span>);</span><br><span class="line">        <span class="type">int</span> (*master_xfer)(i2c_msg msgs, <span class="type">int</span> num);</span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">&#125;i2c_controller, *p_i2c_controller;</span><br></pre></td></tr></table></figure><p>构造i2c_msg和i2c_controller结构。</p><h3><span id="4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</span><a href="#4-2-5-i2c-controller-c" class="header-anchor">#</a></h3><p>实现通用i2c控制器管理，用来注册具体i2c控制器，调用具体控制器去做i2c通信。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CONTROLLER_NUM 10</span></span><br><span class="line"><span class="comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span></span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_controllers[I2C_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_con_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_i2c_controller</span><span class="params">(p_i2c_controller *p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p_i2c_controllers[i]) &#123;</span><br><span class="line">                        p_i2c_controllers[i] = p;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据名字来选择某款I2C控制器 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_i2c_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (p_i2c_controllers[i] &amp;&amp; !<span class="built_in">strcmp</span>(name, p_i2c_controllers[i]-&gt;name))</span><br><span class="line">                &#123;</span><br><span class="line">                        p_i2c_con_selected = p_i2c_controllers[i];</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现 i2c_transfer 接口函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(i2c_msg msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p_i2c_con_selected-&gt;master_xfer(msgs, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 注册下面的I2C控制器 */</span></span><br><span class="line">s3c2440_i2c_con_add();</span><br><span class="line"><span class="comment">/* 选择某款I2C控制器 */</span></span><br><span class="line">select_i2c_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line"><span class="comment">/* 调用它的init函数 */</span></span><br><span class="line">p_i2c_con_selected-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</span><a href="#4-2-6-s3c2440-i2c-controller-c" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_interrupt_func</span>(<span class="params"><span class="built_in">int</span> irq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 配置引脚用于I2C*/</span></span><br><span class="line">        GPECON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">        GPECON |= ((<span class="number">2</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置时钟 */</span></span><br><span class="line">        <span class="comment">/* [7] : IIC-bus acknowledge enable bit, 1-enable in rx mode</span></span><br><span class="line"><span class="comment">         * [6] : 时钟源, 0: IICCLK = fPCLK /16; 1: IICCLK = fPCLK /512</span></span><br><span class="line"><span class="comment">         * [5] : 1-enable interrupt</span></span><br><span class="line"><span class="comment">         * [4] : 读出为1时表示中断发生了, 写入0来清除并恢复I2C操作</span></span><br><span class="line"><span class="comment">         * [3:0] : Tx clock = IICCLK/(IICCON[3:0]+1).</span></span><br><span class="line"><span class="comment">         * Tx Clock = 100khz = 50Mhz/16/(IICCON[3:0]+1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IICCON = (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">        register_irq(<span class="number">27</span>, i2c_interrupt_func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_tx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 master tx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* TX mode, 在ACK周期释放SDA */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/*IIC-bus data output enable/disable(1: Enable Rx/Tx)*/</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>;<span class="comment">//[slave addr [7:1], addr[0] is trans dir]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xf0 (启动传输), slave addr数据即被发送出去,当到达第9个clk,无论是否有ack, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_rx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 Master Rx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* RX mode, 在ACK周期回应ACK */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);  <span class="comment">/*IIC-bus data output enable/disable*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xb0 , 从设备地址即被发送出去, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xb0</span>;</span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">s3c2440_master_xfer</span>(<span class="params">p_i2c_msg msgs, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="built_in">int</span> err;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)        </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgs[i].flags == <span class="number">0</span>)<span class="comment">/* write */</span></span><br><span class="line">                        err = do_master_tx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        err = do_master_rx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_add</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_i2c_controller(&amp;s3c2440_i2c_con);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> i2c_controller s3c2440_i2c_con = &#123;</span><br><span class="line">        .name = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">        .<span class="keyword">init</span> = s3c2440_i2c_con_init,</span><br><span class="line">        .master_xfer = s3c2440_master_xfer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>s3c2440_i2c_con_add函数：注册 s3c2440的i2c控制器， 当调用i2c_init就会对选中的这款控制器初始化，也就是调用s3c2440_i2c_con_init。</p><p>s3c2440_i2c_con_init函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>).IICCON = (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>); 设置IICCON控制寄存器。选择发送时钟，使能中断。设置ACK应答使能，bit[<span class="number">7</span>]。</span><br><span class="line"><span class="number">2</span>).register_irq(<span class="number">27</span>, i2c_interrupt_func)：注册中断处理函数，当发生I2C中断的时候就会调用i2c_interrupt_func中断处理函数。</span><br></pre></td></tr></table></figure><p>s3c2440_master_xfer函数：</p><p>当发起i2c传输时，调用i2c_transfer，进而调用s3c2440_master_xfer进行数据传输。写的话do_master_tx，读的话do_master_rx。</p><p>do_master_rx函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)：把从设备地址写入IICDS，前<span class="number">7</span>位是从机地址，第<span class="number">8</span>位表示传输方向(<span class="number">0</span>表示写操作，<span class="number">1</span>表示读操作)。</span><br></pre></td></tr></table></figure><p>do_master_tx函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>: 把从机地址（高<span class="number">7</span>位，所以需要向右移一位）写入到IICDS寄存器中。</span><br><span class="line"><span class="number">2.</span> IICSTAT = <span class="number">0xf0</span>:设置IICSTAT寄存器，将s3c2440设为主机发送器，并发出S信号后，紧接着就发出从机地址。后续的传输工作将在中断服务程序中完成。</span><br></pre></td></tr></table></figure><h2><span id="4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</span><a href="#4-3-cheng-xu-kuang-jia-zong-jie" class="header-anchor">#</a></h2><p>对应程序框架的4层架构。</p><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/27.png" alt="img"></p><h2><span id="4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</span><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h2><p>Start信号之后，发出设备地址，在第9个时钟就会产生第一个中断，我们根据i2c的流程图来编写中断程序。每传输完一个数据将又产生一个中断，I2C操作的主体在<strong>中断服务程序</strong>，它可以分为两部分：写操作，读操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> p_i2c_msg p_cur_msg;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">isLastData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == p_cur_msg-&gt;len - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* 正要开始传输最后一个数据 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_with_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* 回应ACK */</span></span><br><span class="line">        iiccon &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/* 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_without_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)); <span class="comment">/* 不回应ACK, 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_interrupt_func</span><span class="params">(<span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iicstat = IICSTAT;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//printf(&quot;i2c_interrupt_func! flags = %d\n\r&quot;, p_cur_msg-&gt;flags);</span></span><br><span class="line"> </span><br><span class="line">        p_cur_msg-&gt;cnt_transferred++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;flags == <span class="number">0</span>) &#123;<span class="comment">//write</span></span><br><span class="line"><span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;  <span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/*iicstat [0] == 1表示no ack*/</span></span><br><span class="line"><span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;tx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line"><span class="comment">/* 对于其他中断, 要继续发送下一个数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred];</span><br><span class="line">IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//clear pending bit</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 停止传输 */</span></span><br><span class="line">IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//read</span></span><br><span class="line">                <span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在, 恢复I2C传输, 这样在下一个中断才可以得到第1个数据</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;<span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;rx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ack */</span></span><br><span class="line">                                <span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">                                <span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">                                <span class="keyword">if</span> (isLastData())</span><br><span class="line">                                        resume_iic_without_ack();</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        resume_iic_with_ack();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 非第1个中断, 表示得到了一个新数据</span></span><br><span class="line"><span class="comment"> * 从IICDS读出、保存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">index = p_cur_msg-&gt;cnt_transferred - <span class="number">1</span>;</span><br><span class="line">p_cur_msg-&gt;buf[index] = IICDS;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line"><span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line"><span class="keyword">if</span> (isLastData())</span><br><span class="line">resume_iic_without_ack();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">resume_iic_with_ack();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* 发出停止信号 */</span></span><br><span class="line">IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">delay(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="4-4-1-xie-cao-zuo">4.4.1 写操作</span><a href="#4-4-1-xie-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. p_cur_msg-&gt;cnt_transferred初始值为-1(do_master_tx启动时设置)。</span><br><span class="line">2. p_cur_msg-&gt;cnt_transferred == 0表示是第一次传输数据完后产生的中断，即发送从设备地址产生的中断。</span><br><span class="line">3. iicstat &amp; (1&lt;&lt;0)表示主机没有接受到ACK信号(即发出的设备地址不存在)，需要停止传输。</span><br><span class="line">4. IICSTAT = 0xd0置IICSTAT寄存器的[5]写为0，产生P信号。但是由于这时IICCON[4]仍为1，P信号没有实际发出，当执行IICCON &amp;= ~(1&lt;&lt;4);清除IICCON[4]后，P信号才真正发出。</span><br><span class="line">5. 等待一段时间，确保P信号已经发送完毕。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">1).假如if (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)条件成立，表示数据还没有发送完毕，需要继续发送数据。</span><br><span class="line">2).执行IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred]把要发送的数据写入到IICDS寄存器中，经过执行IICCON &amp;= ~(1&lt;&lt;4);清除中断标志后后，紧接着就自动把数据发送出去了，这将触发下一个中断。</span><br><span class="line">3).如果条件不成立表示数据传输完毕，发出P信号，停止数据的传输。</span><br></pre></td></tr></table></figure><h3><span id="4-4-2-du-cao-zuo">4.4.2 读操作</span><a href="#4-4-2-du-cao-zuo" class="header-anchor">#</a></h3><p>见注释。</p><h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><h3><span id="4-5-1-i2c-test-c">4.5.1 i2c_test.c</span><a href="#4-5-1-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">    err = at24cxx_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_write ret = %d\n\r&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得长度 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the length to read: &quot;</span>);</span><br><span class="line">    len = get_int();</span><br><span class="line"></span><br><span class="line">    err = at24cxx_read(addr, data, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_read ret = %d\n\r&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 长度固定为64 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="comment">/* 先打印数值 */</span></span><br><span class="line">            c = data[cnt++];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line"><span class="comment">/* 后打印字符 */</span></span><br><span class="line"><span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">putchar</span>(str[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* 打印菜单, 供我们选择测试内容 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[w] Write at24cxx\n\r&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[r] Read at24cxx\n\r&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[q] quit\n\r&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter selection: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n\r&quot;</span>, c);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* 测试内容:</span></span><br><span class="line"><span class="comment">             * 3. 编写某个地址</span></span><br><span class="line"><span class="comment">             * 4. 读某个地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    do_write_at24cxx();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">do_read_at24cxx();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-i2c-yuan-li&quot;&gt;1 I2C原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-ying-jian-dian-lu&quot;&gt;1.1 硬件电路&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="通信协议" scheme="http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-nandflash</title>
    <link href="http://example.com/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/"/>
    <id>http://example.com/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/</id>
    <published>2024-04-17T12:10:39.000Z</published>
    <updated>2024-04-18T06:36:46.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-nandflash-yuan-li">1 nandflash原理</a><ul><li><a href="#1-1-yuan-li-tu">1.1 原理图</a></li><li><a href="#1-2-yin-jiao-miao-shu">1.2 引脚描述</a></li><li><a href="#1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</a><ul><li><a href="#1-3-1-block-kuai">1.3.1 Block块</a></li><li><a href="#1-3-2-page-ye">1.3.2 Page页</a></li><li><a href="#1-3-3-oob-qu-yu">1.3.3 oob区域</a></li><li><a href="#1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</a></li></ul></li><li><a href="#1-4-feature-te-xing">1.4 Feature特性</a></li><li><a href="#1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</a></li></ul></li><li><a href="#2-nand-kong-zhi-qi">2 Nand控制器</a><ul><li><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</a></li><li><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</a></li></ul></li><li><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</a><ul><li><a href="#3-1-ming-ling-di-zhi-suo-cun-shi-xu-xie-ming-ling-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</a><ul><li><a href="#3-1-1-k9f2g08u0c-ming-ling-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</a></li></ul></li><li><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</a></li><li><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</a></li></ul></li><li><a href="#4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</a><ul><li><a href="#4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</a></li><li><a href="#4-2-du-id-shi-xu">4.2 读ID时序</a></li><li><a href="#4-3-chu-shi-hua">4.3 初始化</a><ul><li><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</a><ul><li><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</a></li><li><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</a></li></ul></li></ul></li><li><a href="#4-4-shi-bie-nandflash">4.4 识别nandflash</a><ul><li><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</a></li><li><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</a></li></ul></li></ul></li><li><a href="#5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</a><ul><li><a href="#5-1-du-shu-ju">5.1 读数据</a><ul><li><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</a></li><li><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</a></li></ul></li><li><a href="#5-2-ca-shu-ju">5.2 擦数据</a></li><li><a href="#5-3-xie-shu-ju">5.3 写数据</a></li><li><a href="#5-4-ce-shi">5.4 测试</a></li><li><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-nandflash-yuan-li">1 nandflash原理</span><a href="#1-nandflash-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-yuan-li-tu">1.1 原理图</span><a href="#1-1-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/1.png"></p><h2><span id="1-2-yin-jiao-miao-shu">1.2 引脚描述</span><a href="#1-2-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/2.png"></p><table><thead><tr><th>引脚名称</th><th>引脚功能</th></tr></thead><tbody><tr><td>IO0~IO7</td><td>数据输入输出（命令、地址、数据共用数据总线）</td></tr><tr><td>CLE</td><td>命令使能</td></tr><tr><td>ALE</td><td>地址使能</td></tr><tr><td>&#x2F;CE</td><td>芯片使能（片选）</td></tr><tr><td>&#x2F;RE</td><td>读使能</td></tr><tr><td>&#x2F;WE</td><td>写使能</td></tr><tr><td>R&#x2F;B</td><td>就绪&#x2F;忙输出信号（低电平表示操作还在进行中，高电平表示操作完成）</td></tr></tbody></table><h2><span id="1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</span><a href="#1-3-nand-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/3.png"></p><p>我们常见的Nand Flash，内部只有一个chip，每个chip只有一个plane。但也有些复杂的，容量更大的Nand Flash，内部有多个chip，每个chip有多个plane，这类的Nand Flash，其实就是多了一个主控将多块flash叠加在一起，如下图：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/4.png"></p><h3><span id="1-3-1-block-kuai">1.3.1 Block块</span><a href="#1-3-1-block-kuai" class="header-anchor">#</a></h3><p>一个Nand Flash由很多个块（Block）组成，块的大小一般有64K，128KB，256KB，512KB，<strong>Block是Nand Flash的擦除操作的基本&#x2F;最小单位</strong>。Nand Flash中，一个块中含有1个或多个位是坏的，就称为其为<strong>坏块Bad Block</strong>。</p><h3><span id="1-3-2-page-ye">1.3.2 Page页</span><a href="#1-3-2-page-ye" class="header-anchor">#</a></h3><p>每个块里面又包含了很多页（page）。每个页的大小，对于现在常见的Nand Flash多数是2KB，当然也有的nand flash的页大小为4KB、8KB等。<strong>页Page，是读写操作的基本单位</strong>。</p><h3><span id="1-3-3-oob-qu-yu">1.3.3 oob区域</span><a href="#1-3-3-oob-qu-yu" class="header-anchor">#</a></h3><p>每一个page页，对应还附加了一块区域，一般为64byte，叫做空闲区域（spare area）&#x2F;oob区域（Out Of Band），由于nandflash在操作过程中容易产生位反转，这是nandflash的物理特性决定的，所以必须要有对应的检测和纠错机制，这种机制被叫做Error Checking and Correcting，所以设计了多余的oob区域，<strong>用于放置数据的校验值</strong>。oob的读写操作，一般是随着页的操作一起完成的，即读写页的时候，对应地就读写了oob。</p><p>关于oob具体用途，总结起来有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记是否是坏快</span><br><span class="line">存储ECC数据</span><br><span class="line">存储一些和文件系统相关的数据。如jffs2就会用到这些空间存储一些特定信息</span><br></pre></td></tr></table></figure><h3><span id="1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</span><a href="#1-3-4-cun-chu-dan-wei-guan-xi" class="header-anchor">#</a></h3><p>一般情况下：1block &#x3D; 64page &#x3D; 64 * (2K+64B) &#x3D; 128K + 4K， 一个page包含2K数据和64B的oob。</p><h2><span id="1-4-feature-te-xing">1.4 Feature特性</span><a href="#1-4-feature-te-xing" class="header-anchor">#</a></h2><p>以<strong>K9F2G08U0C</strong>这款nandflash为例：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/5.png"></p><p>可以看出此款nandflash特性如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 容量为<span class="number">256</span>M，外加<span class="number">8</span>M的冗余oob存储区。</span><br><span class="line"><span class="number">2.</span> page大小为<span class="number">2</span>K，block大小为<span class="number">128</span>K</span><br><span class="line"><span class="number">3.</span> 读一个page时顺序读取至少<span class="number">25</span>*<span class="number">2048</span>ns(数据可以每字节<span class="number">25</span>ns的循环时间读出)，随机读取不超过<span class="number">40u</span>s</span><br><span class="line"><span class="number">4.</span> 写一个page一般为<span class="number">250u</span>s</span><br><span class="line"><span class="number">5.</span> 擦除一个block一般为<span class="number">2</span>ms</span><br><span class="line"><span class="number">6.</span> 封装上分为TSOP分装和FBGA封装（TSOP是指引脚在侧面，FBGA是引脚封在芯片底部，更能保障数据安全，有些客户为了保障数据安全性，防止被飞线进行数据破解，会要求用FBGA封装的flash）</span><br></pre></td></tr></table></figure><h2><span id="1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</span><a href="#1-5-chang-jian-de-flash-han-shang" class="header-anchor">#</a></h2><p>常见的flash厂商有：Micron（镁光）、Toshiba（东芝）、Samsung（三星）、MXIC(旺宏)、dosilicon(东芯)，（Winbond）华邦、ESMT等。</p><h1><span id="2-nand-kong-zhi-qi">2 Nand控制器</span><a href="#2-nand-kong-zhi-qi" class="header-anchor">#</a></h1><p>前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>介绍讲到，我们知道nand没有独立地址线，cpu无法直接访问nand上的指令，所以nand不能片上执行。那么为何程序还能支持nand启动的呢？</p><p>为了支持NAND启动，S3C2440A配备了一个称为“ Steppingstone”的内部SRAM缓冲区,容量为4K。 开机时，Nandflash中的前4K数据将被加载到Steppingstone中，而引导代码将被加载到SRAM中将被执行，如下图所示：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/6.png"></p><h2><span id="2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</span><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze" class="header-anchor">#</a></h2><p>我们知道s3c2440支持2种boot方式，nand或者nor，那么需要配置OM引脚来设置引导方式，如下图：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/7.png"></p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/8.png"></p><p>内存控制器的地址映射表如下：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/9.png"></p><p>当SW2闭合,OM0&#x3D;1, OM[1:0]&#x3D;01, 0地址对应nor，那么从nor启动。<br>当SW2断开,OM0&#x3D;0, OM[1:0]&#x3D;00, 0地址对应bootSRAM(4K)，那么0地址对应该SRAM, 那么从nand启动。</p><h2><span id="2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</span><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi" class="header-anchor">#</a></h2><p>当上电启动时，NAND Flash 控制器将通过下面的引脚配置来获取连接的 NAND Flash 的信息。</p><p><strong>NCON</strong>：NAND Flash 存储器选择（普通&#x2F;先进）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：普通 NAND Flash（<span class="number">256</span> 字或 <span class="number">512</span> 字节页大小，<span class="number">3</span> 或 <span class="number">4</span> 个地址周期）</span><br><span class="line"><span class="number">1</span>：先进 NAND Flash（<span class="number">1</span>K 字或 <span class="number">2</span>K 字节页大小，<span class="number">4</span> 或 <span class="number">5</span> 个地址周期）</span><br></pre></td></tr></table></figure><p><strong>GPG13</strong>：NAND Flash 存储器page size选择</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：页=<span class="number">256</span> 字（NCON=<span class="number">0</span>）或页=<span class="number">1</span>K 字（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：页=<span class="number">512</span> 字节（NCON=<span class="number">0</span>）或页=<span class="number">2</span>K 字节（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><strong>GPG14</strong>：NAND Flash 存储器地址周期选择</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">3</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">4</span> 个地址周期（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：<span class="number">4</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">5</span> 个地址周期（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure><p><strong>GPG15</strong>：NAND Flash 存储器总线宽度选择</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">8</span> 位宽度</span><br><span class="line"><span class="number">1</span>：<span class="number">16</span> 位宽度</span><br></pre></td></tr></table></figure><p>如下表所示更直观:<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/10.png"></p><h1><span id="3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</span><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu" class="header-anchor">#</a></h1><p>nandflash访问时需要遵循一定的时序才能完成命令、地址、数据的发送。nandflash有8bit位宽数据总线，那么没有地址线它是怎么和cpu通信的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>nandflash是DATA0～DATA7上既传输数据，又传输地址，又传输命令；</span><br><span class="line">①当ALE为高电平时传输的是地址；</span><br><span class="line">②当CLE为高电平时传输的是命令；</span><br><span class="line">③当ALE，CLE都为低电平表示传输的是数据</span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 先发送片选CS和WE/RE信号</span><br><span class="line"> <span class="number">3.</span> 再发送CLE</span><br><span class="line"> <span class="number">4.</span> 再发送ALE</span><br><span class="line"> <span class="number">5.</span> 最后发送数据</span><br></pre></td></tr></table></figure><p>下面分别介绍命令、地址、数据的发送过程。</p><h2><span id="3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</span><a href="#3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/11.png"></p><ol><li>首先看时钟，nand控制器的时钟源采用的是HCLK, 也就是AHB高速总线模式，可以参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>那么HCLK&#x3D;100Mhz, T&#x3D;1&#x2F;HCLK&#x3D;10ns。</li><li>从上图可知命令、地址锁存的时序是一样的，复用一个时序图，当到达①的位置时，CLE&#x2F;ALE&#x3D;0; </li><li>当到达位置②时，CLE&#x2F;ALE&#x3D;1,表示命令&#x2F;地址信号拉高，命令&#x2F;地址开始使能，然后往数据总线DATA上放入命令或地址;</li><li>经过TACLS时间，到达位置③时，拉低nWE引脚，这时数据总线DATA上的命令&#x2F;地址开始被锁存，锁存需要一定的时间，所以经过TWRPH0时间后，数据总线DATA上的命令&#x2F;地址锁存完成；</li><li>到达位置④，此时释放nWE信号，nWE&#x3D;1，这时还需要经过TWRPH1时间后，释放CLE&#x2F;ALE，此时一个完整的命令&#x2F;地址锁存过程完成。</li></ol><p>上面分析了命令&#x2F;地址的锁存时序过程，下面详细解释下上面几个时间参数的含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TACLS：CLE/ALE使能信号发送多久后才可以发送nWE信号</span><br><span class="line">TWRPH0:nWE信号发送多久后数据（commamd/addr）才会被锁存成功</span><br><span class="line">TWRPH1：nWE信号释放多久后才能释放CLE/ALE</span><br></pre></td></tr></table></figure><p>这些时间参数要根据我们实际使用的具体nandflash型号和性能来配置我们的nand控制器。</p><h3><span id="3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</span><a href="#3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu" class="header-anchor">#</a></h3><p>以K9F2G08U0C这款nandflash为例进行讲解，规格书上命令和地址锁存周期如下：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/12.png"></p><p>和nand控制器的命令&#x2F;地址锁存时序图对比发现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TACLS = max(tCLS,tALS) - tWP;</span><br><span class="line">TWRPH0 = tWP;</span><br><span class="line">TWRPH0 = max(tCLH,tALH);</span><br></pre></td></tr></table></figure><p>nand控制器把命令、地址锁存时序复用成了一个时序图，其实命令和地址锁存时序参数基本一致，只不过发命令只需要一个周期就OK了，发地址需要5个时钟周期，为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你想，命令多简单，无非就是读写擦，像我们这款nand数据位宽8bit，一个周期绰绰有余。但地址就不一样了，比如此款nandflash容量256M = 2^28，那么需要28根数据线来传输才能一个周期传输完，但这款nandflash的数据总线位宽只有8bit, 只有8根数据线，所以需要把地址拆分成多次发送，先发送col地址，再发送row地址，此款nandflash是用了5个周期发送地址。</span><br></pre></td></tr></table></figure><h2><span id="3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</span><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju" class="header-anchor">#</a></h2><p>从前面的命令地址锁存时序图中我们得知：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLE信号拉高，ALE信号拉低时，表示发送的命令；</span><br><span class="line">CLE信号拉低，ALE信号拉高时，表示发送的地址；</span><br></pre></td></tr></table></figure><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/13.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLE信号拉低, ALE信号拉低时，表示发送的数据;</span><br></pre></td></tr></table></figure><ol><li>当到达①时，nWE还是高电平，写使能没有开启；</li><li>当到达②,③时，那么经过了tWP时间（TDS时间），数据开始被锁存；</li><li>到达④，经过tDH时间，数据锁存完成;</li><li>到达⑤，也就是数据开始锁存后再过了tWH时间后释放nWE信号；</li><li>重复②③④⑤过程,得到DIN0, DIN1, DIN final。</li></ol><p>根据上面这三个图（手册上的命令、地址、数据锁存时序图），下面详细解释各个时间参数的含义：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/14.png"></p><h2><span id="3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</span><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/15.png"></p><ol><li>①处，表示要过tRR后才能发送读使能信号nRE进行访问（上一次的访问结束后，需要等待ready状态稳定后才可以进行下一次访问）；</li><li>当到达②，需要经过rREA时间后nRE信号才有效（待nRE稳定）；</li><li>当到达③，DATA总线上的读取被读取；</li><li>当到达④，nRE释放tREH时间后才允许下一次读使能；</li></ol><p>我们看到连续顺序访问时，单次访问的时间为tRC，那么这些时间参数的值也可以从K9F2G08U0C datasheet中找到：为25ns</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/16.png"></p><h1><span id="4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</span><a href="#4-nandflash-chu-shi-hua-he-shi-bie" class="header-anchor">#</a></h1><h2><span id="4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</span><a href="#4-1-nandflash-ming-ling-biao" class="header-anchor">#</a></h2><p>找到K9F2G08U0C datasheet，对NAND FLASH的操作需要发出命令，下面有个NAND FLASH的命令表格，用此表格上的命令来访问我们的nandflash：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/17.png"></p><h2><span id="4-2-du-id-shi-xu">4.2 读ID时序</span><a href="#4-2-du-id-shi-xu" class="header-anchor">#</a></h2><p>命令表中的读id还不太直观，下图是从nand芯片手册中截取出的读id时序图：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/18.png"></p><ol><li>第一条竖线位置，发送了nCE,CLE,nWE信号，所以90命令被锁存（readID命令）；</li><li>第二条竖线位置，发送了nCE,ALE,nWE信号，所以地址00被锁存；继续往后，命令、地址都发完了，要read数据了，所以释放nWE，ALE，这里tAR表示ALE释放多久后才可以发送nRE信号，tREA表示nRE信号的建立时间；</li><li>第三条竖线位置，发送了nCE,nRE信号，所以数据被锁存，第一个访问周期锁存的数据为marker code，值为0xEC，第二个访问周期的数据为device code，值为0xDA。读id时读5个周期含义对应如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/19.png"></li></ol><p>该款nandflash的5个周期读出来的值对应如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/20.png"></p><p>第四个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/21.png"></p><p>第五个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/22.png"></p><p>根据第4、5个访问周期的结果0x15、0x44我们得知该flash的block_size&#x3D;128K，page_size&#x3D;2k, 有2个plane，plane_size&#x3D;1Gb &#x3D; 128M, 共256M。</p><h2><span id="4-3-chu-shi-hua">4.3 初始化</span><a href="#4-3-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</span><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</span><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>nand控制器要按照我们nandflash的实际型号和性能来设置初始值。NFCONF寄存器，也叫nand配置寄存器：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/23.png"></p><p>以K9F2G08U0C这款nandflash为例：</p><p>前面<strong>第3.1.1小节</strong>分析了TACLS &#x3D; max(tCLS,tALS) - tWP，我们得知tCLS、tALS、tWP最小都可以取到12ns, 所以我们可以取TACLS&#x3D;0；</p><p>TWRPH0 &#x3D; tWP，我们的nand手册上要求tWP最少12ns, 那么取TWRPH0 &#x3D;1， Duration &#x3D; HCLK*(TWRPH0+1)&#x3D;20ns&gt;12ns，满足要求；</p><p>TWRPH0 &#x3D; max(tCLH,tALH), 我们的nand手册上要求tCLH、tALH最少5ns， 那么取TWRPH1 &#x3D;0， Duration &#x3D; HCLK*(TWRPH1+1)&#x3D;10ns&gt;5ns，满足要求。</p><p>再配置BusWidth总线位宽为8bit；<br>所以NFCONF寄存器设置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line"><span class="comment">/*设置NAND FLASH的时序*/</span></span><br><span class="line">NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4><span id="4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</span><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/24.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/25.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE [<span class="number">0</span>]: 设置为<span class="number">1</span>，使能NAND控制器。</span><br><span class="line">Reg_nCE [<span class="number">1</span>]: 设置为<span class="number">1</span>，禁止片选（等要使用的时候再使能片选信号）</span><br></pre></td></tr></table></figure><p>所以NFCONF寄存器设置如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使能NAND FLASH控制器，禁止片选*/</span></span><br><span class="line">NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2><span id="4-4-shi-bie-nandflash">4.4 识别nandflash</span><a href="#4-4-shi-bie-nandflash" class="header-anchor">#</a></h2><h3><span id="4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</span><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/26.png"></p><p>我们可以使用2440上的NAND FLASH控制器简化操作，只需要往NFCMMD寄存器写入要传输的命令就可以了，NAND FLASH控制器默认把上面复杂的时序发出来。</p><p>NFADDR-地址寄存器<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/27.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/28.png"></p><p>发命令后，后面就需要发送地址了，当nWE和ALE有效的时候，表示锁存的是地址，往NFADDR寄存器中写值就可以了，比如：NFADDR&#x3D;0x00。<br>我们得知地址需要用5个周期来发送，前2个周期为col地址，后三个周期为row(page)地址。前面<strong>第3小节</strong>已详细分析过了命令、地址、数据锁存时序过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> column: 列地址A0~A10，就是页内地址，地址范围是从<span class="number">0</span>到<span class="number">2047</span>。（A11用来确定oob的地址，即<span class="number">2048</span><span class="number">-2111</span>这<span class="number">64</span>个字节的范围）</span><br><span class="line"><span class="number">2.</span> page：A12～A30，称作页号，page(row)编号。</span><br></pre></td></tr></table></figure><h3><span id="4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</span><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/29.png"></p><p>当命令、地址都发送完后就可以从数据总线上DATA[7:0]获取数据或者写入数据。同样往NFDATA寄存器中写值或者读值就可以了，如unsigned char buf&#x3D;NFDATA,由于是数据位宽是8位的，所以访问时数据组织形式如下：</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/30.png"></p><p>从上图可以看出，当byte access时，只需一个时钟周期；当wold access的时候，需要4个时钟周期，小端模式下第一个时钟周期对应低字节，第四个时钟周期对应高字节。</p><p>识别nandflash代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化nand控制器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line">NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_select</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">NFCONT &amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*禁止片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_deselect</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">NFCONT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发命令*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">NFCCMD = cmd;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发地址*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_addr_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">NFADDR = addr;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*读数据*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">nand_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>NFDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*识别nandflash*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_chip_probe</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">nand_select(); </span><br><span class="line">nand_cmd(<span class="number">0x90</span>);</span><br><span class="line">nand_addr_byte(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">buf[<span class="number">0</span>] = nand_data();</span><br><span class="line">buf[<span class="number">1</span>] = nand_data();</span><br><span class="line">buf[<span class="number">2</span>] = nand_data();</span><br><span class="line">buf[<span class="number">3</span>] = nand_data();</span><br><span class="line">buf[<span class="number">4</span>] = nand_data();</span><br><span class="line">nand_deselect(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;maker   id  = 0x%x\n\r&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;device  id  = 0x%x\n\r&quot;</span>,buf[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;3rd byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;page  size  = %d kb\n\r&quot;</span>,<span class="number">1</span>  &lt;&lt;  (buf[<span class="number">3</span>] &amp; <span class="number">0x03</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;block size  = %d kb\n\r&quot;</span>,<span class="number">64</span> &lt;&lt; ((buf[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</span><a href="#5-nandflash-shu-ju-cao-zuo" class="header-anchor">#</a></h1><h2><span id="5-1-du-shu-ju">5.1 读数据</span><a href="#5-1-du-shu-ju" class="header-anchor">#</a></h2><p>读数据以page为单位的。下图的表格，来说明NAND FLASH内部结构，前面2K(0<del>2047)表示页数据，后边64字节(2048</del>2111)表示oob。</p><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/31.png"></p><p>CPU想读取，第2048个数据，它是哪以一个？</p><pre><code>是Page1的第0个字节。CPU使用某个地址访问数据的时候，是在页数据空间来寻址的。</code></pre><p>下图为读NAND FLASH的read时序操作：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/32.png"></p><ol><li>首先需要锁存00命令，nCE、CLE、nWE有效，0x00命令被锁存；</li><li>此时CLE无效，ALE开始有效,地址被锁存（从NAND FLASH的地址周期中可以看出来，先发出2个周期的col列地址，再发出3个周期的Row行地址）；</li><li>锁存0x30命令；</li><li>然后会有一个busy时间段，R&#x2F;nB为低电平。tRR表示busy状态的持续时间（手册上最小为20ns）。</li><li>开始锁存数据，nRE使能，nand上的数据被同步到数据nand控制器上。我们的nand是8bit数据位宽，所以每隔一个read时钟周期（tRC），传输1byte数据。每传输1byte数据，地址会自动往后偏移1byte，一般我们会连续读取1page数据。</li></ol><p>下面开始写代码：</p><h3><span id="5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</span><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>当发完命令、地址后再进行读数据前我们知道有一段时间tRR处于busy状态，我们可以通过查询NFSTAT寄存器来确定busy状态有没有结束，是不是已经ready了。<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/33.png"></p><p>wait_ready函数等待NAND FLASH空闲，从上图可以看出当NFSTAT寄存器[0]的值为1时NAND FLASH是空闲的，我们可以通过该位来判断NAND FLASH是否繁忙。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="keyword">while</span> (!(NFSTAT &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nand_read函数为NAND FLASH的读函数，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line"><span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">nand_select(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line"><span class="comment">/* 发出00h命令 */</span></span><br><span class="line">nand_cmd(<span class="number">00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发出地址 */</span></span><br><span class="line"><span class="comment">/* col addr */</span></span><br><span class="line">nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* row/page addr */</span></span><br><span class="line">nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发出30h命令 */</span></span><br><span class="line">nand_cmd(<span class="number">0x30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待就绪 */</span></span><br><span class="line">wait_ready();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读数据 */</span></span><br><span class="line"><span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)</span><br><span class="line">buf[i++] = nand_data();</span><br><span class="line"></span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">page++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nand_deselect(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到每read一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p><h3><span id="5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</span><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong" class="header-anchor">#</a></h3><p>在init.c文件中，加上如下代码，用来判断所使用的FLASH是NOR FLASH还是NAND FLASH。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们知道nand启动0地址对应片内SRAM，可以像内存一样的写0地址；nor启动，0地址对应nor,nor不能像内存一样的写地址，</span></span><br><span class="line"><span class="comment">**所以往0地址写入数据成功表示nand启动，写不成功表示nor启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isBootFromNorFlash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val = *p;</span><br><span class="line"></span><br><span class="line">*p = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">0x12345678</span>) &#123;</span><br><span class="line"><span class="comment">/* 写成功, 对应nand启动 */</span></span><br><span class="line">*p = val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是代码重定位时可以自动区分nand和nor启动，无论是nand启动还是nor启动，都能将程序重定位到sdram中去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">            <span class="comment">/* 要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line"><span class="comment">            * 然后从0地址把数据复制到__code_start</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> len = (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__bss_start) - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__code_start);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (isBootFromNorFlash()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (dest &lt; end)</span><br><span class="line">                    *dest++ = *src++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nand_init();</span><br><span class="line">        nand_read((<span class="type">unsigned</span> <span class="type">int</span>)src, dest, len);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2><span id="5-2-ca-shu-ju">5.2 擦数据</span><a href="#5-2-ca-shu-ju" class="header-anchor">#</a></h2><p>擦除数据以block为单位的。block erase时序图的过程大致如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/34.png"></p><pre><code>1.首先发送0x60命令2.发送row地址（由于擦除是以block为单位的，所以无需知道页内地址，只需要知道要擦除哪个page、哪个block即可）3.发送0xd0,执行擦除动作4.然后会有一个busy时间段，R/nB为低电平5.发送0x70命令，用来读取状态6.判断NFDATA寄存器的第0位是否擦除成功</code></pre><p>代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_erase</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, addr is not block align\n\r&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, len is not block align\n\r&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nand_select(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">page = addr / <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">nand_cmd(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* page addr */</span></span><br><span class="line">nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">nand_cmd(<span class="number">0xD0</span>);</span><br><span class="line"></span><br><span class="line">wait_ready();</span><br><span class="line"></span><br><span class="line">nand_cmd(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">if</span> (nand_data()&amp;<span class="number">0x1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, at addr:0x%x\n\r&quot;</span>, addr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len -= (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">addr += (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nand_deselect(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="5-3-xie-shu-ju">5.3 写数据</span><a href="#5-3-xie-shu-ju" class="header-anchor">#</a></h2><p>写数据以page为单位。往NAND FLASH写数据时，只需要把要写的数据复制给NFDATA寄存器即可。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_w_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">NFDATA = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>page write的写时序图如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/35.png"></p><pre><code>1.首先发送0x80命令2.发送地址（5个周期）3.发送数据4.发送0x10命令，执行烧写动作4.然后会有一个busy时间段，R/nB为低电平5.发送0x70命令，用来读取状态6.判断NFDATA寄存器的第0位是否烧写成功</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line"><span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line"><span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">nand_select(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">nand_cmd(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发出地址 */</span></span><br><span class="line"><span class="comment">/* col addr */</span></span><br><span class="line">nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* row/page addr */</span></span><br><span class="line">nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发出数据 */</span></span><br><span class="line"><span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)  <span class="comment">//还需确认</span></span><br><span class="line">nand_w_data(buf[i++]);</span><br><span class="line"></span><br><span class="line">nand_cmd(<span class="number">0x10</span>);</span><br><span class="line">wait_ready();</span><br><span class="line">        </span><br><span class="line">nand_cmd(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">if</span> (nand_data() &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nand_write err, at page:0x%x, addr:0x%x\n\r&quot;</span>, page, page&lt;&lt;<span class="number">11</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == len)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 开始下一个循环page */</span></span><br><span class="line">col = <span class="number">0</span>;</span><br><span class="line">page++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nand_deselect(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到每写一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p><h2><span id="5-4-ce-shi">5.4 测试</span><a href="#5-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得地址 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">addr = get_uint();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">nand_erase(addr, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得地址 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">addr = get_uint();</span><br><span class="line"></span><br><span class="line">nand_read(addr, buf, <span class="number">64</span>);</span><br><span class="line">p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)buf;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"><span class="comment">/* 长度固定为64 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line"><span class="comment">/* 先打印数值 */</span></span><br><span class="line">c = *p++;</span><br><span class="line">str[j] = c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line"><span class="comment">/* 后打印字符 */</span></span><br><span class="line"><span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">putchar</span>(str[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得地址 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">addr = get_uint();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">gets(str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">nand_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：本节的读、写、擦都只涉及到页数据区，不涉及到oob区的操作。</strong></p><h2><span id="5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</span><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu" class="header-anchor">#</a></h2><p>Nand Flash怎么标记某一个BLOCK是坏的? 如何识别一个flash中的坏快？ </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它使用该BLOCK中第<span class="number">1</span>个扇区的OOB数据中某一个字节来标记: 其值为<span class="number">0xff</span>表示该BLOCK是好的， 其值为非<span class="number">0xff</span>表示该BLOCK是坏的。</span><br><span class="line">在uboot中直接输入“nand bad ”命令即可识别某一个块是否为坏快，在linux用户态的情况下，需要用ioctl(MEMGETBADBLOCK)来获取该block是否为坏快。</span><br><span class="line">有时候我们会误写这个OOB区的值导致有些BLOCK被误认为是<span class="string">&quot;坏块&quot;</span>,可以在u-boot中执行<span class="string">&quot;nand scrub&quot;</span>后, 根据提示信息输入小写字母<span class="string">&#x27;y&#x27;</span>并回车, 它会强制擦除整个Nand <span class="title function_">Flash</span><span class="params">(包括把OOB擦除为<span class="number">0xff</span>)</span>, 这样就可以恢复被误标为坏块的区域了。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-nandflash-yuan-li&quot;&gt;1 nandflash原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-yuan-li-tu&quot;&gt;1.1 原理图&lt;/a&gt;&lt;/li</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="存储驱动" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-ADC</title>
    <link href="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/"/>
    <id>http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/</id>
    <published>2024-04-16T11:57:19.000Z</published>
    <updated>2024-04-18T06:36:56.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-adc-ying-jian-yuan-li">1 ADC硬件原理</a><ul><li><a href="#1-1-adc-shu-xing">1.1 ADC属性</a></li><li><a href="#1-2-adc-kuang-tu">1.2 ADC框图</a></li></ul></li><li><a href="#2-adc-ji-cun-qi">2 ADC寄存器</a><ul><li><a href="#2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</a></li><li><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</a></li><li><a href="#2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</a></li></ul></li><li><a href="#3-bian-cheng-ce-shi">3 编程测试</a></li></ul><!-- tocstop --></div><h1><span id="1-adc-ying-jian-yuan-li">1 ADC硬件原理</span><a href="#1-adc-ying-jian-yuan-li" class="header-anchor">#</a></h1><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p><p>如图，把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。以s3c2440为例：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/1.jpg"></p><h2><span id="1-1-adc-shu-xing">1.1  ADC属性</span><a href="#1-1-adc-shu-xing" class="header-anchor">#</a></h2><p>对于数字信号我们需要得到它的2个属性：</p><ol><li><p>转换精度：<br>用多少位来存储这个数据（假如是10 bit）。那么最大值0b111111111对应3.3v， 0b0对应0v。</p></li><li><p>采样&#x2F;转换速度：</p></li></ol><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/2.png"><br>可以看出s3c2440的转换精度可达10 bit, 转换速率可达 500ksps.</p><h2><span id="1-2-adc-kuang-tu">1.2 ADC框图</span><a href="#1-2-adc-kuang-tu" class="header-anchor">#</a></h2><p>下图是s3c2440芯片的ADC转换框图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/3.png"></p><p>可以看出AD converter前有一个MUX选择器，用来选择模拟输入源，这里选择A[3:0]作为输入源。</p><p>下面是编写程序要做的步骤：</p><pre><code>1.确定是哪一路信号：设置8：1MUX2.设置工作时钟3.启动ADC4.读状态，判断ADC转换是否成功。5.读数据</code></pre><h1><span id="2-adc-ji-cun-qi">2 ADC寄存器</span><a href="#2-adc-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</span><a href="#2-1-kong-zhi-ji-cun-qi-adccon" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/4.png"></p><pre><code>bit[15]：只读，用来表示转换是否完成bit[14:6]:用来设置adc频率（如果是auto TSC则不用设置该位）bit[5：3]:用来选择模拟输入源bit[2]:用来设置是否待机bit[0]:用来启动adc</code></pre><h2><span id="2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</span><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/5.png"></p><h2><span id="2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</span><a href="#2-3-shu-ju-ji-cun-qi-adcdat0" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/6.png"></p><pre><code>bit[9:0]表示转换后的数据</code></pre><h1><span id="3-bian-cheng-ce-shi">3 编程测试</span><a href="#3-bian-cheng-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/7.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//设置输入源AIN0, ADC时钟为1Mhz,并且使能预分频</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_read_ain0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 启动ADC */</span></span><br><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (!(ADCCON &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)));  <span class="comment">/* 等待ADC结束 */</span></span><br><span class="line"><span class="keyword">return</span> ADCDAT0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-adc-ying-jian-yuan-li&quot;&gt;1 ADC硬件原理&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-adc-shu-xing&quot;&gt;1.1 ADC属性&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机-异常中断</title>
    <link href="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/"/>
    <id>http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/</id>
    <published>2024-04-16T06:55:01.000Z</published>
    <updated>2024-04-18T06:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</a><ul><li><a href="#1-1-cpu-mo-shi">1.1 CPU模式</a></li><li><a href="#1-2-gong-zuo-state">1.2 工作State</a></li><li><a href="#1-3-arm-ji-cun-qi">1.3 ARM寄存器</a><ul><li><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</a></li><li><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</a></li></ul></li><li><a href="#1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</a></li></ul></li><li><a href="#2-yi-chang-chu-li-liu-cheng">2 异常处理流程</a><ul><li><a href="#2-1-zhong-duan-qian">2.1 中断前</a><ul><li><a href="#2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</a></li></ul></li><li><a href="#2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</a><ul><li><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</a></li></ul></li><li><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</a></li></ul></li><li><a href="#3-zhong-duan-shi-li">3 中断实例</a><ul><li><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</a><ul><li><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</a></li><li><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</a></li><li><a href="#3-1-3-shi-li-gai-jin">3.1.3 示例改进</a><ul><li><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</a></li><li><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</a></li><li><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</a></li></ul></li></ul></li><li><a href="#3-2-swi-ruan-zhong-duan">3.2 swi-软中断</a><ul><li><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</a><ul><li><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</a></li></ul></li></ul></li><li><a href="#3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</a><ul><li><a href="#3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</a></li><li><a href="#3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</a><ul><li><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</a></li><li><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</a></li><li><a href="#3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</a></li><li><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</a></li></ul></li></ul></li><li><a href="#3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</a><ul><li><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</a><ul><li><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</a><ul><li><a href="#3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</a></li><li><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</a></li></ul></li></ul></li><li><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</a><ul><li><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</a></li><li><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</a></li></ul></li><li><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</a><ul><li><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</a></li><li><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</a><ul><li><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</a></li><li><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</a></li></ul></li></ul></li></ul></li><li><a href="#3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</span><a href="#1-yi-chang-zhong-duan-yin-ru" class="header-anchor">#</a></h1><p>在arm架构的处理器中，cpu有7中工作模式，2中工作状态。</p><h2><span id="1-1-cpu-mo-shi">1.1 CPU模式</span><a href="#1-1-cpu-mo-shi" class="header-anchor">#</a></h2><pre><code>7种Mode: 除了usr/sys，其他5种都是异常模式。我们知道中断属于异常的2中，中断有irq,fiq。</code></pre><table><thead><tr><th>usr</th><th>sys</th><th>undefined(und)</th><th>Supervisor(svc)</th><th>Abort(abt)</th><th>irq</th><th>fiq</th></tr></thead><tbody><tr><td>用户模式</td><td>系统模式</td><td>未定义指令异常模</td><td>svc管理模式</td><td>终止模式（1.指令预取终止(读写某条错误的指令导致终止运行)；2.数据访问终止(读写某个非法地址程序终止)）</td><td>irq中断</td><td>快中断</td></tr></tbody></table><p>除了usr模式，其他6中为特权模式。 CPU无法从usr模式直接进入特权模式。不能直接进入特权模式，那么<strong>怎么进入特权模式</strong>呢？</p><p>可以通过<strong>设置CPSR</strong>进入其他模式。</p><h2><span id="1-2-gong-zuo-state">1.2 工作State</span><a href="#1-2-gong-zuo-state" class="header-anchor">#</a></h2><pre><code>ARM stateThumb state(几乎用不上)</code></pre><h2><span id="1-3-arm-ji-cun-qi">1.3 ARM寄存器</span><a href="#1-3-arm-ji-cun-qi" class="header-anchor">#</a></h2><pre><code>(1)通用寄存器:(2)备份寄存器(banked register):    CPSR:当前程序状态寄存器(Current Program Status Register) 反映程序处在那种状态    SPSR:CPSR的备份寄存器 (Saved Program Status Register)  用来保存&quot;被中断前的CPSR&quot;</code></pre><p>下图是我们arm状态下的通用寄存器和程序状态寄存器<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/1.png"></p><p><strong>R13是SP（栈指针）</strong><br><strong>R14是LR</strong>（link register），程序跳转或者发成异常时的返回地址<br><strong>R15是PC</strong>（程序计数器）</p><p>假设cpu执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov R0, R8</span><br><span class="line">mov R0,R8_fiq</span><br></pre></td></tr></table></figure><p>在usr&#x2F;System 模式下访问的R8, 但是在FIQ模式下，访问R8是访问FIQ模式专属的R8寄存器，不是同一个物理上的寄存器。<br>在5种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈)， R14(LR)是用来保存发生异常时的指令地址。</p><p>为什么快中断(FIQ)有那么多专属寄存器?<br>这些寄存器称为备份寄存器，我们先看下<strong>中断处理流程</strong>：</p><pre><code>1 保存现场(保存被中断模式的寄存器)---(比如程序正在sys/usr模式下运行，当发生中断时，需要把R0-R14这些寄存器全部保存下来)2 异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）3 恢复现场(恢复被中断时保存下来的寄存器R0-R14)</code></pre><p>但如果是快中断，那么我就不需要保存系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，因为在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度，所以它才称得上快中断。</p><h3><span id="1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</span><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>在异常中断中PSR寄存器会使用的很频繁，PSR寄存器的格式如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/2.png"></p><p>我们再来看看下表，反映的是PSR的 M[4:0]与arm工作模式的关系：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/3.png"></p><p>我们可以按照上图的对应关系设置CPSR，让其进入与之对应的模式。</p><h3><span id="1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</span><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h2><span id="1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</span><a href="#1-4-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p><strong>异常向量</strong>：不同的异常有不同的入口函数，那么这个异常入口函数的地址就是存放在该异常向量的位置。从该异常向量读取到的数据就是异常入口函数的地址。<br><strong>异常向量表</strong>：就是由异常向量组成的集合。</p><p>下图是从uboot源代码中截取的smdk2410 的异常向量表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:b       reset</span><br><span class="line">ldrpc, _undefined_instruction</span><br><span class="line">ldrpc, _software_interrupt</span><br><span class="line">ldrpc, _prefetch_abort</span><br><span class="line">ldrpc, _data_abort</span><br><span class="line">ldrpc, _not_used</span><br><span class="line">ldrpc, _irq</span><br><span class="line">ldrpc, _fiq</span><br></pre></td></tr></table></figure><p>异常向量表对应的地址如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/4.png"></p><h1><span id="2-yi-chang-chu-li-liu-cheng">2 异常处理流程</span><a href="#2-yi-chang-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>CPU是如何进入到中断模式，执行中断服务程序的？</p><h2><span id="2-1-zhong-duan-qian">2.1 中断前</span><a href="#2-1-zhong-duan-qian" class="header-anchor">#</a></h2><p>下图是中断未触发前的程序执行过程：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/5.png"></p><h3><span id="2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</span><a href="#2-1-1-chu-shi-hua-zhong-duan" class="header-anchor">#</a></h3><pre><code>1，设置中断源（使中断能够产生，让CPU知道是哪个中断）2，设置中断控制器（设置中断屏蔽，中断优先级）3，设置中断总开关CPSR (使能中断)</code></pre><h2><span id="2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</span><a href="#2-2-zhong-duan-chan-sheng-hou" class="header-anchor">#</a></h2><p>举个栗子：按键按下，产生按键irq。</p><h3><span id="2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</span><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h3><p>cpu强制跳转到异常向量表上对应的_irq异常向量（0x18）去读取指令（这个是CPU强制执行的，不需要我们去控制）。</p><p>具体的进入中断向量和中断返回流程见下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/6.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入：</span><br><span class="line"> (<span class="number">1</span>) LR_异常=PC + offset（具体多少看下图）</span><br><span class="line">（<span class="number">2</span>）SPSR_异常=被中断前的程序模式CPSR</span><br><span class="line"> (<span class="number">3</span>) CPSR被设置成对应的异常模式</span><br><span class="line">（<span class="number">4</span>）跳转到对应的异常向量去执行</span><br><span class="line">退出（返回）：进入和退出就是一个逆过程</span><br><span class="line">（<span class="number">1</span>）PC= LR_异常 -offset</span><br><span class="line">（<span class="number">2</span>）被中断前的程序模式CPSR = SPSR_异常</span><br><span class="line">（<span class="number">3</span>）中断结束，清中断</span><br></pre></td></tr></table></figure><p>进入异常和返回异常时pc和lr的关系如下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/7.png"></p><p>从图中我们发现进入不同异常，offset的值也是有差异的。</p><h2><span id="2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</span><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h2><pre><code>1.当跳转到irq异常向量(0x18)后，发现该处是一条跳转指令“ldr pc, _irq”,那么会通过ldr绝对跳转指令跳到到真正的中断处理函数_irq去执行。2.那么在_irq的函数中我们需要按照之前说的**中断处理流程**去执行：    （1）保存现场    （2）异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）    （3）恢复现场</code></pre><p>流程图总结下中断产生后的详细处理过程：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/8.png"></p><h1><span id="3-zhong-duan-shi-li">3 中断实例</span><a href="#3-zhong-duan-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</span><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang" class="header-anchor">#</a></h2><p>先来看下当cpu解析到什么样的指令才会触发未定义指令异常呢？</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/9.png"></p><p>从上面的arm指令格式中可知，只要指令码属于划线的格式，就属于未定义指令异常。</p><h3><span id="3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</span><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can" class="header-anchor">#</a></h3><p>我们知道汇编给C语言函数传参是通过r0，r1，…通过堆栈的方式去传递的参数，比如r0&#x3D;1, r1&#x3D;2;那么在被调用的c函数中argv0就是r0, argv1就是r1…,那么我们如果通过汇编给C函数传递字符串呢？</p><p>声明und_string为一个字符串:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">und_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br></pre></td></tr></table></figure><p>然后用<code>ldr r1, =und_string</code>，这样r1中就保存了und_string的地址。<br>这样调用我们的c函数就可以把und_string传入进去。</p><h3><span id="3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</span><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line">reset:</span><br><span class="line"><span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">时钟</span></span><br><span class="line"><span class="comment">sdram</span></span><br><span class="line"><span class="comment">设置SP</span></span><br><span class="line"><span class="comment">重定位*/</span></span><br><span class="line">...</span><br><span class="line">bl print1</span><br><span class="line">und_code:</span><br><span class="line">.word <span class="number">0xdeadc0de</span>; <span class="comment">/*定义一条未定义指令*/</span></span><br><span class="line"><span class="comment">/*故意以一个数据的方式引入一条未定义指令，当cpu执行到这里，读取0xdeadc0de指令码的时候，</span></span><br><span class="line"><span class="comment">发现无法识别这条指令，就发生未定义指令异常，就跳转到0x4的中断向量去执行*/</span></span><br><span class="line"></span><br><span class="line">bl print2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在未定义指令异常前后加上打印print1, print2，<strong>如果出现未定义指令异常后，就会跳到0x4的地方去读取指令，print2也就没法执行</strong>。</p><p>当跳转到0x4的中断向量后，发现此处是一条跳转指令<code>bl do_und</code>, 我们再到未定义指令异常的服务程序do_und中打印出und_string这个字符串的内容。<br>现在开始写指令异常的服务程序do_und，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">do_und:</span><br><span class="line"><span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理und异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure><p>下面来分析一下这个未定义指令异常服务程序:</p><ol><li><p>进入未定义指令异常服务do_und之前硬件自动完成的事情如下：</p><ol><li>lr_und保存有被中断模式中的下一条即将执行的指令的地址</li><li>SPSR_und保存有被中断模式的CPSR</li><li>CPSR中的M4-M0被设置为11011, 进入到und模式</li><li>跳到0x4的地方执行程序 （bl do_und）</li></ol></li><li><p>进入指令异常服务程序do_und后，我们需要保存现场，处理und异常,恢复现场，<strong>注意：由于发生了cpu模式切换，如果要用到栈，那么先要设置对应模式的栈。</strong>由于栈的地址是向下生长的，这里我就用sdram的末位地址作为栈指针，把sp_und&#x3D;0x34000000。</p></li><li><p>在und异常服务程序中有可能会用到栈, 所以先保存现场，通过<code>stmdb sp!, &#123;r0-r12, lr&#125;</code>语句把栈中的值备份到r0-r12和lr，然后恢复现场的时候通过<code>ldmia sp!, &#123;r0-r12, pc&#125;^</code>，详见上面的注释。</p></li><li><p>我们看到保存现场后，我们把cpsr的值放到r0, 把und_string放到r1, 然后用bl printException调用c函数，这样我们的c函数printException就能收到汇编传过来的参数，一个是cpsr模式（r0），一个是und_string汇编传过来的字符串(r1)。我们用C函数实现printException：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printException</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpsr, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Exception! cpsr = &quot;</span>);</span><br><span class="line">printHex(cpsr);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line"></span><br><span class="line">b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line"></span><br><span class="line">do_und:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_und保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为11011, 进入到und模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x4的地方执行程序 （bl do_und）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理und异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">und_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line"><span class="comment">/* 时钟 */</span></span><br><span class="line"><span class="comment">/* sdram */</span></span><br><span class="line">bl copy2sdram</span><br><span class="line">bl clean_bss</span><br><span class="line"></span><br><span class="line">bl uart0_init</span><br><span class="line"></span><br><span class="line">bl print1</span><br><span class="line"><span class="comment">/* 故意加入一条未定义指令 */</span></span><br><span class="line">und_code:</span><br><span class="line">.word <span class="number">0xdeadc0de</span>  <span class="comment">/* 未定义指令 */</span></span><br><span class="line">bl print2</span><br><span class="line"></span><br><span class="line"><span class="comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span></span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p><strong>测试结果</strong>如下：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/10.png"></p><p>打印出print1中的字符串‘abc’后，紧接着打印printException函数中的结果，cpsr&#x3D;0x600000db,那么对应的M[4:0]&#x3D;11011， 对应下图为und模式。然后从und异常返回，恢复原来的模式继续执行。</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/11.png"></p><h3><span id="3-1-3-shi-li-gai-jin">3.1.3 示例改进</span><a href="#3-1-3-shi-li-gai-jin" class="header-anchor">#</a></h3><h4><span id="3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</span><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi" class="header-anchor">#</a></h4><p>我们将上面的代码的und_string字符串修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line"><span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>编译烧录再次运行，发现没有任何打印输出，这是为什么呢？我明明只是把und_string字符串改了一下呀。</p><p>查看反汇编：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/12.png"></p><p>我们发现reset的地址是0x30000032，竟然不是4字节对齐的，我们知道arm指令集是以4字节为基本单位的，那么这里没有对齐，肯定无法解析指令。那么我们手工改进代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br></pre></td></tr></table></figure><font color="red" size="2.5">.align 4</font><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line"><span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/13.png"></p><p>我们再来看看反汇编，发现reset的地址是30000040，是以4字节对齐的，再次烧录运行，发现能够正常输出print1, 能够进入未定义指令异常。</p><h4><span id="3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</span><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang" class="header-anchor">#</a></h4><p>如果我们程序非常大，中断向量入口代码的地址可能会大于sram的容量4k，比如do_und和do_swi，那么这个时候就需要用绝对跳转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">    b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br></pre></td></tr></table></figure><p>将上面的相对跳转换成如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">b reset  </span><br><span class="line">ldr pc, und_addr </span><br><span class="line">    ldr pc, swi_addr</span><br><span class="line">    ...</span><br><span class="line">    ... </span><br><span class="line">und_addr:</span><br><span class="line">.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">    .word do_swi</span><br></pre></td></tr></table></figure><p>这样我们的do_und， do_swi就可放在4k之外的地方, 放到sdram。</p><h4><span id="3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</span><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing" class="header-anchor">#</a></h4><p>我们现在不断增加的程序代码量，那么有可能在 <code>ldr pc, =main</code> 这条指令执行之前程序就已经超过4k。那么我们当从nand启动的时候，还没执行到ldr pc, &#x3D;main这句来，就无法取指令执行了。nor同理超过2M也就无法取指令执行了。 所以我们干脆重定位完代码后就直接跳转到sdram上去执行,代码简要概述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">reset：</span><br><span class="line"><span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">时钟</span></span><br><span class="line"><span class="comment">set SP</span></span><br><span class="line"><span class="comment">sdram_init</span></span><br><span class="line"><span class="comment">重定位*/</span></span><br><span class="line">ldr pc, =sdram</span><br><span class="line">sdram：</span><br><span class="line">   ...</span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>我们再来分析下整个程序执行过程：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/14.jpg"></p><pre><code>1.一上电，cpu从0地址执行，执行b reset（进行初始化硬件）2.重定位程序3.跳转到sdram去继续执行4.执行到 deadc0de,发生未定义指令异常5.跳转到异常向量表的0x4地址去执行6.跳转到sdram上执行异常处理函数（do_und）7.异常返回，继续执行</code></pre><h2><span id="3-2-swi-ruan-zhong-duan">3.2 swi-软中断</span><a href="#3-2-swi-ruan-zhong-duan" class="header-anchor">#</a></h2><p>arm有7中工作模式，除了usr模式，其他6种都是特权模式。</p><p>我们知道usr模式无法修改CPSR直接进入其他特权模式，但linux应用程序一般运行在usr模式，既然usr模式权限非常低，是无法直接访问硬件寄存器的，那么它是如何访问硬件的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux应用程序是通过系统调用，从而进入内核态，运行驱动程序来访问的硬件，那么系统调用又是如何实现的呢，就是通过软中断swi指令来进入svc模式，进入到svc模式后当然就能访问硬件啦。</span><br></pre></td></tr></table></figure><p>所以我们的应用程序在usr模式想访问硬件，必须切换模式:</p><p>有以下两种方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 发生异常或中断(被动的)</span><br><span class="line"><span class="number">2.</span> swi + 某个值(主动的)</span><br></pre></td></tr></table></figure><h3><span id="3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</span><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi" class="header-anchor">#</a></h3><p>s3c2440 一上电会跳到0地址（reset复位）执行代码，此时CPU处于svc模式，2440异常向量表如下图所示:<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/15.png"></p><p>为了验证usr模式能够主动的通过swi软中断指令来进入svc模式, 我们先将模式切换到usr模式，那么这个时候就不能访问硬件了，也不能直接修改cpsr直接进入其他模式。</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/16.png"></p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/17.png"></p><p>从上图我们设置CPSR让M4-M0处在10000，这样就进入了usr模式。修改start.s如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">b reset  </span><br><span class="line">ldr pc, und_addr </span><br><span class="line">ldr pc, swi_addr</span><br><span class="line">...</span><br><span class="line">und_addr:</span><br><span class="line">.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">.word do_swi</span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">看门狗</span></span><br><span class="line"><span class="comment">时钟</span></span><br><span class="line"><span class="comment">set SP</span></span><br><span class="line"><span class="comment">sdram_init</span></span><br><span class="line"><span class="comment">重定位</span></span><br><span class="line"><span class="comment">bl uart0_init</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*先进入usr模式*/</span></span><br><span class="line">mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line"><span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">msr cpsr, r0 <span class="comment">/* 写入cpsr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>那么当执行到swi 0x123，就会触发SWI异常, 进入0x8的向量去执行，调用do_swi，我们参考do_und实现我们的软中断服务程序do_swi。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">b reset  </span><br><span class="line">ldr pc, und_addr </span><br><span class="line">ldr pc, swi_addr</span><br><span class="line">...</span><br><span class="line">und_addr:</span><br><span class="line">.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">.word do_swi</span><br><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">看门狗</span></span><br><span class="line"><span class="comment">时钟</span></span><br><span class="line"><span class="comment">set SP</span></span><br><span class="line"><span class="comment">sdram_init</span></span><br><span class="line"><span class="comment">重定位</span></span><br><span class="line"><span class="comment">bl uart0_init</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*先进入usr模式*/</span></span><br><span class="line">mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line"><span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">msr cpsr, r0 <span class="comment">/* 写入cpsr */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>do_swi中调用printException，打印出了软中断异常的字符串和CPSR对应的svc模式。</p><h4><span id="3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</span><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao" class="header-anchor">#</a></h4><p>我们要读出swi 0x123指令，我们知道当执行完swi 0x123指令以后，会发生swi异常，那么lr_svc &#x3D; PC + offset。从下图看出offset是4：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/18.png"></p><p>修改中断服务函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;</span><br></pre></td></tr></table></figure><p>我们要把lr拿出来保存,因为bl printException会破坏lr，那么把lr保存在哪个个寄存器比较好呢？</p><p>我们知道当调用<code>bl printException</code>可能会修改某些寄存器，但是又会恢复这些寄存器，那么得知道它会保护哪些些寄存器。<br>来看下ATPCS规则：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/19.png" alt="img"></p><p>在子程序中,使用R4~R11来保存局部变量,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值。所以对于 r4 ~ r11在C函数里会保存这几个寄存器，执行完C函数再把它释放掉并且恢复原来的值。我们把lr 保存在r4寄存器里，r4寄存器不会被C语言破坏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov r4, lr</span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string</span><br><span class="line">bl printException</span><br></pre></td></tr></table></figure><p>当执行完<code>swi 0x123</code>指令后，会发生swi异常，swi异常模式里的lr寄存器会保存下一条指令的地址（即’ldr pc, &#x3D;main’），我们把lr寄存器的地址减去4就是<code>swi 0x123</code>这条指令的地址。</p><p>把r4的寄存器赋给r0让后打印我们得写出打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    mov r0, r4</span><br><span class="line"></span><br><span class="line">    sub r0, r4, #<span class="number">4</span><span class="comment">//得到swi指令的地址</span></span><br><span class="line">    bl printSWIVal</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure><p>在uart.c添加printSWIVal打印函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printSWIVal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSWI)</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;SWI val = &quot;</span>);</span><br><span class="line">printHEx(*pSWI &amp; ~<span class="number">0xff000000</span>); <span class="comment">//高8位忽略掉  </span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</span><a href="#3-3-irq-wai-bu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</span><a href="#3-3-1-yin-ru-wai-bu-zhong-duan" class="header-anchor">#</a></h3><p>我们想实现一个按键点灯程序，我们知道有以下两种方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>轮询方案:轮询检测按键的电平状态，当检测到被按下后，对应的gpio会拉低，点亮对应的led;(略)</span><br><span class="line"><span class="number">2.</span>中断方案:将按键配置成外部中断源，当有按键按下，触发中断，在中断服务程序（isr）中去完成点灯。</span><br></pre></td></tr></table></figure><p>我们用按键作为外部中断源，我们把按键对应的gpio配置成中断引脚，当按键按下，相应的gpio产生了电平跳变，就会触发外部中断。</p><h3><span id="3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</span><a href="#3-3-2-wai-bu-zhong-duan-shi-li" class="header-anchor">#</a></h3><p>我们想达到按下按键灯亮, 松开按键灯灭这种效果（配成双边沿触发，按下的时候产生下降沿中断，进行点亮，松开产生上升沿中断，进行熄灭）。当然也可做成按一下点亮，再按一下熄灭的效果（设成单边沿触发，每来一次中断，对led电平进行一次取反）。<br>原理图如下：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/20.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/21.png"></p><p>从按键的原理图中得知，当按键没有按下时，接上拉电阻，按键为高电平状态。当按键按下时，电位被拉低，按键处于低电平状态。s2-s5分别对应GPF0，GPF2，GPG3，GPG11; D10-D12这3盏led所对应的gpio分别是GPF4，GPF5，GPF6。</p><p>那么我们让s2,s3,s4分别控制D10,D11,D12；s5对D10-D12同时控制（按下s5同时点亮3个led）。</p><h4><span id="3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</span><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan" class="header-anchor">#</a></h4><p>配置D10-D12的gpio为输出模式，s2-s4的gpio为外部中断模式。</p><p>打开芯片手册找到第九章 IO ports，找到对应的gpio控制寄存器，将对应的gpio配置成中断模式。</p><ol><li>配置GPF GPIO为中断引脚：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/22.png"><br>同理GPG的寄存器类似。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">4</span>));<span class="comment">//先把eint0和eint2这两个引脚清零</span></span><br><span class="line">GPFCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">4</span>));   <span class="comment">//S2,S3被配置为中断引脚</span></span><br><span class="line"></span><br><span class="line">GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">22</span>));</span><br><span class="line">GPGCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">22</span>));   <span class="comment">//S4,S5被配置为中断引脚</span></span><br></pre></td></tr></table></figure><ol start="2"><li>设置中断触发方式:</li></ol><p>当电平从高变低时，此时表示按键按下，当电平由低变高，表示松开按键。不妨设置中断方式为双边沿触发，按下按键，触发下降沿中断，中断服务程序就可以去点亮led，反之，松开触发上升沿中断，就可以去熄灭led。<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/23.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/24.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/25.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTINT0 |= (<span class="number">7</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">7</span>&lt;&lt;<span class="number">8</span>);     <span class="comment">/* S2,S3 */</span></span><br><span class="line">EXTINT1 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S4 */</span></span><br><span class="line">EXTINT2 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S5 */</span></span><br></pre></td></tr></table></figure><ol start="3"><li>设置外部中断屏蔽寄存器EINTMASK：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/26.png"></li></ol><p>从上图我们知道外部中断0-3是直接连接到中断控制器，而外部中断4-7、外部中断8-23还要经过EINTMASK,那么我们需要配置EINTMASK来打开中断的通道：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/27.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EINTMASK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">19</span>));    <span class="comment">//打开外部中断通道</span></span><br></pre></td></tr></table></figure><ol start="4"><li>外部中断挂起寄存器EINTPEND:</li></ol><p>当一个外部中断（EINT4-EINT23）发生后，那么相应的位会被置1, 所以中断结束后需要清除对应位。这个寄存器可以用来区分外部中断4-23的哪一个中断源。</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/28.png"></p><h4><span id="3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</span><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi" class="header-anchor">#</a></h4><p>我们先来看下中断控制器的总框图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/29.png"></p><p><strong>1. 首先是SRCPND:用来表示哪个中断源发出了中断请求。</strong></p><p>先看下中断源:<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/30.png"></p><p>从上图我们发现外部中断有24个外部中断，除了外部中断EINT，还有定时器中断，ADC中断，UART中断等…。</p><p>我们来认识下SRCPND寄存器：（用来表示哪个（哪些）中断源已产生中断请求，中断结束后要清中断）<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/31.png"></p><p>从上图中我们发现EINT4-7共用1bit，EINT8-23共用1bit，那么肯定有其他寄存器来区分它们，那就是EINTPEND寄存器（后面5会讲）。</p><p><strong>2. 然后到达INTMSK：（中断屏蔽寄存器）</strong></p><p>我们需要把INTMSK寄存器配置成非屏蔽状态，默认是中断源时屏蔽的，见下图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/32.png"></p><p><strong>3.INTMOD（中断模式，是fiq还是irq）</strong><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/33.png"></p><p><strong>4.Priroty:</strong></p><p><strong>5.INTPND:</strong><br>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p><p>中断发生后，SRCPND中会有bit置1，可能好几个（因为同时可能发生几个中断），这些中断会由优先级仲裁器选出一个最紧迫的，然后把INTPND中相应位置1。所以只有INTPND置1，CPU才会处理。</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/34.png"></p><p>我们知道有可能同时出现多个中断请求，那么INTPND就挑选出当前优先级最高的、正在发生的中断。</p><p>当产生irq后，要去分辨是哪个中断源，根据不同的中断源去中断服务程序isr中做不同的事情，那么如何得知当前产生的中断是哪一个外部中断源产生的呢？那么就可以访问这个INTPND寄存器。</p><p>可是我们要去手工去解析INTPND里面的位，才能知道是哪个中断源产生了中断请求。那么有没有什么比较快捷的方式自动帮我们解析INTPND呢，直接返回中断号给我们？</p><p>当然有啦，有一个INTOFFSET寄存器的值就是代表哪个中断请求产生了，如果INTOFFSET&#x3D;0表示EINT0产生了中断请求，INTOFFSET&#x3D;2表示EINT2产生了中断请求。具体见下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/35.png"></p><p>我们从上图看到ENIT4-7共用一个offset， EINT8-23也共用一个offset，那么要通过访问EINTPEND寄存器来区分它们。</p><p>中断控制器设置代码入下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化中断控制器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19</span></span><br><span class="line">    INTMSK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)); </span><br><span class="line">    <span class="comment">//INTMOD默认是irq，可以不设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</span><a href="#3-3-3-3-zhong-duan-zong-kai-guan" class="header-anchor">#</a></h4><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/36.png"></p><p>CPSR有I位，是irq的总开关，我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把bit7这一位清零 */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br></pre></td></tr></table></figure><h4><span id="3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</span><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>到这里中断前的初始化工作知识点就已经讲完了，当然要提前准备好led初始化工作（就是将led对应的gpio配置成输出模式，这个不讲解）。</p><p>那么中断产生后，我们之前讲过，会跳转到0x18异常向量，执行跳转指令<code>ldr pc, =_irq</code>，和之前的swi异常，und异常框架一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line"></span><br><span class="line">ldr pc, und_addr <span class="comment">/* vector 4 : und（绝对跳转） */</span></span><br><span class="line">ldr pc, swi_addr <span class="comment">/* vector 8 : swi */</span></span><br><span class="line">b halt <span class="comment">/* vector 0x0c : prefetch aboot */</span></span><br><span class="line">b halt <span class="comment">/* vector 0x10 : data abort */</span></span><br><span class="line">b halt <span class="comment">/* vector 0x14 : reserved */</span></span><br><span class="line">ldr pc, irq_addr <span class="comment">/* vector 0x18 : irq */</span></span><br><span class="line">b halt <span class="comment">/* vector 0x1c : fiq */</span></span><br><span class="line"></span><br><span class="line">und_addr:</span><br><span class="line">.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">.word do_swi</span><br><span class="line">irq_addr:</span><br><span class="line">.word do_irq</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line"><span class="comment">/* 关闭看门狗 */</span></span><br><span class="line"><span class="comment">/*初始化时钟*/</span></span><br><span class="line"><span class="comment">/*初始化sdram,设置栈*/</span></span><br><span class="line"><span class="comment">/*代码重定位,清bss*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 把bit7这一位清零(打开中断总开关) */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br><span class="line"></span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>1.我们在start.s中用汇编代码设置cpsr的I位，开启中断开关；</p><p>2.在main函数中初始化中断源key_eint_init，初始化中断控制器interrupt_init；</p><p>3.然后继续执行main主函数。</p><p>4.当中断产生，触发irq异常，进入0x18异常向量，执行do_irq。</p><p>do_irq实现如下（和do_und, do_swi类似）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">do_irq:</span><br><span class="line"><span class="comment">/* 执行到这里之前: */</span></span><br><span class="line"><span class="comment">/* 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址 */</span></span><br><span class="line"><span class="comment">/* 2. SPSR_irq保存有被中断模式的CPSR */</span></span><br><span class="line"><span class="comment">/* 3. CPSR中的M4-M0被设置为10010, 进入到irq模式 */</span></span><br><span class="line"><span class="comment">/* 4. 跳到0x18的地方执行程序 */</span> </span><br><span class="line"><span class="comment">/* sp_irq未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33d00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">sub lr, lr, #<span class="number">4</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理irq异常 */</span></span><br><span class="line">bl handle_irq_c</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure><p>handle_irq_c函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_eint_irq</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val = EINTPEND;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val1 = GPFDAT;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val2 = GPGDAT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (irq == <span class="number">0</span>) <span class="comment">/* eint0 : s2 控制 D12 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) <span class="comment">/* s2 --&gt; gpf6 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 松开 */</span></span><br><span class="line">GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 按下 */</span></span><br><span class="line">GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">2</span>) <span class="comment">/* eint2 : s3 控制 D11 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) <span class="comment">/* s3 --&gt; gpf5 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 松开 */</span></span><br><span class="line">GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 按下 */</span></span><br><span class="line">GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">5</span>) <span class="comment">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) <span class="comment">/* eint11 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) <span class="comment">/* s4 --&gt; gpf4 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 松开 */</span></span><br><span class="line">GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 按下 */</span></span><br><span class="line">GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">19</span>)) <span class="comment">/* eint19 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 松开 */</span></span><br><span class="line"><span class="comment">/* 熄灭所有LED */</span></span><br><span class="line">GPFDAT |= ((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 按下: 点亮所有LED */</span></span><br><span class="line">GPFDAT &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EINTPEND = val; <span class="comment">/* 清中断 : 源头*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*INTOFFSET中哪一位被设置成1，就表示哪一个 中断源*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 分辨中断源 */</span></span><br><span class="line"><span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line"><span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">&#123;</span><br><span class="line">key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">SRCPND = (<span class="number">1</span>&lt;&lt;bit);<span class="comment">/*清EINT0，EINT2，EINT5*/</span></span><br><span class="line">INTPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</span><a href="#3-4-irq-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</span><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi" class="header-anchor">#</a></h3><p>s3c2440共有2种定时器：</p><pre><code>1.Watchdog看门狗定时器2.PWM脉冲可调制定时器</code></pre><p>下面详细介绍2种定时器的原理，来了解定时器是如何产生定时器中断的。</p><h4><span id="3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</span><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>Watchdog定时器的原理很简单，寄存器很少，框图如下：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/37.png"></p><ol><li>定时器，定时器那肯定是需要用到时钟的，从框图中可以看到Watchdog定时器采用的时钟源是PCLK，从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中也可以体现出来，接的是APB总线。</li><li>然后到达一个8 bit的分频器，可以通过配置WTCON[15:8]来设置分频器的预设值。</li><li>再设置WTCON[4:3]来设置除数因子来进一步分频。<br>所以最终的Watchdog定时器的时钟周期<code>t_watchdog = 1/[ PCLK / (Prescaler value + 1) / Division_factor ]</code></li><li>到达WTCNT：看门狗递减寄存器。WTCNT里的数据就开始在输入时钟频率下递减。WTCNT的值由WTDAT寄存器提供。</li><li>WTDAT：WTDAT寄存器用于指定计数器的初始值，也就是它的超时时间，<strong>系统上电之后硬件自动的将0x8000的初始值载入到WTCNT里，在发生了第一次超时操作时，WTDAT的值才会载入到WTCNT寄存器</strong>。</li></ol><p>当WTCNT的值减到0时，就会触发看门狗定时器中断，进而产生复位。中断框图中可以看到可以设置WTCON[2]来设置是否产生中断信号，可以设置WTCON[0]来设置是否产生复位信号。</p><h5><span id="3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</span><a href="#3-4-1-1-1-wtcon-ji-cun-qi" class="header-anchor">#</a></h5><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/38.png"></p><h5><span id="3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</span><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi" class="header-anchor">#</a></h5><p> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/39.png"></p><h3><span id="3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</span><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li" class="header-anchor">#</a></h3><h4><span id="3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</span><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>在之前的章节中，我们在start.s启动代码中首先做的就是关闭看门狗，把WTCON[5]&#x3D;0，也就是把Watchdog timer给disable。那么Watchdog Timer就不再工作了，这样做是为了防止在启动代码进行硬件初始化的时候出现超时，发出复位信号又去重启硬件，这样就陷入了不断重启过程中。因为s3c2440芯片默认WTCON[5]是1，也就是Watchdog Timer默认是处于使能状态。</p><p>从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中配置了PCLK&#x3D;50M Hz, 那么让WTDAT取默认值0x8000，那么根据公式算出从开机到触发复位重启的时间：</p><p><code>t=WTDAT*( 1/[ PCLK / (Prescaler value + 1) / Division_factor ])</code>。</p><p>根据WTCON寄存器配置Prescaler value&#x3D;255，配置Division_factor&#x3D;128，这样最终定时器分得的频率更低，那么减数器递减的更慢，也就代表从开机到触发复位重启的时间:</p><p><code>T=0x8000 * (1/[50*10^6/(255+1)/128]) = 21474836.48us = 21s</code>。</p><p>之前的start.s中把看门狗已经关闭了，那么我们在跳转到main函数中调用wtd_timer_init函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//使能定时器，开启reset复位</span></span><br><span class="line">WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们查看测试结果：<br>果然初始化wtd_timer_init后，过21s后板子重启了，说明我们watchdog定时器功能已经OK了。</p><p>现在修改代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//使能定时器，开启watchdog定时器中断</span></span><br><span class="line">WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">WTDAT = <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到我们现在定时器的初值被修改成了0x4000, 相对于默认值少了一半，那么触发wtd_timer中断的时间应该减半，也就是约等于10s。</p><h4><span id="3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</span><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>那么需要写一个wtd_timer的中断服务程序，同样需要先在do_irq中去保护现场、调用handle_irq_c、恢复现场。查看INTOFFSET寄存器：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/40.png"></p><p>得知：<br>handle_irq_c代码修改如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        这里还需区分子中断源</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看芯片手册查找“INT_WDT_AC97”如下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/41.png"></p><p>从上图可以看到SRCPND和SUBSRCPND的映射关系。<br>SUBSRCPND寄存器如下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/42.png"></p><p>我们可以读取SUBSRCPND来区分到底是哪一个子中断源产生了中断，当SUBSRCPND中哪一位被置1，表示对应的中断源发生了中断。</p><p>前面做完wtd_timer_init，还要进行中断控制器的初始化，查看INTMSK寄存器如下图：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/43.png"></p><p>查看INTSUBMSK寄存器如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/44.png"></p><p>在interrupt_init中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//不屏蔽INT_WDT_AC97</span></span><br><span class="line">INTSUBMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//不屏蔽INT_AC97</span></span><br></pre></td></tr></table></figure><p>修改handle_irq_c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">9</span>)<span class="comment">//INTOFFSET==9</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SUBSRCPND &amp; <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;watchdog timer interrupt occured.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3><span id="3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</span><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi" class="header-anchor">#</a></h3><p>PWM（Pulse Width Modulation），字面上是脉冲可调制的意思，就是可以调节占空比。</p><p>s3c2440有5个定时器，其中定时器0、1、2和3具有脉宽调制（PWM）功能。定时器4是一个无输出引脚的内部定时器。</p><p>先认识下s3c2440的pwm timer的框架：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/45.jpg"></p><pre><code>1.时钟源为PCLK2.pclk经过8 bit的预分频系数（Prescaler），和4 bit的时钟除数因子（clock divider）,进行分频3.经过MUX选择器选择用哪个定时器（5选1）4.设置TCMPB0和TCNTB0和TCONn寄存器</code></pre><h4><span id="3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</span><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>pwm定时器的逻辑控制单元结构如下：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/46.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> TCMPBn和TCNTBn寄存器中的值分别加载到TCMPn和TCNTn寄存器</span><br><span class="line"><span class="number">2</span> 每来一个clk(时钟)这个TCNTn减去<span class="number">1</span></span><br><span class="line"><span class="number">3</span> 当TCNTn == TCMPn时，可以产生中断，pwm输出引脚反转</span><br><span class="line"><span class="number">4</span> TCNTn继续减<span class="number">1</span>，当TCNTn == <span class="number">0</span>时，又产生一次中断，pwm引脚再次反转</span><br><span class="line"><span class="number">5</span> 重复<span class="number">1</span><span class="number">-4</span>过程</span><br></pre></td></tr></table></figure><p>设置TCNTBn寄存器来设置加载初值，设置后TCNTn中的值就会按照时钟周期递减。<br>设置TCMPBn寄存器来设置占空比，从而控制高低电平持续时间的比例。</p><h4><span id="3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</span><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian" class="header-anchor">#</a></h4><p>要开始一个PWM定时器功能的步骤如下：(假设使用的是timer0)</p><h5><span id="3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</span><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi" class="header-anchor">#</a></h5><p>定义一个pwm_timer_init()函数。</p><ol><li><p>设置时钟：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/47.png"><br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/48.png"></p><p> 分别设置定时器0的预分频器值(prescaler)和时钟分频值(clock divider)，从而控制TCNT0减数器的频率。</p></li></ol><p>根据公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwm Timer clk = PCLK / &#123;(预分频数)prescaler value+<span class="number">1</span>&#125; / &#123;divider value(<span class="number">5.1</span>MUX值)&#125; </span><br></pre></td></tr></table></figure><p>PCLK是50M，设置prescaler value&#x3D;99， divider value&#x3D;16,所以pwm Timer clk&#x3D; 50000000&#x2F;(99+1)&#x2F;16 &#x3D; 31250 Hz</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCFG0 = <span class="number">99</span>; </span><br><span class="line">TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">TCFG1 |= <span class="number">3</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置初值：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置比较缓存寄存器TCMPB0和计数缓存寄存器TCNTB0的初始值*/</span></span><br><span class="line">TCNTB0 = <span class="number">31250</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">/* 2s中断一次 */</span></span><br><span class="line">TCMPB0 = <span class="number">31250</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* 设置占空比*/</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>开启定时器0的手动更新TCNTB0&amp;TCMPB0功能(设置TCON的第1位)：</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/49.png"></p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开始需要手工更新,这样才能将TCNTB0&amp;TCMPB0同步到TCNT0&amp;TCMP0</span></span><br></pre></td></tr></table></figure><ol start="4"><li>开启定时器0的自动加载：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开启自动加载要先清除手动更新</span></span><br><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li>启动定时器0(设置TCON的第0位)；</li></ol><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="6"><li>初始化中断控制器:</li></ol><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/50.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/51.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interrupt_init()&#123;</span><br><span class="line">...</span><br><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* enable timer0 int */</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做完这些初始化工作，就可以产生定时器中断了,同样我们需要在handle_irq_c函数中区分中断源：</p><h5><span id="3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</span><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h5><p>我们可以通过查看TCNTO0寄存器来查看当前TCNT的值。</p><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/52.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>) <span class="comment">//INT_WDT_AC97</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">10</span>) <span class="comment">//timer0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timer0 interrupt occured.\n&quot;</span>);</span><br><span class="line">print_hex(TCNTO0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</span><a href="#3-5-irq-de-you-hua-gai-jin" class="header-anchor">#</a></h2><p>我们对比irq外部中断， irq定时器中断，发现每增加一个中断源，又要去修改中断控制器的初始化interrupt_init()和handle_irq_c(),要在handle_irq_c()中去添加分支去执行不同的中断服务。</p><p>那么我们现在不去改变interrupt文件，在timer.c、key_eint.c中去注册自己的中断服务程序即可，这里我们使用<strong>函数指针数组</strong>，建立一个中断号和中断服务程序的映射关系。这样就可以根据中断号来执行对应的中断服务程序，即在handle_irq_c()中去回调不同类型的中断源注册下来的函数即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义函数指针数组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUM32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*irq_func)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">irq_func irq_array[IRQ_NUM];</span><br></pre></td></tr></table></figure><p>然后实现一个register_irq(…)如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_irq</span> <span class="params">(<span class="type">int</span> irq, irq_func fp)</span></span><br><span class="line">&#123;</span><br><span class="line">irq_array[irq] = fp;</span><br><span class="line">INTMASK &amp;= ~(<span class="number">1</span> &lt;&lt; irq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle_irq_c()修改实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 分辨中断源 */</span></span><br><span class="line"><span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">irq_array[bit](bit); <span class="comment">//根据中断号回调不同的中断处理函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清中断 */</span></span><br><span class="line">SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">INTPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子我们的irq中断就被统一管理了起来，只要在其他各中断模块初始化的时候调用register_irq(…)注册即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-yi-chang-zhong-duan-yin-ru&quot;&gt;1 异常中断引入&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-cpu-mo-shi&quot;&gt;1.1 CPU模式&lt;/</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="中断体系" scheme="http://example.com/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-代码重定位和清bss</title>
    <link href="http://example.com/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/"/>
    <id>http://example.com/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/</id>
    <published>2024-04-15T07:28:42.000Z</published>
    <updated>2024-04-18T06:38:26.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</a><ul><li><a href="#1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</a></li><li><a href="#1-2-lian-jie-jiao-ben">1.2 链接脚本</a><ul><li><a href="#1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</a><ul><li><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</a></li><li><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</a></li></ul></li><li><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</a></li><li><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</a><ul><li><a href="#1-2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li><li><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</a></li></ul></li></ul></li></ul></li><li><a href="#2-qing-chu-bss">2 清除bss</a><ul><li><a href="#2-1-bss-duan-jie-shao">2.1 bss段介绍</a></li><li><a href="#2-2-qing-bss">2.2 清bss</a></li><li><a href="#2-3-qing-bss-you-hua">2.3 清bss优化</a><ul><li><a href="#2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li><li><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</a></li><li><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</a></li></ul></li></ul></li><li><a href="#3-wei-zhi-wu-guan-ma">3 位置无关码</a><ul><li><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</a><ul><li><a href="#3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</a></li><li><a href="#3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</a></li><li><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</span><a href="#1-yin-ru-dai-ma-chong-ding-wei" class="header-anchor">#</a></h1><p>s3c2440的cpu默认是从0地址开始取指令执行，当从nor启动时,0地址对应nor, nor可以像内存一样读，但不能像内存一样写，前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a> 讲过，写入norflash要进行按照spec进行命令表写入。因此我们能够从nor上取指令执行。</p><p>当nand启动的时候，我们nand中的前4K指令会变自动加载到sram中去，这时的0地址对应sram。那么我们的程序如果大于4K,要从nand启动，sram只拷贝了nand中的前4K代码，那么如何解决这个问题呢？</p><p>就需要重定位代码到dram(ddr)中去，dram的容量较大，又可以直接被cpu访问。</p><h2><span id="1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</span><a href="#1-1-cheng-xu-di-zhi-kong-jian" class="header-anchor">#</a></h2><p>我们知道，程序包含：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text）</span><br><span class="line">数据段(.data):存放初始值不为<span class="number">0</span>的全局变量/静态变量</span><br><span class="line">rodata段(.rodata)：<span class="type">const</span>修饰的全局变量或静态变量</span><br><span class="line">bss段(.bss)：存放初始值为<span class="number">0</span>或者未初始化的全局变量/静态变量</span><br><span class="line">commen段(.commen):注释</span><br></pre></td></tr></table></figure><p>下面展开一个实验引入为什么要代码重定位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharB = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharC = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharD = <span class="string">&#x27;D&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_roval = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">uart0_init();</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(g_Char);</span><br><span class="line">g_Char++;         <span class="comment">/* nor启动时, 此代码无效，由于nor启动，nor上不可写 */</span></span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面的代码编译出的裸机程序分别烧录到nand和nor flash，看看结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 烧录到nor flash, 程序一直输出`AAAA`。</span><br><span class="line">2. 烧录到nand flash,程序无任何输出。</span><br></pre></td></tr></table></figure><p>我们发现nor启动时, 对全局变量g_char++无效, nand启动程序无任何输出。我们对程序进行反汇编处理：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/1.png"></p><p>可以看到.text段是从0地址开始的，证明cpu的确从0地址取指令进行译码、执行。<br>当从nor启动时，0地址对应nor；当从nand启动时，0地址对应sram，所以无论从nand还是从nor启动cpu都能取指令执行。</p><p>再进一步分析反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/2.png"></p><p>可以看到.data段的起始地址是0x8474(即g_Char变量的地址为0x8474）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当把程序烧录进nor,  .data段在nor上的某一段区域, 由于nor能像内存一样读，但不能像内存一样直接写，因此对<span class="string">&#x27;g_Char&#x27;</span>修改无效。</span><br><span class="line"><span class="number">2.</span> 当把程序烧录进nand, .data段在nand的某一区域，nand启动时硬件会自动把nand上的前<span class="number">4</span>K数据copy到SRAM,然后cpu从sram取指令执行。但是.data段的起始地址<span class="number">0x8474</span>&gt;<span class="number">0x1000</span>，超过了<span class="number">4</span>K, cpu没法把.data段也copy到SRAM,所以当访问<span class="string">&#x27;g_Char&#x27;</span>时，发生了异常（abt数据访问终止，这个异常后面有在下一节“异常与中断”里面专门讲解)，因此程序卡死。</span><br></pre></td></tr></table></figure><p>再仔细看看反汇编，发现.rodata段和.text段是连续的,但是.rodata段和.data段中间有一段”空洞”。用图形表示更形象，bin文件的内容分布如下所示：</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/3.png"><br>那么我们怎么去掉空洞，让.data段了紧接着.rodata段呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 链接脚本(后面1.2有专门讲)</span><br><span class="line">2. 直接在编译的时候用 &quot;-Tdata 0x800&quot;，这样指定.data段基地址为0x800,这样nand启动时.data就能自动copy到SRAM了。</span><br></pre></td></tr></table></figure><p>我们现在使用<code>-Tdata 0x800</code>编译出裸机程序，对应反汇编如下：</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/4.png"></p><p>这时我们烧录程序到nand，从nand启动，发现能输出<code>ABCDEFG</code>了，这就对了，因为.data段数据从nand自动拷贝到了sram。</p><p>有人说为什么不吧.data段指向到dram呢，这样无论时nor启动还是nand启动不就都能对全局变量写了？<br>当然这个没错，我做了这个尝试，编译时用<code>-Tdata 0x30000000</code>, 发现编译出来的bin文件有800多M,为什么有这么大呢？由于我们指定.data段存放在0x30000000(sdram的基地址)，这时bin文件的内部结构如下所示：</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/5.png"></p><p>这么大的bin文件根本无法烧录。通过上面的例子，现在总结下为什么要代码重定位:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.nand启动，前4K代码被自动copy到sram，当程序大于4K的时候需要重定位代码到sdram。</span><br><span class="line">2.nor启动， 全局变量在nor上，不能像内存一样直接写该全局变量，那么也需要重定位到sdram。</span><br></pre></td></tr></table></figure><h2><span id="1-2-lian-jie-jiao-ben">1.2 链接脚本</span><a href="#1-2-lian-jie-jiao-ben" class="header-anchor">#</a></h2><h3><span id="1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</span><a href="#1-2-1-chong-ding-wei-data-duan" class="header-anchor">#</a></h3><p>我们发现<code>arm-linux-ld -Ttext 0 -Tdata 0x30000000</code>这种方式编译出来的bin文件有800多M,这肯定是不行的。可以通过AT参数指定.data段在编译时的存放位置，我们发现这样指定太不方便了，而且不好确定要放在bin文件的哪个位置。这里就要引入链接脚本，它可以帮我们解决这个不必要的麻烦。</p><h4><span id="1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</span><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/6.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">. = <span class="number">0x00000000</span>; <span class="comment">//表示当前地址为0</span></span><br><span class="line">. = ALIGN(<span class="number">4</span>);  <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">.text  :   </span><br><span class="line">&#123;</span><br><span class="line">  cpu/arm920t/start.o(.text)</span><br><span class="line">  board/lyb2440/boot_init.o (.text)</span><br><span class="line">  *(.text)</span><br><span class="line">&#125;<span class="comment">//表示.text段从0x4开始存放,其中可以手动调整代码段的位置，</span></span><br><span class="line">    <span class="comment">//比如让start.o，boot_init.o中的函数放在最前面,然后存放剩余的代码段</span></span><br><span class="line"></span><br><span class="line">. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">.rodata : &#123; *(.rodata) &#125; <span class="comment">//从该位置开始存放所有的.rodata段</span></span><br><span class="line"></span><br><span class="line">. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">.data : <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//从该位置开始存放所有的.data段 设置运行</span></span><br><span class="line"></span><br><span class="line">__bss_start = .; <span class="comment">//设置.bss段的起始位置</span></span><br><span class="line">.bss : &#123; *(.bss) &#125; <span class="comment">//从该位置开始存放所有的.bss段</span></span><br><span class="line">_end = .;<span class="comment">//设置.bss段的结束位置（也就是整个链接脚本的结束为止）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是从uboot中裁剪过来的链接脚本，注释已经链接脚本的结构讲解的差不多了。这里.data段指定了程序的<strong>运行（链接）地址为sdram的base_addr（0x30000000）</strong>，通过<strong>AT指定加载（在bin文件的存放）地址0x800</strong>。</p><h4><span id="1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</span><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi" class="header-anchor">#</a></h4><p>对于nor启动时，我们可以直接从nor上取指令执行，所以可以只进行数据段的重定位（数据段需要写入），我们编写链接脚本sdram.lds如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .text   <span class="number">0</span>  : &#123; *(.text) &#125;<span class="comment">//所有文件的.text</span></span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125; <span class="comment">//只读数据段</span></span><br><span class="line">    .data <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//放在0x800,但运行时在0x3000000</span></span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;<span class="comment">//所有文件的bss段，所有文件的.COMMON段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将程序烧录进nor flash，程序运行时会将.data拷贝到0x0x30000000也就是sdram中去。只重定位数据段的过程用下图更直观:</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/7.png"></p><p>因此就可以对g_char进行写入了。Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">       arm-linux-gcc -c -o led.o led.c</span><br><span class="line">       arm-linux-gcc -c -o uart.o uart.c</span><br><span class="line">       arm-linux-gcc -c -o init.o init.c</span><br><span class="line">       arm-linux-gcc -c -o main.o main.c</span><br><span class="line">       arm-linux-gcc -c -o start.o start.S</span><br><span class="line">       <span class="comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span></span><br><span class="line">       arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf</span><br><span class="line">       arm-linux-objcopy -O binary -S sdram.elf sdram.bin</span><br><span class="line">       arm-linux-objdump -D sdram.elf &gt; sdram.dis</span><br></pre></td></tr></table></figure><p>修改start.s进行.data段的重定位。我们需要将以0x800为.data段基地址的整个数据段copy到0x30000000处:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">/* 初始化时钟 */</span><br><span class="line">/* 设置栈 */</span><br><span class="line">/*初始化sdram*/</span><br><span class="line">...</span><br><span class="line">/* 重定位data段，把加载地址0x800（bin文件中在nor中）的数据段的内容重定位到sdram的baseaddr */</span><br><span class="line">mov r1, #0x800</span><br><span class="line">ldr r0, [r1]</span><br><span class="line">mov r1, #0x30000000</span><br><span class="line">str r0, [r1]</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>用几行简单的数据加载存储指令即可实现数据段的重定位，这里是用的相对跳转指令bl main，因为还没有重定位整个完整的代码，所以不能用ldr绝对跳转。前面的初始化时钟、sdram我就不写了，参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> , <a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>。</p><p>缺点：<br>这里只是人为的对.data段写死了,那么当我有多个全局变量时，还要计算重定位的次数,而且我们也不知道有多少个全局变量，所以这重定位方式有缺陷。那么我们对这种重定位.data断的方法做一个改进，将链接脚本修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    .text   0  : &#123; *(.text) &#125;</span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125;</span><br><span class="line">    .data 0x30000000 : AT(0x800) </span><br><span class="line">    &#123; </span><br><span class="line">    data_load_addr = LOADADDR(.data);/* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    data_start = . ;/* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    *(.data) </span><br><span class="line">    data_end = . ;/* data段结束地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接脚本用一个变量data_load_addr指定了加载地址(data段在bin文件中的地址，即0x800），用变量data_start指定了运行地址（即为0x30000000），那么用data_end - data_start就是我们数据段的总长度。</p><p>对start.s重定位过程做出如下修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 重定位data段 */</span><br><span class="line">    ldr r1, =data_load_addr  /* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    ldr r2, =data_start  /* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    ldr r3, =data_end      /* data段结束地址 */</span><br><span class="line">cpy:</span><br><span class="line">    ldrb r4, [r1]</span><br><span class="line">    strb r4, [r2] /*r2存入data_load_addr 0x400, 然后，r2,r1依次自加*/</span><br><span class="line">    add r1, r1, #1</span><br><span class="line">    add r2, r2, #1</span><br><span class="line">    cmp r2, r3</span><br><span class="line">    ble cpy</span><br><span class="line"></span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">    b halt</span><br></pre></td></tr></table></figure><p>这里start.s中用到了链接脚本中的label地址。</p><h3><span id="1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</span><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan" class="header-anchor">#</a></h3><p>由于我们的程序可能会大于SRAM或者nor的容量，那么就必须连代码段也一起进行重定位，这种重定位方式更好，在实际应用中也是用的这种方式去做的重定位。</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/8.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将代码段的地址设置为0x3000_0004，然后紧接着放.rodata段，然后再紧接着放.data段。这样我们的bin文件就不再有“空洞”了。再来看重定位代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">...</span><br><span class="line">/* 重定位text, rodata, data段整个程序 */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r2, =_start     /* 第1条指令运行时的地址，也就是.text段的runtime addr，在这里是0x3000_0004*/</span><br><span class="line">ldr r3, =__bss_start    /* bss段的起始地址,也就是整个程序的结束地址  */</span><br><span class="line">cpy:</span><br><span class="line">ldrb r4, [r1]</span><br><span class="line">strb r4, [r2]</span><br><span class="line">add r1, r1, #1</span><br><span class="line">add r2, r2, #1</span><br><span class="line">cmp r2, r3</span><br><span class="line">ble cpy</span><br><span class="line"></span><br><span class="line">bl main  </span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>整个bin文件程序的长度（.text + .rodata + .data）为__bss_start - _start,那么我们是把bin文件从存储介质的0地址copy到程序的运行地址0x3000_0004，这样我们访问.data段时就是访问sdram中重定位后的数据段了。</p><h3><span id="1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</span><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua" class="header-anchor">#</a></h3><h4><span id="1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h4><p>前面重定位时，我们使用的是ldrb命令从的Nor Flash读取1字节数据，再用strb命令将1字节数据写到SDRAM里面。<br>我们开发板的Nor Flash是16位，SDRAM是32位。 假设现在需要复制16byte数据。</p><table><thead><tr><th>不同的读写指令</th><th>cpu读取nor的次数</th><th>cpu写入sdram的次数</th></tr></thead><tbody><tr><td>ldrb、strb</td><td>16</td><td>16</td></tr><tr><td>ldr、str</td><td>8</td><td>4</td></tr></tbody></table><p>可以看出我们更换读写指令后读写次数变少了，提升了cpu的访问效率。修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cpy:</span><br><span class="line">    ldr r4, [r1]</span><br><span class="line">    str r4, [r2]</span><br><span class="line">    add r1, r1, #4 //r1加4</span><br><span class="line">    add r2, r2, #4 //r2加4</span><br><span class="line">    cmp r2, r3 //如果r2 =&lt; r3继续拷贝</span><br><span class="line">    ble cpy</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4><span id="1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</span><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">. = <span class="number">0x30000000</span>;</span><br><span class="line">    __code_start = .;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line">    <span class="comment">//然后从0地址把数据复制到__code_start</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dest &lt; end) &#123;</span><br><span class="line">        *dest++ = *src++; <span class="comment">//从0地址依次copy到__code_start(代码段的运行地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在start.s中设置栈指针sp后，即可执行bl copy2sdram进行重定位代码。如何设置栈指针参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> 有实现，重复代码我就不贴上来了。</p><h1><span id="2-qing-chu-bss">2 清除bss</span><a href="#2-qing-chu-bss" class="header-anchor">#</a></h1><h2><span id="2-1-bss-duan-jie-shao">2.1 bss段介绍</span><a href="#2-1-bss-duan-jie-shao" class="header-anchor">#</a></h2><p>bss段是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">uart0_init();</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">printHex(g_A);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(g_Char);</span><br><span class="line">g_Char++;         <span class="comment">/* nor启动时, 此代码无效 ，重定位到sdram的baseaddr后有效*/</span></span><br><span class="line"><span class="built_in">putchar</span>(g_Char3);</span><br><span class="line">g_Char3++;</span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把程序烧进去，然后打印g_A，但是发现g_A这个值并不是0，而是一个随机值。我们学习linux时知道全局变量g_A, g_B输出肯定是0，裸机输出不是0，为什么呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原因：程序执行汇编过程做完了重定位后把代码copy到了sdram上，然后sdram上紧接着的地址就是.bss的基地址了，这时候bss段的这块内存没有经过任何处理，所以是随机的。</span><br><span class="line">那么我们重定位完代码后需要进行清除sdram上.bss段的数据，因为我们知道bss是未初始化和初始值为<span class="number">0</span>的全局变量。</span><br></pre></td></tr></table></figure><h2><span id="2-2-qing-bss">2.2 清bss</span><a href="#2-2-qing-bss" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x30000000;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .text      :&#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除bss段的代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 清除BSS段 */</span><br><span class="line">ldr r1, =__bss_start</span><br><span class="line">ldr r2, =_end</span><br><span class="line">mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">strb r3, [r1]</span><br><span class="line">add r1, r1, #1</span><br><span class="line">cmp r1, r2</span><br><span class="line">ble clean</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><p>我们把程序再烧进去，然后打印g_A，但是发现g_A的值是0了。本质上就是对重定位后的bss段数据清0。</p><h2><span id="2-3-qing-bss-you-hua">2.3 清bss优化</span><a href="#2-3-qing-bss-you-hua" class="header-anchor">#</a></h2><h3><span id="2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    ldr r1, =__bss_start</span><br><span class="line">    ldr r2, =_end</span><br><span class="line">    mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">    str r3, [r1]</span><br><span class="line">    add r1, r1, #4</span><br><span class="line">    cmp r1, r2</span><br><span class="line">    ble clean</span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure><h3><span id="2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</span><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_bss</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="comment">/* 从lds文件中获得 __bss_start, _end*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> _end, __bss_start;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *start = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;_end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">*start++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：汇编代码获取的是链接脚本中的变量的地址，而C语言代码中获取的是链接脚本中的变量的值</strong>，所以这里的用C语言改进重定位还是清bss都是要加取址符。</p><h3><span id="2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</span><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi" class="header-anchor">#</a></h3><p>前面为了加快重定位和清bss的速度,用到了ldr,str这样以4字节为单位进行读写，但是还可能导致一个问题，假设现在链接脚本没有进行用ALIGN(4)让不同的段以4字节对齐，那么就会出现访问错乱的情况。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">uart0_init();</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">printHex(g_A);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(g_Char);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将链接脚本中.data段和.bss之间的**ALIGN(4)**去掉。那么我们会发现程序执行的时候输出的g_A&#x3D;0，为什么呢，我们明明初始化g_A&#x3D;‘A’呀？</p><p>打开反汇编分析：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/9.png"></p><p>我们的.bss段紧接着.data段后面，可知在对bss段进行清除的时候，由于我们是以4字节为单位操作的，所以我们清除g_A的时候，连带g_Char,g_Char的值也一起清除了。</p><p>所以data段和数据段之间添加ALIGN(4)。修改后就会发现bss段的地址以0x30000248开始了，如下图：</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/10.png"></p><h1><span id="3-wei-zhi-wu-guan-ma">3 位置无关码</span><a href="#3-wei-zhi-wu-guan-ma" class="header-anchor">#</a></h1><h2><span id="3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</span><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</span><a href="#3-1-1-xiang-dui-tiao-zhuan" class="header-anchor">#</a></h3><p>使用b, bl跳转指令。</p><p>对<code>bl sdram_test</code>指令进行分析，查看反汇编, 代码段的链接地址为0x3000,0000。</p><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/11.png"><br><code>这里的bl 3000036c不是跳转到3000036c，这个时候sdram并未初始化,那么这个物理地址是无法访问的.</code></p><p>为了验证，我们做另一个实验，修改连接脚本sdram.lds, 链接地址改为0x3000,0800，编译查看反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/12.png"><br><code>可以看到现在变成了bl 300003ec,但两个的机器码e1a0c00d都是一样的，机器码一样，执行的内容肯定都是一样的。 因此这里并不是跳转到显示的地址，而是跳转到: pc + offset，这个由链接器决定。</code></p><p>假设程序从0x30000000执行，当前指令地址：0x3000005c ,那么就是跳到0x3000036c；如果程序从0运行，当前指令地址:0x5c 跳到：0x000003ec。<br>因此：跳转到某个地址并不是由bl指令所决定，而是由当前pc值和offset偏移量决定。反汇编显示这个值只是为了方便读代码。</p><p>结论： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。</p><h3><span id="3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</span><a href="#3-1-2-jue-dui-tiao-zhuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure><h3><span id="3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</span><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao" class="header-anchor">#</a></h3><p>怎么写位置无关码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用相对跳转命令 b或bl;</span><br><span class="line">重定位之前，不可使用绝对地址(因为你sdram还没初始化，没有重定位代码过去，跳转过去不就死机了)，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；</span><br><span class="line">重定位之后，使用ldr pc = xxx，跳转到/runtime地址；</span><br><span class="line">写位置无关码，其实就是不使用绝对地址</span><br></pre></td></tr></table></figure><p>因此，前面的重定位和清bss例子，程序使用bl命令相对跳转，程序仍在NOR&#x2F;sram执行，要想让main函数在SDRAM执行，需要修改代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-yin-ru-dai-ma-chong-ding-wei&quot;&gt;1 引入代码重定位&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-cheng-xu-di-zhi-kong</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="boot启动" scheme="http://example.com/tags/boot%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-内存控制器</title>
    <link href="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2024-04-11T11:57:48.000Z</published>
    <updated>2024-04-18T12:13:24.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul><li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li><li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul><li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li><li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li></ul></li></ul></li><li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul><li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li><li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li><li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li><li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li><li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li></ul></li><li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul><li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li></ul></li><li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li><li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul><li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li><li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li><li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li><li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li><li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul><li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li><li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li><li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li><li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li><li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li><li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li></ul></li></ul></li><li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul><li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li><li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li><li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li><li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li><li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li><li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul><li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul><li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul><li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li><li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li></ul></li></ul></li><li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul><li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li></ul></li></ul></li></ul></li><li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul><li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul><li><a href="#7-1-1-reset">7.1.1 reset</a></li><li><a href="#7-1-2-du-id">7.1.2 读ID</a></li><li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li><li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li><li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul><li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li><li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li></ul></li></ul></li><li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul><li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li><li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li><li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li></ul></li></ul></li><li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul><li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul><li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li><li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li><li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li></ul></li><li><a href="#8-2-du-shu-ju">8.2 读数据</a></li><li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li><li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure><h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p><h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p><h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p><p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure><p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p><p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p><p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">......</span><br><span class="line"><span class="number">0b110</span>-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure><p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p><h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p><h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p><h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p><h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p><h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p><h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p><h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure><p>为什么要这样设计呢？先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure><p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure><p>用表格更好理解：</p><table><thead><tr><th>ROM&#x2F;bit</th><th>CPU发出地址</th><th>ROM收到地址</th><th>ROM返回数据</th><th>内存控制器挑选出数据给CPU</th></tr></thead><tbody><tr><td>8bit(ROM)</td><td>0b000011</td><td>0b000011</td><td>编号3的存储单元中的8数据</td><td>编号3的存储单元中的8数据</td></tr><tr><td>16bit(ROM)</td><td>0b000011</td><td>0b000001</td><td>编号1的存储单元中的16数据</td><td>根据”A0&#x3D;1”,挑出低8bit数据</td></tr><tr><td>32bit(ROM)</td><td>0b000011</td><td>0b000000</td><td>编号0的存储单元中的32数据</td><td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td></tr></tbody></table><p>对上图的数据再次整理：</p><table><thead><tr><th>ROM&#x2F;bit</th><th>CPU发出地址</th><th>ROM收到地址（内存控制器转发给rom）</th><th>ROM返回数据</th><th>内存控制器组装数据给CPU</th></tr></thead><tbody><tr><td>8bit(ROM)</td><td>0b000100</td><td>0b000100</td><td>地址4的一个1byte数据</td><td>组装地址7、6、5、4数据成4字节数据</td></tr><tr><td></td><td></td><td>0b000101</td><td>地址5的一个1byte数据</td><td></td></tr><tr><td></td><td></td><td>0b000110</td><td>地址6的一个1byte数据</td><td></td></tr><tr><td></td><td></td><td>0b000111</td><td>地址7的一个1byte数据</td><td></td></tr><tr><td>16bit(ROM)</td><td>0b000100</td><td>0b00010</td><td>地址2的一个2byte数据</td><td>组装地址3、2的数据成4字节数据</td></tr><tr><td></td><td></td><td>0b00011</td><td>地址3的一个2byte数据</td><td></td></tr><tr><td>32bit(ROM)</td><td>0b000100</td><td>0b00001</td><td>地址1的一个4byte数据</td><td>直接返回4字节数据</td></tr></tbody></table><p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure><p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure><p>我们知道CPU发出的是32bit地址,那么</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure><h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p><p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p><h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p><table><thead><tr><th>外设类型</th><th>接内存控制器的哪个片选</th><th>基地址</th><th>占用CPU的地址总线</th><th>地址范围(offset + size)</th></tr></thead><tbody><tr><td>nor</td><td>nGCS0</td><td>0x0000,0000</td><td>ADDR0-ADDR20</td><td>0x0000,0000 ~ 0x001f,ffff(2M)</td></tr><tr><td>dm9000网卡</td><td>nGCS4</td><td>0x2000,0000</td><td>ADDR0和ADDR2</td><td>0x2000,0000 ~ 0x2000,0005(5byte)</td></tr><tr><td>sdram</td><td>nGCS6</td><td>0x3000,0000</td><td>ADDR0-ADDR25</td><td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td></tr></tbody></table><p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p><h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p><h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p><h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p><p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p><p>引脚说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure><h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p><p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p><p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p><p>框图翻译成中文形式：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure><h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p><p>答：当然是<strong>拆分地址了，多次传输</strong>。</p><p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p><p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldrr0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure><p>过程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure><p>然后从sdram规格书确定行列地址的数目：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure><p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p><h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure><h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p><p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p><h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p><p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure><h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure><h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure><h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure><h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line"><span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="comment">// write sdram</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read sdram</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">uart0_init();</span><br><span class="line">sdram_init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">led_test();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p><h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p><table><thead><tr><th></th><th>Nor</th><th>NAND</th></tr></thead><tbody><tr><td>XIP(片上执行)</td><td>yes</td><td>no</td></tr><tr><td>性能(擦除)</td><td>非常慢(5s,块太大)</td><td>快(3ms)</td></tr><tr><td>性能(写)</td><td>慢</td><td>快</td></tr><tr><td>性能(读)</td><td>快</td><td>快</td></tr><tr><td>可靠性</td><td>高</td><td>一般（容易出现位反转）</td></tr><tr><td>可擦除次数</td><td>10000 ~ 100000</td><td>100000 ~ 1000000</td></tr><tr><td>接口</td><td>与ram类似，可直接访问任意地址</td><td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td></tr><tr><td>易用性</td><td>容易</td><td>复杂</td></tr><tr><td>主要用途</td><td>常用于保存代码和关键数据</td><td>用于保存数据</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>容量</td><td>小</td><td>大</td></tr><tr><td>常用文件系统类型</td><td>jffs</td><td>yaffs</td></tr></tbody></table><p>nor有以下优缺点相对nand：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure><h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p><h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p><p>引脚信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure><p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p><h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p><h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p><p>时序含义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure><p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure><p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p><p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p><p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p><h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p><h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p><p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p><p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p><h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure><h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">unsigned <span class="built_in">char</span> c;</span><br><span class="line">uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">c = getchar();</span><br><span class="line">putchar(c);</span><br><span class="line"><span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p><p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p><p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p><h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p><p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p><h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p><p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p><h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p><h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure><p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p><table><thead><tr><th>cpu地址</th><th>nor地址</th></tr></thead><tbody><tr><td>A15~A1</td><td>A14~A0</td></tr></tbody></table><p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p><p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p><table><thead><tr><th>Nor Flash的操作</th><th>cpu的操作</th><th>U-BOOT上的操作</th></tr></thead><tbody><tr><td>往地址555H写入AAH(解锁)</td><td>往地址AAAH写入AAH(解锁)</td><td>mw.w aaa aa</td></tr><tr><td>往地址2AAH写入55H(解锁)</td><td>往地址554H写入55H(解锁)</td><td>mw.w 554 55</td></tr><tr><td>往地址555H写入90H(命令)</td><td>往地址AAAH写入90H(命令)</td><td>mw.w aaa 90</td></tr><tr><td>读0地址得到厂家ID(C2H)</td><td>读0地址得到厂家ID(C2H)</td><td>md.w 0 1 (1:表示读一次)</td></tr><tr><td>读1地址得到设备ID(22DAH或225BH)</td><td>读2地址得到设备ID(22DAH或225BH)</td><td>md.w 2 1</td></tr><tr><td>退出读ID状态（给任意地址写F0H）</td><td>退出读ID状态（给任意地址写F0H）</td><td>mw.w 0 f0</td></tr></tbody></table><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p><p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p><h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p><p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p><h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p><p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p><p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p><p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p><p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure><table><thead><tr><th>Nor Flash上操作cfi</th><th>2440上操作cfi</th><th>U-BOOT上操作cfi</th></tr></thead><tbody><tr><td>往55H地址写入98H（进入cfi模式）</td><td>往AAH地址写入98H</td><td>mw.w aa 98</td></tr><tr><td>读地址10H得到0051（’q’）</td><td>读地址20H得到0051</td><td>md.w 20 1</td></tr><tr><td>读地址11H得到0052(‘r’)</td><td>读地址22H得到0052</td><td>md.w 22 1</td></tr><tr><td>读地址12H得到0059(‘y’)</td><td>读地址24H得到0059</td><td>md.w 24 1</td></tr><tr><td>读地址27H得到容量</td><td>读地址4EH得到容量</td><td>md.w 4e 1</td></tr><tr><td>读地址1BH得到VCCmin</td><td>读地址36H得到VCCmin</td><td>md.w 36 1</td></tr></tbody></table><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p><p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p><h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p><ol><li><p>我们在Nor Flash地址0x10000读数据</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure></li><li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p><p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p><table><thead><tr><th>Nor Flash上写操作</th><th>2440上写操作</th><th>U-BOOT上写操作</th></tr></thead><tbody><tr><td>往地址555H写AAH(解锁)</td><td>往地址AAAH写AAH(解锁)</td><td>mw.w aaa aa</td></tr><tr><td>往地址2AAH写55H(解锁)</td><td>往地址554H写55H(解锁)</td><td>mw.w 554 55</td></tr><tr><td>往地址555H写A0H</td><td>往地址AAAH写A0H</td><td>mw.w aaa a0</td></tr><tr><td>往地址PA写PD</td><td>往地址0x100000写1234h</td><td>mw.w 100000 1234</td></tr></tbody></table><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p></li></ol><p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p><p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure><p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p><h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p><table><thead><tr><th>Nor Flash擦操作</th><th>u-boot擦操作</th></tr></thead><tbody><tr><td>往地址555H写AAH</td><td>mw.w   aaa    aa</td></tr><tr><td>往地址2AAH写55H</td><td>mw.w   554    55</td></tr><tr><td>往地址555H写80H</td><td>mw.w    aaa   80</td></tr><tr><td>往地址555H写AAH</td><td>mw.w   aaa    aa</td></tr><tr><td>往地址2AAH写55H</td><td>mw.w   554    55</td></tr><tr><td>往地址PA写30H</td><td>mw.w  100000  30</td></tr></tbody></table><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p><p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p><h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p><p>现在数据就变成我们的0x5678了。</p><p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p><h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p><h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p><h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p><p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p><p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p><h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p><h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line"><span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p><h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p><h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> regions, i;</span><br><span class="line"><span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line"><span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vendor, device;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印容量 */</span></span><br><span class="line">size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line"><span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment"> * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment"> * Erase block region[i] information:</span></span><br><span class="line"><span class="comment"> *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment"> *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line"><span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line"><span class="built_in">printHex</span>(block_addr);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">block_addr += block_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">region_info_base += <span class="number">4</span>;<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"><span class="comment">/* 退出CFI模式 */</span></span><br><span class="line"><span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p><p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p><h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得地址 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">c = *p++;</span><br><span class="line">str[j] = c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">putchar</span>(str[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p><p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">pre = val;</span><br><span class="line">val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">addr = get_uint();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>); <span class="comment">/* erase sector */</span></span><br><span class="line"></span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>); <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p><p>可以看到擦除后这个block就是全0xffff了。</p><h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得地址 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">addr = get_uint();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">gets(str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment"> * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 烧写 */</span></span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>); <span class="comment">/* 解锁 */</span></span><br><span class="line">nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>); <span class="comment">/* program */</span></span><br><span class="line">nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line"><span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">wait_ready(addr);</span><br><span class="line"></span><br><span class="line">i += <span class="number">2</span>;</span><br><span class="line">j += <span class="number">2</span>;</span><br><span class="line">addr += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val = str[i];</span><br><span class="line"><span class="comment">/* 烧写 */</span></span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>); <span class="comment">/* 解锁 */</span></span><br><span class="line">nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>); <span class="comment">/* program */</span></span><br><span class="line">nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line"><span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p><p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p><p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-nei-cun-jie-kou-gai-nian&quot;&gt;1 内存接口概念&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-bu-tong-lei-xing-de-kong-</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="boot启动" scheme="http://example.com/tags/boot%E5%90%AF%E5%8A%A8/"/>
    
    <category term="存储驱动" scheme="http://example.com/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-UART体系</title>
    <link href="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/"/>
    <id>http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/</id>
    <published>2024-04-11T09:11:05.000Z</published>
    <updated>2024-04-18T12:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li><li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li><li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul><li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul><li><a href="#3-1-1-rs232">3.1.1 RS232</a></li></ul></li></ul></li><li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li><li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul><li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul><li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li><li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul><li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li><li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li><li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li></ul></li></ul></li><li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li><li><a href="#5-3-puts">5.3 puts</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure><p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure><h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">举个栗子：</span><br><span class="line">‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure><h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p><pre><code>1.双方约定好波特率（每一位占据的时间）2.规定传输协议</code></pre><p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p><pre><code>1.arm拉低uart总线1bit的时间（起始位）2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位</code></pre><p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p><p>TTL&#x2F;CMOS逻辑电平：</p><pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;1（高电平2-5v）  表示逻辑&#39;1&#39;</code></pre><p>RS-232逻辑电平：</p><pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;(-12V ~ -3V) 表示逻辑&#39;1&#39;</code></pre><p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p><p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p><pre><code>    armpcTxD=data[0:]，    data[0:]=RxDTxD=data[1:]，    data[1:]=RxD...TxD=data[7:]，    data[7:]=RxD</code></pre><h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p><p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p><h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p><p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p><p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p><p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p><h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure><h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p><ol><li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li><li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li></ol><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p><h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p><h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p><h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure><h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。getchar就是从接受寄存器(URXH0)取出值。无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。</code></pre><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p><pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。</code></pre><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">UTXH0 = (unsigned <span class="built_in">char</span>)c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line"><span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s)&#123;</span><br><span class="line">putchar(*s);</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-uart-ying-jian-jie-shao&quot;&gt;1 uart硬件介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-uart-de-can-shu-he-ge-shi</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="外设驱动" scheme="http://example.com/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="通信协议" scheme="http://example.com/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="boot启动" scheme="http://example.com/tags/boot%E5%90%AF%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>s3c2440裸机编程-时钟体系</title>
    <link href="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/"/>
    <id>http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/</id>
    <published>2024-04-11T08:49:52.000Z</published>
    <updated>2024-04-18T12:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-zong-xian-kuang-jia">1 总线框架</a></li><li><a href="#2-shi-zhong-kuang-jia">2 时钟框架</a><ul><li><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</a></li><li><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</a></li></ul></li><li><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</a><ul><li><a href="#3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</a></li><li><a href="#3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</a><ul><li><a href="#3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</a></li><li><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</a></li><li><a href="#3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-zong-xian-kuang-jia">1 总线框架</span><a href="#1-zong-xian-kuang-jia" class="header-anchor">#</a></h1><p>下图是s3c2440的总线框架，其中有AHB(Advanced High performance Bus)高速总线,APB(Advanced Peripheral Bus)外围总线。</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/1.jpg"></p><p>不同总线对应不同的时钟。</p><pre><code>SOC &lt;-&gt; FCLKAHB &lt;-&gt; HCLKAPB &lt;-&gt; PCLK </code></pre><p>其中：</p><p>1.使用AHB总线的有：LCD控制器、usb控制器、中断控制器、内存控制器等…<br>2.使用APB总线的有：i2c、spi、timer、gpio、adc等…具体上图。</p><h1><span id="2-shi-zhong-kuang-jia">2 时钟框架</span><a href="#2-shi-zhong-kuang-jia" class="header-anchor">#</a></h1><p>下图表示s3c2440 Soc的时钟框图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/2.png"></p><p>下面从细节上讲解时钟体系：</p><h2><span id="2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</span><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan" class="header-anchor">#</a></h2><p>s3c2440时钟源有2个，一个是OSC，一个是外部时钟EXTCLK,上面的时钟框图有标记，当然大家也可以查看手册“Figure 7-1. Clock Generator Block Diagram”。</p><p>那么如何选择是OSC还是EXTCLK呢？</p><p>打开原理图，OM3,OM2的引脚接地，那么OM[3,2]&#x3D;00.所以根据手册“Table 7-1. Clock Source Selection at Boot-Up”可知时钟源为OSC晶振。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/3.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/4.png"></p><h2><span id="2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</span><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk" class="header-anchor">#</a></h2><p>先了解下PLL, DIV</p><pre><code>PLL:用锁相环进行倍频DIV:用分频器进行分频</code></pre><p>如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/5.png"></p><p>生成的MPLL(Main PLL)和UPLL(USB PLL)，MPLL直接提供给FCLK，通过HDIVN分频给HCLK，通过PDIVN分频给PCLK，再传给下面的各个设备。<br>osc经过UPLL(USB PLL)得到UCLK。</p><h1><span id="3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</span><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</span><a href="#3-1-s3c2440-shi-zhong-shi-xu" class="header-anchor">#</a></h2><p>下图是2440时钟配置时序：</p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/6.jpg"></p><p>1.上电后，nRESET复位信号拉低，此时cpu还无法取指令工作。<br>2.nRESET复位信号结束后变为高电平，此时cpu开始工作。此时cpu主频FCLK&#x3D;osc。<br>3.此时可以配置PLL，经过lock time后，FCLK倍频成新的时钟。</p><h2><span id="3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</span><a href="#3-2-ru-he-pei-zhi-shi-zhong" class="header-anchor">#</a></h2><p>在参考手册的特性里介绍了S3C2440的工作频率，Fclk最高400MHz，Hclk最高136MHz，Pclk最高68MHz。那么 我们干脆配置FCLK：HCLK:PCLK&#x3D; 400：100：50 (MHz).</p><h3><span id="3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</span><a href="#3-2-1-pei-zhi-lock-time" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/7.png"></p><pre><code>我们取芯片手册上的推荐值。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure><h3><span id="3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</span><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/8.png"></p><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/9.png"></p><p>也可参考配置表取值<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/10.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** MPLL(FCLK) = 2*m*Fin/(p*2^s)</span><br><span class="line">** 不妨取：</span><br><span class="line">** m = MDIV+8 = 92+8=100</span><br><span class="line">** p = PDIV+2 = 1+2 = 3</span><br><span class="line">** s = SDIV = 1</span><br><span class="line">** 则：</span><br><span class="line">** FCLK= 2*100*12/(3*2^1)=400M</span><br><span class="line">*/</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure><p>注意：如果也要配置了UPLL,那么先配置UPLL,要个7个NOP后才能再配置MPLL.</p><p>###3,配置CLKDIVN得到HCLK,PCLK<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/11.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure><p>注意：如果HDIV设置为非0，CPU的总线模式要进行改变，默认情况下FCLK &#x3D; HCLK，CPU工作在fast bus mode快速总线模式下，HDIV设置为非0后， FCLK与HCLK不再相等，要将CPU改为asynchronous bus mod异步总线模式.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15, 0, r1, c1, c0, 0         /* 读取CP15 C1寄存器 */ </span><br><span class="line">orr r1, r1, #0xc0000000           /* 设置CPU总线模式 */ </span><br><span class="line">mcr p15, 0, r1, c1, c0, 0         /* 写回CP15 C1寄存器 */</span><br></pre></td></tr></table></figure><h3><span id="3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</span><a href="#3-2-2-wan-zheng-hui-bian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">ldr r0, =0x53000000</span><br><span class="line">ldr r1, =0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15,0,r0,c1,c0,0</span><br><span class="line">orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,0,r0,c1,c0,0</span><br><span class="line"></span><br><span class="line">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span><br><span class="line"> *  m = MDIV+8 = 92+8=100</span><br><span class="line"> *  p = PDIV+2 = 1+2 = 3</span><br><span class="line"> *  s = SDIV = 1</span><br><span class="line"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span><br><span class="line"> */</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span><br><span class="line"> * 然后CPU工作于新的频率FCLK</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 设置内存: sp 栈 */</span><br><span class="line">/* 分辨是nor/nand启动</span><br><span class="line"> * 写0到0地址, 再读出来</span><br><span class="line"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line"> * 否则就是nor启动</span><br><span class="line"> */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">str r1, [r1] /* 0-&gt;[0] */ </span><br><span class="line">ldr r2, [r1] /* r2=[0] */</span><br><span class="line">cmp r1, r2</span><br><span class="line">ldr sp, =0x40000000+4096</span><br><span class="line">moveq sp, #4096  /* r1=r2， nand启动，修改栈指针=4096（此时sram对应0地址） */</span><br><span class="line">streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-zong-xian-kuang-jia&quot;&gt;1 总线框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-shi-zhong-kuang-jia&quot;&gt;2 时钟框架&lt;/a&gt;&lt;u</summary>
      
    
    
    
    
    <category term="arm裸机" scheme="http://example.com/tags/arm%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="boot启动" scheme="http://example.com/tags/boot%E5%90%AF%E5%8A%A8/"/>
    
    <category term="时钟体系" scheme="http://example.com/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>循环队列FIFO原理图解</title>
    <link href="http://example.com/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/"/>
    <id>http://example.com/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/</id>
    <published>2024-04-11T07:18:51.000Z</published>
    <updated>2024-04-11T08:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</a><ul><li><a href="#1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</a></li><li><a href="#1-2-fifo-chu-shi-hua">1.2 FIFO初始化</a></li><li><a href="#1-3-fifo-xiao-hui">1.3 FIFO销毁</a></li><li><a href="#1-4-ru-dui-lie">1.4 入队列</a></li><li><a href="#1-5-chu-dui-lie">1.5 出队列</a></li><li><a href="#1-6-fifo-pan-kong">1.6 FIFO判空</a></li><li><a href="#1-6-fifo-pan-man">1.6 FIFO判满</a></li><li><a href="#1-7-fifo-rong-liang">1.7 FIFO容量</a></li><li><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</a></li><li><a href="#1-9-fifo-bian-li">1.9 FIFO遍历</a></li><li><a href="#1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</a><ul><li><a href="#1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</a></li><li><a href="#1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</a></li></ul></li></ul></li><li><a href="#2-ce-shi-yong-li">2 测试用例</a></li></ul><!-- tocstop --></div><h1><span id="1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</span><a href="#1-xun-huan-dui-lie-fifo-jie-shao" class="header-anchor">#</a></h1><p>循环队列是把<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/1.png" alt="img"></p><p>入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针。</p><h2><span id="1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</span><a href="#1-1-xun-huan-dui-lie-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_HEAD(name, type)                                          \</span></span><br><span class="line">        <span class="keyword">struct</span> name &#123;                                                  \</span><br><span class="line">                <span class="keyword">struct</span> type *fifo;                                     \</span><br><span class="line">                <span class="built_in">int</span> front, tail, capacity;                             \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">front表示首元素索引</span><br><span class="line">tail表示最后一个元素索引</span><br><span class="line">capacity表示队列的长度</span><br><span class="line">struct type fifo表示该队列中的元素指针，可以指向任意结构体指针</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">struct</span> person_q &#123;                                                        \</span><br><span class="line">    <span class="keyword">struct</span> person* *fifo;                                        \</span><br><span class="line">        <span class="built_in">int</span> front, tail, capacity;                                \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="1-2-fifo-chu-shi-hua">1.2 FIFO初始化</span><a href="#1-2-fifo-chu-shi-hua" class="header-anchor">#</a></h2><p>分配一个连续的空间存储队列元素。用户自定义队列容量。</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/2.png" alt="img"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_INIT(head, _capacity) do &#123;                                  \</span></span><br><span class="line">        (head)-&gt;fifo = malloc(<span class="keyword">sizeof</span>(*(head)-&gt;fifo) * _capacity);        \</span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                               \</span><br><span class="line">        (head)-&gt;capacity = _capacity;                                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="1-3-fifo-xiao-hui">1.3 FIFO销毁</span><a href="#1-3-fifo-xiao-hui" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EXIT(head) do &#123;                                                \</span></span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                                \</span><br><span class="line">        (head)-&gt;capacity = <span class="number">0</span>;                                                \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;fifo)                                                \</span><br><span class="line">                free((head)-&gt;fifo);                                        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="1-4-ru-dui-lie">1.4 入队列</span><a href="#1-4-ru-dui-lie" class="header-anchor">#</a></h2><p>入队列就是尾元素的索引++，也就是tail++，让新元素放进队列的尾部。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PUSH(head, elm) do &#123;                                      \</span></span><br><span class="line">        <span class="keyword">if</span> (FIFO_EMPTY(head))                                          \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">0</span>;                      \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;tail = ((head)-&gt;tail == (head)-&gt;capacity - <span class="number">1</span>)  \</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;tail + <span class="number">1</span>;                        \</span><br><span class="line">        (head)-&gt;fifo[(head)-&gt;tail] = elm;                              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>如果队列是空的，则第一个元素入队列，front和tail索引都指向第一个元素，front &#x3D; tail &#x3D; 0;<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/3.png" alt="img"></p><p>其他情况入队，让tail++<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/4.png" alt="img"></p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/5.png" alt="img"></p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/6.png" alt="img"></p><h2><span id="1-5-chu-dui-lie">1.5 出队列</span><a href="#1-5-chu-dui-lie" class="header-anchor">#</a></h2><p>出队列就是让font对应的元素丢出去，font++。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_POP(head, pelm) do &#123;                                      \</span></span><br><span class="line">        *(pelm) = (head)-&gt;fifo[(head)-&gt;front];                         \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;front == (head)-&gt;tail)                             \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                     \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;front = ((head)-&gt;front == (head)-&gt;capacity - <span class="number">1</span>)\</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;front + <span class="number">1</span>;                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>当front追上tail后，表示队列空了，重新设置起始点，需要将front &#x3D; tail &#x3D; -1 。</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/7.png" alt="img"></p><p>其他情况出队，丢出front元素，让front++</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/8.png" alt="img"></p><h2><span id="1-6-fifo-pan-kong">1.6 FIFO判空</span><a href="#1-6-fifo-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EMPTY(head)    ((head)-&gt;front == -1)</span></span><br></pre></td></tr></table></figure><p>①队列初始化时，队列是空的，会让front为-1<br>②出队列时，font++, 当font追上tail表示空了，则可以重新设置起始点，令front &#x3D; tail &#x3D; -1<br>综合①②所以可以用-1判断</p><h2><span id="1-6-fifo-pan-man">1.6 FIFO判满</span><a href="#1-6-fifo-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FULL(head)     (((head)-&gt;front == ((head)-&gt;tail + 1)%(head)-&gt;capacity))</span></span><br></pre></td></tr></table></figure><p>①当front&#x3D;0时，那么tail到达capacity-1表示FIFO full。</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/9.png" alt="img"></p><p>②否则，tail追上front后(front &#x3D; tail + 1)表示FIFO full。</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/10.png" alt="img"></p><h2><span id="1-7-fifo-rong-liang">1.7 FIFO容量</span><a href="#1-7-fifo-rong-liang" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CAPACITY(head) ((head)-&gt;capacity)</span></span><br></pre></td></tr></table></figure><h2><span id="1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</span><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_SIZE(head)     (FIFO_EMPTY(head) ? \</span></span><br><span class="line">        <span class="number">0</span> : ((((head)-&gt;tail + (head)-&gt;capacity - (head)-&gt;front) % (head)-&gt;capacity) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>用tail - front就表示有效元素个数，不过由于循环FIFO,可能tail&lt;front,这个时候就需要取余运算，如下图:</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/11.png" alt="img"></p><h2><span id="1-9-fifo-bian-li">1.9 FIFO遍历</span><a href="#1-9-fifo-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FOREACH(var, head, idx) \</span></span><br><span class="line">　　<span class="keyword">for</span> (idx = (head)-&gt;front, <span class="keyword">var</span> = (head)-&gt;fifo[idx]; \</span><br><span class="line">　　　　idx &lt; (head)-&gt;front + FIFO_SIZE(head); \</span><br><span class="line">　　　　<span class="keyword">var</span> = (head)-&gt;fifo[++idx % (head)-&gt;capacity])</span><br></pre></td></tr></table></figure><h2><span id="1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</span><a href="#1-10-dui-lie-yuan-su-huo-qu" class="header-anchor">#</a></h2><h3><span id="1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</span><a href="#1-10-1-di-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_FRONT(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;front])</span></span><br></pre></td></tr></table></figure><h3><span id="1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</span><a href="#1-10-2-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_TAIL(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;tail])</span></span><br></pre></td></tr></table></figure><h1><span id="2-ce-shi-yong-li">2 测试用例</span><a href="#2-ce-shi-yong-li" class="header-anchor">#</a></h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;fifo.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="keyword">struct</span> person_q person1_queue;</span><br><span class="line"><span class="keyword">struct</span> person_q person2_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">        FIFO_INIT(&amp;person1_queue, <span class="number">1</span>);</span><br><span class="line">        FIFO_INIT(&amp;person2_queue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person2_queue) != <span class="number">5</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">20</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1001</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person1_queue, person_a);<span class="comment">//把person_a这个结构体指针元素丢进FIFO,</span></span><br><span class="line">        <span class="comment">//后面对它pop出来又能拿到它，所以不用担心地址弄丢导致无法释放.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_FULL(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">30</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1002</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 3 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 4 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person1_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">20</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 5 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">40</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1003</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        FIFO_GET_FRONT(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_FRONT NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_GET_TAIL(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_TAIL NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 6 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 7 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_arr[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                person_arr[i] = malloc(<span class="keyword">sizeof</span>(*person_arr[<span class="number">0</span>]));</span><br><span class="line">                person_arr[i]-&gt;age = i;</span><br><span class="line">                person_arr[i]-&gt;id = <span class="number">1000</span> + i;</span><br><span class="line">                FIFO_PUSH(&amp;person2_queue, person_arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_EMPTY(&amp;person2_queue) &#123;</span><br><span class="line">                FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">                printf( <span class="string">&quot;age:%d, id:%d.\n&quot;</span>, person_a-&gt;age, person_a-&gt;id);</span><br><span class="line">                free(person_a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_EXIT(&amp;person1_queue);</span><br><span class="line">        FIFO_EXIT(&amp;person2_queue);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/12.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-xun-huan-dui-lie-fifo-jie-shao&quot;&gt;1 循环队列FIFO介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-xun-huan-dui-li</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>tailq队列</title>
    <link href="http://example.com/2024/04/11/tailq%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2024/04/11/tailq%E9%98%9F%E5%88%97/</id>
    <published>2024-04-11T06:15:23.000Z</published>
    <updated>2024-04-11T06:31:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-tailq-dui-lie-jie-shao">1 tailq队列介绍</a><ul><li><a href="#1-1-queue-jian-jie">1.1 queue 简介</a></li><li><a href="#1-2-slist">1.2 SLIST</a></li><li><a href="#1-3-stailq">1.3 STAILQ</a></li><li><a href="#1-4-list">1.4 LIST</a></li><li><a href="#1-5-tailq">1.5 TAILQ</a></li><li><a href="#1-6-circleq">1.6 CIRCLEQ</a></li></ul></li><li><a href="#2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</a><ul><li><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</a></li><li><a href="#2-2-dui-lie-tou">2.2 队列头</a></li><li><a href="#2-3-chu-shi-hua">2.3 初始化</a></li><li><a href="#2-4-cha-ru-yuan-su">2.4 插入元素</a><ul><li><a href="#2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</a></li><li><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</a></li></ul></li><li><a href="#2-5-shan-chu-yuan-su">2.5 删除元素</a></li><li><a href="#2-6-di-yi-ge-yuan-su">2.6 第一个元素</a></li><li><a href="#2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</a></li><li><a href="#2-8-xia-yi-ge-yuan-su">2.8 下一个元素</a></li><li><a href="#2-9-qian-yi-ge-yuan-su">2.9 前一个元素</a></li><li><a href="#2-10-pan-kong">2.10 判空</a></li><li><a href="#2-11-pan-man">2.11 判满</a></li><li><a href="#2-12-bian-li">2.12 遍历</a></li><li><a href="#2-13-dao-bian-li">2.13 倒遍历</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-tailq-dui-lie-jie-shao">1 tailq队列介绍</span><a href="#1-tailq-dui-lie-jie-shao" class="header-anchor">#</a></h1><p>TAILQ队列是FreeBSD内核中的一种队列数据结构，主要是把队列头抽象成一个单独的结构体。它实现在Linux queue中。</p><h2><span id="1-1-queue-jian-jie">1.1 queue 简介</span><a href="#1-1-queue-jian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/1.png" alt="img"></p><p>可以include &lt;sys&#x2F;queue.h&gt;后直接使用。queue 分为 SLIST、LIST、STAILQ、TAILQ、CIRCLEQ 。queue 的所有源码都是宏定义，因此完全包含于queue.h当中，无需编译为库文件。</p><p>可以从toolchains或者系统路径&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;queue.h找到实现。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/2.png" alt="img"></p><h2><span id="1-2-slist">1.2 SLIST</span><a href="#1-2-slist" class="header-anchor">#</a></h2><p>SLIST 是Singly-linked List 的缩写，意为单向无尾链表。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/3.png" alt="img"></p><h2><span id="1-3-stailq">1.3 STAILQ</span><a href="#1-3-stailq" class="header-anchor">#</a></h2><p>单向有尾链表，节点n为尾节点。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/4.png" alt="img"></p><h2><span id="1-4-list">1.4 LIST</span><a href="#1-4-list" class="header-anchor">#</a></h2><p>双向无尾链表。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/5.png" alt="img"></p><h2><span id="1-5-tailq">1.5 TAILQ</span><a href="#1-5-tailq" class="header-anchor">#</a></h2><p>双向有尾链表。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/6.png" alt="img"></p><h2><span id="1-6-circleq">1.6 CIRCLEQ</span><a href="#1-6-circleq" class="header-anchor">#</a></h2><p>双向循环链表。</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/7.png" alt="img"></p><h1><span id="2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</span><a href="#2-tailq-shi-xian-yuan-li-tu-jie" class="header-anchor">#</a></h1><p>双向有尾链表,也就是有一个表头和表尾，表头指向节点1和尾节点。</p><h2><span id="2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</span><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                                   \</span></span><br><span class="line"><span class="keyword">struct</span> &#123;                                                                    \</span><br><span class="line">    <span class="keyword">struct</span> type *tqe_next;      <span class="comment">/* next element */</span>                          \</span><br><span class="line">    <span class="keyword">struct</span> type **tqe_prev;     <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tqe_next是指向下一个元素的指针，tqe_prev是指向前一个元素的tqe_next地址，对它解引用后</span></span><br><span class="line"><span class="comment">（*tqe_priv）指向当前元素的地址。*/</span></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">struct</span> item&#123;</span><br><span class="line">　　<span class="built_in">int</span> val;</span><br><span class="line">　　TAILQ_ENTRY(item) entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/8.png" alt="img"></p><h2><span id="2-2-dui-lie-tou">2.2 队列头</span><a href="#2-2-dui-lie-tou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    TAILQ_HEAD(name, type)                        \</span></span><br><span class="line"><span class="keyword">struct</span> name &#123;                                \</span><br><span class="line">    <span class="keyword">struct</span> type *tqh_first;    <span class="comment">/* first element */</span>            \</span><br><span class="line">    <span class="keyword">struct</span> type **tqh_last;    <span class="comment">/* addr of last next element */</span>        \</span><br><span class="line">&#125;</span><br><span class="line">STAILQ_HEAD(my_tailq,  tailq_entry) queue_head;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/9.png" alt="img"></p><p>先看TAILQ_HEAD:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqh_first为队列第一个元素的地址；</span><br><span class="line">tqh_last为最后一个元素tqe_next的地址；</span><br><span class="line">tqh_last指向的指针为<span class="number">0</span>；</span><br></pre></td></tr></table></figure><p>再看TAILQ_ENTRY:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqe_next为队列下一个元素的地址；</span><br><span class="line">tqe_prev为队列上一个元素tqe_next的地址；</span><br><span class="line">tqe_prev指向的指针为当前元素的地址；</span><br></pre></td></tr></table></figure><h2><span id="2-3-chu-shi-hua">2.3 初始化</span><a href="#2-3-chu-shi-hua" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/10.png" alt="img"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head) do &#123;                                               \</span></span><br><span class="line">    (head)-&gt;tqh_first = NULL;                                               \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2><span id="2-4-cha-ru-yuan-su">2.4 插入元素</span><a href="#2-4-cha-ru-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;                  \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = NULL;                                 \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;                     \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                                    \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3><span id="2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</span><a href="#2-4-1-cha-ru-1-ge-yuan-su" class="header-anchor">#</a></h3><ol><li><p>将要插入的node加入到尾部：</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/11.png" alt="img"></p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next = NULL;                         </span><br><span class="line">(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;<span class="comment">//将要插入的节点prev指向最后一个node </span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>更新头节点:</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/12.png" alt="img"></p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);          </span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure><h3><span id="2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</span><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su" class="header-anchor">#</a></h3><p>同理多个元素时尾插。</p><ol><li><p>将要插入的node加入到尾部:</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/13.png" alt="img"></p></li><li><p>更新头节点:</p></li></ol><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/14.png" alt="img"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);           <span class="comment">//尾节点指向新的尾巴</span></span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; <span class="comment">//head的last指向新的尾巴</span></span><br></pre></td></tr></table></figure><h2><span id="2-5-shan-chu-yuan-su">2.5 删除元素</span><a href="#2-5-shan-chu-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;                       \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                          \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;      \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                           \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/15.png"></p><p>我们现在要把val&#x3D;3的elm删除：<br>elm中的tqe_next不为空，表示elm不是尾节点。那么</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure><p>这2句执行完后:</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/16.png" alt="img"></p><p>然后free掉该elm,</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/17.png" alt="img"></p><p>同理再删除val&#x3D;2的elm：</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/18.png" alt="img"></p><p>然后free掉该elm，</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/19.png" alt="img"></p><p>最后如果要把val&#x3D;4的elm删除：</p><p>elm中的tqe_next为空，表示elm是尾节点。那么，</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;               <span class="comment">//让head的last指向新的尾巴        </span></span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;    <span class="comment">//让elm的前一个node的next指向该elm的后一个node</span></span><br></pre></td></tr></table></figure><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/20.png" alt="img"></p><h2><span id="2-6-di-yi-ge-yuan-su">2.6 第一个元素</span><a href="#2-6-di-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure><h2><span id="2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</span><a href="#2-7-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_LAST(head, headname) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span><br></pre></td></tr></table></figure><p>这个实现看起来有点绕，我们先做一个实验:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> _QUEUE_ITEM &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    TAILQ_ENTRY(QUEUE_ITEM) entries;</span><br><span class="line">&#125;QUEUE_ITEM;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(TAIL_QUEUE, QUEUE_ITEM) queue_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    QUEUE_ITEM *item[<span class="number">5</span>];</span><br><span class="line">    TAILQ_INIT(&amp;queue_head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        item[i] = (<span class="keyword">struct</span> QUEUE_ITEM*)malloc(<span class="keyword">sizeof</span>(QUEUE_ITEM));</span><br><span class="line">        item[i]-&gt;<span class="keyword">value</span> = i;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;queue_head, item[i], entries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;item[%d]: item:%#x, next:%#x,&amp;next:%#x, prev:%#x, *prev:%#x\n&quot;</span>,</span><br><span class="line">　　　　　　　　i, item[i], item[i]-&gt;entries.tqe_next, &amp;(item[i]-&gt;entries.tqe_next), item[i]-&gt;entries.tqe_prev, *(item[i]-&gt;entries.tqe_prev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;queue_head:%#x, first:%#x, last:%#x\n&quot;</span>, &amp;queue_head, queue_head.tqh_first, queue_head.tqh_last);</span><br><span class="line">    printf(<span class="string">&quot;last item:%p\n&quot;</span>, TAILQ_LAST(&amp;queue_head, TAIL_QUEUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/21.png" alt="img"></p><p>可以用图形来描述:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/22.png" alt="img"></p><p><code>TAILQ_LAST(&amp;queue_head, TAIL_QUEUE);</code>这句话展开:<br><code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code></p><p><code>((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))</code>这句话,我们把地址0x601060代入进去得0x602098，即为：</p><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/23.png" alt="img"></p><p>然后<code>(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last)</code>得到0x602078,<br>认真的同学此时已经发现，此时对应倒数第二元素的next地址，</p><p>最后取<code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code>得到0x602090,这就是最后一个元素的地址。</p><p><strong>总结：这里核心其实就是把最后一个元素的entries成员当成head指针来使用</strong>。因为本质上最后一个节点的TAILQ_ENTRY域和TAILQ_HEAD是同样的结构。</p><h2><span id="2-8-xia-yi-ge-yuan-su">2.8 下一个元素</span><a href="#2-8-xia-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_NEXT(elm, field)                ((elm)-&gt;field.tqe_next)</span></span><br></pre></td></tr></table></figure><h2><span id="2-9-qian-yi-ge-yuan-su">2.9 前一个元素</span><a href="#2-9-qian-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_PREV(elm, headname, field) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span><br></pre></td></tr></table></figure><p>这里和TAILQ_LAST原理一样，将0x602090代入进去得:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/24.png" alt="img"><br>然后对*(0x602058)得0x602070,即得到了前一个node的地址。</p><h2><span id="2-10-pan-kong">2.10 判空</span><a href="#2-10-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_EMPTY(head)                ((head)-&gt;tqh_first == NULL)</span></span><br></pre></td></tr></table></figure><h2><span id="2-11-pan-man">2.11 判满</span><a href="#2-11-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure><h2><span id="2-12-bian-li">2.12 遍历</span><a href="#2-12-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH(var, head, field)                                        \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = ((head)-&gt;tqh_first);                                \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = ((<span class="keyword">var</span>)-&gt;field.tqe_next))</span><br></pre></td></tr></table></figure><h2><span id="2-13-dao-bian-li">2.13 倒遍历</span><a href="#2-13-dao-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH_REVERSE(var, head, headname, field)                \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last));        \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((<span class="keyword">var</span>)-&gt;field.tqe_prev))-&gt;tqh_last)))</span><br></pre></td></tr></table></figure><p>当看懂之前的<strong>最后一个元素</strong>原理时，倒遍历的实现是不是超级简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-tailq-dui-lie-jie-shao&quot;&gt;1 tailq队列介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-queue-jian-jie&quot;&gt;1.1 queu</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>union和bit_field巧妙进行寄存器位操作</title>
    <link href="http://example.com/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/</id>
    <published>2024-04-04T10:15:23.000Z</published>
    <updated>2024-04-04T10:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</a></li><li><a href="#2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</a><ul><li><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</a></li><li><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</a></li><li><a href="#2-3-du-qu-ji-cun-qi">2.3 读取寄存器</a></li><li><a href="#2-4-xie-ji-cun-qi">2.4 写寄存器</a></li><li><a href="#2-5-wei-du-qu">2.5 位读取</a></li><li><a href="#2-6-wei-xie-ru">2.6 位写入</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</span><a href="#1-union-jie-gou-qu-fen-da-xiao-duan" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_bits(stc, field)(&#123;stc.raw = 0x12345678; stc.bits.field;&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> raw;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_a : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_b : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_c : <span class="number">5</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_d : <span class="number">3</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_e : <span class="number">1</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">num</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#x, %#x, %#x, %#x, %#x\n&quot;</span>,</span><br><span class="line">        read_bits(num, bit_a),</span><br><span class="line">        read_bits(num, bit_b),</span><br><span class="line">        read_bits(num, bit_c),</span><br><span class="line">        read_bits(num, bit_d),</span><br><span class="line">        read_bits(num, bit_e));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1-1.png" alt="img"></p><p>这样的结果，原理如下图:</p><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="img"><br>那么从这里可以看出，低地址对应低字节， 因此我们的运行机器是Little Endian。</p><p>那么bit_a&#x3D;0x78; bit_b&#x3D;0x56; bit_c等于0x34取低5位，也就是0x14; bit_d 等于0x34取高3位，也就是0x1； bit_e等于0x12取最低位，也就是0。</p><p>由于这里的num是union结构，因此对.raw进行操作，那么也就等于对.bits也进行了操作，那么返回bit field是不是和寄存器的位操作很类似。下面详细介绍如何用union和bit field巧妙进行寄存器位操作。</p><h1><span id="2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</span><a href="#2-ji-cun-qi-de-wei-cao-zuo" class="header-anchor">#</a></h1><p>举个例子，这是mipi-rx DPHY的寄存器的部分截取：</p><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/2.png" alt="img"></p><p>那么我们可以对该module进行结构定义如下：(当然如果觉得手动去定义麻烦，网上有专门的python工具可以对excel到寄存器定义的转换)<br><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/3.png" alt="img"></p><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/4.png" alt="img"></p><p>这里对该module的每个寄存器都定义成union。</p><h2><span id="2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</span><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃define <span class="title function_">offsetof</span><span class="params">(<span class="type">struct_t</span>,member)</span> <span class="params">( (<span class="type">int</span>)&amp;((<span class="type">struct_t</span> *)<span class="number">0</span>)-&gt;member )</span></span><br></pre></td></tr></table></figure><p>(struct_t <em>)0)，可以看到这里*<em>把一个0地址转换成一个指针，它表示一个结构体指针变量，并且是值&#x3D;0的指针</em></em>, 那么访问它的成员，成员的地址自然就会往后递增，因此该成员的地址那么就等于该成员的偏移量。</p><p>eg:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么offsetof(struct student, id)就为100 + 4&#x3D;104，同理.name的offsetof为0，.age的offsetof为100，.sex的offsetof为108。</p><h2><span id="2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</span><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti" class="header-anchor">#</a></h2><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/5.png" alt="img"></p><p>该函数实现位于include&#x2F;linux&#x2F;kernel.h， 源码如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span>(<span class="params"> ((type *</span>)0)-&gt;member ) *__mptr</span> = (ptr);    \</span><br><span class="line">    (type *)( (<span class="built_in">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure><ol><li>定义一个结构体成员指针mptr指向该成员，</li><li>用该成员指针减去该成员在结构体中的偏移量，不就是该结构体的起始地址</li></ol><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/6.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;.name=<span class="string">&quot;robin&quot;</span>, .age=<span class="number">18</span>, .id=<span class="number">123456</span>, .sex=<span class="string">&#x27;M&#x27;</span>&#125;, *pstu;</span><br><span class="line">pstu = container_of(&amp;stu.sex, <span class="keyword">struct</span> student, sex);</span><br></pre></td></tr></table></figure><h2><span id="2-3-du-qu-ji-cun-qi">2.3 读取寄存器</span><a href="#2-3-du-qu-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_read(addr) readl((void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPHY_BA_ADDR (0x0300b000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFST(_BLK_T, _REG)       ((uint64_t)&amp;(((struct _BLK_T *)0)-&gt;_REG))//this is same with offsetof</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_REG(_BA, _BLK_T, _REG) \</span></span><br><span class="line">(_reg_read(_BA+_OFST(_BLK_T, _REG)))</span><br></pre></td></tr></table></figure><p>用如下函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RD_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08);</span><br></pre></td></tr></table></figure><p>这样就表示对该module的REG_08的寄存器进行了read。</p><h2><span id="2-4-xie-ji-cun-qi">2.4 写寄存器</span><a href="#2-4-xie-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_write(addr, data) writel(data, (void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR_REG(_BA, _BLK_T, _REG, _V) \</span></span><br><span class="line">                (_reg_write((_BA+_OFST(_BLK_T, _REG)), _V))</span><br></pre></td></tr></table></figure><p>用如下函数:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WR_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, <span class="number">0x3333ffff</span>);</span><br></pre></td></tr></table></figure><p>这样就表示对该module的REG_08的寄存器进行了write, write的数据为0x3333ffff。</p><h2><span id="2-5-wei-du-qu">2.5 位读取</span><a href="#2-5-wei-du-qu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RD_BITS(_BA, _BLK_T, _REG, _FLD) \</span></span><br><span class="line">        (&#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD;\</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><p>用如下函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RD_BITS</span>(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1);</span><br></pre></td></tr></table></figure><p>这里首先是定义了一个module的REG_08的寄存器结构，typeof表示对该成员取数据结构类型，然后把该寄存器里的值读出来，最后返回bit[31:16]。</p><h2><span id="2-6-wei-xie-ru">2.6 位写入</span><a href="#2-6-wei-xie-ru" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WR_BITS(_BA, _BLK_T, _REG, _FLD, _V) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD = _V;\</span><br><span class="line">                _reg_write((_BA+_OFST(_BLK_T, _REG)), _r.raw);\</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">WR_BITS(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1, <span class="number">0x1111</span>);</span><br></pre></td></tr></table></figure><p>这里首先是定义了一个module的REG_08的寄存器结构，然后把该寄存器里的值读出来, 再把该寄存器的bit[31:16]写入0x1111。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-union-jie-gou-qu-fen-da-xiao-duan&quot;&gt;1 union结构区分大小端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-ji-cun-qi-d</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>卷帘快门RollingShutter与全局快门GlobalShutter</title>
    <link href="http://example.com/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/"/>
    <id>http://example.com/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/</id>
    <published>2024-04-03T07:56:37.000Z</published>
    <updated>2024-04-03T08:04:58.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-global-shutter">1 Global Shutter</a></li><li><a href="#2-rolling-shutter">2 Rolling Shutter</a></li></ul><!-- tocstop --></div><h1><span id="1-global-shutter">1 Global Shutter</span><a href="#1-global-shutter" class="header-anchor">#</a></h1><p>通过整幅场景在同一时间曝光实现的。Sensor所有像素点同时收集光线，同时曝光。即在曝光开始的时候，Sensor开始收集光线；在曝光结束的时候，光线收集电路被切断。CCD就是Global shutter工作方式。所有像元同时曝光</p><h1><span id="2-rolling-shutter">2 Rolling Shutter</span><a href="#2-rolling-shutter" class="header-anchor">#</a></h1><p>与Global shutter不同，它是通过Sensor逐行曝光的方式实现的。在曝光开始的时候，Sensor逐行扫描逐行进行曝光，直至所有像素点都被曝光。</p><p>对比优缺点:</p><p>Global shutter： 曝光时间更短，但会增加读出噪声；</p><p>Rolling shutter：可以达到更高的帧速，噪声小，但是运动场景会产生果冻效应。</p><p>卷帘快门与全局快门大致原理如下图：</p><p align="left">&nbsp;<img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/1.gif" alt width="292" height="165" loading="lazy"></p><p>卷帘快门：</p><p><img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/2.gif" alt width="409" height="187" loading="lazy"></p><p><strong>适用性：</strong></p><table><thead><tr><th><strong>Global shutter</strong></th><th><strong>rolling shutter</strong></th></tr></thead><tbody><tr><td><strong>曝光时间短的应用（如</strong><strong>&lt;500μs****）</strong></td><td><strong>曝光时间长（如大于<strong><strong>500μs</strong></strong>）的应用可以有更低的噪声和帧速</strong></td></tr><tr><td><strong>快速移动物体拍适合</strong></td><td><strong>静止的物体适合</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-global-shutter&quot;&gt;1 Global Shutter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-rolling-shutter&quot;&gt;2 Rolling S</summary>
      
    
    
    
    
    <category term="mipi图像处理" scheme="http://example.com/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>mipi-csi软件篇</title>
    <link href="http://example.com/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/"/>
    <id>http://example.com/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/</id>
    <published>2024-04-02T09:20:23.000Z</published>
    <updated>2024-04-03T06:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</a></li><li><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</a><ul><li><a href="#2-1-chuan-shu-mo-shi">2.1 传输模式</a></li><li><a href="#2-2-lane-states">2.2 lane states</a></li><li><a href="#2-3-lane-levels">2.3 Lane Levels</a></li><li><a href="#2-4-cao-zuo-mo-shi">2.4 操作模式</a></li><li><a href="#2-5-shi-zhong-mo-shi">2.5 时钟模式</a></li><li><a href="#2-6-shi-xu-yao-qiu">2.6 时序要求</a></li><li><a href="#2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</a></li><li><a href="#2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</a></li></ul></li><li><a href="#3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</a><ul><li><a href="#3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</a></li><li><a href="#3-2-bao-lei-xing">3.2 包类型</a><ul><li><a href="#3-2-1-duan-bao-jie-gou">3.2.1 短包结构</a></li><li><a href="#3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</a></li><li><a href="#3-2-3-chang-bao-jie-gou">3.2.3 长包结构</a></li><li><a href="#3-2-4-h-blanking-v-blanking">3.2.4 H-blanking &amp; V-blanking</a></li><li><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</a><ul><li><a href="#3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</a></li><li><a href="#3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</a></li></ul></li></ul></li></ul></li><li><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</a><ul><li><a href="#4-1-rgb-ge-shi">4.1 RGB格式</a></li><li><a href="#4-2-yuv-ge-shi">4.2 YUV格式</a><ul><li><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</a><ul><li><a href="#4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</a></li><li><a href="#4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</a></li><li><a href="#4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</a></li></ul></li><li><a href="#4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</a><ul><li><a href="#4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</a><ul><li><a href="#4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</a></li><li><a href="#4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</a></li><li><a href="#4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</a></li><li><a href="#4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</a></li></ul></li><li><a href="#4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</a><ul><li><a href="#4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</a></li><li><a href="#4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</a></li></ul></li></ul></li></ul></li><li><a href="#4-3-raw-ge-shi">4.3 RAW 格式</a><ul><li><a href="#4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</a></li></ul></li></ul></li><li><a href="#5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</a></li><li><a href="#6-se-cai-shen-du">6 色彩深度</a></li><li><a href="#7-tu-xiang-jie-xi-du-fen-bian-lu">7 图像解析度&#x2F;分辨率</a></li></ul><!-- tocstop --></div><h1><span id="1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</span><a href="#1-mipi-csi2-de-fa-song-he-jie-shou" class="header-anchor">#</a></h1><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/1.png" alt="img"></p><p>上图反映了sensor 和 soc 的数据关系，soc 通过 CCI (Camera Control Interface) 控制 sensor 寄存器，配置正确，sensor 将会通过 mipi 接口输出图像数据。</p><p>控制信息是 soc 通过 CCI 发送到 sensor，CCI 接口一般的就是 I2C 接口,最大支持400KHz。</p><p>data信息是CSI DPHY发送者发送到CSI DPHY接收者，由sensor端发送到soc的mipi-rx。</p><h1><span id="2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</span><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi" class="header-anchor">#</a></h1><p>D-PHY 是 MIPI 聯盟發布的高速物理層標準，規定了接口層的物理特性和傳輸協議。 DPHY 採用了 200mV 源同步的低压差分信號技術，每個 Lane 的數據綠率範圍支持到2500Mbps。 D-PHY 可以工作在低功耗 (Low Power, LP) 和高速 (High Speed, HS) 兩種模式下。</p><h2><span id="2-1-chuan-shu-mo-shi">2.1 传输模式</span><a href="#2-1-chuan-shu-mo-shi" class="header-anchor">#</a></h2><p><strong>LP（Low-Power） 模式</strong>：用于传输控制信号，最高速率 10 MHz</p><p><strong>HS（High-Speed）模</strong>式：用于高速传输数据，速率范围 [80 Mbps， 2.5Gbps] per Lane</p><p>传输的最小单元为 1 个字节，采用小端的方式，也就是 LSB first，MSB last。</p><p><strong>相关缩写名</strong>词：</p><p>HS-RX：高速接收器<br>HS-TX：高速发送器<br>LP-RX：低功耗接收器<br>LP-TX：低功耗发送器<br>LPS:  Low Power State, 封包之間的spacing間距。<br>ST:    Start of Transmission (SoT), 封包的起始訊號, 一般為低速轉換為高速的暫態訊號。<br>ET:    End of Transmission (EoT), 封包的結束訊號, 一般為高速轉換為低速的暫態訊號。<br>PH:   Packet Header, 32 bit表示, 為封包的標頭。<br>PF:    Packet Footer, 16 bit表示, 為封包的結尾。</p><h2><span id="2-2-lane-states">2.2 lane states</span><a href="#2-2-lane-states" class="header-anchor">#</a></h2><p>*  LP mode 有 4 种状态： LP00、LP01（<strong>0</strong>）、LP10（<strong>1</strong>）、LP11 （Dp、Dn）</p><p>* HS mode 有 2 种状态： HS-0、HS-1</p><p>HS 发送器发送的数据 LP 接收器看到的都是 LP00。</p><h2><span id="2-3-lane-levels">2.3 Lane Levels</span><a href="#2-3-lane-levels" class="header-anchor">#</a></h2><p>* LP： 0 ~ 1.2V</p><p>* HS： 100 ~ 300mV，HS common level &#x3D; 200mV，swing &#x3D; 200 mv</p><h2><span id="2-4-cao-zuo-mo-shi">2.4 操作模式</span><a href="#2-4-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p> • 数据Lane的3种操作模式 </p><ul><li><p>Escape mode,</p></li><li><p>High-Speed(Burst) mode</p></li><li><p>Control mode</p><p><strong>①Escape mode request</strong><br> LP-11→LP-10→LP-00→LP-01→LP-00<br> exit:LP-10 -&gt; LP-11</p></li></ul><p>当进入 Escape mode 需要发送 8-bit entry command 表明请求的动作，比如要进行低速数据传输则需要发送 cmd： 0x87，进入超低功耗模式则发送 cmd： 0x78。</p><p>  <strong>②High-Speed mode request :</strong><br>    LP-11→LP-01→LP-00-&gt;SOT(0001_1101)<br>    exit: EOT -&gt; LP-11</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/2.png" alt="img"></p><p><strong>③Turnaround request</strong><br>    LP-11→LP-10→LP-00→LP-10→LP-00</p><p>这是开启 BTA 的时序，一般用于从 slave 返回数据如 ACK： 0x84.<br>    exit：LP00→LP10→LP11</p><p> 最常用的就是“低功耗进入高速模式”如下图：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/3.png" alt="img"></p><p>我们的D0-D4都是一个差分信号，它从lowpower state进入到HS后，从hi speed mode 中sync出我们的data。</p><p>sensor控制的信号由绿色框圈出来，主要是以下三个讯号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HS-Prepare：表示从low power mode进入到hi speed mode需要prepare一段时间</span><br><span class="line">Hs-zero: 表示从low power mode进入到hi speed mode需要keep LP-00状态一段时间</span><br><span class="line">Hs-trail:表示送完1 st data后需要keep一段时间后才允许进入low power mode，进行下一轮数据传输。</span><br></pre></td></tr></table></figure><p>soc端的控制的信号由黄色框圈出来:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hs-settle:表示soc要等一段时间才去开始去parse “sync code”, 当抓到sync code后表示sensor已经进入了hi speed mode， 这个时候就可以sync data了。</span><br></pre></td></tr></table></figure><p>注意：</p><p>1.每次EOT(end of trans)结束讯号后，都会进入low power mode，而不是sensor 工作后就一直处于hi speed mode。也就是每传一个package，都会走一遍上述的过程。</p><p>2.hs-settle为mclk&#x2F;8 *n(这个n表示配置几个clk，对应code的话配置这个mipi_dev_attr_s-&gt;dphy)</p><p>当hs-settle的时间太长会压到data中的“sync code”,那么就会出现sync code parse不到,出现ecc err. 又或者从data中parse到一个假的“sync code”，那么最后就会出现数据不太对，出现ecc err.</p><p>Ecc还有一种出现可能就是lane mapping 出错，当我们传输数据出现ecc err, 有可能就是传输short pack时，4 byte的short pack拼接的不对（详见CSI的数据包结构），导致出现ecc error.</p><p>3.如果hs-trail持续的太短（拉高的太快），有可能会压到最后面的data，所以会出现crc&#x2F;wc(word count ) err.另外，如果hs -settle太大，也有可能hs-trail也会是错误的数据，所以出现wc, crc err，因此不一定是hs-trail的问题，得先确保前面的ecc&#x2F;decode无误后再来调整hs-trail。</p><p>一般排查流程如下：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/4.png" alt="img"></p><h2><span id="2-5-shi-zhong-mo-shi">2.5 时钟模式</span><a href="#2-5-shi-zhong-mo-shi" class="header-anchor">#</a></h2><ul><li>连续时钟模式：数据包传输间隔，clk lane 保持在高速模式；</li><li>非连续时钟模式：数据包传输间隔，clk lane 进入 LP-11 状态，退出hi speed mode；</li></ul><h2><span id="2-6-shi-xu-yao-qiu">2.6 时序要求</span><a href="#2-6-shi-xu-yao-qiu" class="header-anchor">#</a></h2><p>在调试 DSI 或者 CSI 的时候， HS mode 下的几个时序非常重要：T_LPX，T_HS-SETTLE ≈ T_HS-PREPARE + T_HS-ZERO，T_HS-TRAIL，一般遵循的原则为：Host 端的 T_HS-SETTLE &gt; Slave 端的 T_HS-SETTLE。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/5.png" alt="img"></p><h2><span id="2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</span><a href="#2-7-start-of-transmission-sot-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/6.png" alt="img"></p><p>当要进行数据传输的时候，data lane 将会通过信号（SoT）退出停止状态，进入高速模式。过程如下：</p><table><thead><tr><th><strong>TX Side</strong></th><th><strong>RX Side</strong></th></tr></thead><tbody><tr><td>退出停止状态 ( LP-11 )</td><td>检测停止状态</td></tr><tr><td>进入 HS-Rqst 状态 ( LP-01 )，并处于该状态的时间间隔为 TLPX</td><td>检测到 lane 从 LP-11 转变为 LP-01</td></tr><tr><td>进入 Bridge 状态 ( LP-00 )，并处于该状态的时间间隔为 THS-PREPARE</td><td>检测到 lane 从 LP-01 转变为 LP-00，间隔 TD-TERM-EN 时间之后将使能传输</td></tr><tr><td>同时退出低功耗模式，进入高速模式</td><td></td></tr><tr><td>处于 HS-0 状态，时长为 THS-ZERO</td><td>使能 HS-RX 并等待 THS-SETTLE，以忽略转换状态</td></tr><tr><td></td><td>开始从数据流中等待同步序列</td></tr><tr><td>时钟上升边缘插入 HS 同步序列 ‘00011101’</td><td></td></tr><tr><td></td><td>识别到同步序列 ‘00011101’</td></tr><tr><td>高速模式开始传输有效数据</td><td></td></tr><tr><td></td><td>接收到有效数据</td></tr></tbody></table><h2><span id="2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</span><a href="#2-8-end-of-transmission-eot-guo-cheng" class="header-anchor">#</a></h2><p>在数据完成传输时，通过结束传输（EoT）过程，数据通道退出高速模式并进入停止状态，这个过程状态变化如下：</p><table><thead><tr><th><strong>TX Side</strong></th><th><strong>RX Side</strong></th></tr></thead><tbody><tr><td>传输数据</td><td>接收到数据</td></tr><tr><td>在完成最后一个字节数据的传输之后，保持该状态的时间间隔为 THS-TRAIL</td><td></td></tr><tr><td>关闭 HS-TX，启用 LP-TX，并在 THS-EXIT一段时间内处于停止状态 ( LP-11 )</td><td>检测到 lane 状态进入停止状态 ( LP-11 )，关闭传输功能</td></tr><tr><td></td><td>忽略 THS-SKIP一段时间内的 lane 变化，以忽略转换状态</td></tr><tr><td></td><td>检测有效数据的最后一次转换，确定最后一次有效数据并忽略包尾序列</td></tr></tbody></table><p>接收器是如何判断数据将要开始传输了呢？</p><p>当出现LP11→LP01→LP00时，接收器将会判断，将会有数据达到，同时，使用示波器查看mipi波形，将会发现在PL00（THS-PREPARE）时会有一个小脉冲（峰刺），一般的，在这个小脉冲之后，接收器将会打开比较器（由于在THS-PREPARE会有这个小脉冲的存在，所以在接收器中，会通过设置接收器的settle time，避开这个小脉冲，在这个脉冲之后再打开比较器），准备接收数据。而HS-00011101则表示有效数据开始，同时数据的开头，将会有数据表明将要数据的数据量，所以mipi接收器将会按其数据量接收，直到接收完成。<br>每根 lane（data lane&#x2F;clk lane）从 LP 模式切换到 HS 模式都会有 LP11→LP01→LP00 这样的一个时序，同时还要检查 HS-00011101 ，HS-00011101 主要是用于同步，只有前面正确采集到 00011101 ，才能保证 clk 和 data 相位一一对应。</p><p><strong>mipi csi调试助手：</strong><br>测量 sensor 有相应的 mipi 信号输出，但是主控并没有接收到数据，通过查看主控的 mipi 寄存器发现，mipi接收器还处于 LP 模式，这种情况一般是mipi没有检测到sensor发送的从 LP 进入 HS 的时序。此时可测量sensor 开始输出图像数据时，clk lane 是否有 LP11→LP01→LP00 这样的一个时序。同时，应该先开 mipi，sensor 再开始 mipi 数据传输；<br>由于THS-PREPARE会有一个小脉冲的存在，所以，主控在接收mipi数据的时候，需要通过设置主控的settle time，这个时间需要在这个小脉冲之后，这样接收才不会有问题；<br>当出现 sensor 有数据输出，但是主控没有接收成功，这个情况一般是 mipi 的时序问题，sensor 端的时序没有和主控端的配合好，这个时候，可以尝试的减小sensor端的THS-PREPARE，增大THS-ZERO和THS-TRAIL；<br>由于一些主控的需求，在一帧数据完成之后，需要一定的时间才可以进行相应的ISP处理，当一帧传输完毕之后的LP11时间达不到主控ISP的时间要求导致ISP报错，可通过调节THS-TRAIL时间，以此得到ISP对帧间的时序长度要求 。</p><h1><span id="3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</span><a href="#3-csi-2-shu-ju-bao-xie-yi" class="header-anchor">#</a></h1><p>CSI-2 是針對攝像頭的數據協議， 規定了主機與外設通信的數據包格式。CSI-2 可以支持不同像素格式的圖像應用， 數據傳輸的最小粒度是字節。 為增加 CSI-2 的性能，可以選擇數據 Lane 的數量， CSI-2 協議規訂了發送端將像素數據打包成字節的機制， 並指明多個數據 Lane 分配和管理的方式。字節數據以數據包的形式組織，數據包在SoT 與 EoT 之間傳輸。 接收端根據協議解析相應的數據包， 恢復出原始的像素數據。</p><p>CSI-2 的數據包分為長包和短包兩種，包含有校驗碼，能進行誤碼糾正和錯誤檢測。長包和短包都是在 SoT 和 EoT 之間傳輸，在數據傳送的間隙， D-PHY 處於 LP 模式。 CSI-2數據包的傳輸機制如圖所示。 PH 和 PF 分別表示 Packet Header 和 Packet Footer。</p><h2><span id="3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</span><a href="#3-1-yi-ge-shu-ju-bao-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/7.png" alt="img"></p><h2><span id="3-2-bao-lei-xing">3.2 包类型</span><a href="#3-2-bao-lei-xing" class="header-anchor">#</a></h2><p>• 短包：4 bytes (固定)<br>• 长包：6~65541 bytes (可变) </p><h3><span id="3-2-1-duan-bao-jie-gou">3.2.1 短包结构</span><a href="#3-2-1-duan-bao-jie-gou" class="header-anchor">#</a></h3><p><strong>一个short packet（也叫做pack head(PH)）</strong></p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/8.png" alt="img"></p><p>包结构（4个字节）：<br>    • 数据标识(DI) 1个字节<br>    • WC （长度固定为2个字节）<br>    • 错误检测(ECC) 1个字节</p><p>包大小：<br>    • 长度固定为4个字节</p><h3><span id="3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</span><a href="#3-2-2-pack-footer-pf-de-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/9.png" alt="img"></p><h3><span id="3-2-3-chang-bao-jie-gou">3.2.3 长包结构</span><a href="#3-2-3-chang-bao-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/10.png" alt="img"></p><p>包头部（4个字节）（PH）：<br>• 　　数据标识(DI) 1个字节<br>• 　　数据计数WC (2个字节 )（PH和PF之間的資料個數）<br>• 　　错误检测(ECC) 1个字节<br>•　    数据填充(0~65535 字节)<br>•       长度&#x3D;WC*字节</p><p>包尾：校验和（2个字节）(PF)</p><p>长包 &#x3D; 短包（包头） + 数据 + 包尾 </p><p>包大小：<br>    4 + (0~65535) + 2 &#x3D; 6 ~ 65541 字节</p><h3><span id="3-2-4-h-blanking-amp-v-blanking">3.2.4 H-blanking &amp; V-blanking</span><a href="#3-2-4-h-blanking-amp-v-blanking" class="header-anchor">#</a></h3><p>传输多个pack和传输一个pack时对应的图像如下, VVALID&#x2F;HVALID&#x2F;DVALID可以先把它想成是影像的同步訊號VSync&#x2F;HSync&#x2F;DE，而Data就是影像資料，以方便理解。</p><p>从图中可以看到，当水平同步讯号HVALID为Low的这段区间，剛好就是每行的Blanking间隔, 也就是H-blanking。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/11.png" alt="img"></p><p>从下图可以看到上一FE到下一FS之间的间隔为V-blanking.</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/12.png" alt="img"></p><p>frame的封包示意图：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/13.png" alt="img"></p><h3><span id="3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</span><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/14.png" alt="img"></p><p> Data Identifier (DI) 为虚拟通道(VC, 2 bit)和资料类型(DT, 6 bit)组成。</p><h4><span id="3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</span><a href="#3-2-5-1-vc-virtual-channel" class="header-anchor">#</a></h4><p>可以看出MIPI最多可以輸入4组影像来源，其ID为0~3，且內容可以是任意的內容，下图就表示用virtual chn来传输不同格式的数据。比如一般Sony, OV的HDR 模式基本都是VC mode，包括2帧HDR, 3帧HDR。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/15.png" alt="img"></p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/16.png" alt="img"></p><h4><span id="3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</span><a href="#3-2-5-2-dt-data-type" class="header-anchor">#</a></h4><p>Data Type目前定义多种资料形态，范围从0x00<del>0x3F，其中0x00</del>0x0F为短封包类型，0x10~0x3F为長封包类型，如下表：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/17.png" alt="img"></p><p>用于同步的短包Data Type:</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/18.png" alt="img"></p><p>从<strong>soc到外设</strong>发送的包类型:</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/19.png" alt="img"></p><p>从<strong>外设到soc</strong>的数据包类型:</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/20.png" alt="img"></p><h1><span id="4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</span><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi" class="header-anchor">#</a></h1><p>MIPI CSI 共支持五種pixel資料格式的傳輸， 包含 YUV422-8bit、 YUV422-10bit、 RAW8、RAW10 和 RAW12。</p><h2><span id="4-1-rgb-ge-shi">4.1 RGB格式</span><a href="#4-1-rgb-ge-shi" class="header-anchor">#</a></h2><p>传统的红绿蓝格式，比如RGB565，RGB888，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>RGB565</td><td>1. 每个像素用16位表示，RGB分量分别使用5位、6位、5位。2. 内存中排列（高字节-&gt;低字节）：R R R R R G G G G G G B B B B B</td></tr><tr><td>RGB555</td><td>1. 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）2. 内存中排列（高字节-&gt;低字节）：X R R R R G G G G G B B B B B（X表示不用，可以忽略）</td></tr><tr><td>RGB24（RGB888）</td><td>1. 每个像素用24位表示，RGB分量各使用8位。在内存中RGB各分量的排列顺序为：BGR BGR BGR ……2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R</td></tr><tr><td>ARGB32（ARGB8888）</td><td>1. 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R A A A A A A A A</td></tr></tbody></table><h2><span id="4-2-yuv-ge-shi">4.2 YUV格式</span><a href="#4-2-yuv-ge-shi" class="header-anchor">#</a></h2><p>YUV是一种色彩编码方法，是一种彩色编码系统，相对于RGB色彩空间，YUV传输带宽占用更低，传输数据不易出错。</p><p>Y’UV、YUV、YCbCr、YPbPr 几个概念其实是一回事儿。由于历史关系，Y’UV、YUV 主要是用在彩色电视中，用于模拟信号表示。YCbCr 是用在数字视频、图像的压缩和传输，如 MPEG、JPEG。今天大家所讲的 YUV 其实就是指 YCbCr。Y 表示亮度（luma），CbCr 表示色度（chroma）。</p><p>人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感。所以在视频编码系统中为了降低带宽，可以保存更多的亮度信息(luma)，保存较少的色差信息(chroma)。</p><p>luminance 亮度，luma 是在视频编码系统中指亮度值；</p><p>chrominance 色度，chroma 是在视频编码系统中指色度值。</p><p>Y’UV 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是(UV)，那么在彩色电视显示的时候只显示亮度信息。</p><p>YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式。色度(UV)定义了颜色的两个方面─色调与饱和度，分别用CB和CR表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p><h3><span id="4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</span><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping" class="header-anchor">#</a></h3><p>原则：在数字图像中<br>    1) 每一个图形像素都要包含 luma（亮度）值；<br>    2）几个图形像素共用一个 Cb + Cr 值，一般是 2、4、8 个像素。</p><p>主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。</p><h4><span id="4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</span><a href="#4-2-1-1-yuv444-cai-yang" class="header-anchor">#</a></h4><p>全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。<br>假设4*4像素，采样格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br></pre></td></tr></table></figure><p>那么1920<em>1080文件的大小：1920</em>1080*3（B），那么一个像素对应3个字节。</p><h4><span id="4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</span><a href="#4-2-1-2-yuv422-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;3存储空间和1&#x2F;3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。如果水平方向有10个像素点，那么采样了10个Y分量，而只采样了5个UV分量。其中，每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。<br>假设4*4像素，采样格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br></pre></td></tr></table></figure><p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.5+1920<em>1080</em>0.5（B），那么UV的数量减少了一半，相对于YUV444空间节省了1&#x2F;3。</p><h4><span id="4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</span><a href="#4-2-1-3-yuv420-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;2存储空间和1&#x2F;2的数据传输量。YUV 420采样，并不是指只采样U分量而不采样V分量。而是指，在每一行扫描时，只扫描一种色度分量（U或者V）和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402，也就是第一行只有U，而第二行只有V。<br>假设4*4像素，采样格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br></pre></td></tr></table></figure><p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.25+1920<em>1080</em>0.25（B）相对于YUV444空间节省1&#x2F;2，因此也是比较主流的采样方式。</p><h3><span id="4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</span><a href="#4-2-2-yuv-cun-chu-fang-shi" class="header-anchor">#</a></h3><p>YUV的格式有两大类：<strong>planar（平面格式）和packed（打包格式）</strong>。</p><h4><span id="4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</span><a href="#4-2-2-1-planner-cun-chu" class="header-anchor">#</a></h4><p>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。</p><p>一般默认是3个平面，即y平面，u平面，v平面。但还有一种semi-planar是两个平面。也就是说uv为同一个平面，即一个y平面，一个uv平面。</p><h5><span id="4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</span><a href="#4-2-2-1-1-yuv420-planner" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/21.png" alt="img"></p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/22.png" alt="img"></p><p>例如：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/23.png" alt="img"></p><p>可以看到第一行的Y1Y2和第二行的Y7Y8共同使用一组U1V1。</p><h5><span id="4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</span><a href="#4-2-2-1-2-yuv420sp" class="header-anchor">#</a></h5><p> two-planer双平面，Y一个平面，UV在同一个平面交叉存储。也叫做semi-planar的YUV格式。</p><ol><li><p>nv12</p><p>先存储全部的Y分量，然后UV分量交叉存储。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/24.png" alt="img"></p></li><li><p>nv21</p><p>先UV分量交叉存储, 然后存储全部的Y分量。</p></li></ol><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/25.png" alt="img"></p><h5><span id="4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</span><a href="#4-2-2-1-3-yuv422-planner" class="header-anchor">#</a></h5><p>3平面，数据量：u&#x3D;v&#x3D;y&#x2F;2，不画图展示</p><h5><span id="4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</span><a href="#4-2-2-1-4-yuv422sp" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/26.png" alt="img"></p><p>可以看到y0y82个像素公用一组u0v0。</p><h4><span id="4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</span><a href="#4-2-2-2-packed-cun-chu" class="header-anchor">#</a></h4><p>packed的YUV格式，每个像素点的Y、U、V都是连续交叉存储的。</p><h5><span id="4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</span><a href="#4-2-2-2-1-yuyv" class="header-anchor">#</a></h5><p>该格式属于4：2：2类型，且是用packed形式存储的，相邻的2个像素共用一个Cb(U)和Cr(V)，以16个像素为例如下图：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/27.png" alt="img"></p><h5><span id="4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</span><a href="#4-2-2-2-2-yvyu" class="header-anchor">#</a></h5><p>与YUYV相似，只是存储时UV分量顺序不同而已。</p><p>4.2.2.2.2 uyvy</p><p>与YUYV相似，只是存储时UV分量顺序不同而已。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/28.png" alt="img"></p><h2><span id="4-3-raw-ge-shi">4.3 RAW 格式</span><a href="#4-3-raw-ge-shi" class="header-anchor">#</a></h2><p>RAW图像就是CMOS或者CCD图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。Raw data（Raw RGB）经过彩色插值就变成RGB。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/29.png" alt="img"></p><p>sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B 。</p><h3><span id="4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</span><a href="#4-3-1-bayer-zhen-lie" class="header-anchor">#</a></h3><p>人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和，那么bayer格式一般有下面4种：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/30.png" alt="img"></p><h1><span id="5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</span><a href="#5-mipi-csi-shu-ju-bao-chuan-shu" class="header-anchor">#</a></h1><p>raw8格式传输：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/31.png" alt="img"></p><p>raw10格式传输：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/32.png" alt="img"></p><p>raw12格式传输：</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/33.png" alt="img"></p><p> 从图像看，RAW8是一传输个字节对应一个pixel， 而raw10是5个byte去对应4个pixel，第5个byte用来存储pixel 0~3的bit[0:1]。同理raw12用3个byte存储2个pixel。</p><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/34.png" alt="img"></p><h1><span id="6-se-cai-shen-du">6 色彩深度</span><a href="#6-se-cai-shen-du" class="header-anchor">#</a></h1><p>8位彩色，有256种深度。<br>16位彩色：65,536种颜色。<br>24位彩色：每种原色都有256个层次，它们的组合便有256<em>256</em>256种颜色。<br>32位彩色：除了24位彩色的颜色外，额外的8位是储存重叠图层的图形资料(alpha透明度)。</p><h1><span id="7-tu-xiang-jie-xi-du-x2f-fen-bian-lu">7 图像解析度&#x2F;分辨率</span><a href="#7-tu-xiang-jie-xi-du-x2f-fen-bian-lu" class="header-anchor">#</a></h1><p>Resolution：</p><table><thead><tr><th>1280 * 720 &#x3D; 921600</th><th>1M</th><th>100万像素</th><th>720P</th><th>H65 sensor</th></tr></thead><tbody><tr><td>1920 * 1080 &#x3D; 2073600</td><td>2M</td><td>200万像素</td><td>1080P</td><td>Imx307&#x2F;imx327 sensor</td></tr><tr><td>2560 * 1440 &#x3D; 36864002560 * 1600 &#x3D; 40960002592 * 1944 &#x3D; 5038848</td><td>4M&#x2F;5M</td><td>400万像素500万像素</td><td>2K</td><td>Imx335&#x2F;sc4210 sensor</td></tr><tr><td>3840 * 2160 &#x3D; 8294400</td><td>8M</td><td>800万像素</td><td>4K</td><td>Imx334 sensor</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-mipi-csi2-de-fa-song-he-jie-shou&quot;&gt;1 MIPI CSI2的发送和接收&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-d-phy-dsi</summary>
      
    
    
    
    
    <category term="mipi图像处理" scheme="http://example.com/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>mipi-csi硬件篇</title>
    <link href="http://example.com/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/"/>
    <id>http://example.com/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/</id>
    <published>2024-04-02T06:28:07.000Z</published>
    <updated>2024-04-02T07:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-mipi-csi-ying-jian">1 mipi-csi硬件</a><ul><li><a href="#1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</a></li><li><a href="#1-2-mipi-vs-dvp">1.2 MIPI vs DVP</a></li><li><a href="#1-3-csi-gui-ge">1.3 CSI规格</a></li><li><a href="#1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</a></li><li><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</a><ul><li><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</a></li><li><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</a></li></ul></li><li><a href="#1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</a></li><li><a href="#1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</a></li></ul></li></ul><!-- tocstop --></div># 1 mipi-csi硬件<h2><span id="1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</span><a href="#1-1-mipi-csi-gai-nian" class="header-anchor">#</a></h2><p><strong>DSI （Display serial interface）</strong>定义了一个位于处理器和显示模组之间的高速串行接口,对应MIPI-TX.<br><strong>CSI(Camera Serial Interface）</strong>定义了一个位于处理器和摄像模组之间的高速串行接口,也就是接下来要讲的MIPI-RX。</p><p>MIPI Rx (Mobile Industry Processor Interface Receiver) 模塊主要功能為接收由 CMOS sensor 所傳送的視頻數據， 支持 MIPI D-PHY、 sub-LVDS (Low-Voltage Differential Signal)、 HiSPi (High-Speed Serial Pixel Interface) 等不同的串行視頻信號輸入， 並將其處理轉化為內部視頻時序，傳遞給下一級的視頻處理模塊 (ISP)。MIPI Rx 模塊中可細分為 PHY 和 Controller 兩部分，其中 PHY 模塊集成了模擬和數字兩個部分，主要將串行信號轉換為並行信號，而 Controller 模塊則負責解碼不同的視頻數據格式，傳送給後端的視頻處理模塊 (ISP)。功能框圖及在系統中的位置如下图所示:</p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/1.png" alt="img"></p><h2><span id="1-2-mipi-vs-dvp">1.2 MIPI vs DVP</span><a href="#1-2-mipi-vs-dvp" class="header-anchor">#</a></h2><p><strong>DVP:</strong></p><p>并口传输数据需要帧同步信号（Vsync）、行同步信号（Hsync）和八条数据线，共十根数据线, DVP 接口在信号完整性方面受限制，速率也受限制。</p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/2.png" alt="img"></p><p><strong>MIPI:</strong></p><p>MIPI 传输只需要帧同步信号（Vsync）、行同步信号（Hsync）、mipi 时钟（mipi_clk）、mipi 数据（mipi_data）和像素时钟（PCLK）5 根数据线。对比MIPI 接口比 DVP 的接口信号线少，由于是低压差分信号，产生的干扰小，抗干扰能力也强。</p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/3.png" alt="img"></p><h2><span id="1-3-csi-gui-ge">1.3 CSI规格</span><a href="#1-3-csi-gui-ge" class="header-anchor">#</a></h2><p>可同時支持 2 路 sensor 輸入（2组D-PHY， 每组5对差分线（1C4D））</p><p>• sensor 0 最大支持 4K2K @60fps HDR or @30fps 線性輸入</p><p>• sensor 1 最大支持 3M(2304x1296) @60fps HDR or linear 輸入</p><p>• 單路最多支持 4-Lane MIPI D-PHY 接口，最大支持 2.5Gbps&#x2F;Lane</p><p>• 單路最多支持 4-Lane sub-LVDS&#x2F; HiSPi 接口，最大支持 1.5Gbps&#x2F;Lane</p><p>• 支持 RAW8&#x2F; RAW10&#x2F; RAW12 數據類型的解析</p><p>• 支持 YUV422 8-bit&#x2F; YUV422 10-bit 數據類型的解析</p><p>• 最多支持 2 幀 WDR，支持多種 WDR 時序</p><p>• 支持 sub-LVDS&#x2F; HiSPi 模式像素&#x2F;同步碼大小端配置</p><p>• 支持 Lane 數和 Lane 順序可配置</p><p>MIPI Rx 的帶寬有兩部分限制： PHY 的接口數據率和內部處理速度。</p><p>輸入接口最大支持 2.5Gbps&#x2F;Lane，內部處理速度最大為 600M*1pixels&#x2F;s（MAC clk）</p><h2><span id="1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</span><a href="#1-4-csi-jie-kou-lei-xing" class="header-anchor">#</a></h2><table><thead><tr><th>Common modevoltage</th><th>Differential modevoltage</th><th>Maximum clockfrequency</th><th>Maximum datarate per lane</th></tr></thead><tbody><tr><td><strong>MIPI DPHY</strong> 200mV</td><td>200mV</td><td>1.25GHz</td><td>2.5Gbps</td></tr><tr><td>Sub-LVDS 900mV</td><td>150mV</td><td>750MHz</td><td>1.5Gbps</td></tr><tr><td>HiSPi(HiVCM) 900mV</td><td>280mV</td><td>750MHz</td><td>1.5Gbps</td></tr><tr><td>HiSPi(SLVDS) 200mV</td><td>200mV</td><td>750MHz</td><td>1.5Gbps</td></tr></tbody></table><h2><span id="1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</span><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian" class="header-anchor">#</a></h2><p>常用的电脑摄像头是USB接口, 主流的智能手机摄像头是MIPI接口, 下面讲解常用的智能手机 camera MIPI接口。</p><p>MIPI CSI一般会有1对I2C通信引脚，1对MIPI差分时钟引脚和1~4对MIPI差分数据信号引脚, 也就是1CD4(1 clk lane &amp; 4 data lane)。</p><h3><span id="1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</span><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu" class="header-anchor">#</a></h3><table><thead><tr><th>信号名</th><th>引脚类型</th><th>描述</th></tr></thead><tbody><tr><td>DOVDD</td><td>电源</td><td>1.8V IO 电源</td></tr><tr><td>DVDD</td><td>电源</td><td>1.2V 数字电源</td></tr><tr><td>AVDD</td><td>电源</td><td>2.8V 模拟电源</td></tr><tr><td>SCL</td><td>输入</td><td>I2C 时钟线</td></tr><tr><td>SDA</td><td>输入&#x2F;输出</td><td>I2C 数据线(open drain)</td></tr><tr><td>SID0</td><td>输入</td><td>I2C Device ID 的选择 0 (内置下拉电阻，默认Device ID 是 7’h30)</td></tr><tr><td>SID1</td><td>输入</td><td>I2C Device ID 的选择 1 (内置下拉电阻，默认Device ID 是 7’h30)</td></tr><tr><td>XSHUTDN （RST）</td><td>输入</td><td>复位信号输入(内置上拉电阻，低电位有效)</td></tr><tr><td>EXTCLK</td><td>输入</td><td>时钟输入</td></tr><tr><td>PWDNB</td><td>输入</td><td>Power Down 信号输入(内置上拉电阻， 低电位有效)</td></tr><tr><td>D&lt;3&gt;(MD3P)</td><td>输出</td><td>DVP 输出 bit[3]&#x2F;MIPI 数据 3 正极信号</td></tr><tr><td>D&lt;5&gt;(MD1P)</td><td>输出</td><td>DVP 输出 bit[5]&#x2F;MIPI 数据 1 正极信号</td></tr><tr><td>D&lt;7&gt;(MCP)</td><td>输出</td><td>DVP 输出 bit[7]&#x2F;MIPI 时钟正极信号</td></tr><tr><td>D&lt;8&gt;(MD0P)</td><td>输出</td><td>DVP 输出 bit[8]&#x2F;MIPI 数据 0 正极信号</td></tr><tr><td>D&lt;10&gt;(MD2P)</td><td>输出</td><td>DVP 输出 bit[10]&#x2F;MIPI 数据 2 正极信号</td></tr><tr><td>D&lt;4&gt;(MD3N)</td><td>输出</td><td>DVP 输出 bit[4]&#x2F;MIPI 数据 3 负极信号</td></tr><tr><td>D&lt;6&gt;(MD1N)</td><td>输出</td><td>DVP 输出 bit[6]&#x2F;MIPI 数据 1 负极信号</td></tr><tr><td>PCLK(MCN)</td><td>输出</td><td>DVP 输出时钟&#x2F;MIPI 时钟负极信号</td></tr><tr><td>D&lt;9&gt;(MD0N)</td><td>输出</td><td>DVP 输出 bit[9]&#x2F;MIPI 数据 0 负极信号</td></tr><tr><td>D&lt;11&gt;(MD2N)</td><td>输出</td><td>DVP 输出 bit[11]&#x2F;MIPI 数据 2 负极信号</td></tr></tbody></table><h3><span id="1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</span><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/4.png" alt="img"></p><p>一般mipi接口的sensor支持4 lane，2 lane，1 lane等数据传输方式。上图硬件上的连接了1组clk lane, 4组data lane。这幅图只连接了i2c和lane总线，还有EXTCLK ，PWDN, RST, VDD等引脚的连线需要外部soc去提供。这里就需要驱动人员会看原理图，知道lane id和pn swap的接线。clk lane, data lane等。</p><h2><span id="1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</span><a href="#1-6-chai-fen-xin-hao-jie-shao" class="header-anchor">#</a></h2><p>我们用一个方法对差分信号做一下比喻，差分信号就好比是跷跷板上的两个人，当一个人被跷上去的时候，另一个人被跷下来了 - 但是他们的平均位置是不变的。继续跷跷板的类推，正值可以表示左边的人比右边的人高，而负值表示右边的人比左边的人高。0 表示两个人都是同一水平。</p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/5.png" alt="img"></p><p>下图，应用到电学上，这两个跷跷板用一对标识为V+和V-的导线来表示。当V+ &gt; V-时，信号定义成正极信号，V+ &lt; V-时，信号定义成负极信号。 差分对的平均电压设置成 2.5V。</p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/6.png" alt="img"></p><h2><span id="1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</span><a href="#1-7-mipi-sensor-de-power-on-shi-xu" class="header-anchor">#</a></h2><p><strong>Sony imx334：</strong></p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/7.png" alt="img"></p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/8.png" alt="img"></p><p><strong>SC4210：</strong></p><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/9.png" alt="img"></p><p>这里列举了sony imx334和格科微gc2093, sc4210的上电时序，现在市面上大部分的mipi接口sensor都可以让VDD，PWDN, RST，EXTCLK讯号同时发出，然后过一段时间后就可以进行I2c通信了。</p><p>在HW交接到SW后，要确保最基本的power on时序是ok的，最好是用示波器对VDD，PWDN, RST，EXTCLK，I2c等波形进行测量无误后再porting到SW手上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-mipi-csi-ying-jian&quot;&gt;1 mipi-csi硬件&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-mipi-csi-gai-nian&quot;&gt;1.1 mipi</summary>
      
    
    
    
    
    <category term="mipi图像处理" scheme="http://example.com/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Vim配置成类似source-insight的IDE</title>
    <link href="http://example.com/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/"/>
    <id>http://example.com/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/</id>
    <published>2024-04-01T10:05:19.000Z</published>
    <updated>2024-04-02T07:07:04.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#qian-yan">前言</a><ul><li><a href="#ji-ben-an-zhuang">基本安装</a></li></ul></li><li><a href="#1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</a><ul><li><a href="#1-1-ctag-zuo-yong">1.1 ctag作用</a></li><li><a href="#1-2-an-zhuang-ctags">1.2 安装ctags</a></li><li><a href="#1-3-an-zhuang-taglist">1.3 安装taglist</a></li><li><a href="#1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</a><ul><li><a href="#1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</a></li></ul></li><li><a href="#1-5-pei-zhi-vimrc">1.5 配置.vimrc</a></li></ul></li><li><a href="#2-ctags-taglist-shi-yong">2 ctags + taglist使用</a><ul><li><a href="#2-1-ctags-shi-yong">2.1 ctags使用</a><ul><li><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</a></li><li><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</a></li><li><a href="#2-1-3-jia-zai-tags">2.1.3 加载tags</a></li><li><a href="#2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</a></li><li><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</a></li><li><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</a></li><li><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</a></li></ul></li><li><a href="#2-2-taglist-shi-yong">2.2 taglist使用</a><ul><li><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</a></li><li><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</a></li><li><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</a></li></ul></li></ul></li><li><a href="#3-nerdtree-cha-jian">3 NERDTree插件</a><ul><li><a href="#3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</a><ul><li><a href="#3-1-1-an-zhuang">3.1.1 安装</a></li><li><a href="#3-1-2-pei-zhi">3.1.2 配置</a></li></ul></li><li><a href="#3-2-shi-yong-nerdtree">3.2 使用NERDTree</a><ul><li><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</a></li><li><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</a></li><li><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</a></li><li><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</a></li></ul></li></ul></li><li><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</a><ul><li><a href="#4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</a></li><li><a href="#4-2-srcexpl-shi-yong">4.2 SrcExpl使用</a><ul><li><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</a></li></ul></li></ul></li><li><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</a><ul><li><a href="#5-1-an-zhuang-pei-zhi">5.1 安装配置</a></li><li><a href="#5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</a></li></ul></li><li><a href="#6-cscope-cha-jian">6 cscope插件</a><ul><li><a href="#6-1-an-zhuang">6.1 安装</a></li><li><a href="#6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</a></li><li><a href="#6-3-pei-zhi-vimrc">6.3 配置.vimrc</a></li><li><a href="#6-5-shi-yong">6.5 使用</a><ul><li><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</a></li><li><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</a></li><li><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</a></li></ul></li></ul></li><li><a href="#7-source-insight-kuo-zhan">7 source insight扩展</a><ul><li><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><h2><span id="ji-ben-an-zhuang">基本安装</span><a href="#ji-ben-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install vim vim-scripts vim-doc</code></pre><p>vim-scripts是vim的一些基本插件，包括语法高亮的支持、缩进等等。<br>整体配置好后效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/1.png" alt="image"></p><h1><span id="1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</span><a href="#1-ctags-taglist-an-zhuang-pei-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-ctag-zuo-yong">1.1 ctag作用</span><a href="#1-1-ctag-zuo-yong" class="header-anchor">#</a></h2><p>ctags 最先是用来生成C代码的tags文件，后来扩展成可以生成各类语言的tags, 有些语言也有专有的tags生成工具（比如java的jtags, python的 ptags)，因此ctag用来进行vim阅读源码时进行函数，变量的快速定位跳转。</p><h2><span id="1-2-an-zhuang-ctags">1.2 安装ctags</span><a href="#1-2-an-zhuang-ctags" class="header-anchor">#</a></h2><pre><code>sudo apt-get install ctags</code></pre><h2><span id="1-3-an-zhuang-taglist">1.3 安装taglist</span><a href="#1-3-an-zhuang-taglist" class="header-anchor">#</a></h2><p>taglist_46.zip压缩包：解压到~&#x2F;.vim目录下即可。<br><a href="https://www.vim.org/scripts/script.php?script_id=273">https://www.vim.org/scripts/script.php?script_id=273</a></p><pre><code>mkdir ~/.vimcd ~/.vimunzip taglist_46.zip</code></pre><h2><span id="1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</span><a href="#1-4-chuang-jian-tags-wen-jian" class="header-anchor">#</a></h2><p><code>$ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q</code><br>如果为了简单，也可以只进行：<br><code>$ctags -R *</code><br>不过，这种成员变量没有包含在里面。所以可能有些对象的成员时无法跳转。</p><h3><span id="1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</span><a href="#1-4-1-pei-zhi-xuan-xiang" class="header-anchor">#</a></h3><pre><code>  $ ctags -R　　　　　　　　　　　　　  #递归的为当前目录及子目录下的所有代码文件生成tags文件 (推荐使用此命令)  $ ctags filename.c filename1.c file.h 　#为当前目录某些源码生成tags文件  $ ctags *.c *.h　　　　　　　　　　　   #为当前目录所有.c, .h源码生成tags文件  为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c++参数主要是：ctags -R --c++-kinds=+px --fields=+iaS --extra=+q  其中：    选项c++-kinds 用于指定C++语言的 tags记录类型,  --c-kinds用于指定c语言的，  通用格式是  --&#123;language&#125;-kinds    选项 fileds 用于指定每条标记的扩展字段域    extra 选项用于增加额外的条目:   f表示为每个文件增加一个条目，  q为每个类增加一个条目</code></pre><h2><span id="1-5-pei-zhi-vimrc">1.5 配置.vimrc</span><a href="#1-5-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;--------------display-----------------set nu                          &quot;行号syntax on                       &quot;语法高亮set ruler                       &quot;显示当前行和列set showcmd                     &quot;显示部分命令set showmode            &quot;最后一行显示当前模式&quot;set match                      &quot;显示括号匹配&quot;--------------display-----------------&quot;---------------input------------------set smartindent         &quot;自动缩进set expandtab           &quot;将tab转化为空格set smarttab            &quot;插入tab使用shiftwidthset shiftwidth=4        &quot;缩进列数为4&quot;---------------input------------------&quot;---------------search-----------------set hlsearch            &quot;搜索结果高亮显示&quot;set inccase                    &quot;预览搜索结果set ignorecase          &quot;不区分大小写set smartcase           &quot;当有大写字母时区分大小写&quot;---------------search-----------------&quot;---------------encoding----------------set encoding=utf-8              &quot;设置编码格式set fileencodings=utf-8,gb18030,gbk,gb2312,big5set termencoding=utf-8&quot;--------------ctags----------------set tags=tags;set autochdir        &quot;通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。&quot;--------------ctags----------------&quot;--------------taglist----------------let Tlist_Use_Left_Window=1             &quot;vim左侧窗口显示Taglistlet Tlist_Exit_OnlyWindow=1             &quot;Taglist是最后一个窗口是退出vimlet Tlist_WinWidth=60           &quot;设置Taglist窗口宽度为60nmap &lt;F2&gt; :Tlist&lt;CR&gt;                    &quot;设置快捷键&lt;F2&gt;打开Taglist&quot;--------------taglist----------------</code></pre><h1><span id="2-ctags-taglist-shi-yong">2 ctags + taglist使用</span><a href="#2-ctags-taglist-shi-yong" class="header-anchor">#</a></h1><h2><span id="2-1-ctags-shi-yong">2.1 ctags使用</span><a href="#2-1-ctags-shi-yong" class="header-anchor">#</a></h2><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/2.png" alt="image"></p><h3><span id="2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</span><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/3.png" alt="image"></p><h3><span id="2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</span><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/4.png" alt="image"></p><h3><span id="2-1-3-jia-zai-tags">2.1.3 加载tags</span><a href="#2-1-3-jia-zai-tags" class="header-anchor">#</a></h3><p>默认从创建tags的目录去启动vim打开文件会自动加载当前目录的tags文件，因此可以直接跳转：<br>如我是从uboot根目录建立的tags文件，然后：</p><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c</code></pre><p>这样自动加载tags文件，能够进行跳转。<br>如果进入其他目录：可以看到就无法打开tags文件。</p><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ cd  drivers/usb/gadget/book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/5.png" alt="image"></p><p>vim进入命令模式输入：</p><pre><code>:set tags+=&#39;/home/book/ftp/openedv/uboot-2016/tags</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/6.png" alt="image"><br>此时就可以正常跳转了。</p><h3><span id="2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</span><a href="#2-1-4-zi-dong-jia-zai-tags" class="header-anchor">#</a></h3><p>在~&#x2F;.vimrc文件中添加下面两行：</p><pre><code>set tags=tags;set autochdir</code></pre><p>通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。<br>这样就可以在不用在tags根路径去使用vim了。如：</p><pre><code>book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/7.png" alt="image"></p><h3><span id="2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</span><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/8.png" alt="image"><br>可以看到有2处地方匹配，一个是cmd&#x2F;bootm.c，一个是include&#x2F;command.h<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/9.png" alt="image"></p><h3><span id="2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</span><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/10.png" alt="image"><br>输入:q退出分割窗口。</p><h3><span id="2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</span><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu" class="header-anchor">#</a></h3><p>例如stitch_event_handler_th函数位于当前tags目录中的stitch&#x2F;common&#x2F;stitch.c的第1212行。只需确保在tags中的子目录中任意位置输入：</p><p><code>robin.lee@WORKSTATION5:/robin.lee/zip/A2/osdrv/interdrv/v2/dwa$ vi -t stitch_event_handler_th</code><br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/11.png" alt="image"></p><h2><span id="2-2-taglist-shi-yong">2.2 taglist使用</span><a href="#2-2-taglist-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</span><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/12.png" alt="image"></p><h3><span id="2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</span><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/13.png" alt="image"></p><p>例如光标位置处于vim窗口的第1211行，按下ctrl w w键（w按2次），光标会跳到左边taglist窗口。按上下左右方向键可以查找宏定义，符号，函数等。再次按ctrl w w又会跳到vim的窗口。</p><h3><span id="2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</span><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/14.png" alt="image"><br>比如现在光标位于taglist界面的stitch_src_qbuf位置，按下回车会跳转到函数定义的具体位置：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/15.png" alt="image"></p><h1><span id="3-nerdtree-cha-jian">3 NERDTree插件</span><a href="#3-nerdtree-cha-jian" class="header-anchor">#</a></h1><p>NERDTree是Vim界面显示树形目录的文件管理器插件，可在vim操作界面进行文件打开、目录浏览操作。</p><h2><span id="3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</span><a href="#3-1-an-zhuang-pei-zhi-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-1-1-an-zhuang">3.1.1 安装</span><a href="#3-1-1-an-zhuang" class="header-anchor">#</a></h3><p><a href="https://www.vim.org/scripts/script.php?script_id=1658">https://www.vim.org/scripts/script.php?script_id=1658</a><br>下载后放到~&#x2F;.vim目录，解压即可完成安装。</p><h3><span id="3-1-2-pei-zhi">3.1.2 配置</span><a href="#3-1-2-pei-zhi" class="header-anchor">#</a></h3><p><code>vi ~/.vimrc</code><br>添加如下配置：</p><pre><code>&quot;--------------NERDTree---------------let NERDTreeWinPos=&#39;right&#39;&quot;设置窗口在右侧nmap &lt;F8&gt; :NERDTree&lt;CR&gt;&quot;设置快捷键F8打开let NERDTreeWinSize=40 &quot;窗口大小为40&quot;--------------NERDTree---------------</code></pre><h2><span id="3-2-shi-yong-nerdtree">3.2 使用NERDTree</span><a href="#3-2-shi-yong-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</span><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/16.png" alt="image"></p><h3><span id="3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</span><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/17.png" alt="image"><br>光标原本再右边窗口，输入ctrl w w(w按2次)切换到左边vim窗口。</p><h3><span id="3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</span><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p>同理，和taglist一样，也是光标移动到具体文件后回车即可跳转到具体文件。方向键上下移动选择具体文件。跳转到stitch_ctx.h：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/18.png" alt="image"></p><h3><span id="3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</span><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu" class="header-anchor">#</a></h3><p>选择‘up a dir’，按回车：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/19.png" alt="image"><br>返回上一层目录的结果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/20.png" alt="image"></p><h1><span id="4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</span><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao" class="header-anchor">#</a></h1><p>SrcExpl（源资源管理器）是一个源代码资源管理器，通过显示函数或类型定义来显示当前选定的关键字或在单独的窗口中声明。该插件旨在重新创建上下文 IDE 中可用的窗口。</p><p>结合“Taglist”和“NERD tree”效果更佳。</p><h2><span id="4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</span><a href="#4-1-srcexp-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>安装：<br><a href="https://github.com/wenlongche/SrcExpl">https://github.com/wenlongche/SrcExpl</a><br><a href="https://www.vim.org/scripts/script.php?script_id=2179">https://www.vim.org/scripts/script.php?script_id=2179</a><br>下载后放入<del>&#x2F;.vim进行解压即可。<br>配置：<br>打开</del>&#x2F;.vimrc,添加如下配置：</p><pre><code>&quot; // The switch of the Source Explorernmap &lt;F12&gt; :SrcExplToggle&lt;CR&gt;&quot; // Set the height of Source Explorer windowlet g:SrcExpl_winHeight = 16&quot; // Set 100 ms for refreshing the Source Explorerlet g:SrcExpl_refreshTime = 500&quot; // Set &quot;Enter&quot; key to jump into the exact definition contextlet g:SrcExpl_jumpKey = &quot;&lt;ENTER&gt;&quot;&quot; // Set &quot;Space&quot; key for back from the definition contextlet g:SrcExpl_gobackKey = &quot;&lt;SPACE&gt;&quot;&quot; // In order to avoid conflicts, the Source Explorer should know what plugins except&quot; // itself are using buffers. And you need add their buffer names into below list&quot; // according to the command &quot;:buffers!&quot;let g:SrcExpl_pluginList = [        \ &quot;__Tag_List__&quot;,        \ &quot;_NERD_tree_&quot;,        \ &quot;Source_Explorer&quot;    \ ]&quot; // The color schemes used by Source Explorer. There are five color schemes&quot; // supported for now - Red, Cyan, Green, Yellow and Magenta. Source Explorer&quot; // will pick up one of them randomly when initialization.let g:SrcExpl_colorSchemeList = [        \ &quot;Red&quot;,        \ &quot;Cyan&quot;,        \ &quot;Green&quot;,        \ &quot;Yellow&quot;,        \ &quot;Magenta&quot;    \ ]&quot; // Enable/Disable the local definition searching, and note that this is not&quot; // guaranteed to work, the Source Explorer doesn&#39;t check the syntax for now.&quot; // It only searches for a match with the keyword according to command &#39;gd&#39;let g:SrcExpl_searchLocalDef = 1&quot; // Workaround for Vim bug @https://goo.gl/TLPK4K as any plugins using autocmd for&quot; // BufReadPre might have conflicts with Source Explorer. e.g. YCM, Syntastic etc.let g:SrcExpl_nestedAutoCmd = 1&quot; // Do not let the Source Explorer update the tags file when openinglet g:SrcExpl_isUpdateTags = 0&quot; // Use &#39;Exuberant Ctags&#39; with &#39;--sort=foldcase -R .&#39; or &#39;-L cscope.files&#39; to&quot; // create/update the tags filelet g:SrcExpl_updateTagsCmd = &quot;ctags --sort=foldcase -R .&quot;&quot; // Set &quot;&lt;F12&gt;&quot; key for updating the tags file artificiallylet g:SrcExpl_updateTagsKey = &quot;&lt;F12&gt;&quot;&quot; // Set &quot;&lt;F3&gt;&quot; key for displaying the previous definition in the jump listlet g:SrcExpl_prevDefKey = &quot;&lt;F3&gt;&quot;&quot; // Set &quot;&lt;F4&gt;&quot; key for displaying the next definition in the jump listlet g:SrcExpl_nextDefKey = &quot;&lt;F4&gt;&quot;</code></pre><h2><span id="4-2-srcexpl-shi-yong">4.2 SrcExpl使用</span><a href="#4-2-srcexpl-shi-yong" class="header-anchor">#</a></h2><h3><span id="4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</span><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl" class="header-anchor">#</a></h3><h1><span id="5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</span><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian" class="header-anchor">#</a></h1><h2><span id="5-1-an-zhuang-pei-zhi">5.1 安装配置</span><a href="#5-1-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>先安装编译依赖工具：</p><pre><code>sudo apt install build-essential cmake python-dev python3-dev clang</code></pre><p>下载YouCompleteMe源码：</p><pre><code>git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/cd .vim/bundle/YouCompleteMegit submodule update --init --recursive</code></pre><p>编译安装 YouCompleteMe:</p><pre><code>./install.py --clang-completer</code></pre><p>安装好后打印如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/21.png" alt="image"></p><h2><span id="5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</span><a href="#5-2-youcompleteme-shi-yong" class="header-anchor">#</a></h2><p>.vimrc添加配置：</p><pre><code>let g:ycm_global_ycm_extra_conf = &#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;set runtimepath+=~/.vim/bundle/YouCompleteMeautocmd InsertLeave * if pumvisible() == 0|pclose|endifinoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;imap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)vmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)nmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)</code></pre><p>vim版本比较低达不到插件YCM的要求从而报错【YouCompleteMe unavailable: requires Vim 8.1.2269+.】，这样也好解决，从github上重新下最新版本的vim即可。命令如下所示：</p><pre><code>cd /usr/local/sharesudo git clone https://github.com/vim/vim.gitcd vim/srcsudo ./configure --with-features=huge \--enable-multibyte \--enable-rubyinterp=yes \--enable-pythoninterp=yes \--enable-python3interp=yes \--prefix=/usr/local/vim82</code></pre><p>之后make和make install一下，命令如下所示：</p><pre><code>sudo makesudo make install</code></pre><p>在&#x2F;usr&#x2F;bin目录下建立符号链接，命令如下所示：</p><pre><code>sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim82sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vimsudo ln -s /usr/local/vim82/bin/vim /usr/bin/vi</code></pre><p>补齐效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/22.png" alt="image"><br>输入vim –version信息可以看vim版本号，现已经v9.1,默认应该是8.1的。<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/23.png" alt="image"></p><p>vim配色方案：<br><a href="https://github.com/flazz/vim-colorschemes">https://github.com/flazz/vim-colorschemes</a><br>设置函数高亮：</p><pre><code>vi /usr/share/vim/vim91/syntax/c.vim&quot;highlight Functionssyn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1hi cFunctions gui=NONE cterm=bold  ctermfg=40</code></pre><h1><span id="6-cscope-cha-jian">6 cscope插件</span><a href="#6-cscope-cha-jian" class="header-anchor">#</a></h1><h2><span id="6-1-an-zhuang">6.1 安装</span><a href="#6-1-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install cscope</code></pre><h2><span id="6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</span><a href="#6-2-pei-zhi-chan-sheng-cscope-out" class="header-anchor">#</a></h2><pre><code>cscope -Rbqk-R: 在生成索引文件时，搜索子目录树中的代码-b: 只生成索引文件，不进入cscope的界面-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度-k: 在生成索引文件时，不搜索/usr/include目录-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”–“，表示由标准输入获得文件列表。</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/24.png" alt="image"></p><h2><span id="6-3-pei-zhi-vimrc">6.3 配置.vimrc</span><a href="#6-3-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; cscope setting&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;if has(&quot;cscope&quot;)  set csprg=/usr/bin/cscope  set csto=1  set cst  set nocsverb  &quot; add any database in current directory  if filereadable(&quot;cscope.out&quot;)      cs add cscope.out  endif  set csverbendifnmap &lt;C-@&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;nmap &lt;C-@&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;nmap &lt;C-@&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;set cscopequickfix=s-,c-,d-,i-,t-,e-</code></pre><h2><span id="6-5-shi-yong">6.5 使用</span><a href="#6-5-shi-yong" class="header-anchor">#</a></h2><h3><span id="6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</span><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs add ./cscope.out</code></pre><h3><span id="6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</span><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs show</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/25.png" alt="image"></p><h3><span id="6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</span><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi" class="header-anchor">#</a></h3><pre><code>:cs f s symbol #查看symbol和引用的地方, 如:cs find s IDLE_TIMEOUT_MS</code></pre><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/26.png" alt="image"></p><h1><span id="7-source-insight-kuo-zhan">7 source insight扩展</span><a href="#7-source-insight-kuo-zhan" class="header-anchor">#</a></h1><h2><span id="7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</span><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight" class="header-anchor">#</a></h2><p><a href="https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE">https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#qian-yan&quot;&gt;前言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#ji-ben-an-zhuang&quot;&gt;基本安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Windows10搭建NFS服务</title>
    <link href="http://example.com/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-03-31T13:10:00.000Z</published>
    <updated>2024-03-31T13:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</a></li><li><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</a><ul><li><a href="#2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</a></li><li><a href="#2-2-bao-cun-pei-zhi">2.2 保存配置</a></li></ul></li><li><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3 让NFS服务通过防火墙</a></li><li><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</a></li><li><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</a></li><li><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</a></li><li><a href="#5-nfs-pei-zhi-wen-jian">5 nfs配置文件</a></li></ul><!-- tocstop --></div><h1><span id="1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</span><a href="#1-xia-zai-hanewin-nfs-server-for-windows" class="header-anchor">#</a></h1><p>链接如下：<br><a href="https://www.hanewin.net/nfs-e.htm">https://www.hanewin.net/nfs-e.htm</a><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/1.png" alt="image"></p><h1><span id="2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</span><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server" class="header-anchor">#</a></h1><p>安装完后，打开hanWin如下：进入Edit-&gt;Preferences<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/2.png" alt="image"></p><p>进入Exports-&gt;Edit exports file<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/3.png" alt="image"></p><h2><span id="2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</span><a href="#2-1-xiu-gai-pei-zhi-wen-jian" class="header-anchor">#</a></h2><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/4.png" alt="image"><br>添加一行配置如下：<br><code>D:\ldc_res -name:nfs *(rw,sync,no_root_squash)</code><br>表示把D盘ldc_res目录当成nfs共享目录，-name:nfs表示客户端挂载时使用nfs表示D:\ldc_res路径<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code></p><h2><span id="2-2-bao-cun-pei-zhi">2.2 保存配置</span><a href="#2-2-bao-cun-pei-zhi" class="header-anchor">#</a></h2><p>勾选如下2个选项：仅对授权用户可见，通过nfs将导出添加到文件夹的上下文菜单<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/5.png" alt="image"></p><h1><span id="3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3  让NFS服务通过防火墙</span><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang" class="header-anchor">#</a></h1><p>方法1：打开电脑防火墙设置，将专用网络和公用网络的防火墙禁用。<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/6.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/7.png" alt="image"></p><p>方法2：设置防火墙入栈连接规则<br>查看haneWIN NFS server的端口映射：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/8.png" alt="image"><br>可以看到haneWIN使用的端口如下：</p><pre><code>TCP：111, 1058, 2049UDP：111, 1058, 2049</code></pre><p>进入windows防火墙高级设置，设置入栈规则-&gt;新建规则：</p><pre><code>规则类型选端口，协议选TCP, 规则应用于特定本地端口，输入刚才查看的映射端口号：111，1058， 2049操作选允许连接配置文件将域，专用，公用网络全部勾选最后设置好名称和描述</code></pre><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/9.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/10.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/11.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/12.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/13.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/14.png" alt="image"></p><h1><span id="4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</span><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/15.png" alt="image"></p><p>设置板端IP地址：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/16.png" alt="image"><br>先确保windows和板端能ping通<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/17.png" alt="image"></p><h1><span id="4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</span><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/18.png" alt="image"></p><p><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code><br>可以看到已经挂载上了，并且能访问挂载目录的文件</p><h1><span id="4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</span><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian" class="header-anchor">#</a></h1><p>挂载上后发现没有可写权限，<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/19.png" alt="image"></p><p>修改配置exports选项，添加-maproot:0 -public<br><code>D:\ldc_res -name:nfs -maproot:0 -public *(rw,sync,no_root_squash)</code><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/20.png" alt="image"></p><p>可以可写可执行了：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/21.png" alt="image"></p><h1><span id="5-nfs-pei-zhi-wen-jian">5 nfs配置文件</span><a href="#5-nfs-pei-zhi-wen-jian" class="header-anchor">#</a></h1><pre><code>## exports example## please read doc for a list of all options# drive letters should be in upper case, because file-id returns upper case#   by default (option setting) they are mapped to lower case for clients# Option -range restricts access to specified address range#   a list of addresses restricts to these clients only# Option -readonly prohibits create/write/delete# Option -name:&lt;x&gt; makes folder for clients avalailable as /&lt;x&gt;# Option -maproot:&lt;uid&gt; maps unix root to specified &lt;uid&gt;#   without it uid root -&gt; uid NOBODY# Option -alldirs allows clients to mount folder or any subfolder# Use UNC path specification for access to remote drive# Hidden volumes without a drive letter can be mounted by volume GUID#C:\ftp -range 192.168.1.1 192.168.1.10C:\video -readonly 192.168.1.1 192.168.1.4 192.18.1.23C:\server -alldirs -name:server -maproot:0 -range 192.168.1.1 192.168.1.30\\router\FRITZ.NAS\SanDisk-U3CruzerMicro-00 -name:fritz\\?\Volume&#123;6afa3aa3-1b38-11e6-a140-0000fbaa0005&#125;\ -name:drive1D:\ldc_res -name:nfs -public -maproot:0 *(rw,sync,no_root_squash)E:\ -name:nfs_udisk -public -maproot:0 *(rw,sync,no_root_squash)</code></pre><p>挂载：<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs_udisk /mnt/</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-xia-zai-hanewin-nfs-server-for-windows&quot;&gt;1 下载haneWIN NFS Server for Windows&lt;/a&gt;&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>virtualbox配置实现PC-虚拟机-开发板互ping</title>
    <link href="http://example.com/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/"/>
    <id>http://example.com/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/</id>
    <published>2024-03-30T06:13:08.000Z</published>
    <updated>2024-03-30T06:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</a><ul><li><a href="#1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</a></li><li><a href="#1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</a><ul><li><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</a></li><li><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</a></li></ul></li></ul></li><li><a href="#2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</a><ul><li><a href="#2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</a></li><li><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</a></li></ul></li><li><a href="#3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</a></li><li><a href="#4-gai-jin-he-you-hua">4 改进和优化</a><ul><li><a href="#4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</a></li><li><a href="#4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</a></li><li><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</span><a href="#1-she-zhi-virtualbox-wang-qia" class="header-anchor">#</a></h1><h2><span id="1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</span><a href="#1-1-guan-bi-xu-ni-ji" class="header-anchor">#</a></h2><h2><span id="1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</span><a href="#1-2-she-zhi-tian-jia-wang-qia" class="header-anchor">#</a></h2><p>进入设置-网络</p><h3><span id="1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</span><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过网络地址转换到虚拟机，比如主机用无线网卡WLAN上网，用NAT转换比较合适，这样虚拟机也可以访问外网。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/1.png"></p><h3><span id="1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</span><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过无线网卡WLAN上外网，但是虚拟机想通过有线网卡和主机、甚至与开发板互相ping通，传输文件。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/2.png"></p><p>当然开启host only模式前先确保windows下的virtual host only网卡有开启，如下图：<br><img src="https://img2020.cnblogs.com/blog/1876680/202009/1876680-20200923151634434-1218500133.png"></p><p>如果没有请按照下图操作：（这里是添加host only网卡）<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/3.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/4.png"></p><h1><span id="2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</span><a href="#2-pei-zhi-windows-he-xu-ni-ji" class="header-anchor">#</a></h1><h2><span id="2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</span><a href="#2-1-pei-zhi-window-yi-tai-wang-qia" class="header-anchor">#</a></h2><p>刚添加了虚拟机虚拟virtual host only网卡, 那么我们反正用的WLAN上的外网，为了方便，设置windows下的以太网卡网段和virtual host only网卡保持一致。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/5.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/6.png"></p><h2><span id="2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</span><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo" class="header-anchor">#</a></h2><p>一般默认情况下，虚拟机是通过NAT共享网络给虚拟机用的，那么此时虚拟机也是可以上网的，只是不能和外界开发板进行互相ping, 同时windows主机也不能ping虚拟机。 如下图：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/7.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/8.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/9.png"><br>图中可以看到两块网卡，enp0s3是Ubuntu默认的网卡（NAT），enp0s8是新增的网卡(host only)，可以看到enp0s8还没有分配IP地址，我们需要手工指定一下。sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces将文件内容修改为如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.101</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure><p>再来看下网卡ip信息：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/10.png"></p><h1><span id="3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</span><a href="#3-ce-shi-shang-wang-zhuang-tai" class="header-anchor">#</a></h1><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/11.png"><br>从测试结果上可以看到虚拟机上外网和ping windows主机都是ok的。</p><pre><code>  10.80.0.75时无线网卡的ip，  192.168.56.100是以太网卡的ip,  192.168.56.101是host only网卡的ip。 </code></pre><p>同理用Windows ping虚拟机也是ok的。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/12.png"></p><p>用开发板ping主机和虚拟机发现，只能ping通windows主机，无法ping通虚拟机，如下图。这是为什么呢？<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/13.png"></p><p>这是由于我们windows主机和开发板用的网线直连，两个以太网卡在同一网段下，当然能够ping通。但是虚拟机和windows主机用的确是host only网卡（NAT方式用来上外网），这样只能保证虚拟机和Windows主机是互通的，但是却无法被开发板访问，我们的开发板是没有无线网卡的，所以不能用WLAN，因此我们要想让开发板访问到虚拟机还得经过windows的以太网卡。</p><p>那么我们虚拟机和windows主机是host only方式，所以我们无法用到以太网卡进行虚拟机和windows主机的交互。所以我们可以采取将host only网卡桥接到以太网卡，进入 网络-更改适配器-同时选中host only网卡和以太网卡，点击右键-选择桥接，如下图所示：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/14.png"></p><p>这样我们的虚拟机的host only网卡就可以透过以太网卡和开发板交互了，效果如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/15.png"><br>开发板能够ping windows主机和虚拟机。</p><h1><span id="4-gai-jin-he-you-hua">4 改进和优化</span><a href="#4-gai-jin-he-you-hua" class="header-anchor">#</a></h1><p>如果不想在windows下进行host only网卡和以太网卡桥接，也可直接把virtualbox的第2路网卡由原来的host only修改成以太网卡桥接模式，如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/16.png"></p><p>这样需要配置虚拟机的enp0s8网卡和windows主机的以太网卡网段保持一致的。（和前面2.2操作一样）</p><h2><span id="4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</span><a href="#4-1-windows-ping-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/17.png"></p><h2><span id="4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</span><a href="#4-2-xu-ni-ji-ping-windows" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/18.png"></p><h2><span id="4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</span><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/19.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-she-zhi-virtualbox-wang-qia&quot;&gt;1 设置virtualbox网卡&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-guan-bi-xu-ni-</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>vmware双网卡_NAT_桥接</title>
    <link href="http://example.com/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/"/>
    <id>http://example.com/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/</id>
    <published>2024-03-29T14:03:51.000Z</published>
    <updated>2024-03-29T15:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</a></li><li><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</a><ul><li><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</a></li><li><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</a><ul><li><a href="#2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</a></li><li><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</a></li><li><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</a></li><li><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</a></li><li><a href="#2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</a></li></ul></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</span><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi" class="header-anchor">#</a></h1><p>vmware安装后默认就会用NAT方式和pc主机共享网络，虚拟机是通过pc主机的网卡数据转换进行上网的，只要windows主机有网，虚拟机就会对应有网络。<br>NAT模式在这里主要目的就是提供给虚拟机进行上网。<br>如果没有可以进行如下配置，打开虚拟机-&gt;编辑虚拟机设置-&gt;网络适配器,网络连接选择NAT模式如下图：</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/1.png" alt="img"></p> <span id="more"></span><p>启动进入虚拟机，console输入ifconfig</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/2.png" alt="img"></p><p> windows进入cmd,输入ipconfig</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/3.png" alt="img"></p><p> VMware Network Adapter VMnet8是虚拟机启用NAT模式后多出来的虚拟网卡，可以看到ip为192.168.70.1，和虚拟机的192.168.70.128同一网段。下图可以看到都可以ping通，且都能访问外网。</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/4.png" alt="img"></p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/5.png" alt="img"></p><p> windows搜索框输入vmnet,进入虚拟网络编辑器，可以看到虚拟网络信息，有这个VMnet8，模式为NAT</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/6.png" alt="img"></p><h1><span id="2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</span><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo" class="header-anchor">#</a></h1><h2><span id="2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</span><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia" class="header-anchor">#</a></h2><p>需要买一个usb网卡，连接板子和windows主机。双网卡配置参考如下视频： <a href="https://www.bilibili.com/video/BV1zV411U7H9?p=3">https://www.bilibili.com/video/BV1zV411U7H9?p=3</a></p><h2><span id="2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</span><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi" class="header-anchor">#</a></h2><h3><span id="2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</span><a href="#2-1-1-tian-jia-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>桥接网络使用实际的物理网卡进行数据交换，因此需要借助实际的物理网卡，可以是有线网卡，也可以是无线网卡。桥接的目的是为了让虚拟机和主机以及板子能够互相进行收据收发传送。打开虚拟机，配置如下：</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/7.png" alt="img"></p><h3><span id="2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</span><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>打开vmnet,进入虚拟网络编辑器,在这个里面要把桥接网卡选择成具体的网卡型号，不能设置为自动桥接。注意：这里根据你电脑主机接路由器的网卡，如果你用的无线网卡与路由器通信，那么就要桥接到无线网卡，如果是接网线到路由器，那就要用有线网卡。具体的网卡名字可以进入入网络共享中心-&gt;更改适配器选项或者进入设备管理器来确认清楚。</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/8.png" alt="img"></p><p>配置完桥接网卡后，需要配置桥接网卡对应到window主机&#x2F;虚拟机&#x2F;板子的ip.</p><h3><span id="2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</span><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip" class="header-anchor">#</a></h3><p>ifconfig查看，发现桥接的网卡在虚拟机中还没有分配ip.</p><p> <img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/9.png" alt="img"></p><p>进入ubuntu setting-&gt; network， 设置成和路由器同一网段即可。配置ens36 ip为192.168.2.100</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/10.png" alt="img"></p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/11.png" alt="img"></p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/12.png" alt="img"></p><h3><span id="2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</span><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip" class="header-anchor">#</a></h3><p>桥接网卡为intel Ethernet Connection I219-V ,ip 192.168.2.6</p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/13.png" alt="img"></p><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/14.png" alt="img"></p><h3><span id="2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</span><a href="#2-1-5-pei-zhi-kai-fa-ban-ip" class="header-anchor">#</a></h3><p><strong>三者互 ping 验证:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">windows ip: 192.168.2.6</span><br><span class="line">ubuntu ip:  192.168.2.100</span><br><span class="line">开发板 ip:   192.168.2.xxx</span><br></pre></td></tr></table></figure><p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/15.png" alt="img"></p>]]></content>
    
    
    <summary type="html">&lt;div class=&quot;tocStart&quot;&gt;&lt;/div&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-pei-zhi-xu-ni-ji-net-mo-shi&quot;&gt;1 配置虚拟机NET模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo&quot;&gt;2 配置虚拟机桥接网络&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-fang-fa-1-shi-yong-usb-wang-qia&quot;&gt;2.1 方法1：使用usb网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-fang-fa-2-shi-yong-lu-you-qi&quot;&gt;2.1 方法2：使用路由器&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-1-tian-jia-qiao-jie-wang-qia&quot;&gt;2.1.1 添加桥接网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-2-pei-zhi-qiao-jie-wang-qia&quot;&gt;2.1.2 配置桥接网卡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip&quot;&gt;2.1.3 配置虚拟机桥接网卡静态ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip&quot;&gt;2.1.4 配置windows主机桥接网卡ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-1-5-pei-zhi-kai-fa-ban-ip&quot;&gt;2.1.5 配置开发板IP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;

&lt;div class=&quot;tocEnd&quot;&gt;&lt;/div&gt;

&lt;h1 id=&quot;1-配置虚拟机NET模式&quot;&gt;&lt;a href=&quot;#1-配置虚拟机NET模式&quot; class=&quot;headerlink&quot; title=&quot;1 配置虚拟机NET模式&quot;&gt;&lt;/a&gt;1 配置虚拟机NET模式&lt;/h1&gt;&lt;p&gt;vmware安装后默认就会用NAT方式和pc主机共享网络，虚拟机是通过pc主机的网卡数据转换进行上网的，只要windows主机有网，虚拟机就会对应有网络。&lt;br&gt;NAT模式在这里主要目的就是提供给虚拟机进行上网。&lt;br&gt;如果没有可以进行如下配置，打开虚拟机-&amp;gt;编辑虚拟机设置-&amp;gt;网络适配器,网络连接选择NAT模式如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>gdb移植到arm开发板</title>
    <link href="http://example.com/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    <id>http://example.com/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/</id>
    <published>2024-03-28T13:59:59.000Z</published>
    <updated>2024-03-29T15:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-xia-zai-gdb">1.下载gdb</a></li><li><a href="#2-bian-yi-an-zhuang">2.编译安装</a><ul><li><a href="#2-1-she-zhi-gong-ju-lian">2.1 设置工具链</a></li><li><a href="#2-2-bian-yi-ncurses">2.2 编译ncurses</a></li><li><a href="#2-3-bian-yi-gdb">2.3 编译gdb</a></li></ul></li><li><a href="#3-yun-xing-ce-shi">3.运行测试</a></li></ul><!-- tocstop --></div><h1><span id="1-xia-zai-gdb">1.下载gdb</span><a href="#1-xia-zai-gdb" class="header-anchor">#</a></h1><p><a href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p><p><a href="http://ftp.gnu.org/gnu/ncurses/">http://ftp.gnu.org/gnu/ncurses/</a></p><p>我这里选择的是gdb-7.12.tar.gz和ncurses-5.6.tar.gz</p><h1><span id="2-bian-yi-an-zhuang">2.编译安装</span><a href="#2-bian-yi-an-zhuang" class="header-anchor">#</a></h1><h2><span id="2-1-she-zhi-gong-ju-lian">2.1 设置工具链</span><a href="#2-1-she-zhi-gong-ju-lian" class="header-anchor">#</a></h2><p><code>export PATH=$PATH:/home/robin/share/cv183x/host-tools/gcc/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/</code><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/1.png"><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/2.png"></p><h2><span id="2-2-bian-yi-ncurses">2.2 编译ncurses</span><a href="#2-2-bian-yi-ncurses" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --host=aarch64-linux-gnu-gcc --prefix=/home/robin/share/ncurses --without-ada --enable-termcap --with-shared CFLAGS=<span class="string">&quot;-O3 -fPIC&quot;</span></span><br><span class="line">    make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>执行.&#x2F;configure时可能会失败，报错如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/3.png"><br>这是由于64bit machine配置引起的，进行如下操作后继续尝试。</p><pre><code>wget -O config.guess &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD&#39;wget -O config.sub &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD&#39;</code></pre><p>编译出的ncurses库如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/4.png"></p><h2><span id="2-3-bian-yi-gdb">2.3 编译gdb</span><a href="#2-3-bian-yi-gdb" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvf gdb-7.12.tar.gz;</span><br><span class="line"><span class="built_in">cd</span> gdb-7.12</span><br><span class="line">./configure --host=aarch64-linux-gnu-gcc(--host=arm-linux-gnueabihf) --enable-shared --prefix=/home/robin/share/gdb --without-x --disable-gdbtk --disable-tui --without-included-regex --without-included-gettext  --disable-werror CFLAGS=<span class="string">&quot;-O0 -fPIC&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>.&#x2F;configure后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/5.png"></p><p>make install后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/6.png"></p><h1><span id="3-yun-xing-ce-shi">3.运行测试</span><a href="#3-yun-xing-ce-shi" class="header-anchor">#</a></h1><p>1.将gdb和ncureses库cp到板子运行，结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-xia-zai-gdb&quot;&gt;1.下载gdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-bian-yi-an-zhuang&quot;&gt;2.编译安装&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>linux搭建samba服务</title>
    <link href="http://example.com/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-03-27T15:17:30.000Z</published>
    <updated>2024-03-29T15:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-an-zhuang-fu-wu">1 安装服务</a></li><li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li><li><a href="#3-tian-jia-yong-hu-book">3 添加用户book</a></li><li><a href="#4-chong-qi-fu-wu">4 重启服务</a></li><li><a href="#5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</a></li><li><a href="#6-chang-jian-wen-ti">6 常见问题</a></li></ul><!-- tocstop --></div><h1><span id="1-an-zhuang-fu-wu">1 安装服务</span><a href="#1-an-zhuang-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install samba samba-common</code></p><h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo systemctl stop ufw</code></p><h1><span id="3-tian-jia-yong-hu-book">3 添加用户book</span><a href="#3-tian-jia-yong-hu-book" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a book</span><br><span class="line">配置samba</span><br><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">[book_share_samba_dir]</span><br><span class="line">        comment = share samba <span class="built_in">dir</span></span><br><span class="line">        path = /home/book/ftp</span><br><span class="line">        valid <span class="built_in">users</span> = book</span><br><span class="line">        force user = book</span><br><span class="line">        force group = book</span><br><span class="line">        creat mask = 0644</span><br><span class="line">        directory mask = 0755</span><br><span class="line">        browseable= <span class="built_in">yes</span></span><br><span class="line">        available = <span class="built_in">yes</span></span><br><span class="line">        public = <span class="built_in">yes</span></span><br><span class="line">        <span class="built_in">read</span> only = no</span><br><span class="line">        writeable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><h1><span id="4-chong-qi-fu-wu">4 重启服务</span><a href="#4-chong-qi-fu-wu" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~$ sudo service smbd restart</span><br><span class="line">~$ sudo /etc/init.d/smbd restart</span><br><span class="line">~$ /etc/init.d/smbd restart</span><br></pre></td></tr></table></figure><h1><span id="5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</span><a href="#5-windows-jin-xing-samba-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/1.png" alt="img"></p><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/2.png" alt="img"></p><p>注意不能用NAT虚拟网络IP访问samba, 要用桥接网络ip，不过ssh可以两种方式访问，但是NAT虚拟网络是用来虚拟机上网的IP地址可能会发生变化，还是建议用桥接网络IP地址。</p><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/3.png" alt="img"></p><h1><span id="6-chang-jian-wen-ti">6 常见问题</span><a href="#6-chang-jian-wen-ti" class="header-anchor">#</a></h1><p>samba不允许一个用户使用一个以上用户名与一个服务器或共享资源的多重连接，因此需要windows进入cmd</p><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/4.png" alt="img"></p><p>可以windows cmd下用 net use 命令查看下当前的共享访问到底有没有它。</p><p>有的话，net use * &#x2F;del &#x2F;y</p><p>重新映射网络驱动器即可</p><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/5.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-an-zhuang-fu-wu&quot;&gt;1 安装服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-guan-bi-fang-huo-qiang&quot;&gt;2 关闭防火墙&lt;/a&gt;&lt;/</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>linux搭建nfs服务</title>
    <link href="http://example.com/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-03-26T15:32:15.000Z</published>
    <updated>2024-03-29T15:27:12.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</a></li><li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li><li><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</a></li><li><a href="#4-pei-zhi-nfs">4 配置NFS</a></li><li><a href="#5-qi-dong-nfs-fu-wu">5 启动NFS服务</a></li><li><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</a></li></ul><!-- tocstop --></div><h1><span id="1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</span><a href="#1-xia-zai-an-zhuang-nfs-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install nfs-kernel-server nfs-common</code></p><h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo ufw disable</code></p><h1><span id="3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</span><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> book:book /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /home/book/nfs_share -R</span><br></pre></td></tr></table></figure><h1><span id="4-pei-zhi-nfs">4 配置NFS</span><a href="#4-pei-zhi-nfs" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br><span class="line">/home/book/nfs_share *(rw,<span class="built_in">sync</span>,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure><p><img src="/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p><h1><span id="5-qi-dong-nfs-fu-wu">5 启动NFS服务</span><a href="#5-qi-dong-nfs-fu-wu" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-serve</span><br><span class="line">或者sudo service nfs-kernel-server restart</span><br><span class="line">或者sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure><h1><span id="6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</span><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai" class="header-anchor">#</a></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">运行开发板</span><br><span class="line"><span class="meta prompt_">[root@book]~# </span><span class="language-bash">mount -t nfs -o nolock -o tcp 192.168.2.100:/home/book/nfs_share /mnt/nfs</span></span><br><span class="line">-t nfs                          #挂载类型</span><br><span class="line">-o nolock                       #读写的时候不锁定</span><br><span class="line">-o tcp                          #tcp模式</span><br><span class="line">客户端退出NFS挂载</span><br><span class="line">umount /mnt/nfs</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-xia-zai-an-zhuang-nfs-fu-wu&quot;&gt;1 下载安装NFS服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-guan-bi-fang-huo-qia</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2024/03/25/hello-world/"/>
    <id>http://example.com/2024/03/25/hello-world/</id>
    <published>2024-03-25T07:16:51.270Z</published>
    <updated>2024-03-24T13:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor">#</a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux搭建tftp和ftp服务</title>
    <link href="http://example.com/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-03-24T14:24:38.000Z</published>
    <updated>2024-03-30T06:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul><li><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</a><ul><li><a href="#1-1-pei-zhi">1.1 配置</a></li><li><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</a></li><li><a href="#1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</a><ul><li><a href="#1-3-1-ben-ji-ce-shi">1.3.1 本机测试</a></li><li><a href="#1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</a></li></ul></li></ul></li><li><a href="#2-ftp-fu-wu">2 ftp服务</a><ul><li><a href="#2-1-windows-ke-hu-duan">2.1 windows客户端</a></li></ul></li></ul><!-- tocstop --></div><h1><span id="1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</span><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan" class="header-anchor">#</a></h1><pre><code>sudo apt-get install xinetd tftp tftpd</code></pre><h2><span id="1-1-pei-zhi">1.1 配置</span><a href="#1-1-pei-zhi" class="header-anchor">#</a></h2><p>vim &#x2F;etc&#x2F;xinetd.d&#x2F;tftp<br>内容如下：</p><pre><code>service tftp&#123;        socket_type     = dgram        protocol                = udp        wait                    = yes        user                    = root        server          = /usr/sbin/in.tftpd        server_args     = -s /home/lyb/tftpshare/        disable         = no        per_source      =11        cps                     = 100 2        flags                   = IPv4&#125;</code></pre><h2><span id="1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</span><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu" class="header-anchor">#</a></h2><pre><code>1.创建服务器目录mkdir /home/lyb/tftpshare/2.然后修改目录权限chmod 777 /home/lyb/tftpshare/3.重启xinetd服务sudo /etc/init.d/xinetd restart（如果启动失败先关闭防火墙 service iptables stop）</code></pre><h2><span id="1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</span><a href="#1-3-ce-shi-yan-zheng-gong-neng" class="header-anchor">#</a></h2><h3><span id="1-3-1-ben-ji-ce-shi">1.3.1 本机测试</span><a href="#1-3-1-ben-ji-ce-shi" class="header-anchor">#</a></h3><pre><code>重新启动一个终端，输入命令 tftp 192.168.1.11（我的虚拟机ip）进入tftp,输入get test,这样就可以获取到test文件,输入q退出tftp</code></pre><p>如下图所示：<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p><h3><span id="1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</span><a href="#1-3-2-kai-fa-ban-ce-shi" class="header-anchor">#</a></h3><p>2440开发板的uboot可以支持tftp下载功能，在uboot命令行输入：</p><pre><code>tftp 0x30000000  uImage_4.3</code></pre><p>如下图所示。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/2.png" alt="2"></p><h1><span id="2-ftp-fu-wu">2 ftp服务</span><a href="#2-ftp-fu-wu" class="header-anchor">#</a></h1><pre><code>sudo apt install vsftpdvi /etc/vsftpd.conflocal_enable=YESwrite_enable=YESsudo /etc/init.d/vsftpd restart</code></pre><p><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/3.png" alt="3"></p><h2><span id="2-1-windows-ke-hu-duan">2.1 windows客户端</span><a href="#2-1-windows-ke-hu-duan" class="header-anchor">#</a></h2><p><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></p><p>新建站点，配置ftp协议, 主机输入ubuntu IP地址，用户密码信息，即可连接成功。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/4.png" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;toc&quot;&gt;

&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan&quot;&gt;1 安装tftp服务和客户端&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-1-pei-zhi&quot;&gt;</summary>
      
    
    
    
    
    <category term="linux嵌入式环境搭建" scheme="http://example.com/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
