<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-mmap驱动应用实例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T15:21:52.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">字符设备驱动-mmap驱动应用实例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</a></li>
<li><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</a></li>
<li><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</a><ul>
<li><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</a><ul>
<li><a href="#3-1-1-copy-on-write">3.1.1 copy on write</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</span><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing" class="header-anchor">#</a></h1><ol>
<li>确定物理地址</li>
<li>确定属性：是否使用 <code>cache、 buffer</code></li>
<li>建立映射关系</li>
</ol>
<p>参考 Linux 驱动源文件代码：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/2.png" alt="image"><br>我们要验证mmap功能，在驱动程序中申请一个 8K 的 buffer，让 APP 通过 mmap 能直接访问。</p>
<h1><span id="2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</span><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi" class="header-anchor">#</a></h1><p>linux内核中常用的内存申请方式：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>分配到的内存物理地址是连续的</td>
</tr>
<tr>
<td>kzalloc</td>
<td>分配到的内存物理地址是连续的，内容清 0</td>
</tr>
<tr>
<td>vmalloc</td>
<td>分配到的内存物理地址不保证是连续的</td>
</tr>
<tr>
<td>vzalloc</td>
<td>vzalloc 分配到的内存物理地址不保证是连续的，内容清 0</td>
</tr>
</tbody></table>
<p>我们在 mmap 时应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，mmap后 APP 才可以使用同一个基地址去访问这块内存。 (如果物理地址不连续，就要执行多次 mmap 了)</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/pgtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *kernel_buf;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsiz = <span class="number">1024</span>*<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_to_user(buf, kernel_buf, MIN(bufsiz, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(bufsiz, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获得物理地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line">	<span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">	vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">/* map */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;mmap remap_pfn_range failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = hello_drv_open,</span><br><span class="line">	.read    = hello_drv_read,</span><br><span class="line">	.write   = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line">	.mmap    = hello_drv_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	kernel_buf = kmalloc(bufsiz, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">strcpy</span>(kernel_buf, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">	hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">	err = PTR_ERR(hello_class);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(hello_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	kfree(kernel_buf);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>分析：init时，驱动使用kmalloc分配8K空间(物理地址连续), 初始化为<code>”old“</code>字符串。实现read，write函数。mmap函数中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得物理地址 */</span></span><br><span class="line">unsigned <span class="built_in">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line"><span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">/*映射*/</span></span><br><span class="line">remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT, vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/3.png" alt="image"></p>
<p><code>pgprot_writecombine</code>设置属性为<code>Non-cached buffered (NCB)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;asm/pgtable.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_noncached(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRnE) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_writecombine(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_NORMAL_NC) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_device(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRE) | PTE_PXN | PTE_UXN)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/4.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/5.png" alt="image"></p>
<p>注意：<code>remap_pfn_range</code> 中，<code>pfn </code>的意思是<code>“ Page Frame Number”</code>。在 Linux 中，整个物理地址空间可以分为第 0 页、第 1 页、第 2 页，诸如此类，这就是 pfn。假设每页大小是 4K，那么给定物理地址<code> phy</code>，它的<code> pfn = phy / 4096 = phy &gt;&gt; 12</code>。内核的 page 一般是 4K，但是也可以配置内核修改 page的大小。所以为了通用， <code>pfn = phy &gt;&gt; PAGE_SHIFT</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们的buf不是用<code>kmalloc</code>, 而是<code>vmalloc</code>，那么需要映射多次，每次映射一个<code>page 4k</code>.(MMU过程中内存以page为单位作为连续内存单元)<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/6.png" alt="image"></p>
<h1><span id="3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</span><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi" class="header-anchor">#</a></h1><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/* 1. 打开文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. mmap </span></span><br><span class="line"><span class="comment">	 * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment">	 *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment">	 * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment">	 *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment">	 *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment">	 *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buf =  mmap(<span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (buf == MAP_FAILED)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not mmap file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mmap address = 0x%x\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;buf origin data = %s\n&quot;</span>, buf); <span class="comment">/* old */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. write */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. read &amp; compare */</span></span><br><span class="line">	<span class="comment">/* 对于MAP_SHARED映射:  str = &quot;new&quot; </span></span><br><span class="line"><span class="comment">	 * 对于MAP_PRIVATE映射: str = &quot;old&quot; </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	read(fd, str, <span class="number">1024</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, str) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_SHARED映射，APP写的数据驱动可见</span></span><br><span class="line"><span class="comment">		 * APP和驱动访问的是同一个内存块</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare ok!\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_PRIVATE映射，APP写数据时, 是写入原来内存块的&quot;拷贝&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str = %s!\n&quot;</span>, str);  <span class="comment">/* old */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf = %s!\n&quot;</span>, buf);  <span class="comment">/* new */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);  <span class="comment">/* cat /proc/pid/maps */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	munmap(buf, <span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</span><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment"> *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment"> *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment"> *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment"> *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-copy-on-write">3.1.1 copy on write</span><a href="#3-1-1-copy-on-write" class="header-anchor">#</a></h3><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/7.png" alt="image"></p>
<pre><code>① mmap时使用MAP_PRIVATE
②③ 当写入mmap内存时，会copy这块内存
④写入新数据，会将数据写入新copy的内存
⑤读数据还是从旧的那块映射内存去读，因此这时会与buf中的数据不一样
</code></pre>
<p>根据上面的mmap应用示例来分析和验证<code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>的差异：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/8.png" alt="image"><br>先用<code>MAP_PRIVATE</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/9.png" alt="image"><br>再用<code>MAP_SHARED</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/10.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" data-id="clzww9otk0001nguf8pethpld" data-title="字符设备驱动-mmap驱动应用实例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-mmap机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T13:58:58.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/">字符设备驱动-mmap机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-mmap">1 引入mmap</a><ul>
<li><a href="#1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</a><ul>
<li><a href="#1-1-1-yin-ru-mmu">1.1.1 引入MMU</a></li>
<li><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</a><ul>
<li><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</a><ul>
<li><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ye-biao-ying-she">3 页表映射</a><ul>
<li><a href="#3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</a></li>
<li><a href="#3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</a></li>
</ul>
</li>
<li><a href="#4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</a><ul>
<li><a href="#4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</a></li>
<li><a href="#4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</a><ul>
<li><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</a><ul>
<li><a href="#4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-mmap">1  引入mmap</span><a href="#1-yin-ru-mmap" class="header-anchor">#</a></h1><p>应用程序和驱动程序之间传递数据时，可以通过 read、write 函数进行, 用户态和内核态的数据交互一般用<code>copy_from_user</code>,<code>copy_to_user</code>。这种方式在数据量比较小时没什么问题；但是数据量比较大时效率就太低了。比如更新 LCD 显示时，如果每次都让 APP 传递一帧数据给内核，假设 LCD 采用<code>1024x600x32 bpp </code>的格式，一帧数据就有<code>1024x600x32/8=2.3MB</code> 左右,而且一般为了显示动态画面，LDC输出fps要求是<code>60fps or 30 fps</code>，那么一秒数据量为<code>30x2.3 = 70M</code>左右，显然<code>copy_from_user</code>，<code>copy_to_user</code>的方式不再适合。<br>改进的方法就是让程序可以直接读写驱动程序中的 buffer，这可以通过mmap 实现(memory map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h2><span id="1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</span><a href="#1-1-nei-cun-ying-she-xian-xiang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, &amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PC 上如下编译(必须静态编译)：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -staitc</span><br></pre></td></tr></table></figure>
<p>分别后台执行 test 程序 2 次。最后执行 ps，可以看到这 2 个程序同时存在，这 2 个程序里 a 变量的地址相同，但是值不同。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 个程序同时运行，它们的变量a的地址都是一样的：0x6bc3a0；</span><br><span class="line">2 个程序同时运行，它们的变量a的值是不一样的，一个是 111，另一个是 123。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-yin-ru-mmu">1.1.1 引入MMU</span><a href="#1-1-1-yin-ru-mmu" class="header-anchor">#</a></h3><p>来分析一下：<br>2个程序同时在内存中运行，它们的值不一样，所以变量 a 的物理内存地址肯定不同（2个变量存放不是同一个地方）；<br>但是打印出来的变量 a 的地址却是一样的。怎么回事？<br>这里要引入<strong>虚拟地址</strong>的概念：CPU 发出的地址是虚拟地址，它经过<code>MMU(Memory Manage Unit，内存管理单元)</code>映射到物理地址上，对于不同进程的同一个虚拟地址，MMU 会把它们映射到不同的物理地址。<br>总结:虽然虚拟地址一样，但物理地址不一样，这个是mmu的功劳，将同一虚拟地址映射到不同物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前运行的是 app1 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr1，用 paddr1 去访问内存。</span><br><span class="line">当前运行的是 app2 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr2，用 paddr2 去访问内存。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</span><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian" class="header-anchor">#</a></h3><p>MMU 负责把虚拟地址映射为物理地址，虚拟地址映射到哪个物理地址去？可以执行<code>ps</code>命令查看进程 ID，然后执行<code>“cat /proc/[PID]/maps”</code>得到虚拟地址空间映射关系。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00400000</span><span class="number">-004b</span>6000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>6000<span class="number">-006b</span>c000 rw-p <span class="number">000b</span>6000 <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>c000<span class="number">-006b</span>d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">021</span>c8000<span class="number">-021</span>eb000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</span><br><span class="line"><span class="number">7f</span>fe18738000<span class="number">-7f</span>fe18759000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fe187f9000<span class="number">-7f</span>fe187fc000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</span><br><span class="line"><span class="number">7f</span>fe187fc000<span class="number">-7f</span>fe187fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>第一行地址范围显示权限为可读可执行，表示该程序<code>代码段（.text）</code><br>第二行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code><br>第三行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code>刚才变量a地址就在这段地址范围内<br>第四行地址范围是<code>堆空间（.heap段）</code>,malloc的内存就会处于这段<br>第5行地址范围是<code>栈空间（.stack段）</code>,局部变量处于这段<br>p表示<code>private</code>, s表示<code>share</code>, 再来看一个使用动态库的进程，比如bash进程：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</span><a href="#2-mmap-nei-he-tai-de-miao-shu" class="header-anchor">#</a></h1><h2><span id="2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</span><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct" class="header-anchor">#</a></h2><p>每一个 APP对应了很多虚拟地址空间，比如栈空间，堆空间，数据段，代码段等,也叫做进程地址空间<code>（mm_strcut）</code>。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<p>因此在内核里都有一个 tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每个 APP 在内核中都有一个 task_struct 结构体，它用来描述一个进程；</span><br><span class="line"><span class="number">2.</span> 每个 APP 都要占据内存，在 task_struct 中用 mm_struct 来管理进程占用的内存；</span><br><span class="line"><span class="number">3.</span> 内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，</span><br><span class="line">用 pgd 来描述对应的物理地址。(注意：pgd，Page Global Directory，页目录)</span><br><span class="line"><span class="number">4.</span> 每个 APP 都有一系列的 VMA：virtual memory，即mmap会指向vm_area_struct, </span><br><span class="line">比如 APP 含有代码段、数据段、BSS 段、栈等等，还有共享库。这些单元会保存在内存里，</span><br><span class="line">它们的地址空间不同，权限不同(代码段是只读的可运行的、数据段可读可写)，内核用一系列的 vm_area_struct 来描述它们。</span><br><span class="line"><span class="number">6.</span> vm_area_struct 中的 vm_start、vm_end 是虚拟地址。</span><br><span class="line"><span class="number">7.</span> vm_area_struct 中虚拟地址如何映射到物理地址去？ 每一个 APP 的虚拟地址可能相同，</span><br><span class="line">物理地址不相同，这些对应关系保存在 pgd 中。</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</span><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu" class="header-anchor">#</a></h3><p>每个进程有一个<code>task_struct</code>和一个<code>mm_struct</code>, 其中<code>mm_struct</code>中的mmap对应<code>vm_area_struct</code>虚拟内存区域：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png" alt="image-20240816222839173"></p>
<p>可以看到<code>mm_struct</code>每一段都对应一块<code>vm_area_struct</code>。</p>
<h1><span id="3-ye-biao-ying-she">3 页表映射</span><a href="#3-ye-biao-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<p>页表是存在<code>ddr</code>中的一段连续地址空间，页表里面存放了要映射的物理地址集合，页表分为很多个页表项。<br>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址可以找到第 1 个页表，从第 1 个页表里就可以知道这个虚拟地址对应的物理地址。一级页表里地址映射的最小单位是 1M。<br>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2 级页表在哪里；再取出第 2 级页表，从第 2 个页表里才能确定这个虚拟地址对应的物理地址。二级页表地址映射的最小单位有 4K、1K，Linux 使用 4K。<br><strong>一级页表项里的内容，决定了它是指向一块物理内存，还是指问二级页表</strong>，一个页表项格式如下图：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png" alt="image"></p>
<h2><span id="3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</span><a href="#3-1-yi-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>arm32系统中，一个页表项占4个byte, 32bit,它分为一级页表项和二级页表项，通过<code>bit[1:0]</code>区分，一级页表项保存有物理地址，用<code>bit[31:20]</code> 共12位表示段基地址，有1M物理内存。比如cpu发出虚拟地址<code>0x12345678</code>, MMU通过<code>bit[31:20]</code>发现为0x123,也就是从第0x123个页表项中找到<code>Section Base Address</code>, 比如第0个页表项中物理及地址为<code>0x8000,0000</code>， 那么第0x123个页表项目物理基地址就是<code>0x123 * 1M + 0x8000,0000</code>,也就是<code>0x9230,0000</code>, 因为每一个一级页表项物理内存大小为1M.<br>段内偏移是 <code>0x45678</code>，那么最终通过一级页表映射最终映射到物理地址就为<code>0x0x9230,0000 + 0x45678</code>,也就是<code>0x9234,5678</code>。<br><code>Section Base Address</code>的数量为多少呢？一共12bit，也就是4096个，每一个1级页表项大小为1M, 因此总共可表示4G。对于 32 位的系统，虚拟地址空间有 4G，<code>4G/1M=4096</code>。所以一级页表要映射整个 4G 空间的话，刚好需要 4096 个页表项。<br>所以 CPU 要访问虚拟地址 0x12345678 时，实际上访问的是 0x81045678 的物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png" alt="image"></p>
<h2><span id="3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</span><a href="#3-2-er-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>一级页表项每项有1M空间, 一级页表映射时是吧虚拟地址的1M映射到物理地址的1M连续空间，但有时我们的程序没有那么大，显然用1M太浪费空间。 那么引入二级页表映射来映射更小的块，对于二级页表，每一个页可以是1K, 4K，64K， Linux系统一般使用4K, 对应<code>Small Page</code>, 64K对应的是大页（<code>Large Page</code>）, 1K对应的是Tine Page(一般很少用)。<br><strong>二级页表映射过程：</strong><br>首先设置好一级页表、二级页表，并且把一级页表的首地址告诉 MMU,比如<code>0x8000,0000</code>。<br>二级页表首先也是要经过一级页表映射，用<code>bit[31:20] </code>共12位表示段基地址，找到对应的一级页表项比如<code>0x123</code>项，通过这一项里面的<code>bit[1:0]</code>发现它是一个二级页表项（注意不再是取出1M的物理地址），然后根据二级页表项的<code>bit[19：12]</code>这8位得到二级页表是得到索引0x45,表示为第0x45个二级页表项。从这个二级页表项中取出里面的物理地址，比如为addr。<br>二级页表格式如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png" alt="image"></p>
<p>可以看到里面含有<code>64k(Large Page) 4k(Small Page）</code>或 <code>1K(Tine) </code>物理空间的基地址<code> page base addr</code>，假设从第0x45个二级页表项取出的物理地址为<code>0x8188,9000</code>。然后<code>offset=0x678</code>, 那么它跟 <code>vaddr[11:0] </code>组 合 得 到 物 理 地 址 ：<code> 0x8188,9000 + 0x678 = 0x8188,9678</code>，所以 CPU 要访问虚拟地址 <code>0x1234,5678 </code>时，实际上访问的是<code>0x8188,9678</code>的物理地址, 根据<code>bit[1:0]</code>得到映射的大小为<code>4K(linux Small Page)</code>。假如这里不使用二级页表映射，理论去计算对应物理地址则会是<code>0x8180,0000</code>往后1M内存，显然浪费了。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png" alt="image"></p>
<h1><span id="4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</span><a href="#4-mmap-han-shu-diao-yong-guo-cheng" class="header-anchor">#</a></h1><p>从上面内存映射的过程可以知道，要给 APP 新开劈一块虚拟内存，并且让它指向某块内核buffer，我们要做这些事：</p>
<ol>
<li>得到一个 <code>vm_area_struct</code>，它表示 APP 的一块虚拟内存空间：<br> 很 幸 运 ， APP 调 用 mmap 系 统 函 数 时 ， 内 核 就 帮 我 们 构 造 了 一 个<code>vm_area_stuct </code>结构体。里面含有虚拟地址的地址范围、权限，属性。</li>
<li>确定物理地址：<br> 你想映射某个内核 buffer，你需要得到它的物理地址，这得由你提供。</li>
<li>给<code>vm_area_struct</code>和物理地址建立映射关系</li>
</ol>
<p>比如APP 里调用 mmap 时，导致的内核相关函数调用过程如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>可以传入一个addr虚拟地址，需要用户自己malloc。也可以将addr设置为NULL, 让linux内核帮你产生一段内存映射，返回虚拟地址给你。<br>内核得到可用的虚拟地址后会分配一个<code>vm_area_struct</code>, 用来描述一块虚拟地址空间，里面有这块虚拟地址空间的起始地址、结束地址、权限信息。最后会调用驱动里面的mmap函数，参数为刚刚分配的<code>vm_area_sruct</code>。<br>那么需要再驱动程序实现mmap函数，主要包括：</p>
<ol>
<li>提供物理地址</li>
<li>设置属性，<code>cache，buffer</code></li>
<li>给<code>vm_area_stuct</code>和物理地址建立映射</li>
</ol>
<h2><span id="4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</span><a href="#4-1-vm-area-struct-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct describes a virtual memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task. A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">	 * See vmf_insert_mixed_prot() for discussion.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br></pre></td></tr></table></figure>

<p>它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是<code>0~3G</code>，对应的物理页面都可以是不连续的.<br>主要成员有起始地址、结束地址、权限信息，属性信息。<br><code>vm_flags:</code>可读，可写，可执行权限，私有，共享等权限</p>
<p>常用<strong>vm_flags</strong>访问权限的取值说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VM_READ：可读</span><br><span class="line">VM_WRITE：可写</span><br><span class="line">VM_EXEC：可执行</span><br><span class="line">VM_SHARD：可多进程之间共享</span><br><span class="line">VM_IO：可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED：内存区域不可被换出</span><br><span class="line">VM_SEQ_READ：内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ：内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<p><code>vm_pgoff:</code>是否使用cache? 是否使用buffer？</p>
<h2><span id="4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</span><a href="#4-2-yin-ru-cache-he-buffer" class="header-anchor">#</a></h2><p>使用<code> mmap</code> 时，需要有<code>cache、 buffer</code>的知识。下图是 CPU 和内存之间的关系，有<code> cache、 buffer</code>(写缓冲器)。 Cache 是一块高速内存；写缓冲器相当于一个 FIFO，可以把多个写操作集合起来一次写入内存。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png" alt="image"></p>
<h3><span id="4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</span><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing" class="header-anchor">#</a></h3><p>当程序运行时有<code>“局部性原理”</code>，这又分为<strong>时间局部性、空间局部性</strong>。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间局部性：</strong><br>a++在很短的时间内被重复写了100次，与此同时i也被访问了100次，像这种在某个时间点访问了存储器的特定位置，反复地访问这个位置被称为<code>“时间局部性”</code>。<br><strong>空间局部性：</strong><br>访问变量a的同时也访问了它周围临近变量i, 像这种访问了存储器的特定位置，很可能在不久的将来访问它附近的位置被称作<code>”空间局部性“</code>， 那么为什么不用<code>buffer or cache</code>把它一次性访问完呢？<br>根据<code>“局部性原理”</code>，引入 <code>cache</code>和<code>buffer</code>。</p>
<h4><span id="4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</span><a href="#4-2-1-1-cache-miss-he-cache-hit" class="header-anchor">#</a></h4><p>读数据：</p>
<ol>
<li>要读取内存指定addr处的数据时，先看看cache中有没有addr的数据，如果有则直接从cache返回数据，这一过程叫做<code>cache命中(cache hit)</code>。</li>
<li>假如cache中没有该addr的数据，触发<code>cache缺失 (cache miss)</code>, 那么会从addr读一段连续数据进去，注意：它不是仅仅读入一个数据，而是读入一行数据(cache line)。</li>
<li>那么CPU 短时间内很可能会再次用到甚至多次用到这个 addr 的数据或者周围临近的数据，那么就可以直接从cache快速的获取数据。这样<strong>弥补了时间和空间上的”局部性“</strong>。</li>
</ol>
<p>写数据：</p>
<ol>
<li>CPU 写数据时，可以<strong>直接写内存</strong>，这很慢；也可以先把数据<strong>写入 cache</strong>，这很快。</li>
<li>cache 中的数据终究是要写入内存的啊，这有 2 种写策略:<br> <strong>2.1 写通(write through)：</strong><br> ◆ 数据要同时写入 cache 和内存，所以 cache 和内存中的数据保持一致，但是它的效率很低。能改进吗？可以！使用“<strong>写缓冲器</strong>”：cache 大哥，你把数据给我就可以了，我来慢慢写，保证帮你写完。<br> ◆ 有些写缓冲器有“<strong>写合并</strong>”的功能，比如 CPU 执行了 4 条写指令：写第 0、 1、 2、 3 个字节，每次写 1 字节；写缓冲器会把这 4 个写操作合并成一个写操作：写 word。对于内存来说，这没什么差别，但是对于硬件寄存器，这就有可能导致问题。<br> ◆ 所以对于寄存器操作，不会启动 buffer 功能；对于内存操作，比如 LCD 的显存，可以启用 buffer 功能(cpu直接用<code>write buffer</code>进行操作<code>frame buffer内存</code>)<br> <strong>2.2 写回(write back)：</strong><br> ◆ 新数据只是写入<code> cache</code>，不会立刻写入内存， <code>cache </code>和内存中的数据并不一致。<br> ◆ 新数据写入 cache 时，这一行 cache 被标为<code>“脏” (dirty)</code>；当cache 不够用时，才需要把脏的数据写入内存。</li>
</ol>
<p>对内存或者变量进行写操作可以使用写回功能，可以大幅提高效率。但是要注意 cache 和内存中的数据很可能不一致。这在很多时间要小心处理：比如 CPU 产生了新数据， DMA 把数据从内存搬到网卡，这时候就要 CPU 执行命令先把新数据从 cache 刷到内存。反过来也是一样的， DMA 从网卡得过了新数据存在内存里， CPU 读数据之前先把 cache中的数据丢弃。下图举例说明哪些硬件可以用或者不能用cache：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png" alt="image"></p>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合(位于<code>arch\arm\include\asm\pgtable-2level.h</code>：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png" alt="image"></p>
<p>以s3c2440芯片为例，上面 4 种组合对应下表中的各项：</p>
<table>
<thead>
<tr>
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件；写操作通过 buffer 实现， CPU 不等待操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><code>Cached, write-through mode (WT)</code>，写通    ①读：<code>cache hit</code>时从 cahce 读数据； <code>cache miss </code>时已入一行数据到 cache；②写：通过 buffer 实现， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><code>Cached, write-back mode (WB)</code>，写回    ①读：<code> cache hit</code> 时从 cahce 读数据；<code>cache miss</code>时已入一行数据到 cache；②写：通过 buffer 实现， <code>cache hit</code> 时新数据不会到达硬件，而是在 cahce 中被标为 “脏”； <code>cache miss</code> 时，通过 buffer写入硬件， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
</tbody></table>
<p>◼ 第 1 种是不使用 cache 也不使用 buffer，读写时都直达硬件，这适合寄存器的读写。<br>◼ 第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer 进行优化，可能会有<code>“写合并”</code>，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。<br>◼ 第 3 种是使用 cache 不使用 buffer，就是<code>“ write through”</code>，适用于只读设备：在读数据时用 cache 加速，基本不需要写。<br>◼ 第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" data-id="clzww9otj0000ngufh5fqcv44" data-title="字符设备驱动-mmap机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断线程化-threaded_irq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/" class="article-date">
  <time class="dt-published" datetime="2024-08-11T07:24:53.000Z" itemprop="datePublished">2024-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/">字符设备驱动-9-中断子系统-中断线程化-threaded_irq</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-threaded-irq-yin-ru">1 threaded_irq引入</a></li>
<li><a href="#2-threaded-irq-shi-yong">2 threaded_irq使用</a></li>
<li><a href="#3-threaded-irq-shi-li">3 threaded_irq实例</a><ul>
<li><a href="#3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</a></li>
<li><a href="#3-2-app-dai-ma-bian-xie">3.2 app代码编写</a></li>
<li><a href="#3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</a></li>
</ul>
</li>
<li><a href="#4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</a><ul>
<li><a href="#4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</a><ul>
<li><a href="#4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></a><ul>
<li><a href="#4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</a><ul>
<li><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</a></li>
<li><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</a><ul>
<li><a href="#4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</a></li>
<li><a href="#4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-threaded-irq-yin-ru">1 threaded_irq引入</span><a href="#1-threaded-irq-yin-ru" class="header-anchor">#</a></h1><p>工作队列用起来挺简单，但是它有一个缺点：工作队列中有多个 work，前一个 work 没处理完会影响后面的 work执行，导致后面的work没法快速响应。那么可以再内核自己创建一个线程来单独处理，不跟别的 work 凑在一块了。比如在 Linux 系统中，对于存储设备比如 SD&#x2F;TF 卡，它的驱动程序就是这样做的，它有自己的内核线程。用<code>kthread_creat</code>创建内核线程。<br>对于中断处理，还有另一种方法：<code>threaded irq</code>，线程化的中断处理。中断的处理仍然可以认为分为上半部、下半部。上半部用来处理紧急的事情，下半部用一个内核线程来处理，这个内核线程专用于这个中断。</p>
<h1><span id="2-threaded-irq-shi-yong">2 threaded_irq使用</span><a href="#2-threaded-irq-shi-yong" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html" title="1异常中断引入">1异常中断引入</a> </p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a>前面已经提到了<code>threaded_irq</code>。</p>
<ol>
<li>你可以只提供 <code>thread_fn</code>，内核会提供默认的上半部处理函数<code>irq_default_primary_handler</code>,该函数只是返回一个<strong>IRQ_WAKE_THREAD</strong>。发生中断时，系统会立刻调用 handler 函数，然后唤醒某个内核线程，内核线程再来执行<code>thread_fn</code> 函数。</li>
<li>你也可以既提供<code>handler</code>函数，也提供<code>thread_fn</code>函数。等硬件中断到来，先执行<code>handler</code>函数，handler函数中返回<strong>IRQ_WAKE_THREAD</strong>去唤醒中断线程函数<code>thread_fn</code>。</li>
</ol>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/1.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_threaded_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">			  <span class="type">irq_handler_t</span> handler, <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"><span class="comment">//include\linux\interrupt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> devm_request_threaded_irq(dev, irq, handler, <span class="literal">NULL</span>, irqflags,</span><br><span class="line">					 devname, dev_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		     <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-threaded-irq-shi-li">3 threaded_irq实例</span><a href="#3-threaded-irq-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</span><a href="#3-1-qu-dong-yuan-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line">		</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>,</span><br><span class="line">               __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>,</span><br><span class="line">                   __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">//err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span></span><br><span class="line">        <span class="comment">//, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span></span><br><span class="line">        <span class="comment">//, &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">        						   , gpio_key_thread_func,</span><br><span class="line">                                   IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                                   , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-2-app-dai-ma-bian-xie">3.2 app代码编写</span><a href="#3-2-app-dai-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>app代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</span><a href="#3-3-qu-dong-dai-ma-jie-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/2.png" alt="image"><br>为每个按键注册中断服务</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/3.png" alt="image"><br>硬件中断上半部irq中做完重要事情如：清中断，然后返回<strong>IRQ_WAKE_THREAD</strong></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/4.png" alt="image"><br>返回后，内核线程开始调度<code>gpio_key_thread_func</code>，中断线程化的处理函数<code>gpio_key_thread_func</code>做完后返回<code>IRQ_HANDLED</code>;</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/5.png" alt="image"><br>最后卸载驱动时取消irq注册.</p>
<h1><span id="4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</span><a href="#4-threaded-irq-nei-he-ji-zhi" class="header-anchor">#</a></h1><p>前面<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17532830.html" title="中断相关结构体">中断相关结构体</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/">字符设备驱动-9-中断子系统-中断结构体 | Hexo (fuzidage.github.io)</a>讲过<code>struct irq_desc</code>结构：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当发生中断时，handler函数被调用，如果返回IRQ_HANDLED,表示中断处理完毕，如果返回IRQ_WAKE_THREAD表示要唤醒thread_fn.</span><br><span class="line"><span class="number">2.</span> 内核线程唤醒后，执行thread_fn</span><br></pre></td></tr></table></figure>

<h2><span id="4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</span><a href="#4-1-request-threaded-irq-guo-cheng" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc = irq_to_desc(irq);  <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;   <span class="comment">//2</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chip_bus_lock(desc);</span><br><span class="line">	retval = __setup_irq(irq, desc, action); <span class="comment">//3</span></span><br><span class="line">	chip_bus_sync_unlock(desc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">		 * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">		 * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/7.png" alt="image"></p>
<ol>
<li><p>首先根据<code>irq num</code>获取到<code>struct irq_desc</code>信息。</p>
</li>
<li><p>然后分配、设置一个<code> irqaction</code> 结构体。设置中断相关参数</p>
</li>
<li><p>然后进入<code>__setup_irq</code>，<code>__setup_irq </code>函数核心代码如下：</p>
</li>
</ol>
<h3><span id="4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></span><a href="#4-1-1-setup-irq" class="header-anchor">#</a></h3><h4><span id="4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</span><a href="#4-1-1-1-setup-irq-thread" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line">	ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//setup_irq_thread函数核心代码如下：</span></span><br><span class="line"><span class="keyword">if</span> (!secondary) &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-s-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">	param.sched_priority -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">new-&gt;thread = t;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/9.png" alt="image"><br>①可以看到创建了<code>irq_thread</code>这个内核线程。线程名字为<code>“irq/pid-中断名字”</code>。</p>
<p><code>kthread_create()</code>只是创建一个内核线程，但并没有启动，需要调用<code>wake_up_process()</code>来启动线程，所以内核又帮我们定义了一个宏<code>kthread_run</code>来帮我们搞定. 来看kthread相关API:</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/10.png" alt="image-20240811233308139"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_create(threadfn, data, namefmt, arg...) \</span></span><br><span class="line"><span class="meta">	kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create_on_cpu</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">					  <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">int</span> cpu,</span></span><br><span class="line"><span class="params">					  <span class="type">const</span> <span class="type">char</span> *namefmt)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kthread_run - create and wake a thread.</span></span><br><span class="line"><span class="comment"> * @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment"> * @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment"> * @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: Convenient wrapper for kthread_create() followed by</span></span><br><span class="line"><span class="comment"> * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)			   \</span></span><br><span class="line"><span class="meta">(&#123;									   \</span></span><br><span class="line"><span class="meta">	struct task_struct *__k						   \</span></span><br><span class="line"><span class="meta">		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (!IS_ERR(__k))						   \</span></span><br><span class="line"><span class="meta">		wake_up_process(__k);					   \</span></span><br><span class="line"><span class="meta">	__k;								   \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>;</span><br></pre></td></tr></table></figure>

<p>②然后将创建内核线程返回的<code>task_strcut</code>给到<code>irqaction</code>.(<code>new-&gt;trhead = t;这句</code>)<br>我们知道<code>irqaction</code>就包含了<code>thread_fn</code>和<code>handler</code>。</p>
<h2><span id="4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</span><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de" class="header-anchor">#</a></h2><h3><span id="4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</span><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>无论是中断的上半部的<code>handler</code>, 还是后处理的<code>thread_fn</code>前面的<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/#3-4-gic-zhong-duan-chu-guo-cheng">字符设备驱动-9-中断子系统-GICv2架构解析 | Hexo (fuzidage.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a>有引入介绍。</p>
<p>当中断产生时，用gdb看看gic驱动框架调用关系：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">1</span>, gpio_keys_gpio_isr (irq=<span class="number">200</span>, dev_id=<span class="number">0x863e6930</span>) at drivers/input/keybo</span><br><span class="line">ard/gpio_keys.c:<span class="number">393</span></span><br><span class="line"><span class="number">393</span> &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#0 gpio_keys_gpio_isr (irq=200, dev_id=0x863e6930) at drivers/input/keyboard/gpio_k</span></span><br><span class="line">eys.c:<span class="number">393</span></span><br><span class="line"><span class="meta">#1 0x80270528 in __handle_irq_event_percpu (desc=0x8616e300, flags=0x86517edc) at ke</span></span><br><span class="line">rnel/irq/handle.c:<span class="number">145</span></span><br><span class="line"><span class="meta">#2 0x802705cc in handle_irq_event_percpu (desc=0x8616e300) at kernel/irq/handle.c:18</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">#3 0x80270640 in handle_irq_event (desc=0x8616e300) at kernel/irq/handle.c:202</span></span><br><span class="line"><span class="meta">#4 0x802738e8 in handle_level_irq (desc=0x8616e300) at kernel/irq/chip.c:518</span></span><br><span class="line"><span class="meta">#5 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#6 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#7 0x805005e0 in mxc_gpio_irq_handler (port=0xc8, irq_stat=2252237104) at drivers/gp</span></span><br><span class="line">io/gpio-mxc.c:<span class="number">274</span></span><br><span class="line"><span class="meta">#8 0x805006fc in mx3_gpio_irq_handler (desc=&lt;optimized out&gt;) at drivers/gpio/gpio-mx</span></span><br><span class="line">c.c:<span class="number">291</span></span><br><span class="line"><span class="meta">#9 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#10 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#11 0x8026fd0c in __handle_domain_irq (domain=0x86006000, hwirq=32, lookup=true, regs</span></span><br><span class="line">=<span class="number">0x86517fb0</span>) at kernel/irq/irqdesc.c:<span class="number">627</span></span><br><span class="line"><span class="meta">#12 0x80201484 in handle_domain_irq (regs=&lt;optimized out&gt;, hwirq=&lt;optimized out&gt;, dom</span></span><br><span class="line">ain=&lt;optimized <span class="keyword">out</span>&gt;) at ./include/linux/irqdesc.h:<span class="number">168</span></span><br><span class="line"><span class="meta">#13 gic_handle_irq (regs=0xc8) at drivers/irqchip/irq-gic.c:364</span></span><br><span class="line"><span class="meta">#14 0x8020b704 in __irq_usr () at arch/arm/kernel/entry-armv.S:464</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/11.png" alt="image"></p>
<p>从打印可以看出注册的上半部硬件中断<code>handler</code>的调用流程。</p>
<h3><span id="4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</span><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>来看<code>gpio_keys_gpio_isr</code>是如何一层层调用上来的。从<code>__handle_irq_event_percpu</code>开始分析：（它在<code>kernel\irq\handle.c</code>中）<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/12.png" alt="image"><br>执行上半部提供的的<code>handler</code>函数。判断上半部返回值如果是<code>IRQ_WAKE_THREAD</code>，就调用<code>__irq_wake_thread</code>唤醒中断线程处理函数。</p>
<p>如果上半部返回值是<code>IRQ_HANDLED</code>,表示该中断无需线程化处理，直接退出。</p>
<h4><span id="4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</span><a href="#4-2-2-1-irq-wake-thread-fen-xi" class="header-anchor">#</a></h4><p>它在<code>kernel\irq\handle.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __irq_wake_thread(<span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *action)&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_active);</span><br><span class="line">	wake_up_process(action-&gt;thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒的是谁，就是<code>action-&gt;thread</code>，也就是对应前面<code>kthread_create</code>出来的<code>irq_thread</code>，再次贴图如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/13.png" alt="image"></p>
<h4><span id="4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</span><a href="#4-2-2-2-irq-thread-han-shu-fen-xi" class="header-anchor">#</a></h4><p>在<code>kernel\irq\manage.c</code>，平时<code>irq_thread</code>是处于休眠idle状态，不占用cpu资源。</p>
<p>当被唤醒后，<code>irq_thread</code>进入唤醒状态调用<code>handler_fn</code>，也就是最终使用者预先设定的<code>action-&gt;thread_fn</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupt handler thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">irq_thread</span><span class="params">(<span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">on_exit_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(action-&gt;irq);</span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler_fn)(<span class="keyword">struct</span> irq_desc *desc,</span><br><span class="line">			<span class="keyword">struct</span> irqaction *action);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (force_irqthreads &amp;&amp; test_bit(IRQTF_FORCED_THREAD,</span><br><span class="line">					&amp;action-&gt;thread_flags))</span><br><span class="line">		handler_fn = irq_forced_thread_fn;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		handler_fn = irq_thread_fn;</span><br><span class="line"></span><br><span class="line">	init_task_work(&amp;on_exit_work, irq_thread_dtor);</span><br><span class="line">	task_work_add(current, &amp;on_exit_work, <span class="literal">false</span>);</span><br><span class="line">	irq_thread_check_affinity(desc, action);</span><br><span class="line">	<span class="keyword">while</span> (!irq_wait_for_interrupt(action)) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> action_ret;</span><br><span class="line">		irq_thread_check_affinity(desc, action);</span><br><span class="line">		action_ret = handler_fn(desc, action);<span class="comment">//调用irq_thread_fn</span></span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_HANDLED)</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_handled);</span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_WAKE_THREAD)</span><br><span class="line">			irq_wake_secondary(desc, action);</span><br><span class="line">		wake_threads_waitq(desc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts explicitly requested as threaded interrupts want to be</span></span><br><span class="line"><span class="comment"> * preemtible - many of them need to sleep and wait for slow busses to</span></span><br><span class="line"><span class="comment"> * complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">irq_thread_fn</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> irqaction *action)</span>&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line">	ret = action-&gt;thread_fn(action-&gt;irq, action-&gt;dev_id);<span class="comment">//调用使用者预先设定的action-&gt;thread_fn</span></span><br><span class="line">	irq_finalize_oneshot(desc, action);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/15.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/" data-id="clzp8uttf003y9oufh6ujezxm" data-title="字符设备驱动-9-中断子系统-中断线程化-threaded_irq" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断线程化-workqueue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/" class="article-date">
  <time class="dt-published" datetime="2024-08-11T06:43:08.000Z" itemprop="datePublished">2024-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/">字符设备驱动-9-中断子系统-中断线程化-workqueue</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</a><ul>
<li><a href="#1-1-work-struct-miao-shu">1.1 work_struct描述</a><ul>
<li><a href="#1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</a></li>
<li><a href="#1-1-2-shi-yong-work">1.1.2 使用work</a></li>
<li><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</a><ul>
<li><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</a></li>
<li><a href="#2-2-fen-xi">2.2 分析</a></li>
</ul>
</li>
<li><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</a><ul>
<li><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</a></li>
<li><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</a></li>
<li><a href="#3-3-schedule-work">3.3 schedule_work</a><ul>
<li><a href="#3-3-1-queue-work">3.3.1 <code>__queue_work</code></a><ul>
<li><a href="#3-3-1-1-insert-work">3.3.1.1 insert_work</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-worker-thread-diao-du">3.4 worker_thread调度</a></li>
<li><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</span><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru" class="header-anchor">#</a></h1><p>定时器、<code> tasklet</code>，它们都是在中断上下文中执行（<code>softirq</code>中完成的），它们无法休眠。那么如果一旦中断要处理耗时复杂的操作，就会显得很卡。那么使用内核线程来处理这些耗时的工作，那就可以解决系统卡顿的问题。<br>Linux内核中<code>工作队列workqueue</code>就是线程化处理的一种方式，<code>“工作队列”(workqueue)</code>, 它是内核自带的<code>内核线程</code>。要使用<code>“工作队列”</code>，只需要把<code>“工作”</code>放入<code>“工作队列&quot;</code>中，对应的内核线程就会取出 <code>“工作”</code>，执行里面的函数。</p>
<p>工作队列的应用场合：<br>要做的事情比较耗时，甚至可能需要休眠，那么可以使用工作队列。<br>缺点：多个工作(函数)是在某个内核线程中依序执行的，前面函数执行很慢，就会影响到后面的函数。<br>在多 CPU 的系统下，一个工作队列可以有多个内核线程，可以在一定程度上缓解这个问题。</p>
<p>工队队列的源码机制在<code>Linux-4.9.88\kernel\workqueue.c</code>，头文件在<code>Linux-4.9.88\include\linux\workqueue.h</code></p>
<h2><span id="1-1-work-struct-miao-shu">1.1 work_struct描述</span><a href="#1-1-work-struct-miao-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/2.png" alt="image"><br>表示一个work结构，一个任务或者叫做一个工作，里面的<code>.func</code>表示是要执行的任务函数，类型定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</span><a href="#1-1-1-ding-yi-yi-ge-work" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELAYED_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第 1 个宏是用来定义一个 work_struct 结构体，要指定它的函数。</span></span><br><span class="line"><span class="comment">//第 2 个宏用来定义一个 delayed_work 结构体，也要指定它的函数。所以“delayed”</span></span><br><span class="line">   <span class="comment">// ，意思就是说要让它运行时，可以指定：某段时间之后你再执行</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/3.png" alt="image"><br>定义一个work为<code>n</code>, 并且初始化函数<code>f</code>.</p>
<p>如果代码中定义好了一个work_struct结构体，那么可以用<code>INIT_WORK</code>函数来初始化：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/4.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line"><span class="meta">	__INIT_WORK((_work), (_func), 0)</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-shi-yong-work">1.1.2 使用work</span><a href="#1-1-2-shi-yong-work" class="header-anchor">#</a></h3><p>初始化完work后，调用<strong>schedule_work</strong>即可调度工作队列进行处理当前任务。<br>调用 <code>schedule_work </code>时，就会把<code>work_struct</code> 结构体放入队列<code>system_wq</code>中，并唤醒对应的内核线程。内核线程就会从队列里把 work_struct 结构体取出来，执行里面的函数。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_work - put work task in global workqueue</span></span><br><span class="line"><span class="comment"> * @work: job to be done</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns %false if @work was already on the kernel-global workqueue and</span></span><br><span class="line"><span class="comment"> * %true otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This puts a job in the kernel-global workqueue if it was not already</span></span><br><span class="line"><span class="comment"> * queued and leaves it in the same position on the kernel-global</span></span><br><span class="line"><span class="comment"> * workqueue otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>system_wq</code>是内核自带的队列，结构属性为<code>struct workqueue_struct</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/7.png" alt="image"><br>如果不想用内核自带的<strong>system_wq</strong>来调度我们的work, 那么可以调用<strong>create_workqueue</strong>函数自行创建工队队列。然后用<strong>queue_work</strong>函数使能.</p>
<h3><span id="1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</span><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create_workqueue</td>
<td>在 Linux 系统中已经有了现成的 system_wq 等工作队列，你当然也可以自己调用 create_workqueue 创建工作队列，对于 SMP 系统，这个工作队列会有多个内核线程与它对应，创建工作队列时，内核会帮这个工作队列创建多个内核线程</td>
</tr>
<tr>
<td>create_singlethread_workqueue</td>
<td>如果想只有一个内核线程与工作队列对应，可以用本函数创建工作队列，创建工作队列时，内核会帮这个工作队列创建一个内核线程</td>
</tr>
<tr>
<td>destroy_workqueue</td>
<td>销毁工作队列</td>
</tr>
<tr>
<td>schedule_work</td>
<td>调度执行一个具体的 work，执行的 work 将会被挂入 Linux 系统提供的工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work</td>
<td>延迟一定时间去执行一个具体的任务，功能与 schedule_work 类似，多了一个延迟时间</td>
</tr>
<tr>
<td>queue_work</td>
<td>跟 schedule_work 类似，schedule_work 是在系统默认的工作队列上执行一个work，queue_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>queue_delayed_work</td>
<td>跟 schedule_delayed_work 类似，schedule_delayed_work 是在系统默认的工作队列上执行一个 work，queue_delayed_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>flush_work</td>
<td>等待一个 work 执行完毕，如果这个 work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
<tr>
<td>flush_delayed_work</td>
<td>等待一个 delayed_work 执行完毕，如果这个 delayed_work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 delayed_work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
</tbody></table>
<h1><span id="2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</span><a href="#2-bian-xie-dai-ma-ji-jie-xi" class="header-anchor">#</a></h1><h2><span id="2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</span><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">/*err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, </span></span><br><span class="line"><span class="comment">        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span></span><br><span class="line"><span class="comment">        &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);*/</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq</span><br><span class="line">              , gpio_key_isr, gpio_key_thread_func</span><br><span class="line">              , IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">              , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-fen-xi">2.2 分析</span><a href="#2-2-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/9.png" alt="image"><br>为每一个按键都建立一个work_struct，并且初始化work。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br></pre></td></tr></table></figure>
<p><code>key_work_func</code>是work里面函数，参数为该work自身。该函数只是简单打印该work的自身属性（work名字，work进程id），然后输出按键值。通过<code>container_of</code>找到父亲结构体<code>gpio_key</code>。<br>注意：current是Linux内核自带的一个变量，外部驱动要引用它只需要包含头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/10.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/11.png" alt="image"></p>
<p>中断到来后，这时候上半部完成清中断等一些列重要操作，使能workqueue工作队列，调用函数<strong>schedule_work</strong>。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12.png" alt="image"><br>内核从系统工作队列<code>system_wq</code>从取出该work，执行里面的函数<code>（key_work_func)</code>。</p>
<p>可以看到<code>current</code>信息：<code>pid为428</code>，内核线程名字为<code>[kworker/0:1]</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12-1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/13.png" alt="image"></p>
<h1><span id="3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</span><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</span><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>代码在<code>kernel\workqueue.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init_workqueues<span class="comment">//函数主体如下</span></span><br><span class="line">keventd_wq = create_workqueue(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"> __create_workqueue((name), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> err = create_workqueue_thread(cwq, cpu);</span><br><span class="line"> p = kthread_create(worker_thread, cwq, fmt, wq-&gt;name, cpu); </span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/15.png" alt="image"></p>
<p>会先分配一个workqueue结构创建一个<code>system_wq</code>工作队列，为每一个 CPU，都创建一个名为<code>“events/X”</code>的内核线程，X 从 0 开始。在创建 workqueue 的同时创建内核线程。</p>
<h2><span id="3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</span><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>Linux4.x 中，内核线程和工作队列是分开创建的。先创建内核线程，在 <code>kernel\workqueue.c </code>中<br>对每一个cpu，都会创建2个<code>work_pool</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init_workqueues <span class="comment">//函数主体如下：</span></span><br><span class="line"><span class="comment">/* initialize CPU pools */</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 都创建 2 个 worker_pool 结构体，它是含有 ID 的 */</span></span><br><span class="line"> <span class="comment">/* 一个 worker_pool 对应普通优先级的 work，第 2 个对应高优先级的 work */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* create the initial worker */</span></span><br><span class="line">for_each_online_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 的每一个 worker_pool，创建一个 worker */</span></span><br><span class="line"><span class="comment">/* 每一个 worker 对应一个内核线程 */</span></span><br><span class="line"> BUG_ON(!create_worker(pool));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/16.png" alt="image"><br><code>create_worker </code>函数代码如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/17.png" alt="image"></p>
<p>创建好内核线程后，再创建<code> workqueue</code>：这里<code>workqueue</code>会和普通优先级的<code>work_pool</code>建立联系，以后给<code>workqueue</code>添加work的时候会放入<code>work_pool</code>中，执行对应<code>work</code>的时候唤醒相对应的<code>work</code>线程，比如<code>kwork/0:1</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/18.png" alt="image"></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/19.png" alt="image"></p>
<h2><span id="3-3-schedule-work">3.3 schedule_work</span><a href="#3-3-schedule-work" class="header-anchor">#</a></h2><p><code>schedule_work</code> 会将 work 添加到默认的工作队列也就是 <code>system_wq </code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;<span class="comment">//queue_work_on ，增加一个参数 WORK_CPU_UNBOUND，这个参数并不是指将当前</span></span><br><span class="line"><span class="comment">//work 绑定到 unbound 类型的 worker_pool 中，只是说明调用者并不指定将当前</span></span><br><span class="line"><span class="comment">//work 绑定到哪个 cpu 上，由系统来分配 cpu.当然，调用者也可以直接使用</span></span><br><span class="line"><span class="comment">//queue_work_on 接口，通过第一个参数来指定当前 work 绑定的 cpu。</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">        __queue_work(cpu, wq, work);</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-1-queue-work">3.3.1 <code>__queue_work</code></span><a href="#3-3-1-queue-work" class="header-anchor">#</a></h3><p>继续调用<code>__queue_work</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">             <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取 cpu 相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">        cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查当前的 work 是不是在这之前被添加到其他 worker_pool 中，</span></span><br><span class="line">    <span class="comment">//如果是，就让它继续在原本的 worker_pool 上运行</span></span><br><span class="line">    last_pool = get_work_pool(work);</span><br><span class="line">    <span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">        worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">            pwq = worker-&gt;current_pwq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">            spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">            spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果超过 pwq 支持的最大的 work 数量，将work添加到 pwq-&gt;delayed_works 中</span></span><br><span class="line">    <span class="comment">//，否则就添加到 pwq-&gt;pool-&gt;worklist 中。  </span></span><br><span class="line">    <span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">        trace_workqueue_activate_work(work);</span><br><span class="line">        pwq-&gt;nr_active++;</span><br><span class="line">        worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(worklist))</span><br><span class="line">            pwq-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">        worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加 work 到队列中。</span></span><br><span class="line">    insert_work(pwq, work, worklist, work_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要由3个部分组成：</p>
<ol>
<li>获取 cpu 参数</li>
<li>检查冲突</li>
<li>添加 work 到队列<code>insert_work</code></li>
</ol>
<h4><span id="3-3-1-1-insert-work">3.3.1.1 insert_work</span><a href="#3-3-1-1-insert-work" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_work</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="keyword">struct</span> work_struct *work,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> list_head *head, <span class="type">unsigned</span> <span class="type">int</span> extra_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> pwq-&gt;pool;</span><br><span class="line">    <span class="comment">//设置 work 的 pwq 和 flag。</span></span><br><span class="line">    set_work_pwq(work, pwq, extra_flags);</span><br><span class="line">    <span class="comment">//将 work 添加到 worklist 链表中</span></span><br><span class="line">    list_add_tail(&amp;work-&gt;entry, head);</span><br><span class="line">    <span class="comment">//为 pwq 添加引用计数</span></span><br><span class="line">    get_pwq(pwq);</span><br><span class="line">    <span class="comment">//添加内存屏障，防止 cpu 将指令乱序排列</span></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒 worker 对应的内核线程</span></span><br><span class="line">    <span class="keyword">if</span> (__need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，就是将<code> work</code> 插入到<code>worker_pool-&gt;worklist</code>中。<br>添加完之后，就会唤醒<code> worker_pool</code> 中第一个处于<code>idle</code>状态<code>worker-&gt;task</code>内核线程，work 就会进入到待处理状态。</p>
<h2><span id="3-4-worker-thread-diao-du">3.4 worker_thread调度</span><a href="#3-4-worker-thread-diao-du" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">    spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    <span class="comment">//在必要的时候删除 worker，退出当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">        spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">        WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">        worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">        set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>);</span><br><span class="line">        ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">        worker_detach_from_pool(worker, pool);</span><br><span class="line">        kfree(worker);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">    <span class="comment">//管理 worker 线程</span></span><br><span class="line">    <span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">        <span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">        <span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 work</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">            list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">                     <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">        pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">            process_one_work(worker, work);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">                process_scheduled_works(worker);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">            process_scheduled_works(worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">    worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">    <span class="comment">//处理完成，陷入睡眠</span></span><br><span class="line">    worker_enter_idle(worker);</span><br><span class="line">    __set_current_state(TASK_IDLE);</span><br><span class="line">    spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>worker_thread</code>函数主要包括以下的几个主要部分：</p>
<ol>
<li>管理 worker</li>
<li>执行 work<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.1</span> 从当前worker_pool-&gt;worklist 中的链表元素取出work</span><br><span class="line"><span class="number">2.2</span> move_linked_works 将会在执行前将 work 添加到 worker-&gt;scheduled 链表中</span><br><span class="line">    ，该接口和 list_add_tail 不同的是，这个接口会先删除链表中存在的节点并重新添加，</span><br><span class="line">	保证不会重复添加，且始终添加到最后一个节点。</span><br><span class="line"><span class="number">2.3</span> process_scheduled_works 函数正式执行 work，该函数会遍历 worker-&gt;scheduled 链表，</span><br><span class="line">    执行每一个 work，执行之前会做一些必要的检查，比如在同一个 cpu 上，</span><br><span class="line">	一个 worker 不能在多个 worker 线程中被并发执行(这里的并发执行指的是同时加入到 schedule 链表)，</span><br><span class="line">    是否需要唤醒其它的 worker 来协助执行(碰到 cpu 消耗型的work 需要这么做)，</span><br><span class="line">    执行 work 的方式就是调用 work-&gt;func</span><br></pre></td></tr></table></figure>
当执行完<code>worker_pool-&gt;worklist</code> 中所有的<code>work</code>之后，当前线程就会陷入睡眠.</li>
</ol>
<h2><span id="3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</span><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug" class="header-anchor">#</a></h2><p>在多核<code>cpu</code>调度时，使用<code>workqueue</code>会小概率出现<code>WARNING: CPU: x PID: xx at linux_5.10/kernel/workqueue.c:1796 worker_enter_idle</code><br>的<code>call trace</code>提示，然后cpu进入idel休眠状态。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/20.png" alt="image"></p>
<p>由于如果在 <code>WORKER_NOT_RUNNING </code>检查时和下面的 <code>nr_running </code>增量之间被<code>unbind_workers()</code>抢占，我们可能会破坏 <code>nr_running </code>重置并在新的未绑定池上留下意外的<code> pool-&gt;nr_running == 1</code> 。</p>
<p>为了 防止这样的竞态产生，linux内核patch参考:<br><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/">https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/</a><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/21.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/22.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/" data-id="clzp8uttg00409oufffvc9qgc" data-title="字符设备驱动-9-中断子系统-中断线程化-workqueue" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断下半部-tasklet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T12:44:36.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/">字符设备驱动-9-中断子系统-中断下半部-tasklet</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tasklet-yin-ru">1 tasklet引入</a></li>
<li><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</a></li>
<li><a href="#3-tasklet-shi-yong">3 tasklet使用</a><ul>
<li><a href="#3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</a><ul>
<li><a href="#3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</a></li>
<li><a href="#3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</a></li>
<li><a href="#3-1-2-tasklet-init">3.1.2 tasklet_init</a></li>
<li><a href="#3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</a></li>
</ul>
</li>
<li><a href="#3-2-shi-neng-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</a></li>
<li><a href="#3-3-diao-du-tasklet">3.3 调度tasklet</a></li>
<li><a href="#3-4-zhi-xing-tasklet">3.4 执行tasklet</a></li>
<li><a href="#3-5-tasklet-kill">3.5 tasklet_kill</a></li>
</ul>
</li>
<li><a href="#4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</a><ul>
<li><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</a></li>
<li><a href="#4-2-fen-xi">4.2 分析</a></li>
</ul>
</li>
<li><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</a><ul>
<li><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tasklet-yin-ru">1 tasklet引入</span><a href="#1-tasklet-yin-ru" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a></p>
<p>介绍了硬件中断和软件中断，硬件中断有gpio中断，网卡，外部电路IP引起的中断，而软件中断则有定时器，tasklet这些为软件中断。cpu会先处理硬件中断，然后处理软件中断。</p>
<p>简单说可以认为内核中有一个数组softirq[], 里面有很多项，某一项对应timer，某一项表示tasklet, 每一项中都有一个<code>.action</code>函数，当内核处理完某一个硬件中断之后，处理软件中断时会找到对应的项，找到<code>.action</code>函数执行。</p>
<p>对于<code>tasklet</code>软件中断，它的<code>.action</code>函数对应<code>tasklet_action</code>,这个函数会从链表里取出每一个<code>tasklet</code>结构，执行里面的<code>.func</code>函数。</p>
<p>内核处理硬件中断的过程叫做中断上半部，处理软件中断的过程叫做中断下半部。上半部执行过程中，中断是禁止的，这里防止中断嵌套，也就是说来了更紧急的硬件中断，也要等这个上半部分处理完，上半部一般处理重要紧急事情。下半部执行过程中，中断是使能的，因此在下半部的处理过程它是可以响应其他中断。因此如果有不紧急但是耗时的事情放在下半部来处理，比如用tasklet。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/1.png" alt="image"></p>
<h1><span id="2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</span><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen" class="header-anchor">#</a></h1><p>如何使能或者说调度tasklet呢？它其实就是把一个tasklet放入到内核tasklet链表中，假如硬件中断服务函数func_A(), 软件中断中也就是下半部放入tasklet中断的服务函数为func_B(), 那么可以想象看A和B被调度的次数因该是多对1的关系，应为软件中断由于是使能中断的，因此func_A()对应的硬件又可能会产生硬件中断。</p>
<h1><span id="3-tasklet-shi-yong">3 tasklet使用</span><a href="#3-tasklet-shi-yong" class="header-anchor">#</a></h1><h2><span id="3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</span><a href="#3-1-chu-shi-hua-tasklet" class="header-anchor">#</a></h2><h3><span id="3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</span><a href="#3-1-0-tasklet-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span><span class="comment">//tasklet链表</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;<span class="comment">//RUN表示正在运行，SCHED表示已被调度</span></span><br><span class="line">	<span class="type">atomic_t</span> count;<span class="comment">//0表示处于激活状态，不为0表示该tasklet禁止，不允许执行</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//处理函数，等效softirq的action函数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>\include\linux\interrupt.h</code><br>state 有 2 位：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">◼ bit0 表示 TASKLET_STATE_SCHED</span><br><span class="line">等于 <span class="number">1</span> 时表示已经执行了 tasklet_schedule 把该 tasklet 放入队列了；(等于<span class="number">1</span>表示放入队列就绪了)</span><br><span class="line">tasklet_schedule 会判断该位，如果已经等于 <span class="number">1</span> 那么它就不会再次把tasklet 放入队列。</span><br><span class="line">◼ bit1 表示 TASKLET_STATE_RUN</span><br><span class="line">等于 <span class="number">1</span> 时，表示正在运行 tasklet 中的 func 函数；函数执行完后内核会把该位清 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>count 表示该 tasklet 是否使能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等于 <span class="number">0</span> 表示使能了，非 <span class="number">0</span> 表示被禁止了。对于 count 非 <span class="number">0</span> 的 tasklet，里面的 func 函数不会被执行</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</span><a href="#3-1-1-tasklet-lian-biao" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span>                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>; <span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br><span class="line"><span class="comment">//对应softirq的TASKLET_SOFTIRQ和HI_SOFTIRQ， 优先级分别为6和0</span></span><br></pre></td></tr></table></figure>

<p>tasklet执行过程<code> TASKLET_SOFTIRQ</code>对应执行函数为<code>tasklet_action</code>，<code>HI_SOFTIRQ</code>为<code>tasklet_hi_action</code>。</p>
<h3><span id="3-1-2-tasklet-init">3.1.2 tasklet_init</span><a href="#3-1-2-tasklet-init" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</span><a href="#3-1-3-declare-tasklet" class="header-anchor">#</a></h3><p><code>DECLARE_TASKLET</code>和<code>DECLARE_TASKLET_DISABLED</code>可以定义一个tasklet结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 DECLARE_TASKLET 定义的 tasklet 结构体，它是使能的；</span></span><br><span class="line"><span class="comment">//使用 DECLARE_TASKLET_DISABLED 定义的 tasklet 结构体，它是禁止的；使用之前要先调用 tasklet_enable 使能它。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shi-neng-x2f-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</span><a href="#3-2-shi-neng-x2f-jin-zhi-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_enable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_disable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/5.png" alt="image"></p>
<h2><span id="3-3-diao-du-tasklet">3.3 调度tasklet</span><a href="#3-3-diao-du-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/6.png" alt="image"><br>把 <code>tasklet</code> 放入链表，并且设置它的 <code>TASKLET_STATE_SCHED </code>状态为1。<code>tasklet_schedule</code> 只是把 tasklet 放入内核队列，它的 <code>func</code> 函数会在软件中断的执行过程中被调用。</p>
<h2><span id="3-4-zhi-xing-tasklet">3.4 执行tasklet</span><a href="#3-4-zhi-xing-tasklet" class="header-anchor">#</a></h2><p>对于 <code>TASKLET_SOFTIRQ</code> 类型的 <code>softirq</code>，其handler是 <code>tasklet_action</code>，可以看到软中断执行，硬件中断是使能的。执行对应的<code>func</code>函数。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/7.png" alt="image-20240810224518977"></p>
<h2><span id="3-5-tasklet-kill">3.5 tasklet_kill</span><a href="#3-5-tasklet-kill" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果一个 tasklet 未被调度， tasklet_kill 会把它的TASKLET_STATE_SCHED 状态清 0；</span></span><br><span class="line"><span class="comment">//如果一个 tasklet 已被调度，tasklet_kill 会等待它执行完华，再把它的TASKLET_STATE_SCHED 状态清 0。</span></span><br></pre></td></tr></table></figure>

<p>通常在卸载驱动程序时调用 <code>tasklet_kill</code>。</p>
<h1><span id="4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</span><a href="#4-tasklet-dai-ma-shi-li-jie-xi" class="header-anchor">#</a></h1><h2><span id="4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</span><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line"></span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">		, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>用户态测试代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h2><span id="4-2-fen-xi">4.2 分析</span><a href="#4-2-fen-xi" class="header-anchor">#</a></h2><p>probe函数中为每一个gpio按键都创建一个<code>tasklet</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/10.png" alt="image"><br>当按键按下，中断服务执行，那么此时需要调度tasklet去完成中断下半部的事情，每当一个按键按下，就会执行一次tasklet里面的函数，也就是<code>key_tasklet_func</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/11.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/12.png" alt="image"><br>根据不同的gpio带来不同的data，这里<code>key_tasklet_func</code>下半部分只是简单打印出对应哪一个gpio，输出什么电平。<br>最终驱动卸载时调用<code>tasklet_kill</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/13.png" alt="image"></p>
<h1><span id="5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</span><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi" class="header-anchor">#</a></h1><h2><span id="5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</span><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng" class="header-anchor">#</a></h2><p><code>tasklet</code>属于<code>TASKLET_SOFTIRQ</code>软件中断，入口函数为<code>tasklet_action</code>，这在内核<code> kernel\softirq.c</code> 中设置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/14.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/15.png" alt="image"></p>
<p>当驱动程序调用<code> tasklet_schedule</code> 时，会设置 tasklet 的<code>state</code>为<code>TASKLET_STATE_SCHED</code>，并把它放入内核<code>tasklet链表</code>:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/16.png" alt="image"><br>触发<code>TASKLET_SOFTIRQ </code>软件中断，会调用 <code>tasklet_action </code>函数，遍历<code>tasklet </code>链表，进行状态判断后执行<code> .func</code><br>函数，从队列中删除 <code>tasklet</code>。<br>可以看出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tasklet_schedule 调度 tasklet 时，其中的函数并不会立刻执行，而只是把tasklet 放入队列</span><br><span class="line"><span class="number">2.</span>调用一次 tasklet_schedule，只会导致 tasklet 的函数被执行一次；如果 tasklet 的函数尚未执行</span><br><span class="line">    ，多次调用 tasklet_schedule 也是无效的，只会放入队列一次，TASKLET_STATE_SCHED状态会自行判断。</span><br></pre></td></tr></table></figure>
<p>最终tasklet中的<code>func</code>执行要看<code>tasklet_action</code>的过程分析：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/17.png" alt="image"><br>首先从链表中取出每一项<code>tasklet</code>, 读取<code>count</code>, 如果等于0表示有使能该<code>tasklet</code>, 清除<code>TASKLET_STATE_SCHED</code>位，并且执行<code>t-&gt;func</code>，执行完该task中的<code>func</code>后从链表取出并且删除掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/" data-id="clzp8uttf003r9oufcsos6iiv" data-title="字符设备驱动-9-中断子系统-中断下半部-tasklet" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断设备树表述与解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T11:30:34.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/">字符设备驱动-9-中断子系统-中断设备树表述与解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</a><ul>
<li><a href="#1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</a></li>
<li><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</a><ul>
<li><a href="#1-2-1-interrupt-controller">1.2.1 interrupt-controller</a></li>
<li><a href="#1-2-2-interrupt-cells">1.2.2 interrupt-cells</a></li>
<li><a href="#1-2-3-interrupt-parent">1.2.3 interrupt-parent</a></li>
<li><a href="#1-2-4-interrupts">1.2.4 interrupts</a></li>
</ul>
</li>
<li><a href="#1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</a><ul>
<li><a href="#1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</a><ul>
<li><a href="#1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</a></li>
</ul>
</li>
<li><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</a><ul>
<li><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</a></li>
</ul>
</li>
<li><a href="#1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</a><ul>
<li><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</a><ul>
<li><a href="#2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</a><ul>
<li><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</a></li>
<li><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</a></li>
</ul>
</li>
<li><a href="#2-2-qu-dong-dai-ma">2.2 驱动代码</a><ul>
<li><a href="#2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</span><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu" class="header-anchor">#</a></h1><h2><span id="1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</span><a href="#1-1-zhong-duan-kong-zhi-qi" class="header-anchor">#</a></h2><p>如图：GPIO1 连接到 GIC，GPIO2 连接到 GIC，所以 GPIO1 的父亲是 GIC，GPIO2的父亲是 GIC。假设 GPIO1 有 32 个中断源，但是它把其中的 16 个汇聚起来向 GIC 发出一个中断，把另外 16 个汇聚起来向 GIC 发出另一个中断。这就意味着 GPIO1 会用到 GIC 的两个中断，会涉及 GIC 里的 2 个 <code>hwirq</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/1.png" alt="image"></p>
<h2><span id="1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</span><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing" class="header-anchor">#</a></h2><p>设备树中，中断控制器节点中必须有一个属性：</p>
<h3><span id="1-2-1-interrupt-controller">1.2.1 interrupt-controller</span><a href="#1-2-1-interrupt-controller" class="header-anchor">#</a></h3><p>表明它是 <code>“中断控制器”</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<h3><span id="1-2-2-interrupt-cells">1.2.2 interrupt-cells</span><a href="#1-2-2-interrupt-cells" class="header-anchor">#</a></h3><p>⚫ <code>#interrupt-cells=&lt;1&gt;</code><br>    别的节点要使用这个中断控制器时，只需要一个 cell 来表明使用 “哪一个中断”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vic: intc@<span class="number">10140000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;arm,versatile-vic&quot;</span>;</span><br><span class="line">interrupt-controller;</span><br><span class="line"><span class="meta">#interrupt-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x10140000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>⚫ <code>#interrupt-cells=&lt;2&gt;</code><br>别的节点要使用这个中断控制器时，需要一个 cell 来表明使用 “哪一个中断”；还需要另一个 cell 来描述中断，一般是表明触发类型：<br>    第 2 个 cell 的 bits[3:0] 用来表示中断触发类型(<code>trigger type and level flags</code>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> = low-to-high edge triggered，上升沿触发</span><br><span class="line"><span class="number">2</span> = high-to-low edge triggered，下降沿触发</span><br><span class="line"><span class="number">4</span> = active high level-sensitive，高电平触发</span><br><span class="line"><span class="number">8</span> = active low level-sensitive，低电平触发</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpio2: gpio@<span class="number">020</span>a0000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6q-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x020a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">68</span> <span class="number">4</span>&gt;,</span><br><span class="line">		  &lt;<span class="number">0</span> <span class="number">69</span> <span class="number">4</span>&gt;;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-interrupt-parent">1.2.3 interrupt-parent</span><a href="#1-2-3-interrupt-parent" class="header-anchor">#</a></h3><p>你要用哪一个中断控制器里的中断？<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<h3><span id="1-2-4-interrupts">1.2.4 interrupts</span><a href="#1-2-4-interrupts" class="header-anchor">#</a></h3><p>你要用哪一个中断？<br><code>Interrupts</code> 里要用几个 cell，由<code>interrupt-parent</code>对应的中断控制器决定。在中断控制器里有<code>“#interrupt-cells”</code>属性，它指明了要用几个 cell来描述中断。比如下图表示用到gpio中断控制器的160号中断，上升沿触发。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/4.png" alt="image"></p>
<h2><span id="1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</span><a href="#1-3-dts-zhong-huo-qu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</span><a href="#1-3-1-dui-yu-platform-device" class="header-anchor">#</a></h3><h4><span id="1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</span><a href="#1-3-1-1-platform-get-resource" class="header-anchor">#</a></h4><p>当平台设备和平台驱动match上后，一个节点能被转换为 <code>platform_device</code>，调用<code>platform_get_resource</code>可获取节点资源信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *,<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/5.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/6.png" alt="image"><br>如果需要获取中断信息，传入<code>IORESOURCE_IRQ</code>。</p>
<h3><span id="1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</span><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei" class="header-anchor">#</a></h3><p>I2C 总线驱动在处理设备树里的 I2C 子节点时，Linux总线会自动处理其中的中断信息。一个 I2C 设备会被转换为一个 <code>i2c_client</code>结构体，中断号会保存在 i2c_client 的 irq 成员里，代码如下(<code>drivers/i2c/i2c-core.c</code>)，probe函数里面<strong>of_irq_get</strong>函数会根据dts中的i2c节点获取中断资源。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/7.png" alt="image"></p>
<p><strong>GIC_SPI</strong>表示中断类型为共享中断。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/9.png" alt="image"><br>SPI总线同理，一个 SPI 设备会被转换为一个<code>spi_device</code>结构体，中断号会保存在 <code>spi_device</code> 的 irq 成员里，代码如下(<code>drivers/spi/spi.c</code>)：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<h4><span id="1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</span><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao" class="header-anchor">#</a></h4><p>如果我们没用<code>platform device</code>架构写字符设备驱动，也可以直接调用<code>of_irq_get</code>获取。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<h3><span id="1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</span><a href="#1-3-3-dui-yu-gpio" class="header-anchor">#</a></h3><h4><span id="1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</span><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq" class="header-anchor">#</a></h4><p>参考：<code>drivers/input/keyboard/gpio_keys.c</code>， api路径<code>linux_5.10\include\linux\of_gpio.h</code><br>可以使用 <code>gpio_to_irq</code> 或 <code>gpiod_to_irq </code>获得中断号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button-&gt;gpio = of_get_gpio_flags(pp, <span class="number">0</span>, &amp;flags);</span><br><span class="line">bdata-&gt;gpiod = gpio_to_desc(button-&gt;gpio);</span><br><span class="line"><span class="comment">//再去使用 gpiod_to_irq 获得中断号：</span></span><br><span class="line">irq = gpiod_to_irq(bdata-&gt;gpiod)；</span><br></pre></td></tr></table></figure>

<h1><span id="2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</span><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</span><a href="#2-1-an-jian-dts-pei-zhi" class="header-anchor">#</a></h2><p>linux内核自带的<code>input sub system</code>本身就包含了gpio按键驱动，驱动程序 <code>drivers/input/keyboard/gpio_keys.c</code> 就可以，然后你需要做<br>的只是修改设备树指定引脚及键值。<br>为了简化我们直接写一个例子：强化熟悉对gpio中断的使用。</p>
<p>我们确定好用<code>gpio5_1</code>,  <code>gpio4_14</code>这2个按键来展开实验：定义好dts节点,这里定义<code>gpio_keys_100ask</code>，内核有函数自动把gpio num转成irq。在其他地方dts中(<code>imx6ull.dts</code>中)会描述好gpio5,gpio4节点信息，里面会有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>因此，这里表示引用gpio5的第0个引脚，gpio4的第14个引脚，节点如下，需要把原来的节点<code>gpio-keys</code> disable掉，添加下面的<code>gpio_keys_100ask</code>。进入内核目录 <code>make dtbs</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpio_keys_100ask &#123;</span><br><span class="line">	compatible = <span class="string">&quot;100ask,gpio_key&quot;</span>;</span><br><span class="line">	gpios = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH</span><br><span class="line">	&amp;gpio4 <span class="number">14</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;key1_pinctrl &amp;key2_pinctrl&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<p>设备树中并没有对这2个引脚进行<code>pinctrl</code>配置，也就是<code>iomux</code>配置，那为什么这2个引脚还能工作，是因为这个个引脚默认就是gpio状态，不用进行<code>iomux</code>切换。<br>为了保险起见，按照标准流程还需要对其添加<code>pinctrl</code>信息。</p>
<h3><span id="2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</span><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi" class="header-anchor">#</a></h3><p>imx6ull工具有制作好<code>pinctrl</code>如何配置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/13.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/14.png" alt="image"></p>
<p>填入到对应的子节点下面：gpio5的iomux配置放在<code>iomuxc_snvs</code>节点下，gpio4的配置放在<code>iomuxc</code>下。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/15.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/16.png" alt="image"></p>
<h3><span id="2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</span><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu" class="header-anchor">#</a></h3><p>再到定义的<code>gpio_keys_100ask</code>引用这2个<code>pinctrl</code>信息 <code>key1_100ask</code>和 <code>key2_100ask</code>。这里pinctrl只有一个default状态，<code>pinctrl-0</code>表示该默认状态，因此最终<code>gpio5_1</code>,  <code>gpio4_14</code>就被<code>iomux</code>成了gpio状态。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/17.png" alt="image"></p>
<h2><span id="2-2-qu-dong-dai-ma">2.2 驱动代码</span><a href="#2-2-qu-dong-dai-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码如下</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_key = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, g_key);</span><br><span class="line">	err = copy_to_user(buf, &amp;g_key, <span class="number">4</span>);</span><br><span class="line">	g_key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	g_key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count) </span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                          , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span>        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</span><a href="#2-2-1-qu-dong-dai-ma-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/18.png" alt="image"></p>
<p>定义<code>gpio_key</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/19.png" alt="image"><br>通过<code>.compatible = &quot;100ask,gpio_key&quot;</code>匹配<code>plateform_device</code>和<code>platform_driver</code>, 当<code>insmod ko</code>时probe函数被调用。<br><code>struct device_node *node = pdev-&gt;dev.of_node;//可以从platform_device获取到device_node</code>。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/20.png" alt="image"><br><code>of_gpio_count</code>可以根据设备树节点获取到gpio的数量。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/21.png" alt="image"><br><code>of_get_gpio_flags</code>可以根据设备树节点获取到<code>gpio</code>编号和<code>gpio flags</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/22.png" alt="image"><br>获取gpio描述子和gpio中断号:</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>注册中断服务程序<code>gpio_key_isr</code>，当按键按下会触发gpio中断，执行<code>gpio_key_isr</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/24.png" alt="image"><br>中断服务程序就简单的打印按键的电平状态:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/" data-id="clzp8uttm007o9ouf3pmw1l5l" data-title="字符设备驱动-9-中断子系统-中断设备树表述与解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断结构体" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T10:33:55.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/">字符设备驱动-9-中断子系统-中断结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</a></li>
<li><a href="#1-irq-desc-shu-zu">1 irq_desc 数组</a><ul>
<li><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</a><ul>
<li><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</a></li>
<li><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</a></li>
</ul>
</li>
<li><a href="#1-2-irqaction">1.2 irqaction</a><ul>
<li><a href="#1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</a></li>
<li><a href="#1-2-2-request-irq">1.2.2 request_irq</a></li>
<li><a href="#1-2-3-devm-request-irq">1.2.3 devm_request_irq</a></li>
</ul>
</li>
<li><a href="#1-3-irq-data">1.3 irq_data</a></li>
<li><a href="#1-4-irq-domain">1.4 irq_domain</a><ul>
<li><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</a></li>
<li><a href="#1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</a><ul>
<li><a href="#1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</a></li>
<li><a href="#1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-5-irq-chip">1.5 irq_chip</a></li>
</ul>
</li>
<li><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</span><a href="#0-yin-ru-sparse-irq" class="header-anchor">#</a></h1><p>如果内核配置了 <strong>CONFIG_SPARSE_IRQ</strong>，那么它就会用 <strong>基数树(radix tree)</strong> 来代替 irq_desc 数组。<br>SPARSE 的意思是“稀疏”，假设大小为 1000 的数组中只用到 2 个数组项，那不是浪费嘛？当中断比较“稀疏”时可以用基数树来代替数组。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/1.png" alt="image"></p>
<h1><span id="1-irq-desc-shu-zu">1 irq_desc 数组</span><a href="#1-irq-desc-shu-zu" class="header-anchor">#</a></h1><p>位于<code>include/linux/irqdesc.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/2.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/3.png" alt="在这里插入图片描述"></p>
<p>内核中记录一个<code>irq_desc</code>的数组，数组的每一项对应一个中断或者一组中断（使用同一中断号）。<code>irq_desc</code>几乎记录所有中断相关的东西，这个结构是中断的核心。每一个<code>irq_desc</code>数组项中都有一个函数：<code>handle_irq</code>，还有一个<code>action链表</code>。</p>
<p><code>irq_desc </code>数组结构链路如下图：</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/4.png" alt="image"></p>
<h2><span id="1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</span><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq" class="header-anchor">#</a></h2><h3><span id="1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</span><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru" class="header-anchor">#</a></h3><p>：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/5.png" alt="image"></p>
<ol>
<li>上图一个gpio按键连接gpio模块第一个引脚1，可以设置该引脚，当电平发生变化时，让该引脚产生中断，那么gpio模块会上报中断到gic模块, gic模块继续中断cpu。</li>
<li>同理当一个外部设备网卡和该gpio按键可以共享一个中断，也接到gpio模块第一个引脚1，gpio模块会上报中断到gic模块, gic模块继续中断cpu。这里就用到了共享中断的概念。</li>
</ol>
<p>可以看到中断的触发时从左到右的过程，那么cpu进行响应中断请求时就是从右到左的过程。</p>
<ol>
<li><p>cpu读取GIC控制器，判段中断号，如果是A号中断说明是来源于<code>gpio模块</code>，如果是<code>A&#39;</code>中断，说明来源于<code>其他模块</code>。</p>
</li>
<li><p>A号中断的来源有很多种，有<code>gpio0,gpio1....</code>， 又会从gpio控制寄存器来辨别倒是是哪一个gpio产生的中断，比如是B号中断</p>
</li>
<li><p>B号中断的来源有很多种，有<code>按键，网卡...</code></p>
</li>
</ol>
<h3><span id="1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</span><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan" class="header-anchor">#</a></h3><p>中断处理函数来源有三：</p>
<ol>
<li>GIC 的处理函数：<br> GIC 中断 CPU 时，CPU 读取 GIC 状态得到中断 A。假设<code> irq_desc[A].handle_irq 是 XXX_gpio_irq_handler</code>(XXX 指厂家)，这个函数需要读取芯片的 GPIO 控制器，细分发生的是哪一个 GPIO 中断(假设是B)，再去调用<code> irq_desc[B]. handle_irq</code>。</li>
</ol>
<p>  CPU从异常向量表中调用<code>handle_arch_irq</code>，这个函数指针是有GIC驱动设置的.调用<code>irq_desc[virq].handle_irq</code>函数：这也应该由GIC驱动提供。</p>
<ol start="2">
<li><p>模块的中断处理函数：<br>对于 GPIO 模块向 GIC 发出的中断 B ， 它 的 处 理 函 数 是<code>irq_desc[B].handle_irq</code>。<br>导致 GPIO 中断 B 发生的原因很多，可能是外部设备 1，可能是外部设备n，可能只是某一个设备，也可能是多个设备。所以<code> irq_desc[B].handle_irq</code>会调用链表里的函数，这些函数由外部设备提供。这些函数自行判断该中断是否自己产生，若是则处理。</p>
</li>
<li><p>外部设备提供的处理函数：（也就是<code>action</code>里面的函数）<br> 这里说的“外部设备”可能是芯片，也可能是简单的按键。它们的处理函数由自己驱动程序提供。对于共享中断，比如 GPIO 中断 B，它的中断来源可能有多个，每个中断源对应一个中断处理函数。所以<code> irq_desc[B]</code>中应该有一个链表, 这个链表就是<code> action</code> 链表。一旦程序确定发生了 GPIO 中断 B，那么就会从链表里把那些函数取出来，一一执行。</p>
</li>
</ol>
<h2><span id="1-2-irqaction">1.2 irqaction</span><a href="#1-2-irqaction" class="header-anchor">#</a></h2><p>irqaction 结构体在<code>include/linux/interrupt.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/6.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/7.png" alt="image"></p>
<p><code>irq_desc[A]</code>这里对应的<code>action一般为NULL</code>, 而<code>irq_desc[B]</code>的<code>handle_irq</code>会调用链表里的函数，这些函数就是对应不同的<code>irqaction</code>。</p>
<p>当调用<code>request_irq、request_threaded_irq </code>注册中断处理函数时，内核就会构造一个 <code>irqaction</code> 结构体。在里面保存<code>name、dev_id</code>等，最重要的是 <code>handler、thread_fn、thread</code>。<br>函数原型为：</p>
<h3><span id="1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</span><a href="#1-2-1-request-threaded-irq" class="header-anchor">#</a></h3><h3><span id="1-2-2-request-irq">1.2.2 request_irq</span><a href="#1-2-2-request-irq" class="header-anchor">#</a></h3><h3><span id="1-2-3-devm-request-irq">1.2.3 devm_request_irq</span><a href="#1-2-3-devm-request-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/10.png" alt="image"><br>这里irq编号使用的虚拟中断号，虚拟中断号怎么来？详见后面<code>1.4 irq_domain</code>。</p>
<pre><code>handler ：是中断处理的上半部函数，用来处理紧急的事情。
thread_fn ：对应一个内核线程 thread，当 handler 执行完毕，Linux 内核会唤醒对应的内核线程。在内核线程里，会调用 thread_fn 函数。
</code></pre>
<ol>
<li>可以提供 handler 而不提供 thread_fn，就退化为一般的 <code>request_irq</code> 函数。</li>
<li>可以不提供 handler 只提供 thread_fn，完全由内核线程来处理中断。</li>
<li>也可以既提供 handler 也提供 thread_fn，这就是中断上半部、下半部。</li>
</ol>
<p>在 reqeust_irq 时可以传入 dev_id，为何需要 dev_id？作用有 2：</p>
<ol>
<li>中断处理函数执行时，可以使用 <code>dev_id</code></li>
<li>卸载中断时要传入 <code>dev_id</code>，这样才能在<code>action</code>链表中根据 dev_id 找到对应项（所以在共享中断中必须提供<code> dev_id</code>，非共享中断可以不提供）</li>
</ol>
<h2><span id="1-3-irq-data">1.3 irq_data</span><a href="#1-3-irq-data" class="header-anchor">#</a></h2><p>定义再<code>include/linux/irq.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/11.png" alt="image"><br><code>irq_data</code>就是个中转站，里面有<code> irq_chip</code> 指针 <code>irq_domain </code>指针，<code>irq </code>是软件中断号，<code>hwirq </code>是硬件中断号。<br>比如GPIO 中断 B 就是软件中断号，可以找到<code> irq_desc[B]</code>这个数组项；GPIO 里的第 x 号中断，这就是 <code>hwirq</code>。</p>
<p><code>irq、hwirq </code>之间的联系呢？由 <code>irq_domain </code>来建立。下面介绍<code>irq_domain</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/12.png" alt="image"></p>
<h2><span id="1-4-irq-domain">1.4 irq_domain</span><a href="#1-4-irq-domain" class="header-anchor">#</a></h2><p><code>include/linux/irqdomain.h</code> 中定义该结构。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/13.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/14.png" alt="img"></p>
<p>设备树中你会看到这样的属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">interrupts = &lt;<span class="number">5</span> IRQ_TYPE_EDGE_RISING&gt;;</span><br></pre></td></tr></table></figure>
<p>表示使用<code>gpio1_5</code>作为中断，<code>hwirq </code>就是 5。当我们在驱动中会使用<code> request_irq(irq, handler)</code>这样的函数来注册中断，<code>irq编号</code>就是虚拟中断，那么虚拟中断号（软件中断号）要怎么得到？<br>就是<code>gpio1</code>对应的<code>irq_domain </code>结构体。<code>irq_domain </code>结构体中有一个 <code>irq_domain_ops </code>结构体，里面有各种操作函数。</p>
<h3><span id="1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</span><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/15.png" alt="img"></p>
<p>通过 <code>__irq_domain_add</code> 初始化<code>irq_domain</code>数据结构，然后把 irq_domain 添加到全局的链表<code>irq_domain_list</code>中。</p>
<h3><span id="1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</span><a href="#1-4-1-irq-domain-ops" class="header-anchor">#</a></h3><h4><span id="1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</span><a href="#1-4-1-1-xlate-han-shu" class="header-anchor">#</a></h4><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/16.png" alt="image"></p>
<p><code>xlate</code>函数<br>用来解析设备树的中断属性，提取出 <code>hwirq、type</code> 等信息。</p>
<h4><span id="1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</span><a href="#1-4-1-2-map-han-shu" class="header-anchor">#</a></h4><p>把 <code>hwirq 转换为 irq</code>。</p>
<h2><span id="1-5-irq-chip">1.5 irq_chip</span><a href="#1-5-irq-chip" class="header-anchor">#</a></h2><p><code>irq_chip </code>结构体在<code>include/linux/irq.h</code>中定义</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/17.png" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* @<span class="attr">irq_startup</span>:  start up the interrupt (defaults to -&gt;enable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_shutdown</span>:  shut down the interrupt (defaults to -&gt;disable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_enable</span>:    enable the interrupt (defaults to chip-&gt;unmask <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_disable</span>:  disable the interrupt</span><br><span class="line">* @<span class="attr">irq_ack</span>:    start <span class="keyword">of</span> a <span class="keyword">new</span> interrupt</span><br><span class="line">* @<span class="attr">irq_mask</span>:    mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_mask_ack</span>:  ack and mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_unmask</span>:    unmask an interrupt source</span><br><span class="line">* @<span class="attr">irq_eoi</span>:    end <span class="keyword">of</span> interrupt</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/18.png" alt="在这里插入图片描述"></p>
<p>我们在<code>request_irq</code>后，并不需要手工去使能中断，原因就是系统调用对应的 <code>irq_chip </code>里的<code>irq_enable</code>函数帮我们使能了中断。<br>我们提供的中断处理函数中，也不需要执行主芯片相关的清中断操作，也是系统帮我们调用<code>irq_chip</code>中的相关函数。<br>但是对于外部设备相关的清中断操作，还是需要我们自己做的。就像上面图里的<code>“外部设备 1“、“外部设备 n”</code>，外设备千变万化，内核里没有对应的清除中断操作。</p>
<h1><span id="2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</span><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu" class="header-anchor">#</a></h1><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/19.png" alt="image-20240810191140464"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/" data-id="clzp8uttn007r9ouf29qk11s0" data-title="字符设备驱动-9-中断子系统-中断结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-GICv2架构解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2024-08-06T16:40:22.000Z" itemprop="datePublished">2024-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">字符设备驱动-9-中断子系统-GICv2架构解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</a><ul>
<li><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</a></li>
<li><a href="#1-1-gic-lei-xing">1.1 GIC 类型</a></li>
<li><a href="#1-2-zhong-duan-id">1.2 中断 ID</a></li>
<li><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</a><ul>
<li><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</a></li>
<li><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</a></li>
<li><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</a></li>
<li><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</a></li>
<li><a href="#1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</a></li>
</ul>
</li>
<li><a href="#1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</a></li>
<li><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</a></li>
<li><a href="#1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</a></li>
<li><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</a><ul>
<li><a href="#1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</a><ul>
<li><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</a><ul>
<li><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</a></li>
<li><a href="#1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</a></li>
<li><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</a></li>
<li><a href="#1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</a></li>
<li><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</a></li>
<li><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</a></li>
<li><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</a></li>
<li><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</a></li>
<li><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</a></li>
<li><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</a></li>
<li><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</a></li>
<li><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</a></li>
</ul>
</li>
<li><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</a><ul>
<li><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</a></li>
<li><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</a></li>
<li><a href="#1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</a></li>
<li><a href="#1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</a></li>
<li><a href="#1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</a><ul>
<li><a href="#2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</a></li>
</ul>
</li>
<li><a href="#3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</a><ul>
<li><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</a></li>
<li><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</a></li>
<li><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</a><ul>
<li><a href="#3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</a><ul>
<li><a href="#3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</a></li>
<li><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</a></li>
<li><a href="#3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</a><ul>
<li><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</a></li>
<li><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</a><ul>
<li><a href="#3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</a><ul>
<li><a href="#3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</a><ul>
<li><a href="#3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</a><ul>
<li><a href="#3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</a></li>
</ul>
</li>
<li><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</a><ul>
<li><a href="#4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</a></li>
<li><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</a><ul>
<li><a href="#4-2-1-dts-miao-shu">4.2.1 dts描述</a></li>
<li><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</span><a href="#1-armv7-32-wei-gicv2-jie-shao" class="header-anchor">#</a></h1><p>armv7 32位 gic采用v2版本，参考手册 <a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/bb/?lang=en">https://developer.arm.com/documentation/ihi0048/bb/?lang=en</a></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1-2.png" alt="image"></p>
<p> <code>GIC400 </code>就是v2版本的中断控制器 IP 核，当 GIC 接收到外部中断信号以后就会报给 ARM 内核。框架如下：<br> <img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<p>GIC 架构分为了两个逻辑块：<code>Distributor</code> 和 <code>CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h2><span id="1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</span><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan" class="header-anchor">#</a></h2><ol>
<li><p>分发器用来全局中断使能控制，每一个中断使能开关，中断优先级，外部中断触发方式（边沿触发、电平触发）等。外设-&gt;分发器会设置成<code>pending</code>（或者<code>active and pending</code>状态），这时分发器传递优先级最高的pending中断给cpu 接收端。</p>
</li>
<li><p>cpu接收端用来接收中断信号汇报给cpu, 如：应答中断，通知中断处理完成，定义抢占策略，设置优先级掩码，当多个中断到来选择最高优先级的中断号。</p>
<p> 例如：I.MX6U给了一个<code> core_ca7.h</code>定义了GIC的所有寄存器。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* GIC 寄存器描述结构体，</span></span><br><span class="line"><span class="comment">* GIC 分为分发器端和 CPU 接口端</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 分发器端寄存器 */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED0[<span class="number">1024</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_CTLR; <span class="comment">/* Offset: 0x1000 (R/W) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_TYPER; <span class="comment">/* Offset: 0x1004 (R/ ) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_IIDR; <span class="comment">/* Offset: 0x1008 (R/ ) */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED1[<span class="number">29</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_IGROUPR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1080 - 0x0BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED2[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1100 - 0x13C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED3[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1180 - 0x1BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED4[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1200 - 0x23C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED5[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1280 - 0x2BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED6[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1300 - 0x33C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED7[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1380 - 0x3BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED8[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_IPRIORITYR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1400 - 0x5FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED9[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_ITARGETSR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1800 - 0x9FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED10[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICFGR[<span class="number">32</span>]; <span class="comment">/* Offset: 0x1C00 - 0xC7C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED11[<span class="number">32</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PPISR; <span class="comment">/* Offset: 0x1D00 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_SPISR[<span class="number">15</span>]; <span class="comment">/* Offset: 0x1D04 - 0xD3C (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED12[<span class="number">112</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> D_SGIR; <span class="comment">/* Offset: 0x1F00 ( /W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED13[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_CPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F10 - 0xF1C (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_SPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F20 - 0xF2C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED14[<span class="number">40</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR4; <span class="comment">/* Offset: 0x1FD0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR5; <span class="comment">/* Offset: 0x1FD4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR6; <span class="comment">/* Offset: 0x1FD8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR7; <span class="comment">/* Offset: 0x1FDC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR0; <span class="comment">/* Offset: 0x1FE0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR1; <span class="comment">/* Offset: 0x1FE4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR2; <span class="comment">/* Offset: 0x1FE8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR3; <span class="comment">/* Offset: 0x1FEC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR0; <span class="comment">/* Offset: 0x1FF0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR1; <span class="comment">/* Offset: 0x1FF4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR2; <span class="comment">/* Offset: 0x1FF8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR3; <span class="comment">/* Offset: 0x1FFC (R/ ) */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* CPU 接口端寄存器 */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_CTLR; <span class="comment">/* Offset: 0x2000 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_PMR; <span class="comment">/* Offset: 0x2004 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_BPR; <span class="comment">/* Offset: 0x2008 (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IAR; <span class="comment">/* Offset: 0x200C (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_EOIR; <span class="comment">/* Offset: 0x2010 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_RPR; <span class="comment">/* Offset: 0x2014 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_HPPIR; <span class="comment">/* Offset: 0x2018 (R/ ) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_ABPR; <span class="comment">/* Offset: 0x201C (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AIAR; <span class="comment">/* Offset: 0x2020 (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_AEOIR; <span class="comment">/* Offset: 0x2024 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AHPPIR; <span class="comment">/* Offset: 0x2028 (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED15[<span class="number">41</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_APR0; <span class="comment">/* Offset: 0x20D0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED16[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_NSAPR0; <span class="comment">/* Offset: 0x20E0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED17[<span class="number">6</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IIDR; <span class="comment">/* Offset: 0x20FC (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED18[<span class="number">960</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> C_DIR; <span class="comment">/* Offset: 0x3000 ( /W) */</span></span><br><span class="line">  &#125; GIC_Type;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="1-1-gic-lei-xing">1.1 GIC 类型</span><a href="#1-1-gic-lei-xing" class="header-anchor">#</a></h2><p>GIC 将众多的中断源分为分为三类：<br>①、<code>SPI</code>(<code>Shared Peripheral Interrupt</code>),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断 。<br>②、<code>PPI</code>(<code>Private Peripheral Interrupt)</code>，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。<br>③、<code>SGI</code>(<code>Software-generated Interrupt</code>)，软件中断，由软件触发引起的中断，通过向寄存器<code>GICD_SGIR</code> 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</p>
<h2><span id="1-2-zhong-duan-id">1.2 中断 ID</span><a href="#1-2-zhong-duan-id" class="header-anchor">#</a></h2><p>为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID。每一个 CPU 最多支持 1020 个中断 ID，<code>ID0~ID1019</code> 中断使能和禁止。这 1020 个 ID 包含了 PPI、SPI 和 SGI。</p>
<pre><code>ID0~ID15：这 16 个 ID 分配给 SGI。
ID16~ID31：这 16 个 ID 分配给 PPI。
ID32~ID1019：这 988 个 ID 分配给 SPI。
</code></pre>
<p>例如：I.MX6U 的总共使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 <code>128+32=160</code>，那么irq为0的中断ID即为32。<br>个。NXP 官方 SDK中的文件 <code>MCIMX6Y2C.h</code>定义了160个中断ID。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_INT_VECTORS 160 <span class="comment">/* 中断源 160 个，SGI+PPI+SPI*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">IRQn</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Auxiliary constants */</span></span><br><span class="line">	otAvail_IRQn = <span class="number">-128</span>,</span><br><span class="line">	<span class="comment">/* Core interrupts */</span></span><br><span class="line">	oftware0_IRQn = <span class="number">0</span>, </span><br><span class="line">	oftware1_IRQn = <span class="number">1</span>, </span><br><span class="line">	Software2_IRQn = <span class="number">2</span>, </span><br><span class="line">	Software3_IRQn = <span class="number">3</span>, </span><br><span class="line">	Software4_IRQn = <span class="number">4</span>, </span><br><span class="line">	Software5_IRQn = <span class="number">5</span>, </span><br><span class="line">	Software6_IRQn = <span class="number">6</span>, </span><br><span class="line">	Software7_IRQn = <span class="number">7</span>, </span><br><span class="line">	Software8_IRQn = <span class="number">8</span>, </span><br><span class="line">	Software9_IRQn = <span class="number">9</span>, </span><br><span class="line">	Software10_IRQn = <span class="number">10</span>, </span><br><span class="line">	Software11_IRQn = <span class="number">11</span>, </span><br><span class="line">	Software12_IRQn = <span class="number">12</span>, </span><br><span class="line">	Software13_IRQn = <span class="number">13</span>, </span><br><span class="line">	Software14_IRQn = <span class="number">14</span>, </span><br><span class="line">	Software15_IRQn = <span class="number">15</span>, </span><br><span class="line">	VirtualMaintenance_IRQn = <span class="number">25</span>, </span><br><span class="line">	HypervisorTimer_IRQn = <span class="number">26</span>, </span><br><span class="line">	VirtualTimer_IRQn = <span class="number">27</span>, </span><br><span class="line">	LegacyFastInt_IRQn = <span class="number">28</span>, </span><br><span class="line">	SecurePhyTimer_IRQn = <span class="number">29</span>, </span><br><span class="line">	NonSecurePhyTimer_IRQn = <span class="number">30</span>, </span><br><span class="line">	LegacyIRQ_IRQn = <span class="number">31</span>, </span><br><span class="line">	<span class="comment">/* Device specific interrupts */</span></span><br><span class="line">	IOMUXC_IRQn = <span class="number">32</span>, </span><br><span class="line">	DAP_IRQn = <span class="number">33</span>, </span><br><span class="line">	SDMA_IRQn = <span class="number">34</span>, </span><br><span class="line">	TSC_IRQn = <span class="number">35</span>, </span><br><span class="line">	SNVS_IRQn = <span class="number">36</span>, </span><br><span class="line">	...... ...... </span><br><span class="line">&#125; IRQn_Type;</span><br></pre></td></tr></table></figure>



<h2><span id="1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</span><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</span><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng" class="header-anchor">#</a></h3><p>“<strong>CPSR程序状态寄存器</strong>”已经讲过了，寄存器 CPSR 的 I&#x3D;1 禁止 IRQ，当 I&#x3D;0 使<br>能 IRQ；F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。我们还有更简单的指令来完成 IRQ 或者 FIQ 的使能和<br>禁止:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cpsid i</td>
<td>禁止 IRQ 中断。</td>
</tr>
<tr>
<td>cpsie i</td>
<td>使能 IRQ 中断。</td>
</tr>
<tr>
<td>cpsid f</td>
<td>禁止 FIQ 中断。</td>
</tr>
<tr>
<td>cpsie f</td>
<td>使能 FIQ 中断。</td>
</tr>
</tbody></table>
<h3><span id="1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</span><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi" class="header-anchor">#</a></h3><p>前面讲到中断ID有<code> ID0~ID1019</code>， GIC 寄存器 <code>GICD_ISENABLERn </code>和 <code>GICD_ ICENABLERn </code>用来完成外部中断的使能和禁止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。<br>一共16组<code>GICD_ISENABLER</code>和<code>GICD_ISENABLER</code>，其中<code>GICD_ISENABLER0 </code>的 <code>bit[15:0]</code>对应<code>ID15~0</code> 的 SGI 中断，<code>GICD_ISENABLER0 </code>的 <code>bit[31:16]</code>对应<code>ID31~16</code>的 PPI 中断。剩下的<code>GICD_ISENABLER1~GICD_ISENABLER15 </code>就是控制 SPI 中断的。</p>
<h3><span id="1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</span><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr" class="header-anchor">#</a></h3><p>Cortex-A7 GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高！Cortex-A7 选择了 32 个优先级，<code>GICC_PMR</code> 寄存器，此寄存器用来决定使用几级优先级,<code>GICC_PMR</code> 寄存器只有低 8 位有效，这 8 位最多可以设置 256 个优先级:<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/4.png" alt="image"><br>I.MX6U 为例 Cortex-A7内核，所以支持 32 个优先级，因此 GICC_PMR 要设置为<code> 0b11111000</code>。</p>
<h3><span id="1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</span><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr" class="header-anchor">#</a></h3><p>寄存器 <code>GICC_BPR </code>只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5.png" alt="image"><br>比如 I.MX6U 的优先级位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级。</p>
<h3><span id="1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</span><a href="#1-3-5-zhong-duan-priority-d-ipriorityr" class="header-anchor">#</a></h3><p>Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优先级寄存器，所以一共有 512 个 <code>D_IPRIORITYR </code>寄存器。如果优先级个数为 32 的话，使用寄存器 <code>D_IPRIORITYR 的 bit7:4 </code>来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GICD_IPRIORITYR[<span class="number">40</span>] = <span class="number">5</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</span><a href="#1-4-zhong-duan-zhuang-tai-ji" class="header-anchor">#</a></h2><p>① <strong>非活动状态（Inactive）</strong>：这意味着该中断未触发。 </p>
<p>② <strong>挂起（Pending）</strong>：这意味着中断源已被触发，但正在等待CPU核处理。待处理的中断要通过转发到CPU接口单元，然后再由CPU接口单元转发到内核。</p>
<p>③ <strong>活动（Active）</strong>：描述了一个已被内核接收并正在处理的中断。 </p>
<p>④ <strong>活动和挂起（Active and pending）</strong>：描述了一种情况，其中CPU核正在为中断服务，而GIC又收到来自同一源的中断。</p>
<h2><span id="1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</span><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/6.png" alt="image"></p>
<h2><span id="1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</span><a href="#1-6-gic-zhong-duan-chu-li" class="header-anchor">#</a></h2><p>当CPU核接收到中断时，<code>cpu interface</code>中有<code>Interrupt Acknowledge Register</code>可以读，获取中断ID。并且标记为active状态。</p>
<p>当对应的中断服务程序执行完，会将中断ID写入<code>CPU interface</code>模块中的<code>End of Interrupt register</code>。标记为<code>inactive</code>或<code>pending</code>（如果状态为<code>inactive and pending</code>）。</p>
<h2><span id="1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</span><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><p>前面讲了GIC 架构分为了两个逻辑块：<code>Distributor </code>和<code> CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h3><span id="1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</span><a href="#1-7-1-gic-de-nei-cun-ying-she" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/7.png" alt="image"><br>GIC基地址偏移0x1000是分发器 block, 偏移0x2000是CPU 接口端 block。</p>
<h4><span id="1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</span><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/8.png" alt="image"></p>
<h5><span id="1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</span><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register" class="header-anchor">#</a></h5><p><code>Distributor Control Register</code>，分发器控制寄存器。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/9.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">EnableGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 1中断从Distributor转发到CPU interfaces 0：group 1中断不转发 1：根据优先级规则转发Group 1中断</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">EnableGrp0</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 0中断从Distributor转发到CPU interfaces 0：group 0中断不转发 1：根据优先级规则转发Group 0中断</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</span><a href="#1-7-1-1-2-gicd-typer-controller-type-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">15:11</td>
<td align="left">LSPI</td>
<td align="left">R</td>
<td align="left">如果GIC实现了安全扩展，则此字段的值是已实现的可锁定SPI的最大数量，范围为0（0b00000）到31（0b11111）。 如果此字段为0b00000，则GIC不会实现配置锁定。 如果GIC没有实现安全扩展，则保留该字段。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SecurityExtn</td>
<td align="left">R</td>
<td align="left">表示GIC是否实施安全扩展： 0未实施安全扩展； 1实施了安全扩展</td>
</tr>
<tr>
<td align="left">7:5</td>
<td align="left">CPUNumber</td>
<td align="left">R</td>
<td align="left">表示已实现的CPU interfaces的数量。 已实现的CPU interfaces数量比该字段的值大1。 例如，如果此字段为0b011，则有四个CPU interfaces。</td>
</tr>
<tr>
<td align="left">4:0</td>
<td align="left">ITLinesNumber</td>
<td align="left">R</td>
<td align="left">表示GIC支持的最大中断数。 如果ITLinesNumber &#x3D; N，则最大中断数为32*(N+1)。 中断ID的范围是0到（ID的数量– 1）。 例如：0b00011最多128条中断线，中断ID 0-127。 中断的最大数量为1020（0b11111）。 无论此字段定义的中断ID的范围如何，都将中断ID 1020-1023保留用于特殊目的</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</span><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:24</td>
<td align="left">ProductID</td>
<td align="left">R</td>
<td align="left">产品标识ID</td>
</tr>
<tr>
<td align="left">23:20</td>
<td align="left">保留</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">19:16</td>
<td align="left">Variant</td>
<td align="left">R</td>
<td align="left">通常是产品的主要版本号</td>
</tr>
<tr>
<td align="left">15:12</td>
<td align="left">Revision</td>
<td align="left">R</td>
<td align="left">通常此字段用于区分产品的次版本号</td>
</tr>
<tr>
<td align="left">11:0</td>
<td align="left">Implementer</td>
<td align="left">R</td>
<td align="left">含有实现这个GIC的公司的JEP106代码； [11:8]：JEP106 continuation code，对于ARM实现，此字段为0x4； [7]：始终为0； [6:0]：实现者的JEP106code，对于ARM实现，此字段为0x3B</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</span><a href="#1-7-1-1-4-gicd-igrouprn-group-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Group status bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">组状态位，对于每个位： 0：相应的中断为Group 0； 1：相应的中断为Group 1。</td>
</tr>
</tbody></table>
<p>对于一个中断，如何设置它的Group ？首先找到对应的<code>GICD_IGROUPRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一位。</p>
<p>对于<code>interrtups ID m</code>，如下计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = m DIV <span class="number">32</span>，GICD_IGROUPRn里的n就确定了；</span><br><span class="line">GICD_IGROUPRn在GIC内部的偏移地址是多少？<span class="number">0x080</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</span><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/13.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：使能转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</span><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/14.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：禁止转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</span><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/15.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为active状态，如果中断已处于Active状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ISACTIVERn里的n就确定了；</span><br><span class="line">GICD_ISACTIVERn在GIC内部的偏移地址是多少？0x300+(4*n)</span><br><span class="line">使用GICD_ISACTIVERn 中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</span><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为deactive状态，如果中断已处于dective状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ICACTIVERn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？0x380+(4*n)</span><br><span class="line">使用GICD_ICACTIVERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</span><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/16.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">Priority, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：它的优先级。 每个优先级字段都对应一个优先级值，值越小，相应中断的优先级越高</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">Priority, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">Priority, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">Priority, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的优先级(<code>Priority</code>)，首先找到对应的<code>GICD_IPRIORITYRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">4</span>，GICD_IPRIORITYRn里的n就确定了；</span><br><span class="line">GICD_IPRIORITYRn在GIC内部的偏移地址是多少？<span class="number">0x400</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中<span class="number">4</span>个字节中的哪一个来表示interrtups ID m的优先级？</span><br><span class="line">byte offset = m mod <span class="number">4</span>。</span><br><span class="line">byte offset <span class="number">0</span>对应寄存器里的[<span class="number">7</span>:<span class="number">0</span>]；</span><br><span class="line">byte offset <span class="number">1</span>对应寄存器里的[<span class="number">15</span>:<span class="number">8</span>]；</span><br><span class="line">byte offset <span class="number">2</span>对应寄存器里的[<span class="number">23</span>:<span class="number">16</span>]；</span><br><span class="line">byte offset <span class="number">3</span>对应寄存器里的[<span class="number">31</span>:<span class="number">24</span>]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</span><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/17.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">CPU targets, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：这个中断可以发给哪些CPU。 处理器编号从0开始，8位数里每个位均指代相应的处理器。 例如，值0x3表示将中断发送到处理器0和1。 当读取GICD_ITARGETSR0～GICD_ITARGETSR7时，读取里面任意字节，返回的都是执行这个读操作的CPU的编号。</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">CPU targets, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">CPU targets, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">CPU targets, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的目杯CPU？优先级(<code>Priority</code>)，首先找到对应的<code>GICD_ITARGETSRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 4，GICD_ITARGETSRn里的n就确定了；</span><br><span class="line">GICD_ITARGETSRn在GIC内部的偏移地址是多少？0x800+(4*n)</span><br><span class="line">使用GICD_ITARGETSRn中4个字节中的哪一个来表示interrtups ID m的目标CPU？</span><br><span class="line">byte offset = m mod 4。</span><br><span class="line">byte offset 0对应寄存器里的[7:0]；</span><br><span class="line">byte offset 1对应寄存器里的[15:8]；</span><br><span class="line">byte offset 2对应寄存器里的[23:16]；</span><br><span class="line">byte offset 3对应寄存器里的[31:24]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</span><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/18.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[2F+1:2F]</td>
<td align="left">Int_config, field F</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的2位数据用来描述：它的边沿触发，还是电平触发。 对于Int_config [1]，即高位[2F + 1]，含义为： 0：相应的中断是电平触发； 1：相应的中断是边沿触发。 对于Int_config [0]，即低位[2F]，是保留位。</td>
</tr>
</tbody></table>
<p>如何找到<code>GICD_ICFGRn</code>并确定相应的位域F？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">16</span>，GICD_ICFGRn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？<span class="number">0xC00</span>+(<span class="number">4</span>*n)</span><br><span class="line">F = m mod <span class="number">16</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</span><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/19.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
<tr>
<td align="left">[7:4]</td>
<td align="left">ArchRev</td>
<td align="left">R</td>
<td align="left">该字段的值取决于GIC架构版本： 0x1：GICv1； 0x2：GICv2。</td>
</tr>
<tr>
<td align="left">[3:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
</tbody></table>
<h4><span id="1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</span><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/20.png" alt="image"></p>
<h5><span id="1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</span><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/21.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:10]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[9]</td>
<td align="left">EOImodeNS</td>
<td align="left">R&#x2F;W</td>
<td align="left">控制对GICC_EOIR和GICC_DIR寄存器的非安全访问： 0：GICC_EOIR具有降低优先级和deactivate中断的功能； 对GICC_DIR的访问是未定义的。 1：GICC_EOIR仅具有降低优先级功能； GICC_DIR寄存器具有deactivate中断功能。</td>
</tr>
<tr>
<td align="left">[8:7]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[6]</td>
<td align="left">IRQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的IRQ信号被禁用时，该位控制是否向处理器发送bypass IRQ信号： 0：将bypass IRQ信号发送给处理器； 1：将bypass IRQ信号不发送到处理器。</td>
</tr>
<tr>
<td align="left">[5]</td>
<td align="left">FIQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的FIQ信号被禁用时，该位控制是否向处理器发送bypass FIQ信号： 0：将bypass FIQ信号发送给处理器； 1：旁路FIQ信号不发送到处理器</td>
</tr>
<tr>
<td align="left">[4:1]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">使能CPU interface向连接的处理器发出的组1中断的信号: 0：禁用中断信号 1：使能中断信号</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</span><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/22.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:8]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[7:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">优先级高于这个值的中断，才会发送给CPU</td>
</tr>
</tbody></table>
<p><code>[7:0]</code>共8位，可以表示256个优先级。但是某些芯片里的GIC支持的优先级少于256个，则某些位为RAZ &#x2F; WI，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果有128个级别，则寄存器中bit[0] = 0b0，即使用[7:1]来表示优先级；</span><br><span class="line">如果有64个级别，则寄存器中bit[1:0] = 0b00，即使用[7:2]来表示优先级；</span><br><span class="line">如果有32个级别，则寄存器中bit[2:0] = 0b000，即使用[7:3]来表示优先级；</span><br><span class="line">如果有16个级别，则寄存器中bit[3:0] = 0b0000，即使用[7:4]来表示优先级；</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</span><a href="#1-7-1-2-3-gicc-bpr-binary-point-register" class="header-anchor">#</a></h5><p>此寄存器用来把8位的优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:3]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[2:0]</td>
<td align="left">Binary point</td>
<td align="left">R&#x2F;W</td>
<td align="left">此字段的值控制如何将8bit中断优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。 更多信息还得看看GIC手册。</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</span><a href="#1-7-1-2-4-gicc-iar-acknowledge-register" class="header-anchor">#</a></h5><p>读此寄存器，获得当前中断的<code>interrtup ID</code>。</p>
<p><code>GICC_IAR</code>寄存器描述来自<code>《ARM Generic Interrupt Controller Architecture Specification.pdf》</code>,它用来表示中断ID号。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>处理完具体的中断处理函数，需要将<code>GICC_IAR</code>寄存器的值写入<code>GICC_EOIR</code>寄存器中。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">R</td>
<td align="left">对于SGI类中断，它表示谁发出了中断。例如，值为3表示该请求是通过对CPU interface 3上的GICD_SGIR的写操作生成的。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">Interrupt ID</td>
<td align="left">R</td>
<td align="left">中断ID</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</span><a href="#1-7-1-2-5-gicc-eoir-interrupt-register" class="header-anchor">#</a></h5><p> 写此寄存器，表示某中断已经处理完毕。<code>GICC_IAR</code>的值表示当前在处理的中断，把<code>GICC_IAR</code>的值写入<code>GICC_EOIR</code>就表示中断处理完了。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/24.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">W</td>
<td align="left">对于SGI类中断，它的值跟GICD_IAR. CPUID的相同。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">EOIINTID</td>
<td align="left">W</td>
<td align="left">中断ID，它的值跟GICD_IAR里的中断ID相同</td>
</tr>
</tbody></table>
<h1><span id="2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</span><a href="#2-zhong-duan-shi-li-start-s-fen-xi" class="header-anchor">#</a></h1><p>以nxp的IMX6UL为例，SDK中<code>core_ca7.h</code>定了了GIC相关函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GIC_Init</td>
<td>初始化 GIC。</td>
</tr>
<tr>
<td>GIC_EnableIRQ</td>
<td>使能指定的外设中断。</td>
</tr>
<tr>
<td>GIC_DisableIRQ</td>
<td>关闭指定的外设中断。</td>
</tr>
<tr>
<td>GIC_AcknowledgeIRQ</td>
<td>返回中断号。</td>
</tr>
<tr>
<td>GIC_DeactivateIRQ</td>
<td>无效化指定中断。</td>
</tr>
<tr>
<td>GIC_GetRunningPriority</td>
<td>获取当前正在运行的中断优先级。</td>
</tr>
<tr>
<td>GIC_SetPriorityGrouping</td>
<td>设置抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_GetPriorityGrouping</td>
<td>获取抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_SetPriority</td>
<td>设置指定中断的优先级。</td>
</tr>
<tr>
<td>GIC_GetPriority</td>
<td>获取指定中断的优先级。</td>
</tr>
</tbody></table>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">.global _start  				<span class="comment">/* 全局标号 */</span></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		<span class="comment">/* 复位中断 					*/</span>	</span><br><span class="line">	ldr pc, =Undefined_Handler	<span class="comment">/* 未定义中断 					*/</span></span><br><span class="line">	ldr pc, =SVC_Handler		<span class="comment">/* SVC(Supervisor)中断 		*/</span></span><br><span class="line">	ldr pc, =PrefAbort_Handler	<span class="comment">/* 预取终止中断 					*/</span></span><br><span class="line">	ldr pc, =DataAbort_Handler	<span class="comment">/* 数据终止中断 					*/</span></span><br><span class="line">	ldr	pc, =NotUsed_Handler	<span class="comment">/* 未使用中断					*/</span></span><br><span class="line">	ldr pc, =IRQ_Handler		<span class="comment">/* IRQ中断 					*/</span></span><br><span class="line">	ldr pc, =FIQ_Handler		<span class="comment">/* FIQ(快速中断)未定义中断 			*/</span></span><br><span class="line"><span class="comment">/* 复位中断 */</span>	</span><br><span class="line">Reset_Handler:</span><br><span class="line">	cpsid i						<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line">	<span class="comment">/* 关闭I,DCache和MMU </span></span><br><span class="line"><span class="comment">	 * 采取读-改-写的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">    mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 汇编版本设置中断向量表偏移 */</span></span><br><span class="line">	ldr r0, =<span class="number">0X87800000</span></span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 设置各个模式下的栈指针，</span></span><br><span class="line"><span class="comment">	 * 注意：IMX6UL的堆栈是向下增长的！</span></span><br><span class="line"><span class="comment">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span></span><br><span class="line"><span class="comment">	 * DDR范围:0X80000000~0X9FFFFFFF</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x12</span> 	<span class="comment">/* r0或上0x13,表示使用IRQ模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80600000</span>	<span class="comment">/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SYS模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* r0或上0x13,表示使用SYS模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80400000</span>	<span class="comment">/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br><span class="line">	cpsie i				<span class="comment">/* 打开全局中断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 使能IRQ中断 */</span></span><br><span class="line">	mrs r0, cpsr		<span class="comment">/* 读取cpsr寄存器值到r0中 			*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0x80</span>	<span class="comment">/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0重新写入到cpsr中 			*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	b main				<span class="comment">/* 跳转到main函数 			 	*/</span></span><br><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* SVC中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 数据终止中断 */</span></span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 未使用的中断 */</span></span><br><span class="line">NotUsed_Handler:</span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IRQ中断！重点！！！！！ */</span></span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存lr地址 */</span></span><br><span class="line">	push &#123;r0-r3, r12&#125;			<span class="comment">/* 保存r0-r3，r12寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrs r0, spsr				<span class="comment">/* 读取spsr寄存器 */</span></span><br><span class="line">	push &#123;r0&#125;					<span class="comment">/* 保存spsr寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrc p15, <span class="number">4</span>, r1, c15, c0, <span class="number">0</span> <span class="comment">/* 从CP15的C0寄存器内的值到R1寄存器中</span></span><br><span class="line"><span class="comment">								* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span></span><br><span class="line"><span class="comment">								* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span></span><br><span class="line"><span class="comment">								*/</span>							</span><br><span class="line">	add r1, r1, #<span class="number">0X2000</span>			<span class="comment">/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span></span><br><span class="line">	ldr r0, [r1, #<span class="number">0XC</span>]			<span class="comment">/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span></span><br><span class="line"><span class="comment">								 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span></span><br><span class="line"><span class="comment">								 * 这个中断号来绝对调用哪个中断服务函数</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">	push &#123;r0, r1&#125;				<span class="comment">/* 保存r0,r1 */</span></span><br><span class="line">	</span><br><span class="line">	cps #<span class="number">0x13</span>					<span class="comment">/* 进入SVC模式，允许其他中断再次进去 */</span></span><br><span class="line">	</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存SVC模式的lr寄存器 */</span></span><br><span class="line">	ldr r2, =system_irqhandler	<span class="comment">/* 加载C语言中断处理函数到r2寄存器中*/</span></span><br><span class="line">	blx r2						<span class="comment">/* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* 执行完C语言中断服务函数，lr出栈 */</span></span><br><span class="line">	cps #<span class="number">0x12</span>					<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	pop &#123;r0, r1&#125;				</span><br><span class="line">	str r0, [r1, #<span class="number">0X10</span>]			<span class="comment">/* 中断执行完成，写EOIR */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0&#125;						</span><br><span class="line">	msr spsr_cxsf, r0			<span class="comment">/* 恢复spsr */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0-r3, r12&#125;			<span class="comment">/* r0-r3,r12出栈 */</span></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* lr出栈 */</span></span><br><span class="line">	subs pc, lr, #<span class="number">4</span>				<span class="comment">/* 将lr-4赋给pc */</span></span><br><span class="line"><span class="comment">/* FIQ中断 */</span></span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</span><a href="#2-1-start-s-qi-dong-liu-cheng" class="header-anchor">#</a></h2><ol>
<li>进入<code>_start</code>,初始化异常向量表。进入复位中断，初始化时钟，关闭看门狗，关闭<code>MMU</code>和<code>ICACHE</code> <code>DCACHE</code>,关闭总中断</li>
<li>设置各个模式的<code>SP</code>指针</li>
<li>代码段重定位到DDR上并且清bss段</li>
<li>开启总中断</li>
<li>跳转到C语言main函数执行</li>
</ol>
<p>这里很多流程如代码重定位，清除bss，关闭看门狗等没有列举出来。</p>
<h1><span id="3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</span><a href="#3-gic-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</span><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/25.png" alt="image"></p>
<ul>
<li>假设GIC可以向CPU发出<code>16-1019</code>号中断，这些数字被称为<code>hwirq</code>。<code>0-15</code>用于Process之间通信，比较特殊。</li>
<li>假设要使用UART模块，它发出的中断连接到GIC的32号中断，分配的<code>irq_desc</code>序号为16</li>
<li>在<code>GIC domain</code>中会记录<code>(32, 16)</code></li>
<li>那么注册中断时就是：<code>request_irq(16, ...)</code></li>
<li>发生UART中断时    <ul>
<li>程序从GIC中读取寄存器知道发生了32号中断，通过GIC <code>irq_domain</code>可以知道<code>virq</code>为16</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleA</code>函数，它的作用是调用action链表中用户注册的函数.</li>
</ul>
</li>
</ul>
<h2><span id="3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</span><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/26.png" alt="img"></p>
<ul>
<li>假设GPIO模块下有4个引脚，都可以产生中断，都连接到GIC的33号中断</li>
<li><strong>GPIO也可以看作一个中断控制器</strong>，对于它的4个中断</li>
<li>对于GPIO模块中<code>0~3</code>这四个<code>hwirq</code>，一般都会一下子分配四个<code>irq_desc</code></li>
<li>假设这4个<code>irq_desc</code>的序号为<code>100~103</code>，在<code>GPIO domain</code>中记录<code>(0,100) (1,101)(2,102) (3,103)</code></li>
<li>对于KEY，注册中断时就是：<code>request_irq(102, ...)</code></li>
<li>按下KEY时：    <ul>
<li>程序从GIC中读取寄存器知道发生了33号中断，通过<code>GIC irq_domain</code>可以知道virq为16.</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleB</code>函数      <ul>
<li><code>handleB</code>读取GPIO寄存器，确定是GPIO里2号引脚发生中断</li>
<li>通过GPIO<code> irq_domain</code>可以知道<code>virq</code>为102</li>
<li>调用<code>irq_desc[102]</code>中的<code>handleA</code>函数，它的作用是调用<code>action</code>链表中用户注册的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</span><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_kernel (init\main.c)</span><br><span class="line">    init_IRQ (arch\arm\kernel\irq.c)</span><br><span class="line">    	irqchip_init (drivers\irqchip\irqchip.c)</span><br><span class="line">    		of_irq_init (drivers\of\irq.c)<span class="comment">//gic子系统</span></span><br><span class="line">    			desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">                ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">                            desc-&gt;interrupt_parent);</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</span><a href="#3-3-1-gic-qu-dong-zhu-ce" class="header-anchor">#</a></h3><p>内核支持多种GIC, 在内核为每一类GIC定义一个结构体<code>of_device_id</code>，并放在一个段里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers\irqchip\irq-gic.c</span></span><br><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm11mp_gic, <span class="string">&quot;arm,arm11mp-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm1176jzf_dc_gic, <span class="string">&quot;arm,arm1176jzf-devchip-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a15_gic, <span class="string">&quot;arm,cortex-a15-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a9_gic, <span class="string">&quot;arm,cortex-a9-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a7_gic, <span class="string">&quot;arm,cortex-a7-gic&quot;</span>, gic_of_init);<span class="comment">//imx6ull对应gic类型</span></span><br><span class="line">IRQCHIP_DECLARE(msm_8660_qgic, <span class="string">&quot;qcom,msm-8660-qgic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(msm_qgic2, <span class="string">&quot;qcom,msm-qgic2&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(pl390, <span class="string">&quot;arm,pl390&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>

<p><code> IRQCHIP_DECLARE</code>宏进行展开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include\linux\irqchip.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line"><span class="meta">		_OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line"><span class="meta">	static const struct of_device_id __of_table_##name		\</span></span><br><span class="line"><span class="meta">		__used __section(__irqchip_of_table)			\</span></span><br><span class="line"><span class="meta">		 = &#123; .compatible = compat,				\</span></span><br><span class="line"><span class="meta">		     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>展开后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_cortex_a7_gic</span>		\</span></span><br><span class="line"><span class="class">	__<span class="title">used</span> __<span class="title">section</span>(__<span class="title">irqchip_of_table</span>)			\</span></span><br><span class="line"><span class="class">	 =</span> &#123; .compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>,				\</span><br><span class="line">		 .data = gic_of_init  &#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</span><a href="#3-3-1-1-dts-pi-pei" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/27.png" alt="在这里插入图片描述"></p>
<p>根据dts匹配调用<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>, 对<code>irq chip driver</code> 的声明。</p>
<p>定义 <code>IRQCHIP_DECLARE </code>之后，相应的内容会保存到 <code>__irqchip_of_table </code>里。<code>__irqchip_of_table </code>在链接脚本 <code>vmlinux.lds </code>里，被放到了<code>__irqchip_begin</code>和 <code>__irqchip_of_end</code> 之间，该段用于存放中断控制器信息。</p>
<h4><span id="3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</span><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou" class="header-anchor">#</a></h4><p><code>gic_of_init</code>内容太多，大致就是对中断控制器初始化：</p>
<ol>
<li><p>初始化<code>GICD</code>(分发器寄存器)</p>
</li>
<li><p>初始化<code>GICC</code>(cpu接口端寄存器)</p>
</li>
<li><p>调用<code>gic_init_bases</code> 流程</p>
<ol>
<li><p>调用<code>set_handle_irq</code>注册<code>gic_handle_irq</code>,异常处理的入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">set_handle_irq</span><span class="params">(<span class="type">void</span> (*handle_irq)(<span class="keyword">struct</span> pt_regs *))</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (handle_arch_irq)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> handle_arch_irq = handle_irq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">void</span> __iomem *dist_base,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> redist_region *rdist_regs,</span></span><br><span class="line"><span class="params">     u32 nr_redist_regions,</span></span><br><span class="line"><span class="params">     u64 redist_stride,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> fwnode_handle *handle)</span> &#123;</span><br><span class="line"> set_handle_irq(gic_handle_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4><span id="3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</span><a href="#3-3-1-3-shen-qing-gic-zhong-duan" class="header-anchor">#</a></h4><h5><span id="3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</span><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/28.png" alt="image-20240809003246767"></p>
<h5><span id="3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</span><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/29.png" alt="在这里插入图片描述"></p>
<h2><span id="3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</span><a href="#3-4-gic-zhong-duan-chu-guo-cheng" class="header-anchor">#</a></h2><ol>
<li>进入中断栈<code>irq_stack_entry</code></li>
<li>执行中断控制器的中断入口<code>handle_arch_irq</code></li>
<li>退出中断栈<code>irq_stack_exit</code></li>
</ol>
<p>中断栈用来保存中断的上下文，中断发生和退出的时候调用 <code>irq_stack_entry </code>和 <code>irq_stack_exit </code>来进入和退出中断栈。</p>
<h3><span id="3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</span><a href="#3-4-1-handle-arch-irq-ru-kou" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/30.png" alt="image-20240810150555648"></p>
<h4><span id="3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</span><a href="#3-4-1-1-gic-handle-irq" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> asmlinkage <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span>&#123;</span><br><span class="line"> u32 irqnr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  irqnr = gic_read_iar();                                     ------(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1020</span>) || irqnr &gt;= <span class="number">8192</span>) &#123;  ------(<span class="number">2</span>)</span><br><span class="line">   <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    isb();</span><br><span class="line"></span><br><span class="line">   err = handle_domain_irq(gic_data.domain, irqnr, regs);    ------(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected interrupt received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (irqnr &lt; <span class="number">8192</span>)</span><br><span class="line">      gic_write_dir(irqnr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     gic_write_eoir(irqnr);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;                                          ------(<span class="number">4</span>)</span><br><span class="line">   gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_dir(irqnr);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Unlike GICv2, we don&#x27;t need an smp_rmb() here.</span></span><br><span class="line"><span class="comment">    * The control dependency from gic_read_iar to</span></span><br><span class="line"><span class="comment">    * the ISB in gic_write_eoir is enough to ensure</span></span><br><span class="line"><span class="comment">    * that any shared data read by handle_IPI will</span></span><br><span class="line"><span class="comment">    * be read after the ACK.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   handle_IPI(irqnr, regs);                                ------(<span class="number">5</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected SGI received!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (irqnr != ICC_IAR1_EL1_SPURIOUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>读取中断控制器的寄存器<code>GICC_IAR</code>，并获取 <code>hwirq</code></li>
<li>外设触发的中断。硬件中断号<code>0-15</code>表示 <code>SGI (软件中断)</code>类型的中断，<code>15-1020 </code>表示外设中断（SPI或PPI共享中断类型），<code>8192-MAX </code>表示 LPI 类型的中断</li>
<li>中断控制器中断处理的主体</li>
<li>软件触发的中断</li>
<li>核间交互触发的中断</li>
</ol>
<h5><span id="3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</span><a href="#3-4-1-1-1-handle-domain-irq" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/31.png" alt="image-20240810151815454"></p>
<ol>
<li>进入中断上下文</li>
<li>根据 <code>hwirq</code> 去查找 linux 中断号</li>
<li>通过中断号找到全局中断描述符数组<code>irq_desc[NR_IRQS]</code>中的一项，然后调用<code> generic_handle_irq_desc</code>，执行该 irq 号注册的<code> action</code></li>
<li>退出中断上下文</li>
</ol>
<h6><span id="3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</span><a href="#3-4-1-1-1-1-generic-handle-irq" class="header-anchor">#</a></h6><p>把<code>generic_handle_irq</code>展开：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32.png" alt="image-20240810151917713"></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32-1.png" alt="image-20240810152019303"></p>
<p>调用 <code>desc-&gt;handle_irq </code>指向的回调函数。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/33.png" alt="image-20240810152332559"></p>
<p><code>irq_domain_set_info</code> 根据硬件中断号的范围设置 <code>irq_desc-&gt;handle_irq </code>的指针，共享中断入口为<code> handle_fasteoi_irq</code>，私有中断入口为 <code>handle_percpu_devid_irq</code>。</p>
<ul>
<li><code>handle_percpu_devid_irq</code>：处理私有中断处理，在这个过程中会分别调用中断控制器的处理函数进行硬件操作，该函数调用 <code>action-&gt;handler()</code> 来进行中断处理</li>
<li><code>handle_fasteoi_irq</code>：处理共享中断，并且遍历 <code>irqaction</code> 链表，逐个调用 <code>action-&gt;handler() </code>函数，这个函数正是设备驱动程序调用 <code>request_irq/request_threaded_irq </code>接口注册的中断处理函数，此外如果中断线程化处理的话，还会调用<code>__irq_wake_thread</code>唤醒内核线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags) &#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">    for_each_action_of_desc(desc, action) &#123;            </span><br><span class="line">        <span class="type">irqreturn_t</span> res;</span><br><span class="line">        res = action-&gt;handler(irq, action-&gt;dev_id);<span class="comment">//requst_irq注册的函数</span></span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            __irq_wake_thread(desc, action);          </span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            *flags |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</span><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/34.png" alt="image-20240810152452686"></p>
<h1><span id="4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</span><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu" class="header-anchor">#</a></h1><p>中断控制器而言 ，设备树绑定信息参考文档<code>Documentation/devicetree/bindings/arm/gic.txt</code>。以nxp的<code>imx6ull.dtsi</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">	&lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol>
<li><code>compatible</code> 属性值为<code>“arm,cortex-a7-gic”</code>在 Linux 内核源码中搜索<code>“arm,cortex-a7-gic”</code>即可找到 GIC 中断控制器驱动文件， GIC 中断控制器驱是架构通用的，在<code>drivers/irqchip/irq-gic.c</code></li>
<li><code>interrupt-cells </code>和<code>#address-cells、#size-cells </code>一样。<br> 2.1 每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一个 cells：中断类型，<span class="number">0</span> 表示 SPI(共享) 中断，<span class="number">1</span> 表示 PPI（私有） 中断。</span><br><span class="line">第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 <span class="number">0</span>~<span class="number">987</span>，对于PPI</span><br><span class="line">       中断来说中断号的范围为 <span class="number">0</span>~<span class="number">15</span>。</span><br><span class="line">第三个 cells：标志，bit[<span class="number">3</span>:<span class="number">0</span>]表示中断触发类型，为 <span class="number">1</span> 的时候表示上升沿触发，</span><br><span class="line">       为 <span class="number">2</span> 的时候表示下降沿触发，为 <span class="number">4</span> 的时候表示高电平触发，为 <span class="number">8</span> 的时候表示低</span><br><span class="line">       电平触发。bit[<span class="number">15</span>:<span class="number">8</span>]为 PPI 中断的 CPU 掩码。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>interrupt-controller</code>表示该节点中断控制器</li>
</ol>
<p>对于gpio来说也可以作为中断控制器，如imx6ull的<code>gpio5</code>：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/35.png" alt="image"><br>对于 gpio5 来说一共有两条信息，中断类型都是 SPI，<br>触发电平都是<code> IRQ_TYPE_LEVEL_HIGH</code>。不同之处在于中断源，一个是 74，一个是 75，打开可以打开《IMX6ULL 参考手册》的<code>“Chapter 3 Interrupts and DMA Events”</code>章节：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/36.png" alt="image"><br>GPIO5 一共用了 2 个中断号，一个是 74，一个是 75。其中 74 对应<code>GPIO5_IO00~GPIO5_IO15</code>这低 16 个 IO，75 对应 <code>GPIO5_IO16~GPIOI5_IO31 </code>这高 16 位 IO。</p>
<p>使用者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fxls8471</code> 有一个中断引脚链接到了 I.MX6ULL 的<code>SNVS_TAMPER0</code>因脚上，这个引脚可以复用为<code>GPIO5_IO00 interrupts</code>设置中断信息，0 表示 <code>GPIO5_IO00</code>，8 表示低电平触发。</p>
<h2><span id="4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</span><a href="#4-1-huo-qu-zhong-duan-hao-han-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_of_parse_and_map</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_create_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hwirq)</span>;</span><br></pre></td></tr></table></figure>

<p><code>irq_of_parse_and_map </code>函数从 interupts 属性中提取到对应的设备号，<br>dev：设备节点。<br>index：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br>返回值：中断号。</p>
<h2><span id="4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</span><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan" class="header-anchor">#</a></h2><h3><span id="4-2-1-dts-miao-shu">4.2.1 dts描述</span><a href="#4-2-1-dts-miao-shu" class="header-anchor">#</a></h3><p>我们驱动一个按键，采用中断的方式，并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key &#123;</span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-key&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">	key-gpio = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="comment">/* KEY0 */</span></span><br><span class="line">	interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;; <span class="comment">/* FALLING RISING */</span></span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到key使用<code>key-gpio</code>使用<code>GPIO1_IO18</code>, 可以看到也用到了gpio中断源interrupts，<code>IRQ_TYPE_EDGE_BOTH</code>定义在<code>include/linux/irq.h：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	IRQ_TYPE_NONE = <span class="number">0x00000000</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_RISING = <span class="number">0x00000001</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_FALLING = <span class="number">0x00000002</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING |</span><br><span class="line">		IRQ_TYPE_EDGE_RISING),</span><br><span class="line">	IRQ_TYPE_LEVEL_HIGH = <span class="number">0x00000004</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_LOW = <span class="number">0x00000008</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW |</span><br><span class="line">		IRQ_TYPE_LEVEL_HIGH),</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</span><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi" class="header-anchor">#</a></h3><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> <span class="title">imx6uirq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	imx6uirq.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);</span><br><span class="line">		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);	</span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		printk(<span class="string">&quot;key%d:gpio=%d, irqnum=%d\r\n&quot;</span>,i, imx6uirq.irqkeydesc[i].gpio,</span><br><span class="line">                                         imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum, imx6uirq.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	init_timer(&amp;imx6uirq.timer);</span><br><span class="line">	imx6uirq.timer.function = timer_function;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;imx6uirq;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span></span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.major) &#123;</span><br><span class="line">		imx6uirq.devid = MKDEV(imx6uirq.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;imx6uirq.devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		imx6uirq.major = MAJOR(imx6uirq.devid);</span><br><span class="line">		imx6uirq.minor = MINOR(imx6uirq.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);</span><br><span class="line">	cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	imx6uirq.class = class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.class);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.device = device_create(imx6uirq.class, <span class="literal">NULL</span>, imx6uirq.devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="number">0</span>);</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;imx6uirq.timer);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);</span><br><span class="line">		gpio_free(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_del(&amp;imx6uirq.cdev);</span><br><span class="line">	unregister_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(imx6uirq.class, imx6uirq.devid);</span><br><span class="line">	class_destroy(imx6uirq.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
分析：
![image](字符设备驱动-9-中断子系统-GICv2架构解析/37.png)
从key节点取出key-gpio,得到gpio编号
调用gpio请求配置函数，配成input模式
根据key节点信息解析出中断号，或者gpio编号转成中断号.（这里用到一个函数`irq_of_parse_and_map`)
注册中断
创建定时器用来消抖

<p>中断响应过程：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/38.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/39.png" alt="image"><br>按键按下或松开，中断产生调用<code>key0_handler</code>，修改定时器超时10ms, 如果是抖动那么，定时器中断那么不会触发（原理请参考[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器 - fuzidage - 博客园 (cnblogs.com)</a>]</p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器 | Hexo (fuzidage.github.io)</a>，只有当不是抖动真正按下或松开，定时器中断触发进行读取按键，原子操作设置键值。releasekey置1表示一次完整的按下松开。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/40.png" alt="image"><br>最后用户调用read, 返回键值。可见releasekey很好的控制着按键按下和read的次数，比如当连续read 2次但是只按了一次，则读取失败。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/41.png" alt="image"></p>
<p>硬中断和虚拟中断号的映射关系可以用 <code>/proc/interrupts </code>查看：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/42.png" alt="img"></p>
<p>通过 ps 命令可以查看系统中的中断线程，注意这些线程是实时线程 <code>SCHED_FIFO</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ps -A | grep &quot;irq/&quot;</span><br><span class="line">root          1749     2       0      0 irq_thread          0 S [irq/433-imx_drm]</span><br><span class="line">root          1750     2       0      0 irq_thread          0 S [irq/439-imx_drm]</span><br><span class="line">root          1751     2       0      0 irq_thread          0 S [irq/445-imx_drm]</span><br><span class="line">root          1752     2       0      0 irq_thread          0 S [irq/451-imx_drm]</span><br><span class="line">root          2044     2       0      0 irq_thread          0 S [irq/279-isl2902]</span><br><span class="line">root          2192     2       0      0 irq_thread          0 S [irq/114-mmc0]</span><br><span class="line">root          2199     2       0      0 irq_thread          0 S [irq/115-mmc1]</span><br><span class="line">root          2203     2       0      0 irq_thread          0 S [irq/322-5b02000]</span><br><span class="line">root          2361     2       0      0 irq_thread          0 S [irq/294-4-0051]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" data-id="clzp8uttf003w9oufbtsy2cmd" data-title="字符设备驱动-9-中断子系统-GICv2架构解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断引入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2024-08-05T15:50:47.000Z" itemprop="datePublished">2024-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</a></li>
<li><a href="#2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</a><ul>
<li><a href="#2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</a><ul>
<li><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</a></li>
</ul>
</li>
<li><a href="#2-2-gic-gai-shu">2.2 GIC概述</a></li>
<li><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</a><ul>
<li><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</a></li>
<li><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</a></li>
</ul>
</li>
<li><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</a><ul>
<li><a href="#2-4-1-ying-zhong-duan">2.4.1 硬中断</a></li>
<li><a href="#2-4-2-ruan-zhong-duan">2.4.2 软中断</a><ul>
<li><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</a></li>
<li><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</a><ul>
<li><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</a></li>
<li><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</a></li>
<li><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</a></li>
</ul>
</li>
<li><a href="#2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</a><ul>
<li><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</a></li>
<li><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</a></li>
<li><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</a></li>
<li><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</a></li>
</ul>
</li>
<li><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</a><ul>
<li><a href="#2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</a></li>
<li><a href="#2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</a></li>
<li><a href="#2-6-3-threaded-irq">2.6.3 threaded irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</span><a href="#1-zhong-duan-yu-yi-chang-chong-lei" class="header-anchor">#</a></h1><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png" alt="image"><br>CPU 在运行的过程中，也会被各种<code>“异常”</code>打断。这些<code>“异常”</code>有：</p>
<ol>
<li>指令未定义</li>
<li>Reset复位</li>
<li>指令、数据访问有问题</li>
<li>SWI(软中断)</li>
<li>快中断</li>
<li>IRQ中断</li>
</ol>
<p>IRQ中断只是一种（一类）异常而已。导致中断发生的情况有很多，比如：</p>
<ol>
<li>按键</li>
<li>定时器</li>
<li>ADC 转换完成</li>
<li>UART 发送完数据、收到数据</li>
</ol>
<p>这些众多的<code>“中断源”</code>，汇集到<code>“中断控制器”</code>，由<code>“中断控制器”</code>选择优先级最高的中断并通知 CPU。如上图所示：</p>
<h1><span id="2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</span><a href="#2-zhong-duan-de-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>arm 对异常(中断)处理过程：</p>
<ol>
<li>初始化：<br> a) 设置<strong>中断源</strong>，让它可以产生中断<br> b) 设置<strong>中断控制器</strong>(可以屏蔽某个中断，优先级)<br> c) 设置 <strong>CPU 总开关(使能中断)</strong></li>
<li>执行其他程序：正常程序</li>
<li>产生中断：比如按下按键（中断源发出中断请求）—&gt;中断控制器—&gt;CPU</li>
<li>CPU 每执行完一条指令都会检查有无中断&#x2F;异常产生</li>
<li>CPU 发现有中断&#x2F;异常产生，开始处理。</li>
</ol>
<p>对于不同的异常，跳去不同的地址执行程序。这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。③④⑤都是硬件做的。③是中断源来做，④⑤是cpu来做</p>
<p>综上5个过程，软件要做的事情:<br>a) 保存现场(各种寄存器)<br>b) 处理异常(中断): 从<strong>异常向量表</strong>跳到不同的异常向量去执行，分辨中断源，再调用不同的处理函数<br>c) 恢复现场</p>
<h2><span id="2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</span><a href="#2-1-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>可以参考我之前写的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="异常向量表">s3c2440裸机-异常中断（一. 异常、中断的原理与流程）</a> 介绍了异常向量表。<br>uboot中就有大量类似这种的异常向量表，不同系列芯片每个异常的偏移地址会有所不同。下图以s3c2440芯片为例：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/2.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/3.png" alt="image"></p>
<table>
<thead>
<tr>
<th>向量地址</th>
<th>中断类型</th>
<th>中断模式</th>
</tr>
</thead>
<tbody><tr>
<td>0X00</td>
<td>复位中断(Rest)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X04</td>
<td>未定义指令中断(Undefined Instruction)</td>
<td>未定义指令中止模式(Undef)</td>
</tr>
<tr>
<td>0X08</td>
<td>软中断(Software Interrupt,SWI)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X0C</td>
<td>指令预取中止中断(Prefetch Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X10</td>
<td>数据访问中止中断(Data Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X14</td>
<td>未使用(Not Used)</td>
<td>未使用</td>
</tr>
<tr>
<td>0X18</td>
<td>IRQ</td>
<td>中断(IRQ Interrupt)</td>
</tr>
<tr>
<td>0X1C</td>
<td>FIQ</td>
<td>中断(FIQ Interrupt)</td>
</tr>
</tbody></table>
<p>这就是异常向量表，每一条指令对应一种异常。<br>发生复位时，CPU 就去 执行第 1 条指令：<code>b reset</code>。<br>发生中断时，CPU 就去执行<code>“ldr pc, _irq”</code>这条指令。这些指令存放的位置是固定的，比如对于ARM9芯片中断向量的地址是<code>0x18</code>。当发生中断时，CPU 就强制跳去执行 <code>0x18 </code>处的代码。</p>
<h3><span id="2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</span><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base" class="header-anchor">#</a></h3><p>在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU 就会执行向量表中的跳转指令，去调用更复杂的函数。当然，向量表的位置并不总是从 0 地址开始，很多芯片可以设置某个 <code>vector base </code>寄存器，指定向量表在其他位置，比如imx6ull芯片设置 <code>vector base </code>为 <code>0x80000000</code>，指定为 DDR 的某个地址。但是表中的各个异常向量的偏移地址，是固定的：复位向量偏移地址是 0，中断是 0x18。</p>
<h2><span id="2-2-gic-gai-shu">2.2 GIC概述</span><a href="#2-2-gic-gai-shu" class="header-anchor">#</a></h2><p>对于 ARM 的中断控制器，述语上称之为<code> GIC (Generic Interrupt Controller)</code>，到目前已经更新到 v4 版本了。在STM32叫做<code>NVIC</code>(内嵌向量中断控制器 <code>Nested Vectored Interrupt Controller</code>)<br>简单地说，<code>GIC v3/v4</code> 用于 <code>ARMv8</code> 架构，即 64 位 ARM 芯片。<br>而 <code>GIC v2</code> 用于<code> ARMv7</code> 和其他更低的32位架构。v2架构下一节：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析</a> 会展开细说。</p>
<p>v8架构是在32位ARM架构上进行开发的，将被首先用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域，如企业应用、高档消费电子产品。<code>ARMv8</code>架构包含两个执行状态：<code>AArch64</code>和<code>AArch32</code>。<code>AArch64</code>执行状态针对64位处理技术，引入了一个全新指令集A64；而<code>AArch32</code>执行状态将支持现有的ARM指令集。</p>
<h2><span id="2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</span><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan" class="header-anchor">#</a></h2><p>中断当前正在运行的进程、线程。进程、线程是什么？内核如何切换进程、线程、中断？要理解这些概念，必须理解栈的作用。</p>
<p>进程是资源分配的基本单位，线程是调度的基本单位。<br>    比如全局变量a, 对不同线程它是共享的，但是这个资源a是属于该进程独立的资源，对其他进程是不可见的。<br>    一个进程可以包含多个线程，线程有自己的栈空间，也就是局部变量。</p>
<h3><span id="2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</span><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng" class="header-anchor">#</a></h3><p>ARM 芯片属于精简指令集计算机(<code>RISC：Reduced Instruction Set  Computing</code>)，它所用的指令比较简单，有如下特点：</p>
<pre><code>对内存只有读、写指令
对于数据的运算是在 CPU 内部实现
使用 RISC 指令的 CPU 复杂度小一点，易于设计
</code></pre>
<p>比如对于<code>a=a+b</code>这样的算式，需要经过下面 4 个步骤才可以实现：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/4.png" alt="image"><br>我们先忽略各种 CPU 模式(系统模式、用户模式等等)。详细过程如下：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/5.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [a]</span><br><span class="line">LDR R1, [b]</span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">STR R0, [a]</span><br><span class="line">/*翻译如下：</span><br><span class="line">把内存 a 的值读入 CPU 寄存器 R0</span><br><span class="line">把内存 b 的值读入 CPU 寄存器 R1</span><br><span class="line">把 R0、R1 累加，存入 R0</span><br><span class="line">把 R0 的值写入内存 a*/</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</span><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang" class="header-anchor">#</a></h3><p>当进行函数调用跳转到下一个函数，又或者中断一个程序，就需要把这些寄存器的值保存下来：这就称为<strong>保存现场</strong>。保存的寄存器那块内存就称为栈空间。<br>当跳转的函数执行完成，就需要从栈中恢复那些 CPU 内部寄存器的值，这一出栈的过程也被叫做<strong>“恢复现场”</strong>。</p>
<p><strong>①函数调用：</strong></p>
<pre><code>1.在函数 A 里调用函数 B，实际就是中断函数 A 的执行。
2.那么需要把函数 A 调用 B 之前瞬间的 CPU 寄存器的值，保存到栈里
</code></pre>
<p><strong>②中断处理：</strong></p>
<pre><code>a) 进程 A 正在执行，这时候发生了中断。
b) CPU 强制跳到中断异常向量地址去执行，
c) 这时就需要保存进程 A 被中断瞬间的 CPU 寄存器值，
d) 可以保存在进程 A 的内核态栈，也可以保存在进程 A 的内核结构体中。
e) 中断处理完毕，要继续运行进程 A 之前，恢复这些值
</code></pre>
<p><strong>③进程切换：</strong><br>进程 A 的时间用完了，就切换到进程 B。怎么切换？切换过程是发生在内核态里的，跟中断的处理类似。<br>a) 进程 A 被切换瞬间的 CPU 寄存器值保存在某个地方；<br>b) 恢复进程 B 之前保存的 CPU 寄存器值，这样就可以运行进程 B 了。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/6.png" alt="image"><br>总结有3种场景会要用到栈去保存和恢复现场：</p>
<p>①函数调用，②进程切换，③中断过程。<strong>进程调度核心就是靠定时器中断来实现</strong>。</p>
<h2><span id="2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</span><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><h3><span id="2-4-1-ying-zhong-duan">2.4.1 硬中断</span><a href="#2-4-1-ying-zhong-duan" class="header-anchor">#</a></h3><p>硬件产生的中断，称之为<code>“硬件中断”</code>(<code>hard irq</code>)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断，定时器中断的处理函数肯定不一样。<br>为方便理解，可以先认为对硬件中断的处理是用数组来实现的，数组里存放的是函数指针：一个中断号对应一个中断服务函数<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/7.png" alt="image"></p>
<h3><span id="2-4-2-ruan-zhong-duan">2.4.2 软中断</span><a href="#2-4-2-ruan-zhong-duan" class="header-anchor">#</a></h3><p>相对的，还可以人为地制造中断：软件中断(<code>soft irq</code>)，如下图所示：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/8.png" alt="image"></p>
<ol>
<li>软件中断何时生产？<br> 由软件决定，对于 X 号软件中断，只需要把它的 flag 设置为 1 就表示发生了该中断。</li>
<li>软件中断何时处理？<br> 软件中断嘛，并不是那么十万火急，有空再处理它好了,因此一般软件中断是硬件中断处理完后，顺便来处理软件中断。</li>
<li>有哪些软件中断？</li>
</ol>
<h4><span id="2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</span><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing" class="header-anchor">#</a></h4><p>查内核源码<code> include/linux/interrupt.h</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/9.png" alt="image"><br>怎么设置使用软中断，比如<code>tasklet </code>（后面会讲中断上半部分， 和中断下半部分）就是使用软件中断实现的。还有<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器</a>也是利用软中断实现的。</p>
<p>总结使用软中断的类型有:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优先级为<span class="number">0</span>，HI_SOFTIRQ，高优先级的tasklet</span><br><span class="line">优先级为<span class="number">1</span>，定时器软中断</span><br><span class="line">发送网络数据包的软中断</span><br><span class="line">接受网络数据包的软中断</span><br><span class="line">块设备的软中断</span><br><span class="line">优先级为<span class="number">0</span>，tasklet，低优先级的tasklet</span><br><span class="line">进程调度和负载均衡</span><br><span class="line">高进度定时器</span><br><span class="line">RCU</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</span><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong" class="header-anchor">#</a></h4><h5><span id="2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</span><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如网络发包对应类型为<code>NET_TX_SOFTIRQ</code>的处理函数<code>net_tx_action</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/core/dev.c</span></span><br><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</span><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11.png" alt="image"><br>  最核心的函数是 <code>raise_softirq</code>，简单地理解就是设置<code> softirq_veq[nr]</code>的标记位，设置后表示使能该软中断号。</p>
<h5><span id="2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</span><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq" class="header-anchor">#</a></h5><p>每个 CPU 上会初始化一个 <code>ksoftirqd</code> 内核线程，负责处理各种类型的 <code>softirq </code>中断事件:</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-1.png" alt="image-20240810221847189"></p>
<p>当注册软中断使能后，<code>ksoftirqd</code> 线程，执行<code>pending</code>的软中断。<code>ksoftirqd</code> 里面会进一步调用到 <code>__do_softirq</code>。</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-2.png" alt="image-20240810223529233"></p>
<p>可以看到软中断执行，硬件中断是使能的。遍历使能的<code>softlrq</code>,执行对应的<code>action</code>函数。</p>
<h3><span id="2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</span><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/12.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/13.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                  CPU0     CPU1  ...    CPU46    CPU47</span><br><span class="line">          HI:        2        0  ...        0        1</span><br><span class="line">       TIMER:   443727   467971  ...   313696   270110</span><br><span class="line">      NET_TX:    57919    65998  ...    42287    54840</span><br><span class="line">      NET_RX:    28728  5262341  ...    81106    55244</span><br><span class="line">       BLOCK:      261     1564  ...   268986   463918</span><br><span class="line">    IRQ_POLL:        0        0  ...        0        0</span><br><span class="line">     TASKLET:       98      207  ...      129      122</span><br><span class="line">       SCHED:  1854427  1124268  ...  5154804  5332269</span><br><span class="line">     HRTIMER:    12224    68926  ...    25497    24272</span><br><span class="line">         RCU:  1469356   972856  ...  5961737  5917455</span><br></pre></td></tr></table></figure>

<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</span><a href="#2-5-zhong-duan-chu-li-yuan-ze" class="header-anchor">#</a></h2><h3><span id="2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</span><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao" class="header-anchor">#</a></h3><p>中断 A 正在处理的过程中，假设又发生了中断 B，那么在栈里要保存 A 的现场，然后处理 B。在处理 B 的过程中又发生了中断 C，那么在栈里要保存 B 的现场，然后处理C。<br>如果中断嵌套突然暴发，那么栈将越来越大，栈终将耗尽。<br>为了防止这种情况发生，也是为了简单化中断的处理，在 Linux 系统上规定中断无法嵌套：即当前中断 A 没处理完之前，不会响应另一个中断 B(即使它的优先级更高)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br></pre></td></tr></table></figure>
<h3><span id="2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</span><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao" class="header-anchor">#</a></h3><p>在单核心芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。</p>
<h3><span id="2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</span><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu" class="header-anchor">#</a></h3><p>当处理某个中断要做的事情就是很多，没办法加快。比如对于按键中断，我们需要等待几十毫秒消除机械抖动。难道要在<code>irq_handler</code> 中等待吗？对于计算机来说，这可是一个段很长的时间。又比如图像处理中，当一个硬件IP处理完成一张图像的操作，那么对这张图像的后处理操作难道要放在中断服务中来操作嘛，显然这个耗时是非常久的。<br>那么中断操作切分为中断上半部、下半部。上半部分关中断，清中断执行关键紧急的事情，下半部分去处理耗时久的事情，如下图：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/14.png" alt="image"><br>中断下半部的实现有很多种方法： ①<code>tasklet</code>(小任务)、②<code>work queue</code>(工作队列)， ③<code>threaded irq</code>等。</p>
<h3><span id="2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</span><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian" class="header-anchor">#</a></h3><p>中断上半部、下半部的执行过程中，不能休眠：中断休眠的话，以后谁来调度进程啊？</p>
<h2><span id="2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</span><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa" class="header-anchor">#</a></h2><h3><span id="2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</span><a href="#2-6-1-xiao-ren-wu-tasklet" class="header-anchor">#</a></h3><p><code>tasklet</code> 是使用软中断来实现的：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/15.png" alt="image"><br><strong>中断上半部和下半部的处理流程：</strong><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/16.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/17.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 中断源产生中断，执行irq_enter(), 最开始preempt_count=<span class="number">0</span>，preempt_count++后为<span class="number">1</span>, </span><br><span class="line">	generic_handle_irq中会找到该中断源对应的中断服务程序</span><br><span class="line"><span class="number">2.</span> 执行irq函数，执行中断上半部，（注意执行上半部分时是无法被中断的，调用了local_irq_disable()）</span><br><span class="line"><span class="number">3.</span> irq_exit(),preempt_count-- 后为<span class="number">0</span>，</span><br><span class="line"><span class="number">4.</span> 判断preempt_count是否等于<span class="number">0</span>，此时等于<span class="number">0</span>，也就是执行下半部分，也叫做软中断流程</span><br><span class="line"><span class="number">5.</span> 下半部过程中会对preempt_count++，开始软件中断</span><br><span class="line"><span class="number">6.</span> 由于是软件中断，开总中断，允许其他的硬件中断响应local_irq_enable();</span><br><span class="line"><span class="number">7.</span> 根据软中断号找到服务函数，执行所谓的中断下半部分（可以进行耗时的一些操作，因为有使能中断）</span><br><span class="line"><span class="number">8.</span> 下半部分执行完后，local_irq_disable()</span><br><span class="line"><span class="number">9.</span> preempt_count--，preempt_count又回到<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上半部中断（硬件中断）有<code>local_irq_disable()</code>，中断是不允许被另一个中断打断的。而下半部（软件中断）时中断是开的，它可以被其他中断打断<code>local_irq_enable()</code>。</p>
<p>那么软中断（下半部）A还没有执行到<code>⑨preempt_count--</code>，当被其他中断B打断时，又执行<code>①preempt_count++</code>，等于2，又进入了下一个硬件中断B流程。当下一个硬件中断B流程执行完后，<code>preempt_count--</code>，等于1，此时不会进入软总断流程直接结束，然后恢复A中断的下半部，继续执行完A中断下半部分的代码。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/18.png" alt="image"><br>那这样B的下半部怎么执行呢？难道不要了吗？注意：<code>步骤7</code>中的中断下半部处理过程中，它处理的是所有中断的下半部分，处理完A的下半部后会继续处理B中断的下半部。所以，多个中断的下半部，是汇集在一起处理的。<br>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.中断的处理可以分为上半部，下半部</span><br><span class="line">2.中断上半部，用来处理紧急的事，它是在关中断的状态下执行的</span><br><span class="line">3.中断下半部，用来处理耗时的、不那么紧急的事，它是在开中断的状态下执行的.</span><br><span class="line">   	中断下半部执行时，有可能会被其他硬件中断打断</span><br><span class="line">4.中断上半部、下半部的执行过程中，不能休眠</span><br></pre></td></tr></table></figure>
<h3><span id="2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</span><a href="#2-6-2-gong-zuo-dui-lie-workqueue" class="header-anchor">#</a></h3><p>如果下半部要做的事情太多，那么<code>tasklet</code>就有点不太符合需求了，我们希望建立一个线程来专门执行中断后处理，用内核线程来做：在中断上半部唤醒内核线程。<br>在linux操作系统中，有一个内核线程**<code>kworker</code>** 线程，是系统帮我们创建的。内核中有很多这样的线程：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/19.png" alt="image"><br><code>kworker</code> 线程要去<code>“工作队列”(work queue)</code>上取出一个一个<code>“工作”(work)</code>，来执行它里面的函数。</p>
<p>1.创建 <code>work</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/20.png" alt="image"></p>
<p>2.要执行这个函数时，把<code> work</code> 提交给 <code>work queue </code>就可以了<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/21.png" alt="image"><br>上述函数会把 <code>work</code> 提供给**<code>系统默认的 work queue：system_wq</code>**，它是一个队列。<code>schedule_work</code> 函数不仅仅是把 <code>work </code>放入队列，还会把<code>kworker </code>线程唤醒。</p>
<p>3.什么时候把 <code>work </code>提交给 <code>work queue</code>？<br>在中断场景中，可以在中断上半部调用 <code>schedule_work</code> 函数。<br>因此耗时久的中断下半部分，应该利用线程化处理方式，比如使用工作队列<code>workqueue</code>，上半部调用<code>schedule_work </code>函数，触发<code> work</code> 的处理。</p>
<h3><span id="2-6-3-threaded-irq">2.6.3 threaded irq</span><a href="#2-6-3-threaded-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/22.png" alt="image"><br><code>threaded_irq</code>：下半部也是利用线程化处理。前面的<code>workqueue</code>处理使用方法太麻烦，需要在上半部进行<code>work</code>定义，<code>schedule_work</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数handler:上半部分可以为空</span><br><span class="line">参数：thread_fn，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数</span><br></pre></td></tr></table></figure>
<p>以前用 <code>work </code>来线程化地处理中断，一个 <code>worker </code>线程只能由一个 CPU 执行，多个中断的 <code>work</code> 都由同一个<code> worker</code> 线程来处理，在单 CPU 系统中也只能忍着了。但是在 SMP 系统中，明明有那么多 CPU 空着，你偏偏让多个中断挤在这个CPU 上？<br>新技术 <code>threaded irq</code>，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个 CPU 上执行，这提高了效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" data-id="clzp8uttf003u9ouf7td61cir" data-title="字符设备驱动-9-中断子系统-中断引入" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-8-内核定时器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-04T06:49:31.000Z" itemprop="datePublished">2024-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ding-shi-qi">1 引入定时器</a><ul>
<li><a href="#1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</a></li>
<li><a href="#1-1-timer-nei-he-han-shu">1.1 timer内核函数</a></li>
<li><a href="#1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</a><ul>
<li><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</a></li>
<li><a href="#1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</a><ul>
<li><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</a></li>
<li><a href="#1-2-2-2-usleep-range">1.2.2.2 usleep_range</a></li>
</ul>
</li>
<li><a href="#1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</a><ul>
<li><a href="#2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</a></li>
</ul>
</li>
<li><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</a><ul>
<li><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</a></li>
<li><a href="#3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</a></li>
<li><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-ding-shi-qi">1 引入定时器</span><a href="#1-yin-ru-ding-shi-qi" class="header-anchor">#</a></h1><p>前面的<code>阻塞非阻塞IO, 休眠唤醒，poll查询，异步通知</code>小结内容都是针对按键驱动为例进行的演示。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制 | Hexo (fuzidage.github.io)</a>引入了中断，当按键按下会记录按键信息，理想状况是按下一次按键记录一组数据，但实际上按下机械振动导致电平反复跳动最后才稳定，按下一次gpio irq会触发多次，这个被叫做<strong>“抖动”</strong>，那么可以利用定时器进行<strong>“去抖”</strong>。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p>
<h2><span id="1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</span><a href="#1-0-ding-shi-qi-timer-list-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"></p>
<p>到<code>linux_5.10</code>版本<code>struct timer_list</code>变成了<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//设定的超时的值</span></span><br><span class="line"><span class="type">void</span>(*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//超时处理函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">//超时处理函数参数</span></span><br></pre></td></tr></table></figure>
<h2><span id="1-1-timer-nei-he-han-shu">1.1 timer内核函数</span><a href="#1-1-timer-nei-he-han-shu" class="header-anchor">#</a></h2><p>在内核中使用定时器很简单，涉及这些函数(参考内核源码<code>include\linux\timer.h</code>)</p>
<ol>
<li><code>setup_timer(timer, fn, data)</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></li>
</ol>
<p>到<code>linux_5.10</code>版本变成了<code>timer_setup</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p>
<p>设置定时器，主要是初始化<code> timer_list</code> 结构体，设置其中的函数、参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还有一种用宏DEFINE_TIMER去定义和初始化一个timer_list</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_INITIALIZER(_function, _expires, _data, _flags) &#123; \</span></span><br><span class="line"><span class="meta">		.entry = &#123; .next = TIMER_ENTRY_STATIC &#125;,	\</span></span><br><span class="line"><span class="meta">		.function = (_function),			\</span></span><br><span class="line"><span class="meta">		.expires = (_expires),				\</span></span><br><span class="line"><span class="meta">		.data = (_data),				\</span></span><br><span class="line"><span class="meta">		.flags = (_flags),				\</span></span><br><span class="line"><span class="meta">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span></span><br><span class="line"><span class="meta">			__FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__))	\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><code> void add_timer(struct timer_list *timer)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"><br> 向内核添加定时器。<code>timer-&gt;expires</code>表示超时时间。<br> 当超时时间到达 ， 就会调用这个函数 ：<code>timer-&gt;function(timer-&gt;data)</code>。</p>
</li>
<li><p><code>int mod_timer(struct timer_list *timer, unsigned long expires)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p>
<p> 修改定时器的超时时间:<br> 它等同于： </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del_timer(timer);</span><br><span class="line">timer-&gt;expires = expires;</span><br><span class="line">add_timer(timer);</span><br></pre></td></tr></table></figure>
<p> 但是更加高效。</p>
</li>
<li><p><code>int del_timer(struct timer_list *timer)</code><br>删除定时器。</p>
</li>
</ol>
<h2><span id="1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</span><a href="#1-2-ding-shi-qi-shi-jian-dan-wei" class="header-anchor">#</a></h2><p>可以在内核源码根目录下用<code>“ ls -a”</code>看到一个隐藏文件<code>.config</code>, 可以看到如下这项：会被内核转换成<code>include/generated/autoconf.h</code>，<code>HZ</code>定义头文件<code>uapi/asm-generic/param.h</code>和<code>include/asm-generic/param.h</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"></p>
<p><code>CONFIG_HZ=100</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"></p>
<p>这表示内核<strong>每秒中会发生 100 次系统滴答中断(tick)<strong>，这就像人类的心跳一样，这是 Linux 系统的心跳。</strong>每发生一次 tick 中断，全局变量 jiffies 就会累加 1</strong>。<br><code>CONFIG_HZ=100</code> 表示每个滴答是 10ms。<br>定时器的时间就是基于<code>jiffies</code>的，我们修改超时时间时，一般使用这 2 种方法：</p>
<ol>
<li><code>add_timer</code> 之前，直接修改：<br><code>imer.expires = jiffies + xxx; // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br><code>imer.expires = jiffies + 2*HZ; // HZ 等于 CONFIG_HZ， 2*HZ HZ是100个10ms, 就相当于 2 秒</code></li>
<li><code>add_timer</code> 之后，使用 <code>mod_timer</code> 修改：<br> <code>mod_timer(&amp;timer, jiffies + xxx); // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br> <code>mod_timer(&amp;timer, jiffies + 2*HZ); // HZ 等于 CONFIG_HZ， 2*HZ 就相当于 2 秒</code></li>
</ol>
<h3><span id="1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</span><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将 jiffies转换为秒，可采用公式：(jiffies/HZ) 计算。</span><br><span class="line">将秒转换为jiffies，可采用公式：(seconds*HZ) 计算。</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</span><a href="#1-2-2-nei-he-shi-jian-huo-qu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get();<span class="comment">//不包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果：ktime_get:492257307974640 ns</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get_boottime();<span class="comment">//包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get_boottime:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果： ktime_get_boottime:581660801601637 ns</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ktime_get_ts64</span><span class="params">(<span class="keyword">struct</span> timespec64 *ts)</span>; <span class="comment">//这也是一种</span></span><br><span class="line"></span><br><span class="line"><span class="type">ktime_t</span> start, end, elapsed;</span><br><span class="line">start = ktime_get_boottime();</span><br><span class="line">...</span><br><span class="line">end = ktime_get_boottime();</span><br><span class="line">elapsed = ktime_sub(end, start);</span><br><span class="line">elapsed_msecs = ktime_to_ms(elapsed);</span><br><span class="line">printk(<span class="string">&quot;%d.%03d seconds&quot;</span>, elapsed_msecs / <span class="number">1000</span>,elapsed_msecs % <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</span><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_msecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_usecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line">u64 <span class="title function_">jiffies_to_nsecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> m)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> u)</span>;<span class="comment">//jiffies.h</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">nsecs_to_jiffies</span><span class="params">(u64 n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_us</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;<span class="comment">//ktime.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ms</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ns</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-2-usleep-range">1.2.2.2 usleep_range</span><a href="#1-2-2-2-usleep-range" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">usleep_range</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> min, <span class="type">unsigned</span> <span class="type">long</span> max)</span>；</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</span><a href="#1-2-3-clock-monotonic-yu-clock-realtime" class="header-anchor">#</a></h3><p><strong>CLOCK_MONOTONIC</strong>(即<code>monotonic time</code>)<br><code>CLOCK_MONOTONIC</code>：以绝对时间为准，获取的时间为系统重启到现在的时间，更改系统时间对它没有影响。<br>字面意义：单调时间，表示系统启动后流逝的时间，由变量jiffies来记录的。<br>系统每次启动时，<code>jiffies</code>初始化为0。每来一个<code>timer interrupt</code>，<code>jiffies</code>加1，即它代表系统启动后流逝的<code>tick</code>数。<br><code>jiffies</code>一定是单调递增的，因为时间不可逆。</p>
<p><strong>CLOCK_REALTIME</strong>(即<code>wall time</code>)<br><code>CLOCK_REALTIME</code>：相对时间，从<code>1970.1.1</code>到目前的时间。更改系统时间会更改获取的值。它以系统时间为坐标。<br>字面意思: <code>wall time</code>挂钟时间，表示现实的时间，由变量<code>xtime</code>来记录的。<br><strong>一些题外话</strong>：<br>一些应用软件可能就是用到了这个<code>wall time</code>。比如以前用<code>vmware workstation</code>，一启动提示试用期已过，但是只要把系统时间调整一下提前一年，再启动就不会有提示了。这很可能就是因为它启动时，用<code>gettimeofday</code>去读<code>wall time</code>，然后判断是否过期，只要将<code>wall time</code>改一下，就可以欺骗过去了。</p>
<h1><span id="2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</span><a href="#2-nei-he-ding-shi-qi-shi-li" class="header-anchor">#</a></h1><p>就前面讲到的gpio按键中断来举例，每次发生gpio 中断，irq中我们都去调用一次<code>mod_timer</code>函数判断是不是抖动带来的垃圾数据。如果是抖动，那么irq会一直触发，一直调用<code>mod_timer</code>，一直推迟定时器中断函数的触发。<br>当按下按键键值稳定下来后机械振动没了，电平数据趋于稳定了，那么gpio irq就不会一直响应了，也就是<code>mod_timer</code>函数不会一直调用了，那么等到timer超时，上报数据，整个流程如下图所示：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"><br>按键为下降沿触发，因此会在<code>t1、t2 和 t3</code> 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，但是 <code>t1~t2 </code>和<code>t2~t3</code>这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理。</p>
<details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf</span></span><br><span class="line"><span class="params">	, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_isr key %d irq happened\n&quot;</span>, gpio_key-&gt;gpio);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span></span><br><span class="line">               , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span></span><br><span class="line">                   , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer</span><br><span class="line">                    , key_timer_expire</span><br><span class="line">                    , &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">			, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">			, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_key */</span></span><br><span class="line"></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, MKDEV(major, <span class="number">0</span>)</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</span><a href="#2-2-shi-li-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/13.png" alt="image"></p>
<p><code>linux_5.10</code>内核版本用法<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/14.png" alt="image"></p>
<p>probe函数进行初始化定时器，这里<code>add_timer</code>前修改<code>expires</code>，为了防止定时器中断提前触发（按键还没按下就触发了定时器中断），因此修改<code>expires</code>为一个最大值。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/15.png" alt="image"><br>当按下按键gpio_irq按键中断服务程序响应后，调用<code>mod_timer</code>进行修改定时器超时时间，用来去除 “抖动”。<code>jiffies + HZ/5</code>表示延时20个tick时钟滴答，也就是<code>20*10ms</code>，如果这个时间内有多次电平跳动，那么不会去上报数据，而是继续修改定时器超时时间，直到按键数据稳定后，也就是200ms已经到了但是没有人去修改定时器超时时间，那么将会触发定时器中断，上报按键数据。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/16.png" alt="image"><br><code>linux_5.10</code>内核版本用法:<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/17.png" alt="image"></p>
<h1><span id="3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</span><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h1><h2><span id="3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</span><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><p>《后面中断子系统会专门介绍》<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入</a></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/18.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/19.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</span><a href="#3-2-ding-shi-qi-di-ceng-yuan-li" class="header-anchor">#</a></h2><p>定时器就是通过<code>软件中断</code>来实现的，它属于 <code>TIMER_SOFTIRQ </code>软中断<br>对于<code> TIMER_SOFTIRQ</code> 软中断，内核启动时会调用<code>start_kernel</code>初始化<code>init_timers();</code> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_timers</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	init_timer_cpus();</span><br><span class="line">	init_timer_stats();</span><br><span class="line">	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生硬件中断时，硬件中断处理完后，内核会调用软件中断的处理函数。<br>对于<code> TIMER_SOFTIRQ</code>，会调用<code> run_timer_softirq</code>，它的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softirq</span><br><span class="line">	__run_timers(base);</span><br><span class="line">    <span class="keyword">while</span> (time_after_eq(jiffies, base-&gt;clk)) &#123;</span><br><span class="line">    ……</span><br><span class="line">    expire_timers(base, heads + levels);</span><br><span class="line">        fn = timer-&gt;function;</span><br><span class="line">        data = timer-&gt;data;</span><br><span class="line">        call_timer_fn(timer, fn, data);</span><br><span class="line">			fn(data);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/20.png" alt="image-20240804152644572"></p>
<p>简单地说， <code>add_timer</code> 函数会把 timer 放入内核里某个链表；在 <code>TIMER_SOFTIRQ</code> 的处理函数<code>run_timer_softirq</code>中，会从链表中把这些超时的 timer 取出来，<br>执行其中的函数。怎么判断是否超时？ <code>jiffies</code> 大于或等于 <code>timer-&gt;expires </code>时， timer 就超时，执行超时处理函数。</p>
<h2><span id="3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</span><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies" class="header-anchor">#</a></h2><p>在开发板执行以下命令，可以看到 CPU0 下有一个数值变化特别快，它就是<code>滴答中断tick</code>，<code>jiffies</code>也叫做系统节拍数。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/21.png" alt="image"></p>
<p>以 <code>100ASK_IMX6ULL </code>为做，滴答中断名字就是<code>“ i.MX Timer Tick”</code>。在 Linux内核源码目录下执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;i.MX Timer Tick&quot;</span> * -nr</span><br><span class="line">drivers/clocksource/timer-imx-gpt.c:<span class="number">319</span>: act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>⚫ 打开 <code>timer-imx-gpt.c</code> <code>319 行</code>左右，可得如下源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br><span class="line">act-&gt;flags = IRQF_TIMER | IRQF_IRQPOLL;</span><br><span class="line">act-&gt;handler = mxc_timer_interrupt;</span><br><span class="line">act-&gt;dev_id = ced;</span><br><span class="line"><span class="keyword">return</span> setup_irq(imxtm-&gt;irq, act);</span><br></pre></td></tr></table></figure>
<p>⚫ <code>mxc_timer_interrupt</code> 应该就是滴答中断的处理函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">mxc_timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">ced</span> =</span> dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_timer</span> *<span class="title">imxtm</span> =</span> to_imx_timer(ced);</span><br><span class="line">	<span class="type">uint32_t</span> tstat;</span><br><span class="line">	tstat = readl_relaxed(imxtm-&gt;base + imxtm-&gt;gpt-&gt;reg_tstat);<span class="number">472</span> / <span class="number">573</span></span><br><span class="line">	imxtm-&gt;gpt-&gt;gpt_irq_acknowledge(imxtm);</span><br><span class="line">	ced-&gt;event_handler(ced);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看<code>ced-&gt;event_handler(ced);</code>调用：</p>
<p><code>ced-&gt;event_handler(ced)</code>是哪一个函数？不太好找，使用 <code>QEMU</code> 来调试内核，在 <code>mxc_timer_interrupt</code> 中打断点跟踪代码发现它对应 <code>tick_handle_periodic</code>。<br><code>tick_handle_periodic</code> 位于 <code>kernel\time\tick-common.c </code>中，它里面的调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic</span><br><span class="line">	<span class="title function_">tick_periodic</span><span class="params">(cpu)</span>;</span><br><span class="line">		do_timer(<span class="number">1</span>);</span><br><span class="line">		jiffies_64 += ticks; <span class="comment">// jiffies 就是 jiffies_64</span></span><br></pre></td></tr></table></figure>
<p>为何说<code>jiffies</code>就是<code> jiffies_64</code>？在 <code>arch\arm\kernel\vmlinux.lds.S</code> 有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARMEB__</span></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">jiffies = jiffies_64 + <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码说明了，对于大字节序的 CPU， <code>jiffies</code> 指向<code> jiffies_64</code> 的高 4字节；对于小字节序的 CPU，<code> jiffies</code> 指向 <code>jiffies_64 </code>的低 4 字节。对<code> jiffies_64</code> 的累加操作，就是对 <code>jiffies </code>的累加操作。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __cacheline_aligned_in_smp jiffies_64; <span class="comment">//include/linux/jiffies.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" data-id="clzp8utte003n9oufb7gs9507" data-title="字符设备驱动-8-内核定时器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 19.09px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 20px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 11.82px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.73px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13.64px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">字符设备驱动-mmap驱动应用实例</a>
          </li>
        
          <li>
            <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/">字符设备驱动-mmap机制</a>
          </li>
        
          <li>
            <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/">字符设备驱动-9-中断子系统-中断线程化-threaded_irq</a>
          </li>
        
          <li>
            <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/">字符设备驱动-9-中断子系统-中断线程化-workqueue</a>
          </li>
        
          <li>
            <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/">字符设备驱动-9-中断子系统-中断下半部-tasklet</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>