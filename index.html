<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-Framebuffer子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-01T05:28:35.000Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-framebuffer">1 引入Framebuffer</a></li>
<li><a href="#2-framebuffer-qu-dong-jie-shao">2 Framebuffer驱动介绍</a><ul>
<li><a href="#2-1-framebuffer-she-bei-jie-dian">2.1 Framebuffer设备节点</a></li>
<li><a href="#2-2-framebuffer-kuang-jia">2.2 Framebuffer框架</a></li>
<li><a href="#2-3-framebuffer-shu-ju-jie-gou">2.3 Framebuffer数据结构</a><ul>
<li><a href="#2-3-1-fb-info">2.3.1 fb_info</a><ul>
<li><a href="#2-3-1-1-fb-ops">2.3.1.1 fb_ops</a></li>
<li><a href="#2-3-1-2-fb-var-screeninfo">2.3.1.2 fb_var_screeninfo</a><ul>
<li><a href="#2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu">2.3.1.2.1 引入可视屏幕和虚拟屏幕</a></li>
</ul>
</li>
<li><a href="#2-3-1-3-fb-fix-screeninfo">2.3.1.3 fb_fix_screeninfo</a></li>
<li><a href="#2-3-1-4-fb-bitfield">2.3.1.4 fb_bitfield</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-framebuffer-yuan-ma-fen-xi">2.4 Framebuffer源码分析</a><ul>
<li><a href="#2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng">2.4.1 编写fb驱动大致流程</a></li>
<li><a href="#2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai">2.4.2 fb子系统注册卸载</a><ul>
<li><a href="#2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu">2.4.2.1 fb注册卸载相关函数</a><ul>
<li><a href="#2-4-2-1-1-framebuffer-alloc">2.4.2.1.1 framebuffer_alloc</a></li>
<li><a href="#2-4-2-1-2-register-framebuffer">2.4.2.1.2 register_framebuffer</a></li>
<li><a href="#2-4-2-1-3-unregister-framebuffer">2.4.2.1.3 unregister_framebuffer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-3-fb-ops-fen-xi">2.4.3 fb_ops分析</a><ul>
<li><a href="#2-4-3-1-fb-open">2.4.3.1 fb_open</a></li>
<li><a href="#2-4-3-2-fb-write">2.4.3.2 fb_write</a></li>
<li><a href="#2-4-3-3-fb-mmap">2.4.3.3 fb_mmap</a></li>
<li><a href="#2-4-3-4-fb-ioctl">2.4.3.4 fb_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-framebuffer-qu-dong-shi-li">3 Framebuffer驱动实例</a><ul>
<li><a href="#3-1-ding-yi-fb-info-shi-li">3.1定义fb_info实例</a><ul>
<li><a href="#3-1-0-kong-zhi-qi-dts-pei-zhi">3.1.0 控制器dts配置</a></li>
<li><a href="#3-1-1-mxsfb-probe-guo-cheng-fen-xi">3.1.1 mxsfb_probe过程分析</a></li>
</ul>
</li>
<li><a href="#3-2-lcd-ping-mu-dts-miao-shu">3.2 LCD屏幕dts描述</a><ul>
<li><a href="#3-2-1-ping-mu-io-pei-zhi">3.2.1 屏幕 IO 配置</a></li>
<li><a href="#3-2-2-ping-mu-jie-dian">3.2.2 屏幕节点</a></li>
<li><a href="#3-2-3-bei-guang-jie-dian">3.2.3 背光节点</a><ul>
<li><a href="#3-2-3-1-backlight-she-zhi">3.2.3.1 backlight设置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-lcd-ce-shi">4 LCD测试</a><ul>
<li><a href="#4-1-shi-neng-linux-logo">4.1 使能 Linux logo</a></li>
<li><a href="#4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console">4.2 LCD 作为终端控制台console</a></li>
<li><a href="#4-3-lcd-bei-guang-diao-jie-ming-ling">4.3 LCD 背光调节命令</a></li>
<li><a href="#4-4-lcd-ping-mu-zi-dong-xi-mie">4.4 LCD屏幕自动熄灭</a><ul>
<li><a href="#4-1-1-an-jian-pan-huan-xing">4.1.1 按键盘唤醒</a></li>
<li><a href="#4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping">4.1.2 关闭10分钟自动熄屏</a></li>
</ul>
</li>
<li><a href="#4-5-ce-shi-dai-ma">4.5 测试代码</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-framebuffer">1 引入Framebuffer</span><a href="#1-yin-ru-framebuffer" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13152010.html">s3c2440裸机-LCD编程一、LCD硬件原理</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/">s3c2440裸机编程-LDC | Hexo (fuzidage.github.io)</a></p>
<p>介绍了LDC的基本原理。裸机 LCD 驱动编写流程如下：</p>
<ol>
<li>初始化 I.MX6U 的 eLCDIF 控制器，屏幕宽(width)、高(height)、<code>hspw、 hbp、hfp、vspw、vbp 和 vfp</code> 等信息。</li>
<li>初始化 LCD 像素时钟。</li>
<li>设置 RGBLCD 显存属性。</li>
<li>应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。</li>
</ol>
<p>同理linux系统下也是希望应用程序来直接操作一块内存来实现实现在 LCD 上显示字符、图片等信息，Framebuffer就是用来干这件事的。<code>Framebuffer</code> 翻译过来就是帧缓冲，简称<code> fb</code>。</p>
<p>作用：把显示设备描述成一个缓冲区，允许应用程序通过帧缓冲定义好的接口访问这些图形设备，从而不用关心具体的硬件细节。</p>
<p>因此需要在底层<code>framebuffer框架</code>去对接具体的显示设备，显示设备控制器。</p>
<h1><span id="2-framebuffer-qu-dong-jie-shao">2 Framebuffer驱动介绍</span><a href="#2-framebuffer-qu-dong-jie-shao" class="header-anchor">#</a></h1><h2><span id="2-1-framebuffer-she-bei-jie-dian">2.1 Framebuffer设备节点</span><a href="#2-1-framebuffer-she-bei-jie-dian" class="header-anchor">#</a></h2><p>当我们编写好 LCD 驱动以后会生成一个名为<code>/dev/fbX(X=0~n)</code>的设备，应用程序通 过访问<code>/dev/fbX </code>这个设备就可以访问 LCD。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/0.png" alt="image"></p>
<h2><span id="2-2-framebuffer-kuang-jia">2.2 Framebuffer框架</span><a href="#2-2-framebuffer-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<ul>
<li><code>drivers/video/fbmem.c</code>：主要任务是创建<code>graphics类</code>、注册FB的字符设备驱动（主设备号是29）、提供<code>register_framebuffer</code>接口给具体framebuffer驱动编写着来注册fb设备的。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FB_MAJOR		29   /* /dev/fb* framebuffers */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>drivers/video/fbsys.c</code>：是<code>fbmem.c</code>引出来的，处理fb在<code>/sys/class/graphics/fb0</code>目录下的一些属性文件的。</p>
</li>
<li><p><code>xxx_fb.c</code>: 具体的显示设备控制器驱动代码，dts描述对应的显示设备，控制器去驱动显示设备。</p>
</li>
</ul>
<h2><span id="2-3-framebuffer-shu-ju-jie-gou">2.3 Framebuffer数据结构</span><a href="#2-3-framebuffer-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-3-1-fb-info">2.3.1 fb_info</span><a href="#2-3-1-fb-info" class="header-anchor">#</a></h3><p>fb_info结构体记录了帧缓冲设备的全部信息，包括设备的设置参数、状态以及操作函数指针，对于每一个帧缓冲设备都必须对应一个fb_info结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 互斥锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span> <span class="comment">/* 互斥锁，用于 fb_mmap 和 smem_*域*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span> <span class="comment">/* 当前可变参数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span> <span class="comment">/* 当前固定参数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span> <span class="comment">/* 当前显示器特性 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span> <span class="comment">/* 帧缓冲事件队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span> <span class="comment">/* 图像硬件映射 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span> <span class="comment">/* 光标硬件映射 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span> <span class="comment">/* 当前调色板 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span> <span class="comment">/* 当前模式列表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span> <span class="comment">/* 当前视频模式 */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT <span class="comment">/* 如果 LCD 支持背光的话 */</span></span></span><br><span class="line">	<span class="comment">/* assigned backlight device */</span></span><br><span class="line">	<span class="comment">/* set before framebuffer registration,</span></span><br><span class="line"><span class="comment">	remove after unregister */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backlight_device</span> *<span class="title">bl_dev</span>;</span> <span class="comment">/* 背光设备 */</span></span><br><span class="line">	<span class="comment">/* Backlight level curve */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bl_curve_mutex</span>;</span></span><br><span class="line">	u8 bl_curve[FB_BACKLIGHT_LEVELS];</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span> <span class="comment">/* 帧缓冲操作函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 父设备 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* 当前 fb 设备 */</span></span><br><span class="line">	<span class="type">int</span> class_flag; <span class="comment">/* 私有 sysfs 标志 */</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">char</span> __iomem *screen_base; <span class="comment">/* 虚拟内存基地址(屏幕显存) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> screen_size; <span class="comment">/* 虚拟内存大小(屏幕显存大小) */</span></span><br><span class="line">	<span class="type">void</span> *pseudo_palette; <span class="comment">/* 伪 16 位调色板 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-1-fb-ops">2.3.1.1 fb_ops</span><a href="#2-3-1-1-fb-ops" class="header-anchor">#</a></h4><p>帧缓冲操作函数集,包含open,release,read,write等操作函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Frame buffer operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LOCKING <span class="doctag">NOTE:</span> those functions must _ALL_ be called with the console</span></span><br><span class="line"><span class="comment"> * semaphore held, this is the only suitable locking mechanism we have</span></span><br><span class="line"><span class="comment"> * in 2.6. Some may be called at interrupt time at this point though.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The exception to this is the debug related hooks.  Putting the fb</span></span><br><span class="line"><span class="comment"> * into a debug state (e.g. flipping to the kernel console) and restoring</span></span><br><span class="line"><span class="comment"> * it must be done in a lock-free manner, so low level drivers should</span></span><br><span class="line"><span class="comment"> * keep track of the initial console (if applicable) and may need to</span></span><br><span class="line"><span class="comment"> * perform direct, unlocked hardware writes in these hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/* open/release and usage marking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span> (*fb_open)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">	<span class="type">int</span> (*fb_release)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">	<span class="comment">/* For framebuffers with strange non linear layouts or that do not</span></span><br><span class="line"><span class="comment">	 * work with normal memory mapped access</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">ssize_t</span> (*fb_read)(<span class="keyword">struct</span> fb_info *info, <span class="type">char</span> __user *buf,</span><br><span class="line">			   <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">	<span class="type">ssize_t</span> (*fb_write)(<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="type">char</span> __user *buf,</span><br><span class="line">			    <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">	<span class="comment">/* checks var and eventually tweaks it to something supported,</span></span><br><span class="line"><span class="comment">	 * DO NOT MODIFY PAR */</span></span><br><span class="line">	<span class="type">int</span> (*fb_check_var)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set the video mode according to info-&gt;var */</span></span><br><span class="line">	<span class="type">int</span> (*fb_set_par)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set color register */</span></span><br><span class="line">	<span class="type">int</span> (*fb_setcolreg)(<span class="type">unsigned</span> regno, <span class="type">unsigned</span> red, <span class="type">unsigned</span> green,</span><br><span class="line">			    <span class="type">unsigned</span> blue, <span class="type">unsigned</span> transp, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set color registers in batch */</span></span><br><span class="line">	<span class="type">int</span> (*fb_setcmap)(<span class="keyword">struct</span> fb_cmap *cmap, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* blank display */</span></span><br><span class="line">	<span class="type">int</span> (*fb_blank)(<span class="type">int</span> blank, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* pan display */</span></span><br><span class="line">	<span class="type">int</span> (*fb_pan_display)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* Draws a rectangle */</span></span><br><span class="line">	<span class="type">void</span> (*fb_fillrect) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_fillrect *rect);</span><br><span class="line">	<span class="comment">/* Copy data from area to another */</span></span><br><span class="line">	<span class="type">void</span> (*fb_copyarea) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_copyarea *region);</span><br><span class="line">	<span class="comment">/* Draws a image to the display */</span></span><br><span class="line">	<span class="type">void</span> (*fb_imageblit) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_image *image);</span><br><span class="line">	<span class="comment">/* Draws cursor */</span></span><br><span class="line">	<span class="type">int</span> (*fb_cursor) (<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> fb_cursor *cursor);</span><br><span class="line">	<span class="comment">/* wait for blit idle, optional */</span></span><br><span class="line">	<span class="type">int</span> (*fb_sync)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* perform fb specific ioctl (optional) */</span></span><br><span class="line">	<span class="type">int</span> (*fb_ioctl)(<span class="keyword">struct</span> fb_info *info, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line">	<span class="type">int</span> (*fb_compat_ioctl)(<span class="keyword">struct</span> fb_info *info, <span class="type">unsigned</span> cmd,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="comment">/* perform fb specific mmap */</span></span><br><span class="line">	<span class="type">int</span> (*fb_mmap)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line">	<span class="comment">/* get capability given var */</span></span><br><span class="line">	<span class="type">void</span> (*fb_get_caps)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> fb_blit_caps *caps,</span><br><span class="line">			    <span class="keyword">struct</span> fb_var_screeninfo *var);</span><br><span class="line">	<span class="comment">/* teardown any resources to do with this framebuffer */</span></span><br><span class="line">	<span class="type">void</span> (*fb_destroy)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* called at KDB enter and leave time to prepare the console */</span></span><br><span class="line">	<span class="type">int</span> (*fb_debug_enter)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="type">int</span> (*fb_debug_leave)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-2-fb-var-screeninfo">2.3.1.2 fb_var_screeninfo</span><a href="#2-3-1-2-fb-var-screeninfo" class="header-anchor">#</a></h4><p>记录用户<strong>可修改的显示控制器参数</strong>，包括了屏幕的分辨率和每个像素点的比特数bpp,pixclock等。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> &#123;</span></span><br><span class="line">	__u32 xres;			<span class="comment">/* visible resolution		*/</span></span><br><span class="line">	__u32 yres;</span><br><span class="line">	__u32 xres_virtual;		<span class="comment">/* virtual resolution		*/</span></span><br><span class="line">	__u32 yres_virtual;</span><br><span class="line">	__u32 xoffset;			<span class="comment">/* offset from virtual to visible */</span></span><br><span class="line">	__u32 yoffset;			<span class="comment">/* resolution			*/</span></span><br><span class="line"></span><br><span class="line">	__u32 bits_per_pixel;		<span class="comment">/* guess what			*/</span></span><br><span class="line">	__u32 grayscale;		<span class="comment">/* 0 = color, 1 = grayscale,	*/</span></span><br><span class="line">					<span class="comment">/* &gt;1 = FOURCC			*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span>		<span class="comment">/* bitfield in fb mem if true color, */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span>	<span class="comment">/* else only length is significant */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span>	<span class="comment">/* transparency			*/</span>	</span><br><span class="line"></span><br><span class="line">	__u32 nonstd;			<span class="comment">/* != 0 Non standard pixel format */</span></span><br><span class="line"></span><br><span class="line">	__u32 activate;			<span class="comment">/* see FB_ACTIVATE_*		*/</span></span><br><span class="line"></span><br><span class="line">	__u32 height;			<span class="comment">/* height of picture in mm    */</span></span><br><span class="line">	__u32 width;			<span class="comment">/* width of picture in mm     */</span></span><br><span class="line"></span><br><span class="line">	__u32 accel_flags;		<span class="comment">/* (OBSOLETE) see fb_info.flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timing: All values in pixclocks, except pixclock (of course) */</span></span><br><span class="line">	__u32 pixclock;			<span class="comment">/* pixel clock in ps (pico seconds) */</span></span><br><span class="line">	__u32 left_margin;		<span class="comment">/* time from sync to picture	*/</span></span><br><span class="line">	__u32 right_margin;		<span class="comment">/* time from picture to sync	*/</span></span><br><span class="line">	__u32 upper_margin;		<span class="comment">/* time from sync to picture	*/</span></span><br><span class="line">	__u32 lower_margin;</span><br><span class="line">	__u32 hsync_len;		<span class="comment">/* length of horizontal sync	*/</span></span><br><span class="line">	__u32 vsync_len;		<span class="comment">/* length of vertical sync	*/</span></span><br><span class="line">	__u32 sync;			<span class="comment">/* see FB_SYNC_*		*/</span></span><br><span class="line">	__u32 vmode;			<span class="comment">/* see FB_VMODE_*		*/</span></span><br><span class="line">	__u32 rotate;			<span class="comment">/* angle we rotate counter clockwise */</span></span><br><span class="line">	__u32 colorspace;		<span class="comment">/* colorspace for FOURCC-based modes */</span></span><br><span class="line">	__u32 reserved[<span class="number">4</span>];		<span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5><span id="2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu">2.3.1.2.1 引入可视屏幕和虚拟屏幕</span><a href="#2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu" class="header-anchor">#</a></h5><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)可视屏幕：LCD分辨率，这是硬件相关的。比如：LCD屏幕的分辨率是<span class="number">800</span>x480，那可视屏幕的最大分辨率就是<span class="number">800</span>x480；</span><br><span class="line">(<span class="number">2</span>)虚拟屏幕：我们在内核中开辟的帧缓冲区的大小。比如：屏幕分辨率是<span class="number">800</span>x480，但是我们可以将帧缓冲区开辟成<span class="number">1920</span>x1080，</span><br><span class="line">    在刷新屏幕时可以直接将<span class="number">1080</span>p的图像一次性刷新到帧缓冲区中；</span><br><span class="line">(<span class="number">3</span>)虚拟屏到可视屏的偏移量：虚拟屏大小是超过可视屏幕的大小，偏移量决定了可视屏显示虚拟屏的哪一个部分；</span><br><span class="line">(<span class="number">4</span>)总结：通过改变虚拟屏到可视屏的偏移量，可以将虚拟屏的不同部分图像显示到可视屏中，而不需要每次都刷新帧缓冲区；</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-3-fb-fix-screeninfo">2.3.1.3 fb_fix_screeninfo</span><a href="#2-3-1-3-fb-fix-screeninfo" class="header-anchor">#</a></h4><p>记录了用户<strong>不能修改的显示控制器的参数</strong>，比如说屏幕缓冲区的物理地址、长度。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];            <span class="comment">/* identification string eg &quot;TT Builtin&quot; */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> smem_start;    <span class="comment">/* Start of frame buffer mem */</span></span><br><span class="line">                    <span class="comment">/* (physical address) */</span></span><br><span class="line">    __u32 smem_len;            <span class="comment">/* Length of frame buffer mem */</span></span><br><span class="line">    __u32 type;            <span class="comment">/* see FB_TYPE_*        */</span></span><br><span class="line">    __u32 type_aux;            <span class="comment">/* Interleave for interleaved Planes */</span></span><br><span class="line">    __u32 visual;            <span class="comment">/* see FB_VISUAL_*        */</span> </span><br><span class="line">    __u16 xpanstep;            <span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">    __u16 ypanstep;            <span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">    __u16 ywrapstep;        <span class="comment">/* zero if no hardware ywrap    */</span></span><br><span class="line">    __u32 line_length;        <span class="comment">/* length of a line in bytes    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmio_start;    <span class="comment">/* Start of Memory Mapped I/O   */</span></span><br><span class="line">                    <span class="comment">/* (physical address) */</span></span><br><span class="line">    __u32 mmio_len;            <span class="comment">/* Length of Memory Mapped I/O  */</span></span><br><span class="line">    __u32 accel;            <span class="comment">/* Indicate to driver which    */</span></span><br><span class="line">                    <span class="comment">/*  specific chip/card we have    */</span></span><br><span class="line">    __u16 capabilities;        <span class="comment">/* see FB_CAP_*            */</span></span><br><span class="line">    __u16 reserved[<span class="number">2</span>];        <span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-4-fb-bitfield">2.3.1.4 fb_bitfield</span><a href="#2-3-1-4-fb-bitfield" class="header-anchor">#</a></h4><p>描述每一像素缓冲区的组织方式，包括域偏移、位域长度和MSB指示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> &#123;</span></span><br><span class="line">    __u32 offset;            <span class="comment">/* beginning of bitfield    */</span></span><br><span class="line">    __u32 length;            <span class="comment">/* length of bitfield        */</span></span><br><span class="line">    __u32 msb_right;        <span class="comment">/* != 0 : Most significant bit is */</span> </span><br><span class="line">                    <span class="comment">/* right */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-framebuffer-yuan-ma-fen-xi">2.4 Framebuffer源码分析</span><a href="#2-4-framebuffer-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3><span id="2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng">2.4.1 编写fb驱动大致流程</span><a href="#2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng" class="header-anchor">#</a></h3><ol>
<li>构建fb_info结构体</li>
<li><code>register_framebuffer</code>注册<code>fb_info</code>到<code>fb框架</code>中，驱动框架会自动创建<code>/dev/fbx</code>设备节点</li>
<li>app通过open、ioctl等函数接口去操作设备节点<code>/dev/fb0</code>，驱动框架就会调用fb_info实例化中对应的open、ioctl接口去完成具体的硬件操作。</li>
</ol>
<h3><span id="2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai">2.4.2 fb子系统注册卸载</span><a href="#2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai" class="header-anchor">#</a></h3><p>如果定义了<code>MODULE</code>宏就表示要fb子系统单独编译成ko文件，否则用<code>subsys_initcall</code>编译进内核。入口在<code>drivers\video\fbdev\core\fbmem.c</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<ol>
<li><p>创建proc条目<code>/proc/fb</code></p>
</li>
<li><p>注册成字符设备，fb主设备号定义在<code>include\uapi\linux\major.h</code></p>
<p><code>#define FB_MAJOR		29   /* /dev/fb* framebuffers */</code></p>
</li>
<li><p>建立<code>graphics</code>类。</p>
</li>
</ol>
<h4><span id="2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu">2.4.2.1 fb注册卸载相关函数</span><a href="#2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu" class="header-anchor">#</a></h4><h5><span id="2-4-2-1-1-framebuffer-alloc">2.4.2.1.1 framebuffer_alloc</span><a href="#2-4-2-1-1-framebuffer-alloc" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> fb_info *<span class="title function_">framebuffer_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//计算私有数据起始地址需要补齐的字节数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTES_PER_LONG (BITS_PER_LONG/8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDING (BYTES_PER_LONG - (sizeof(struct fb_info) % BYTES_PER_LONG))</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> fb_info_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		fb_info_size += PADDING;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	p = kzalloc(fb_info_size + size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	info = (<span class="keyword">struct</span> fb_info *) p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将申请的私有数据的地址赋值给info-&gt;par</span></span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		info-&gt;par = p + fb_info_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设备的父节点</span></span><br><span class="line">	info-&gt;device = dev;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT</span></span><br><span class="line">	mutex_init(&amp;info-&gt;bl_curve_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PADDING</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BYTES_PER_LONG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)famebuffer_alloc函数是用来申请一个struct fb_info结构体的，传参的size是设备私有数据的大小；</span><br><span class="line">(2)申请sizeof(struct fb_info) + PADDING + size大小的空间分配给fb_info结构体类型的指针info，</span><br><span class="line">	加上PADDING 字节是为了后面的设备私有数据保持BYTES_PER_LONG字节对齐；</span><br><span class="line">(3)将fb_info结构体后面size大小且BYTES_PER_LONG 字节的设备私有数据地址赋值info-&gt;par;</span><br><span class="line">(4)将传入的参数dev赋值给info-&gt;device，作为父设备；</span><br><span class="line">(5)返回创建好的struct fb_into结构体指针info；</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-1-2-register-framebuffer">2.4.2.1.2 register_framebuffer</span><a href="#2-4-2-1-2-register-framebuffer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_framebuffer</span><span class="params">(<span class="keyword">struct</span> fb_info *fb_info)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> <span class="title">mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查已经注册的帧缓冲设备是否已经达到上限</span></span><br><span class="line">	<span class="keyword">if</span> (num_registered_fb == FB_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断 fb_ info-&gt;flags 标志中关于控制器大小端的设置是否正确</span></span><br><span class="line">	<span class="keyword">if</span> (fb_check_foreignness(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在registered_fb数组中找一个空闲的变量</span></span><br><span class="line">	num_registered_fb++;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; FB_MAX; i++)</span><br><span class="line">		<span class="keyword">if</span> (!registered_fb[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将申请到的变量在数组中的下标赋值给fb_info-&gt;node</span></span><br><span class="line">	fb_info-&gt;node = i;</span><br><span class="line">		</span><br><span class="line">	mutex_init(&amp;fb_info-&gt;lock);</span><br><span class="line">	mutex_init(&amp;fb_info-&gt;mm_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建帧缓冲设备</span></span><br><span class="line">	fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,</span><br><span class="line">				     MKDEV(FB_MAJOR, i), <span class="literal">NULL</span>, <span class="string">&quot;fb%d&quot;</span>, i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(fb_info-&gt;dev)) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Unable to create device for framebuffer %d; errno = %ld\n&quot;</span>, </span><br><span class="line">               i, PTR_ERR(fb_info-&gt;dev));</span><br><span class="line">		fb_info-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//初始化帧缓冲设备，创建更多设备属性文件</span></span><br><span class="line">		fb_init_device(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化fb_info-&gt;pixmap，该变量的作用是将用于显示的硬件无关数据转换为设备需要的格式</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;pixmap.addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fb_info-&gt;pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (fb_info-&gt;pixmap.addr) &#123;</span><br><span class="line">			fb_info-&gt;pixmap.size = FBPIXMAPSIZE;</span><br><span class="line">			fb_info-&gt;pixmap.buf_align = <span class="number">1</span>;</span><br><span class="line">			fb_info-&gt;pixmap.scan_align = <span class="number">1</span>;</span><br><span class="line">			fb_info-&gt;pixmap.access_align = <span class="number">32</span>;</span><br><span class="line">			fb_info-&gt;pixmap.flags = FB_PIXMAP_DEFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	fb_info-&gt;pixmap.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_x)</span><br><span class="line">		fb_info-&gt;pixmap.blit_x = ~(u32)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_y)</span><br><span class="line">		fb_info-&gt;pixmap.blit_y = ~(u32)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化显示模式链表 fb_ info-&gt;modelist</span></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;modelist.prev || !fb_info-&gt;modelist.next)</span><br><span class="line">		INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据fb_info-&gt;var设置一个 mode</span></span><br><span class="line">	fb_var_to_videomode(&amp;mode, &amp;fb_info-&gt;var);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将该mode添加到fb_info-&gt;modelist中</span></span><br><span class="line">	fb_add_videomode(&amp;mode, &amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将fb_info注册到registered_fb结构体中</span></span><br><span class="line">	registered_fb[i] = fb_info;</span><br><span class="line"></span><br><span class="line">	event.info = fb_info;</span><br><span class="line">	<span class="keyword">if</span> (!lock_fb_info(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//〕通知发生了FB_EVENT_FB_REGISTERED事件(帧缓冲设备注册事件)</span></span><br><span class="line">	fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &amp;event);</span><br><span class="line">	unlock_fb_info(fb_info);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-1-3-unregister-framebuffer">2.4.2.1.3 unregister_framebuffer</span><a href="#2-4-2-1-3-unregister-framebuffer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unregister_framebuffer</span><span class="params">(<span class="keyword">struct</span> fb_info *fb_info)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="type">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//检查传入的fb_info是否已经注册过</span></span><br><span class="line">	i = fb_info-&gt;node;</span><br><span class="line">	<span class="keyword">if</span> (!registered_fb[i]) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!lock_fb_info(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	event.info = fb_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通知发生FB_EVENT_FB_UNBIND事件，绑定了该帧缓冲设备的都解绑</span></span><br><span class="line">	ret = fb_notifier_call_chain(FB_EVENT_FB_UNBIND, &amp;event);</span><br><span class="line">	unlock_fb_info(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放掉申请的fb_info-&gt;pixmap.addr</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;pixmap.addr &amp;&amp;</span><br><span class="line">	    (fb_info-&gt;pixmap.flags &amp; FB_PIXMAP_DEFAULT))</span><br><span class="line">		kfree(fb_info-&gt;pixmap.addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁fb_info-&gt;modelist模式链表</span></span><br><span class="line">	fb_destroy_modelist(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将占用的registered_fb数组中的变量置为NULL，表示空闲</span></span><br><span class="line">	registered_fb[i]=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内核中注册的帧缓冲设备数量减一</span></span><br><span class="line">	num_registered_fb--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁点帧缓冲设备的属性文件</span></span><br><span class="line">	fb_cleanup_device(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁掉帧缓冲设备</span></span><br><span class="line">	device_destroy(fb_class, MKDEV(FB_MAJOR, i));</span><br><span class="line">	event.info = fb_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通知发生了FB_EVENT_FB_UNREGISTERED事件，表示该帧缓冲设备已经被注销掉</span></span><br><span class="line">	fb_notifier_call_chain(FB_EVENT_FB_UNREGISTERED, &amp;event);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果fb_info结构体中有销毁函数就调用销毁函数</span></span><br><span class="line">	<span class="comment">/* this may free fb info */</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;fbops-&gt;fb_destroy)</span><br><span class="line">		fb_info-&gt;fbops-&gt;fb_destroy(fb_info);</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-3-fb-ops-fen-xi">2.4.3  fb_ops分析</span><a href="#2-4-3-fb-ops-fen-xi" class="header-anchor">#</a></h3><p><code>fb_ops</code>中的操作函数属于框架部分，并不和具体的硬件相关，在进行一些处理后最后都是调用<code>struct fb_info</code>结构体中<code>fb_ops</code>定义的操作方法；</p>
<p>!<img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="2-4-3-1-fb-open">2.4.3.1 fb_open</span><a href="#2-4-3-1-fb-open" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fb_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(inode);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断次设备号是否在合法范围</span></span><br><span class="line">	<span class="keyword">if</span> (fbidx &gt;= FB_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据次设备号找到对应的struct fb_info结构体指针</span></span><br><span class="line">	info = registered_fb[fbidx];</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="comment">//如果数组下标fbidx的变量是NULL，手动加载帧缓冲设备</span></span><br><span class="line">		request_module(<span class="string">&quot;fb%d&quot;</span>, fbidx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//再次从registered_fb数组中获取对应的struct fb_info结构体指针</span></span><br><span class="line">	info = registered_fb[fbidx];</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	mutex_lock(&amp;info-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(info-&gt;fbops-&gt;owner)) &#123;</span><br><span class="line">		res = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将struct fb_info结构体指针保存到struct file结构体的私有数据指针中，后续的接口会用到</span></span><br><span class="line">	file-&gt;private_data = info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用帧缓冲设备驱动的fb_open函数</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_open) &#123;</span><br><span class="line">		res = info-&gt;fbops-&gt;fb_open(info,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (res)</span><br><span class="line">			module_put(info-&gt;fbops-&gt;owner);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;info-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-3-2-fb-write">2.4.3.2 fb_write</span><a href="#2-4-3-2-fb-write" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span>&#123;</span><br><span class="line">	<span class="comment">//显示的偏移量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> p = *ppos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取到设备节点的struct inode结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从inode节点中获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以次设备号为下标在registered_fb数组中获取到对应的struct fb_info结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];</span><br><span class="line">	</span><br><span class="line">	u32 *buffer, *src;</span><br><span class="line">	u32 __iomem *dst;</span><br><span class="line">	<span class="type">int</span> c, i, cnt = <span class="number">0</span>, err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!info || !info-&gt;screen_base)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;state != FBINFO_STATE_RUNNING)</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果帧缓冲设备驱动中的struct fb_ops中有定义写帧缓冲的方法就执行</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_write)</span><br><span class="line">		<span class="keyword">return</span> info-&gt;fbops-&gt;fb_write(info, buf, count, ppos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*************执行通用的写帧缓冲的方法*************/</span></span><br><span class="line">	<span class="comment">//虚拟内存的大小</span></span><br><span class="line">	total_size = info-&gt;screen_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (total_size == <span class="number">0</span>)</span><br><span class="line">		total_size = info-&gt;fix.smem_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p &gt; total_size)</span><br><span class="line">		<span class="keyword">return</span> -EFBIG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; total_size) &#123;</span><br><span class="line">		err = -EFBIG;</span><br><span class="line">		count = total_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查偏移量加上写入数据的大小是否超过虚拟内存的大小</span></span><br><span class="line">	<span class="keyword">if</span> (count + p &gt; total_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			err = -ENOSPC;</span><br><span class="line"></span><br><span class="line">		count = total_size - p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buffer = kmalloc((count &gt; PAGE_SIZE) ? PAGE_SIZE : count,</span><br><span class="line">			 GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buffer)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到要写入帧缓冲区的起始地址:帧缓冲虚拟起始地址加上偏移量</span></span><br><span class="line">	dst = (u32 __iomem *) (info-&gt;screen_base + p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于某些帧缓冲设备来说，必须等待它完成之前的显示处理操作，</span></span><br><span class="line">	<span class="comment">//才能继续向帧缓冲中送入显示数据，该方t法用于该过程的同步</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_sync)</span><br><span class="line">		info-&gt;fbops-&gt;fb_sync(info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向帧缓冲写入count个字节数据，如果写入的数据超过一个页的大小，则分多次写入</span></span><br><span class="line">	<span class="keyword">while</span> (count) &#123;</span><br><span class="line">		<span class="comment">//将预写数据依次读到buffer中，每次写数据不超过PAGE_SIZE大小</span></span><br><span class="line">		c = (count &gt; PAGE_SIZE) ? PAGE_SIZE : count;</span><br><span class="line">		src = buffer;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//把数据从用户空间拷贝到内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(src, buf, c)) &#123;</span><br><span class="line">			err = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将数据写入到目标帧缓冲区地址</span></span><br><span class="line">		<span class="keyword">for</span> (i = c &gt;&gt; <span class="number">2</span>; i--; )</span><br><span class="line">			fb_writel(*src++, dst++);</span><br><span class="line">		<span class="keyword">if</span> (c &amp; <span class="number">3</span>) &#123;</span><br><span class="line">			u8 *src8 = (u8 *) src;</span><br><span class="line">			u8 __iomem *dst8 = (u8 __iomem *) dst;</span><br><span class="line">			<span class="keyword">for</span> (i = c &amp; <span class="number">3</span>; i--; )</span><br><span class="line">				fb_writeb(*src8++, dst8++);</span><br><span class="line">			dst = (u32 __iomem *) dst8;</span><br><span class="line">		&#125;</span><br><span class="line">		*ppos += c;</span><br><span class="line">		buf += c;</span><br><span class="line">		cnt += c;</span><br><span class="line">		count -= c;</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(buffer);</span><br><span class="line">	<span class="keyword">return</span> (cnt) ? cnt : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-3-3-fb-mmap">2.4.3.3 fb_mmap</span><a href="#2-4-3-3-fb-mmap" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fb_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct * vma)</span>&#123;</span><br><span class="line">	<span class="comment">//获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(file-&gt;f_path.dentry-&gt;d_inode);</span><br><span class="line">	<span class="comment">//根据次设备号获取到struct fb_info 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];</span><br><span class="line">	<span class="comment">//得到驱动的fbops操作方法</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fb</span> =</span> info-&gt;fbops;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> off;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line">	u32 len;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_pgoff &gt; (~<span class="number">0UL</span> &gt;&gt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	off = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">if</span> (!fb)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	mutex_lock(&amp;info-&gt;mm_lock);</span><br><span class="line">	<span class="comment">//如果fb_ops中实现了mmap方法，则调用之</span></span><br><span class="line">	<span class="keyword">if</span> (fb-&gt;fb_mmap) &#123;</span><br><span class="line">		<span class="type">int</span> res;</span><br><span class="line">		res = fb-&gt;fb_mmap(info, vma);</span><br><span class="line">		mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*******下面是通用的mmap方法********/</span></span><br><span class="line">	<span class="comment">/* 获取映射帧缓冲的物理起始地址和长度 */</span></span><br><span class="line">	start = info-&gt;fix.smem_start;</span><br><span class="line">	len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.smem_len);</span><br><span class="line">	<span class="keyword">if</span> (off &gt;= len) &#123;</span><br><span class="line">		<span class="comment">/* 如果off大于帧缓冲长度．则认为映射的是内存映射IO */</span></span><br><span class="line">		off -= len;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;var.accel_flags) &#123;</span><br><span class="line">			mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取内存映射IO的物理起始地址和长度</span></span><br><span class="line">		start = info-&gt;fix.mmio_start;</span><br><span class="line">		len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.mmio_len);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">	<span class="comment">//保证页对齐</span></span><br><span class="line">	start &amp;= PAGE_MASK;</span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start + off) &gt; len)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">//现在off表示映射设备内存实际的物理地址</span></span><br><span class="line">	off += start;</span><br><span class="line">	vma-&gt;vm_pgoff = off &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="comment">/* This is an IO map - tell maydump to skip this VMA */</span></span><br><span class="line">	vma-&gt;vm_flags |= VM_IO | VM_RESERVED;</span><br><span class="line">	<span class="comment">//置页保护标识</span></span><br><span class="line">	fb_pgprotect(file, vma, off);</span><br><span class="line">	<span class="comment">//建立从物理页帧号为 off》PAGE SH 工FT的物理内存，到虚拟地址为 vma-&gt;vm start 、</span></span><br><span class="line">	<span class="comment">//大小为 vma-&gt;vm_end - vma-&gt;vm_start 、页保护标志为 vma-&gt;vm_page_prot的映射</span></span><br><span class="line">	<span class="keyword">if</span> (io_remap_pfn_range(vma, vma-&gt;vm_start, off &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			     vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="2-4-3-4-fb-ioctl">2.4.3.4 fb_ioctl</span><a href="#2-4-3-4-fb-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>FBIOGET_VSCREENINFO</td>
<td>获取屏幕可变参数</td>
</tr>
<tr>
<td>FBIOPUT_VSCREENINFO</td>
<td>设置屏幕可变参数</td>
</tr>
<tr>
<td>FBIOGET_FSCREENINFO</td>
<td>获取屏幕固定参数</td>
</tr>
<tr>
<td>FBIOPUTCMAP</td>
<td>设置颜色表</td>
</tr>
<tr>
<td>FBIOGETCMAP</td>
<td>获取颜色表</td>
</tr>
<tr>
<td>FBIOPAN_DISPLAY</td>
<td>动视窗显示</td>
</tr>
<tr>
<td>FBIO_CURSOR</td>
<td>光标设置，目前不支持</td>
</tr>
<tr>
<td>FBIOGET_CON2FBMAP</td>
<td>获取指定帧缓冲控制台对应的帧缓冲设备</td>
</tr>
<tr>
<td>FBIOPUT_CON2FBMAP</td>
<td>置指定的帧缓冲控制台对应的帧缓冲设备</td>
</tr>
<tr>
<td>FBIOBLANK</td>
<td>显示空白</td>
</tr>
</tbody></table>
<h1><span id="3-framebuffer-qu-dong-shi-li">3 Framebuffer驱动实例</span><a href="#3-framebuffer-qu-dong-shi-li" class="header-anchor">#</a></h1><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h2><span id="3-1-ding-yi-fb-info-shi-li">3.1定义fb_info实例</span><a href="#3-1-ding-yi-fb-info-shi-li" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>以飞思卡尔nxp的LCD控制器来说，叫做<code>lcdif</code>。位于<code>drivers/video/fbdev/mxsfb.c</code>,以像素时钟模式为例：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<h3><span id="3-1-0-kong-zhi-qi-dts-pei-zhi">3.1.0 控制器dts配置</span><a href="#3-1-0-kong-zhi-qi-dts-pei-zhi" class="header-anchor">#</a></h3><p>打开<code>imx6ull.dtsi</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lcdif: lcdif@<span class="number">021</span>c8000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx6u  l-lcdif&quot;</span>, <span class="string">&quot;fsl,imx28-lcdif&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x021c8000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;disp_axi&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>compatible</code>匹配，<code>probe</code>执行。</p>
<h3><span id="3-1-1-mxsfb-probe-guo-cheng-fen-xi">3.1.1 mxsfb_probe过程分析</span><a href="#3-1-1-mxsfb-probe-guo-cheng-fen-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxsfb_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line">			of_match_device(mxsfb_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxsfb_info</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fb_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line">	<span class="type">int</span> irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> gpio, ret;</span><br><span class="line">	<span class="keyword">if</span> (of_id)</span><br><span class="line">		pdev-&gt;id_entry = of_id-&gt;data;</span><br><span class="line">	gpio = of_get_named_gpio(pdev-&gt;dev.of_node, <span class="string">&quot;enable-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (gpio == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(gpio)) &#123;</span><br><span class="line">		ret = devm_gpio_request_one(&amp;pdev-&gt;dev, gpio, GPIOF_OUT_INIT_LOW, <span class="string">&quot;lcd_pwr_en&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;faild to request gpio %d, ret = %d\n&quot;</span>, gpio, ret);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Cannot get memory IO resource\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	host = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mxsfb_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!host) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate IO resource\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	fb_info = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info), &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!fb_info) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate fbdev\n&quot;</span>);</span><br><span class="line">		devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	host-&gt;fb_info = fb_info;</span><br><span class="line">	fb_info-&gt;par = host;</span><br><span class="line">	ret = devm_request_irq(&amp;pdev-&gt;dev, irq, mxsfb_irq_handler, <span class="number">0</span>,</span><br><span class="line">			  dev_name(&amp;pdev-&gt;dev), host);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;request_irq (%d) failed with error %d\n&quot;</span>,</span><br><span class="line">				irq, ret);</span><br><span class="line">		ret = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;base)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;ioremap failed\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(host-&gt;base);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line">	host-&gt;pdev = pdev;</span><br><span class="line">	platform_set_drvdata(pdev, host);</span><br><span class="line"></span><br><span class="line">	host-&gt;devdata = &amp;mxsfb_devdata[pdev-&gt;id_entry-&gt;driver_data];</span><br><span class="line">	host-&gt;clk_pix = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;pix&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_pix)) &#123;</span><br><span class="line">		host-&gt;clk_pix = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_pix);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;clk_axi = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;axi&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_axi)) &#123;</span><br><span class="line">		host-&gt;clk_axi = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_axi);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;clk_disp_axi = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;disp_axi&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_disp_axi)) &#123;</span><br><span class="line">		host-&gt;clk_disp_axi = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_disp_axi);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;reg_lcd = devm_regulator_get(&amp;pdev-&gt;dev, <span class="string">&quot;lcd&quot;</span>);<span class="comment">//电流整流:和电源管理有关，实现低功耗</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;reg_lcd))</span><br><span class="line">		host-&gt;reg_lcd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fb_info-&gt;pseudo_palette = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(u32) * <span class="number">16</span>,</span><br><span class="line">					       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pseudo_palette) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	pm_runtime_enable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = mxsfb_init_fbinfo(host);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"></span><br><span class="line">	mxsfb_dispdrv_init(pdev, fb_info);</span><br><span class="line">	<span class="keyword">if</span> (!host-&gt;dispdrv) &#123;</span><br><span class="line">		pinctrl = devm_pinctrl_get_select_default(&amp;pdev-&gt;dev);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(pinctrl)) &#123;</span><br><span class="line">			ret = PTR_ERR(pinctrl);</span><br><span class="line">			<span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!host-&gt;enabled) &#123;</span><br><span class="line">		writel(<span class="number">0</span>, host-&gt;base + LCDC_CTRL);</span><br><span class="line">		mxsfb_set_par(fb_info);</span><br><span class="line">		mxsfb_enable_controller(fb_info);</span><br><span class="line">		pm_runtime_get_sync(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = register_framebuffer(fb_info);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register framebuffer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fb_destroy;</span><br><span class="line">	&#125;</span><br><span class="line">	console_lock();</span><br><span class="line">	ret = fb_blank(fb_info, FB_BLANK_UNBLANK);</span><br><span class="line">	console_unlock();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to unblank framebuffer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fb_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;initialized\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fb_unregister:</span><br><span class="line">	unregister_framebuffer(fb_info);</span><br><span class="line">fb_destroy:</span><br><span class="line">	<span class="keyword">if</span> (host-&gt;enabled)</span><br><span class="line">		clk_disable_unprepare(host-&gt;clk_pix);</span><br><span class="line">	fb_destroy_modelist(&amp;fb_info-&gt;modelist);</span><br><span class="line">fb_pm_runtime_disable:</span><br><span class="line">	pm_runtime_disable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line">	devm_kfree(&amp;pdev-&gt;dev, fb_info-&gt;pseudo_palette);</span><br><span class="line">fb_release:</span><br><span class="line">	framebuffer_release(fb_info);</span><br><span class="line">	devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>host</code> 结构体指针变量，表示<code>LDCIF</code>控制器，包含Framebuffer设备详细信息，比如<code>时钟</code>、<code>eLCDIF</code> 控制器<code>寄存器基地址</code>、<code>fb_info </code>等。</p>
</li>
<li><p>从dts中提取<code>gpio, irq, res,时钟</code>等信息。初始化<code>host, fb_info</code>等结构体。</p>
</li>
<li><p><code>host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</code>对io内存进行<code>ioremap</code>, 把<code>eLCDIF </code>控制器地址映射成虚拟地址。</p>
</li>
<li><p><code>mxsfb_init_fbinfo</code>:</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<ol>
<li><p>设置<code>eLCDIF</code>控制器具体的<code>fb_ops</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> fb_ops mxsfb_ops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.fb_check_var = mxsfb_check_var,</span><br><span class="line">	.fb_set_par = mxsfb_set_par,</span><br><span class="line">	.fb_setcolreg = mxsfb_setcolreg,</span><br><span class="line">	.fb_ioctl = mxsfb_ioctl,</span><br><span class="line">	.fb_blank = mxsfb_blank,</span><br><span class="line">	.fb_pan_display = mxsfb_pan_display,</span><br><span class="line">	.fb_mmap = mxsfb_mmap,</span><br><span class="line">	.fb_fillrect = cfb_fillrect,</span><br><span class="line">	.fb_copyarea = cfb_copyarea,</span><br><span class="line">	.fb_imageblit = cfb_imageblit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从dts获取LCD 的各个参数信息，然后调用<code>mxsfb_map_videomem</code>申请framebuffer空间，也就是显存。</p>
</li>
</ol>
</li>
<li><p><code>fb_videomode_to_var</code>设置ldc的可变属性</p>
</li>
<li><p>设置控制器寄存器信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writel(<span class="number">0</span>, host-&gt;<span class="keyword">base</span> + LCDC_CTRL);</span><br><span class="line">mxsfb_set_par(fb_info);</span><br><span class="line">mxsfb_enable_controller(fb_info);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>register_framebuffer </code>函数向 Linux 内核注册 <code>fb_info</code>。</p>
</li>
</ol>
<p>在<code>mxsfb.c</code>中已经定义了<code> eLCDIF</code> 控制器各个寄存器相比于基地址的偏移值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_CTRL			0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_CTRL1			0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_CTRL2			0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_TRANSFER_COUNT		0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_TRANSFER_COUNT		0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_CUR_BUF			0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_NEXT_BUF		0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_CUR_BUF			0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_NEXT_BUF		0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_TIMING			0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL0			0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL1			0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL2			0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL3			0xa0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL4			0xb0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL0			0xc0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL1			0xd0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL2			0xe0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL3			0xf0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL4			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_DATA			0x180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_DATA			0x1b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_DEBUG0			0x1d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_DEBUG0			0x1f0</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-lcd-ping-mu-dts-miao-shu">3.2 LCD屏幕dts描述</span><a href="#3-2-lcd-ping-mu-dts-miao-shu" class="header-anchor">#</a></h2><h3><span id="3-2-1-ping-mu-io-pei-zhi">3.2.1 屏幕 IO 配置</span><a href="#3-2-1-ping-mu-io-pei-zhi" class="header-anchor">#</a></h3><p>除了<code>eLCDIF</code> 控制器，对LCD设备也需要进行描述，主要是引脚pinmux。比如<code>imx6ull-alientek-emmc.dts</code>这块板子对应的LCD屏幕使用引脚如下，<code>iomuxc </code>节点下有如下节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_dat: lcdifdatgrp &#123;<span class="comment">//数据引脚，24根，rgb888</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  <span class="number">0x79</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;<span class="comment">//控制引脚，hsync vsync pixclk en等...</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_LCD_CLK__LCDIF_CLK        <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    <span class="number">0x79</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_pwm1: pwm1grp &#123;<span class="comment">//背光亮度</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_GPIO1_IO08__PWM1_OUT   <span class="number">0x110b0</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以及iomixc_snvs下有一个reset节点：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_dat，为 RGB LCD 的 24 根数据线配置项</span><br><span class="line">pinctrl_lcdif_ctrl，RGB LCD 的 4 根控制线配置项，包括 CLK、 ENABLE、VSYNC 和 HSYNC</span><br><span class="line">pinctrl_pwm1，LCD 背光 PWM 引脚配置项</span><br></pre></td></tr></table></figure>

<p>可以看到控制和数据引脚的电器属性默认nxp都帮我们设置成了0x79。</p>
<h3><span id="3-2-2-ping-mu-jie-dian">3.2.2 屏幕节点</span><a href="#3-2-2-ping-mu-jie-dian" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat <span class="comment">/* 使用到的 IO */</span></span><br><span class="line">            &amp;pinctrl_lcdif_ctrl</span><br><span class="line">            &amp;pinctrl_lcdif_reset&gt;;</span><br><span class="line">	display = &lt;&amp;display0&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	display0: display &#123; <span class="comment">/* LCD 属性信息 */</span></span><br><span class="line">		bits-per-pixel = &lt;<span class="number">16</span>&gt;; <span class="comment">/* 一个像素占用几个 bit */</span></span><br><span class="line">		bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line">		display-timings &#123;</span><br><span class="line">			native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">			timing0: timing0 &#123;</span><br><span class="line">				clock-frequency = &lt;<span class="number">9200000</span>&gt;; <span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">				hactive = &lt;<span class="number">480</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">				vactive = &lt;<span class="number">272</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">				hfront-porch = &lt;<span class="number">8</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">				hback-porch = &lt;<span class="number">4</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">				hsync-len = &lt;<span class="number">41</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">				vback-porch = &lt;<span class="number">2</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">				vfront-porch = &lt;<span class="number">4</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">				vsync-len = &lt;<span class="number">10</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line">				hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">				vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">				de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">				pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>display0 </code>子节点，描述 LCD 的参数信息，包括<code>bpp, bus-width</code>,时序特性，这些参数跟随具体的屏厂屏幕规格走。例如另一款屏幕<code>ATK7016(7 寸 1024*600)</code>屏幕：可以看到这款屏幕是<code>RGB888</code>的，<code>bpp是3byte</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">display0: display &#123;</span><br><span class="line">	bits-per-pixel = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 一个像素占用 24bit */</span></span><br><span class="line">	bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line">	display-timings &#123;</span><br><span class="line">		native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">		timing0: timing0 &#123;</span><br><span class="line">			clock-frequency = &lt;<span class="number">51200000</span>&gt;;<span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">			hactive = &lt;<span class="number">1024</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">			vactive = &lt;<span class="number">600</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">			hfront-porch = &lt;<span class="number">160</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">			hback-porch = &lt;<span class="number">140</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">			hsync-len = &lt;<span class="number">20</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">			vback-porch = &lt;<span class="number">20</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">			vfront-porch = &lt;<span class="number">12</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">			vsync-len = &lt;<span class="number">3</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line">			hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">			vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">			de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">			pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-bei-guang-jie-dian">3.2.3 背光节点</span><a href="#3-2-3-bei-guang-jie-dian" class="header-anchor">#</a></h3><p>LCD 背光要用到 <code>PWM1</code>，因此也要设置 <code>PWM1</code> 节点，如果背光只用简单的<code>gpio</code>，那么只能控制亮灭。无法控制亮度, 在<code>imx6ull.dtsi</code>文件中找到<code>pwm1</code>描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm1: pwm@<span class="number">02080000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02080000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">83</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line">			&lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	<span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>imx6ull 的 PWM 驱动文件为<code> drivers/pwm/pwm-imx.c</code>，具体见xxxxx。只要会使用pwm1即可，打开<code>imx6ull-alientek-emmc.dts</code>这块板子：</p>
<p>往pwm1添加如下内容,设置好pwm1对应的引脚：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm1 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是<code>MX6UL_PAD_GPIO1_IO08__PWM1_OUT</code>，将<code>gpio1_8</code>设成pwm输出。</p>
<h4><span id="3-2-3-1-backlight-she-zhi">3.2.3.1 backlight设置</span><a href="#3-2-3-1-backlight-she-zhi" class="header-anchor">#</a></h4><p>我们还需要一个节点来将 <code>LCD 背光</code>和<code> PWM1_OUT</code> 连接起来。这个节点就是 <code>backlight</code> ， <code>backlight </code>节点描述可以参考 <code>Documentation/devicetree/indings/video/backlight/pwm-backlight.txt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">	compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">	pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;</span><br><span class="line">	brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;</span><br><span class="line">	<span class="keyword">default</span>-brightness-level = &lt;<span class="number">6</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>设置背 <code>8 级背光(0~7)</code>，分别为 <code>0、4、8、16、32、64、128、255</code>，对应占空比为 <code>0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%</code>，如果嫌少的话可以自行添加一 些其他的背光等级值。 </p>
</li>
<li><p>设置默认背光等级为 6，也就是<code> 50.19%</code>的亮度</p>
</li>
</ol>
<p>backlight 节点说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 节点名称要为“backlight”</span><br><span class="line">2. compatible 属性值要为“pwm-backlight”，因此可以通过在 Linux 内核中搜索 “ pwm-backlight ” </span><br><span class="line">	来查找PWM背光控制驱动程序 ， 文件为 drivers/video/backlight/pwm_bl.c</span><br><span class="line">3. pwms属性用于描述背光所使用的PWM以及PWM频率，比如本章我们要使用的pwm1， pwm 频率设置为 200Hz</span><br><span class="line">4. brightness-levels 属性描述亮度级别，范围为 0~255，0 表示 PWM 占空比为 0%，也就 是亮度最低，</span><br><span class="line">	255 表示 100%占空比，也就是亮度最高</span><br><span class="line">5. default-brightness-level 属性为默认亮度级别</span><br></pre></td></tr></table></figure>

<h1><span id="4-lcd-ce-shi">4 LCD测试</span><a href="#4-lcd-ce-shi" class="header-anchor">#</a></h1><h2><span id="4-1-shi-neng-linux-logo">4.1 使能 Linux logo</span><a href="#4-1-shi-neng-linux-logo" class="header-anchor">#</a></h2><p>Linux 内核启动的时候可以选择显示小企鹅 logo，一般默认关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Graphics support</span><br><span class="line">		-&gt; Bootup <span class="title function_">logo</span> <span class="params">(LOGO [=y])</span></span><br><span class="line">                -&gt; Standard black and white Linux logo</span><br><span class="line">                -&gt; Standard 16-color Linux logo</span><br><span class="line">                -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure>

<p>三个选项分别对应黑白、16 位、24 位色彩格式的 logo，我们把这三个都选 中，都编译进 Linux 内核里面。</p>
<h2><span id="4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console">4.2 LCD 作为终端控制台console</span><a href="#4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console" class="header-anchor">#</a></h2><ol>
<li><p>u-boot中bootargs设置</p>
<p><code>setenv bootargs &#39;console=tty1 console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.1.250: /home/zuozhongkai/linux/nfs/rootfs ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0: off&#39;</code></p>
<p>第一次设置 <code>console=tty1</code>， 也就是设置 LCD 屏幕为控制台，第二遍又设置<code> console=ttymxc0,115200</code>，也就是设置串口也作为控制台。大家重启开发板就会发 现 LCD 和串口都会显示 Linux 启动 log 信息。</p>
</li>
<li><p>修改<code>/etc/inittab</code></p>
<p>添加下面这行，</p>
<p><code>tty1::askfirst:-/bin/sh</code></p>
</li>
</ol>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>   修改完成以后保存<code>/etc/inittab </code>并退出，然后重启开发板，重启以后开发板 LCD 屏幕最后一 行会显示下面一行语句:</p>
<p>   <code>Please press Enter to activate this console</code></p>
<p>   为什么请参考: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18019053">linux内核-4.rootfs构建移植</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/">Linux内核-rootfs构建移植 | Hexo (fuzidage.github.io)</a></p>
<p>   大家也可以接上一个 USB 键盘，Linux 内核默认已经使能了 USB 键盘驱动 了，因此可以直接使用 USB 键盘Enter键。</p>
<p>   当然也可以利用input子系统来用一个gpio按键做成Enter键。见: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18114268">linux驱动-17-input子系统</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-3-lcd-bei-guang-diao-jie-ming-ling">4.3 LCD 背光调节命令</span><a href="#4-3-lcd-bei-guang-diao-jie-ming-ling" class="header-anchor">#</a></h2><p>前面背光设备树节点设置了 8 个等级的背光调节，可以设置为<code> 0~7</code>，我 们可以通过设置背光等级来实现 LCD 背光亮度的调节：</p>
<p>   <code>/sys/devices/platform/backlight/backlight/backlight</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p><code>echo 7 &gt; brightness</code>设置亮度为<code>100%</code>，<code> echo 0 &gt;brightness</code>设置成熄灭背光。</p>
<h2><span id="4-4-lcd-ping-mu-zi-dong-xi-mie">4.4 LCD屏幕自动熄灭</span><a href="#4-4-lcd-ping-mu-zi-dong-xi-mie" class="header-anchor">#</a></h2><h3><span id="4-1-1-an-jian-pan-huan-xing">4.1.1 按键盘唤醒</span><a href="#4-1-1-an-jian-pan-huan-xing" class="header-anchor">#</a></h3><p>默认情况下 10 分钟以后 LCD 就会熄屏，这个并不是代码有问题，而是 Linux 内核设置的。按下回车键就会唤醒屏幕。</p>
<h3><span id="4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping">4.1.2 关闭10分钟自动熄屏</span><a href="#4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping" class="header-anchor">#</a></h3><ol>
<li><code>drivers/tty/vt/vt.c</code>中, <code>blankinterval</code> 变量控制着 LCD 关闭时间，默认是 <code>10*60</code>，也就是 10 分钟。将<code> blankinterval</code> 的值改为 0 即可关闭 10 分钟熄屏的功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">181</span> <span class="type">static</span> <span class="type">int</span> blankinterval = <span class="number">10</span>*<span class="number">60</span>;</span><br><span class="line"><span class="number">182</span> core_param(consoleblank, blankinterval, <span class="type">int</span>, <span class="number">0444</span>);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><code>echo -e &#39;\033[9;0]&#39; &gt; /dev/tty0</code></li>
</ol>
<h2><span id="4-5-ce-shi-dai-ma">4.5 测试代码</span><a href="#4-5-ce-shi-dai-ma" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAUSE()                                                                    \</span></span><br><span class="line"><span class="meta">    do &#123;    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;---------------press Enter key to continue!---------------\n&quot;</span>);    \</span></span><br><span class="line"><span class="meta">        getchar();                                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1	<span class="comment">// 32bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED      0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN    0xFF00FF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE     0xFF0000FF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW   0xFFFFFF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE    0xFFFFFFFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK    0xFF000000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_color</span><span class="params">(<span class="type">uint32_t</span> *fb_addr, <span class="type">uint32_t</span> bit_map, <span class="type">int</span> psize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">        *fb_addr = bit_map;</span><br><span class="line">        fb_addr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">// 16bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED      0xFC00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN    0x83E0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE     0x801F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW   0xFFE0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE    0xFFFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK    0x8000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_color</span><span class="params">(<span class="type">short</span> *fb_addr, <span class="type">short</span> bit_map, <span class="type">int</span> psize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">        *fb_addr = bit_map;</span><br><span class="line">        fb_addr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fb_get_info(<span class="type">int</span> fp, <span class="keyword">struct</span> fb_fix_screeninfo *finfo, <span class="keyword">struct</span> fb_var_screeninfo *vinfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> screensize=<span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOGET_FSCREENINFO, finfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading fixed information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOGET_VSCREENINFO, vinfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading variable information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    screensize = finfo-&gt;line_length * vinfo-&gt;yres;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The ID=%s\n&quot;</span>, finfo-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phy mem = 0x%x, total size = %d(byte)\n&quot;</span>, finfo-&gt;smem_start, finfo-&gt;smem_len);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;line length = %d(byte)\n&quot;</span>, finfo-&gt;line_length);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xres = %d, yres = %d, bits_per_pixel = %d\n&quot;</span>, vinfo-&gt;xres, vinfo-&gt;yres, vinfo-&gt;bits_per_pixel);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xresv = %d, yresv = %d\n&quot;</span>, vinfo-&gt;xres_virtual, vinfo-&gt;yres_virtual);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.xoffset = %d, vinfo.yoffset = %d\n&quot;</span>, vinfo-&gt;xoffset, vinfo-&gt;yoffset);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.vmode is :%d\n&quot;</span>, vinfo-&gt;vmode);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finfo.ypanstep is :%d\n&quot;</span>, finfo-&gt;ypanstep);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.red.offset=0x%x\n&quot;</span>, vinfo-&gt;red.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.red.length=0x%x\n&quot;</span>, vinfo-&gt;red.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.green.offset=0x%x\n&quot;</span>, vinfo-&gt;green.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.green.length=0x%x\n&quot;</span>, vinfo-&gt;green.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.blue.offset=0x%x\n&quot;</span>, vinfo-&gt;blue.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.blue.length=0x%x\n&quot;</span>, vinfo-&gt;blue.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.transp.offset=0x%x\n&quot;</span>, vinfo-&gt;transp.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.transp.length=0x%x\n&quot;</span>, vinfo-&gt;transp.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Expected screensize = %d(byte), using %d frame\n&quot;</span>, screensize, finfo-&gt;smem_len/screensize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   &#123;  </span><br><span class="line">    <span class="type">int</span> fp=<span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span>  </span><br><span class="line">    <span class="type">void</span> *fbp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="type">char</span> *test_fbp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">long</span> location = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pix_size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fp = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error : Can not open framebuffer device/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-- Default fb info --\n&quot;</span>);</span><br><span class="line">    _fb_get_info(fp, &amp;finfo, &amp;vinfo);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    vinfo.xres = <span class="number">720</span>;</span><br><span class="line">    vinfo.yres = <span class="number">1280</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOPUT_VSCREENINFO, &amp;vinfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error putting variable information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-- Updated fb info --\n&quot;</span>);</span><br><span class="line">    _fb_get_info(fp, &amp;finfo, &amp;vinfo);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    fbp = mmap(<span class="number">0</span>, finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fbp == MAP_FAILED)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Error: failed to map framebuffer device to memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">4</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get virt mem = %p\n&quot;</span>, fbp);  </span><br><span class="line"></span><br><span class="line">    pix_size = vinfo.xres * vinfo.yres;</span><br><span class="line">    <span class="comment">/* using first frame, for FBIOPAN_DISPLAY</span></span><br><span class="line"><span class="comment">     * 当刷新需要调用FBIOPAN_DISPLAY， 要告知驱动刷哪块帧， 用到下面两个参数</span></span><br><span class="line"><span class="comment">     * 如果使用第二帧buffer -&gt; vinfo.xoffset = 0; vinfo.yoffset = vinfo.yres;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vinfo.xoffset = <span class="number">0</span>;</span><br><span class="line">    vinfo.yoffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* show color loop */</span></span><br><span class="line">    <span class="keyword">while</span>(num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing YELLOW......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, YELLOW, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing BLUE......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, BLUE, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing RED......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, RED, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">	PAUSE();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">/*这是你想画的点的位置坐标,(0，0)点在屏幕左上角*/</span></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    location = x * (vinfo.bits_per_pixel / <span class="number">8</span>) + y  *  finfo.line_length;</span><br><span class="line">    test_fbp = fbp + location;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw line.......\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (vinfo.xres - x); i++)</span><br><span class="line">        *test_fbp++ = i+<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">    PAUSE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    munmap(fbp, finfo.smem_len); <span class="comment">/*解除映射*/</span></span><br><span class="line"></span><br><span class="line">    close (fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0japrcz0000v4uf9o68952v" data-title="字符设备驱动-Framebuffer子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-PWM子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-01T04:28:35.000Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pwm-zi-xi-tong-kuang-jia">1 pwm子系统框架</a><ul>
<li><a href="#1-1-yuan-ma-jie-gou">1.1 源码结构</a></li>
<li><a href="#1-2-shu-ju-jie-gou">1.2 数据结构</a><ul>
<li><a href="#1-2-1-pwm-chip">1.2.1 <code>pwm_chip</code></a></li>
<li><a href="#1-2-2-pwm-ops">1.2.2 <code>pwm_ops</code></a></li>
<li><a href="#1-2-3-pwm-state">1.2.3 <code>pwm_state</code></a></li>
</ul>
</li>
<li><a href="#1-3-api">1.3 API</a><ul>
<li><a href="#1-3-1-pwmchip-add">1.3.1 <code>pwmchip_add</code></a></li>
<li><a href="#1-3-2-pwmchip-remove">1.3.2 <code>pwmchip_remove</code></a></li>
<li><a href="#1-3-3-pwm-request">1.3.3 pwm_request</a></li>
<li><a href="#1-3-4-pwm-free">1.3.4 pwm_free</a></li>
<li><a href="#1-3-5-pwm-config">1.3.5 <code>pwm_config</code></a></li>
<li><a href="#1-3-6-pwm-set-polarity">1.3.6 <code>pwm_set_polarity</code></a></li>
<li><a href="#1-3-6-pwm-enable">1.3.6 pwm_enable</a></li>
<li><a href="#1-3-7-pwm-disable">1.3.7 pwm_disable</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-pwm-qu-dong-shi-li">2 pwm驱动实例</a><ul>
<li><a href="#2-1-dts-miao-shu">2.1 dts描述</a></li>
<li><a href="#2-2-shi-neng-pwm-qu-dong">2.2 使能PWM驱动</a></li>
<li><a href="#2-3-pwm-bei-guang-she-zhi">2.3 PWM 背光设置</a></li>
<li><a href="#2-4-qu-dong-yuan-ma-fen-xi">2.4 驱动源码分析</a><ul>
<li><a href="#2-4-1-probe-guo-cheng">2.4.1 probe过程</a><ul>
<li><a href="#2-4-1-1-imx-chip">2.4.1.1 imx_chip</a></li>
</ul>
</li>
<li><a href="#2-4-2-imx-pwm-ops">2.4.2 imx_pwm_ops</a><ul>
<li><a href="#2-4-2-1-imx-pwm-config">2.4.2.1 imx_pwm_config</a></li>
<li><a href="#2-4-2-2-imx-pwm-enable">2.4.2.2 imx_pwm_enable</a></li>
<li><a href="#2-4-2-3-imx-pwm-disable">2.4.2.3 imx_pwm_disable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ji-yu-pwm-sysfs-ce-shi">3 基于pwm sysfs测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pwm-zi-xi-tong-kuang-jia">1 pwm子系统框架</span><a href="#1-pwm-zi-xi-tong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>用户态：基于sysfs操作pwm</p>
<p>内核态分为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwm core：pwm_chip的添加删除，pwm_class类pwm_chip/pwm_device的sysfs创建。</span><br><span class="line"></span><br><span class="line">pwm driver：pwm_chip对象实例，注册添加到pwm core。</span><br><span class="line">	pwm_chip可以包含一个或多个pwm_device，每个pwm_device通过设置不同pwm_state来达到目的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="1-1-yuan-ma-jie-gou">1.1 源码结构</span><a href="#1-1-yuan-ma-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drivers/pwm/</span><br><span class="line">	core.c <span class="comment">//pwm子系统核心。</span></span><br><span class="line">	sysfs.c<span class="comment">//pwm子系统的pwm_class注册，pwm_chip属性，pwm_device属性等定义。</span></span><br><span class="line">	pwm-imx.c<span class="comment">//imx的pwm_chip驱动。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p>我已经编译进<code>vmlinux</code>了，可以看到<code>built-in.o</code>。<code>Makefile</code>如下：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p><code>Kconfig</code>如下，我的内核<code>.config</code>配置选中了<code>PWM和PWM_IMX</code>，因此编译进了内核镜像。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<h2><span id="1-2-shu-ju-jie-gou">1.2 数据结构</span><a href="#1-2-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-2-1-pwm-chip">1.2.1 <code>pwm_chip</code></span><a href="#1-2-1-pwm-chip" class="header-anchor">#</a></h3><p>是对一个pwm控制器的抽象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_chip</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> npwm;<span class="comment">//pwm控制器的pwm数量。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> * (*<span class="title">of_xlate</span>)(<span class="keyword">struct</span> <span class="title">pwm_chip</span> *<span class="title">pc</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">args</span>);</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> of_pwm_n_cells;</span><br><span class="line">    <span class="comment">/* only used internally by the PWM framework */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> *<span class="title">pwms</span>;</span></span><br><span class="line">&#125;; <span class="comment">//include/linux/pwm.h</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-pwm-ops">1.2.2 <code>pwm_ops</code></span><a href="#1-2-2-pwm-ops" class="header-anchor">#</a></h3><p>pwm控制器的操作接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*request)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//请求 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//释放 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">int</span> (*config)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//配置 PWM 周期和占空比</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">	<span class="type">int</span> duty_ns, <span class="type">int</span> period_ns);</span><br><span class="line">	<span class="type">int</span> (*set_polarity)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//设置 PWM 极性</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">	<span class="keyword">enum</span> pwm_polarity polarity);</span><br><span class="line">	<span class="type">int</span> (*enable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//使能 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">void</span> (*disable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//关闭 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-pwm-state">1.2.3 <code>pwm_state</code></span><a href="#1-2-3-pwm-state" class="header-anchor">#</a></h3><p>pwm_state就是控制占空比控制转速，亮度参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_state</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> period; <span class="comment">//pwm的周期，单位ns。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> duty_cycle; <span class="comment">//占空比duty_cycle，单位ns。</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pwm_polarity</span> <span class="title">polarity</span>;</span><span class="comment">//PWM_POLARITY_NORMAL表示高电平持续duty_cycle，</span></span><br><span class="line">    <span class="comment">//然后是低电平持续剩余时间。PWM_POLARITY_INVERSED表示低电平持续duty_cycle，然后是高电平持续剩余时间。</span></span><br><span class="line">    <span class="type">bool</span> enabled; <span class="comment">//是否使能</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-api">1.3 API</span><a href="#1-3-api" class="header-anchor">#</a></h2><p>api声明见<code>linux\include\linux\pwm.h</code>，实现<code>linux\drivers\pwm\core.c</code></p>
<h3><span id="1-3-1-pwmchip-add">1.3.1 <code>pwmchip_add</code></span><a href="#1-3-1-pwmchip-add" class="header-anchor">#</a></h3><p>向<code>pwm</code>子系统注册一个<code>pwm_chip</code>。</p>
<p><code>int pwmchip_add(struct pwm_chip *chip);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwmchip_add</span><br><span class="line">	pwmchip_add_with_polarity</span><br><span class="line">		-&gt;pwm_ops_check   <span class="comment">//检查pwm_ops是否支持apply等。</span></span><br><span class="line">		-&gt;alloc_pwms     <span class="comment">//为pwm_chip的pwm_device分配allocated_pwms。</span></span><br><span class="line">		-&gt;<span class="comment">//初始化每个pwm_device，并加入pwm_tree。</span></span><br><span class="line">		-&gt;pwmchip_sysfs_export</span><br><span class="line">			-&gt;pwmchip_sysfs_export <span class="comment">//创建pwm_class类设备pwmchpX，位于/sys/class/pwm/pwmchipX。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h3><span id="1-3-2-pwmchip-remove">1.3.2 <code>pwmchip_remove</code></span><a href="#1-3-2-pwmchip-remove" class="header-anchor">#</a></h3><p><code>int pwmchip_remove(struct pwm_chip *chip);</code></p>
<p>删除一个<code>pwm_chip</code>。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h3><span id="1-3-3-pwm-request">1.3.3 pwm_request</span><a href="#1-3-3-pwm-request" class="header-anchor">#</a></h3><p>请求 PWM。</p>
<p><code>struct pwm_device *pwm_request(int pwm, const char *label)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>可以看到就是调用具体pwm示例的request函数。</p>
<h3><span id="1-3-4-pwm-free">1.3.4 pwm_free</span><a href="#1-3-4-pwm-free" class="header-anchor">#</a></h3><p>释放 PWM。</p>
<p><code>void pwm_free(struct pwm_device *pwm)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<h3><span id="1-3-5-pwm-config">1.3.5 <code>pwm_config</code></span><a href="#1-3-5-pwm-config" class="header-anchor">#</a></h3><p>配置 PWM 周期和占空比,操作具体pwm实例。</p>
<p><code>int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<h3><span id="1-3-6-pwm-set-polarity">1.3.6 <code>pwm_set_polarity</code></span><a href="#1-3-6-pwm-set-polarity" class="header-anchor">#</a></h3><p>设置 PWM 极性。</p>
<p><code>int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<h3><span id="1-3-6-pwm-enable">1.3.6 pwm_enable</span><a href="#1-3-6-pwm-enable" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<h3><span id="1-3-7-pwm-disable">1.3.7 pwm_disable</span><a href="#1-3-7-pwm-disable" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p>从<code>1.3.3</code>到<code>1.3.7</code>本质都是调用<code>pwm_ops</code>。</p>
<h1><span id="2-pwm-qu-dong-shi-li">2 pwm驱动实例</span><a href="#2-pwm-qu-dong-shi-li" class="header-anchor">#</a></h1><p><code>I.MX6ULL </code>有 8 路 PWM 控制器。这 8 路 PWM 都属于<code>I.MX6ULL 的 AIPS-1</code>域，但是在设备树<code>imx6ull.dtsi</code>中 分为了两部分，<code>PWM1~PWM4 </code>在一起，<code>PWM5~PWM8</code> 在一起。以<code>pwm3</code>为例：</p>
<h2><span id="2-1-dts-miao-shu">2.1 dts描述</span><a href="#2-1-dts-miao-shu" class="header-anchor">#</a></h2><p>打开<code>imx6ull.dtsi</code>：可以看到<code>pwm3</code>的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm3: pwm@<span class="number">02088000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02088000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">85</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_PWM3&gt;,</span><br><span class="line">	&lt;&amp;clks IMX6UL_CLK_PWM3&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	<span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关 于<code>I.MX6ULL</code>的<code>PWM dts</code>节点描述参考对应的绑定文档 ：<code> Documentation/devicetree/bindings/pwm/ imx-pwm.txt</code></p>
<p><code>GPIO1_IO04 </code>这里作为<code>PWM3</code>的输出引脚，所以我们需要在设备树里面添加 <code>GPIO1_IO04 </code>的引脚信息以及<code>PWM3</code>控制器对应的节点信息:</p>
<p>打开<code> imx6ull-alientek-emmc.dts</code>, 添加<code>iomux</code>配置信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_pwm3: pwm3grp &#123;</span><br><span class="line">	fsl,pins = &lt;MX6UL_PAD_GPIO1_IO04__PWM3_OUT <span class="number">0x110b0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm3 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-shi-neng-pwm-qu-dong">2.2 使能PWM驱动</span><a href="#2-2-shi-neng-pwm-qu-dong" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>从<code>.config</code>中已经使能了，但是为了学习， 我们还是需要知道怎么使能。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">    -&gt; Pulse-Width Modulation (PWM) Support</span><br><span class="line">        -&gt; &lt;*&gt; i.MX PWM support</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-pwm-bei-guang-she-zhi">2.3 PWM 背光设置</span><a href="#2-3-pwm-bei-guang-she-zhi" class="header-anchor">#</a></h2><p> <code>linux</code> 内核里面关于 <code>backlight(背光)</code>的绑定文档，路径为<code> Documentation/devicetree/bindings/video/backlight/pwm-backlight.txt</code>，此文档描述了如何创建<code> backlight 节点</code>来使用<code>linux</code>内核自带的<code>pwm</code>背光驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compatible：内容必须为“pwm-backlight”，通过这个可以匹配到内核自带的 PWM 背光驱</span><br><span class="line">动，驱动文件为 drivers/video/backlight/pwm_bl.c，这里就不去分析驱动源码了。</span><br><span class="line"></span><br><span class="line">pwms：此属性指定背光使用哪一路 PWM，以及 PWM 相关的属性。</span><br><span class="line"></span><br><span class="line">brightness-levels：背光等级数组，范围 <span class="number">0</span>~<span class="number">255</span>，对应占空比为 <span class="number">0</span>%~<span class="number">100</span>%。数组内的值必须</span><br><span class="line">从 <span class="number">0</span> 开始，也就是 <span class="number">0</span>%占空比，最后一个值必须是 <span class="number">255</span>，也就是 <span class="number">100</span>%占空比。数组中间值的个</span><br><span class="line">数以及值大小可以自行定义。</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>-brightness-level：默认的背光等级，也就是 brightness-levels 属性中第几个值，注意</span><br><span class="line">这里是数索引编号，不是具体的数值！</span><br><span class="line"></span><br><span class="line">power-supply：支持的电压，此属性可以不需要</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">    compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">    pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;<span class="comment">// PWM 周期为 5000000ns，频率为 200Hz</span></span><br><span class="line">    brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;</span><br><span class="line">    <span class="keyword">default</span>-brightness-level = &lt;<span class="number">7</span>&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-qu-dong-yuan-ma-fen-xi">2.4 驱动源码分析</span><a href="#2-4-qu-dong-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3><span id="2-4-1-probe-guo-cheng">2.4.1 probe过程</span><a href="#2-4-1-probe-guo-cheng" class="header-anchor">#</a></h3><h4><span id="2-4-1-1-imx-chip">2.4.1.1 imx_chip</span><a href="#2-4-1-1-imx-chip" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>定义了<code>imx_chip</code>，包装了<code>pwm_chip</code>结构。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p>probe时，先分配内存，从dts获取<code>per, ipg</code>等时钟信息，设置pwm的ops为<code>imx_pwm_ops</code>。最后<code>pwmchip_add</code>注册进pwm子系统。注意这里有一个<code>of_id-&gt;data</code>,对应如下：可以看到有<code>v1,v2两2版本</code>，到时候会被ops中的函数调用。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></p>
<p>同理，驱动卸载最后调用<code>pwmchip_remove</code>注销pwm。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"></p>
<h3><span id="2-4-2-imx-pwm-ops">2.4.2 imx_pwm_ops</span><a href="#2-4-2-imx-pwm-ops" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<h4><span id="2-4-2-1-imx-pwm-config">2.4.2.1 imx_pwm_config</span><a href="#2-4-2-1-imx-pwm-config" class="header-anchor">#</a></h4><p>配置 PWM 周期和占空比。根据dts描述(<code>”imx27-pwm“</code>)我们使用的是v2。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p><code>PWMv2</code>会有4 word的采样fifo, 为了避免采样FIFO溢出，当pwm关闭时，对所有采样FIFO进行软件复位。当pwm使能后处于工作中，要等待完整的 PWM 周期以保证pwm空闲。</p>
<p>然后设置<code>PWM 周期period_cycles</code>，和<code>占空比duty_cycles</code>。</p>
<p>最后调用<code>writel</code>写入寄存器。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<h4><span id="2-4-2-2-imx-pwm-enable">2.4.2.2 imx_pwm_enable</span><a href="#2-4-2-2-imx-pwm-enable" class="header-anchor">#</a></h4><p>控制<code>MX3_PWMCR</code>寄存器，使能关闭开关。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h4><span id="2-4-2-3-imx-pwm-disable">2.4.2.3 imx_pwm_disable</span><a href="#2-4-2-3-imx-pwm-disable" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<h1><span id="3-ji-yu-pwm-sysfs-ce-shi">3 基于pwm sysfs测试</span><a href="#3-ji-yu-pwm-sysfs-ce-shi" class="header-anchor">#</a></h1><p><code>alpha</code>开发板 <code>JP2 排针</code>上的 <code>GPIO_4(GPIO1_IO04)</code>引脚连接到 示波器上。等下看pwm信号效果。</p>
<p>可以看到一共8 路 PWM 控制器：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<p>我们使用的<code>pwm3</code>,对应出<code> pwmchip2</code>, 导出chip2通道的0设备文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip2/export</span><br></pre></td></tr></table></figure>

<p>执行完成会在<code>pwmchip2 </code>目录下生成一个名为<code>“pwm0”</code>的子目录:</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/class/pwm/pwmchip2/pwm0/enable <span class="comment">#使能pwm3</span></span><br><span class="line"><span class="built_in">echo</span> 50000 &gt; /sys/class/pwm/pwmchip2/pwm0/period <span class="comment">#设置周期值，单位为 ns，比如 20KHz 频率的周期就是 50000ns</span></span><br><span class="line"><span class="built_in">echo</span> 10000 &gt; /sys/class/pwm/pwmchip2/pwm0/duty_cycle <span class="comment">#20%占空比</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p>总结：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导出chip1通道的0设备文件：<span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip1/export</span><br><span class="line">配置chip1通道0的周期： <span class="built_in">echo</span> 10000000 &gt; /sys/class/pwm/pwmchip1 /pwm0/period</span><br><span class="line">配置chip1通道0的占空比:<span class="built_in">echo</span> 4000000 &gt;/sys/class/pwm/pwmchip1/pwm0/duty_cycle</span><br><span class="line">配置片chip通道0使能： <span class="built_in">echo</span> 1 &gt; /sys/class/pwm/pwmchip1/pwm0/enable</span><br><span class="line">配置片chip通道0禁能： <span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip1/pwm0/enable</span><br><span class="line">取消导出片chip通道0设备文件： <span class="built_in">echo</span> 0 &gt;/sys/class/pwm/pwmchip1/unexport</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0jcpo1u0000xcuf971uam1a" data-title="字符设备驱动-PWM子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-input子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T12:02:38.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</a><ul>
<li><a href="#1-0-shu-ju-jie-gou">1.0 数据结构</a><ul>
<li><a href="#1-0-1-input-dev">1.0.1 input_dev</a></li>
</ul>
</li>
<li><a href="#1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</a><ul>
<li><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</a></li>
<li><a href="#1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</a><ul>
<li><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</a></li>
</ul>
</li>
<li><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</a></li>
<li><a href="#1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-input-zi-xi-tong-shi-li">2 input子系统示例</a><ul>
<li><a href="#2-1-ding-yi-input-dev">2.1 定义input_dev</a></li>
<li><a href="#2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</a></li>
<li><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</a></li>
<li><a href="#2-4-shi-fang-input-dev">2.4 释放input_dev</a></li>
</ul>
</li>
<li><a href="#3-app-ce-shi">3 APP测试</a></li>
<li><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</a><ul>
<li><a href="#4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</a><ul>
<li><a href="#4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</a><ul>
<li><a href="#4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</a></li>
<li><a href="#4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-ce-shi-yan-zheng">4.2 测试验证</a></li>
</ul>
</li>
<li><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</a><ul>
<li><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</a><ul>
<li><a href="#5-1-1-te-xing">5.1.1 特性</a></li>
<li><a href="#5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</a></li>
<li><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</a></li>
<li><a href="#5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</a></li>
</ul>
</li>
<li><a href="#5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</a><ul>
<li><a href="#5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</a><ul>
<li><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</a></li>
<li><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</a></li>
<li><a href="#5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</a></li>
<li><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</a></li>
</ul>
</li>
<li><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</a></li>
<li><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</a></li>
<li><a href="#5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</a><ul>
<li><a href="#5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-duo-dian-hong-mo-api">5.3 多点触摸API</a><ul>
<li><a href="#5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</a></li>
<li><a href="#5-3-2-input-mt-slot">5.3.2 input_mt_slot</a></li>
<li><a href="#5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</a></li>
<li><a href="#5-3-4-input-report-abs">5.3.4 input_report_abs</a></li>
<li><a href="#5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</a></li>
</ul>
</li>
<li><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</a><ul>
<li><a href="#5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</a><ul>
<li><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</a></li>
<li><a href="#5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</a></li>
</ul>
</li>
<li><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</a><ul>
<li><a href="#5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</a></li>
<li><a href="#5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</a></li>
<li><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</a></li>
</ul>
</li>
<li><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</a><ul>
<li><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</a></li>
</ul>
</li>
<li><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</span><a href="#1-input-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>按键、鼠标、键盘、触摸屏等都属于输入(<code>input</code>)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。<br>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。</p>
<h2><span id="1-0-shu-ju-jie-gou">1.0  数据结构</span><a href="#1-0-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-0-1-input-dev">1.0.1 input_dev</span><a href="#1-0-1-input-dev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">   <span class="number">2</span>:      <span class="type">const</span> <span class="type">char</span> *name;      <span class="comment">//设备名</span></span><br><span class="line">   <span class="number">3</span>:      <span class="type">const</span> <span class="type">char</span> *phys;     <span class="comment">// 设备在系统中路径</span></span><br><span class="line">   <span class="number">4</span>:      <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">   <span class="number">5</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//与input_handler匹配用的id;</span></span><br><span class="line"></span><br><span class="line">   <span class="number">9</span>:      <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">//设备所支持事件类型主要有EV_SYNC,EV_KEY,EV_REL,EV_ABS</span></span><br><span class="line">  <span class="number">10</span>:      <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 按键所对应的位图</span></span><br><span class="line">  <span class="number">11</span>:      <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];<span class="comment">//  相对坐标对应位图</span></span><br><span class="line">  <span class="number">12</span>:      <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];<span class="comment">// 绝对坐标对应位图</span></span><br><span class="line">  <span class="number">13</span>:      <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];<span class="comment">//支持其它事件</span></span><br><span class="line">  <span class="number">14</span>:      <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];<span class="comment">//支持led事件</span></span><br><span class="line">  <span class="number">15</span>:      <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">//支持声音事件</span></span><br><span class="line">  <span class="number">16</span>:      <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];<span class="comment">//支持受力事件</span></span><br><span class="line">  <span class="number">17</span>:      <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];<span class="comment">//支持开关机事件</span></span><br><span class="line">  <span class="number">18</span>:   </span><br><span class="line">  <span class="number">19</span>:      <span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;</span><br><span class="line">  <span class="number">21</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodemax;</span><br><span class="line">  <span class="number">22</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodesize;</span><br><span class="line">  <span class="number">23</span>:      <span class="type">void</span> *keycode;</span><br><span class="line">  <span class="number">24</span>:   </span><br><span class="line">  <span class="number">25</span>:      <span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">26</span>:                <span class="type">const</span> <span class="keyword">struct</span> input_keymap_entry *ke,</span><br><span class="line">  <span class="number">27</span>:                <span class="type">unsigned</span> <span class="type">int</span> *old_keycode);</span><br><span class="line">  <span class="number">28</span>:      <span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">29</span>:                <span class="keyword">struct</span> input_keymap_entry *ke);</span><br><span class="line">  <span class="number">30</span>:   </span><br><span class="line">  <span class="number">31</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span></span><br><span class="line">  <span class="number">33</span>:      <span class="type">unsigned</span> <span class="type">int</span> repeat_key;<span class="comment">//最近一次的按键值</span></span><br></pre></td></tr></table></figure>



<h2><span id="1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</span><a href="#1-1-input-qu-dong-bian-xie-liu-cheng" class="header-anchor">#</a></h2><h3><span id="1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</span><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li" class="header-anchor">#</a></h3><p><code>drivers/input/input.c</code>就是input子系统的核心层，此文件里面有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">input_class</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">	.devnode = input_devnode,</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = class_register(&amp;input_class);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">		INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail2: input_proc_exit();</span><br><span class="line">fail1: class_unregister(&amp;input_class);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册一个 input 类，这样系统启动以后就会在&#x2F;sys&#x2F;class 目录下有一个 input 子目录:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>创建<code>proc/input</code>信息，申请主设备号为<code> INPUT_MAJOR, INPUT_MAJOR</code> 定义在 <code>include/uapi/linux/major.h</code>:<br><code>#define INPUT_MAJOR 13</code><br>因此，input 子系统的所有设备主设备号都为 <code>13</code>，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 <code>input_device </code>即可。</p>
<h3><span id="1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</span><a href="#1-1-1-zhu-ce-input-dev" class="header-anchor">#</a></h3><p>使用 input 子系统的时候我们只需要注册一个 input 设备即可，<code>input_dev</code> 结构体表示<code> input设备</code>，此结构体定义在 <code>include/linux/input.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">/* sound 有关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">	.....</span><br><span class="line">	<span class="type">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>evbit </code>表示输入事件类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br></pre></td></tr></table></figure>

<p><code>evbit、keybit、relbit </code>等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></span><br></pre></td></tr></table></figure>

<p>我们可以将开发板上的按键值设置为任意一个，比如就叫<code>KEY_0</code>。</p>
<p><strong>申请input内存：</strong><br><code>struct input_dev *input_allocate_device(void);</code></p>
<p><strong>释放input内存：</strong><br><code>void input_free_device(struct input_dev *dev);</code></p>
<p><strong>注册input设备：</strong><br><code>int input_register_device(struct input_dev *dev);</code></p>
<p><strong>注销input设备：</strong><br><code>void input_unregister_device(struct input_dev *dev);</code></p>
<h4><span id="1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</span><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span> <span class="comment">/* input 结构体变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	inputdev = input_allocate_device(); <span class="comment">/* 申请 input_dev */</span></span><br><span class="line">	inputdev-&gt;name = <span class="string">&quot;test_inputdev&quot;</span>; <span class="comment">/* 设置 input_dev 名字 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*********第一种设置事件和事件值的方法***********/</span></span><br><span class="line">	 __set_bit(EV_KEY, inputdev-&gt;evbit); <span class="comment">/* 设置产生按键事件 */</span></span><br><span class="line">	 __set_bit(EV_REP, inputdev-&gt;evbit); <span class="comment">/* 重复事件 */</span></span><br><span class="line">	 __set_bit(KEY_0, inputdev-&gt;keybit); <span class="comment">/*设置产生哪些按键值 */</span></span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">/*********第二种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |=</span><br><span class="line">	T_MASK(KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">/*********第三种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 input_register_device(inputdev);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">	 input_unregister_device(inputdev); <span class="comment">/* 注销 input_dev */</span></span><br><span class="line">	 input_free_device(inputdev); <span class="comment">/* 删除 input_dev */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</span><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h3><p>当输入设备中断到来，我们需要上报input输入事件给linux内核的input核心层，比如按键：我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。<br>不同的事件，上报事件的 API 函数不一样:<br><strong>input_event:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	dev：需要上报的 input_dev。</span></span><br><span class="line"><span class="comment">	type: 上报的事件类型，比如 EV_KEY。</span></span><br><span class="line"><span class="comment">	code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</span></span><br><span class="line"><span class="comment">	value：事件值，比如 1 表示按键按下，0 表示按键松开。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当然linux系统帮我们也封装了一层api去使用：<br><strong>input_report_key：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的还有一些其他的事件上报函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>
<p>我们上报事件以后还需要使用<code>input_sync</code>函数来告诉 Linux 内核 input 子系统上报结束，<code>input_sync </code>函数本质是上报一个同步事件:<br><code>void input_sync(struct input_dev *dev);</code><br>举个例子，按键中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于按键消抖的定时器服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; <span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1，按下 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 按键松开 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0，松开 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3><span id="1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</span><a href="#1-1-3-input-event-jie-gou-ti" class="header-anchor">#</a></h3><p><code>include/uapi/linux/input.h</code> 文件中:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p><code>type</code>：事件类型，比如 EV_KEY，表示此次事件为<code>按键事件</code>，此成员变量为 16 位。<br><code>code</code>：事件码，比如在 EV_KEY 事件中 code 就表示具体的<code>按键码</code>，如：<code>KEY_0、KEY_1</code>等等这些按键。此成员变量为 16 位。<br><code>value</code>：值，比如 EV_KEY 事件中 value 就是<code>按键值</code>，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了</p>
<p><code>input_envent </code>这个结构体非常重要,用户态的应用程序也是通过 <code>input_event </code>来获取到具体的输入事件或相关的值，比如按键值等。</p>
<h1><span id="2-input-zi-xi-tong-shi-li">2 input子系统示例</span><a href="#2-input-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>还是以之前的按键来举例，利用input子系统来做一个按键驱动程序：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_NAME		<span class="string">&quot;keyinput&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span>		<span class="comment">/* input结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> <span class="title">keyinputdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123;<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span></span><br><span class="line">        <span class="comment">/* 最后一个参数表示按下还是松开，1为按下，0为松开 */</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">1</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">0</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	keyinputdev.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (keyinputdev.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取GPIO */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		keyinputdev.irqkeydesc[i].gpio = of_get_named_gpio(keyinputdev.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (keyinputdev.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化key所使用的IO，并且设置成中断模式 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(keyinputdev.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(keyinputdev.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(keyinputdev.irqkeydesc[i].gpio, name);</span><br><span class="line">		gpio_direction_input(keyinputdev.irqkeydesc[i].gpio);	</span><br><span class="line">		keyinputdev.irqkeydesc[i].irqnum = irq_of_parse_and_map(keyinputdev.nd, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].value = KEY_0;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(keyinputdev.irqkeydesc[i].irqnum, keyinputdev.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING,</span><br><span class="line">                         keyinputdev.irqkeydesc[i].name, &amp;keyinputdev);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, keyinputdev.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建定时器 */</span></span><br><span class="line">	init_timer(&amp;keyinputdev.timer);</span><br><span class="line">	keyinputdev.timer.function = timer_function;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请input_dev */</span></span><br><span class="line">	keyinputdev.inputdev = input_allocate_device();</span><br><span class="line">	keyinputdev.inputdev-&gt;name = KEYINPUT_NAME;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些事件 */</span></span><br><span class="line">	__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 设置产生按键事件          */</span></span><br><span class="line">	__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 重复事件，比如按下去不放开，就会一直输出信息*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些按键 */</span></span><br><span class="line">	__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册输入设备 */</span></span><br><span class="line">	ret = input_register_device(keyinputdev.inputdev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">&quot;register input device failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">keyinput_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">keyinput_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;keyinputdev.timer);	<span class="comment">/* 删除定时器 */</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(keyinputdev.irqkeydesc[i].irqnum, &amp;keyinputdev);</span><br><span class="line">	&#125;</span><br><span class="line">	input_unregister_device(keyinputdev.inputdev);</span><br><span class="line">	input_free_device(keyinputdev.inputdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(keyinput_init);</span><br><span class="line">module_exit(keyinput_exit);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-ding-yi-input-dev">2.1 定义input_dev</span><a href="#2-1-ding-yi-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h2><span id="2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</span><a href="#2-2-chu-shi-hua-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<ol>
<li><code>input_allocate_device</code>分配内存</li>
<li>设置事件和事件值，<code>input_event</code>类型是<code>EV_KEY</code>,键值<code>KEY_0</code>,<code> evbit</code>为<code>EV_KEY | EV_REP</code></li>
<li>注册input设备</li>
</ol>
<h2><span id="2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</span><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h2><span id="2-4-shi-fang-input-dev">2.4 释放input_dev</span><a href="#2-4-shi-fang-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h1><span id="3-app-ce-shi">3 APP测试</span><a href="#3-app-ce-shi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">inputevent</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		err = read(fd, &amp;inputevent, <span class="keyword">sizeof</span>(inputevent));</span><br><span class="line">		<span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123; <span class="comment">/* 读取数据成功 */</span></span><br><span class="line">			<span class="keyword">switch</span> (inputevent.type) &#123;</span><br><span class="line">				<span class="keyword">case</span> EV_KEY:</span><br><span class="line">					<span class="keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="comment">/* 键盘键值 */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;key %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;button %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">/* 其他类型的事件，自行处理 */</span></span><br><span class="line">				<span class="keyword">case</span> EV_REL:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EV_ABS:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;读取数据失败\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们向 Linux 内核成功注册 input_dev 设备以后，会在<code>/dev/input </code>目录下生成一个名为<code>“eventX(X=0….n)”</code>的文件，这个<code>/dev/input/eventX </code>就是对应的 input 设备文件。</p>
<p>测试：<br>在加载<code>keyinput.ko</code>驱动模块之前，先看一下<code>/dev/input </code>目录下都有哪些文件：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br><code>modprobe keyinput.ko</code> 可以看到多一个<code>input1</code>,就是我们刚创建的设备节点：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"><br>运行app:<br><code>./keyinputApp /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 <code>KEY_0</code> 为 <code>11</code>。<br>另外，我们也可以不用<code>keyinputApp</code>来测试驱动，可以直接使用<code>hexdump</code>命令来查看<code>/dev/input/event1 </code>文件内容，输入如下命令：<br><code>hexdump /dev/input/event1</code><br>这就是<code>input_event</code> 类型的原始事件数据值：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>含义如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"><br><code>type </code>为事件类型，<code>EV_KEY </code>事件值为 1，<code>EV_SYN </code>事件值为0。因此第 1 行表示 <code>EV_KEY </code>事件，第 2 行表示 <code>EV_SYN </code>事件。code 为事件编码，也就是按键号，<code>KEY_0</code> 这个按键编号为 11，对应的十六进制为 <code>0xb</code>，因此第1 行表示 <code>KEY_0 </code>这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。<br>综上所述，上述原始事件值含义如下：<br>第 1 行，按键<code>(KEY_0)</code>按下事件。<br>第 2 行，<code>EV_SYN</code> 同步事件，因为每次上报按键事件以后都要同步的上报一个 <code>EV_SYN</code> 事件。<br>第 3 行，按键<code>(KEY_0)</code>松开事件。<br>第 4 行，<code>EV_SYN </code>同步事件，和第 2 行一样。</p>
<h1><span id="4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</span><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong" class="header-anchor">#</a></h1><p>Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Input device support</span><br><span class="line">		-&gt; Generic input <span class="title function_">layer</span> <span class="params">(needed <span class="keyword">for</span> keyboard, mouse, ...)</span> <span class="params">(INPUT [=y])</span></span><br><span class="line">			-&gt; <span class="title function_">Keyboards</span> <span class="params">(INPUT_KEYBOARD [=y])</span></span><br><span class="line">				-&gt;GPIO Buttons</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>选中以后就会在<code>.config</code> 文件中出现<code>“CONFIG_KEYBOARD_GPIO=y”</code>这一行，Linux 内核<br>就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。Linux 内核自带的 KEY 驱动文件为<br><code>drivers/input/keyboard/gpio_keys.c</code>，<code>gpio_keys.c </code>采用了 platform 驱动框架，在 KEY 驱动上使用<br>了 input 子系统实现。</p>
<h2><span id="4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</span><a href="#4-1-gpio-keys-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>要使用 Linux 内 核 自 带 的 按 键 驱 动 程 序 很 简 单 ， 只 需 要 根 据<code>Documentation/devicetree/bindings/input/gpio-keys.txt </code>这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①、节点名字为“gpio-keys”。</span><br><span class="line">②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</span><br><span class="line">③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：</span><br><span class="line">	gpios：KEY 所连接的 GPIO 信息。</span><br><span class="line">	interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。</span><br><span class="line">	label：KEY 名字</span><br><span class="line">	linux,code：KEY 要模拟的按键，也就是示例代码</span><br><span class="line">④、如果按键要支持连按的话要加入 autorepeat。</span><br></pre></td></tr></table></figure>
<p>打开<code> imx6ull-alientek-emmc.dts</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	autorepeat;</span><br><span class="line">	key0 &#123;</span><br><span class="line">		label = <span class="string">&quot;GPIO Key Enter&quot;</span>;</span><br><span class="line">		linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ALPHA 开发板 KEY 按键信息，名字设置为<code>“GPIO Key Enter”</code>，这里我们将开发板上的 KEY 按键设置为<code>“EKY_ENTER”</code>这个按键，也就是回车键，效果和键盘上的回车键一样。</p>
<h3><span id="4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</span><a href="#4-1-1-gpio-keys-probe-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br>可以看到就是对<code>input</code>子系统的调用封装，实例化了一个利用input子系统写的驱动程序。<br>调用<code> gpio_keys_get_devtree_pdata</code> 函数从设备树中获取到 KEY 相关的设备节点信息。<br>使用 <code>devm_input_allocate_device</code> 函数申请 input_dev。<br>初始化<code> input_dev</code>。<br>设置<code> input_dev 事件</code>，这里设置了<code> EV_REP</code> 事件.<br><strong>调用 <code>gpio_keys_setup_key</code> 函数继续设置 KEY，此函数会设置 input_dev 的EV_KEY 事件已经事件码(也就是 KEY 模拟为哪个按键)</strong><br>调用 <code>input_register_device</code> 函数向 Linux 系统注册<code> input_dev</code>。</p>
<h4><span id="4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</span><a href="#4-1-1-1-gpio-keys-setup-key" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>调用<code> input_set_capability</code> 函数设置<code> EV_KEY</code> 事件以及 KEY 的按键类型，也就是 KEY 作为哪个按键？我们会在设备树里面设置指定的 KEY 作为哪个按键.</p>
<h4><span id="4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</span><a href="#4-1-1-2-gpio-keys-irq-isr" class="header-anchor">#</a></h4><p>当dts对应的按键按下后，中断进行响应，函数如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"><br>可以看到同理还是调用input_event， input_sync进行上报事件。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image-20240825144156414"></p>
<h2><span id="4-2-ce-shi-yan-zheng">4.2 测试验证</span><a href="#4-2-ce-shi-yan-zheng" class="header-anchor">#</a></h2><p>烧录新的dtb和kernel进去，可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用<br>hexdump 命令来查看<code>/dev/input/event1 </code>文件：<br><code>hexdump /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"><br>大家如果发现按下 KEY 按键以后没有反应，那么请检查一下三方面：<br>①、是否使能 Linux 内核 KEY 驱动。<br>②、设备树中 <code>gpio-keys</code> 节点是否创建成功。<br>③、在设备树中是否有其他外设也使用了 KEY 按键对应的 GPIO，但是我们并没有删除掉这些外设信息。检查 Linux 启动 log 信息，看看是否有类似下面这条信息:<br><code>gpio-keys gpio_keys：Failed to request GPIO 18, error -16</code></p>
<h1><span id="5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</span><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong" class="header-anchor">#</a></h1><h2><span id="5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</span><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie" class="header-anchor">#</a></h2><h3><span id="5-1-1-te-xing">5.1.1 特性</span><a href="#5-1-1-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p>特性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 自动模式切换。</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span>hz采样率</span><br><span class="line"><span class="number">3.</span> 自动校准</span><br><span class="line"><span class="number">4.</span> i2c接口，速率高达<span class="number">400</span>k</span><br><span class="line"><span class="number">5.</span> <span class="number">12</span>位ADC精度转换</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p>触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。</p>
<h3><span id="5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</span><a href="#5-1-2-i2c-chuan-shu-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.1.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p>可以看到slave addr是7位，第8位表示方向。数据是每次传输1byte。</p>
<h3><span id="5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</span><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu" class="header-anchor">#</a></h3><p><a name="power_on_sequence"></a></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</span><a href="#5-1-4-ji-cun-qi-miao-shu" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<h2><span id="5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</span><a href="#5-2-duo-dian-hong-mo-mt-xie-yi" class="header-anchor">#</a></h2><p>多点电容触摸屏协议，文档路径为：<code>Documentation/input/multitouch-protocol.txt。</code></p>
<p>老版本的 2.x 版本 linux 内核是不支持多点电容触摸的(<code>Multi-touch，简称 MT</code>)，MT 协议是后面加入 的。</p>
<p>MT 协议被分为两种类型，<code>Type A</code> 和 <code>TypeB</code>，这两种类型的区别如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)。</span><br><span class="line">Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个 触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</span><a href="#5-2-1-abs-mt-shi-jian" class="header-anchor">#</a></h3><p>ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 <code>include/uapi/linux/input.h</code> 中,  上报给 linux 内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_SLOT 0x2f <span class="comment">/* MT slot being modified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MAJOR 0x30 <span class="comment">/* Major axis of touching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MINOR 0x31 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MAJOR 0x32 <span class="comment">/* Major axis of approaching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MINOR 0x33 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_ORIENTATION 0x34 <span class="comment">/* Ellipse orientation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_X 0x35 <span class="comment">/* Center X touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_Y 0x36 <span class="comment">/* Center Y touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_TYPE 0x37 <span class="comment">/* Type of touching device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_BLOB_ID 0x38 <span class="comment">/* Group a set of packets as a blob */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TRACKING_ID 0x39 <span class="comment">/* Unique ID of initiated contact */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_PRESSURE 0x3a <span class="comment">/* Pressure on contact area */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_DISTANCE 0x3b <span class="comment">/* Contact hover distance */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_X 0x3c <span class="comment">/* Center X tool position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_Y 0x3d <span class="comment">/* Center Y tool position */</span></span></span><br></pre></td></tr></table></figure>

<p><code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>用来上 报触摸 点的 (X,Y) 坐标 信息。<code>ABS_MT_SLOT </code>用来上 报触摸点 ID ， 对 于 Type B 类型的设备，需要用到 <code>ABS_MT_TRACKING_ID </code>事件来区分触摸点。</p>
<h4><span id="5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</span><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code> Type A</code> 类型的设备，通过<code> input_mt_sync()</code>函数来隔离不同的触摸点数据信息。<code>nput_mt_sync() </code>函数会触发 <code>SYN_MT_REPORT </code>事件，此事件会通知接收者获取当前触摸数据，并且准备接收 下一个触摸点数据。</p>
<p><code>void input_mt_sync(struct input_dev *dev);</code></p>
<h4><span id="5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</span><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code>Type B</code>类型的设备，上报触摸点信息的时候需要通过<code> input_mt_slot()</code>函数区分是哪一 个触摸点。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是 哪个触摸点信息。<code>input_mt_slot()</code>函数会触发 <code>ABS_MT_SLOT </code>事件，此事件会告诉接收者当前 正在更新的是哪个触摸点(slot)的数据。</p>
<h4><span id="5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</span><a href="#5-2-1-3-input-sync-jie-shu-shang-bao" class="header-anchor">#</a></h4><p>不管是哪个类型的设备，最终都要调用<code> input_sync()</code>函数来标识多点触摸信息传输完成，告 诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p>
<p>可以通过 slot 的 <code>ABS_MT_TRACKING_ID </code>来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个 新加的触摸点，一个 ID 如果再也不存在了就表示删除了。上报 <code>SYN_REPORT </code>事件。</p>
<h4><span id="5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</span><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao" class="header-anchor">#</a></h4><p>上报触摸屏原始数据。</p>
<p><code>void input_report_abs(struct input_dev *dev, unsigned int code, int value);</code></p>
<h3><span id="5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</span><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据，通过input_report_abs 函数实现，下面同理</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报第一个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line"></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//上报第二个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件,通知接收者获取坐标</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核里面也有<code> Type A</code> 类型的多点触摸驱动，如<code> st2332.c</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image-20240825151728439"></p>
<h3><span id="5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</span><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><p>对于<code>Type B</code>类型的设备，发送触摸点信息的时序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT <span class="number">0</span> <span class="comment">/* 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line"><span class="comment">    每次上报一个触摸点坐标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID，需要由触摸 IC 提供</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span> <span class="comment">/*根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过</span></span><br><span class="line"><span class="comment">	修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到</span></span><br><span class="line"><span class="comment">	的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数</span></span><br><span class="line"><span class="comment">	active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指</span></span><br><span class="line"><span class="comment">	定具体的 ABS_MT_TRACKING_ID 值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 y 轴坐标</span></span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span> <span class="comment">//同理， 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>] <span class="comment">//坐标1的x</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>] <span class="comment">//坐标1的y</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>当一个触摸点移除以后，同样需要通过 SLOT 关联的<code>ABS_MT_TRACKING_ID</code>来处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_TRACKING_ID <span class="number">-1</span> <span class="comment">/*当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一</span></span><br><span class="line"><span class="comment">个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的</span></span><br><span class="line"><span class="comment">第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure>

<p>Linux 内核里面有大量的 <code>Type B</code> 类型的多点触摸驱动程序,<code>drivers/input/touchscreen/ili210x.c </code>上报示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ili210x_report_events</span><span class="params">(<span class="keyword">struct</span> input_dev *input, <span class="type">const</span> <span class="keyword">struct</span> touchdata *touchdata)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">bool</span> touch;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">finger</span> *<span class="title">finger</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_TOUCHES; i++) &#123;</span><br><span class="line">		input_mt_slot(input, i);<span class="comment">//上报ABS_MT_SLOT事件</span></span><br><span class="line">		finger = &amp;touchdata-&gt;finger[i];</span><br><span class="line">		touch = touchdata-&gt;status &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="comment">//上报ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件</span></span><br><span class="line">		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);</span><br><span class="line">		<span class="keyword">if</span> (touch) &#123;</span><br><span class="line">			x = finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			y = finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_X, x);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_Y, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	input_mt_report_pointer_emulation(input, <span class="literal">false</span>);</span><br><span class="line">	input_sync(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</span><a href="#5-2-4-abs-mt-qi-ta-shi-jian" class="header-anchor">#</a></h3><p>如果设备支持的话，还可以使用 <code>ABS_MT_TOUCH_MAJOR</code> 和 <code>ABS_MT_WIDTH_MAJOR</code> 这两个消息上报触摸面积信息，关于 其他 ABS_MT 事件的具体含义大家可以查看 Linux 内核中的 <code>multi-touch-protocol.txt</code> 文档。</p>
<h4><span id="5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</span><a href="#5-2-4-1-abs-mt-tool-type" class="header-anchor">#</a></h4><p>上报触摸工具类型。</p>
<p>很多内核驱动都不能区分出触摸设备类型 ，是手指还是触摸 笔？ 这种情况下， 这个事件可以忽略掉 。目前的协议支持 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MT_TOOL_FINGER(手指)</span><br><span class="line">MT_TOOL_PEN(笔)</span><br><span class="line">MT_TOOL_PALM(手掌)这三种触摸设备类型</span><br></pre></td></tr></table></figure>

<p>要 上 报 ABS_MT_TOOL_TYPE 事件，那么可以使用<code> input_mt_report_slot_state</code> 函数来完成此工作。</p>
<h2><span id="5-3-duo-dian-hong-mo-api">5.3 多点触摸API</span><a href="#5-3-duo-dian-hong-mo-api" class="header-anchor">#</a></h2><h3><span id="5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</span><a href="#5-3-1-input-mt-init-slots" class="header-anchor">#</a></h3><p>初始化 MT 的输入 slots槽，<code>drivers/input/input-mt.c</code>。</p>
<p><code>int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots, unsigned int flags);</code></p>
<p>num_slots: 要使用的 SLOT 数量，也就是触摸点的数量。</p>
<p>flags：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_POINTER 0x0001 <span class="comment">/* pointer device, e.g. trackpad */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DIRECT 0x0002 <span class="comment">/* direct device, e.g. touchscreen */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DROP_UNUSED0x0004 <span class="comment">/* drop contacts not seen in frame */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_TRACK 0x0008 <span class="comment">/* use in-kernel tracking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_SEMI_MT 0x0010 <span class="comment">/* semi-mt device, finger count handled manually */</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="5-3-2-input-mt-slot">5.3.2 input_mt_slot</span><a href="#5-3-2-input-mt-slot" class="header-anchor">#</a></h3><p> Type B类型，此函数用于产生 <code>ABS_MT_SLOT </code>事件，告诉内核当前上报的是哪个触摸点的坐标数据，定义在文件<code> include/linux/input/mt.h</code>。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。</p>
<h3><span id="5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</span><a href="#5-3-3-input-mt-report-slot-state" class="header-anchor">#</a></h3><p>Type B类型，用于产生<code>ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE </code>事件 ，<code>ABS_MT_TRACKING_ID</code>事件给slot关联一个<code>ABS_MT_TRACKING_ID </code>，<code> ABS_MT_TOOL_TYPE</code>事件指定触摸类型（是笔还是手指等 ）。此函数定义在文件<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, bool active);</code></p>
<p>tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或 MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。 </p>
<p>active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。 false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸 点溢出。</p>
<h3><span id="5-3-4-input-report-abs">5.3.4 input_report_abs</span><a href="#5-3-4-input-report-abs" class="header-anchor">#</a></h3><p>上报<code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>事件，上报坐标。include&#x2F;linux&#x2F;input.h。</p>
<p><code>void input_report_abs( struct input_dev *dev, unsigned int code, int value);</code></p>
<p><code>code</code>：要上报的是什么数据，设置为<code> ABS_MT_POSITION_X</code> 或 <code>ABS_MT_POSITION_Y</code></p>
<p><code>value</code>：具体的 X 轴或 Y 轴坐标数据值。</p>
<h3><span id="5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</span><a href="#5-3-5-input-mt-report-pointer-emulation" class="header-anchor">#</a></h3><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 <code>BTN_TOOL_TAP</code> 事件来通 知用户空间当前追踪到的触摸点总数量，然后调用<code>input_mt_report_pointer_emulation</code>函数将 <code>use_count</code> 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)，<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count);</code></p>
<p><code>use_count</code>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量.</p>
<h2><span id="5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</span><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426" class="header-anchor">#</a></h2><h3><span id="5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</span><a href="#5-4-1-she-bei-shu-tian-jia" class="header-anchor">#</a></h3><h4><span id="5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</span><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_tsc: tscgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="number">0xF080</span> <span class="comment">/* TSC_INT */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_tsc_reset: tsc_reset &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 <span class="number">0x10B0</span> <span class="comment">/* TSC_RST */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;</span><br><span class="line">pinctrl_i2c2: i2c2grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART5_TX_DATA__I2C2_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART5_RX_DATA__I2C2_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>触摸屏要用到4个IO, i2c 2个引脚和1个<code>RST</code>, 1个<code>INT</code>引脚。</p>
<h4><span id="5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</span><a href="#5-4-1-2-ft5426-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">	clock_frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c2&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	......</span><br><span class="line">	ft5426: ft5426@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">		pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">		pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_tsc</span><br><span class="line">			&amp;pinctrl_tsc_reset&gt;;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">		interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">		reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		interrupt-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>找到<code>i2c2</code>节点，引用<code>pinctrl_i2c2</code>，设置好I2c的iomux。设置时钟100k, status开启okay。</p>
<p>添加子节点<code>ft5426</code>，器件地址为 <code>0X38</code>，引用<code>pinctrl_tsc</code>， <code>pinctrl_tsc_reset</code>设置<code>rst</code>和<code>int</code>引脚的iomux。</p>
<p><code>interrupt-parent</code> 属性描述中断 IO 对应的 GPIO 组为<code> GPIO1</code>。</p>
<p><code>interrupts</code> 属性描述中断 IO 对应的是 GPIO1 组的<code> IOI09</code>。</p>
<p><code>reset-gpios </code>属性描述复位 IO 对应的 GPIO 为 <code>GPIO5_IO09</code>。</p>
<p><code>interrupt-gpios </code>属性描述中断 IO 对应的 GPIO 为 <code>GPIO1_IO09</code>。</p>
<h3><span id="5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</span><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi" class="header-anchor">#</a></h3><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ft5x06.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ratelimit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/debugfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/mt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/edt-ft5x06.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SUPPORT_POINTS		5			<span class="comment">/* 5点触摸 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_DOWN		0x00		<span class="comment">/* 按下 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_UP			0x01		<span class="comment">/* 抬起 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_ON			0x02		<span class="comment">/* 接触 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_RESERVED	0x03		<span class="comment">/* 保留 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FT5X06寄存器相关宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_TD_STATUS_REG	0X02		<span class="comment">/*	状态寄存器地址 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5x06_DEVICE_MODE_REG	0X00 		<span class="comment">/* 模式寄存器 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5426_IDG_MODE_REG		0XA4		<span class="comment">/* 中断模式				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_READLEN			29			<span class="comment">/* 要读取的寄存器个数 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 				<span class="comment">/* 设备节点 		*/</span></span><br><span class="line">	<span class="type">int</span> irq_pin,reset_pin;					<span class="comment">/* 中断和复位IO		*/</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号    		*/</span></span><br><span class="line">	<span class="type">void</span> *private_data;						<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span>				<span class="comment">/* input结构体 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span>				<span class="comment">/* I2C客户端 		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> <span class="title">ft5x06</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_reset</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;reset_pin)) &#123;</span><br><span class="line">		<span class="comment">/* 申请复位IO，并且默认输出低电平 */</span></span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev,	</span><br><span class="line">					dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,</span><br><span class="line">					<span class="string">&quot;edt-ft5x06 reset&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		msleep(<span class="number">5</span>);</span><br><span class="line">		gpio_set_value(dev-&gt;reset_pin, <span class="number">1</span>);<span class="comment">/* 输出高电平，停止复位 */</span></span><br><span class="line">		msleep(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_read_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;					<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;					<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;						<span class="comment">/* reg长度*/</span></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;			<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;					<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;					<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ft5x06_write_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ft5x06_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">ft5x06_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> *<span class="title">multidata</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">	u8 rdbuf[<span class="number">29</span>];</span><br><span class="line">	<span class="type">int</span> i, type, x, y, id;</span><br><span class="line">	<span class="type">int</span> offset, tplen;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">bool</span> down;</span><br><span class="line"></span><br><span class="line">	offset = <span class="number">1</span>; 	<span class="comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span></span><br><span class="line">	tplen = <span class="number">6</span>;		<span class="comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(rdbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(rdbuf));		<span class="comment">/* 清除 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span></span><br><span class="line">	ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 上报每一个触摸点坐标 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">		u8 *buf = &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span></span><br><span class="line"><span class="comment">		 * bit5:4  保留</span></span><br><span class="line"><span class="comment">		 * bit3:0  X轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		type = buf[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>;     <span class="comment">/* 获取触摸类型 */</span></span><br><span class="line">		<span class="keyword">if</span> (type == TOUCH_EVENT_RESERVED)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span></span><br><span class="line">		x = ((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">3</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		y = ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span></span><br><span class="line"><span class="comment">		 * bit3:0  Y轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		id = (buf[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">		down = type != TOUCH_EVENT_UP;</span><br><span class="line"></span><br><span class="line">		input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">		input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!down)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_mt_report_pointer_emulation(multidata-&gt;input, <span class="literal">true</span>);</span><br><span class="line">	input_sync(multidata-&gt;input);</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_irq</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;irq_pin)) &#123;</span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,</span><br><span class="line">					GPIOF_IN, <span class="string">&quot;edt-ft5x06 irq&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,</span><br><span class="line">				dev-&gt;irq_pin, ret);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line">					ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">					client-&gt;name, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;client-&gt;dev, <span class="string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06.client = client;</span><br><span class="line"></span><br><span class="line">	ft5x06.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;interrupt-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	ft5x06.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_reset(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_irq(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4，初始化FT5X06 */</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, <span class="number">0</span>); 	<span class="comment">/* 进入正常模式 	*/</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, <span class="number">1</span>); 		<span class="comment">/* FT5426中断模式	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5，input设备注册 */</span></span><br><span class="line">	ft5x06.input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!ft5x06.input) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ft5x06.input-&gt;name = client-&gt;name;</span><br><span class="line">	ft5x06.input-&gt;id.bustype = BUS_I2C;</span><br><span class="line">	ft5x06.input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line">	__set_bit(EV_KEY, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(EV_ABS, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_X, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_Y, <span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,<span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,<span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);	     </span><br><span class="line">	ret = input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = input_register_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span>&#123;</span><br><span class="line">	input_unregister_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_ts_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5206&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5426&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ft5x06_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_ts_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.name = <span class="string">&quot;edt_ft5x06&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(ft5x06_of_match),</span><br><span class="line">	&#125;,</span><br><span class="line">	.id_table = ft5x06_ts_id,</span><br><span class="line">	.probe    = ft5x06_ts_probe,</span><br><span class="line">	.remove   = ft5x06_ts_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ft5x06_ts_driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ft5x06_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ft5x06_init);</span><br><span class="line">module_exit(ft5x06_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

</details>

<h4><span id="5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</span><a href="#5-4-2-1-probe-guo-cheng" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<p>dts中的<code>compatible</code>和驱动匹配，<code>of_match_table</code>匹配，因此触发probe函数。可以看到FT5426使用的标准I2C从设备驱动框架<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统 | Hexo (fuzidage.github.io)</a>。因为使用的I2c2。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p>由于<code>i2c_client</code>描述i2c从设备的i2c相关硬件信息。 一个<code>i2c_driver</code>可以支持多个同类型的<code>i2c_client</code>。<code>i2c_client</code>一般描述在设备树中, 这里<code>对应i2c2的ft5426子节点</code>。</p>
<ol>
<li><p>当驱动和设备匹配，<code>ft5x06_ts_probe</code>执行。首先获取dts中的属性<code>reset-gpios</code>,<code>interrupt-gpios</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.1.png" alt="image"></p>
</li>
<li><p>对复位引脚进行复位。（参考<a href="#power_on_sequence">5.1.3上电复位时序</a>）</p>
</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<ol start="3">
<li>注册中断服务</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/33.png" alt="image"></p>
<ol start="4">
<li><p>初始化ft5426内部寄存器</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/34.png" alt="image"></p>
</li>
<li><p>利用input子系统设置MT协议参数，并且注册input设备。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/35.png" alt="image"></p>
</li>
</ol>
<p>需要上报的事件为 <code>EV_KEY 和 EV_ABS</code>，需要上报的按键码为<code> BTN_TOUCH</code>(<code>BTN_TOUCH见include\uapi\linux\input-event-codes.h</code>)。<code>EV_KEY </code>是按键事件，用于上报触摸屏是否被按下，相当于把触摸屏当做一个按键。<code>EV_ABS </code>是触摸点坐标数据，<code>BTN_TOUCH </code>表示将触摸屏的按下和抬起用作 <code>BTN_TOUCH </code>按键。</p>
<p><code>input_set_abs_params </code>函数设置 EV_ABS 事件需要上报 <code>ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y</code>。单点触摸需要上报<code>ABS_X</code> 和<code> ABS_Y</code>，对于多点触摸需要上报 <code>ABS_MT_POSITION_X </code>和<code> ABS_MT_POSITION_Y</code>。</p>
<p><code>input_mt_init_slots</code> 函数初始 化 slots，也就是最大触摸点数量，FT5426 是个 5 点电容触摸芯片，因此一共 5 个 slot。</p>
<h4><span id="5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</span><a href="#5-4-2-2-i2c-shu-ju-chuan-shu" class="header-anchor">#</a></h4><p>其实就是i2c数据传输的应用。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统 | Hexo (fuzidage.github.io)</a>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/36.png" alt="image"></p>
<p>读过程：</p>
<p>构造<code>i2c_msg[0]</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要读哪个寄存器地址。</p>
<p>构造<code>i2c_msg[1]</code>，flag&#x3D;1表示读，先发送i2c从设备器件地址0x38。然后传入要读的buf。</p>
<p>写过程：</p>
<p>构造<code>i2c_msg</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要写哪个寄存器地址和写入的内容。</p>
<h4><span id="5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</span><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/37.png" alt="image"></p>
<ol>
<li>通过<code>I2c_read</code>获取寄存器值。一共29个寄存器，读出29 byte。从0X02寄存器开始读。</li>
<li>for循环内部用来拆解坐标信息，上报每一个点的坐标。</li>
<li>最后调用<code>input_sync</code>上传上报<code>SYN_REPORT</code>事件。</li>
</ol>
<h3><span id="5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</span><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/38.png" alt="image"></p>
<p>驱动加载成功以后就会生成<code>/dev/input/eventX</code>(X&#x3D;1,2,3…)</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/39.png" alt="image"></p>
<h4><span id="5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</span><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi" class="header-anchor">#</a></h4><p><code>hexdump /dev/input/event2</code>可以查看原始数据。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/40.png" alt="image"></p>
<p>第1行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x2f</code>，为<code>ABS_MT_SLOT</code>，因此这一行就是<code>input_mt_slot</code>函数上报的<code>ABS_MT_SLOT</code>事件。value&#x3D;0，说明接下来上报的是第一个触摸点坐标。</p>
<p>第2行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，这一行就是<code>input_mt_report_slot_state</code>函数上报<code>ABS_MT_TRACKING_ID</code>事件。<code>value=5</code>说明给<code>SLOT0</code>分配的ID为5。</p>
<p>​		第3行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x35</code>，为<code>ABS_MT_POSITION_X</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_X</code>事件，也就是触摸点的X轴坐标。<code>value=0x03ec=1004</code>，说明触摸点X轴坐标为1004，属于屏幕右上角区域。</p>
<p>​		第4行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x36</code>，为<code>ABS_MT_POSITION_Y</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_Y</code>事件，也就是触摸点的Y轴坐标。<code>value=0x17=23</code>，说明Y轴坐标为23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</p>
<p>​		第5行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x1</code>表示触摸屏被按下。</p>
<p>​		第6行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x0</code>，为<code>ABS_X</code>，用于单点触摸的时候上报X轴坐标。在这里和<code>ABS_MT_POSITION_X</code>相同，<code>value也为0x3f0=1008</code>。ABS_X是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>​		第7行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x1</code>，为<code>ABS_Y</code>，用于单点触摸的时候上报Y轴坐标。在这里和<code>ABS_MT_POSITION_Y</code>相同，<code>value也为0x17=23</code>。ABS_Y是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>第8行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>第9行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，<code>value=0xffffffff=-1</code>，说明触摸点离开了屏幕。</p>
<p>第10行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x0</code>表示手指离开触摸屏，也就是触摸屏没有被按下了。</p>
<p>第11行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>以上就是一个触摸点的坐标上报过程。</p>
<h2><span id="5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</span><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong" class="header-anchor">#</a></h2><p>打开<code>driver/input/touchscreen/Makefile</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/41.png" alt="image"></p>
<p>linux内核默认已经帮我们实现了这款<code>edt-ft5x06.c</code>触摸屏驱动。此驱动文件不仅仅 能够驱动 <code>FT5426，FT5206、FT5406 </code>这些都可以驱动。</p>
<p><code>make menuconfig</code>,选中这款触摸屏即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line"> -&gt; Device Drivers</span><br><span class="line"> 	-&gt; Input device support</span><br><span class="line"> 		-&gt; Generic input layer (needed <span class="keyword">for</span> keyboard, mouse, ...) (INPUT [=y])</span><br><span class="line">			-&gt; Touchscreens (INPUT_TOUCHSCREEN [=y])</span><br><span class="line">				-&gt; &lt;*&gt; EDT FocalTech FT5x06 I2C Touchscreen support</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/42.png" alt="image"></p>
<p>编译后开机如下打印：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/43.png" alt="image"></p>
<p>直接运行 ts_test_mt 来测试触摸屏是否可以使用。</p>
<h1><span id="6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</span><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux/kconfig.h:<span class="number">73</span>:<span class="meta">#<span class="keyword">define</span> IS_ENABLED(option) __or(IS_BUILTIN(option), IS_MODULE(option))</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14m004jdsufgd2oaw7j" data-title="字符设备驱动-input子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-SPI子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T11:02:38.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-spi-qu-dong-kuang-jia">1 Linux SPI驱动框架</a><ul>
<li><a href="#1-1-spi-he-xin-ceng">1.1 spi核心层</a><ul>
<li><a href="#1-1-1-he-xin-ceng-chu-shi-hua">1.1.1 核心层初始化</a><ul>
<li><a href="#1-1-1-1-spi-init">1.1.1.1 spi_init</a></li>
<li><a href="#1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei">1.1.1.2 spi从设备和驱动的匹配</a></li>
</ul>
</li>
<li><a href="#1-1-2-he-xin-ceng-api">1.1.2 核心层API</a><ul>
<li><a href="#1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong">1.1.2.1 spi_register_master-(供适配层调用)</a><ul>
<li><a href="#1-1-2-1-1-spi-controller-initialize-queue-spi-master-initialize-queue">1.1.2.1.1 spi_controller_initialize_queue&#x2F;spi_master_initialize_queue</a></li>
</ul>
</li>
<li><a href="#1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong">1.1.2.2 spi_message_init-(供从设备调用)</a></li>
<li><a href="#1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong">1.1.2.3 spi_message_add_tail-(供从设备调用)</a></li>
<li><a href="#1-1-2-4-spi-async-gong-cong-she-bei-diao-yong">1.1.2.4 spi_async-(供从设备调用)</a><ul>
<li><a href="#1-1-2-4-1-spi-queued-transfer">1.1.2.4.1 spi_queued_transfer</a></li>
</ul>
</li>
<li><a href="#1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong">1.1.2.4 spi_sync-(供从设备调用)</a></li>
<li><a href="#1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong">1.1.2.5 spi_bitbang_start-(供适配层调用)</a><ul>
<li><a href="#1-1-2-5-1-spi-register-master">1.1.2.5.1 spi_register_master</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-spi-kong-zhi-qi-qu-dong-ceng">1.2 SPI控制器驱动层</a><ul>
<li><a href="#1-2-1-spi-kong-zhi-qi-api">1.2.1 SPI控制器API</a><ul>
<li><a href="#1-2-1-1-spi-alloc-master">1.2.1.1 spi_alloc_master</a></li>
<li><a href="#1-2-1-2-spi-master-put">1.2.1.2 spi_master_put</a></li>
<li><a href="#1-2-1-3-spi-register-master-spi-register-controller">1.2.1.3 spi_register_master&#x2F;spi_register_controller</a></li>
<li><a href="#1-2-1-4-spi-unregister-master-spi-unregister-controller">1.2.1.4 spi_unregister_master&#x2F;spi_unregister_controller</a></li>
</ul>
</li>
<li><a href="#1-2-2-spi-kong-zhi-qi-shi-li">1.2.2 SPI控制器示例</a><ul>
<li><a href="#1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu">1.2.2.1 spi控制器设备树描述</a></li>
<li><a href="#1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong">1.2.2.2 imx6ul spi控制器驱动</a><ul>
<li><a href="#1-2-2-2-1-probe-chu-shi-hua-spi-master">1.2.2.2.1 probe-(初始化spi_master)</a></li>
<li><a href="#1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi">1.2.2.2.2 spi_imx_setupxfer-(设置位宽和配置控制器)</a></li>
<li><a href="#1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa">1.2.2.2.3 spi_imx_transfer-(数据收发)</a></li>
<li><a href="#1-2-2-2-4-spi-imx-isr">1.2.2.2.4 spi_imx_isr</a></li>
<li><a href="#1-2-2-2-5-spi-imx-chipselect-pian-xuan">1.2.2.2.5 spi_imx_chipselect-(片选)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-spi-cong-she-bei-qu-dong-ceng">1.3 SPI从设备驱动层</a><ul>
<li><a href="#1-3-1-spi-cong-she-bei-api">1.3.1 SPI从设备API</a><ul>
<li><a href="#1-3-1-1-spi-message-init">1.3.1.1 spi_message_init</a></li>
<li><a href="#1-3-1-2-spi-message-add-tail">1.3.1.2 spi_message_add_tail</a></li>
<li><a href="#1-3-1-3-spi-async">1.3.1.3 spi_async</a></li>
<li><a href="#1-3-1-4-spi-sync">1.3.1.4 spi_sync</a></li>
<li><a href="#1-3-1-5-spi-register-driver">1.3.1.5 spi_register_driver</a></li>
<li><a href="#1-3-1-6-spi-unregister-driver">1.3.1.6 spi_unregister_driver</a></li>
<li><a href="#1-3-1-7-spi-read-spi-write">1.3.1.7 spi_read&#x2F;spi_write</a></li>
</ul>
</li>
<li><a href="#1-3-2-spi-cong-she-bei-shi-li-icm-20608-g">1.3.2 SPI从设备示例-ICM-20608-G</a><ul>
<li><a href="#1-3-2-1-dts-miao-shu">1.3.2.1 dts描述</a><ul>
<li><a href="#1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze">1.3.2.1.1 spi从设备dts描述规则</a></li>
</ul>
</li>
<li><a href="#1-3-2-2-icm20608-qu-dong">1.3.2.2 ICM20608驱动</a><ul>
<li><a href="#1-3-2-2-1-icm20608reg-h">1.3.2.2.1 icm20608reg.h</a></li>
<li><a href="#1-3-2-2-2-icm20608-c">1.3.2.2.2 icm20608.c</a><ul>
<li><a href="#1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi">1.3.2.2.2.1 驱动过程分析</a></li>
</ul>
</li>
<li><a href="#1-3-2-2-3-icm20608app-c">1.3.2.2.3 icm20608App.c</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c">1.3.3 SPI万能从设备驱动-spidev.c</a><ul>
<li><a href="#1-3-3-1-spidev-init">1.3.3.1 spidev_init</a></li>
<li><a href="#1-3-3-2-spidev-de-probe">1.3.3.2 spidev的probe</a></li>
<li><a href="#1-3-3-3-spidev-fops">1.3.3.3 spidev_fops</a><ul>
<li><a href="#1-3-3-3-1-spidev-read">1.3.3.3.1 spidev_read</a></li>
<li><a href="#1-3-3-3-2-spidev-write">1.3.3.3.2 spidev_write</a></li>
<li><a href="#1-3-3-3-3-spidev-ioctl">1.3.3.3.3 spidev_ioctl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.4 使用SPI万能驱动oled举例</a><ul>
<li><a href="#1-3-4-1-spi-oled-yuan-li">1.3.4.1 spi oled原理</a></li>
<li><a href="#1-3-4-2-spi-oled-c">1.3.4.2 spi_oled.c</a><ul>
<li><a href="#1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi">1.3.4.2.1 用户态驱动分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.5 不使用SPI万能驱动oled举例</a><ul>
<li><a href="#1-3-5-1-dts-miao-shu">1.3.5.1 dts描述</a></li>
<li><a href="#1-3-5-2-oled-drv-c">1.3.5.2 oled_drv.c</a><ul>
<li><a href="#1-3-5-2-1-qu-dong-fen-xi">1.3.5.2.1 驱动分析</a></li>
</ul>
</li>
<li><a href="#1-3-5-3-spi-oled-c-ying-yong-ce-shi">1.3.5.3 spi_oled.c应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-spi-master-spi-controller">2.1 spi_master&#x2F;spi_controller</a></li>
<li><a href="#2-2-spi-driver">2.2 spi_driver</a></li>
<li><a href="#2-3-spi-device">2.3 spi_device</a></li>
<li><a href="#2-4-spi-message-spi-transfer">2.4 spi_message&#x2F;spi_transfer</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-linux-spi-qu-dong-kuang-jia">1 Linux SPI驱动框架</span><a href="#1-linux-spi-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>linux SPI驱动框架层次如上图：</p>
<p>除开硬件和用户态应用程序，由上到下分成3层：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设备驱动层: spi框架使用者</span><br><span class="line">核心层：spi框架搭建者</span><br><span class="line">控制器驱动层： spi框架适配者</span><br></pre></td></tr></table></figure>

<h2><span id="1-1-spi-he-xin-ceng">1.1 spi核心层</span><a href="#1-1-spi-he-xin-ceng" class="header-anchor">#</a></h2><p>SPI核心层代码位于<code>linux_5.10\drivers\spi</code>目录:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile for kernel SPI drivers.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ccflags-<span class="variable">$(CONFIG_SPI_DEBUG)</span> := -DDEBUG</span><br><span class="line"><span class="comment"># small core, mostly translating board-specific</span></span><br><span class="line"><span class="comment"># config declarations into driver model code</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MASTER)</span>		+= spi.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MEM)</span>			+= spi-mem.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MUX)</span>			+= spi-mux.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_SPIDEV)</span>		+= spidev.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_LOOPBACK_TEST)</span>		+= spi-loopback-test.o</span><br><span class="line"><span class="comment"># SPI master controller drivers (bus)</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ALTERA)</span>		+= spi-altera.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AR934X)</span>		+= spi-ar934x.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ARMADA_3700)</span>		+= spi-armada-3700.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATMEL)</span>			+= spi-atmel.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATMEL_QUADSPI)</span>		+= atmel-quadspi.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AT91_USART)</span>		+= spi-at91-usart.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATH79)</span>			+= spi-ath79.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AU1550)</span>		+= spi-au1550.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AXI_SPI_ENGINE)</span>	+= spi-axi-spi-engine.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_BCM2835)</span>		+= spi-bcm2835.o</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drivers/spi/spi.c spi-mem.c spi-mux.c</span><br><span class="line">include/linux/spi/spi.h</span><br><span class="line">spi.c：</span><br><span class="line">    一方面对SPI子系统进行初始化工作，注册spi bus，注册spi_master <span class="class"><span class="keyword">class</span>，</span></span><br><span class="line"><span class="class">    同时提供<span class="title">spi</span>设备驱动对<span class="title">spi</span>总线进行操作的<span class="title">API</span>。</span></span><br><span class="line"><span class="class">    另一方面<span class="title">SPI</span>子系统对<span class="title">spi</span>控制器层，提供注册控制器的<span class="title">api</span>和回调操作函数。</span></span><br><span class="line"><span class="class"><span class="title">spi</span>.<span class="title">h</span>包含了<span class="title">spi</span>核心层的一些重要数据结构，<span class="keyword">struct</span> <span class="title">spi_master</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>，以及一些实现比较简单的函数等。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">spi</span>-<span class="title">gpio</span>.<span class="title">c</span>：<span class="title">SPI</span> <span class="title">GPIO</span>框架：<span class="title">SPI</span>子系统提供了一个名为<span class="title">spi</span>-<span class="title">gpio</span>的框架，</span></span><br><span class="line"><span class="class">        可使用<span class="title">GPIO</span>引脚模拟<span class="title">SPI</span>总线，<span class="title">gpio</span>模拟<span class="title">spi</span>代码在<span class="title">drivers</span>/<span class="title">spi</span>/<span class="title">spi</span>-<span class="title">gpio</span>.<span class="title">c</span>中。</span></span><br><span class="line"><span class="class">        这个框架允许将<span class="title">GPIO</span>引脚配置为<span class="title">SPI</span>总线的时钟、片选、输入和输出信号，</span></span><br><span class="line"><span class="class">        并提供了对应的接口函数供驱动程序使用。</span></span><br><span class="line"><span class="class"><span class="title">spi</span>-<span class="title">bitbang</span>：<span class="title">spi</span>-<span class="title">bitbang</span>是<span class="title">Linux</span>内核中提供的一个通用框架，用于在没有硬件<span class="title">SPI</span>控制器</span></span><br><span class="line"><span class="class">        或需要灵活控制<span class="title">SPI</span>时序和配置的系统中模拟<span class="title">SPI</span>总线的通信。代码在<span class="title">spi</span>-<span class="title">bitbang</span>.<span class="title">c</span>中</span></span><br></pre></td></tr></table></figure>

<p>核心层的作用:</p>
<p>对上层的使用者，也就是SPI设备驱动：提供标准的spi收发API，以及设备注册函数。<br>对底下的适配者，也就是控制器驱动层：提供注册控制器接口，并提供一些需要控制器驱动实现的回调函数。</p>
<h3><span id="1-1-1-he-xin-ceng-chu-shi-hua">1.1.1 核心层初始化</span><a href="#1-1-1-he-xin-ceng-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="1-1-1-1-spi-init">1.1.1.1 spi_init</span><a href="#1-1-1-1-spi-init" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span>	status;</span><br><span class="line">	buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">		status = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err0;</span><br><span class="line">	&#125;</span><br><span class="line">	status = bus_register(&amp;spi_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	status = class_register(&amp;spi_master_class);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_SLAVE)) &#123;</span><br><span class="line">		status = class_register(&amp;spi_slave_class);</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class="line">		WARN_ON(of_reconfig_notifier_register(&amp;spi_of_notifier));</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ACPI))</span><br><span class="line">		WARN_ON(acpi_reconfig_notifier_register(&amp;spi_acpi_notifier));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err3:</span><br><span class="line">	class_unregister(&amp;spi_master_class);</span><br><span class="line">err2:</span><br><span class="line">	bus_unregister(&amp;spi_bus_type);</span><br><span class="line">err1:</span><br><span class="line">	kfree(buf);</span><br><span class="line">	buf = <span class="literal">NULL</span>;</span><br><span class="line">err0:</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spi子系统初始化函数，仅仅是注册了<code>spi bus</code>，以及<code>spi_master class</code>。</p>
<p>成功注册后，在<code>/sys/bus </code>下即可找到spi 文件目录，在<code>/sys/class</code>下可以看到spi_master目录:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<h4><span id="1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei">1.1.1.2 spi从设备和驱动的匹配</span><a href="#1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei" class="header-anchor">#</a></h4><p>当spi总线和类注册后，当有驱动和设备匹配上就会调用<code>spi_match_device</code>，也就是<code>spi_bus_type.match</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_match_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>	*<span class="title">sdrv</span> =</span> to_spi_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check override first, and if set, only use the named driver */</span></span><br><span class="line">	<span class="keyword">if</span> (spi-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;driver_override, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>of_match_table</code>的<code>compatible</code>和设备树匹配；</li>
<li>通过<code>acpi_match_table</code>的<code>compatible</code>和<code>device</code>的<code>of_node</code>的<code>compatible</code>匹配；</li>
<li>通过驱动和设备的<code>id_table</code>去匹配。</li>
<li>最后通过驱动和设备的<code>名字</code>去匹配。</li>
</ol>
<p>匹配过程参考[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17031328.html">字符设备驱动-2.总线&#x2F;平台设备&#x2F;平台驱动模型</a></p>
<p> <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">字符设备驱动-2-总线模型和平台设备驱动 | Hexo (fuzidage.github.io)</a>。</p>
<h3><span id="1-1-2-he-xin-ceng-api">1.1.2 核心层API</span><a href="#1-1-2-he-xin-ceng-api" class="header-anchor">#</a></h3><h4><span id="1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong">1.1.2.1 spi_register_master-(供适配层调用)</span><a href="#1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_master</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	status = of_spi_register_master(master);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	...</span><br><span class="line">	dev_set_name(&amp;master-&gt;dev, <span class="string">&quot;spi%u&quot;</span>, master-&gt;bus_num);</span><br><span class="line">	status = device_add(&amp;master-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;registered master %s%s\n&quot;</span>, dev_name(&amp;master-&gt;dev),</span><br><span class="line">			dynamic ? <span class="string">&quot; (dynamic)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (master-&gt;transfer)</span><br><span class="line">		dev_info(dev, <span class="string">&quot;master is unqueued, this is deprecated\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		status = spi_master_initialize_queue(master);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			device_del(&amp;master-&gt;dev);</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	mutex_lock(&amp;board_lock);</span><br><span class="line">	list_add_tail(&amp;master-&gt;<span class="built_in">list</span>, &amp;spi_master_list);</span><br><span class="line">	list_for_each_entry(bi, &amp;board_list, <span class="built_in">list</span>)</span><br><span class="line">		spi_match_master_to_boardinfo(master, &amp;bi-&gt;board_info);</span><br><span class="line">	mutex_unlock(&amp;board_lock);</span><br><span class="line">	...</span><br><span class="line">	of_register_spi_devices(master);</span><br><span class="line">	...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>of_spi_register_master</code>，根据设备树节点中的<code>&quot;cs-gpios&quot;</code>，向<code>struct spi_master</code>添加gpio cs引脚。</p>
</li>
<li><p><code>device_add</code>将device注册到设备模型中。</p>
</li>
<li><p>如果控制器驱动没有自己实现<code>transfer</code>函数，则初始化发送队列<code>spi_master_initialize_queue</code>。（核心层填充默认transfer函数)</p>
</li>
<li><p><code>spi_match_master_to_boardinfo</code>老的方式，遍历所有<code>spi_board_info</code>数据结构，并注册<code>spi_device</code></p>
</li>
<li><p><code>of_register_spi_devices</code>新的设备树方式，遍历spi控制器节点下所有子节点，并注册成对应的<code>spi_device</code>设备</p>
</li>
</ol>
<h5><span id="1-1-2-1-1-spi-controller-initialize-queue-x2f-spi-master-initialize-queue">1.1.2.1.1 spi_controller_initialize_queue&#x2F;spi_master_initialize_queue</span><a href="#1-1-2-1-1-spi-controller-initialize-queue-x2f-spi-master-initialize-queue" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p>可以看到是对控制器<code>spi_master（或者叫做spi_controller）</code>成员函数赋值。<code>transfer_one_message</code>或者<code>transfer</code>赋值成默认的函数。然后调用<code>spi_init_queue</code>和<code>spi_start_queue</code>函数初始化队列并启动工作线程。<code>spi_init_queue</code>函数最主要的作用就是建立一个内核工作线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_init_queue</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	kthread_init_worker(&amp;master-&gt;kworker);</span><br><span class="line">	master-&gt;kworker_task = kthread_run(kthread_worker_fn,</span><br><span class="line">            &amp;master-&gt;kworker, <span class="string">&quot;%s&quot;</span>, dev_name(&amp;master-&gt;dev));</span><br><span class="line">	......</span><br><span class="line">	kthread_init_work(&amp;master-&gt;pump_messages, spi_pump_messages);</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_start_queue</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	master-&gt;running = <span class="literal">true</span>;</span><br><span class="line">	master-&gt;cur_msg = <span class="literal">NULL</span>;</span><br><span class="line">	......</span><br><span class="line">	kthread_queue_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* spi_init_queue函数先初始化kthread_worker，为kthread_worker创建一个内核线程来处理work，</span></span><br><span class="line"><span class="comment">		随后初始化kthread_work,设置work执行函数，work执行函数为spi_pump_messages</span></span><br><span class="line"><span class="comment">spi_start_queue就相对简单了，只是唤醒该工作线程而已；自此，队列化的相关工作已经完成，</span></span><br><span class="line"><span class="comment">		系统等待message请求被发起，然后在工作线程中处理message的传送工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4><span id="1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong">1.1.2.2 spi_message_init-(供从设备调用)</span><a href="#1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p>对<code>spi_massage</code>进行初始化.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init_no_memset</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	INIT_LIST_HEAD(&amp;m-&gt;transfers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;m-&gt;resources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span> *m);</span><br><span class="line">	spi_message_init_no_memset(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong">1.1.2.3 spi_message_add_tail-(供从设备调用)</span><a href="#1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">spi_message_add_tail</span><span class="params">(<span class="keyword">struct</span> spi_transfer *t, <span class="keyword">struct</span> spi_message *m)</span> &#123;</span><br><span class="line">	list_add_tail(&amp;t-&gt;transfer_list, &amp;m-&gt;transfers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是把<code>spi_transfer</code>这个<code>buffer</code>添加到<code>spi_message</code>传输链表中。</p>
<h4><span id="1-1-2-4-spi-async-gong-cong-she-bei-diao-yong">1.1.2.4 spi_async-(供从设备调用)</span><a href="#1-1-2-4-spi-async-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p>发起数据传输。可以看到就是调用控制器内部的<code>master-&gt;transfer</code>。既然是<code>async</code>那就是异步执行的，不会等待传输是否完成，就直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spi_async-&gt;</span><br><span class="line">		__spi_async-&gt;</span><br><span class="line">				master-&gt;transfer</span><br></pre></td></tr></table></figure>

<p>那假如<code>master-&gt;transfer</code>控制器这边没有去实现。内核会自己填充默认的transfer函数<code>spi_queued_transfer</code>.</p>
<h5><span id="1-1-2-4-1-spi-queued-transfer">1.1.2.4.1 spi_queued_transfer</span><a href="#1-1-2-4-1-spi-queued-transfer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spi_queued_transfer(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *msg) &#123;</span><br><span class="line">		__spi_queued_transfer(spi, msg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __spi_queued_transfer(<span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">				 <span class="keyword">struct</span> spi_message *msg,</span><br><span class="line">				 <span class="type">bool</span> need_pump) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> *<span class="title">master</span> =</span> spi-&gt;master;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span><br><span class="line">	...</span><br><span class="line">	list_add_tail(&amp;msg-&gt;<span class="built_in">queue</span>, &amp;master-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">if</span> (!master-&gt;busy &amp;&amp; need_pump)</span><br><span class="line">		kthread_queue_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span><br><span class="line">	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到默认的<code>spi_queued_transfer</code>就是去把<code>message</code>添加到<code>master</code>的发送链表中。接下来就交给工作服务线程<code>__spi_pump_messages</code>去处理<code>message</code>。</p>
<h4><span id="1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong">1.1.2.4 spi_sync-(供从设备调用)</span><a href="#1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p>同理，<code>spi_sync</code>就是用来同步传输 <code>spi_message</code>, 完成传输后会调用<code>spi_comlete</code>唤醒等待的线程。</p>
<p>那假如<code>master-&gt;transfer</code>控制器这边没有去实现。内核也会自己填充默认的transfer函数<code>spi_queued_transfer</code>.可以看到<code>need_pump=false</code>,因此还是一样就是去把message添加到master的发送链表中。</p>
<p>然后调用<code>__spi_pump_messages</code>，也就是工作线程服务，交给工作服务线程去处理message。</p>
<p>最后调用<code>wait_for_completion</code>去等待传输完成。</p>
<h4><span id="1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong">1.1.2.5 spi_bitbang_start-(供适配层调用)</span><a href="#1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_bitbang_start</span><span class="params">(<span class="keyword">struct</span> spi_bitbang *bitbang)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> *<span class="title">master</span> =</span> bitbang-&gt;master;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master || !bitbang-&gt;chipselect)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;bitbang-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master-&gt;mode_bits)</span><br><span class="line">        master-&gt;mode_bits = SPI_CPOL | SPI_CPHA | bitbang-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;transfer || master-&gt;transfer_one_message)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    master-&gt;prepare_transfer_hardware = spi_bitbang_prepare_hardware;</span><br><span class="line">    master-&gt;unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;</span><br><span class="line">    master-&gt;transfer_one = spi_bitbang_transfer_one;</span><br><span class="line">    master-&gt;set_cs = spi_bitbang_set_cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bitbang-&gt;txrx_bufs) &#123;</span><br><span class="line">        bitbang-&gt;use_dma = <span class="number">0</span>;</span><br><span class="line">        bitbang-&gt;txrx_bufs = spi_bitbang_bufs;</span><br><span class="line">        <span class="keyword">if</span> (!master-&gt;setup) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitbang-&gt;setup_transfer)</span><br><span class="line">                bitbang-&gt;setup_transfer =</span><br><span class="line">                     spi_bitbang_setup_transfer;</span><br><span class="line">            master-&gt;setup = spi_bitbang_setup;</span><br><span class="line">            master-&gt;cleanup = spi_bitbang_cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver may get busy before register() returns, especially</span></span><br><span class="line"><span class="comment">     * if someone registered boardinfo for devices</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = spi_register_master(spi_master_get(master));</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        spi_master_put(master);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果主设备结构体中的传输模式位字段 <code>mode_bits</code> 未设置，则设置为默认的模式位，包括 <code>SPI_CPOL</code>、<code>SPI_CPHA </code>和<code>位移传输控制</code>结构体中的标志位。</p>
</li>
<li><p>检查主设备结构体中的传输函数是否已经定义，如果已定义则返回错误码<code> -EINVAL</code>。</p>
</li>
<li><p>设置主设备结构体中的准备硬件传输函数、释放硬件传输函数、单次传输函数和片选信号控制函数，分别对应位移传输控制结构体中的对应函数。</p>
</li>
<li><p>如果位移传输控制结构体中的数据缓冲区传输函数未定义，则设置使用 DMA 标志为 0，并将数据缓冲区传输函数设置为默认的位移传输函数 <code>spi_bitbang_bufs</code>。如果主设备结构体中的设置函数未定义，则设置使用默认的设置函数 <code>spi_bitbang_setup</code> 和清理函数 <code>spi_bitbang_cleanup</code>。</p>
</li>
<li><p>注册 SPI 主设备，将其添加到系统中。</p>
</li>
</ol>
<h5><span id="1-1-2-5-1-spi-register-master">1.1.2.5.1 spi_register_master</span><a href="#1-1-2-5-1-spi-register-master" class="header-anchor">#</a></h5><h2><span id="1-2-spi-kong-zhi-qi-qu-dong-ceng">1.2 SPI控制器驱动层</span><a href="#1-2-spi-kong-zhi-qi-qu-dong-ceng" class="header-anchor">#</a></h2><p>控制器驱动就是用来实现<code>spi_master</code>中的成员函数。如<code>transfer, transfer_one_message</code>。基本流程是：申请 <code>spi_master</code>，然后初始化<code> spi_master</code>，最后向 Linux 内核注册 <code>spi_master</code>。</p>
<h3><span id="1-2-1-spi-kong-zhi-qi-api">1.2.1 SPI控制器API</span><a href="#1-2-1-spi-kong-zhi-qi-api" class="header-anchor">#</a></h3><h4><span id="1-2-1-1-spi-alloc-master">1.2.1.1 spi_alloc_master</span><a href="#1-2-1-1-spi-alloc-master" class="header-anchor">#</a></h4><p>申请spi控制器内存。</p>
<p><code>struct spi_master *spi_alloc_master(struct device *dev, unsigned size);</code></p>
<p>dev：设备，一般是 platform_device 中的 dev 成员变量。 </p>
<p>size：私有数据大小，可以通过<code> spi_master_get_devdata</code> 函数获取到这些私有数据。</p>
<p> 返回值：申请到的 spi_master。</p>
<h4><span id="1-2-1-2-spi-master-put">1.2.1.2 spi_master_put</span><a href="#1-2-1-2-spi-master-put" class="header-anchor">#</a></h4><p> <code>spi_master </code>的释放通过 <code>spi_master_put</code>函数来完成，当我们删除一个 SPI 主机驱动的时候就 需要释放掉前面申请的 spi_master，<code>spi_master_put </code>函数原型如下： </p>
<p><code>void spi_master_put(struct spi_master *master);</code></p>
<p>释放spi控制器内存。</p>
<h4><span id="1-2-1-3-spi-register-master-x2f-spi-register-controller">1.2.1.3 spi_register_master&#x2F;spi_register_controller</span><a href="#1-2-1-3-spi-register-master-x2f-spi-register-controller" class="header-anchor">#</a></h4><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，<code>spi_register_master</code>注册spi控制器。</p>
<p><code>int spi_register_master(struct spi_master *master);</code></p>
<h4><span id="1-2-1-4-spi-unregister-master-x2f-spi-unregister-controller">1.2.1.4 spi_unregister_master&#x2F;spi_unregister_controller</span><a href="#1-2-1-4-spi-unregister-master-x2f-spi-unregister-controller" class="header-anchor">#</a></h4><p>spi控制器卸载。</p>
<p><code>void spi_unregister_master(struct spi_master *master);</code></p>
<h3><span id="1-2-2-spi-kong-zhi-qi-shi-li">1.2.2 SPI控制器示例</span><a href="#1-2-2-spi-kong-zhi-qi-shi-li" class="header-anchor">#</a></h3><p>以飞思卡尔nxp官方spi驱动为例，文件位于<code>linux\drivers\spi\spi-imx.c</code></p>
<h4><span id="1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu">1.2.2.1 spi控制器设备树描述</span><a href="#1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu" class="header-anchor">#</a></h4><p>打开设备树文件<code>imx6ul.dtsi</code>：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ecspi3: spi@<span class="number">2010000</span> &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x02010000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">        dmas = &lt;&amp;sdma <span class="number">7</span> <span class="number">7</span> <span class="number">1</span>&gt;, &lt;&amp;sdma <span class="number">8</span> <span class="number">7</span> <span class="number">2</span>&gt;;</span><br><span class="line">        dma-names = <span class="string">&quot;rx&quot;</span>, <span class="string">&quot;tx&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong">1.2.2.2 imx6ul spi控制器驱动</span><a href="#1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong" class="header-anchor">#</a></h4><h5><span id="1-2-2-2-1-probe-chu-shi-hua-spi-master">1.2.2.2.1 probe-(初始化spi_master)</span><a href="#1-2-2-2-1-probe-chu-shi-hua-spi-master" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li><p>解析设备树，初始化控制器</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<p>配置master和spi_imx。包括传输函数，片选函数，片选引脚。<code>master</code>作为平台设备的dev的driver_data, <code>spi_imx</code>作为master的dev的driver_data。</p>
<p>获取irq, res等信息，进行ioremap和注册irq。</p>
<p>设置时钟，开启时钟。</p>
<p>初始话dma寄存器。进行控制器初始化和复位。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/9-1.png" alt="image"></p>
</li>
<li><p>申请并初始化 spi_master， 调用 <code>spi_bitbang_start</code> 函数(<code>spi_bitbang_start 会调用 spi_register_master 函数</code>)向 Linux 内核注册 spi_master。</p>
</li>
</ol>
<h5><span id="1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi">1.2.2.2.2 spi_imx_setupxfer-(设置位宽和配置控制器)</span><a href="#1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>设置 <code>spi_imx</code> 的 tx 和 rx 传输函数。根据要发送的数据数据位宽的不 同，分别有 8 位、16 位和 32 位的发送函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spi_imx_buf_tx_u8</span><br><span class="line">spi_imx_buf_tx_u16</span><br><span class="line">spi_imx_buf_tx_u32</span><br><span class="line">spi_imx_buf_rx_u8</span><br><span class="line">spi_imx_buf_rx_u16</span><br><span class="line">spi_imx_buf_rx_u32</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_RX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_rx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;	    <span class="comment">//将要接收的数据值读到 ECSPI 的 MXC_CSPIRXDATA 寄存器里面去	\</span></span><br><span class="line">	unsigned <span class="built_in">int</span> val = readl(spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPIRXDATA);	\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;rx_buf) &#123;						\</span><br><span class="line">		*(type *)spi_imx-&gt;rx_buf = val;				\</span><br><span class="line">		spi_imx-&gt;rx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_TX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_tx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	type val = <span class="number">0</span>;							\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;tx_buf) &#123;						\</span><br><span class="line">		val = *(type *)spi_imx-&gt;tx_buf;				\</span><br><span class="line">		spi_imx-&gt;tx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">									\</span><br><span class="line">	spi_imx-&gt;count -= <span class="keyword">sizeof</span>(type);					\</span><br><span class="line"><span class="comment">//将要发送的数据值写入到 ECSPI 的 TXDATA 寄存器里面去		\</span></span><br><span class="line">	writel(val, spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPITXDATA);	\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MXC_SPI_BUF_RX(u8)</span><br><span class="line">MXC_SPI_BUF_TX(u8)</span><br><span class="line">MXC_SPI_BUF_RX(u16)</span><br><span class="line">MXC_SPI_BUF_TX(u16)</span><br><span class="line">MXC_SPI_BUF_RX(u32)</span><br><span class="line">MXC_SPI_BUF_TX(u32)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p>调用关系如下：<code>mx51_ecspi_config</code>就是最底层<code>SPI controller</code>的寄存器配置，这里不做分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spi_imx-&gt;bitbang.setup_transfer = spi_imx_setupxfer</span><br><span class="line">	spi_imx-&gt;devtype_data-&gt;config = mx51_ecspi_config</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa">1.2.2.2.3 spi_imx_transfer-(数据收发)</span><a href="#1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa" class="header-anchor">#</a></h5><p>数据收发函数为<code> spi_imx_transfer</code>:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spi_imx_transfer</span><br><span class="line">    -&gt; spi_imx_pio_transfer</span><br><span class="line">        -&gt; spi_imx_push</span><br><span class="line">        	-&gt; spi_imx-&gt;tx</span><br></pre></td></tr></table></figure>

<p><code>spi_imx</code> 是个 <code>spi_imx_data </code>类型的机构指针变量，其中 tx 和 rx 这两个成员变量分别为 SPI 数据发送和接收函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spi_bitbang_start中</span><br><span class="line">    -&gt;master-&gt;transfer_one = spi_bitbang_transfer_one;</span><br><span class="line">当spi_bitbang_transfer_on时</span><br><span class="line">    bitbang-&gt;txrx_bufs(spi,t) = spi_imx_transfer</span><br><span class="line">    也就是spi_imx-&gt;tx就可以spi_imx_buf_tx_u8</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-4-spi-imx-isr">1.2.2.2.4 spi_imx_isr</span><a href="#1-2-2-2-4-spi-imx-isr" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>中断服务程序，只要rx_available,启用spi_imx-&gt;rx。从<code>MXC_CSPIRXDATA</code> 寄存器读出数据。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __<span class="function">maybe_unused <span class="title">mx51_ecspi_rx_available</span>(<span class="params"><span class="keyword">struct</span> spi_imx_data *spi_imx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(spi_imx-&gt;<span class="keyword">base</span> + MX51_ECSPI_STAT) &amp; MX51_ECSPI_STAT_RR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_RX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_rx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	unsigned <span class="built_in">int</span> val = readl(spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPIRXDATA);	\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;rx_buf) &#123;						\</span><br><span class="line">		*(type *)spi_imx-&gt;rx_buf = val;				\</span><br><span class="line">		spi_imx-&gt;rx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-5-spi-imx-chipselect-pian-xuan">1.2.2.2.5 spi_imx_chipselect-(片选)</span><a href="#1-2-2-2-5-spi-imx-chipselect-pian-xuan" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p>设置片选gpio电平。</p>
<h2><span id="1-3-spi-cong-she-bei-qu-dong-ceng">1.3 SPI从设备驱动层</span><a href="#1-3-spi-cong-she-bei-qu-dong-ceng" class="header-anchor">#</a></h2><h3><span id="1-3-1-spi-cong-she-bei-api">1.3.1 SPI从设备API</span><a href="#1-3-1-spi-cong-she-bei-api" class="header-anchor">#</a></h3><h4><span id="1-3-1-1-spi-message-init">1.3.1.1 spi_message_init</span><a href="#1-3-1-1-spi-message-init" class="header-anchor">#</a></h4><p><code>void spi_message_init(struct spi_message *m);</code></p>
<p>在使用<code>spi_message</code>之前需要对其进行初始化。</p>
<h4><span id="1-3-1-2-spi-message-add-tail">1.3.1.2 spi_message_add_tail</span><a href="#1-3-1-2-spi-message-add-tail" class="header-anchor">#</a></h4><p><code>void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m);</code></p>
<p><code>spi_message </code>初始化完成以后需要将 <code>spi_transfer</code> 添加到 <code>spi_message</code> 队列中。</p>
<h4><span id="1-3-1-3-spi-async">1.3.1.3 spi_async</span><a href="#1-3-1-3-spi-async" class="header-anchor">#</a></h4><p>参考核心层api有介绍。</p>
<h4><span id="1-3-1-4-spi-sync">1.3.1.4 spi_sync</span><a href="#1-3-1-4-spi-sync" class="header-anchor">#</a></h4><p>参考核心层api有介绍。</p>
<h4><span id="1-3-1-5-spi-register-driver">1.3.1.5 spi_register_driver</span><a href="#1-3-1-5-spi-register-driver" class="header-anchor">#</a></h4><h4><span id="1-3-1-6-spi-unregister-driver">1.3.1.6 spi_unregister_driver</span><a href="#1-3-1-6-spi-unregister-driver" class="header-anchor">#</a></h4><h4><span id="1-3-1-7-spi-read-x2f-spi-write">1.3.1.7 spi_read&#x2F;spi_write</span><a href="#1-3-1-7-spi-read-x2f-spi-write" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init_with_transfers</span><span class="params">(<span class="keyword">struct</span> spi_message *m,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> spi_transfer *xfers, <span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	spi_message_init(m);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_xfers; ++i)</span><br><span class="line">		spi_message_add_tail(&amp;xfers[i], m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_sync_transfer</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_transfer *xfers,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line">	spi_message_init_with_transfers(&amp;msg, xfers, num_xfers);</span><br><span class="line">	<span class="keyword">return</span> spi_sync(spi, &amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.rx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_write</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.tx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spi_read, spi_write</code>本质还是调用<code>spi_sync</code>传输函数，做了一层封装把<code>spi_transfrer</code>和<code>spi_message</code>包装好了。</p>
<h3><span id="1-3-2-spi-cong-she-bei-shi-li-icm-20608-g">1.3.2 SPI从设备示例-ICM-20608-G</span><a href="#1-3-2-spi-cong-she-bei-shi-li-icm-20608-g" class="header-anchor">#</a></h3><p>该传感器详细介绍：<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">6轴陀螺仪加速度传感器ICM-20608-G</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17780817.html">IMX6ULL SPI应用-6轴陀螺仪加速度传感器ICM-20608-G - fuzidage - 博客园 (cnblogs.com)</a></p>
<h4><span id="1-3-2-1-dts-miao-shu">1.3.2.1 dts描述</span><a href="#1-3-2-1-dts-miao-shu" class="header-anchor">#</a></h4><p>打开自己board对应的dts,我这里是<code>imx6ull-alientek-emmc.dts</code>。我们修改<code>ecspi3 spi控制器</code>。我的spi3接了一个<code>ICM-20608</code>。资源定义如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>根据原理图接线先配置<code>iomux</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="number">0x10b0</span> <span class="comment">/* CS */</span></span><br><span class="line">		MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="number">0x10b1</span> <span class="comment">/* SCLK */</span></span><br><span class="line">		MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="number">0x10b1</span> <span class="comment">/* MISO */</span></span><br><span class="line">		MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="number">0x10b1</span> <span class="comment">/* MOSI */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UART2_TX_DATA </code>这个 IO 是<code> ICM20608</code> 的片选信号，这里我们并没有将其复用为 ECSPI3 的<code>SS0</code>信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复 用为普通的 GPIO。</p>
<p><code>imx6ull-alientek-emmc.dts</code>重新修改<code>ecspi3</code>节点，追加从设备描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">	fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	spidev: icm20608@<span class="number">0</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,icm20608&quot;</span>;</span><br><span class="line">		spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;</span><br><span class="line">		reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置当前片选数量为 1，因为就只接了一个<code> ICM20608</code>。</li>
<li>一定要使用 <code>“cs-gpios”</code>属性来描述片选引脚，SPI 主机驱动就会控制片选引脚。 </li>
<li><code>imx6ull.dtsi</code> 文件中默认将 <code>ecspi3</code> 节点状态(status)设置为<code>“disable”</code>，这里我们要将 其改为<code>“okay”</code>。 </li>
<li><code>icm20608</code> 设备子节点，因为 <code>icm20608 </code>连接在<code>ECSPI3</code>的第 0 个通道上，因此 @后面为 0。<ol>
<li>设置节点属性兼容值为<code>“alientek,icm20608”</code>。</li>
<li>设置 SPI 最大时钟频 率为 <code>8MHz</code>，这是 ICM20608 的 SPI 接口所能支持的最大的时钟频率。</li>
<li>icm20608 连接 在<code>通道 0 </code>上，因此 reg 为 0。</li>
</ol>
</li>
</ol>
<h5><span id="1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze">1.3.2.1.1 spi从设备dts描述规则</span><a href="#1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze" class="header-anchor">#</a></h5><p>打开<code>linux\Documentation\devicetree\bindings\spi\spi-bus.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SPI slave nodes must be children of the SPI master node and can</span><br><span class="line">contain the following properties.</span><br><span class="line">- reg             - (required) chip select address of device.</span><br><span class="line">- compatible      - (required) name of SPI device following generic names</span><br><span class="line">    		recommended practice</span><br><span class="line">- spi-max-frequency - (required) Maximum SPI clocking speed of device in Hz</span><br><span class="line">- spi-cpol        - (optional) Empty property indicating device requires</span><br><span class="line">    		inverse clock <span class="title function_">polarity</span> <span class="params">(CPOL)</span> mode</span><br><span class="line">- spi-cpha        - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		shifted clock <span class="title function_">phase</span> <span class="params">(CPHA)</span> mode</span><br><span class="line">- spi-cs-high     - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		chip select active high</span><br><span class="line">- spi-3wire       - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		    3-wire mode.</span><br><span class="line">- spi-lsb-first   - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">		LSB first mode.</span><br><span class="line">- spi-tx-bus-width - <span class="params">(optional)</span> The bus <span class="title function_">width</span><span class="params">(number of data wires)</span> that</span><br><span class="line">                      used <span class="keyword">for</span> MOSI. Defaults to 1 <span class="keyword">if</span> not present.</span><br><span class="line">- spi-rx-bus-width - <span class="params">(optional)</span> The bus <span class="title function_">width</span><span class="params">(number of data wires)</span> that</span><br><span class="line">                      used <span class="keyword">for</span> MISO. Defaults to 1 <span class="keyword">if</span> not present.</span><br></pre></td></tr></table></figure>

<h4><span id="1-3-2-2-icm20608-qu-dong">1.3.2.2 ICM20608驱动</span><a href="#1-3-2-2-icm20608-qu-dong" class="header-anchor">#</a></h4><h5><span id="1-3-2-2-1-icm20608reg-h">1.3.2.2.1 icm20608reg.h</span><a href="#1-3-2-2-1-icm20608reg-h" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ICM20608_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_H</span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">文件名		: icm20608reg.h</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608G_ID			0XAF	<span class="comment">/* ID值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608D_ID			0XAE	<span class="comment">/* ID值 */</span></span></span><br><span class="line"><span class="comment">/* ICM20608寄存器 </span></span><br><span class="line"><span class="comment"> *复位后所有寄存器地址都为0，除了</span></span><br><span class="line"><span class="comment"> *Register 107(0X6B) Power Management 1 	= 0x40</span></span><br><span class="line"><span class="comment"> *Register 117(0X75) WHO_AM_I 				= 0xAF或0xAE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FSYNC_INT				0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_ENABLE			0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_STATUS			0x3A</span></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_USER_CTRL				0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_R_W				0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5><span id="1-3-2-2-2-icm20608-c">1.3.2.2.2 icm20608.c</span><a href="#1-3-2-2-2-icm20608-c" class="header-anchor">#</a></h5><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;icm20608reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_NAME	<span class="string">&quot;icm20608&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;				<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>			<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 	<span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;					<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;			<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc;		<span class="comment">/* 陀螺仪X轴原始值 	 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_adc;		<span class="comment">/* 陀螺仪Y轴原始值		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_adc;		<span class="comment">/* 陀螺仪Z轴原始值 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc;		<span class="comment">/* 加速度计X轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_adc;		<span class="comment">/* 加速度计Y轴原始值	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_adc;		<span class="comment">/* 加速度计Z轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;		<span class="comment">/* 温度原始值 			*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> <span class="title">icm20608dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 从icm20608读取多个寄存器数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  读取到的数据</span></span><br><span class="line"><span class="comment"> * @param - len:  要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @return 		: 操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> txdata[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> * rxdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rxdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len, GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!rxdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，一共要读取len个字节长度的数据，*/</span></span><br><span class="line">	txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;		<span class="comment">/* 写数据的时候首寄存器地址bit8要置1 */</span>			</span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">    t-&gt;rx_buf = rxdata;			<span class="comment">/* 要读取的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//第一步，发送寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步，读取数据</span></span><br><span class="line">    txdata[<span class="number">0</span>] = <span class="number">0xff</span>;</span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf , rxdata+<span class="number">1</span>, len);  <span class="comment">/* 只需要读取的数据 */</span></span><br><span class="line">out2:</span><br><span class="line">	kfree(rxdata);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:	</span><br><span class="line">	kfree(t);						<span class="comment">/* 释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608多个寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写入的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  要写入的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - len:  要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @return 	  :   操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *txdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	txdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>)+len, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(!txdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，len为要写入的寄存器的集合，*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	*txdata = reg &amp; ~<span class="number">0x80</span>;	<span class="comment">/* 写数据的时候首寄存器地址bit8要清零 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(txdata+<span class="number">1</span>, buf, len);	<span class="comment">/* 把len个寄存器拷贝到txdata里，等待发送 */</span></span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//第一步，发送寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg &amp; ~<span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步，写入数据</span></span><br><span class="line">    t-&gt;tx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line">out2:</span><br><span class="line">	kfree(txdata);				<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:</span><br><span class="line">	kfree(t);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取icm20608指定寄存器值，读取一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器</span></span><br><span class="line"><span class="comment"> * @return 	  :   读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line">	icm20608_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608指定寄存器写入指定的值，写一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写的寄存器</span></span><br><span class="line"><span class="comment"> * @param - data: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return   :    无</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">icm20608_write_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span> &#123;</span><br><span class="line">	u8 buf = value;</span><br><span class="line">	icm20608_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_readdata</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]); </span><br><span class="line">	dev-&gt;accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]); </span><br><span class="line">	dev-&gt;accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]); </span><br><span class="line">	dev-&gt;temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]); </span><br><span class="line">	dev-&gt;gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]); </span><br><span class="line">	dev-&gt;gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">	dev-&gt;gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;icm20608dev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">icm20608_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span>&#123;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> data[<span class="number">7</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> icm20608_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	icm20608_readdata(dev);</span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;gyro_x_adc;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;gyro_y_adc;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;gyro_z_adc;</span><br><span class="line">	data[<span class="number">3</span>] = dev-&gt;accel_x_adc;</span><br><span class="line">	data[<span class="number">4</span>] = dev-&gt;accel_y_adc;</span><br><span class="line">	data[<span class="number">5</span>] = dev-&gt;accel_z_adc;</span><br><span class="line">	data[<span class="number">6</span>] = dev-&gt;temp_adc;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">icm20608_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = icm20608_open,</span><br><span class="line">	.read = icm20608_read,</span><br><span class="line">	.release = icm20608_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_reginit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	u8 value = <span class="number">0</span>;</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x80</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	value = icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);</span><br><span class="line">	printk(<span class="string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);	</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, <span class="number">0x00</span>); 	<span class="comment">/* 输出速率是内部采样率					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 陀螺仪±2000dps量程 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 加速度计±16G量程 					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, <span class="number">0x04</span>); 		<span class="comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); <span class="comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, <span class="number">0x00</span>); 	<span class="comment">/* 打开加速度计和陀螺仪所有轴 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, <span class="number">0x00</span>); 	<span class="comment">/* 关闭低功耗 						*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, <span class="number">0x00</span>);		<span class="comment">/* 关闭FIFO						*/</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (icm20608dev.major) &#123;</span><br><span class="line">		icm20608dev.devid = MKDEV(icm20608dev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;icm20608dev.devid, <span class="number">0</span>, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">		icm20608dev.major = MAJOR(icm20608dev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;icm20608dev.cdev, &amp;icm20608_ops);</span><br><span class="line">	cdev_add(&amp;icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);</span><br><span class="line"></span><br><span class="line">	icm20608dev.class = class_create(THIS_MODULE, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.class);</span><br><span class="line">	&#125;</span><br><span class="line">	icm20608dev.device = device_create(icm20608dev.class, <span class="literal">NULL</span>, icm20608dev.devid, <span class="literal">NULL</span>, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化spi_device */</span></span><br><span class="line">	spi-&gt;mode = SPI_MODE_0;	<span class="comment">/*MODE0，CPOL=0，CPHA=0*/</span></span><br><span class="line">	spi_setup(spi);</span><br><span class="line">	icm20608dev.private_data = spi; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="comment">/* 初始化ICM20608内部寄存器 */</span></span><br><span class="line">	icm20608_reginit();		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">	cdev_del(&amp;icm20608dev.cdev);</span><br><span class="line">	unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);</span><br><span class="line">	device_destroy(icm20608dev.class, icm20608dev.devid);</span><br><span class="line">	class_destroy(icm20608dev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">icm20608_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,icm20608&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">icm20608_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,icm20608&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI驱动结构体 */</span>	</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">icm20608_driver</span> =</span> &#123;</span><br><span class="line">	.probe = icm20608_probe,</span><br><span class="line">	.remove = icm20608_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;icm20608&quot;</span>,</span><br><span class="line">		   	.of_match_table = icm20608_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line">		   </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">icm20608_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">icm20608_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(icm20608_init);</span><br><span class="line">module_exit(icm20608_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

</details>

<h6><span id="1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi">1.3.2.2.2.1 驱动过程分析</span><a href="#1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi" class="header-anchor">#</a></h6><ol>
<li><p>作为一个spi从设备驱动，需要定义一个<code>spi_driver</code> <code>icm20608_driver</code>。通过<code>spi_register_driver</code>、<code>spi_unregister_driver</code>注册卸载。</p>
</li>
<li><p><code>compatible</code>匹配执行probe。</p>
<ol>
<li>定一个<code>icm20608_dev</code>，按照字符设备框架，注册字符设备。</li>
<li><code>spi_setup</code>设置<code>spi_device</code>从设备, 设置spi设备的模式和速率。<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image-20240831182608432"></li>
<li>初始化<code>ICM20608</code>内部寄存器（发起spi传输）。<ol>
<li>设置启动时序，使能读写。</li>
<li>读id。</li>
<li>设置量程，速率。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>ICM20608</code>的读写</p>
</li>
<li><p><code>icm20608_read</code>调用<code>icm20608_readdata</code>，调用<code>icm20608_read_regs</code></p>
</li>
<li><p><code>icm20608_write_regs</code>， <code>icm20608_read_regs</code>用来spi协议让主控去读写spi从设备，都是通过<code>spi_sync</code>进行数据传输。</p>
</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<pre><code>  将函数精简话一下：
</code></pre>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"></p>
<p>注意精简后有个bug, 就是调用spi_write后，又继续调用spi_read。这时imx6ul spi控制器驱动内部会帮忙控制cs片选信号。又会重新拉高，再拉低cs片选。因此导致数据传输异常。nxp官方也是用的gpio作为cs片选，软件手动去控制的。因此优化如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p>probe读出icm20608 <code>id</code>为：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<h5><span id="1-3-2-2-3-icm20608app-c">1.3.2.2.3 icm20608App.c</span><a href="#1-3-2-2-3-icm20608app-c" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> databuf[<span class="number">7</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc, gyro_y_adc, gyro_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc, accel_y_adc, accel_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;</span><br><span class="line">	<span class="type">float</span> accel_x_act, accel_y_act, accel_z_act;</span><br><span class="line">	<span class="type">float</span> temp_act;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			gyro_x_adc = databuf[<span class="number">0</span>];</span><br><span class="line">			gyro_y_adc = databuf[<span class="number">1</span>];</span><br><span class="line">			gyro_z_adc = databuf[<span class="number">2</span>];</span><br><span class="line">			accel_x_adc = databuf[<span class="number">3</span>];</span><br><span class="line">			accel_y_adc = databuf[<span class="number">4</span>];</span><br><span class="line">			accel_z_adc = databuf[<span class="number">5</span>];</span><br><span class="line">			temp_adc = databuf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 计算实际值 */</span></span><br><span class="line">			gyro_x_act = (<span class="type">float</span>)(gyro_x_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_y_act = (<span class="type">float</span>)(gyro_y_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_z_act = (<span class="type">float</span>)(gyro_z_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			accel_x_act = (<span class="type">float</span>)(accel_x_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_y_act = (<span class="type">float</span>)(accel_y_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_z_act = (<span class="type">float</span>)(accel_z_adc) / <span class="number">2048</span>;</span><br><span class="line">			temp_act = ((<span class="type">float</span>)(temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n原始值:\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc, gyro_y_adc, gyro_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;temp = %d\r\n&quot;</span>, temp_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;实际值:&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act temp = %.2f°C\r\n&quot;</span>, temp_act);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<h3><span id="1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c">1.3.3 SPI万能从设备驱动-spidev.c</span><a href="#1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c" class="header-anchor">#</a></h3><p>万能SPI从设备驱动对应spidev， 驱动代码位于<code>/drivers/spi/spidev.c</code>。不用为每个spi从设备去写一个驱动，linux内核有一个万能通用的从设备驱动。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<p>为什么说<code>spidev.c</code>是一个通用的从设备驱动。</p>
<p>spidev不是专门针对某一SPI硬件设备做的驱动，只是简单的注册字符设备，用户空间通过<code>read、write、ioctl</code>，直接对spi进行操作，相当于是用户空间和spi设备的桥梁。用户空间操作时，打开设备节点，然后通过IOCTL设置模式、速度等参数，然后就可以调用<code>read write</code>进行操作了。</p>
<h4><span id="1-3-3-1-spidev-init">1.3.3.1 spidev_init</span><a href="#1-3-3-1-spidev-init" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p>注册了字符设备，主设备号<code>SPIDEV_MAJOR= 153</code>，绑定<code>spidev_fops</code>。</p>
<p>创建了spidev的class，创建完成后在用户空间<code>/sys/class/</code>下可以看到spidev目录结构。</p>
<p><code>spi_register_driver</code>按照标准流程注册spidev从设备驱动。</p>
<h4><span id="1-3-3-2-spidev-de-probe">1.3.3.2 spidev的probe</span><a href="#1-3-3-2-spidev-de-probe" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">spidev_dt_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;rohm,dh2228fv&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;lineartechnology,ltc2488&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;ge,achc&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;nanopi,spidev&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;semtech,sx1301&quot;</span> &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spidev_spi_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name =		<span class="string">&quot;spidev&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(spidev_dt_ids),</span><br><span class="line">		.acpi_match_table = ACPI_PTR(spidev_acpi_ids),</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe =	spidev_probe,</span><br><span class="line">	.remove =	spidev_remove,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		minor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (spi-&gt;dev.of_node &amp;&amp; !of_match_device(spidev_dt_ids, &amp;spi-&gt;dev)) &#123;</span><br><span class="line">		dev_err(&amp;spi-&gt;dev, <span class="string">&quot;buggy DT: spidev listed directly in DT\n&quot;</span>);</span><br><span class="line">		WARN_ON(spi-&gt;dev.of_node &amp;&amp;</span><br><span class="line">			!of_match_device(spidev_dt_ids, &amp;spi-&gt;dev));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spidev_probe_acpi(spi);</span><br><span class="line">	<span class="comment">/* Allocate driver data */</span></span><br><span class="line">	spidev = kzalloc(<span class="keyword">sizeof</span>(*spidev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!spidev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/* Initialize the driver data */</span></span><br><span class="line">	spidev-&gt;spi = spi;</span><br><span class="line">	spin_lock_init(&amp;spidev-&gt;spi_lock);</span><br><span class="line">	mutex_init(&amp;spidev-&gt;buf_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;spidev-&gt;device_entry);</span><br><span class="line">	<span class="comment">/* If we can allocate a minor number, hook up this device.</span></span><br><span class="line"><span class="comment">	 * Reusing minors is fine so long as udev or mdev is working.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;device_list_lock);</span><br><span class="line">	minor = find_first_zero_bit(minors, N_SPI_MINORS);</span><br><span class="line">	<span class="keyword">if</span> (minor &lt; N_SPI_MINORS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">		spidev-&gt;devt = MKDEV(SPIDEV_MAJOR, minor);</span><br><span class="line">		dev = device_create(spidev_class, &amp;spi-&gt;dev, spidev-&gt;devt,</span><br><span class="line">				    spidev, <span class="string">&quot;spidev%d.%d&quot;</span>,</span><br><span class="line">				    spi-&gt;master-&gt;bus_num, spi-&gt;chip_select);</span><br><span class="line">		status = PTR_ERR_OR_ZERO(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;no minor number available!\n&quot;</span>);</span><br><span class="line">		status = -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">		set_bit(minor, minors);</span><br><span class="line">		list_add(&amp;spidev-&gt;device_entry, &amp;device_list);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;device_list_lock);</span><br><span class="line">	spidev-&gt;speed_hz = spi-&gt;max_speed_hz;</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">		spi_set_drvdata(spi, spidev);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kfree(spidev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>device_create</code>创建了<code>/dev/</code>下的<code>spidev</code>节点,主设备号<code>SPIDEV_MAJOR= 153</code>，如<code>spi总线0</code>上<code>cs1</code>设备，则设备名为<code>/dev/spidev0.1</code>，其他以此类推。</p>
<h4><span id="1-3-3-3-spidev-fops">1.3.3.3 spidev_fops</span><a href="#1-3-3-3-spidev-fops" class="header-anchor">#</a></h4><h5><span id="1-3-3-3-1-spidev-read">1.3.3.3.1 spidev_read</span><a href="#1-3-3-3-1-spidev-read" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spidev_read</span><br><span class="line">	-&gt;spidev_sync_read</span><br><span class="line">		-&gt;spidev_sync</span><br><span class="line">			-&gt;spi_sync</span><br></pre></td></tr></table></figure>

<h5><span id="1-3-3-3-2-spidev-write">1.3.3.3.2 spidev_write</span><a href="#1-3-3-3-2-spidev-write" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spidev_write</span><br><span class="line">	-&gt;spidev_sync_write</span><br><span class="line">		-&gt;spidev_sync</span><br><span class="line">			-&gt;spi_sync</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<p>构造<code>spi_message</code>,<code>spi_transfer</code>调用<code>spi_sync</code>进行数据传输。</p>
<h5><span id="1-3-3-3-3-spidev-ioctl">1.3.3.3.3 spidev_ioctl</span><a href="#1-3-3-3-3-spidev-ioctl" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">spidev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span>			retval = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line">	u32			tmp;</span><br><span class="line">	<span class="type">unsigned</span>		n_ioc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_ioc_transfer</span>	*<span class="title">ioc</span>;</span></span><br><span class="line">    <span class="comment">/* Check type and command number */</span></span><br><span class="line">    <span class="keyword">if</span> (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)</span><br><span class="line">        <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">    <span class="comment">/* guard against device removal before, or while,</span></span><br><span class="line"><span class="comment">     * we issue this ioctl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    spidev = filp-&gt;private_data;</span><br><span class="line">    spin_lock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line">    spi = spi_dev_get(spidev-&gt;spi);</span><br><span class="line">    spin_unlock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spi == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ESHUTDOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use the buffer lock here for triple duty:</span></span><br><span class="line"><span class="comment">     *  - prevent I/O (from us) so calling spi_setup() is safe;</span></span><br><span class="line"><span class="comment">     *  - prevent concurrent SPI_IOC_WR_* from morphing</span></span><br><span class="line"><span class="comment">     *    data fields while SPI_IOC_RD_* reads them;</span></span><br><span class="line"><span class="comment">     *  - SPI_IOC_MESSAGE needs the buffer locked &quot;normally&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_lock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">/* read requests */</span></span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MODE:</span><br><span class="line">        retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">                    (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MODE32:</span><br><span class="line">        retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">                    (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_LSB_FIRST:</span><br><span class="line">        retval = put_user((spi-&gt;mode &amp; SPI_LSB_FIRST) ?  <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_BITS_PER_WORD:</span><br><span class="line">        retval = put_user(spi-&gt;bits_per_word, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MAX_SPEED_HZ:</span><br><span class="line">        retval = put_user(spidev-&gt;speed_hz, (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write requests */</span></span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MODE:</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MODE32:</span><br><span class="line">        <span class="keyword">if</span> (cmd == SPI_IOC_WR_MODE)</span><br><span class="line">            retval = get_user(tmp, (u8 __user *)arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            retval = get_user(tmp, (u32 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span> =</span> spi-&gt;controller;</span><br><span class="line">            u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; ~SPI_MODE_MASK) &#123;</span><br><span class="line">                retval = -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ctlr-&gt;use_gpio_descriptors &amp;&amp; ctlr-&gt;cs_gpiods &amp;&amp;</span><br><span class="line">                ctlr-&gt;cs_gpiods[spi-&gt;chip_select])</span><br><span class="line">                tmp |= SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line">            tmp |= spi-&gt;mode &amp; ~SPI_MODE_MASK;</span><br><span class="line">            spi-&gt;mode = (u16)tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;mode = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;spi mode %x\n&quot;</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_LSB_FIRST:</span><br><span class="line">        retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp)</span><br><span class="line">                spi-&gt;mode |= SPI_LSB_FIRST;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                spi-&gt;mode &amp;= ~SPI_LSB_FIRST;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;mode = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%csb first\n&quot;</span>,</span><br><span class="line">                        tmp ? <span class="string">&#x27;l&#x27;</span> : <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_BITS_PER_WORD:</span><br><span class="line">        retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u8	save = spi-&gt;bits_per_word;</span><br><span class="line"></span><br><span class="line">            spi-&gt;bits_per_word = tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;bits_per_word = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d bits per word\n&quot;</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MAX_SPEED_HZ:</span><br><span class="line">        retval = get_user(tmp, (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u32	save = spi-&gt;max_speed_hz;</span><br><span class="line"></span><br><span class="line">            spi-&gt;max_speed_hz = tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">                spidev-&gt;speed_hz = tmp;</span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d Hz (max)\n&quot;</span>,</span><br><span class="line">                    spidev-&gt;speed_hz);</span><br><span class="line">            &#125;</span><br><span class="line">            spi-&gt;max_speed_hz = save;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* segmented and/or full-duplex I/O request */</span></span><br><span class="line">        <span class="comment">/* Check message and copy into scratch area */</span></span><br><span class="line">        ioc = spidev_get_ioc_message(cmd,</span><br><span class="line">                (<span class="keyword">struct</span> spi_ioc_transfer __user *)arg, &amp;n_ioc);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(ioc)) &#123;</span><br><span class="line">            retval = PTR_ERR(ioc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ioc)</span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">/* n_ioc is also 0 */</span></span><br><span class="line">        <span class="comment">/* translate to spi_message, execute */</span></span><br><span class="line">        retval = spidev_message(spidev, ioc, n_ioc);</span><br><span class="line">        kfree(ioc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">    spi_dev_put(spi);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<p>这些SPI_IOC命令就是一些设置速率参数，spi模式啊，然后就可以通过read,write操作<code>/dev/spidev%d.%d</code>设备了。</p>
<h3><span id="1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.4 使用SPI万能驱动oled举例</span><a href="#1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li" class="header-anchor">#</a></h3><h4><span id="1-3-4-1-spi-oled-yuan-li">1.3.4.1 spi oled原理</span><a href="#1-3-4-1-spi-oled-yuan-li" class="header-anchor">#</a></h4><p>见<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/#3-spi-luo-ji-shi-li">SPI-OLED显示面板介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15668520.html">S3c2440裸机-spi编程-2.OLED显示面板 - fuzidage - 博客园 (cnblogs.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15697593.html">S3c2440裸机-spi编程-3.gpio模拟spi驱动OLED - fuzidage - 博客园 (cnblogs.com)</a>。</p>
<h4><span id="1-3-4-2-spi-oled-c">1.3.4.2 spi_oled.c</span><a href="#1-3-4-2-spi-oled-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_spidev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dc_pin_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dc_pin_init</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// echo 509 &gt; /sys/class/gpio/export</span></span><br><span class="line">	<span class="comment">// echo out &gt; /sys/class/gpio/gpio509/direction	</span></span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">100</span>];</span><br><span class="line">	dc_pin_num = number;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %d &gt; /sys/class/gpio/export&quot;</span>, number);</span><br><span class="line">	system(cmd);</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo out &gt; /sys/class/gpio/gpio%d/direction&quot;</span>, number);</span><br><span class="line">	system(cmd);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_set_dc_pin</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* echo 1 &gt; /sys/class/gpio/gpio509/value</span></span><br><span class="line"><span class="comment">	 * echo 0 &gt; /sys/class/gpio/gpio509/value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %d &gt; /sys/class/gpio/gpio%d/value&quot;</span>, val, dc_pin_num);</span><br><span class="line">	system(cmd);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">spi_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd_spidev, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line">	spi_write_datas(buf, len);</span><br><span class="line">&#125;</span><br><span class="line">  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： oled_write_cmd</span></span><br><span class="line"><span class="comment">	 * 功能描述： oled向特定地址写入数据或者命令</span></span><br><span class="line"><span class="comment">	 * 输入参数：@uc_data :要写入的数据</span></span><br><span class="line"><span class="comment">	 			@uc_cmd:为1则表示写入数据，为0表示写入命令</span></span><br><span class="line"><span class="comment">	 * 输出参数：无</span></span><br><span class="line"><span class="comment">	 * 返 回 值： 无</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_cmd_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> uc_data,<span class="type">unsigned</span> <span class="type">char</span> uc_cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> uc_read=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(uc_cmd==<span class="number">0</span>)</span><br><span class="line">		oled_set_dc_pin(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line"></span><br><span class="line">	spi_write_datas(&amp;uc_data, <span class="number">1</span>);<span class="comment">//写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">oled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> uc_dev_id = <span class="number">0</span>;</span><br><span class="line">		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line">	oled_write_cmd_data(<span class="number">0xae</span>,OLED_CMD);<span class="comment">//关闭显示</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//设置 lower column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//设置 higher column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//设置 display start line</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//设置page address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x81</span>,OLED_CMD);<span class="comment">// contract control</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x66</span>,OLED_CMD);<span class="comment">//128</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa1</span>,OLED_CMD);<span class="comment">//设置 segment remap</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa6</span>,OLED_CMD);<span class="comment">//normal /reverse</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa8</span>,OLED_CMD);<span class="comment">//multiple ratio</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//duty = 1/64</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xc8</span>,OLED_CMD);<span class="comment">//com scan direction</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd3</span>,OLED_CMD);<span class="comment">//set displat offset</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd9</span>,OLED_CMD);<span class="comment">//ser pre-charge period</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x1f</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xda</span>,OLED_CMD);<span class="comment">//set com pins</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xdb</span>,OLED_CMD);<span class="comment">//set vcomh</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x8d</span>,OLED_CMD);<span class="comment">//set charge pump disable </span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xaf</span>,OLED_CMD);<span class="comment">//set dispkay on</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： oled_fill_data</span></span><br><span class="line"><span class="comment">	 * 功能描述： 整个屏幕显示填充某个固定数据</span></span><br><span class="line"><span class="comment">	 * 输入参数：@fill_Data：要填充的数据</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">oled_fill_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;<span class="number">8</span>;x++) &#123;</span><br><span class="line">		oled_write_cmd_data(<span class="number">0xb0</span>+x,OLED_CMD);		<span class="comment">//page0-page1</span></span><br><span class="line">		oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);		<span class="comment">//low column start address</span></span><br><span class="line">		oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);		<span class="comment">//high column start address	</span></span><br><span class="line">		<span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">128</span>;y++)</span><br><span class="line">			oled_write_cmd_data(fill_Data,OLED_DATA);<span class="comment">//填充数据				</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Clear</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        <span class="comment">//for (x = 0; x &lt; 128; x++)</span></span><br><span class="line">        <span class="comment">//    oled_write_cmd_data(0, OLED_DATA); /* 清零 */</span></span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： OLED_DIsp_All</span></span><br><span class="line"><span class="comment">	 * 功能描述： 整个屏幕显示全部点亮，可以用于检查坏点</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_All</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">128</span>; x++)</span><br><span class="line">			oled_write_cmd_data(<span class="number">0xff</span>, OLED_DATA); <span class="comment">/* 全点亮 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： OLED_DIsp_Set_Pos</span></span><br><span class="line"><span class="comment">	 * 功能描述：设置要显示的位置</span></span><br><span class="line"><span class="comment">	 * 输入参数：@ x ：要显示的column address</span></span><br><span class="line"><span class="comment">	 			@y :要显示的page address</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	oled_write_cmd_data(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	oled_write_cmd_data((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">	oled_write_cmd_data(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 得到字模 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 发给OLED */</span></span><br><span class="line">	OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">	<span class="comment">//	oled_write_cmd_data(dots[i], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">	OLED_DIsp_Set_Pos(x, y+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">		<span class="comment">//oled_write_cmd_data(dots[i+8], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">8</span>], <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_String</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[j])&#123;		</span><br><span class="line">		OLED_DIsp_Char(x, y, str[j]);<span class="comment">//显示单个字符</span></span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">127</span>)&#123;</span><br><span class="line">			x = <span class="number">0</span>;</span><br><span class="line">			y += <span class="number">2</span>;</span><br><span class="line">		&#125;<span class="comment">//移动显示位置</span></span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;wiki.100ask.net&quot;</span>);</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;book.100ask.net&quot;</span>);</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">4</span>, <span class="string">&quot;bbs.100ask.net&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* spi_oled /dev/spidevB.D &lt;DC_pin_number&gt; */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> dc_pin;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev/spidevB.D&gt; &lt;DC_pin_number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);<span class="comment">//B表示spi bus, D表示cs片选</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	fd_spidev = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_spidev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open %s err\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	dc_pin = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	dc_pin_init(dc_pin);</span><br><span class="line"> </span><br><span class="line">	oled_init();</span><br><span class="line">	OLED_DIsp_Clear();</span><br><span class="line">	OLED_DIsp_Test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi">1.3.4.2.1 用户态驱动分析</span><a href="#1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi" class="header-anchor">#</a></h5><p>有了spidev.c万能SPI从设备驱动，就不需要去写spi从设备驱动了，直接用户态去读写spidev即可。</p>
<ol>
<li><code>open(&quot;/dev/spi%d.%d&quot;, O_RDWR);</code>&#x2F;&#x2F;根据自己外设使用的spi bus和cs片选去设置</li>
<li>对外设oled进行初始化<code>D/C（data or cmd ）引脚</code>, 利用gpio子系统的命令去设置gpio模式为输出。</li>
<li>利用spi协议发送初始化序列：<ol>
<li><code>spi_write_datas</code>就是操作<code>spidev</code>，write数据到底层<code>spidev</code>，再调用对应的fops中的<code>spidev_write</code>，最终调用<code>spi_sync</code>传输数据。这里是每次传输1byte，把初始化序列利用spi协议写完。</li>
</ol>
</li>
<li>清屏并且测试<code>oled</code>显示字符。</li>
</ol>
<h3><span id="1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.5 不使用SPI万能驱动oled举例</span><a href="#1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li" class="header-anchor">#</a></h3><h4><span id="1-3-5-1-dts-miao-shu">1.3.5.1 dts描述</span><a href="#1-3-5-1-dts-miao-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi1 &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi1&gt;;</span><br><span class="line">    fsl,spi-num-chipselects = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    cs-gpios = &lt;&amp;gpio4 <span class="number">26</span> GPIO_ACTIVE_LOW&gt;, &lt;&amp;gpio4 <span class="number">24</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    oled: oled &#123;</span><br><span class="line">        compatible = <span class="string">&quot;100ask,oled&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        spi-max-frequency = &lt;<span class="number">10000000</span>&gt;;</span><br><span class="line">        dc-gpios = &lt;&amp;gpio4 <span class="number">20</span> GPIO_ACTIVE_HIGH&gt;; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spi1</code>下接了一个<code>spi oled</code>，修改对应dts文件，修改<code>ecspi1</code>节点，添加oled子节点。oled有一个<code>dc引脚</code>，叫做<code>data/cmd</code>引脚，选择是发送数据还是命令。参考spi oled原理。</p>
<h4><span id="1-3-5-2-oled-drv-c">1.3.5.2 oled_drv.c</span><a href="#1-3-5-2-oled-drv-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/acpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_INIT 			123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_SET_POS 		124</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//为0 表示命令，为1表示数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD 	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 	1</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">oled</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">dc_gpio</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dc_pin_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	gpiod_direction_output(dc_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_set_dc_pin</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">	gpiod_set_value(dc_gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spi_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	spi_write(oled, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_write_cmd_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> uc_data,<span class="type">unsigned</span> <span class="type">char</span> uc_cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(uc_cmd==<span class="number">0</span>)</span><br><span class="line">		oled_set_dc_pin(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line"></span><br><span class="line">	spi_write_datas(&amp;uc_data, <span class="number">1</span>);<span class="comment">//写入</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	oled_write_cmd_data(<span class="number">0xae</span>,OLED_CMD);<span class="comment">//关闭显示</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//设置 lower column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//设置 higher column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//设置 display start line</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//设置page address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x81</span>,OLED_CMD);<span class="comment">// contract control</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x66</span>,OLED_CMD);<span class="comment">//128</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa1</span>,OLED_CMD);<span class="comment">//设置 segment remap</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa6</span>,OLED_CMD);<span class="comment">//normal /reverse</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa8</span>,OLED_CMD);<span class="comment">//multiple ratio</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//duty = 1/64</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xc8</span>,OLED_CMD);<span class="comment">//com scan direction</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd3</span>,OLED_CMD);<span class="comment">//set displat offset</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd9</span>,OLED_CMD);<span class="comment">//ser pre-charge period</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x1f</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xda</span>,OLED_CMD);<span class="comment">//set com pins</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xdb</span>,OLED_CMD);<span class="comment">//set vcomh</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x8d</span>,OLED_CMD);<span class="comment">//set charge pump disable </span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xaf</span>,OLED_CMD);<span class="comment">//set dispkay on</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	oled_write_cmd_data(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	oled_write_cmd_data((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">	oled_write_cmd_data(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">spidev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="comment">/* 根据cmd操作硬件 */</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OLED_IOC_INIT: <span class="comment">/* init */</span></span><br><span class="line">		&#123;</span><br><span class="line">			dc_pin_init();</span><br><span class="line">			oled_init();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> OLED_IOC_SET_POS: <span class="comment">/* set pos */</span></span><br><span class="line">		&#123;</span><br><span class="line">			x = arg &amp; <span class="number">0xff</span>;</span><br><span class="line">			y = (arg &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">spidev_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *ker_buf;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	ker_buf = kmalloc(count, GFP_KERNEL);</span><br><span class="line">	err = copy_from_user(ker_buf, buf, count);</span><br><span class="line">	oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line">	spi_write_datas(ker_buf, count);</span><br><span class="line">	kfree(ker_buf);</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">spidev_fops</span> =</span> &#123;</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.write =	spidev_write,</span><br><span class="line">	.unlocked_ioctl = spidev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">spidev_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">spidev_dt_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;100ask,oled&quot;</span> &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	oled = spi;</span><br><span class="line"> </span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_oled&quot;</span>, &amp;spidev_fops);</span><br><span class="line">	spidev_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_oled&quot;</span>);</span><br><span class="line">	device_create(spidev_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_oled&quot;</span>);	</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 3. 获得GPIO引脚 */</span></span><br><span class="line">	dc_gpio = gpiod_get(&amp;spi-&gt;dev, <span class="string">&quot;dc&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">	gpiod_put(dc_gpio);</span><br><span class="line">	device_destroy(spidev_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(spidev_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;cumtchw_oled&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spidev_spi_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name =		<span class="string">&quot;cumtchw_spi_oled_drv&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(spidev_dt_ids),</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe =	spidev_probe,</span><br><span class="line">	.remove =	spidev_remove,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spidev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	status = spi_register_driver(&amp;spidev_spi_driver);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">spidev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	spi_unregister_driver(&amp;spidev_spi_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(spidev_init);</span><br><span class="line">module_exit(spidev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5><span id="1-3-5-2-1-qu-dong-fen-xi">1.3.5.2.1 驱动分析</span><a href="#1-3-5-2-1-qu-dong-fen-xi" class="header-anchor">#</a></h5><ol>
<li>调用<code>spi_register_driver</code>注册SPI从设备驱动，probe函数中利用标准字符设备驱动框架编写的驱动，注册字符设备，添加类。</li>
<li>当用户调用<code>open(&quot;/dev/100ask_oled&quot;)</code>后，就可以调用read,write函数读写oled。<ol>
<li>spidev_ioctl提供了2个ioctl命令，用来初始化oled和设置坐标位置。用<code>spi_write_datas</code>写入初始化序列，每次写1byte。</li>
<li><code>spi_write_datas</code>调用标准的SPI从设备驱动API(<code>spi_write</code>)传输数据。</li>
</ol>
</li>
<li>spi oled初始化完后就可以使用另一个<code>OLED_IOC_SET_POS</code> ioctl命令设置坐标位置。</li>
<li>调用spidev_write写入数据。</li>
</ol>
<h4><span id="1-3-5-3-spi-oled-c-ying-yong-ce-shi">1.3.5.3 spi_oled.c应用测试</span><a href="#1-3-5-3-spi-oled-c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_INIT 			123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_SET_POS 		124</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//为0 表示命令，为1表示数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD 	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 	1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_spidev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dc_pin_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd_spidev, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Clear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_All</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0xff</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	ioctl(fd_spidev, OLED_IOC_SET_POS, x  | (y &lt;&lt; <span class="number">8</span>));</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 得到字模 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 发给OLED */</span></span><br><span class="line">	OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">	<span class="comment">//	oled_write_cmd_data(dots[i], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">	OLED_DIsp_Set_Pos(x, y+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">		<span class="comment">//oled_write_cmd_data(dots[i+8], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">8</span>], <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_String</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[j]) &#123;		</span><br><span class="line">		OLED_DIsp_Char(x, y, str[j]);<span class="comment">//显示单个字符</span></span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">127</span>) &#123;</span><br><span class="line">			x = <span class="number">0</span>;</span><br><span class="line">			y += <span class="number">2</span>;</span><br><span class="line">		&#125;<span class="comment">//移动显示位置</span></span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Test</span><span class="params">(<span class="type">void</span>)</span> &#123; 	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;100ask test&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;	</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s /dev/cumtchw_oled\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	fd_spidev = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_spidev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open %s err\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd_spidev, OLED_IOC_INIT);</span><br><span class="line">	OLED_DIsp_Clear();</span><br><span class="line">	OLED_DIsp_Test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-spi-master-x2f-spi-controller">2.1 spi_master&#x2F;spi_controller</span><a href="#2-1-spi-master-x2f-spi-controller" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span>	<span class="comment">/* SPI设备的device数据结构 */</span></span><br><span class="line">	s16			bus_num;		<span class="comment">/* SPI总线序号 */</span></span><br><span class="line">	u16			num_chipselect;	<span class="comment">/* 片选信号数量 */</span></span><br><span class="line">	u16			dma_alignment;	<span class="comment">/* SPI控制器DMA缓冲区对齐定义 */</span></span><br><span class="line">	u16			mode_bits;		<span class="comment">/* 工作模式位，由驱动定义 */</span></span><br><span class="line">	u32			min_speed_hz;	<span class="comment">/* 最小速度 */</span></span><br><span class="line">	u32			max_speed_hz;	<span class="comment">/* 最小速度 */</span></span><br><span class="line">	u16			flags;			<span class="comment">/* 限制条件标志 */</span></span><br><span class="line">	<span class="type">int</span>			(*setup)(<span class="keyword">struct</span> spi_device *spi);   <span class="comment">/* 设置SPI设备的工作参数 */</span></span><br><span class="line">	<span class="type">int</span>			(*transfer)(<span class="keyword">struct</span> spi_device *spi,	<span class="comment">/* SPI发送函数1 */</span></span><br><span class="line">						<span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line">	<span class="type">void</span>		(*cleanup)(<span class="keyword">struct</span> spi_device *spi);	<span class="comment">/* SPI清除函数，当spi_master被释放时调用 */</span></span><br><span class="line">	<span class="type">int</span> (*transfer_one_message)(<span class="keyword">struct</span> spi_master *master,	<span class="comment">/* SPI发送函数2 */</span></span><br><span class="line">	<span class="type">int</span> (*transfer_one)(<span class="keyword">struct</span> spi_master *master, <span class="keyword">struct</span> spi_device *spi,<span class="comment">/* SPI发送函数3 */</span></span><br><span class="line">			    <span class="keyword">struct</span> spi_transfer *transfer);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct <code>spi_master</code>描述一个spi控制器，包扩spi控制器的属性描述信息，spi的一些操作回调函数，如<code>transfer</code>，<code>setup</code>。</p>
<h2><span id="2-2-spi-driver">2.2 spi_driver</span><a href="#2-2-spi-driver" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*probe)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">int</span>			(*remove)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">void</span>			(*shutdown)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span>	<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来描述一个spi从设备驱动。用来和spi从设备匹配。</p>
<h2><span id="2-3-spi-device">2.3 spi_device</span><a href="#2-3-spi-device" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">controller</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">master</span>;</span>	<span class="comment">/* compatibility layer */</span></span><br><span class="line">	u32			max_speed_hz;</span><br><span class="line">	u8			chip_select;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPHA	0x01			<span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPOL	0x02			<span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_0	(0|0)			<span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_1	(0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_2	(SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_HIGH	0x04			<span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LSB_FIRST	0x08			<span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE	0x10			<span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LOOP	0x20			<span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NO_CS	0x40			<span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_READY	0x80			<span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_DUAL	0x100			<span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_QUAD	0x200			<span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_DUAL	0x400			<span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_QUAD	0x800			<span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_WORD	0x1000			<span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_OCTAL	0x2000			<span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_OCTAL	0x4000			<span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE_HIZ	0x8000			<span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line">	<span class="type">int</span>			irq;</span><br><span class="line">	<span class="type">void</span>			*controller_state;</span><br><span class="line">	<span class="type">void</span>			*controller_data;</span><br><span class="line">	<span class="type">char</span>			modalias[SPI_NAME_SIZE];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*driver_override;</span><br><span class="line">	<span class="type">int</span>			cs_gpio;	<span class="comment">/* LEGACY: chip select gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">cs_gpiod</span>;</span>	<span class="comment">/* chip select gpio desc */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span> <span class="comment">/* inter-word delay */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来描述一个spi从设备。用来和spi从设备驱动匹配。</p>
<h2><span id="2-4-spi-message-x2f-spi-transfer">2.4 spi_message&#x2F;spi_transfer</span><a href="#2-4-spi-message-x2f-spi-transfer" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span>	*tx_buf;</span><br><span class="line">	<span class="type">void</span>		*rx_buf;</span><br><span class="line">	<span class="type">unsigned</span>	len;</span><br><span class="line">	...</span><br><span class="line">	u8		bits_per_word;</span><br><span class="line">	u16		delay_usecs;</span><br><span class="line">	u32		speed_hz;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">transfers</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">void</span>			(*complete)(<span class="type">void</span> *context);</span><br><span class="line">	<span class="type">void</span>			*context;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">queue</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spi_message</code>是发起一次数据传输，里面的<code>transfers</code>构成基本输入输出数据，通过<code>spi_sync</code>函数或<code>spi_async</code>函数发送。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0i1u4bo0000jcufa3h637lq" data-title="字符设备驱动-SPI子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-I2C子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T08:23:34.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</a></li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</a><ul>
<li><a href="#2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</a></li>
<li><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</a></li>
</ul>
</li>
<li><a href="#2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</a><ul>
<li><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</a></li>
<li><a href="#2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</a><ul>
<li><a href="#2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</a></li>
</ul>
</li>
<li><a href="#3-i2c-zi-xi-tong-api">3 I2C子系统API</a><ul>
<li><a href="#3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</a><ul>
<li><a href="#3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</a></li>
<li><a href="#3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</a></li>
</ul>
</li>
<li><a href="#3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</a><ul>
<li><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</a></li>
<li><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</a></li>
<li><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</a></li>
<li><a href="#3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</a><ul>
<li><a href="#3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</a></li>
<li><a href="#3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</a></li>
<li><a href="#3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</a><ul>
<li><a href="#4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</a><ul>
<li><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</a></li>
</ul>
</li>
<li><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</a><ul>
<li><a href="#4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</a><ul>
<li><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</a></li>
<li><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</a></li>
</ul>
</li>
<li><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</a><ul>
<li><a href="#4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</a></li>
<li><a href="#4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</a><ul>
<li><a href="#4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</a><ul>
<li><a href="#4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</a><ul>
<li><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</a></li>
<li><a href="#4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</a></li>
</ul>
</li>
<li><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</a><ul>
<li><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</a></li>
<li><a href="#4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</a></li>
<li><a href="#4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</a></li>
<li><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</span><a href="#1-linux-i2c-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>由上到下分为3层结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i2c设备驱动层: 作为client使用者使用i2c子系统。提供操作接口给应用层，与应用层交互数据。</span><br><span class="line"></span><br><span class="line">I2C核心层：提供transfer send recv函数。把client设备挂载到I2C总线上；</span><br><span class="line">    维护i2c driver和i2c client 链表 ，实现i2c_client和i2c_driver匹配。</span><br><span class="line"></span><br><span class="line">I2C适配器层：底层SOC I2C控制器驱动，实现i2c时序，实现i2c总线发送和接收数据的方法。</span><br></pre></td></tr></table></figure>

<p>目录结构位于drivers&#x2F;i2c：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/robin.lee/zip/A2/linux_5.10/drivers/i2c$ <span class="built_in">ls</span></span><br><span class="line">algos            i2c-core-acpi.c  i2c-core-of.c     i2c-dev.c           i2c-slave-testunit.c  Kconfig</span><br><span class="line">busses           i2c-core-base.c  i2c-core-slave.c  i2c-mux.c           i2c-smbus.c           Makefile</span><br><span class="line">i2c-boardinfo.c  i2c-core.h       i2c-core-smbus.c  i2c-slave-eeprom.c  i2c-stub.c            muxes</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</span><a href="#2-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</span><a href="#2-1-1-i2c-adapter-kong-zhi-qi" class="header-anchor">#</a></h3><p> I2C 适配器，也就是 SOC 的 I2C 控制器。<code>i2c_adapter</code> 结构体定义在<code> include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="type">int</span> nr;   <span class="comment">//总线的编号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>适配器的类类型，在一些口I2C设备驱动中会检查该成员，以判断设备能否被该适配器操作</td>
</tr>
<tr>
<td>algo</td>
<td>指向该造配器通信方法描述结构的指针，就是该适配器具体操作I2C控制器的函数</td>
</tr>
<tr>
<td>algo_data</td>
<td>指向通信方法数据的指针，该成员不会被I2C核心层修改，仅供具体的 i2c_algorithm使用</td>
</tr>
<tr>
<td>timeout</td>
<td>传输超时时间</td>
</tr>
<tr>
<td>retries</td>
<td>传输超时的重试次数</td>
</tr>
<tr>
<td>name</td>
<td>适配器名称，该名称可以通过<code>sys/bus/i2c/devices/i2c-x/name</code> (x&#x3D;0,1,2 … ）来访问</td>
</tr>
<tr>
<td>nr</td>
<td>总线编号（也是适配器编号），同时对应设备节点<code>／dev/i2c-x</code> (x&#x3D;0,1,2 …）中的 x</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</span><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa" class="header-anchor">#</a></h3><p>对于一个 I2C 适配器，肯定要对外提供读 写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。<code>i2c_algorithm </code>就是 I2C 适 配器与 IIC 设备进行通信的方法。包括<code>transfer send recv</code>等函数<code>。i2c_algorithm </code>结构体定义在 <code>include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>master_xfer </code>就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之 间的通信。 用于产生I2C访问周期需要的信号， 以<code>i2c_msg</code>为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<p><code>smbus_xfer</code> 是 SMBUS 总线协议的传输函数。</p>
<p><code>functionality</code>：查看适配的能力。这些功能都是以宏定义的方式表示，定义在<code>include/linux/i2c.h</code>中，以<code>I2C_FUNC</code>开头：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To determine what functionality is present */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_10BIT_ADDR		0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_IGNORE_NAK etc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_NOSTART		0x00000010 /* I2C_M_NOSTART */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SLAVE			0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_HOST_NOTIFY	0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br></pre></td></tr></table></figure>



<h2><span id="2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</span><a href="#2-2-ke-hu-duan-xiang-guan" class="header-anchor">#</a></h2><p>i2c 设备(client使用者)驱动要使用<code>i2c_driver</code> 和<code>i2c_client</code>数据结构并填充i2c_driver中的成员函数。</p>
<h3><span id="2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</span><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong" class="header-anchor">#</a></h3><p>代表一个i2c使用者设备驱动。结构体定义在 include&#x2F;linux&#x2F;i2c.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);<span class="comment">//类似于ioctl 的命令控制函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> </span><br><span class="line">	<span class="type">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attach_adapter</td>
<td>依附i2c_adapter的函数指针</td>
</tr>
<tr>
<td>detach_adapter</td>
<td>脱离i2c_adapter的函数指针</td>
</tr>
<tr>
<td>probe</td>
<td>设备和驱动匹配时调用</td>
</tr>
<tr>
<td>driver</td>
<td>在注册i2c_driver对象时，i2c_driver-&gt;driver的总线类型被指定为<code>i2c_bus_type</code></td>
</tr>
<tr>
<td>id_table</td>
<td>匹配列表，驱动和设备匹配时会用到</td>
</tr>
<tr>
<td>detect</td>
<td>基于设备探测机制实现的 12C 设备驱动：设备探测的回调函数</td>
</tr>
<tr>
<td>address_list</td>
<td>设备探测的地址范围</td>
</tr>
<tr>
<td>clients</td>
<td>探测到的设备列表</td>
</tr>
</tbody></table>
<p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;rtc-ds1307&quot;</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</span><a href="#2-2-2-i2c-client-cong-she-bei" class="header-anchor">#</a></h3><p>代表一个连接到<code>i2c_bus</code>总线上的从设备，结构体定义在 <code>include/linux/i2c.h</code>。描述i2c从设备的i2c相关硬件信息。 一个i2c_driver可以支持多个同类型的i2c_client。i2c_client一般描述再设备树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>&#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> flags;   <span class="comment">//描述从设备的一些特性，如I2C_CLIENT_TEN---使用的10位地址</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> addr;   <span class="comment">//设备的i2c地址，7位地址用低7位，10位地址用低10位。</span></span><br><span class="line"> 	<span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line"></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>   <span class="comment">//所属的适配器i2c_adapter,挂载在哪条i2c物理总线上</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>  *<span class="title">driver</span>;</span>    <span class="comment">//匹配成功的i2c_driver</span></span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</span><a href="#2-2-2-1-i2c-board-info" class="header-anchor">#</a></h4><p>也是描述从设备i2c硬件属性。通常情况下先填充i2c_board_info对象的成员，然后去初始化i2c_client对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> type[I2C_NAME_SIZE];<span class="comment">//名字，驱动层和设备层匹配参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//设备地址位数，一般不填或填0表示7位地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">//IIC设备地址</span></span><br><span class="line">    <span class="type">void</span> *platform_data;<span class="comment">//私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> irq;<span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</span><a href="#2-3-i2c-msg-xiao-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* 从机在I2C总线上的地址*/</span></span><br><span class="line">	__u16 flags;	<span class="comment">/* 消息特征的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的宏定义就是消息特征的标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* 消息数据长度，单位是字节 */</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* 指向存放消息数据的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息。</p>
<h1><span id="3-i2c-zi-xi-tong-api">3 I2C子系统API</span><a href="#3-i2c-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</span><a href="#3-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</span><a href="#3-1-1-zhu-ce-kong-zhi-qi" class="header-anchor">#</a></h3><p>通过<code>i2c_add_numbered_adapter</code>或 <code>i2c_add_adapter</code> 这两个函数向系统注册设置好的 i2c_adapter。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter 使用静态总线号。</p>
<h3><span id="3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</span><a href="#3-1-2-xie-zai-kong-zhi-qi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</span><a href="#3-2-ke-hu-duan-she-bei-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</span><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">i2c_register_driver</span>(<span class="params"><span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver</span>)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver);</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</span><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</span><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong" class="header-anchor">#</a></h3><p>在编写从设备驱动时为了方便也可以直接调用<code>module_i2c_driver</code>完成i2c驱动的<code>module_init</code>。或者使用<code>builtin_i2c_driver</code>完成i2c驱动的<code>device_initcall</code>。两者区别一个是编译成内核模块，一个是编译进内核镜像。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_init(__driver<span class="meta">##_init); \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit __driver<span class="meta">##_exit(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	__unregister(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_exit(__driver<span class="meta">##_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * builtin_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in init and have no exit. This eliminates some boilerplate.</span></span><br><span class="line"><span class="comment"> * Each driver may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * device_initcall (or in some cases, the legacy __initcall).  This is</span></span><br><span class="line"><span class="comment"> * meant to be a direct parallel of module_driver() above but without</span></span><br><span class="line"><span class="comment"> * the __exit stuff that is not used for builtin cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> builtin_driver(__driver, __register, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">device_initcall(__driver<span class="meta">##_init);</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</span><a href="#3-2-4-shu-ju-chuan-shu" class="header-anchor">#</a></h3><h4><span id="3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</span><a href="#3-2-4-1-i2c-transfer" class="header-anchor">#</a></h4><p>发送或接收指定字节数的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</span><a href="#3-2-4-2-i2c-master-recv" class="header-anchor">#</a></h4><p>接收指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</span><a href="#3-2-4-3-i2c-master-send" class="header-anchor">#</a></h4><p>发送指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</span><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</span><a href="#4-1-he-xin-core-ceng-zhu-ce" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i2c-core.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,	<span class="comment">//总线上驱动和设备的匹配函数</span></span><br><span class="line">	.probe		= i2c_device_probe,	<span class="comment">//总线上设备和驱动匹配时调用</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">	.pm		= &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">dummy_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;dummy&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">dummy_driver</span> =</span> &#123;</span><br><span class="line">	.driver.name	= <span class="string">&quot;dummy&quot;</span>,</span><br><span class="line">	.probe		= dummy_probe,</span><br><span class="line">	.remove		= dummy_remove,</span><br><span class="line">	.id_table	= dummy_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="comment">//注册I2C总线</span></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;	</span><br><span class="line">	<span class="comment">//向I2C总线注册一个名字为dummy的驱动，这个驱动没什么实际的功能，空实现的驱动</span></span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">class_err:</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">i2c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//删除dummy驱动</span></span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="comment">//卸载I2C总线</span></span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must initialize early, because some subsystems register i2c drivers</span></span><br><span class="line"><span class="comment"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到内核启动阶段就调用i2c_init 注册了I2C总线和注册了I2C设备驱动<code>dummy_driver</code>；</p>
<h3><span id="4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</span><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="title function_">i2c_match_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	driver = to_i2c_driver(drv);</span><br><span class="line">	<span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向I2C总线注册I2C驱动或者I2C设备时，会逐一将I2C驱动的名字和I2C设备的名字进行匹配，如果匹配上则调用I2C总线的probe方法；</p>
<p>I2C总线的probe方法就是进一步调用i2c_driver的probe方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C设备结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C驱动结构体</span></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 把I2C设备驱动和I2C设备绑定，将来可以互相查找到对方</span></span><br><span class="line">	client-&gt;driver = driver;</span><br><span class="line">	<span class="keyword">if</span> (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">					client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用I2C驱动的probe函数</span></span><br><span class="line">	status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		client-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		i2c_set_clientdata(client, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</span><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</span><a href="#4-2-1-gua-pei-qi-zhu-ce" class="header-anchor">#</a></h3><h4><span id="4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</span><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu" class="header-anchor">#</a></h4><p>以nxp的imx6ull芯片为例，在<code>imx6ull.dtsi</code>文件中找到 I2C1 控制器节点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1节点的compatible属性值有两个：<code>fsl,imx6ul-i2c</code>和<code>fsl,imx21-i2c</code>，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件为<code>drivers/i2c/busses/i2c-imx.c</code>。</p>
<h4><span id="4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</span><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>I2C 适配器驱动也是使用标准的 platform 驱动框架。<code>compatible</code> 属性匹配成功后就会调用probe函数如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.1.png" alt="image"></p>
<details>
<summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_hwdata</span> *<span class="title">match</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	match = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (match)</span><br><span class="line">		i2c_imx-&gt;hwdata = match;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line">	ACPI_COMPANION_SET(&amp;i2c_imx-&gt;adapter.dev, ACPI_COMPANION(&amp;pdev-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get I2C clock */</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(&amp;pdev-&gt;dev, PTR_ERR(i2c_imx-&gt;clk),</span><br><span class="line">				     <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init queue */</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up adapter data */</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up platform driver data */</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, I2C_PM_TIMEOUT);</span><br><span class="line">	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Request IRQ */</span></span><br><span class="line">	ret = request_threaded_irq(irq, i2c_imx_isr, <span class="literal">NULL</span>, IRQF_SHARED,</span><br><span class="line">				   pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up clock divider */</span></span><br><span class="line">	i2c_imx-&gt;bitrate = I2C_MAX_STANDARD_MODE_FREQ;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line">	i2c_imx-&gt;clk_change_nb.notifier_call = i2c_imx_clk_notifier_call;</span><br><span class="line">	clk_notifier_register(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	i2c_imx_set_clk(i2c_imx, clk_get_rate(i2c_imx-&gt;clk));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init optional bus recovery function */</span></span><br><span class="line">	ret = i2c_imx_init_recovery_info(i2c_imx, pdev);</span><br><span class="line">	<span class="comment">/* Give it another chance if pinctrl used is not ready yet */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add I2C adapter */</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	pm_runtime_mark_last_busy(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init DMA config if supported */</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_notifier_unregister:</span><br><span class="line">	clk_notifier_unregister(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	free_irq(irq, i2c_imx);</span><br><span class="line">rpm_disable:</span><br><span class="line">	pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ol>
<li><p><code>platform_get_irq</code> 函数获取中断号。</p>
</li>
<li><p><code>platform_get_resource </code>函数从设备树中获取 I2C1 控制器寄存器物理基 地址，也就是 <code>0X021A0000</code>。使用 <code>devm_ioremap_resource </code>函数对其进 行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p>
</li>
<li><p>使用 <code>imx_i2c_struct </code>结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使 用 <code>devm_kzalloc</code> 函数来申请内存。</p>
</li>
<li><p>初始化<code>i2c_adapter</code>。设置i2c_adapter 的algo成员变量为<code>i2c_imx_algo</code>， 也就是设置<code> i2c_algorithm</code>。</p>
</li>
<li><p>开启i2c时钟。</p>
</li>
<li><p>注册 I2C 控制器中断，中断服务函数为<code> i2c_imx_isr</code>。</p>
</li>
<li><p>设置 I2C 频率默认为 <code>IMX_I2C_BIT_RATE=100KHz</code>，如果设备树节点设 置了<code>“clock-frequency”</code>属性的话 I2C 频率就使用 <code>clock-frequency</code> 属性值。</p>
</li>
<li><p>设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image-20240825172735043"></p>
</li>
<li><p>调用 <strong>i2c_add_numbered_adapter</strong> 函数向 Linux 内核注册 i2c_adapter。</p>
</li>
</ol>
<h3><span id="4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</span><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">    .master_xfer = i2c_imx_xfer,</span><br><span class="line">    .functionality = i2c_imx_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</span><a href="#4-2-2-1-i2c-imx-func" class="header-anchor">#</a></h4><p><code>functionality</code>用于返回此I2C适配器支持什么样的通信协议， 在这里<code> functionality</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">i2c_imx_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</span><a href="#4-2-2-2-i2c-imx-xfer" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = pm_runtime_get_sync(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">false</span>);</span><br><span class="line">	pm_runtime_mark_last_busy(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	pm_runtime_put_autosuspend(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_atomic</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = clk_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">true</span>);</span><br><span class="line">	clk_disable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</span><a href="#4-2-2-2-1-i2c-imx-xfer-common" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_msg *msgs,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> num, <span class="type">bool</span> atomic)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start I2C transfer */</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">	<span class="keyword">if</span> (result) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Bus recovery uses gpiod_get_value_cansleep() which is not</span></span><br><span class="line"><span class="comment">		 * allowed within atomic context.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!atomic &amp;&amp; i2c_imx-&gt;adapter.bus_recovery_info) &#123;</span><br><span class="line">			i2c_recover_bus(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">			result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line">	<span class="comment">/* read/write data */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);</span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>, atomic);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);</span><br><span class="line">		<span class="comment">/* write/read data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_DEBUG_BUS</span></span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2CR_IEN ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_IIEN ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_MSTA ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_MTX ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_TXAK ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_RSTA ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2SR_ICF ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAAS ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_IBB ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAL ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_SRW ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IIF ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_RXAK ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg, atomic);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!atomic &amp;&amp;</span><br><span class="line">			    i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i], atomic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">/* Stop I2C transfer */</span></span><br><span class="line">	i2c_imx_stop(i2c_imx, atomic);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,</span><br><span class="line">		(result &lt; <span class="number">0</span>) ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;success msg&quot;</span>,</span><br><span class="line">			(result &lt; <span class="number">0</span>) ? result : num);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用<code>i2c_imx_start</code>函数开启 I2C 通信。</li>
<li>读数据的话就调用 <code>i2c_imx_read</code> 函数。</li>
<li>向 I2C 设备写数据，如果要用 DMA 的话就使用<code> i2c_imx_dma_write</code> 函数来 完成写数据。如果不使用 DMA 的话就使用 <code>i2c_imx_write</code> 函数完成写数据。</li>
<li>I2C 通信完成以后调用<code>i2c_imx_stop</code>函数停止 I2C 通信。</li>
</ol>
<p><code>i2c_imx_start</code>、<code>i2c_imx_read</code>、<code>i2c_imx_write</code> 和 <code>i2c_imx_stop</code> 这些函数就是 I2C 寄存器的具体操作函数，按照<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15384523.html">i2c协议</a>。</p>
<h2><span id="4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</span><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</span><a href="#4-3-1-i2c-cong-she-bei-miao-shu" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</span><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu" class="header-anchor">#</a></h4><p>在未使用设备树的时候需要在 BSP 里面使用<code>i2c_board_info</code>结构体来描 述一个具体的 I2C 设备。</p>
<p>举个例子，<code>arch/arm/mach-imx/mach-mx27_3ds.c</code>， <code>OV2640 摄像头</code>使用的 I2C 设备信息描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">mx27_3ds_i2c_camera</span> =</span> &#123;</span><br><span class="line">	I2C_BOARD_INFO(<span class="string">&quot;ov2640&quot;</span>, <span class="number">0x30</span>),</span><br><span class="line">&#125;;<span class="comment">//从设备OV2640 的名字和i2c地址</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</span><a href="#4-3-1-2-shi-yong-dts-miao-shu" class="header-anchor">#</a></h4><p>比如NXP 官方的 EVK 开发 板在<code> I2C1</code> 上接了 <code>mag3110 </code>这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然 后在这个子节点内描述 mag3110 这个i2c外设的相关信息。打开 <code>imx6ull-14x14-evk.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点 是 <code>compatible </code>属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</p>
<h3><span id="4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</span><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</span><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi" class="header-anchor">#</a></h4><p>AP3216C是一个三合一环境传感器，包含<code>环境光强度(ALS)、接近距离(PS)和红外线强度(IR)</code>这 三个环境参数检测。接开发板子的<code>i2c1</code>。因此用这个外设作为i2c从设备来举例。</p>
<p>AP3216C 的特点 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. I2C 接口，快速模式下波特率可以到 400Kbit/S</span><br><span class="line">2. 多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等。</span><br><span class="line">3. 内建温度补偿电路。</span><br><span class="line">4. 宽工作温度范围(-30°C ~ +80°C)。</span><br><span class="line">5. 超小封装，4.1mm x 2.4mm x 1.35mm</span><br><span class="line">6. 环境光传感器具有 16 位分辨率。</span><br><span class="line">7. 接近传感器和红外传感器具有 10 位分辨率</span><br></pre></td></tr></table></figure>

<p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</span><a href="#4-3-2-2-dts-she-zhi" class="header-anchor">#</a></h4><p>打开 <code>imx6ull-alientek-emmc.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1使用<code>pinctrl子系统</code>配置了iomux属性。<code>pinctrl_i2c1</code> 就是 I2C1 的 IO 节点，这里将<code> UART4_TXD</code> 和 <code>UART4_RXD </code>这两个 IO 分别 复用为<code> I2C1_SCL</code> 和<code> I2C1_SDA</code>，电气属性都设置为 <code>0x4001b8b0</code>。</p>
<p>默认i2c1 节点下并不是对应 <code>ap3216c</code> 从设备，而是<code>mag3110</code>。修改dts如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ap3216c </code>子节点，@后面的<code>“1e”</code>是 ap3216c 的<code>器件地址</code>。</p>
<p>reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 <code>0x1e</code>。</p>
<p>修改编译启动linux，可以看到<code>/sys/bus/i2c/devices </code>目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在 <code>/sys/bus/i2c/devices </code>目录下看到一个名为<code>“0-001e”</code>的子目录：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p><code>“0-001e”</code>就是 ap3216c 的设备目录，<code>“1e”</code>就是 ap3216c 器件地址。进入<code> 0-001e</code> 目录，可以看到<code>“name”</code>文件，name 问价就保存着此设备名字，在这里就是<code>“ap3216c”</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</span><a href="#4-3-2-3-ap3216c-qu-dong-shi-li" class="header-anchor">#</a></h4><p><code>ap3216creg.h</code>定义<code>AP3216C 的寄存器</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AP3216C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ADDR    	0X1E	<span class="comment">/* AP3216C器件地址  */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_SYSTEMCONG	0x00	<span class="comment">/* 配置寄存器       */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTSTATUS	0X01	<span class="comment">/* 中断状态寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTCLEAR	0X02	<span class="comment">/* 中断清除寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATALOW	0x0A	<span class="comment">/* IR数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATAHIGH	0x0B	<span class="comment">/* IR数据高字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATALOW	0x0C	<span class="comment">/* ALS数据低字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATAHIGH	0X0D	<span class="comment">/* ALS数据高字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATALOW	0X0E	<span class="comment">/* PS数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATAHIGH	0X0F	<span class="comment">/* PS数据高字节     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ap3216c.c:</p>
<details>     <summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME	<span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;			<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;	<span class="comment">/* 私有数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;		<span class="comment">/* 三个光传感器数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;			<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;			<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;				<span class="comment">/* reg长度*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;		<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;		<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;				<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;			<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">		</span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_read_byte_data(client, reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ap3216c_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)	</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) 	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ir = <span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取IR传感器的数据*/</span></span><br><span class="line">		dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>); 			</span><br><span class="line">	</span><br><span class="line">	dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* 读取ALS传感器的数据*/</span>  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>)	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ps = <span class="number">0</span>;    													</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取PS传感器的数据    */</span></span><br><span class="line">		dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">	<span class="comment">/* 初始化AP3216C */</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);<span class="comment">/* 复位AP3216C */</span></span><br><span class="line">	mdelay(<span class="number">50</span>);	<span class="comment">/* AP3216C复位最少10ms 	*/</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0X03</span>);<span class="comment">/* 开启ALS、PS+IR */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">	<span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">	ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = ap3216c_open,</span><br><span class="line">	.read = ap3216c_read,</span><br><span class="line">	.release = ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">		ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">		ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">	cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line">	ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid,</span><br><span class="line">                                      <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">	unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line">	device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">	class_destroy(ap3216cdev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">	.probe = ap3216c_probe,</span><br><span class="line">	.remove = ap3216c_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">		   	.of_match_table = ap3216c_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">module_i2c_driver(ap3216c_driver);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</details>

<ol>
<li>典型的i2c驱动框架编写的从设备驱动示例，<code>i2c_add_driver/i2c_del_driver</code>添加和删除从设备驱动。</li>
<li><code>ap3216c_of_match</code>中<code>compatible</code>匹配上，执行<code>ap3216c_probe</code>，把从设备ap3216c按照字符设备框架构造驱动。</li>
<li><code>ap3216cdev.private_data = client</code>， <code>private_data </code>成员变量用于存放 <code>ap3216c </code>对 应的 <code>i2c_client</code>。</li>
<li><code>ap3216c_open</code>初始化<code>ap3216c</code>。</li>
<li>传感器数据获取</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ap3216c_read</span><br><span class="line">   	ap3216c_readdata<span class="comment">//读取数据6字节</span></span><br><span class="line">   		ap3216c_read_reg<span class="comment">//读取一个字节</span></span><br><span class="line">   			ap3216c_read_regs<span class="comment">//构造i2c_msg[2]调用i2c_transfer获取1个字节传感器数据</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>ap3216c_write_reg</code>调用<code>ap3216c_write_regs</code>再调用<code>i2c_transfer</code>写入数据到指定地址寄存器。</li>
</ol>
<h4><span id="4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</span><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> databuf[<span class="number">3</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			ir =  databuf[<span class="number">0</span>]; 	<span class="comment">/* ir传感器数据 */</span></span><br><span class="line">			als = databuf[<span class="number">1</span>]; 	<span class="comment">/* als传感器数据 */</span></span><br><span class="line">			ps =  databuf[<span class="number">2</span>]; 	<span class="comment">/* ps传感器数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">200000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行程序如下：</span><br><span class="line">./a.out /dev/ap3216c</span><br></pre></td></tr></table></figure>

<p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14l004bdsuffrq2di67" data-title="字符设备驱动-I2C子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-内核led子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T09:01:56.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</a><ul>
<li><a href="#1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</a></li>
<li><a href="#1-2-jie-gou-ti-miao-shu">1.2 结构体描述</a><ul>
<li><a href="#1-2-1-led-classdev">1.2.1 led_classdev</a></li>
<li><a href="#1-2-2-gpio-led">1.2.2 gpio_led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-led-qu-dong-shi-neng">2 LED 驱动使能</a></li>
<li><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</a><ul>
<li><a href="#3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</a><ul>
<li><a href="#3-1-1-create-gpio-led">3.1.1 create_gpio_led</a></li>
<li><a href="#3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</a><ul>
<li><a href="#4-1-dts-bian-xie">4.1 dts编写</a></li>
<li><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</a></li>
</ul>
</li>
<li><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</a><ul>
<li><a href="#5-1-dian-liang-led">5.1 点亮 LED</a></li>
<li><a href="#5-2-shan-shuo">5.2 闪烁</a></li>
<li><a href="#5-3-guan-bi-led">5.3 关闭 LED</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</span><a href="#1-led-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>用来管理控制板子的led灯，比如系统心跳灯，普通的硬盘指示灯光，颜色灯，休眠唤醒灯等等。</p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>led 子系统相关描述可在内核源码 <code>Documentation/leds/leds-class.txt </code>了解。</p>
<p>led 子系统是一个简单的 Linux 子系统 ，在目录 <code>/sys/class/leds</code> 下展示该子系统设备，每个设备都有自己的属性：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brightness：设置 LED 亮度，范围 <span class="number">0</span> ~ max_brightness</span><br><span class="line">max_brightness：最大亮度（<span class="number">255</span> 或其他数字）</span><br><span class="line">trigger：触发方式，如 heartbeat、mmc0、backlight、gpio</span><br><span class="line">delay_off、delay_on：trigger为timer时，LED亮灭的时间，单位ms</span><br></pre></td></tr></table></figure>

<p><code>kernel/include/linux/leds.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span> &#123;</span></span><br><span class="line">	LED_OFF  = <span class="number">0</span>,    <span class="comment">//全暗</span></span><br><span class="line">	LED_HALF = <span class="number">127</span>,  <span class="comment">//一半亮度</span></span><br><span class="line">	LED_FULL = <span class="number">255</span>,  <span class="comment">//最大亮度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</span><a href="#1-1-dai-ma-kuang-jia-fen-xi" class="header-anchor">#</a></h2><p><code>led-class.c</code> (led 子系统框架的入口)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有 LED 设备，为 LED 设备提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_classdev_register()</span><br><span class="line">devm_led_classdev_register()</span><br><span class="line"></span><br><span class="line">注销操作函数:</span><br><span class="line">led_classdev_unregister()</span><br><span class="line">devm_led_classdev_unregister();</span><br><span class="line"></span><br><span class="line">电源管理的休眠和恢复操作函数: </span><br><span class="line">led_classdev_suspend()</span><br><span class="line">led_classdev_resume();</span><br><span class="line"></span><br><span class="line">用户态操作接口:brightness 、max_brightness</span><br></pre></td></tr></table></figure>
<p><code>led-core.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象出 LED 操作逻辑，封装成函数导出，供其它文件使用:</span><br><span class="line"></span><br><span class="line">led_init_core(): 核心初始化;</span><br><span class="line">led_blink_set(): 设置led闪烁时间:</span><br><span class="line">led_blink_set_oneshot() : 闪烁一次</span><br><span class="line">led_stop_software_blink() : led停止闪烁</span><br><span class="line">led_set_brightness() : 设置led的亮度</span><br><span class="line">led_update_brightness : 更新亮度</span><br><span class="line">led_sysfs_disable : 用户态关闭</span><br><span class="line">led_sysfs enable : 用户态打开</span><br><span class="line">leds_list : leds链表;</span><br><span class="line">leds_list_lock : leds链表锁</span><br></pre></td></tr></table></figure>
<p><code>led-triggers.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有触发器，为触发器提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_trigger_register()</span><br><span class="line">devm_led_trigger_register()</span><br><span class="line">led_trigger_register_simple()</span><br><span class="line"></span><br><span class="line">注销操作函数: </span><br><span class="line">led_trigger_unregister()</span><br><span class="line">led_trigger_unregister_simple()</span><br><span class="line"></span><br><span class="line">以及其它触发器相关的操作函数</span><br></pre></td></tr></table></figure>
<p><code>ledtrig-timer.c、ledtrig-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以 ledtrig-timer.c 为例</span><br><span class="line"></span><br><span class="line">入口函数调用 led_trigger_register() 注册触发器，</span><br><span class="line">注册时候传入 led_trigger 结构体，里面有 activate 和 deactivate 成员函数指针，</span><br><span class="line">作用是生成 delay_on 、 delay_off 文件</span><br><span class="line"></span><br><span class="line">同时还提供 delay_on 和 delay_off 的用户态操作接口</span><br><span class="line">卸载时，使用 led_trigger_unregister() 注销触发器</span><br></pre></td></tr></table></figure>

<p><code>leds-gpio.c、leds-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以 leds-gpio.c 为例</span><br><span class="line"></span><br><span class="line">在通过设备树或者其它途径匹配到设备信息后，将调用 probe() 函数，</span><br><span class="line">然后再根据设备信息设置 led_classdev，</span><br><span class="line">最后调用 devm_led_classdev_register() 注册 LED 设备。</span><br></pre></td></tr></table></figure>

<p>对于驱动开发人员，LED框架已经有了，并不需要我们去熟悉，只要知道如何使用，它是如何与我们的硬件相关联的，只要熟悉<code>leds-gpio.c</code>。</p>
<h2><span id="1-2-jie-gou-ti-miao-shu">1.2 结构体描述</span><a href="#1-2-jie-gou-ti-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-2-1-led-classdev">1.2.1 led_classdev</span><a href="#1-2-1-led-classdev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_classdev</span> &#123;</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *name;<span class="comment">//名字</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">brightness</span>;</span><span class="comment">//亮度</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">max_brightness</span>;</span><span class="comment">//最大亮度</span></span><br><span class="line">	 <span class="type">int</span>    flags;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Lower 16 bits reflect status */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SUSPENDED  (1 &lt;&lt; 0)</span></span><br><span class="line">	 <span class="comment">/* Upper 16 bits reflect control information */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_CORE_SUSPENDRESUME (1 &lt;&lt; 16)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT (1 &lt;&lt; 17)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT_STOP (1 &lt;&lt; 18)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_INVERT (1 &lt;&lt; 19)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SYSFS_DISABLE (1 &lt;&lt; 20)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_ASYNC (1 &lt;&lt; 21)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_SYNC (1 &lt;&lt; 22)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_DEV_CAP_FLASH (1 &lt;&lt; 23)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置亮度API</span></span><br><span class="line">	 <span class="type">void</span>  (*brightness_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line">	 <span class="type">int</span>  (*brightness_set_sync)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取亮度API</span></span><br><span class="line">	 <span class="keyword">enum</span> <span class="title function_">led_brightness</span> <span class="params">(*brightness_get)</span><span class="params">(<span class="keyword">struct</span> led_classdev *led_cdev)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//闪烁时点亮和熄灭的时间设置</span></span><br><span class="line">	 <span class="type">int</span>  (*blink_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="type">unsigned</span> <span class="type">long</span> *delay_on,<span class="type">unsigned</span> <span class="type">long</span> *delay_off);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">device</span>  *<span class="title">dev</span>;</span></span><br><span class="line">	 <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//leds-list的node</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">//默认trigger的名字</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *default_trigger;</span><br><span class="line">	<span class="comment">//闪烁的开关时间</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>   blink_delay_on, blink_delay_off;</span><br><span class="line">	<span class="comment">//闪烁的定时器链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>  <span class="title">blink_timer</span>;</span></span><br><span class="line">	<span class="comment">//闪烁的亮度</span></span><br><span class="line">	 <span class="type">int</span>    blink_brightness;</span><br><span class="line">	 <span class="type">void</span>   (*flash_resume)(<span class="keyword">struct</span> led_classdev *led_cdev);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">set_brightness_work</span>;</span></span><br><span class="line">	 <span class="type">int</span>   delayed_set_value;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_LEDS_TRIGGERS</span></span><br><span class="line">	<span class="comment">//trigger的锁</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>  <span class="title">trigger_lock</span>;</span></span><br><span class="line">	<span class="comment">//led的trigger</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">led_trigger</span> *<span class="title">trigger</span>;</span></span><br><span class="line">	<span class="comment">//trigger的链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">trig_list</span>;</span></span><br><span class="line">	<span class="comment">//trigger的数据</span></span><br><span class="line">	 <span class="type">void</span>   *trigger_data;</span><br><span class="line">	 <span class="type">bool</span>   activated;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">led_access</span>;</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-2-gpio-led">1.2.2 gpio_led</span><a href="#1-2-2-gpio-led" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_led</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *default_trigger;</span><br><span class="line">	<span class="type">unsigned</span> 	gpio;</span><br><span class="line">	<span class="type">unsigned</span>	active_low : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	retain_state_suspended : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	panic_indicator : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	default_state : <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/* default_state should be one of LEDS_GPIO_DEFSTATE_(ON|OFF|KEEP) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>name</code>: led名字<br><code>default_trigger</code>:  LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br><code>default_state</code>: 默认状态，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define LEDS_GPIO_DEFSTATE_OFF		0</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_ON		1</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_KEEP		2</span><br></pre></td></tr></table></figure>
<p><code>gpiod</code>：是gpio描述，详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<h1><span id="2-led-qu-dong-shi-neng">2 LED 驱动使能</span><a href="#2-led-qu-dong-shi-neng" class="header-anchor">#</a></h1><p>输入<code>make menuconfig</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; LED Support (NEW_LEDS [=y])</span><br><span class="line">		-&gt;LED Support <span class="keyword">for</span> GPIO connected LEDs</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"><br>可 以 看 出 ， 把 Linux 内 部 自 带 的 LED 灯 驱 动 编 译 进 内 核 以 后，<code>CONFIG_LEDS_GPIO</code> 就会等于‘y’：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h1><span id="3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</span><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi" class="header-anchor">#</a></h1><p>LED 灯驱动文件为<code>/drivers/leds/leds-gpio.c</code>，大家可以打开<code>/drivers/leds/Makefile</code> 这个文件：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br>来看一下<code>leds-gpio.c</code>这个驱动文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_gpio_leds_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;gpio-leds&quot;</span>, &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_led_driver</span> =</span> &#123;</span><br><span class="line">	.probe = gpio_led_probe,</span><br><span class="line">	.remove = gpio_led_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">	.name = <span class="string">&quot;leds-gpio&quot;</span>,</span><br><span class="line">	.of_match_table = of_gpio_leds_match,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(gpio_led_driver);</span><br></pre></td></tr></table></figure>

<p>LED 驱动的匹配表，此表只有一个匹配项，<code>compatible</code> 内容为<code>“gpio-leds”</code>，<br>因此设备树中的 LED 灯设备节点的 <code>compatible </code>属性值也要为<code>“gpio-leds”</code>，否则设备和驱动匹<br>配不成功，驱动就没法工作。</p>
<p>利用内核自带LED子系统驱动，可以帮我们很好的控制板子产品的指示灯，不需要单独编写驱动程序。</p>
<h2><span id="3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</span><a href="#3-1-gpio-led-probe-han-shu-jian-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"><br>进入probe函数，pdata此时为空，<strong>进入gpio_leds_create</strong>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li>调用 <code>device_get_child_node_count</code> 函数统计子节点数量，一般在在设备树中创建<br>一个节点表示 LED 灯，然后在这个节点下面为每个 LED 灯创建一个子节点。因此子节点数量也是 LED 灯的数量。</li>
<li>遍历每个子节点，获取每个子节点的信息：<br> 2.1 <code>devm_get_gpiod_from_child</code>获取每个gpio灯的<code>gpio_desc</code>信息。<br> 2.2 获取<code>label</code>属性，<code>label</code>作为led的名字<br> 2.3 获取<code>“linux,default-trigger”</code>属性，可以通过此属性设置某个 LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br> 2.4 获取<code>“default-state”</code>属性值，也就是 LED 灯的默认状态属性<br> 2.5 <code>create_gpio_led </code>函数创建 LED 相关的 io，常用gpio操作，下面详细介绍</li>
</ol>
<h3><span id="3-1-1-create-gpio-led">3.1.1 create_gpio_led</span><a href="#3-1-1-create-gpio-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<ol>
<li>先获取<code>gpiod</code>信息</li>
<li>配置<code>led_dat</code>属性，包括<code>default_state, brightness</code>等信息</li>
<li>配置<code>gpio</code>方向</li>
<li>将led注册给LED子系统</li>
</ol>
<h3><span id="3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</span><a href="#3-1-2-kai-qi-guan-bi-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<h1><span id="4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</span><a href="#4-led-zi-xi-tong-ying-yong-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-dts-bian-xie">4.1 dts编写</span><a href="#4-1-dts-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建一个节点表示 LED 灯设备，比如<code> dtsleds</code>，如果板子上有多个 LED 灯的话每个 LED灯都作为 <code>dtsleds</code> 的子节点。</p>
<ol>
<li><code>dtsleds </code>节点的<code>compatible</code>属性值一定要为<code>“gpio-leds”</code>。</li>
<li>设置<code>label</code>属性，此属性为可选，每个子节点都有一个 label 属性，label 属性一般表示LED 灯的名字，比如以颜色区分的话就是 red、green 等等。</li>
<li>每个子节点必须要设置<code>gpios</code>属性值，表示此 LED 所使用的 GPIO 引脚！</li>
<li>可以设置<code>“linux,default-trigger”</code>属性值，也就是设置 LED 灯的默认功能，可以查阅<code>Documentation/devicetree/bindings/leds/common.txt </code>这个文档来查看可选功能，比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backlight：LED 灯作为背光。</span><br><span class="line"><span class="keyword">default</span>-on：LED 灯打开</span><br><span class="line">heartbeat：LED 灯作为心跳指示灯，可以作为系统运行提示灯。</span><br><span class="line">ide-disk：LED 灯作为硬盘活动指示灯。</span><br><span class="line">timer：LED 灯周期性闪烁，由定时器驱动，闪烁频率可以修改</span><br></pre></td></tr></table></figure></li>
<li>可以设置<code>“default-state”</code>属性值，可以设置为 on、off 或 keep，为 on 的时候 LED 灯默认打开，为 off 的话 LED 灯默认关闭，为 keep 的话 LED 灯保持当前模式</li>
</ol>
<p>启动开发板：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>进入到 leds 目录中：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //打开 <span class="title">LED0</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //关闭 <span class="title">LED0</span></span></span><br></pre></td></tr></table></figure>
<p>如果能正常的打开和关闭 LED 灯话就说明使用led子系统ok。</p>
<h2><span id="4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</span><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		linux,<span class="keyword">default</span>-trigger = <span class="string">&quot;heartbeat&quot;</span>;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置 LED0 为<code> heartbeat</code>。<br>第 8 行，默认打开 LED0。</p>
<h1><span id="5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</span><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong" class="header-anchor">#</a></h1><h2><span id="5-1-dian-liang-led">5.1 点亮 LED</span><a href="#5-1-dian-liang-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">255</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">max_brightness</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-shan-shuo">5.2 闪烁</span><a href="#5-2-shan-shuo" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">会看到 <span class="title">trigger_list</span></span></span><br><span class="line"><span class="class">[<span class="title">none</span>] <span class="title">mmc0</span> <span class="title">mmc1</span> <span class="title">mmc2</span> <span class="title">timer</span></span></span><br><span class="line"><span class="class">其中的 <span class="title">timer</span> 这个 <span class="title">trigger</span> 是 <span class="title">ledtrig</span>-<span class="title">timer</span>.<span class="title">c</span> 中模块初始化的时候注册进去的</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> <span class="title">timer</span> &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class">这一句会调用</span></span><br><span class="line"><span class="class"><span class="title">led_trigger_store</span>()-&gt;</span></span><br><span class="line">   led_trigger_set()-&gt;</span><br><span class="line">     trigger-&gt;activate(led_cdev);</span><br><span class="line">从而调用 ledtrig-timer.c 文件里 的timer_trig_activate()，</span><br><span class="line">在 /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/ 下创建 <span class="title">delay_on</span>、<span class="title">delay_off</span> 两个文件</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 100 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 200 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_off</span></span></span><br><span class="line"><span class="class">这样会闪烁，亮 100<span class="title">ms</span> 灭 200<span class="title">ms</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-3-guan-bi-led">5.3 关闭 LED</span><a href="#5-3-guan-bi-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class">或</span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14n004sdsuf7ra06ors" data-title="字符设备驱动-内核led子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-pinctrl子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T07:38:09.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</a></li>
<li><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</a><ul>
<li><a href="#2-1-pinctrl-zi-xi-tong">2.1 pinctrl子系统</a><ul>
<li><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</a></li>
<li><a href="#2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</a></li>
<li><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</a><ul>
<li><a href="#3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</a></li>
<li><a href="#3-1-pinctrl-dev">3.1 pinctrl_dev</a></li>
<li><a href="#3-2-pinctrl-desc">3.2 pinctrl_desc</a><ul>
<li><a href="#3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</a></li>
<li><a href="#3-2-2-pin-desc">3.2.2 pin_desc</a></li>
<li><a href="#3-2-3-san-ge-ops">3.2.3 三个ops</a><ul>
<li><a href="#3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</a></li>
<li><a href="#3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</a></li>
<li><a href="#3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</a><ul>
<li><a href="#4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</a></li>
<li><a href="#4-1-pinctrl-map">4.1 pinctrl_map</a></li>
<li><a href="#4-2-dev-pin-info">4.2 dev_pin_info</a><ul>
<li><a href="#4-2-1-pinctrl">4.2.1 pinctrl</a><ul>
<li><a href="#4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</a><ul>
<li><a href="#5-1-pin-controller-shi-li">5.1 pin controller示例</a></li>
<li><a href="#5-2-client-shi-li">5.2 client示例</a><ul>
<li><a href="#5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</a><ul>
<li><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</span><a href="#1-pinctrl-he-gpio-subsystem-yin-ru" class="header-anchor">#</a></h1><p>上一节引入gpio了子系统：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<p>Linux 驱动讲究驱动分离与分层，pinctrl 和 gpio 子系统就是驱动分离与分层思想下的产物。<br>pinctrl顾名思义就是引脚控制，用来配置比如引脚mux复用信息，引脚电器属性（比如上&#x2F;下拉、速度、驱动能力等）信息。<br>gpio顾名思义就是控制gpio的输入输出，以及高低电平。不过，大多数的芯片并没有单独的IOMUX模块，引脚的复用、配置等，而是在GPIO模块内部实现的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<h1><span id="2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</span><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao" class="header-anchor">#</a></h1><h2><span id="2-1-pinctrl-zi-xi-tong">2.1  pinctrl子系统</span><a href="#2-1-pinctrl-zi-xi-tong" class="header-anchor">#</a></h2><h3><span id="2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</span><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou" class="header-anchor">#</a></h3><p>pinctrl子系统源码路径是linux&#x2F;drivers&#x2F;pinctrl：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他驱动层（client）：具体到使用系统pin资源的设备驱动程序</span><br><span class="line">pinctrl核心层(core)：内核抽象出来，向下为SoC pin controler drvier提供底层通信接口的能力， </span><br><span class="line">    向上为其他驱动提供了控制pin的能力，比如pin复用、配置引脚的电气特性，同时也为GPIO子系统提供pin操作。</span><br><span class="line">pin控制器驱动层(pinctrl-driver)： 提供了操作pin的具体方法。</span><br></pre></td></tr></table></figure>

<p><code>pinctrl-driver</code>主要为<code>pinctrl-core</code>提供pin的操作能力。把系统所有的pin以及对于pin的控制接口实例化成<code>pinctrl_desc</code>，并将<code>pinctrl_desc</code>注册到<code>pinctrl-core</code>中去。</p>
<h3><span id="2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</span><a href="#2-1-2-pinctrl-chong-yao-gai-nian" class="header-anchor">#</a></h3><p><code>Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt</code>有介绍重要相关概念：</p>
<p><strong>1. pin controller：</strong><br>    芯片手册里你找不到 <code>pin controller</code>，它是一个软件上的概念。对应 IOMUX──用来复用引脚，还可以配置引脚(比如上下拉电阻等)。<br><strong>2. client device：</strong><br>    “客户设备”，客户是指<code>Pinctrl</code>系统的客户，即使用Pinctrl系统的设备，使用引脚的设备<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<ul>
<li><ol>
<li><strong>pin state</strong><br>  对于一个<code>&quot;client device&quot;</code>，如UART设备，它有多个<code>“状态”</code>：<code>default、sleep</code>等，那么对应的引脚也有这些状态。</li>
</ol>
<p>  比如，默认状态下，UART设备正常工作，那么所用的引脚就要复用为UART功能；<br>  休眠状态下，为了省电，可以把这些引脚复用为GPIO功能；或者直接把它们配置输出高电平。</p>
<p>  上图<code>pinctrl-names</code>定义2种状态：<code>default，sleep</code>。<br>  第0种状态用到的引脚在<code>pinctrl-0</code>中定义，它是<code>state_0_node_a</code>，位于<code>pincontroller</code>节点中。<br>  第1种状态用到的引脚在<code>Pinctrl-1</code>中定义，它是<code>state_1_node_a</code>，位于<code>pincontroller</code>节点中。</p>
<p>  当UART设备处于<code>default</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚复用为uart0功能。<br>  当UART设备处于<code>sleep</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚配置为高电平。</p>
</li>
<li><ol start="2">
<li><strong>groups和function</strong><br>  一个设备会用到一个或多个引脚，这些引脚可以归纳为一组<code>（group）</code>；<br>  这些引脚可以复用为某个功能：<code>function</code>，如I2C功能，SPI功能，GPIO功能等。当然：一个设备可以用到多组引脚，比如A1、A2两组引脚，A1组复用为F1功能，A2组复用为F2功能：<br>  <img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></li>
</ol>
</li>
<li><ol start="3">
<li><strong>Generic pin multiplexing node和Generic pin configuration node</strong><br>  下图左边<code>pin controller</code>节点中，有子节点或孙节点，它们是给<code>client device</code>使用的。<br>  可用来描述复用信息：哪组<code>（group）</code>引脚复用为哪个功能<code>（function）</code>；<br>  配置信息：<code>哪组（group）</code>引脚配置为哪个设置功能（<code>setting</code>），如上拉、下拉等；</li>
</ol>
</li>
</ul>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h3><span id="2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</span><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng" class="header-anchor">#</a></h3><p>以imx6ull为例，<code>drivers/pinctrl/freescale/pinctrl-imx6ul.c</code><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p>驱动的入口是 <code>arch_initcall</code> 中声明的函数，类似于我们经常写的 <code>module_init</code>是动态ko加载，<code>arch_initcall</code>是编译进入内核镜像。可以看到是利用platform_device框架来写的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br>根据 <code>compatible</code> 和<code>设备树的compatible </code>字段进行匹配，匹配成功执行 probe 函数，调用<code>imx_pinctrl_probe_dt</code>解析dts中的<code>pinctrl</code>描述信息。调用<code>pinctrl_register</code>或者<code>devm_pinctrl_register</code>注册pinctl子系统。</p>
<h1><span id="3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</span><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller" class="header-anchor">#</a></h1><h2><span id="3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</span><a href="#3-0-shu-ju-jie-gou-guan-xi-tu" class="header-anchor">#</a></h2><p>总框图记录数据结构之间的关联。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="1876680-20240315174913445-1187095793"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pincontroller数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\pinctrl.h</span><br><span class="line">include\linux\pinctrl\pinmux.h</span><br><span class="line">include\linux\pinctrl\pinconf.h</span><br><span class="line"><span class="comment">//client数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\devinfo.h</span><br><span class="line">include\linux\device.h</span><br><span class="line">include\linux\pinctrl\machine.h</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pinctrl-dev">3.1 pinctrl_dev</span><a href="#3-1-pinctrl-dev" class="header-anchor">#</a></h2><p><code>pinctrl_dev</code> 是 pinctrl 子系统的根源结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">//提供具体操作方法和抽象包括pincrtl_ops函数，pinmux操作函数和pin的描述等</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_group_tree</span>;</span><span class="comment">//存储group的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_groups;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_function_tree</span>;</span><span class="comment">//存储function的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_functions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span><span class="comment">//链接gpio range 2 pin range相关的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">void</span> *driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//每个pinctrl都描述着一组gpio的复用和状态配置，</span></span><br><span class="line">    	<span class="comment">//如果这个pinctrl_dev是一个通过iic连接的，那么使用这个pinctrl_dev</span></span><br><span class="line">    	<span class="comment">//就需要配置其占用的gpio为iic功能，那么就要用这个来描述</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/driver/pinctrl/core.c</code>中注册pinctrl时将soc中所有的<code>pinctrl_dev</code>挂载到<code>pinctrl_dev_list</code>链表中方便查询使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">								 <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="3-2-pinctrl-desc">3.2 pinctrl_desc</span><a href="#3-2-pinctrl-desc" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span>   <span class="comment">//描述一个pin控制器的引脚,</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> npins;                    <span class="comment">//描述该控制器有多少个引脚</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>     <span class="comment">//引脚操作函数，有描述引脚，获取引脚等</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>       <span class="comment">//引脚复用相关的操作函数</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>     <span class="comment">//引脚配置相关的操作函数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> num_custom_params;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>三个ops:</p>
<ol>
<li><p><code>group</code>操作接口对应数据结构<code>struct pinctrl_ops</code>，包含<code>get_groups_count</code>、<code>get_group_name</code>、<code>get_group_pins</code>等接口；</p>
</li>
<li><p><code>mux</code>操作接口对应的数据结构为<code>struct pinmux_ops</code>，包含<code>pin request</code>、<code>free</code>、<code>set_mux</code>、<code>get_functions_count</code>、<code>get_function_groups</code>等；</p>
</li>
<li><p><code>function</code>操作接口对应的数据结构为<code>struct pinconf_ops</code>，包含<code>pin_config_set</code>、<code>pin_config_get</code>、<code>pin_config_group_get</code>、<code>pin_config_group_set</code>等接口；</p>
</li>
</ol>
<h3><span id="3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</span><a href="#3-2-1-pinctrl-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> number;<span class="comment">//引脚序号</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//引脚名</span></span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pinctrl_pin_desc</code>来描述一个引脚.</p>
<h3><span id="3-2-2-pin-desc">3.2.2 pin_desc</span><a href="#3-2-2-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">bool</span> dynamic_name;</span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">	<span class="comment">/* These fields only added when supporting pinmux drivers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINMUX</span></span><br><span class="line">	<span class="type">unsigned</span> mux_usecount;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *mux_owner;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> *<span class="title">mux_setting</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *gpio_owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记录引脚的使用计数、引脚当前所属的<code>function、group</code>信息（该数据结构主要是pinctrl子系统用于判断一个引脚是否被多次配置不同的复用情况使用（<code>pin_request、pin_free</code>）</p>
<h3><span id="3-2-3-san-ge-ops">3.2.3 三个ops</span><a href="#3-2-3-san-ge-ops" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</span><a href="#3-2-3-1-pinctrl-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">//获取组数</span></span><br><span class="line">	<span class="type">int</span> (*get_groups_count) ();</span><br><span class="line">	<span class="comment">//获取组名</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*get_group_name) ();</span><br><span class="line">	<span class="comment">//获取某组的引脚</span></span><br><span class="line">	<span class="type">int</span> (*get_group_pins) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供每个引脚的信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_dbg_show) ();</span><br><span class="line">	<span class="comment">//解析设备树节点，转换成pinctrl_map，重点</span></span><br><span class="line">	<span class="type">int</span> (*dt_node_to_map) ();</span><br><span class="line">	<span class="comment">//释放map</span></span><br><span class="line">	<span class="type">void</span> (*dt_free_map) ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>来取出某组的引脚：<code>get_groups_count、get_group_pins</code></li>
<li>处理设备树中<code>pin controller</code>中的某个节点创建映射：<code>dt_node_to_map</code>，把device_node转换为一系列的<code>pinctrl_map</code></li>
</ul>
<h4><span id="3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</span><a href="#3-2-3-2-pinmux-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</span><a href="#3-2-3-3-pinconf-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1><span id="4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</span><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client" class="header-anchor">#</a></h1><h2><span id="4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</span><a href="#4-0-shu-ju-jie-gou-guan-xi" class="header-anchor">#</a></h2><p>前面Soc pin描述相关的数据结构，已经搭建了该soc所支持的<code>pin</code>、<code>function</code>、<code>group</code>以及相关操作接口等信息；而<code>board pin</code>描述相关的数据结构则描述一块board所使用到的<code>function</code>及相关的<code>group</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="1876680-20240316150501629-222504717"></p>
<h2><span id="4-1-pinctrl-map">4.1 pinctrl_map</span><a href="#4-1-pinctrl-map" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//该pinctrl_map对应的状态（default、idle、sleep等</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span><span class="comment">//pinctrl_map的类型，包括mux group、config group、config pins等</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ctrl_dev_name;<span class="comment">//pinctrl device的名称，根据该名称可获取到soc pin controller对应的pinctrl device</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span><span class="comment">//引脚复用的内容，该数据结构中包含function名称、group名称，</span></span><br><span class="line">        <span class="comment">//通过function、group就可以确定进行引脚复用的引脚id与引脚复用值等信息；</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span><span class="comment">//引脚配置相关的内容，包括group或者pin的名称，</span></span><br><span class="line">        <span class="comment">//以及该group、pin的配置信息，实现引脚配置操作。</span></span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该数据结构可以理解为一个function类型：</p>
<h2><span id="4-2-dev-pin-info">4.2 dev_pin_info</span><a href="#4-2-dev-pin-info" class="header-anchor">#</a></h2><p>device结构体中有一个<code>dev_pin_info</code>，用来保存设备的pinctrl信息：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span>    <span class="comment">//该device对应引脚的配置与复用信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//该设备支持引脚配置类型（包括支持的pinctrl状态，</span></span><br><span class="line">    	<span class="comment">//每一种pinctrl状态下的引脚复用以及引脚配置信息）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="4-2-1-pinctrl">4.2.1 pinctrl</span><a href="#4-2-1-pinctrl" class="header-anchor">#</a></h3><p>一个设备的所有引脚配置相关的信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">//states下链接了该设备支持的所有引脚配置状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</span><a href="#4-2-1-1-pinctrl-state" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<h1><span id="5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</span><a href="#5-pinctrl-shi-li-hua-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-pin-controller-shi-li">5.1 pin controller示例</span><a href="#5-1-pin-controller-shi-li" class="header-anchor">#</a></h2><p>打开imx6ull的dtsi找到<code>pin controller</code>控制器节点，对比IMX6ULL参考手册可知：<code>imx6ull一共3个IOMUX控制器</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<h2><span id="5-2-client-shi-li">5.2 client示例</span><a href="#5-2-client-shi-li" class="header-anchor">#</a></h2><p>以<code>evk</code>公板为例：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br><strong>imx6ull pinmux dts配置描述：</strong><br>我们看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19       <span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br></pre></td></tr></table></figure>
<p>它是表示什么意思呢？配置了哪些信息呢？<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p><code>UART1_RTS_B</code>复用成<code>GPIO1_IO19</code>:<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p>此宏定义在imx_6ull_pinfunc.h, 后面跟着 5 个数字，也就是这个宏定义的具体值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0090</span> <span class="number">0x031C</span> <span class="number">0x0000</span> <span class="number">0x5</span> <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这 5 个值的含义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;</span><br></pre></td></tr></table></figure>
<p>0x0090表示<code>UART1_RTS_B</code>的iomux寄存器<br>0x031C表示<code>UART1_RTS_B</code>的电器属性寄存器<br>0x0000表示<code>input寄存器</code><br>0x5表示复用成模式5<br>0x0表示input寄存器设置值为0x0</p>
<p>注意还少了一项电器属性的值啊？别急定义在dts中，<code>0x17059</code>就刚好是电器属性的值。</p>
<h3><span id="5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</span><a href="#5-2-1-client-ru-he-shi-yong-pinctrl" class="header-anchor">#</a></h3><p>前面讲过client包含device结构体，每个device结构体里都有一个<code>dev_pin_info</code>结构体，用来保存设备的pinctrl信息。<code>platform_device</code>匹配driver会执行probe，probe前会进行pinctrl处理，处理函数为<code>pinctrl_bind_pins</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">	platform_device_add</span><br><span class="line">		device_add</span><br><span class="line">			bus_probe_device;</span><br><span class="line">				device_initial_probe</span><br><span class="line">					__device_attach</span><br><span class="line">						<span class="title function_">bus_for_each_drv</span><span class="params">(dev-&gt;bus, <span class="literal">NULL</span>, &amp;data, __device_attach_driver)</span>;</span><br><span class="line">						<span class="comment">// 对于plarform_bus_type下的每一个driver, 调用__device_attach_driver</span></span><br><span class="line"></span><br><span class="line">__device_attach_driver</span><br><span class="line">	<span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span>;</span><br><span class="line">		drv-&gt;bus-&gt;match(dev, drv)<span class="comment">// 调用platform_bus_type.match</span></span><br><span class="line">			driver_probe_device</span><br><span class="line">				really_probe</span><br><span class="line">				<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">					pinctrl_bind_pins</span><br><span class="line">					drv-&gt;probe <span class="comment">//执行driver中的probe函数			</span></span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</span><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng" class="header-anchor">#</a></h4><ul>
<li>构造<code>pinctrl</code><ul>
<li>通过<code>pinctrl_ops.dt_node_to_map</code>将设备树节点转换成一系列<code>pinctrl_map</code></li>
<li><code>pinctrl_map</code>转换成<code>pinctrl_setting</code>，放入settings链表，记录在<code>pinctrl_state</code>中</li>
</ul>
</li>
<li>选择<code>state</code>，遍历settings链表，进行pinctrl的mux和config<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></li>
</ul>
<p>函数调用过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 分配dev_pin_info结构体 */</span></span><br><span class="line">	devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 获取pinctrl */</span></span><br><span class="line">	devm_pinctrl_get(dev);</span><br><span class="line">		pinctrl_get</span><br><span class="line">			<span class="comment">/* 构建pinctrl */</span></span><br><span class="line">			create_pinctrl(dev);</span><br><span class="line">				<span class="comment">/* 分配pinctrl */</span></span><br><span class="line">				p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">				<span class="comment">/* 设备树节点转换为pinctrl_map */</span></span><br><span class="line">				pinctrl_dt_to_map(p);</span><br><span class="line">				<span class="comment">/* 每个pinctrl_map，又被转换为一个pinctrl_setting，添加到setting链表 */</span></span><br><span class="line">				for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">					ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节点转换为pinctrl_map过程</strong>：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_dt_to_map(p);</span><br><span class="line">	<span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">		propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">	    <span class="comment">/* 取出pinctrl-%d节点属性 */</span></span><br><span class="line">	   	prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">	    <span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">		size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line">	   	<span class="comment">/* 对pinctrl-%d中的每一个phandle进行pinctrl_map转换 */</span></span><br><span class="line">	    <span class="comment">/* 例如pinctrl-0 = &lt;&amp;state_0_node_a &amp;state_0_node_b&gt;有两个phandle */</span></span><br><span class="line">	    <span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">	    	<span class="comment">/* 根据phandle找到对应节点 */</span></span><br><span class="line">	       	np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">	        <span class="comment">/* Parse the node */</span></span><br><span class="line">			dt_to_map_one_config(p, statename, np_config);</span><br><span class="line">	           	<span class="comment">/* 调用Pincontroller中dt_node_to_map函数,构造pinctrl_map */</span></span><br><span class="line">	       		ops-&gt;dt_node_to_map()</span><br><span class="line">	            <span class="comment">/* 将pinctrl_map添加到maps链表 */</span></span><br><span class="line">	            dt_remember_or_free_map</span><br><span class="line">	            	pinctrl_register_map</span><br><span class="line">	                	list_add_tail</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* fy00的dt_node_to_map函数 */</span></span><br><span class="line">mc_pctrl_dt_node_to_map()</span><br><span class="line">	<span class="comment">/* 取出每一个子节点 */</span></span><br><span class="line">    for_each_child_of_node(np_config, np) &#123;</span><br><span class="line">   		mc_pctrl_dt_subnode_to_map</span><br><span class="line">   			<span class="comment">/* 获取设备树pinmux属性 */</span></span><br><span class="line">        	pins = of_find_property(node, <span class="string">&quot;pinmux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    		num_pins = pins-&gt;length / <span class="keyword">sizeof</span>(u32);</span><br><span class="line">    		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">            	of_property_read_u32_index(node, <span class="string">&quot;pinmux&quot;</span>,i, &amp;pinfunc); </span><br><span class="line">                <span class="comment">/* 解析设备树，将pinmux属性中每一个成员记录在pin和func中 */</span></span><br><span class="line">                pin = MC_GET_PIN_NO(pinfunc);</span><br><span class="line">				func = MC_GET_PIN_FUNC(pinfunc);</span><br><span class="line">                <span class="comment">/* 设置复用的pinctrl_map */</span></span><br><span class="line">                mc_pctrl_dt_node_to_map_func();</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;</span><br><span class="line">					(*<span class="built_in">map</span>)[*num_maps].data.mux.group = grp-&gt;name;</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].data.mux.function = mc_gpio_functions[fnum];</span><br><span class="line">					(*num_maps)++;</span><br><span class="line">              	<span class="keyword">if</span> (has_config) &#123;</span><br><span class="line">                    <span class="comment">/* 设置配置pinctrl_map，fy00没有配置pinctrl_map */</span></span><br><span class="line">                    pinctrl_utils_add_map_configs</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].type = type;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.group_or_pin = group;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.configs = dup_configs;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.num_configs = num_configs;</span><br><span class="line">                        (*num_maps)++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong>pinctrl_map转换为pinctrl_setting过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">for_each_maps() &#123;</span><br><span class="line">	add_setting();</span><br><span class="line">		find_state();</span><br><span class="line">		<span class="keyword">if</span> (!state)</span><br><span class="line">			<span class="comment">/* 第一次添加state到states链表 */</span></span><br><span class="line">			create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">				list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states);</span><br><span class="line">		<span class="comment">/* 将map的name和tpye赋值给setting */</span></span><br><span class="line">		setting-&gt;type = <span class="built_in">map</span>-&gt;type;</span><br><span class="line">		setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">			<span class="comment">/* MUX类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">				pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的function字符串转换为序号，赋值给setting*/</span></span><br><span class="line">					pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">					setting-&gt;data.mux.func = ret;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的group字符串转换为序号，赋值给setting */</span></span><br><span class="line">					ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">					setting-&gt;data.mux.group = ret;</span><br><span class="line">			<span class="comment">/* CONFIGS类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">				pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 从pinctrl_map取出pin或group赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.group_or_pin = pin;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map的configs赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;</span><br><span class="line">					setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 添加到settings链表 */</span></span><br><span class="line">			list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pin脚的复用和配置过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 寻找state */</span></span><br><span class="line">	pinctrl_lookup_state</span><br><span class="line">	<span class="comment">/* 选择state */</span></span><br><span class="line">	pinctrl_select_state</span><br><span class="line">		pinctrl_commit_state</span><br><span class="line">			<span class="comment">/* 遍历settings链表 */</span></span><br><span class="line">        	list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">                	<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">                		<span class="comment">/* 设置复用 */</span></span><br><span class="line">                   		pinmux_enable_setting(setting);</span><br><span class="line">                        	ops-&gt;set_mux(...);</span><br><span class="line">                    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">					<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">						<span class="comment">/* 设置配置 */</span></span><br><span class="line">						pinconf_apply_setting(setting);</span><br><span class="line">							ops-&gt;pin_config_group_set(...);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14n004pdsufc03feiae" data-title="字符设备驱动-pinctrl子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-gpio子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T12:14:37.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</a></li>
<li><a href="#2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</a><ul>
<li><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</a><ul>
<li><a href="#2-0-1-probe-fen-xi">2.0.1 probe分析</a><ul>
<li><a href="#2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</a></li>
<li><a href="#2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</a></li>
<li><a href="#2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</a></li>
<li><a href="#2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</a><ul>
<li><a href="#2-1-1-gpio-device">2.1.1 gpio_device</a></li>
<li><a href="#2-1-2-gpio-chip">2.1.2 gpio_chip</a></li>
<li><a href="#2-1-3-gpio-desc">2.1.3 gpio_desc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-gpio-zi-xi-tong-api">3 gpio子系统api</a><ul>
<li><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</a><ul>
<li><a href="#3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</a></li>
<li><a href="#3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</a></li>
<li><a href="#3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</a></li>
</ul>
</li>
<li><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</a></li>
<li><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</a></li>
</ul>
</li>
<li><a href="#4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</a></li>
<li><a href="#5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</a><ul>
<li><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</a></li>
<li><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</a><ul>
<li><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</a><ul>
<li><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</a></li>
<li><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</span><a href="#1-gpio-zi-xi-tong-yin-ru" class="header-anchor">#</a></h1><p>如果 <code>pinctrl </code>子系统将一个 PIN 复用为 GPIO 的话，那么接下来要用到 gpio 子系统了。gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，设置读取 GPIO 的值等。</p>
<p>gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。</p>
<h1><span id="2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</span><a href="#2-gpio-zi-xi-tong-jia-gou" class="header-anchor">#</a></h1><p>Linux的GPIO子系统驱动框架由三个主要部分组成：① GPIO控制器驱动程序、②gpio lib驱动程序 ③GPIO字符设备驱动程序：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image-20240817202346143"><br>使用<code>gpiochip_add/gpiochip_add_data</code>向系统<code>注册gpio_chip</code>, 这些都是半导体原厂要做的，设备商只需要使用即可。</p>
<h2><span id="2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</span><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><code>drivers/gpio/gpio-mxc.c</code> 就是 I.MX6ULL的 GPIO 控制器驱动文件，在此文件中有如下所示<code>of_device_id</code> 匹配表:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>对照<code>imx6ull.dtsi</code>的gpio控制器可以看到能匹配：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>打开<code>drivers/gpio/gpio-mxc.c</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"><br>probe函数内容如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxc_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">iores</span>;</span></span><br><span class="line">	<span class="type">int</span> irq_base = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	mxc_gpio_get_hw(pdev);</span><br><span class="line"></span><br><span class="line">	port = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*port), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!port)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	iores = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(port-&gt;base);</span><br><span class="line"></span><br><span class="line">	port-&gt;irq_high = platform_get_irq(pdev, <span class="number">1</span>);</span><br><span class="line">	port-&gt;irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (port-&gt;irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> port-&gt;irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the controller clock is optional */</span></span><br><span class="line">	port-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;clk))</span><br><span class="line">		port-&gt;clk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	err = clk_prepare_enable(port-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to enable clock.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line">	err = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_pm_dis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disable the interrupt and clear the status */</span></span><br><span class="line">	writel(<span class="number">0</span>, port-&gt;base + GPIO_IMR);</span><br><span class="line">	writel(~<span class="number">0</span>, port-&gt;base + GPIO_ISR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mxc_gpio_hwtype == IMX21_GPIO) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setup one handler for all GPIO interrupts. Actually setting</span></span><br><span class="line"><span class="comment">		 * the handler is needed only once, but doing it for every port</span></span><br><span class="line"><span class="comment">		 * is more robust and easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* setup one handler for each entry */</span></span><br><span class="line">		irq_set_chained_handler_and_data(port-&gt;irq,</span><br><span class="line">						 mx3_gpio_irq_handler, port);</span><br><span class="line">		<span class="keyword">if</span> (port-&gt;irq_high &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">/* setup handler for GPIO 16 to 31 */</span></span><br><span class="line">			irq_set_chained_handler_and_data(port-&gt;irq_high,</span><br><span class="line">							 mx3_gpio_irq_handler,</span><br><span class="line">							 port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = bgpio_init(&amp;port-&gt;gc, &amp;pdev-&gt;dev, <span class="number">4</span>,</span><br><span class="line">			 port-&gt;base + GPIO_PSR,</span><br><span class="line">			 port-&gt;base + GPIO_DR, <span class="literal">NULL</span>,</span><br><span class="line">			 port-&gt;base + GPIO_GDIR, <span class="literal">NULL</span>,</span><br><span class="line">			 BGPIOF_READ_OUTPUT_REG_SET);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(np, <span class="string">&quot;gpio_ranges&quot;</span>))</span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;gc.request = mxc_gpio_request;</span><br><span class="line">	port-&gt;gc.<span class="built_in">free</span> = mxc_gpio_free;</span><br><span class="line">	port-&gt;gc.parent = &amp;pdev-&gt;dev;</span><br><span class="line">	port-&gt;gc.to_irq = mxc_gpio_to_irq;</span><br><span class="line">	port-&gt;gc.base = (pdev-&gt;id &lt; <span class="number">0</span>) ? of_alias_get_id(np, <span class="string">&quot;gpio&quot;</span>) * <span class="number">32</span> :</span><br><span class="line">					     pdev-&gt;id * <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	err = devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;port-&gt;gc, port);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">32</span>, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = irq_base;</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	port-&gt;domain = irq_domain_add_legacy(np, <span class="number">32</span>, irq_base, <span class="number">0</span>,</span><br><span class="line">					     &amp;irq_domain_simple_ops, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!port-&gt;domain) &#123;</span><br><span class="line">		err = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out_irqdesc_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gpio-mxc can be a generic irq chip */</span></span><br><span class="line">	err = mxc_gpio_init_gc(port, irq_base, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_irqdomain_remove;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports);</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, port);</span><br><span class="line">	pm_runtime_put(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_pm_dis:</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(port-&gt;clk);</span><br><span class="line">out_irqdomain_remove:</span><br><span class="line">	irq_domain_remove(port-&gt;domain);</span><br><span class="line">out_irqdesc_free:</span><br><span class="line">	irq_free_descs(irq_base, <span class="number">32</span>);</span><br><span class="line">out_bgio:</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;%s failed with errno %d\n&quot;</span>, __func__, err);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-0-1-probe-fen-xi">2.0.1 probe分析</span><a href="#2-0-1-probe-fen-xi" class="header-anchor">#</a></h3><p>里面定义了一个很重要的结构体<code>mxc_gpio_port</code> 就是对<code> I.MX6ULL GPIO</code> 的抽象。<code>mxc_gpio_port </code>结构体定义如下：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br><code>mxc_gpio_probe</code>又会继续调用<code>mxc_gpio_get_hw</code>获取gpio的硬件相关数据，也就是gpio组，gpio1.gpio2等。</p>
<h4><span id="2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</span><a href="#2-0-1-0-mxc-gpio-get-hw" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p>我们imx6ull gpio<code>控制器类型</code>就是<code>imx35系列</code>。因此选用<code>imx35_gpio_hwdata</code>，如下：可以看出这些成员不就是对应寄存器的偏移量吗？</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</span><a href="#2-0-1-1-get-resource-and-ioremap" class="header-anchor">#</a></h4><p>比如我们probe中通过<code>platform_get_resource</code> 获取<code>gpio1</code>的<code>基地址为0X0209,C000</code>，那么就可以通过配置<code>mxc_gpio_hwdata</code>结构体成员来配置寄存器。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>然后调用 <code>devm_ioremap_resource</code> 函数进行内存映射，得到 <code>0x0209C000</code> 在 Linux 内核中的虚拟地址。<br>然后<code>platform_get_irq</code> 函数获取中断号，分为获取高 16 位 GPIO 的中断号，和获取低 16 位 GPIO 中断号。</p>
<p>操作 GPIO1 的 <code>IMR</code> 和 <code>ISR</code> 这两个寄存器，关闭 GPIO1 所有 IO 中断，并且清除状态寄存器:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>设置对应 GPIO 的中断服务函数，不管是高 16 位还是低 16 位，中断服务函数都是 <code>mx3_gpio_irq_handler</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<h4><span id="2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</span><a href="#2-0-1-2-bgpio-init" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image-20240817211118974"></p>
<p>调用<code>bgpio_init</code> 函数主 要 任 务 就 是 初 始 化<code> port-&gt;gc, (gc就是gpio_chip)</code>。顾名思义<code>bgpio_init</code>就是<code>basic gpio init</code>，里 面 有 三 个 <code>setup</code> 函 数 :</p>
<ol>
<li><code>bgpio_setup_io</code> </li>
<li><code>bgpio_setup_accessors</code> </li>
<li><code>bgpio_setup_direction</code>。这三个函数就是初始化 <code>port-&gt;gc</code> 中的各种有关GPIO 的操作，比如输出，输入等等。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image-20240817213544044"></p>
<h4><span id="2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</span><a href="#2-0-1-3-devm-gpiochip-add-data" class="header-anchor">#</a></h4><p>调用<code>devm_gpiochip_add_data</code>注册这个port。gpio控制器就成功注册给了gpio子系统。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>至此，<code>port-&gt;gc</code>既有了对 GPIO 的操作函数，又有了 I.MX6ULL 有关 GPIO的寄存器，那么只要得到 port 就可以对 I.MX6ULL 的 GPIO 进行操作。</p>
<h2><span id="2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</span><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-1-1-gpio-device">2.1.1 gpio_device</span><a href="#2-1-1-gpio-device" class="header-anchor">#</a></h3><p>每个<code>GPIO Controller</code>用一个<code>gpio_device</code>来表示:</p>
<ol>
<li>每组gpio引脚对应一个<code>gpio_desc</code>和一个<code>gpio_chip</code></li>
<li>gpio引脚的操作函数，都放在<code>gpio_chip</code>成员函数中。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image-20240818143429583"></p>
<h3><span id="2-1-2-gpio-chip">2.1.2 gpio_chip</span><a href="#2-1-2-gpio-chip" class="header-anchor">#</a></h3><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image-20240818140515596"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*label;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>	*<span class="title">gpiodev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//请求一个 GPIO 引脚</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//释放一个之前请求的 GPIO 引脚</span></span><br><span class="line">	<span class="type">int</span>			(*get_direction)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//获取方向</span></span><br><span class="line">	<span class="type">int</span>			(*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//输入模式</span></span><br><span class="line">	<span class="type">int</span>			(*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//输出模式，并且set gpio val</span></span><br><span class="line">	<span class="type">int</span>			(*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//读取 GPIO 引脚的值</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//设置gpio 引脚值</span></span><br><span class="line">	<span class="type">void</span>			(*set_multiple)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *mask,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *bits);</span><br><span class="line">	<span class="type">int</span>			(*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="type">unsigned</span> debounce);<span class="comment">//设置 GPIO 引脚的去抖动时间</span></span><br><span class="line">	<span class="type">int</span>			(*set_single_ended)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="keyword">enum</span> single_ended_mode mode);</span><br><span class="line">	<span class="type">int</span>			(*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);</span><br><span class="line">	<span class="type">void</span>			(*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">						<span class="keyword">struct</span> gpio_chip *chip);<span class="comment">//调试目的，显示 GPIO 引脚的状态</span></span><br><span class="line">	<span class="type">int</span>			base;<span class="comment">//chip的基地址</span></span><br><span class="line">	u16			ngpio;<span class="comment">//GPIO 引脚数量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*<span class="type">const</span> *names;</span><br><span class="line">	<span class="type">bool</span>			can_sleep;</span><br><span class="line">	<span class="type">bool</span>			irq_not_threaded;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_GPIO_GENERIC)<span class="comment">// bgpio使能</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*read_reg)</span><span class="params">(<span class="type">void</span> __iomem *reg)</span>;</span><br><span class="line">	<span class="type">void</span> (*write_reg)(<span class="type">void</span> __iomem *reg, <span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pin2mask)</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> pin)</span>;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dat;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_set;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_clr;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dir;</span><br><span class="line">	<span class="type">int</span> bgpio_bits;</span><br><span class="line">	<span class="type">spinlock_t</span> bgpio_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_dir;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIOLIB_IRQCHIP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">irqchip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">irqdomain</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_base;</span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	irq_handler;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_default_type;</span><br><span class="line">	<span class="type">int</span>			irq_parent;</span><br><span class="line">	<span class="type">bool</span>			irq_need_valid_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*irq_valid_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">lock_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">	<span class="type">int</span> of_gpio_n_cells;<span class="comment">//dts描述几个cells构成</span></span><br><span class="line">	<span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line">			<span class="type">const</span> <span class="keyword">struct</span> of_phandle_args *gpiospec, u32 *flags);<span class="comment">//设备树中 GPIO 引脚的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="2-1-3-gpio-desc">2.1.3 gpio_desc</span><a href="#2-1-3-gpio-desc" class="header-anchor">#</a></h3><p>在<code>gpio_device</code>中有一个<code>gpio_desc</code>数组，每一引脚有一项<code>gpio_desc</code>。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image-20240818145531275"></p>
<h1><span id="3-gpio-zi-xi-tong-api">3 gpio子系统api</span><a href="#3-gpio-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</span><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</span><a href="#3-1-1-qing-qiu-he-pei-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求和释放GPIO</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span>* label)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断gpio释放可用</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">gpio_is_valid</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio为输入还是输出</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio的去抖动时间，其中debounce以ms为单位</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_debounce</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">unsigned</span> debounce)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</span><a href="#3-1-2-du-qu-he-she-zhi-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; <span class="comment">// value为bool值，0表示低电平，非0高电平</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用gpio_can_sleep()判断gpio线是否可能睡眠</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">gpio_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio映射到irq时，使用方式如下gpio_to_irq，返回irq号，接下来可以使用request_irq申请irq</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_to_gpio</span><span class="params">(<span class="type">int</span> irq)</span></span><br></pre></td></tr></table></figure>
<h3><span id="3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</span><a href="#3-1-3-gpiochip-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//注册一个gpio_chip结构体，它描述了一组GPIO引脚及其操作函数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_remove</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//移除之前注册的gpio_chip。</span></span><br><span class="line"></span><br><span class="line">gpiochip_line_config<span class="comment">//配置gpio_chip中的特定引脚。</span></span><br><span class="line">gpiochip_request_own<span class="comment">//请求对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_request_unown<span class="comment">//释放对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_set<span class="comment">//为gpio_chip中的多个引脚设置值。</span></span><br><span class="line">gpiochip_clear<span class="comment">//清除gpio_chip中的多个引脚的值。</span></span><br><span class="line"></span><br><span class="line">gpiochip_set_direction<span class="comment">//为gpio_chip中的多个引脚设置方向。</span></span><br><span class="line">gpiochip_get_direction<span class="comment">//获取gpio_chip中引脚的方向。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</span><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo_device &#123;</span><br><span class="line">	compatible = <span class="string">&quot;acme,foo&quot;</span>;</span><br><span class="line">	[...];</span><br><span class="line">	led-gpios = &lt;&amp;gpio <span class="number">15</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//红色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">16</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//绿色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">17</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//蓝色</span></span><br><span class="line">				;</span><br><span class="line">	power-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	reset-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中获取GPIO的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取gpio的代码</span></span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get_index</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_put</span><span class="params">(sruct gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">red</span>, *<span class="title">green</span>, *<span class="title">blue</span>, *<span class="title">power</span>, *<span class="title">reset</span>;</span></span><br><span class="line">red = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">0</span>, GPIO_OUT_HIGH);</span><br><span class="line">green = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">1</span>, GPIO_OUT_HIGH);</span><br><span class="line">blue = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">2</span>, GPIO_OUT_HIGH);</span><br><span class="line"></span><br><span class="line">power = gpiod_get(dev, <span class="string">&quot;power&quot;</span>, GPIO_OUT_HIGH);</span><br><span class="line">reset = gpiod_get(dev, <span class="string">&quot;reset&quot;</span>, GPIO_OUT_HIGH);</span><br></pre></td></tr></table></figure>

<p>其他类似的功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_set_debounce</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">unsigned</span> debounce)</span>;</span><br><span class="line"><span class="comment">// 输出逻辑1</span></span><br><span class="line"><span class="comment">// 在Active-High的情况下它会输出高电平</span></span><br><span class="line"><span class="comment">// 在Active-Low的情况下它会输出低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者之间相互转换</span></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpio_to_desc</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">desc_to_gpio</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image-20240818143109206"></p>
<p>无论是传统GPIO控制还是基于描述符的gpio方式，都是调用底层控制器gpio_chip的操作函数。</p>
<h2><span id="3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</span><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio1 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio2 : gpio2 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">foo-device &#123;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">2</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;;</span><br><span class="line">	reset-gpio = &lt;&amp;gpio1 <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio2 <span class="number">10</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在传统使用gpio的方式中，需要获取gpio编号，获取方式如下：</span></span><br><span class="line"><span class="type">int</span> n_gpios = of_get_named_gpio_count(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br><span class="line"><span class="type">int</span> first_gpio = of_get_named_gpio(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</span><a href="#4-ji-yu-sysfs-cao-zuo-gpio" class="header-anchor">#</a></h1><p><strong>声明GPIO口:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/export  <span class="comment">#/sys/class/gpio会生成gpio256目录</span></span><br><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><strong>方向：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in&quot;</span> &gt; direction    <span class="comment">#输入方向</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;out&quot;</span> &gt; direction   <span class="comment">#输出方向</span></span><br><span class="line"><span class="built_in">cat</span> direction</span><br></pre></td></tr></table></figure>
<p><strong>val:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; value</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; value</span><br><span class="line"><span class="built_in">cat</span> value</span><br></pre></td></tr></table></figure>

<p><strong>edge:</strong><br>表示中断的触发方式，edge文件有如下四个值：<code>&quot;none&quot;, &quot;rising&quot;,&quot;falling&quot;，&quot;both&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">none：<span class="comment">#表示引脚为输入，不是中断引脚</span></span><br><span class="line">rising：<span class="comment">#表示引脚为中断输入，上升沿触发</span></span><br><span class="line">falling：<span class="comment">#表示引脚为中断输入，下降沿触发</span></span><br><span class="line">both：<span class="comment">#表示引脚为中断输入，边沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;both&quot;</span> &gt; /sys/class/gpio/gpioN/edge</span><br></pre></td></tr></table></figure>
<h1><span id="5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</span><a href="#5-gpio-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>以<code>nxp</code>官方<code>evk</code>公板<code>imx6ull-14x14-evk.dts</code>为例：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"><br>重新定义了<code>iomuxc</code>引脚控制器，<code>evk</code>设备默认default状态对应的pins为<code>pinctrl_hog_1</code>, 配置3个引脚（<code>UART1_RTS_B, GPIO1_IO05, GPIO1_IO09</code>)信息。看起来是要做成sd卡的热插拔功能。<br>我们再找到描述sd的设备树节点：<code>usdhc1</code>和<code>usdhc2</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;usdhc1 &#123;</span><br><span class="line">         pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line">         pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc1&gt;;</span><br><span class="line">         pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;</span><br><span class="line">         pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;</span><br><span class="line">         cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">         keep-power-in-suspend;</span><br><span class="line">         enable-sdio-wakeup;</span><br><span class="line">         vmmc-supply = &lt;&amp;reg_sd1_vmmc&gt;;</span><br><span class="line">         status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iomuxc</code>控制器节点下有<code>usdhc1</code>要用的<code>pins</code>信息，包括<code>pinctrl_hog_1</code>，<code>pinctrl_usdhc1</code>，<code>pinctrl_usdhc1_100mhz</code>节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">     pinctrl_usdhc1: usdhc1grp &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x10071</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x17059</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_100mhz: usdhc1grp100mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170b9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_200mhz: usdhc1grp200mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170f9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</span><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu" class="header-anchor">#</a></h2><p>前面讲的其实都还是<code>pinctrl</code>的内容，<code>usdhc1</code>有一个属性<code>cd-gpios</code>。这时就需要用到gpio控制器了，以<code>imx6ull</code>为例，gpio控制器描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Linux<span class="number">-4.9</span><span class="number">.88</span>/Documentation/devicetree/bindings/gpio$ ls -l fsl-imx-gpio.txt</span><br><span class="line"></span><br><span class="line">   * Freescale i.MX/MXC GPIO controller</span><br><span class="line">  </span><br><span class="line">   Required properties:</span><br><span class="line">   - compatible : Should be <span class="string">&quot;fsl,&lt;soc&gt;-gpio&quot;</span></span><br><span class="line">   - reg : Address and length of the <span class="keyword">register</span> <span class="built_in">set</span> <span class="keyword">for</span> the device</span><br><span class="line">   - interrupts : Should be the port interrupt shared by all <span class="number">32</span> pins, <span class="keyword">if</span></span><br><span class="line">     one number.  If two numbers, the first one is the interrupt shared</span><br><span class="line">     by low <span class="number">16</span> pins and the second one is <span class="keyword">for</span> high <span class="number">16</span> pins.</span><br><span class="line">   - gpio-controller : Marks the device node as a gpio controller.</span><br><span class="line">  - <span class="meta">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">    the second cell is used to specify the gpio polarity:</span><br><span class="line">        <span class="number">0</span> = active high</span><br><span class="line">        <span class="number">1</span> = active low</span><br><span class="line">  - interrupt-controller: Marks the device node as an interrupt controller.</span><br><span class="line">  - <span class="meta">#interrupt-cells : Should be 2.  The first cell is the GPIO number.</span></span><br><span class="line">    The second cell bits[<span class="number">3</span>:<span class="number">0</span>] is used to specify trigger type and level flags:</span><br><span class="line">        <span class="number">1</span> = low-to-high edge triggered.</span><br><span class="line">        <span class="number">2</span> = high-to-low edge triggered.</span><br><span class="line">        <span class="number">4</span> = active high level-sensitive.</span><br><span class="line">        <span class="number">8</span> = active low level-sensitive.</span><br><span class="line"> </span><br><span class="line">  Example:</span><br><span class="line"> </span><br><span class="line">gpio0: gpio@<span class="number">73f</span>84000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx51-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x73f84000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">50</span> <span class="number">51</span>&gt;;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打开具体的<code>imx6ull.dtsi</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"><br>打开芯片参考书册，刚好对应gpio1控制器：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<h2><span id="5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</span><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe" class="header-anchor">#</a></h2><p>回到<code>usdhc1</code>的属性<code>cd-gpios</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br></pre></td></tr></table></figure>

<p>表述使用gpio1控制器，由于该控制器的gpio-cells为2， 根据描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">the second cell is used to specify the gpio polarity:</span><br><span class="line">    0 = active high</span><br><span class="line">    1 = active low</span><br></pre></td></tr></table></figure>
<p>19表示<code>pin number</code>， <code>GPIO_ACTIVE_LOW</code>是一个宏定义：可以看到为1，也就是低电平有效<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</span><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path获取使用该gpio的节点</span><br><span class="line"><span class="number">2.</span> of_get_named_gpio，获取gpio编号</span><br><span class="line"><span class="number">3.</span> gpio_request,申请gpio</span><br><span class="line"><span class="number">4.</span> gpio_direction_set/gpio_direction_get</span><br><span class="line"><span class="number">5.</span> gpio_val_set</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</span><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led" class="header-anchor">#</a></h4><p>编写一个gpioled节点：</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"><br>同时修改<code>iomuxc</code>节点，因为用到了<code>GPIO1_IO03</code>，要设置该pin脚为<code>gpio</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_CNT			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_NAME		<span class="string">&quot;gpioled&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 				0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 				1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="type">int</span> major;</span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span></span><br><span class="line">	<span class="type">int</span> led_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get led-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">	ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gpioled.major) &#123;</span><br><span class="line">		gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">		gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">		gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;gpioled major=%d,minor=%d\r\n&quot;</span>,gpioled.major, gpioled.minor);	</span><br><span class="line">	</span><br><span class="line">	gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);</span><br><span class="line">	</span><br><span class="line">	cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>, gpioled.devid, <span class="literal">NULL</span>, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;gpioled.cdev);</span><br><span class="line">	unregister_chrdev_region(gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">	class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>


<h4><span id="5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</span><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep" class="header-anchor">#</a></h4><p>evk公板的蜂鸣器。<code>BEEP</code>使用了<code>SNVS_TAMPER1</code>这个PIN，打开<code>imx6ull-alientek-emmc.dts</code>，<code>SNVS_TAMPER1</code>属于<code>iomuxc_snvs</code>这个<code>pin controller</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"><br>在<code>iomuxc</code>节点的<code>imx6ul-evk</code>子节点下创建一个名为<code>“pinctrl_beep”</code>的子节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_beep: beepgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 <span class="number">0x10B0</span> <span class="comment">/* beep */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根节点<code>“/”</code>下创建<code>BEEP</code>节点：可以看到用到了引脚控制器的<code>pinctrl_beep</code>节点。同时使用gpio子系统，<code>beep-gpio</code>属性用到<code>gpio5</code>控制器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beep &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;evk-beep&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_beep&gt;;</span><br><span class="line">	beep-gpio = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>蜂鸣器使用的 PIN 为<code> SNVS_TAMPER1</code>，因此先检查 PIN 为<code>SNVS_TAMPER1 </code>这个 PIN 有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查 <code>GPIO5_IO01</code> 这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉。</p>
<p>输入<code>“make dtbs”</code>命令重新编译设备树，然后使用新编译出来的 <code>imx6ull-alientek-emmc.dtb</code> 文件启动 Linux 系统，进入<code>“/proc/device-tree”</code>目录中 查看<code>“beep”</code>节点是否存在：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_CNT			1		<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_NAME			<span class="string">&quot;beep&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPOFF 			0		<span class="comment">/* 关蜂鸣器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPON 				1		<span class="comment">/* 开蜂鸣器 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> beep_gpio;			<span class="comment">/* beep所使用的GPIO编号		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> <span class="title">beep</span>;</span>		<span class="comment">/* beep设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;beep; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">beep_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> beepstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beepstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(beepstat == BEEPON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);	<span class="comment">/* 打开蜂鸣器 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(beepstat == BEEPOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">1</span>);	<span class="comment">/* 关闭蜂鸣器 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">beep_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = beep_open,</span><br><span class="line">	.write = beep_write,</span><br><span class="line">	.release = 	beep_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">beep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：beep */</span></span><br><span class="line">	beep.nd = of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、 获取设备树中的gpio属性，得到BEEP所使用的BEEP编号 */</span></span><br><span class="line">	beep.beep_gpio = of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.beep_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get beep-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, beep.beep_gpio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO5_IO01为输出，并且输出高电平，默认关闭BEEP */</span></span><br><span class="line">	ret = gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (beep.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		beep.devid = MKDEV(beep.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(beep.devid, BEEP_CNT, BEEP_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;beep.devid, <span class="number">0</span>, BEEP_CNT, BEEP_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		beep.major = MAJOR(beep.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		beep.minor = MINOR(beep.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;beep major=%d,minor=%d\r\n&quot;</span>,beep.major, beep.minor);	</span><br><span class="line">	</span><br><span class="line">	beep.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;beep.cdev, &amp;beep_fops);</span><br><span class="line">	cdev_add(&amp;beep.cdev, beep.devid, BEEP_CNT);</span><br><span class="line"></span><br><span class="line">	beep.class = class_create(THIS_MODULE, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beep.device = device_create(beep.class, <span class="literal">NULL</span>, beep.devid, <span class="literal">NULL</span>, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">beep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;beep.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(beep.devid, BEEP_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(beep.class, beep.devid);</span><br><span class="line">	class_destroy(beep.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(beep_init);</span><br><span class="line">module_exit(beep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>核心代码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);<span class="comment">//找到设备节点</span></span><br><span class="line"><span class="number">2.</span> of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);<span class="comment">//获取beep-gpio这个引脚编号</span></span><br><span class="line"><span class="number">3.</span> gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);<span class="comment">//请求gpio并且配成输出</span></span><br><span class="line"><span class="number">4.</span> gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);<span class="comment">//设置高低电平</span></span><br></pre></td></tr></table></figure>

<p>注意这里并没有使用<code>pinctrl</code>, <code>pinctrl子系统</code>是内核启动时就对<code>pinctrl(也叫iomuxc)控制器</code>进行了配置，进行了IOMUX配置。因此<code>SNVS_TAMPER1</code>会复用成gpio模式。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<p>按键作为输入时：</p>
<pre><code>static int keyio_init(void)
&#123;
    keydev.nd = of_find_node_by_path(&quot;/key&quot;);
    if (keydev.nd== NULL) &#123;
        return -EINVAL;
    &#125;

    keydev.key_gpio = of_get_named_gpio(keydev.nd ,&quot;key-gpio&quot;, 0);
    if (keydev.key_gpio &lt; 0) &#123;
        printk(&quot;can&#39;t get key0\r\n&quot;);
        return -EINVAL;
    &#125;
    printk(&quot;key_gpio=%d\r\n&quot;, keydev.key_gpio);

    /* 初始化key所使用的IO */
    gpio_request(keydev.key_gpio, &quot;key0&quot;);	/* 请求IO */
    gpio_direction_input(keydev.key_gpio);	/* 设置为输入 */
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14m004ddsufdjffa5et" data-title="字符设备驱动-gpio子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:46:12.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/">字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</a></li>
<li><a href="#2-qu-dong-dai-ma">2 驱动代码</a></li>
<li><a href="#3-yong-hu-tai-dai-ma">3 用户态代码</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</span><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou" class="header-anchor">#</a></h1><p>以键盘<code>keyscan</code>为例，定义一个IP寄存器描述头文件，<code>IOCRREG</code>, <code>IOCWREG</code>定义了两个ioctl命令，用来读写寄存器。<code>struct msg</code>用来存放寄存器地址和值。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/1.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyscan register: addr + offset + mask */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config1			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config2			0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config3			0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config4			0xc</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_MASK				0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_OFFSET			4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_MASK			0x10</span></span><br><span class="line"><span class="keyword">struct</span> msg &#123;</span><br><span class="line">	<span class="built_in">long</span> unsigned <span class="built_in">int</span> addr;</span><br><span class="line">	unsigned <span class="built_in">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC &#x27;k&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, struct msg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, struct msg)</span></span><br></pre></td></tr></table></figure>

<h1><span id="2-qu-dong-dai-ma">2 驱动代码</span><a href="#2-qu-dong-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">keyscan_ioctl</span>(<span class="params"><span class="keyword">struct</span> file *file, unsigned <span class="built_in">int</span> cmd, unsigned <span class="built_in">long</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> msg m;</span><br><span class="line">	memset(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="keyword">void</span> __iomem* <span class="keyword">base</span> = dev-&gt;<span class="keyword">base</span>;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		m.data = readl(<span class="keyword">base</span> + m.addr);</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, read data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;m, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, write data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		writel(m.data, <span class="keyword">base</span> + m.addr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="literal">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>驱动先定义<code>IP base addr</code>，然后透过<code>ioctl</code>进行<code>arg</code>参数接收，确定<code>msg</code>中的<code>addr</code>和<code>data</code>, 接收<code>cmd</code>调用<code>writel, readl</code>进行读写。</p>
<h1><span id="3-yong-hu-tai-dai-ma">3 用户态代码</span><a href="#3-yong-hu-tai-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">clrsetbits_32</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> clear, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m.data = (m.data &amp; (~clear)) | <span class="built_in">set</span>;</span><br><span class="line">	ret = ioctl(fd, IOCWREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: write error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">read_reg</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">    m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read reg error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先实现基础读写函数进行寄存器读写，<code>reg_read</code>函数传入<code>addr</code>即可得到<code>val</code>, <code>clrsetbits_32</code>需要先读，在写入<code>val.</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_MASK(REG_NAME) keyscan_top_##REG_NAME##_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_OFFSET(REG_NAME) keyscan_top_##REG_NAME##_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_SET(REG_NAME, VAL)                                             \</span></span><br><span class="line">	clrsetbits_32(keyscan_top_<span class="meta">##REG_NAME, KEYSCAN_MASK(REG_NAME),          \</span></span><br><span class="line">			  (VAL) &lt;&lt; KEYSCAN_OFFSET(REG_NAME))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_GET(REG_NAME)                                                  \</span></span><br><span class="line">	((read_reg(keyscan_top_<span class="meta">##REG_NAME) &amp; KEYSCAN_MASK(REG_NAME)) &gt;&gt;        \</span></span><br><span class="line">	 KEYSCAN_OFFSET(REG_NAME))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/5.png" alt="image"></p>
<p>例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_GET(reg_fifo_count); </span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">read_reg(keycan_top_reg_fifo_count) &amp;</span><br><span class="line">    keycan_top_reg_fifo_count_MASK &gt;&gt; keycan_top_reg_fifo_count_OFFSET);</span><br></pre></td></tr></table></figure>

<p><code>reg_fifo</code>表示IP的某一个寄存器:</p>
<p>①<code>count</code>表示位域，因此对<code>OFFSET</code>定义成位域在该寄存器的偏移量（<code>count位域是bit[3:0]</code>）定义为0，因此<code>MASK</code>定义为<code>0xf</code>.<br>②同理<code>not_empty</code>也是一个位域，<code>bit[4]</code>，<code>OFFSET</code>定义成4，<code>MASK</code>定义成<code>0x10</code>，来屏蔽除<code>bit[4]</code>的其他bit.</p>
<p><code>KEYSCAN_GET(reg_fifo_count);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>count</code>位域的内容。<br><code>KEYSCAN_GET(reg_fifo_not_empty);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>not_empty</code>位域的内容</p>
<p>又例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_SET(reg_enable, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">clrsetbits_32(keycan_top_reg_enable, </span><br><span class="line">              keycan_top_reg_enable_MASK, </span><br><span class="line">              <span class="number">1</span> &lt;&lt; keycan_top_reg_enable_OFFSET);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/6.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_MASK			0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_OFFSET			8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_MASK			0xff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable				0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_OFFSET			16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_MASK			0x10000</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>offset</code>定义为<code>16</code>，mask定义为<code>0x10000</code>，用来屏蔽除<code>bit[16]</code>的其他位。<code>clrsetbits_32</code>会先读出该寄存器，然后对该位set1, mask掉其他位，再次写入该寄存器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" data-id="cm0dxg14o004vdsuf5q9b6s9t" data-title="字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-ioctl命令详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:11:24.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">字符设备驱动-ioctl命令详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ioctl">1 引入ioctl</a></li>
<li><a href="#2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</a></li>
<li><a href="#3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</a></li>
<li><a href="#4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</a></li>
<li><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</a><ul>
<li><a href="#5-1-app-shi-li">5.1 app示例</a></li>
<li><a href="#5-2-qu-dong-shi-li">5.2 驱动示例</a></li>
<li><a href="#5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</a><ul>
<li><a href="#5-3-1-sys-ioctl">5.3.1 sys_ioctl</a><ul>
<li><a href="#5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</a><ul>
<li><a href="#5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-yin-ru-ioctl">1 引入ioctl</span><a href="#1-yin-ru-ioctl" class="header-anchor">#</a></h1><p>一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能增添命令，通常以增设 <code>ioctl() </code>命令的方式实现。<br>对于ioctl这个系统调用接口，Linux的创始人在2.0版本之前并没有进行添加，仅有write和read两个接口，但是后来发现当需要去控制文件的某些操作的时候，很显然这两个接口根本不够用。所以才有了这个万能控制接口ioctl，但是作为Linux的创始人Linus本人一直排斥该接口，因为这个ioctl接口的在内核中的使用相当于对应用层开设了一个能够直接交互的窗口，很影响内核整体的权限控制，不过由于目前还暂时没有更好可以替代的方法，所以还是继续保留了这个接口的使用。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.png" alt="image"></p>
<h1><span id="2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</span><a href="#2-yong-hu-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, …)</span>;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数功能：<br>1.向硬件设备发送控制命令<br>2.还可以和硬件设备进行读或者写操作<br>参数：<br><code>fd：</code>文件描述符<br><code>request：</code>给硬件设备发送的控制命令<br><code>arg：</code>保存的就是用户缓冲区的首地址<br>返回值：执行成功返回0，执行失败返回-1, ioctl 最常见的<code> errorno</code> 值为<code> ENOTTY</code>（<code>error not a typewriter</code>)表示命令找不到。</p>
<h1><span id="3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</span><a href="#3-nei-he-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</span><a href="#4-ioctl-de-ming-ling-gou-cheng" class="header-anchor">#</a></h1><p> ioctl命令就是用户和驱动约定的一种协议， 理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段，如下图所示：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/4.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="built_in">dir</span>（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，</span><br><span class="line">	可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，</span><br><span class="line">	分别指示了四种访问模式：无数据、读数据、写数据、读写数据；</span><br><span class="line">2. size，涉及到 ioctl 函数第三个参数 arg ，占据14bit，指定了 arg 的数据类型及长度；</span><br><span class="line">3. <span class="built_in">type</span>（device <span class="built_in">type</span>），设备类型，占据 8 bit，可以为任意 char 型字符，</span><br><span class="line">	例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识；</span><br><span class="line">4. nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，</span><br><span class="line">	取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增</span><br></pre></td></tr></table></figure>

<p>通常而言，为了方便会使用<code>宏 _IOC() 衍生的接口</code>来直接定义 ioctl 命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ioctl.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS	8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let any architecture override either of the following before</span></span><br><span class="line"><span class="comment"> * including this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_SIZEBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_SIZEBITS	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_DIRBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_DIRBITS	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRMASK	((1 &lt;&lt; _IOC_NRBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEMASK	((1 &lt;&lt; _IOC_TYPEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEMASK	((1 &lt;&lt; _IOC_SIZEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRMASK	((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRSHIFT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direction bits, which any architecture can choose to override</span></span><br><span class="line"><span class="comment"> * before including this file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOC_WRITE means userland is writing and kernel is</span></span><br><span class="line"><span class="comment"> * reading. _IOC_READ means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_NONE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_NONE	0U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_WRITE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_WRITE	1U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_READ</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_READ	2U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPECHECK(t) (sizeof(t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to create numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOW means userland is writing and kernel is reading. _IOR</span></span><br><span class="line"><span class="comment"> * means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to decode ioctl numbers.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)		(((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)		(((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)		(((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)		(((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ...and for the drivers/sound files... */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN		(_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT		(_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT	((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK	(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT	(_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/6.png" alt="image"><br>除了<code>_IO/_IOR/_IOW/_IOW</code>等命令外，还支持反向解析 ioctl 命令的宏接口：主要就是利用Mask看是否4个位段是否越界,如果越界说明cmd构造的不合法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr) (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr) (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr) (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr) (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure>

<p>举个例子比如<img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/7.png" alt="image">，展开命令成一个<code>unsigned int</code>的 cmd整数为：(<code>字符D的ascii码为68</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&lt;&lt;<span class="number">30</span> | <span class="number">0</span>&lt;&lt;<span class="number">16</span> | <span class="number">68</span>&lt;&lt;<span class="number">8</span> | <span class="number">0x7</span>&lt;&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</span><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie" class="header-anchor">#</a></h1><h2><span id="5-1-app-shi-li">5.1 app示例</span><a href="#5-1-app-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/ioctl-test&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd, IOCINIT);</span><br><span class="line"><span class="comment">/* 往寄存器0x01写入数据0xef */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">my_msg.data = <span class="number">0xef</span>;</span><br><span class="line">ioctl(fd, IOCWREG, &amp;my_msg);</span><br><span class="line"><span class="comment">/* 读寄存器0x01 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">ret = ioctl(fd, IOCRREG, &amp;my_msg);</span><br></pre></td></tr></table></figure>
<p>构造了<code>IOCINIT</code> <code>IOCRREG</code> <code>IOCWREG</code>3个命令。</p>
<h2><span id="5-2-qu-dong-shi-li">5.2 驱动示例</span><a href="#5-2-qu-dong-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">my_msg</span>;</span></span><br><span class="line">	<span class="comment">/* 检查设备类型 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != IOC_MAGIC) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command type [%c] error!\n&quot;</span>, __func__, _IOC_TYPE(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查序数 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_NR(cmd) &gt; IOC_MAXNR) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command numer [%d] exceeded!\n&quot;</span>, __func__, _IOC_NR(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查访问模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_READ)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_WRITE, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_WRITE)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_READ, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">switch</span>(cmd) &#123; </span><br><span class="line">	<span class="comment">/* 初始化设备 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCINIT:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 读寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		msg-&gt;data = read_reg(msg-&gt;addr);</span><br><span class="line">		ret = copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;msg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 写寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		write_reg(msg-&gt;addr, msg-&gt;data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/8.png" alt="image"><br>首先定好3个命令，通过<code>arg</code>传入要写入的地址和数据or 要读的地址。然后检查<code>type</code>是否为<code>‘c’</code>, 检查命令号是否超过最大值3，检查方向是读还是写，利用<code>access_ok</code>判断用户地址是否可以访问。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/9.png" alt="image"><br>最后将用户地址arg的数据透过<code>copy_from_user</code>和<code>copy_to_user</code>进行拷贝。然后进行寄存器读写。</p>
<h2><span id="5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</span><a href="#5-3-ioctl-guo-cheng-xiang-jie" class="header-anchor">#</a></h2><p>在系统调用中，是通过<code>SWI(Software Interrupt)</code>的方式陷入内核态的, 首先通过软中断方式切换到内核态，ioctl的系统调用位于<code>arch/arm/include/asm/unistd.h</code>：</p>
<h3><span id="5-3-1-sys-ioctl">5.3.1 sys_ioctl</span><a href="#5-3-1-sys-ioctl" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl	(__NR_SYSCALL_BASE+ 54)</span></span><br></pre></td></tr></table></figure>

<p><code>arch/arm/kernel/calls.S</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 55 */</span>	CALL(sys_ioctl);</span><br></pre></td></tr></table></figure>
<p>调用<code>sys_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/include/linux.h</span><br><span class="line">	asmlinkage <span class="type">long</span> <span class="title function_">sys_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>


<p>然后调用<code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/include/linux/syscalls.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...)  SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINE3</code><br><code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code>就是<code>sys_ioctl</code>的定义:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/10.png" alt="image"><br><code>fget_light() </code>以及 <code>security_file_ioctl() </code>就是检验可操作安全性，所以<code>sys_ioctl</code>更多是调用更深一层接口 <code>do_vfs_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="type">int</span> error = -EBADF;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	filp = fget_light(fd, &amp;fput_needed);<span class="comment">//由fd得带filp指针</span></span><br><span class="line">	<span class="keyword">if</span> (!filp)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = security_file_ioctl(filp, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line">	error = do_vfs_ioctl(filp, fd, cmd, arg);</span><br><span class="line"> out_fput:</span><br><span class="line">	fput_light(filp, fput_needed);</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</span><a href="#5-3-1-1-do-vfs-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FIOCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONBIO:</span><br><span class="line">		error = ioctl_fionbio(filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOASYNC:</span><br><span class="line">		error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOQSIZE:</span><br><span class="line">		<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||</span><br><span class="line">			S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">			<span class="type">loff_t</span> res = inode_get_bytes(inode);</span><br><span class="line">			error = copy_to_user(argp, &amp;res, <span class="keyword">sizeof</span>(res)) ?</span><br><span class="line">					-EFAULT : <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOTTY;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIFREEZE:</span><br><span class="line">		error = ioctl_fsfreeze(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FITHAW:</span><br><span class="line">		error = ioctl_fsthaw(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FS_IOC_FIEMAP:</span><br><span class="line">		<span class="keyword">return</span> ioctl_fiemap(filp, arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIGETBSZ:</span><br><span class="line">		<span class="keyword">return</span> put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))<span class="comment">//是否为常规文件若是常规文件</span></span><br><span class="line">			error = file_ioctl(filp, cmd, arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = vfs_ioctl(filp, cmd, arg);<span class="comment">//调用vfs_ioctl</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</span><a href="#5-3-1-1-1-vfs-ioctl" class="header-anchor">#</a></h5><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">unlocked_ioctl</span><br><span class="line">	error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<span class="comment">//调用unlocked_ioctl()</span></span><br><span class="line">	<span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">		error = -EINVAL;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>最终调用对应驱动人员自己fops的unlocked_ioctl函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" data-id="cm0dxg14m004gdsuf9xai1y0t" data-title="字符设备驱动-ioctl命令详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.09px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.73px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.64px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14.55px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>