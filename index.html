<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-9-中断子系统-GICv2架构解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2024-08-06T16:40:22.000Z" itemprop="datePublished">2024-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">字符设备驱动-9-中断子系统-GICv2架构解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</a><ul>
<li><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</a></li>
<li><a href="#1-1-gic-lei-xing">1.1 GIC 类型</a></li>
<li><a href="#1-2-zhong-duan-id">1.2 中断 ID</a></li>
<li><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</a><ul>
<li><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</a></li>
<li><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</a></li>
<li><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</a></li>
<li><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</a></li>
<li><a href="#1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</a></li>
</ul>
</li>
<li><a href="#1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</a></li>
<li><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</a></li>
<li><a href="#1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</a></li>
<li><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</a><ul>
<li><a href="#1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</a><ul>
<li><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</a><ul>
<li><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</a></li>
<li><a href="#1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</a></li>
<li><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</a></li>
<li><a href="#1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</a></li>
<li><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</a></li>
<li><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</a></li>
<li><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</a></li>
<li><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</a></li>
<li><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</a></li>
<li><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</a></li>
<li><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</a></li>
<li><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</a></li>
</ul>
</li>
<li><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</a><ul>
<li><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</a></li>
<li><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</a></li>
<li><a href="#1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</a></li>
<li><a href="#1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</a></li>
<li><a href="#1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</a><ul>
<li><a href="#2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</a></li>
</ul>
</li>
<li><a href="#3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</a><ul>
<li><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</a></li>
<li><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</a></li>
<li><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</a><ul>
<li><a href="#3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</a><ul>
<li><a href="#3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</a></li>
<li><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</a></li>
<li><a href="#3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</a><ul>
<li><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</a></li>
<li><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</a><ul>
<li><a href="#3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</a><ul>
<li><a href="#3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</a><ul>
<li><a href="#3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</a><ul>
<li><a href="#3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</a></li>
</ul>
</li>
<li><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</a><ul>
<li><a href="#4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</a></li>
<li><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</a><ul>
<li><a href="#4-2-1-dts-miao-shu">4.2.1 dts描述</a></li>
<li><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-armv7-32-wei-gicv2-jie-shao">1 armv7 32位GICv2介绍</span><a href="#1-armv7-32-wei-gicv2-jie-shao" class="header-anchor">#</a></h1><p>armv7 32位 gic采用v2版本，参考手册 <a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0048/bb/?lang=en">https://developer.arm.com/documentation/ihi0048/bb/?lang=en</a></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/1-2.png" alt="image"></p>
<p> <code>GIC400 </code>就是v2版本的中断控制器 IP 核，当 GIC 接收到外部中断信号以后就会报给 ARM 内核。框架如下：<br> <img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<p>GIC 架构分为了两个逻辑块：<code>Distributor</code> 和 <code>CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h2><span id="1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan">1.0 分发器端和 CPU 接口端</span><a href="#1-0-fen-fa-qi-duan-he-cpu-jie-kou-duan" class="header-anchor">#</a></h2><ol>
<li><p>分发器用来全局中断使能控制，每一个中断使能开关，中断优先级，外部中断触发方式（边沿触发、电平触发）等。外设-&gt;分发器会设置成<code>pending</code>（或者<code>active and pending</code>状态），这时分发器传递优先级最高的pending中断给cpu 接收端。</p>
</li>
<li><p>cpu接收端用来接收中断信号汇报给cpu, 如：应答中断，通知中断处理完成，定义抢占策略，设置优先级掩码，当多个中断到来选择最高优先级的中断号。</p>
<p> 例如：I.MX6U给了一个<code> core_ca7.h</code>定义了GIC的所有寄存器。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* GIC 寄存器描述结构体，</span></span><br><span class="line"><span class="comment">* GIC 分为分发器端和 CPU 接口端</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="comment">/* 分发器端寄存器 */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED0[<span class="number">1024</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_CTLR; <span class="comment">/* Offset: 0x1000 (R/W) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_TYPER; <span class="comment">/* Offset: 0x1004 (R/ ) */</span></span><br><span class="line">      _IM <span class="type">uint32_t</span> D_IIDR; <span class="comment">/* Offset: 0x1008 (R/ ) */</span></span><br><span class="line">      <span class="type">int32_t</span> RESERVED1[<span class="number">29</span>];</span><br><span class="line">      _IOM <span class="type">uint32_t</span> D_IGROUPR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1080 - 0x0BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED2[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1100 - 0x13C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED3[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICENABLER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1180 - 0x1BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED4[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1200 - 0x23C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED5[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICPENDR[<span class="number">16</span>]; <span class="comment">/* Offset: 0x1280 - 0x2BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED6[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ISACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1300 - 0x33C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED7[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICACTIVER[<span class="number">16</span>];<span class="comment">/* Offset: 0x1380 - 0x3BC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED8[<span class="number">16</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_IPRIORITYR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1400 - 0x5FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED9[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_ITARGETSR[<span class="number">512</span>];<span class="comment">/* Offset: 0x1800 - 0x9FC (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED10[<span class="number">128</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> D_ICFGR[<span class="number">32</span>]; <span class="comment">/* Offset: 0x1C00 - 0xC7C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED11[<span class="number">32</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PPISR; <span class="comment">/* Offset: 0x1D00 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_SPISR[<span class="number">15</span>]; <span class="comment">/* Offset: 0x1D04 - 0xD3C (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED12[<span class="number">112</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> D_SGIR; <span class="comment">/* Offset: 0x1F00 ( /W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED13[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_CPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F10 - 0xF1C (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint8_t</span> D_SPENDSGIR[<span class="number">16</span>];<span class="comment">/* Offset: 0x1F20 - 0xF2C (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED14[<span class="number">40</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR4; <span class="comment">/* Offset: 0x1FD0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR5; <span class="comment">/* Offset: 0x1FD4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR6; <span class="comment">/* Offset: 0x1FD8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR7; <span class="comment">/* Offset: 0x1FDC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR0; <span class="comment">/* Offset: 0x1FE0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR1; <span class="comment">/* Offset: 0x1FE4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR2; <span class="comment">/* Offset: 0x1FE8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_PIDR3; <span class="comment">/* Offset: 0x1FEC (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR0; <span class="comment">/* Offset: 0x1FF0 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR1; <span class="comment">/* Offset: 0x1FF4 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR2; <span class="comment">/* Offset: 0x1FF8 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> D_CIDR3; <span class="comment">/* Offset: 0x1FFC (R/ ) */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* CPU 接口端寄存器 */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_CTLR; <span class="comment">/* Offset: 0x2000 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_PMR; <span class="comment">/* Offset: 0x2004 (R/W) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_BPR; <span class="comment">/* Offset: 0x2008 (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IAR; <span class="comment">/* Offset: 0x200C (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_EOIR; <span class="comment">/* Offset: 0x2010 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_RPR; <span class="comment">/* Offset: 0x2014 (R/ ) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_HPPIR; <span class="comment">/* Offset: 0x2018 (R/ ) */</span></span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_ABPR; <span class="comment">/* Offset: 0x201C (R/W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AIAR; <span class="comment">/* Offset: 0x2020 (R/ ) */</span></span><br><span class="line">      __OM <span class="type">uint32_t</span> C_AEOIR; <span class="comment">/* Offset: 0x2024 ( /W) */</span></span><br><span class="line">      __IM <span class="type">uint32_t</span> C_AHPPIR; <span class="comment">/* Offset: 0x2028 (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED15[<span class="number">41</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_APR0; <span class="comment">/* Offset: 0x20D0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED16[<span class="number">3</span>];</span><br><span class="line">      __IOM <span class="type">uint32_t</span> C_NSAPR0; <span class="comment">/* Offset: 0x20E0 (R/W) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED17[<span class="number">6</span>];</span><br><span class="line">      __IM <span class="type">uint32_t</span> C_IIDR; <span class="comment">/* Offset: 0x20FC (R/ ) */</span></span><br><span class="line">      <span class="type">uint32_t</span> RESERVED18[<span class="number">960</span>];</span><br><span class="line">      __OM <span class="type">uint32_t</span> C_DIR; <span class="comment">/* Offset: 0x3000 ( /W) */</span></span><br><span class="line">  &#125; GIC_Type;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="1-1-gic-lei-xing">1.1 GIC 类型</span><a href="#1-1-gic-lei-xing" class="header-anchor">#</a></h2><p>GIC 将众多的中断源分为分为三类：<br>①、<code>SPI</code>(<code>Shared Peripheral Interrupt</code>),共享中断，顾名思义，所有 Core 共享的中断，这个是最常见的，那些外部中断都属于 SPI 中断 。<br>②、<code>PPI</code>(<code>Private Peripheral Interrupt)</code>，私有中断，我们说了 GIC 是支持多核的，每个核肯定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中断。<br>③、<code>SGI</code>(<code>Software-generated Interrupt</code>)，软件中断，由软件触发引起的中断，通过向寄存器<code>GICD_SGIR</code> 写入数据来触发，系统会使用 SGI 中断来完成多核之间的通信。</p>
<h2><span id="1-2-zhong-duan-id">1.2 中断 ID</span><a href="#1-2-zhong-duan-id" class="header-anchor">#</a></h2><p>为了区分这些不同的中断源肯定要给他们分配一个唯一 ID，这些 ID 就是中断 ID。每一个 CPU 最多支持 1020 个中断 ID，<code>ID0~ID1019</code> 中断使能和禁止。这 1020 个 ID 包含了 PPI、SPI 和 SGI。</p>
<pre><code>ID0~ID15：这 16 个 ID 分配给 SGI。
ID16~ID31：这 16 个 ID 分配给 PPI。
ID32~ID1019：这 988 个 ID 分配给 SPI。
</code></pre>
<p>例如：I.MX6U 的总共使用了 128 个中断 ID，加上前面属于 PPI 和 SGI 的 32 个 ID，I.MX6U 的中断源共有 <code>128+32=160</code>，那么irq为0的中断ID即为32。<br>个。NXP 官方 SDK中的文件 <code>MCIMX6Y2C.h</code>定义了160个中断ID。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUMBER_OF_INT_VECTORS 160 <span class="comment">/* 中断源 160 个，SGI+PPI+SPI*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">IRQn</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Auxiliary constants */</span></span><br><span class="line">	otAvail_IRQn = <span class="number">-128</span>,</span><br><span class="line">	<span class="comment">/* Core interrupts */</span></span><br><span class="line">	oftware0_IRQn = <span class="number">0</span>, </span><br><span class="line">	oftware1_IRQn = <span class="number">1</span>, </span><br><span class="line">	Software2_IRQn = <span class="number">2</span>, </span><br><span class="line">	Software3_IRQn = <span class="number">3</span>, </span><br><span class="line">	Software4_IRQn = <span class="number">4</span>, </span><br><span class="line">	Software5_IRQn = <span class="number">5</span>, </span><br><span class="line">	Software6_IRQn = <span class="number">6</span>, </span><br><span class="line">	Software7_IRQn = <span class="number">7</span>, </span><br><span class="line">	Software8_IRQn = <span class="number">8</span>, </span><br><span class="line">	Software9_IRQn = <span class="number">9</span>, </span><br><span class="line">	Software10_IRQn = <span class="number">10</span>, </span><br><span class="line">	Software11_IRQn = <span class="number">11</span>, </span><br><span class="line">	Software12_IRQn = <span class="number">12</span>, </span><br><span class="line">	Software13_IRQn = <span class="number">13</span>, </span><br><span class="line">	Software14_IRQn = <span class="number">14</span>, </span><br><span class="line">	Software15_IRQn = <span class="number">15</span>, </span><br><span class="line">	VirtualMaintenance_IRQn = <span class="number">25</span>, </span><br><span class="line">	HypervisorTimer_IRQn = <span class="number">26</span>, </span><br><span class="line">	VirtualTimer_IRQn = <span class="number">27</span>, </span><br><span class="line">	LegacyFastInt_IRQn = <span class="number">28</span>, </span><br><span class="line">	SecurePhyTimer_IRQn = <span class="number">29</span>, </span><br><span class="line">	NonSecurePhyTimer_IRQn = <span class="number">30</span>, </span><br><span class="line">	LegacyIRQ_IRQn = <span class="number">31</span>, </span><br><span class="line">	<span class="comment">/* Device specific interrupts */</span></span><br><span class="line">	IOMUXC_IRQn = <span class="number">32</span>, </span><br><span class="line">	DAP_IRQn = <span class="number">33</span>, </span><br><span class="line">	SDMA_IRQn = <span class="number">34</span>, </span><br><span class="line">	TSC_IRQn = <span class="number">35</span>, </span><br><span class="line">	SNVS_IRQn = <span class="number">36</span>, </span><br><span class="line">	...... ...... </span><br><span class="line">&#125; IRQn_Type;</span><br></pre></td></tr></table></figure>



<h2><span id="1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu">1.3 中断配置(1.7有详细描述)</span><a href="#1-3-zhong-duan-pei-zhi-1-7-you-xiang-xi-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng">1.3.1 IRQ 和 FIQ 总中断使能</span><a href="#1-3-1-irq-he-fiq-zong-zhong-duan-shi-neng" class="header-anchor">#</a></h3><p>“<strong>CPSR程序状态寄存器</strong>”已经讲过了，寄存器 CPSR 的 I&#x3D;1 禁止 IRQ，当 I&#x3D;0 使<br>能 IRQ；F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。我们还有更简单的指令来完成 IRQ 或者 FIQ 的使能和<br>禁止:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cpsid i</td>
<td>禁止 IRQ 中断。</td>
</tr>
<tr>
<td>cpsie i</td>
<td>使能 IRQ 中断。</td>
</tr>
<tr>
<td>cpsid f</td>
<td>禁止 FIQ 中断。</td>
</tr>
<tr>
<td>cpsie f</td>
<td>使能 FIQ 中断。</td>
</tr>
</tbody></table>
<h3><span id="1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi">1.3.2 <code>ID0~ID1019</code> 中断使能和禁止</span><a href="#1-3-2-id0-id1019-zhong-duan-shi-neng-he-jin-zhi" class="header-anchor">#</a></h3><p>前面讲到中断ID有<code> ID0~ID1019</code>， GIC 寄存器 <code>GICD_ISENABLERn </code>和 <code>GICD_ ICENABLERn </code>用来完成外部中断的使能和禁止，对于 Cortex-A7 内核来说中断 ID 只使用了 512 个。<br>一共16组<code>GICD_ISENABLER</code>和<code>GICD_ISENABLER</code>，其中<code>GICD_ISENABLER0 </code>的 <code>bit[15:0]</code>对应<code>ID15~0</code> 的 SGI 中断，<code>GICD_ISENABLER0 </code>的 <code>bit[31:16]</code>对应<code>ID31~16</code>的 PPI 中断。剩下的<code>GICD_ISENABLER1~GICD_ISENABLER15 </code>就是控制 SPI 中断的。</p>
<h3><span id="1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr">1.3.3 中断优先级数量 GICC_PMR</span><a href="#1-3-3-zhong-duan-you-xian-ji-shu-liang-gicc-pmr" class="header-anchor">#</a></h3><p>Cortex-A7 GIC 控制器最多可以支持 256 个优先级，数字越小，优先级越高！Cortex-A7 选择了 32 个优先级，<code>GICC_PMR</code> 寄存器，此寄存器用来决定使用几级优先级,<code>GICC_PMR</code> 寄存器只有低 8 位有效，这 8 位最多可以设置 256 个优先级:<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/4.png" alt="image"><br>I.MX6U 为例 Cortex-A7内核，所以支持 32 个优先级，因此 GICC_PMR 要设置为<code> 0b11111000</code>。</p>
<h3><span id="1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr">1.3.4 中断抢占优先级和子优先级位数 GICC_BPR</span><a href="#1-3-4-zhong-duan-qiang-zhan-you-xian-ji-he-zi-you-xian-ji-wei-shu-gicc-bpr" class="header-anchor">#</a></h3><p>寄存器 <code>GICC_BPR </code>只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不同：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/5.png" alt="image"><br>比如 I.MX6U 的优先级位数为 5(32 个优先级)，所以可以设置 Binary point 为 2，表示 5 个优先级位全部为抢占优先级。</p>
<h3><span id="1-3-5-zhong-duan-priority-d-ipriorityr">1.3.5 中断priority D_IPRIORITYR</span><a href="#1-3-5-zhong-duan-priority-d-ipriorityr" class="header-anchor">#</a></h3><p>Cortex-A7 使用了 512 个中断 ID，每个中断 ID 配有一个优先级寄存器，所以一共有 512 个 <code>D_IPRIORITYR </code>寄存器。如果优先级个数为 32 的话，使用寄存器 <code>D_IPRIORITYR 的 bit7:4 </code>来设置优先级，也就是说实际的优先级要左移 3 位。比如要设置ID40 中断的优先级为 5，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GICD_IPRIORITYR[<span class="number">40</span>] = <span class="number">5</span> &lt;&lt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="1-4-zhong-duan-zhuang-tai-ji">1.4 中断状态机</span><a href="#1-4-zhong-duan-zhuang-tai-ji" class="header-anchor">#</a></h2><p>① <strong>非活动状态（Inactive）</strong>：这意味着该中断未触发。 </p>
<p>② <strong>挂起（Pending）</strong>：这意味着中断源已被触发，但正在等待CPU核处理。待处理的中断要通过转发到CPU接口单元，然后再由CPU接口单元转发到内核。</p>
<p>③ <strong>活动（Active）</strong>：描述了一个已被内核接收并正在处理的中断。 </p>
<p>④ <strong>活动和挂起（Active and pending）</strong>：描述了一种情况，其中CPU核正在为中断服务，而GIC又收到来自同一源的中断。</p>
<h2><span id="1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3">1.5 GIC初始化硬件流程（软件流程见3.3）</span><a href="#1-5-gic-chu-shi-hua-ying-jian-liu-cheng-ruan-jian-liu-cheng-jian-3-3" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/6.png" alt="image"></p>
<h2><span id="1-6-gic-zhong-duan-chu-li">1.6 GIC中断处理</span><a href="#1-6-gic-zhong-duan-chu-li" class="header-anchor">#</a></h2><p>当CPU核接收到中断时，<code>cpu interface</code>中有<code>Interrupt Acknowledge Register</code>可以读，获取中断ID。并且标记为active状态。</p>
<p>当对应的中断服务程序执行完，会将中断ID写入<code>CPU interface</code>模块中的<code>End of Interrupt register</code>。标记为<code>inactive</code>或<code>pending</code>（如果状态为<code>inactive and pending</code>）。</p>
<h2><span id="1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao">1.7 GIC控制器寄存器介绍</span><a href="#1-7-gic-kong-zhi-qi-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><p>前面讲了GIC 架构分为了两个逻辑块：<code>Distributor </code>和<code> CPU Interface</code>，也就是分发器端和 CPU 接口端。</p>
<h3><span id="1-7-1-gic-de-nei-cun-ying-she">1.7.1 GIC的内存映射</span><a href="#1-7-1-gic-de-nei-cun-ying-she" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/7.png" alt="image"><br>GIC基地址偏移0x1000是分发器 block, 偏移0x2000是CPU 接口端 block。</p>
<h4><span id="1-7-1-1-fen-fa-qi-ji-cun-qi">1.7.1.1 分发器寄存器</span><a href="#1-7-1-1-fen-fa-qi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/8.png" alt="image"></p>
<h5><span id="1-7-1-1-1-gicd-ctlr-distributor-control-register">1.7.1.1.1 GICD_CTLR(Distributor Control Register)</span><a href="#1-7-1-1-1-gicd-ctlr-distributor-control-register" class="header-anchor">#</a></h5><p><code>Distributor Control Register</code>，分发器控制寄存器。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/9.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">EnableGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 1中断从Distributor转发到CPU interfaces 0：group 1中断不转发 1：根据优先级规则转发Group 1中断</td>
</tr>
<tr>
<td align="left">0</td>
<td align="left">EnableGrp0</td>
<td align="left">R&#x2F;W</td>
<td align="left">用于将pending Group 0中断从Distributor转发到CPU interfaces 0：group 0中断不转发 1：根据优先级规则转发Group 0中断</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-2-gicd-typer-controller-type-register">1.7.1.1.2 GICD_TYPER(Controller Type Register)</span><a href="#1-7-1-1-2-gicd-typer-controller-type-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">15:11</td>
<td align="left">LSPI</td>
<td align="left">R</td>
<td align="left">如果GIC实现了安全扩展，则此字段的值是已实现的可锁定SPI的最大数量，范围为0（0b00000）到31（0b11111）。 如果此字段为0b00000，则GIC不会实现配置锁定。 如果GIC没有实现安全扩展，则保留该字段。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">SecurityExtn</td>
<td align="left">R</td>
<td align="left">表示GIC是否实施安全扩展： 0未实施安全扩展； 1实施了安全扩展</td>
</tr>
<tr>
<td align="left">7:5</td>
<td align="left">CPUNumber</td>
<td align="left">R</td>
<td align="left">表示已实现的CPU interfaces的数量。 已实现的CPU interfaces数量比该字段的值大1。 例如，如果此字段为0b011，则有四个CPU interfaces。</td>
</tr>
<tr>
<td align="left">4:0</td>
<td align="left">ITLinesNumber</td>
<td align="left">R</td>
<td align="left">表示GIC支持的最大中断数。 如果ITLinesNumber &#x3D; N，则最大中断数为32*(N+1)。 中断ID的范围是0到（ID的数量– 1）。 例如：0b00011最多128条中断线，中断ID 0-127。 中断的最大数量为1020（0b11111）。 无论此字段定义的中断ID的范围如何，都将中断ID 1020-1023保留用于特殊目的</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-3-gicd-iidr-implementer-identification-register">1.7.1.1.3 GICD_IIDR(Implementer Identification Register)</span><a href="#1-7-1-1-3-gicd-iidr-implementer-identification-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:24</td>
<td align="left">ProductID</td>
<td align="left">R</td>
<td align="left">产品标识ID</td>
</tr>
<tr>
<td align="left">23:20</td>
<td align="left">保留</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">19:16</td>
<td align="left">Variant</td>
<td align="left">R</td>
<td align="left">通常是产品的主要版本号</td>
</tr>
<tr>
<td align="left">15:12</td>
<td align="left">Revision</td>
<td align="left">R</td>
<td align="left">通常此字段用于区分产品的次版本号</td>
</tr>
<tr>
<td align="left">11:0</td>
<td align="left">Implementer</td>
<td align="left">R</td>
<td align="left">含有实现这个GIC的公司的JEP106代码； [11:8]：JEP106 continuation code，对于ARM实现，此字段为0x4； [7]：始终为0； [6:0]：实现者的JEP106code，对于ARM实现，此字段为0x3B</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-1-4-gicd-igrouprn-group-registers">1.7.1.1.4 GICD_IGROUPRn(Group Registers)</span><a href="#1-7-1-1-4-gicd-igrouprn-group-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Group status bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">组状态位，对于每个位： 0：相应的中断为Group 0； 1：相应的中断为Group 1。</td>
</tr>
</tbody></table>
<p>对于一个中断，如何设置它的Group ？首先找到对应的<code>GICD_IGROUPRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一位。</p>
<p>对于<code>interrtups ID m</code>，如下计算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n = m DIV <span class="number">32</span>，GICD_IGROUPRn里的n就确定了；</span><br><span class="line">GICD_IGROUPRn在GIC内部的偏移地址是多少？<span class="number">0x080</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-5-gicd-isenablern-set-enable-registers">1.7.1.1.5 GICD_ISENABLERn(Set-Enable Registers)</span><a href="#1-7-1-1-5-gicd-isenablern-set-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/13.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：使能转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-6-gicd-icenablern-clear-enable-registers">1.7.1.1.6 GICD_ICENABLERn(Clear-Enable Registers)</span><a href="#1-7-1-1-6-gicd-icenablern-clear-enable-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/14.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-enable bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于SPI和PPI类型的中断，每一位控制对应中断的转发行为：从Distributor转发到CPU interface： 读： 0：表示当前是禁止转发的； 1：表示当前是使能转发的； 写： 0：无效 1：禁止转发</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICENABLERn</code>并确定相应的位？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">32</span>，GICD_ISENABLERn里的n就确定了；</span><br><span class="line">GICD_ISENABLERn在GIC内部的偏移地址是多少？<span class="number">0x100</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_ISENABLERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod <span class="number">32</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-7-gicd-isactivern-set-active-registers">1.7.1.1.7 GICD_ISACTIVERn(Set-Active Registers)</span><a href="#1-7-1-1-7-gicd-isactivern-set-active-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/15.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Set-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为active状态，如果中断已处于Active状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ISACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ISACTIVERn里的n就确定了；</span><br><span class="line">GICD_ISACTIVERn在GIC内部的偏移地址是多少？0x300+(4*n)</span><br><span class="line">使用GICD_ISACTIVERn 中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-8-gicd-icactivern-clear-active-registers">1.7.1.1.8 GICD_ICACTIVERn(Clear-Active Registers)</span><a href="#1-7-1-1-8-gicd-icactivern-clear-active-registers" class="header-anchor">#</a></h5><table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">31:0</td>
<td align="left">Clear-active bits</td>
<td align="left">R&#x2F;W</td>
<td align="left">读： 0：表示相应中断不是active状态； 1：表示相应中断是active状态； 写： 0：无效 1：把相应中断设置为deactive状态，如果中断已处于dective状态，则写入无效</td>
</tr>
</tbody></table>
<p>对于一个中断，如何找到<code>GICD_ICACTIVERn</code>并确定相应的位？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 32，GICD_ICACTIVERn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？0x380+(4*n)</span><br><span class="line">使用GICD_ICACTIVERn中哪一位来表示interrtups ID m？</span><br><span class="line">bit = m mod 32。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-9-gicd-ipriorityrn-priority-registers">1.7.1.1.9 GICD_IPRIORITYRn(Priority Registers)</span><a href="#1-7-1-1-9-gicd-ipriorityrn-priority-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/16.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">Priority, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：它的优先级。 每个优先级字段都对应一个优先级值，值越小，相应中断的优先级越高</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">Priority, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">Priority, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">Priority, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的优先级(<code>Priority</code>)，首先找到对应的<code>GICD_IPRIORITYRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">4</span>，GICD_IPRIORITYRn里的n就确定了；</span><br><span class="line">GICD_IPRIORITYRn在GIC内部的偏移地址是多少？<span class="number">0x400</span>+(<span class="number">4</span>*n)</span><br><span class="line">使用GICD_IPRIORITYRn中<span class="number">4</span>个字节中的哪一个来表示interrtups ID m的优先级？</span><br><span class="line">byte offset = m mod <span class="number">4</span>。</span><br><span class="line">byte offset <span class="number">0</span>对应寄存器里的[<span class="number">7</span>:<span class="number">0</span>]；</span><br><span class="line">byte offset <span class="number">1</span>对应寄存器里的[<span class="number">15</span>:<span class="number">8</span>]；</span><br><span class="line">byte offset <span class="number">2</span>对应寄存器里的[<span class="number">23</span>:<span class="number">16</span>]；</span><br><span class="line">byte offset <span class="number">3</span>对应寄存器里的[<span class="number">31</span>:<span class="number">24</span>]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-10-gicd-itargetsrn-processor-targets-registers">1.7.1.1.10 GICD_ITARGETSRn(Processor Targets Registers)</span><a href="#1-7-1-1-10-gicd-itargetsrn-processor-targets-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/17.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">位域</td>
<td align="left">名</td>
<td align="left">读写</td>
<td align="left">描述</td>
</tr>
<tr>
<td align="left">31:24</td>
<td align="left">CPU targets, byte offset 3</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的8位数据用来描述：这个中断可以发给哪些CPU。 处理器编号从0开始，8位数里每个位均指代相应的处理器。 例如，值0x3表示将中断发送到处理器0和1。 当读取GICD_ITARGETSR0～GICD_ITARGETSR7时，读取里面任意字节，返回的都是执行这个读操作的CPU的编号。</td>
</tr>
<tr>
<td align="left">23:16</td>
<td align="left">CPU targets, byte offset 2</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">15:8</td>
<td align="left">CPU targets, byte offset 1</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">7:0</td>
<td align="left">CPU targets, byte offset 0</td>
<td align="left">R&#x2F;W</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>如何设置它的目杯CPU？优先级(<code>Priority</code>)，首先找到对应的<code>GICD_ITARGETSRn</code>寄存器，即n是多少？还要确定使用这个寄存器里哪一个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV 4，GICD_ITARGETSRn里的n就确定了；</span><br><span class="line">GICD_ITARGETSRn在GIC内部的偏移地址是多少？0x800+(4*n)</span><br><span class="line">使用GICD_ITARGETSRn中4个字节中的哪一个来表示interrtups ID m的目标CPU？</span><br><span class="line">byte offset = m mod 4。</span><br><span class="line">byte offset 0对应寄存器里的[7:0]；</span><br><span class="line">byte offset 1对应寄存器里的[15:8]；</span><br><span class="line">byte offset 2对应寄存器里的[23:16]；</span><br><span class="line">byte offset 3对应寄存器里的[31:24]。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-11-gicd-icfgrn-configuration-registers">1.7.1.1.11 GICD_ICFGRn(Configuration Registers)</span><a href="#1-7-1-1-11-gicd-icfgrn-configuration-registers" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/18.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[2F+1:2F]</td>
<td align="left">Int_config, field F</td>
<td align="left">R&#x2F;W</td>
<td align="left">对于每一个中断，都有对应的2位数据用来描述：它的边沿触发，还是电平触发。 对于Int_config [1]，即高位[2F + 1]，含义为： 0：相应的中断是电平触发； 1：相应的中断是边沿触发。 对于Int_config [0]，即低位[2F]，是保留位。</td>
</tr>
</tbody></table>
<p>如何找到<code>GICD_ICFGRn</code>并确定相应的位域F？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于interrtups ID m，如下计算：</span><br><span class="line">n = m DIV <span class="number">16</span>，GICD_ICFGRn里的n就确定了；</span><br><span class="line">GICD_ICACTIVERn 在GIC内部的偏移地址是多少？<span class="number">0xC00</span>+(<span class="number">4</span>*n)</span><br><span class="line">F = m mod <span class="number">16</span>。</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register">1.7.1.1.12 ICPIDR2(Identification registers: Peripheral ID2 Register)</span><a href="#1-7-1-1-12-icpidr2-identification-registers-peripheral-id2-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/19.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
<tr>
<td align="left">[7:4]</td>
<td align="left">ArchRev</td>
<td align="left">R</td>
<td align="left">该字段的值取决于GIC架构版本： 0x1：GICv1； 0x2：GICv2。</td>
</tr>
<tr>
<td align="left">[3:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">由实现定义</td>
</tr>
</tbody></table>
<h4><span id="1-7-1-2-cpu-jie-kou-duan-ji-cun-qi">1.7.1.2 cpu接口端寄存器</span><a href="#1-7-1-2-cpu-jie-kou-duan-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/20.png" alt="image"></p>
<h5><span id="1-7-1-2-1-gicc-ctlr-cpu-interface-control-register">1.7.1.2.1 GICC_CTLR(CPU Interface Control Register)</span><a href="#1-7-1-2-1-gicc-ctlr-cpu-interface-control-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/21.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:10]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[9]</td>
<td align="left">EOImodeNS</td>
<td align="left">R&#x2F;W</td>
<td align="left">控制对GICC_EOIR和GICC_DIR寄存器的非安全访问： 0：GICC_EOIR具有降低优先级和deactivate中断的功能； 对GICC_DIR的访问是未定义的。 1：GICC_EOIR仅具有降低优先级功能； GICC_DIR寄存器具有deactivate中断功能。</td>
</tr>
<tr>
<td align="left">[8:7]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[6]</td>
<td align="left">IRQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的IRQ信号被禁用时，该位控制是否向处理器发送bypass IRQ信号： 0：将bypass IRQ信号发送给处理器； 1：将bypass IRQ信号不发送到处理器。</td>
</tr>
<tr>
<td align="left">[5]</td>
<td align="left">FIQBypDisGrp1</td>
<td align="left">R&#x2F;W</td>
<td align="left">当CPU interface的FIQ信号被禁用时，该位控制是否向处理器发送bypass FIQ信号： 0：将bypass FIQ信号发送给处理器； 1：旁路FIQ信号不发送到处理器</td>
</tr>
<tr>
<td align="left">[4:1]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">使能CPU interface向连接的处理器发出的组1中断的信号: 0：禁用中断信号 1：使能中断信号</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-2-gicc-pmr-priority-mask-register">1.7.1.2.2 GICC_PMR(Priority Mask Register)</span><a href="#1-7-1-2-2-gicc-pmr-priority-mask-register" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/22.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:8]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[7:0]</td>
<td align="left">-</td>
<td align="left">R&#x2F;W</td>
<td align="left">优先级高于这个值的中断，才会发送给CPU</td>
</tr>
</tbody></table>
<p><code>[7:0]</code>共8位，可以表示256个优先级。但是某些芯片里的GIC支持的优先级少于256个，则某些位为RAZ &#x2F; WI，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果有128个级别，则寄存器中bit[0] = 0b0，即使用[7:1]来表示优先级；</span><br><span class="line">如果有64个级别，则寄存器中bit[1:0] = 0b00，即使用[7:2]来表示优先级；</span><br><span class="line">如果有32个级别，则寄存器中bit[2:0] = 0b000，即使用[7:3]来表示优先级；</span><br><span class="line">如果有16个级别，则寄存器中bit[3:0] = 0b0000，即使用[7:4]来表示优先级；</span><br></pre></td></tr></table></figure>

<h5><span id="1-7-1-2-3-gicc-bpr-binary-point-register">1.7.1.2.3 GICC_BPR(Binary Point Register)</span><a href="#1-7-1-2-3-gicc-bpr-binary-point-register" class="header-anchor">#</a></h5><p>此寄存器用来把8位的优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:3]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[2:0]</td>
<td align="left">Binary point</td>
<td align="left">R&#x2F;W</td>
<td align="left">此字段的值控制如何将8bit中断优先级字段拆分为组优先级和子优先级，组优先级用来决定中断抢占。 更多信息还得看看GIC手册。</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-4-gicc-iar-acknowledge-register">1.7.1.2.4 GICC_IAR(Acknowledge Register)</span><a href="#1-7-1-2-4-gicc-iar-acknowledge-register" class="header-anchor">#</a></h5><p>读此寄存器，获得当前中断的<code>interrtup ID</code>。</p>
<p><code>GICC_IAR</code>寄存器描述来自<code>《ARM Generic Interrupt Controller Architecture Specification.pdf》</code>,它用来表示中断ID号。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>处理完具体的中断处理函数，需要将<code>GICC_IAR</code>寄存器的值写入<code>GICC_EOIR</code>寄存器中。</p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">R</td>
<td align="left">对于SGI类中断，它表示谁发出了中断。例如，值为3表示该请求是通过对CPU interface 3上的GICD_SGIR的写操作生成的。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">Interrupt ID</td>
<td align="left">R</td>
<td align="left">中断ID</td>
</tr>
</tbody></table>
<h5><span id="1-7-1-2-5-gicc-eoir-interrupt-register">1.7.1.2.5 GICC_EOIR(Interrupt Register)</span><a href="#1-7-1-2-5-gicc-eoir-interrupt-register" class="header-anchor">#</a></h5><p> 写此寄存器，表示某中断已经处理完毕。<code>GICC_IAR</code>的值表示当前在处理的中断，把<code>GICC_IAR</code>的值写入<code>GICC_EOIR</code>就表示中断处理完了。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/24.png" alt="image"></p>
<table>
<thead>
<tr>
<th align="left">位域</th>
<th align="left">名</th>
<th align="left">读写</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[31:13]</td>
<td align="left">-</td>
<td align="left"></td>
<td align="left">保留</td>
</tr>
<tr>
<td align="left">[12:10]</td>
<td align="left">CPUID</td>
<td align="left">W</td>
<td align="left">对于SGI类中断，它的值跟GICD_IAR. CPUID的相同。</td>
</tr>
<tr>
<td align="left">[9:0]</td>
<td align="left">EOIINTID</td>
<td align="left">W</td>
<td align="left">中断ID，它的值跟GICD_IAR里的中断ID相同</td>
</tr>
</tbody></table>
<h1><span id="2-zhong-duan-shi-li-start-s-fen-xi">2. 中断示例start.s分析</span><a href="#2-zhong-duan-shi-li-start-s-fen-xi" class="header-anchor">#</a></h1><p>以nxp的IMX6UL为例，SDK中<code>core_ca7.h</code>定了了GIC相关函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GIC_Init</td>
<td>初始化 GIC。</td>
</tr>
<tr>
<td>GIC_EnableIRQ</td>
<td>使能指定的外设中断。</td>
</tr>
<tr>
<td>GIC_DisableIRQ</td>
<td>关闭指定的外设中断。</td>
</tr>
<tr>
<td>GIC_AcknowledgeIRQ</td>
<td>返回中断号。</td>
</tr>
<tr>
<td>GIC_DeactivateIRQ</td>
<td>无效化指定中断。</td>
</tr>
<tr>
<td>GIC_GetRunningPriority</td>
<td>获取当前正在运行的中断优先级。</td>
</tr>
<tr>
<td>GIC_SetPriorityGrouping</td>
<td>设置抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_GetPriorityGrouping</td>
<td>获取抢占优先级位数。</td>
</tr>
<tr>
<td>GIC_SetPriority</td>
<td>设置指定中断的优先级。</td>
</tr>
<tr>
<td>GIC_GetPriority</td>
<td>获取指定中断的优先级。</td>
</tr>
</tbody></table>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">.global _start  				<span class="comment">/* 全局标号 */</span></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		<span class="comment">/* 复位中断 					*/</span>	</span><br><span class="line">	ldr pc, =Undefined_Handler	<span class="comment">/* 未定义中断 					*/</span></span><br><span class="line">	ldr pc, =SVC_Handler		<span class="comment">/* SVC(Supervisor)中断 		*/</span></span><br><span class="line">	ldr pc, =PrefAbort_Handler	<span class="comment">/* 预取终止中断 					*/</span></span><br><span class="line">	ldr pc, =DataAbort_Handler	<span class="comment">/* 数据终止中断 					*/</span></span><br><span class="line">	ldr	pc, =NotUsed_Handler	<span class="comment">/* 未使用中断					*/</span></span><br><span class="line">	ldr pc, =IRQ_Handler		<span class="comment">/* IRQ中断 					*/</span></span><br><span class="line">	ldr pc, =FIQ_Handler		<span class="comment">/* FIQ(快速中断)未定义中断 			*/</span></span><br><span class="line"><span class="comment">/* 复位中断 */</span>	</span><br><span class="line">Reset_Handler:</span><br><span class="line">	cpsid i						<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line">	<span class="comment">/* 关闭I,DCache和MMU </span></span><br><span class="line"><span class="comment">	 * 采取读-改-写的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">    mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 汇编版本设置中断向量表偏移 */</span></span><br><span class="line">	ldr r0, =<span class="number">0X87800000</span></span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* 设置各个模式下的栈指针，</span></span><br><span class="line"><span class="comment">	 * 注意：IMX6UL的堆栈是向下增长的！</span></span><br><span class="line"><span class="comment">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span></span><br><span class="line"><span class="comment">	 * DDR范围:0X80000000~0X9FFFFFFF</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x12</span> 	<span class="comment">/* r0或上0x13,表示使用IRQ模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80600000</span>	<span class="comment">/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SYS模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* r0或上0x13,表示使用SYS模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80400000</span>	<span class="comment">/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span></span><br><span class="line">	<span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br><span class="line">	cpsie i				<span class="comment">/* 打开全局中断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 使能IRQ中断 */</span></span><br><span class="line">	mrs r0, cpsr		<span class="comment">/* 读取cpsr寄存器值到r0中 			*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0x80</span>	<span class="comment">/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0重新写入到cpsr中 			*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	b main				<span class="comment">/* 跳转到main函数 			 	*/</span></span><br><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* SVC中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 数据终止中断 */</span></span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 未使用的中断 */</span></span><br><span class="line">NotUsed_Handler:</span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IRQ中断！重点！！！！！ */</span></span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存lr地址 */</span></span><br><span class="line">	push &#123;r0-r3, r12&#125;			<span class="comment">/* 保存r0-r3，r12寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrs r0, spsr				<span class="comment">/* 读取spsr寄存器 */</span></span><br><span class="line">	push &#123;r0&#125;					<span class="comment">/* 保存spsr寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrc p15, <span class="number">4</span>, r1, c15, c0, <span class="number">0</span> <span class="comment">/* 从CP15的C0寄存器内的值到R1寄存器中</span></span><br><span class="line"><span class="comment">								* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span></span><br><span class="line"><span class="comment">								* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span></span><br><span class="line"><span class="comment">								*/</span>							</span><br><span class="line">	add r1, r1, #<span class="number">0X2000</span>			<span class="comment">/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span></span><br><span class="line">	ldr r0, [r1, #<span class="number">0XC</span>]			<span class="comment">/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span></span><br><span class="line"><span class="comment">								 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span></span><br><span class="line"><span class="comment">								 * 这个中断号来绝对调用哪个中断服务函数</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">	push &#123;r0, r1&#125;				<span class="comment">/* 保存r0,r1 */</span></span><br><span class="line">	</span><br><span class="line">	cps #<span class="number">0x13</span>					<span class="comment">/* 进入SVC模式，允许其他中断再次进去 */</span></span><br><span class="line">	</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存SVC模式的lr寄存器 */</span></span><br><span class="line">	ldr r2, =system_irqhandler	<span class="comment">/* 加载C语言中断处理函数到r2寄存器中*/</span></span><br><span class="line">	blx r2						<span class="comment">/* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* 执行完C语言中断服务函数，lr出栈 */</span></span><br><span class="line">	cps #<span class="number">0x12</span>					<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	pop &#123;r0, r1&#125;				</span><br><span class="line">	str r0, [r1, #<span class="number">0X10</span>]			<span class="comment">/* 中断执行完成，写EOIR */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0&#125;						</span><br><span class="line">	msr spsr_cxsf, r0			<span class="comment">/* 恢复spsr */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0-r3, r12&#125;			<span class="comment">/* r0-r3,r12出栈 */</span></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* lr出栈 */</span></span><br><span class="line">	subs pc, lr, #<span class="number">4</span>				<span class="comment">/* 将lr-4赋给pc */</span></span><br><span class="line"><span class="comment">/* FIQ中断 */</span></span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-start-s-qi-dong-liu-cheng">2.1 start.s启动流程</span><a href="#2-1-start-s-qi-dong-liu-cheng" class="header-anchor">#</a></h2><ol>
<li>进入<code>_start</code>,初始化异常向量表。进入复位中断，初始化时钟，关闭看门狗，关闭<code>MMU</code>和<code>ICACHE</code> <code>DCACHE</code>,关闭总中断</li>
<li>设置各个模式的<code>SP</code>指针</li>
<li>代码段重定位到DDR上并且清bss段</li>
<li>开启总中断</li>
<li>跳转到C语言main函数执行</li>
</ol>
<p>这里很多流程如代码重定位，清除bss，关闭看门狗等没有列举出来。</p>
<h1><span id="3-gic-zhong-duan-chu-li-liu-cheng">3 GIC中断处理流程</span><a href="#3-gic-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.1 一级中断控制器流程</span><a href="#3-1-yi-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/25.png" alt="image"></p>
<ul>
<li>假设GIC可以向CPU发出<code>16-1019</code>号中断，这些数字被称为<code>hwirq</code>。<code>0-15</code>用于Process之间通信，比较特殊。</li>
<li>假设要使用UART模块，它发出的中断连接到GIC的32号中断，分配的<code>irq_desc</code>序号为16</li>
<li>在<code>GIC domain</code>中会记录<code>(32, 16)</code></li>
<li>那么注册中断时就是：<code>request_irq(16, ...)</code></li>
<li>发生UART中断时    <ul>
<li>程序从GIC中读取寄存器知道发生了32号中断，通过GIC <code>irq_domain</code>可以知道<code>virq</code>为16</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleA</code>函数，它的作用是调用action链表中用户注册的函数.</li>
</ul>
</li>
</ul>
<h2><span id="3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng">3.2 多级中断控制器流程</span><a href="#3-2-duo-ji-zhong-duan-kong-zhi-qi-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/26.png" alt="img"></p>
<ul>
<li>假设GPIO模块下有4个引脚，都可以产生中断，都连接到GIC的33号中断</li>
<li><strong>GPIO也可以看作一个中断控制器</strong>，对于它的4个中断</li>
<li>对于GPIO模块中<code>0~3</code>这四个<code>hwirq</code>，一般都会一下子分配四个<code>irq_desc</code></li>
<li>假设这4个<code>irq_desc</code>的序号为<code>100~103</code>，在<code>GPIO domain</code>中记录<code>(0,100) (1,101)(2,102) (3,103)</code></li>
<li>对于KEY，注册中断时就是：<code>request_irq(102, ...)</code></li>
<li>按下KEY时：    <ul>
<li>程序从GIC中读取寄存器知道发生了33号中断，通过<code>GIC irq_domain</code>可以知道virq为16.</li>
<li>调用<code>irq_desc[16]</code>中的<code>handleB</code>函数      <ul>
<li><code>handleB</code>读取GPIO寄存器，确定是GPIO里2号引脚发生中断</li>
<li>通过GPIO<code> irq_domain</code>可以知道<code>virq</code>为102</li>
<li>调用<code>irq_desc[102]</code>中的<code>handleA</code>函数，它的作用是调用<code>action</code>链表中用户注册的函数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="3-3-gic-ruan-jian-chu-shi-hua-guo-cheng">3.3 GIC软件初始化过程</span><a href="#3-3-gic-ruan-jian-chu-shi-hua-guo-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_kernel (init\main.c)</span><br><span class="line">    init_IRQ (arch\arm\kernel\irq.c)</span><br><span class="line">    	irqchip_init (drivers\irqchip\irqchip.c)</span><br><span class="line">    		of_irq_init (drivers\of\irq.c)<span class="comment">//gic子系统</span></span><br><span class="line">    			desc-&gt;irq_init_cb = match-&gt;data;</span><br><span class="line">                ret = desc-&gt;irq_init_cb(desc-&gt;dev,</span><br><span class="line">                            desc-&gt;interrupt_parent);</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-1-gic-qu-dong-zhu-ce">3.3.1 gic驱动注册</span><a href="#3-3-1-gic-qu-dong-zhu-ce" class="header-anchor">#</a></h3><p>内核支持多种GIC, 在内核为每一类GIC定义一个结构体<code>of_device_id</code>，并放在一个段里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// drivers\irqchip\irq-gic.c</span></span><br><span class="line">IRQCHIP_DECLARE(gic_400, <span class="string">&quot;arm,gic-400&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm11mp_gic, <span class="string">&quot;arm,arm11mp-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(arm1176jzf_dc_gic, <span class="string">&quot;arm,arm1176jzf-devchip-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a15_gic, <span class="string">&quot;arm,cortex-a15-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a9_gic, <span class="string">&quot;arm,cortex-a9-gic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(cortex_a7_gic, <span class="string">&quot;arm,cortex-a7-gic&quot;</span>, gic_of_init);<span class="comment">//imx6ull对应gic类型</span></span><br><span class="line">IRQCHIP_DECLARE(msm_8660_qgic, <span class="string">&quot;qcom,msm-8660-qgic&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(msm_qgic2, <span class="string">&quot;qcom,msm-qgic2&quot;</span>, gic_of_init);</span><br><span class="line">IRQCHIP_DECLARE(pl390, <span class="string">&quot;arm,pl390&quot;</span>, gic_of_init);</span><br></pre></td></tr></table></figure>

<p><code> IRQCHIP_DECLARE</code>宏进行展开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include\linux\irqchip.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQCHIP_DECLARE(name, compat, fn) OF_DECLARE_2(irqchip, name, compat, fn)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OF_DECLARE_2(table, name, compat, fn) \</span></span><br><span class="line"><span class="meta">		_OF_DECLARE(table, name, compat, fn, of_init_fn_2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OF_DECLARE(table, name, compat, fn, fn_type)			\</span></span><br><span class="line"><span class="meta">	static const struct of_device_id __of_table_##name		\</span></span><br><span class="line"><span class="meta">		__used __section(__irqchip_of_table)			\</span></span><br><span class="line"><span class="meta">		 = &#123; .compatible = compat,				\</span></span><br><span class="line"><span class="meta">		     .data = (fn == (fn_type)NULL) ? fn : fn  &#125;</span></span><br></pre></td></tr></table></figure>

<p>例如：<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>展开后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> __<span class="title">of_table_cortex_a7_gic</span>		\</span></span><br><span class="line"><span class="class">	__<span class="title">used</span> __<span class="title">section</span>(__<span class="title">irqchip_of_table</span>)			\</span></span><br><span class="line"><span class="class">	 =</span> &#123; .compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>,				\</span><br><span class="line">		 .data = gic_of_init  &#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-1-1-dts-pi-pei">3.3.1.1 dts匹配</span><a href="#3-3-1-1-dts-pi-pei" class="header-anchor">#</a></h4><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/27.png" alt="在这里插入图片描述"></p>
<p>根据dts匹配调用<code>IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</code>, 对<code>irq chip driver</code> 的声明。</p>
<p>定义 <code>IRQCHIP_DECLARE </code>之后，相应的内容会保存到 <code>__irqchip_of_table </code>里。<code>__irqchip_of_table </code>在链接脚本 <code>vmlinux.lds </code>里，被放到了<code>__irqchip_begin</code>和 <code>__irqchip_of_end</code> 之间，该段用于存放中断控制器信息。</p>
<h4><span id="3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou">3.3.1.2 gic_of_init(GIC驱动初始化入口)</span><a href="#3-3-1-2-gic-of-init-gic-qu-dong-chu-shi-hua-ru-kou" class="header-anchor">#</a></h4><p><code>gic_of_init</code>内容太多，大致就是对中断控制器初始化：</p>
<ol>
<li><p>初始化<code>GICD</code>(分发器寄存器)</p>
</li>
<li><p>初始化<code>GICC</code>(cpu接口端寄存器)</p>
</li>
<li><p>调用<code>gic_init_bases</code> 流程</p>
<ol>
<li><p>调用<code>set_handle_irq</code>注册<code>gic_handle_irq</code>,异常处理的入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">set_handle_irq</span><span class="params">(<span class="type">void</span> (*handle_irq)(<span class="keyword">struct</span> pt_regs *))</span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (handle_arch_irq)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> handle_arch_irq = handle_irq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gic_init_bases</span><span class="params">(<span class="type">void</span> __iomem *dist_base,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> redist_region *rdist_regs,</span></span><br><span class="line"><span class="params">     u32 nr_redist_regions,</span></span><br><span class="line"><span class="params">     u64 redist_stride,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> fwnode_handle *handle)</span> &#123;</span><br><span class="line"> set_handle_irq(gic_handle_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h4><span id="3-3-1-3-shen-qing-gic-zhong-duan">3.3.1.3 申请GIC中断</span><a href="#3-3-1-3-shen-qing-gic-zhong-duan" class="header-anchor">#</a></h4><h5><span id="3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan">3.3.1.3.1 在设备树里指定中断</span><a href="#3-3-1-3-1-zai-she-bei-shu-li-zhi-ding-zhong-duan" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/28.png" alt="image-20240809003246767"></p>
<h5><span id="3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li">3.3.1.3.2 对设备树中断的处理</span><a href="#3-3-1-3-2-dui-she-bei-shu-zhong-duan-de-chu-li" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/29.png" alt="在这里插入图片描述"></p>
<h2><span id="3-4-gic-zhong-duan-chu-guo-cheng">3.4 GIC中断处过程</span><a href="#3-4-gic-zhong-duan-chu-guo-cheng" class="header-anchor">#</a></h2><ol>
<li>进入中断栈<code>irq_stack_entry</code></li>
<li>执行中断控制器的中断入口<code>handle_arch_irq</code></li>
<li>退出中断栈<code>irq_stack_exit</code></li>
</ol>
<p>中断栈用来保存中断的上下文，中断发生和退出的时候调用 <code>irq_stack_entry </code>和 <code>irq_stack_exit </code>来进入和退出中断栈。</p>
<h3><span id="3-4-1-handle-arch-irq-ru-kou">3.4.1 handle_arch_irq入口</span><a href="#3-4-1-handle-arch-irq-ru-kou" class="header-anchor">#</a></h3><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/30.png" alt="image-20240810150555648"></p>
<h4><span id="3-4-1-1-gic-handle-irq">3.4.1.1 gic_handle_irq</span><a href="#3-4-1-1-gic-handle-irq" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> asmlinkage <span class="type">void</span> __exception_irq_entry <span class="title function_">gic_handle_irq</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span>&#123;</span><br><span class="line"> u32 irqnr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  irqnr = gic_read_iar();                                     ------(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (likely(irqnr &gt; <span class="number">15</span> &amp;&amp; irqnr &lt; <span class="number">1020</span>) || irqnr &gt;= <span class="number">8192</span>) &#123;  ------(<span class="number">2</span>)</span><br><span class="line">   <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">    isb();</span><br><span class="line"></span><br><span class="line">   err = handle_domain_irq(gic_data.domain, irqnr, regs);    ------(<span class="number">3</span>)</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected interrupt received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate)) &#123;</span><br><span class="line">     <span class="keyword">if</span> (irqnr &lt; <span class="number">8192</span>)</span><br><span class="line">      gic_write_dir(irqnr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     gic_write_eoir(irqnr);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (irqnr &lt; <span class="number">16</span>) &#123;                                          ------(<span class="number">4</span>)</span><br><span class="line">   gic_write_eoir(irqnr);</span><br><span class="line">   <span class="keyword">if</span> (static_key_true(&amp;supports_deactivate))</span><br><span class="line">    gic_write_dir(irqnr);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Unlike GICv2, we don&#x27;t need an smp_rmb() here.</span></span><br><span class="line"><span class="comment">    * The control dependency from gic_read_iar to</span></span><br><span class="line"><span class="comment">    * the ISB in gic_write_eoir is enough to ensure</span></span><br><span class="line"><span class="comment">    * that any shared data read by handle_IPI will</span></span><br><span class="line"><span class="comment">    * be read after the ACK.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   handle_IPI(irqnr, regs);                                ------(<span class="number">5</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   WARN_ONCE(<span class="literal">true</span>, <span class="string">&quot;Unexpected SGI received!\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; <span class="keyword">while</span> (irqnr != ICC_IAR1_EL1_SPURIOUS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>读取中断控制器的寄存器<code>GICC_IAR</code>，并获取 <code>hwirq</code></li>
<li>外设触发的中断。硬件中断号<code>0-15</code>表示 <code>SGI (软件中断)</code>类型的中断，<code>15-1020 </code>表示外设中断（SPI或PPI共享中断类型），<code>8192-MAX </code>表示 LPI 类型的中断</li>
<li>中断控制器中断处理的主体</li>
<li>软件触发的中断</li>
<li>核间交互触发的中断</li>
</ol>
<h5><span id="3-4-1-1-1-handle-domain-irq">3.4.1.1.1 handle_domain_irq</span><a href="#3-4-1-1-1-handle-domain-irq" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/31.png" alt="image-20240810151815454"></p>
<ol>
<li>进入中断上下文</li>
<li>根据 <code>hwirq</code> 去查找 linux 中断号</li>
<li>通过中断号找到全局中断描述符数组<code>irq_desc[NR_IRQS]</code>中的一项，然后调用<code> generic_handle_irq_desc</code>，执行该 irq 号注册的<code> action</code></li>
<li>退出中断上下文</li>
</ol>
<h6><span id="3-4-1-1-1-1-generic-handle-irq">3.4.1.1.1.1 generic_handle_irq</span><a href="#3-4-1-1-1-1-generic-handle-irq" class="header-anchor">#</a></h6><p>把<code>generic_handle_irq</code>展开：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32.png" alt="image-20240810151917713"></p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/32-1.png" alt="image-20240810152019303"></p>
<p>调用 <code>desc-&gt;handle_irq </code>指向的回调函数。</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/33.png" alt="image-20240810152332559"></p>
<p><code>irq_domain_set_info</code> 根据硬件中断号的范围设置 <code>irq_desc-&gt;handle_irq </code>的指针，共享中断入口为<code> handle_fasteoi_irq</code>，私有中断入口为 <code>handle_percpu_devid_irq</code>。</p>
<ul>
<li><code>handle_percpu_devid_irq</code>：处理私有中断处理，在这个过程中会分别调用中断控制器的处理函数进行硬件操作，该函数调用 <code>action-&gt;handler()</code> 来进行中断处理</li>
<li><code>handle_fasteoi_irq</code>：处理共享中断，并且遍历 <code>irqaction</code> 链表，逐个调用 <code>action-&gt;handler() </code>函数，这个函数正是设备驱动程序调用 <code>request_irq/request_threaded_irq </code>接口注册的中断处理函数，此外如果中断线程化处理的话，还会调用<code>__irq_wake_thread</code>唤醒内核线程。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">irqreturn_t</span> __handle_irq_event_percpu(<span class="keyword">struct</span> irq_desc *desc, <span class="type">unsigned</span> <span class="type">int</span> *flags) &#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> irq = desc-&gt;irq_data.irq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line"></span><br><span class="line">    for_each_action_of_desc(desc, action) &#123;            </span><br><span class="line">        <span class="type">irqreturn_t</span> res;</span><br><span class="line">        res = action-&gt;handler(irq, action-&gt;dev_id);<span class="comment">//requst_irq注册的函数</span></span><br><span class="line">        <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">            __irq_wake_thread(desc, action);          </span><br><span class="line">        <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">            *flags |= action-&gt;flags;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5><span id="3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing">3.4.1.1.2 总结request_irq的函数如何被执行</span><a href="#3-4-1-1-2-zong-jie-request-irq-de-han-shu-ru-he-bei-zhi-xing" class="header-anchor">#</a></h5><p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/34.png" alt="image-20240810152452686"></p>
<h1><span id="4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu">4 中断控制器GIC的设备树描述</span><a href="#4-zhong-duan-kong-zhi-qi-gic-de-she-bei-shu-miao-shu" class="header-anchor">#</a></h1><p>中断控制器而言 ，设备树绑定信息参考文档<code>Documentation/devicetree/bindings/arm/gic.txt</code>。以nxp的<code>imx6ull.dtsi</code>为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;arm,cortex-a7-gic&quot;</span>;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;3&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line">	&lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<ol>
<li><code>compatible</code> 属性值为<code>“arm,cortex-a7-gic”</code>在 Linux 内核源码中搜索<code>“arm,cortex-a7-gic”</code>即可找到 GIC 中断控制器驱动文件， GIC 中断控制器驱是架构通用的，在<code>drivers/irqchip/irq-gic.c</code></li>
<li><code>interrupt-cells </code>和<code>#address-cells、#size-cells </code>一样。<br> 2.1 每个 cells 都是 32 位整形值，对于 ARM 处理的GIC 来说，一共有 3 个 cells，这三个 cells 的含义如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一个 cells：中断类型，<span class="number">0</span> 表示 SPI(共享) 中断，<span class="number">1</span> 表示 PPI（私有） 中断。</span><br><span class="line">第二个 cells：中断号，对于 SPI 中断来说中断号的范围为 <span class="number">0</span>~<span class="number">987</span>，对于PPI</span><br><span class="line">       中断来说中断号的范围为 <span class="number">0</span>~<span class="number">15</span>。</span><br><span class="line">第三个 cells：标志，bit[<span class="number">3</span>:<span class="number">0</span>]表示中断触发类型，为 <span class="number">1</span> 的时候表示上升沿触发，</span><br><span class="line">       为 <span class="number">2</span> 的时候表示下降沿触发，为 <span class="number">4</span> 的时候表示高电平触发，为 <span class="number">8</span> 的时候表示低</span><br><span class="line">       电平触发。bit[<span class="number">15</span>:<span class="number">8</span>]为 PPI 中断的 CPU 掩码。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><code>interrupt-controller</code>表示该节点中断控制器</li>
</ol>
<p>对于gpio来说也可以作为中断控制器，如imx6ull的<code>gpio5</code>：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/35.png" alt="image"><br>对于 gpio5 来说一共有两条信息，中断类型都是 SPI，<br>触发电平都是<code> IRQ_TYPE_LEVEL_HIGH</code>。不同之处在于中断源，一个是 74，一个是 75，打开可以打开《IMX6ULL 参考手册》的<code>“Chapter 3 Interrupts and DMA Events”</code>章节：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/36.png" alt="image"><br>GPIO5 一共用了 2 个中断号，一个是 74，一个是 75。其中 74 对应<code>GPIO5_IO00~GPIO5_IO15</code>这低 16 个 IO，75 对应 <code>GPIO5_IO16~GPIOI5_IO31 </code>这高 16 位 IO。</p>
<p>使用者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,fxls8471&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	position = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fxls8471</code> 有一个中断引脚链接到了 I.MX6ULL 的<code>SNVS_TAMPER0</code>因脚上，这个引脚可以复用为<code>GPIO5_IO00 interrupts</code>设置中断信息，0 表示 <code>GPIO5_IO00</code>，8 表示低电平触发。</p>
<h2><span id="4-1-huo-qu-zhong-duan-hao-han-shu">4.1 获取中断号函数</span><a href="#4-1-huo-qu-zhong-duan-hao-han-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_of_parse_and_map</span><span class="params">(<span class="keyword">struct</span> device_node *dev,<span class="type">int</span> index)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gpio)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">irq_create_mapping</span><span class="params">(<span class="keyword">struct</span> irq_domain *domain,</span></span><br><span class="line"><span class="params">				<span class="type">irq_hw_number_t</span> hwirq)</span>;</span><br></pre></td></tr></table></figure>

<p><code>irq_of_parse_and_map </code>函数从 interupts 属性中提取到对应的设备号，<br>dev：设备节点。<br>index：索引号，interrupts 属性可能包含多条中断信息，通过 index 指定要获取的信息。<br>返回值：中断号。</p>
<h2><span id="4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan">4.2 gic使用示例-按键gpio中断</span><a href="#4-2-gic-shi-yong-shi-li-an-jian-gpio-zhong-duan" class="header-anchor">#</a></h2><h3><span id="4-2-1-dts-miao-shu">4.2.1 dts描述</span><a href="#4-2-1-dts-miao-shu" class="header-anchor">#</a></h3><p>我们驱动一个按键，采用中断的方式，并且采用定时器来实现按键消抖，应用程序读取按键值并且通过终端打印出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key &#123;</span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-key&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">	key-gpio = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;; <span class="comment">/* KEY0 */</span></span><br><span class="line">	interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;; <span class="comment">/* FALLING RISING */</span></span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到key使用<code>key-gpio</code>使用<code>GPIO1_IO18</code>, 可以看到也用到了gpio中断源interrupts，<code>IRQ_TYPE_EDGE_BOTH</code>定义在<code>include/linux/irq.h：</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	IRQ_TYPE_NONE = <span class="number">0x00000000</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_RISING = <span class="number">0x00000001</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_FALLING = <span class="number">0x00000002</span>,</span><br><span class="line">	IRQ_TYPE_EDGE_BOTH = (IRQ_TYPE_EDGE_FALLING |</span><br><span class="line">		IRQ_TYPE_EDGE_RISING),</span><br><span class="line">	IRQ_TYPE_LEVEL_HIGH = <span class="number">0x00000004</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_LOW = <span class="number">0x00000008</span>,</span><br><span class="line">	IRQ_TYPE_LEVEL_MASK = (IRQ_TYPE_LEVEL_LOW |</span><br><span class="line">		IRQ_TYPE_LEVEL_HIGH),</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-2-qu-dong-dai-ma-yu-fen-xi">4.2.2 驱动代码与分析</span><a href="#4-2-2-qu-dong-dai-ma-yu-fen-xi" class="header-anchor">#</a></h3><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMX6UIRQ_NAME		<span class="string">&quot;imx6uirq&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断IO描述结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* imx6uirq设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">atomic_t</span> keyvalue;		<span class="comment">/* 有效的按键键值 */</span></span><br><span class="line">	<span class="type">atomic_t</span> releasekey;	<span class="comment">/* 标记是否完成一次完成的按键，包括按下和释放 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> <span class="title">imx6uirq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line"></span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; 						<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, keydesc-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123; 									<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;keyvalue, <span class="number">0x80</span> | keydesc-&gt;value);</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">1</span>);	<span class="comment">/* 标记松开按键，即完成一次完整的按键过程 */</span>			</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	imx6uirq.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		imx6uirq.irqkeydesc[i].gpio = of_get_named_gpio(imx6uirq.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (imx6uirq.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(imx6uirq.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(imx6uirq.irqkeydesc[i].name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(imx6uirq.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(imx6uirq.irqkeydesc[i].gpio, imx6uirq.irqkeydesc[i].name);</span><br><span class="line">		gpio_direction_input(imx6uirq.irqkeydesc[i].gpio);	</span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = irq_of_parse_and_map(imx6uirq.nd, i);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">		imx6uirq.irqkeydesc[i].irqnum = gpio_to_irq(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		printk(<span class="string">&quot;key%d:gpio=%d, irqnum=%d\r\n&quot;</span>,i, imx6uirq.irqkeydesc[i].gpio,</span><br><span class="line">                                         imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	imx6uirq.irqkeydesc[<span class="number">0</span>].value = KEY0VALUE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(imx6uirq.irqkeydesc[i].irqnum, imx6uirq.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING, imx6uirq.irqkeydesc[i].name, &amp;imx6uirq);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, imx6uirq.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	init_timer(&amp;imx6uirq.timer);</span><br><span class="line">	imx6uirq.timer.function = timer_function;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx6uirq_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;imx6uirq;	<span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">imx6uirq_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> keyvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> releasekey = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx6uirq_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> imx6uirq_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	keyvalue = <span class="type">atomic_read</span>(&amp;dev-&gt;keyvalue);</span><br><span class="line">	releasekey = <span class="type">atomic_read</span>(&amp;dev-&gt;releasekey);</span><br><span class="line">	<span class="keyword">if</span> (releasekey) &#123; <span class="comment">/* 有按键按下 */</span></span><br><span class="line">		<span class="keyword">if</span> (keyvalue &amp; <span class="number">0x80</span>) &#123;</span><br><span class="line">			keyvalue &amp;= ~<span class="number">0x80</span>;</span><br><span class="line">			ret = copy_to_user(buf, &amp;keyvalue, <span class="keyword">sizeof</span>(keyvalue));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">goto</span> data_error;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;dev-&gt;releasekey, <span class="number">0</span>);<span class="comment">/* 按下标志清零 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> data_error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">data_error:</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">imx6uirq_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = imx6uirq_open,</span><br><span class="line">	.read = imx6uirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">imx6uirq_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (imx6uirq.major) &#123;</span><br><span class="line">		imx6uirq.devid = MKDEV(imx6uirq.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;imx6uirq.devid, <span class="number">0</span>, IMX6UIRQ_CNT, IMX6UIRQ_NAME);</span><br><span class="line">		imx6uirq.major = MAJOR(imx6uirq.devid);</span><br><span class="line">		imx6uirq.minor = MINOR(imx6uirq.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_init(&amp;imx6uirq.cdev, &amp;imx6uirq_fops);</span><br><span class="line">	cdev_add(&amp;imx6uirq.cdev, imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	imx6uirq.class = class_create(THIS_MODULE, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.class);</span><br><span class="line">	&#125;</span><br><span class="line">	imx6uirq.device = device_create(imx6uirq.class, <span class="literal">NULL</span>, imx6uirq.devid, <span class="literal">NULL</span>, IMX6UIRQ_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(imx6uirq.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(imx6uirq.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.keyvalue, INVAKEY);</span><br><span class="line">	<span class="type">atomic_set</span>(&amp;imx6uirq.releasekey, <span class="number">0</span>);</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">imx6uirq_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;imx6uirq.timer);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(imx6uirq.irqkeydesc[i].irqnum, &amp;imx6uirq);</span><br><span class="line">		gpio_free(imx6uirq.irqkeydesc[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	cdev_del(&amp;imx6uirq.cdev);</span><br><span class="line">	unregister_chrdev_region(imx6uirq.devid, IMX6UIRQ_CNT);</span><br><span class="line">	device_destroy(imx6uirq.class, imx6uirq.devid);</span><br><span class="line">	class_destroy(imx6uirq.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
分析：
![image](字符设备驱动-9-中断子系统-GICv2架构解析/37.png)
从key节点取出key-gpio,得到gpio编号
调用gpio请求配置函数，配成input模式
根据key节点信息解析出中断号，或者gpio编号转成中断号.（这里用到一个函数`irq_of_parse_and_map`)
注册中断
创建定时器用来消抖

<p>中断响应过程：<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/38.png" alt="image"><br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/39.png" alt="image"><br>按键按下或松开，中断产生调用<code>key0_handler</code>，修改定时器超时10ms, 如果是抖动那么，定时器中断那么不会触发（原理请参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/12464079.html" title="定时器中断">定时器中断</a>），只有当不是抖动真正按下或松开，定时器中断触发进行读取按键，原子操作设置键值。releasekey置1表示一次完整的按下松开。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/40.png" alt="image"><br>最后用户调用read, 返回键值。可见releasekey很好的控制着按键按下和read的次数，比如当连续read 2次但是只按了一次，则读取失败。<br><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/41.png" alt="image"></p>
<p>硬中断和虚拟中断号的映射关系可以用 <code>/proc/interrupts </code>查看：</p>
<p><img src="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/42.png" alt="img"></p>
<p>通过 ps 命令可以查看系统中的中断线程，注意这些线程是实时线程 <code>SCHED_FIFO</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ps -A | grep &quot;irq/&quot;</span><br><span class="line">root          1749     2       0      0 irq_thread          0 S [irq/433-imx_drm]</span><br><span class="line">root          1750     2       0      0 irq_thread          0 S [irq/439-imx_drm]</span><br><span class="line">root          1751     2       0      0 irq_thread          0 S [irq/445-imx_drm]</span><br><span class="line">root          1752     2       0      0 irq_thread          0 S [irq/451-imx_drm]</span><br><span class="line">root          2044     2       0      0 irq_thread          0 S [irq/279-isl2902]</span><br><span class="line">root          2192     2       0      0 irq_thread          0 S [irq/114-mmc0]</span><br><span class="line">root          2199     2       0      0 irq_thread          0 S [irq/115-mmc1]</span><br><span class="line">root          2203     2       0      0 irq_thread          0 S [irq/322-5b02000]</span><br><span class="line">root          2361     2       0      0 irq_thread          0 S [irq/294-4-0051]</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" data-id="clznto25t00000cufglc931ds" data-title="字符设备驱动-9-中断子系统-GICv2架构解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断引入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2024-08-05T15:50:47.000Z" itemprop="datePublished">2024-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</a></li>
<li><a href="#2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</a><ul>
<li><a href="#2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</a><ul>
<li><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</a></li>
</ul>
</li>
<li><a href="#2-2-gic-gai-shu">2.2 GIC概述</a></li>
<li><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</a><ul>
<li><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</a></li>
<li><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</a></li>
</ul>
</li>
<li><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</a><ul>
<li><a href="#2-4-1-ying-zhong-duan">2.4.1 硬中断</a></li>
<li><a href="#2-4-2-ruan-zhong-duan">2.4.2 软中断</a></li>
<li><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-jian-qu-bie">2.4.3 硬件中断和软件区别</a></li>
</ul>
</li>
<li><a href="#2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</a><ul>
<li><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</a></li>
<li><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</a></li>
<li><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</a></li>
<li><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</a></li>
</ul>
</li>
<li><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</a><ul>
<li><a href="#2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</a></li>
<li><a href="#2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</a></li>
<li><a href="#2-6-3-threaded-irq">2.6.3 threaded irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</span><a href="#1-zhong-duan-yu-yi-chang-chong-lei" class="header-anchor">#</a></h1><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png" alt="image"><br>CPU 在运行的过程中，也会被各种<code>“异常”</code>打断。这些<code>“异常”</code>有：</p>
<ol>
<li>指令未定义</li>
<li>Reset复位</li>
<li>指令、数据访问有问题</li>
<li>SWI(软中断)</li>
<li>快中断</li>
<li>IRQ中断</li>
</ol>
<p>IRQ中断只是一种（一类）异常而已。导致中断发生的情况有很多，比如：</p>
<ol>
<li>按键</li>
<li>定时器</li>
<li>ADC 转换完成</li>
<li>UART 发送完数据、收到数据</li>
</ol>
<p>这些众多的<code>“中断源”</code>，汇集到<code>“中断控制器”</code>，由<code>“中断控制器”</code>选择优先级最高的中断并通知 CPU。如上图所示：</p>
<h1><span id="2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</span><a href="#2-zhong-duan-de-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>arm 对异常(中断)处理过程：</p>
<ol>
<li>初始化：<br> a) 设置<strong>中断源</strong>，让它可以产生中断<br> b) 设置<strong>中断控制器</strong>(可以屏蔽某个中断，优先级)<br> c) 设置 <strong>CPU 总开关(使能中断)</strong></li>
<li>执行其他程序：正常程序</li>
<li>产生中断：比如按下按键（中断源发出中断请求）—&gt;中断控制器—&gt;CPU</li>
<li>CPU 每执行完一条指令都会检查有无中断&#x2F;异常产生</li>
<li>CPU 发现有中断&#x2F;异常产生，开始处理。</li>
</ol>
<p>对于不同的异常，跳去不同的地址执行程序。这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。③④⑤都是硬件做的。③是中断源来做，④⑤是cpu来做</p>
<p>综上5个过程，软件要做的事情:<br>a) 保存现场(各种寄存器)<br>b) 处理异常(中断): 从<strong>异常向量表</strong>跳到不同的异常向量去执行，分辨中断源，再调用不同的处理函数<br>c) 恢复现场</p>
<h2><span id="2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</span><a href="#2-1-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>可以参考我之前写的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="异常向量表">s3c2440裸机-异常中断（一. 异常、中断的原理与流程）</a> 介绍了异常向量表。<br>uboot中就有大量类似这种的异常向量表，不同系列芯片每个异常的偏移地址会有所不同。下图以s3c2440芯片为例：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/2.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/3.png" alt="image"></p>
<table>
<thead>
<tr>
<th>向量地址</th>
<th>中断类型</th>
<th>中断模式</th>
</tr>
</thead>
<tbody><tr>
<td>0X00</td>
<td>复位中断(Rest)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X04</td>
<td>未定义指令中断(Undefined Instruction)</td>
<td>未定义指令中止模式(Undef)</td>
</tr>
<tr>
<td>0X08</td>
<td>软中断(Software Interrupt,SWI)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X0C</td>
<td>指令预取中止中断(Prefetch Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X10</td>
<td>数据访问中止中断(Data Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X14</td>
<td>未使用(Not Used)</td>
<td>未使用</td>
</tr>
<tr>
<td>0X18</td>
<td>IRQ</td>
<td>中断(IRQ Interrupt)</td>
</tr>
<tr>
<td>0X1C</td>
<td>FIQ</td>
<td>中断(FIQ Interrupt)</td>
</tr>
</tbody></table>
<p>这就是异常向量表，每一条指令对应一种异常。<br>发生复位时，CPU 就去 执行第 1 条指令：<code>b reset</code>。<br>发生中断时，CPU 就去执行<code>“ldr pc, _irq”</code>这条指令。这些指令存放的位置是固定的，比如对于ARM9芯片中断向量的地址是<code>0x18</code>。当发生中断时，CPU 就强制跳去执行 <code>0x18 </code>处的代码。</p>
<h3><span id="2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</span><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base" class="header-anchor">#</a></h3><p>在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU 就会执行向量表中的跳转指令，去调用更复杂的函数。当然，向量表的位置并不总是从 0 地址开始，很多芯片可以设置某个 <code>vector base </code>寄存器，指定向量表在其他位置，比如imx6ull芯片设置 <code>vector base </code>为 <code>0x80000000</code>，指定为 DDR 的某个地址。但是表中的各个异常向量的偏移地址，是固定的：复位向量偏移地址是 0，中断是 0x18。</p>
<h2><span id="2-2-gic-gai-shu">2.2 GIC概述</span><a href="#2-2-gic-gai-shu" class="header-anchor">#</a></h2><p>对于 ARM 的中断控制器，述语上称之为<code> GIC (Generic Interrupt Controller)</code>，到目前已经更新到 v4 版本了。在STM32叫做<code>NVIC</code>(内嵌向量中断控制器 <code>Nested Vectored Interrupt Controller</code>)<br>简单地说，<code>GIC v3/v4</code> 用于 <code>ARMv8</code> 架构，即 64 位 ARM 芯片。<br>而 <code>GIC v2</code> 用于<code> ARMv7</code> 和其他更低的32位架构。v2架构下一节：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析</a> 会展开细说。</p>
<p>v8架构是在32位ARM架构上进行开发的，将被首先用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域，如企业应用、高档消费电子产品。<code>ARMv8</code>架构包含两个执行状态：<code>AArch64</code>和<code>AArch32</code>。<code>AArch64</code>执行状态针对64位处理技术，引入了一个全新指令集A64；而<code>AArch32</code>执行状态将支持现有的ARM指令集。</p>
<h2><span id="2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</span><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan" class="header-anchor">#</a></h2><p>中断当前正在运行的进程、线程。进程、线程是什么？内核如何切换进程、线程、中断？要理解这些概念，必须理解栈的作用。</p>
<p>进程是资源分配的基本单位，线程是调度的基本单位。<br>    比如全局变量a, 对不同线程它是共享的，但是这个资源a是属于该进程独立的资源，对其他进程是不可见的。<br>    一个进程可以包含多个线程，线程有自己的栈空间，也就是局部变量。</p>
<h3><span id="2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</span><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng" class="header-anchor">#</a></h3><p>ARM 芯片属于精简指令集计算机(<code>RISC：Reduced Instruction Set  Computing</code>)，它所用的指令比较简单，有如下特点：</p>
<pre><code>对内存只有读、写指令
对于数据的运算是在 CPU 内部实现
使用 RISC 指令的 CPU 复杂度小一点，易于设计
</code></pre>
<p>比如对于<code>a=a+b</code>这样的算式，需要经过下面 4 个步骤才可以实现：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/4.png" alt="image"><br>我们先忽略各种 CPU 模式(系统模式、用户模式等等)。详细过程如下：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/5.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [a]</span><br><span class="line">LDR R1, [b]</span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">STR R0, [a]</span><br><span class="line">/*翻译如下：</span><br><span class="line">把内存 a 的值读入 CPU 寄存器 R0</span><br><span class="line">把内存 b 的值读入 CPU 寄存器 R1</span><br><span class="line">把 R0、R1 累加，存入 R0</span><br><span class="line">把 R0 的值写入内存 a*/</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</span><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang" class="header-anchor">#</a></h3><p>当进行函数调用跳转到下一个函数，又或者中断一个程序，就需要把这些寄存器的值保存下来：这就称为<strong>保存现场</strong>。保存的寄存器那块内存就称为栈空间。<br>当跳转的函数执行完成，就需要从栈中恢复那些 CPU 内部寄存器的值，这一出栈的过程也被叫做<strong>“恢复现场”</strong>。</p>
<p><strong>①函数调用：</strong></p>
<pre><code>1.在函数 A 里调用函数 B，实际就是中断函数 A 的执行。
2.那么需要把函数 A 调用 B 之前瞬间的 CPU 寄存器的值，保存到栈里
</code></pre>
<p><strong>②中断处理：</strong></p>
<pre><code>a) 进程 A 正在执行，这时候发生了中断。
b) CPU 强制跳到中断异常向量地址去执行，
c) 这时就需要保存进程 A 被中断瞬间的 CPU 寄存器值，
d) 可以保存在进程 A 的内核态栈，也可以保存在进程 A 的内核结构体中。
e) 中断处理完毕，要继续运行进程 A 之前，恢复这些值
</code></pre>
<p><strong>③进程切换：</strong><br>进程 A 的时间用完了，就切换到进程 B。怎么切换？切换过程是发生在内核态里的，跟中断的处理类似。<br>a) 进程 A 被切换瞬间的 CPU 寄存器值保存在某个地方；<br>b) 恢复进程 B 之前保存的 CPU 寄存器值，这样就可以运行进程 B 了。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/6.png" alt="image"><br>总结有3种场景会要用到栈去保存和恢复现场：</p>
<p>①函数调用，②进程切换，③中断过程。<strong>进程调度核心就是靠定时器中断来实现</strong>。</p>
<h2><span id="2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</span><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><h3><span id="2-4-1-ying-zhong-duan">2.4.1 硬中断</span><a href="#2-4-1-ying-zhong-duan" class="header-anchor">#</a></h3><p>硬件产生的中断，称之为<code>“硬件中断”</code>(<code>hard irq</code>)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断，定时器中断的处理函数肯定不一样。<br>为方便理解，可以先认为对硬件中断的处理是用数组来实现的，数组里存放的是函数指针：一个中断号对应一个中断服务函数<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/7.png" alt="image"></p>
<h3><span id="2-4-2-ruan-zhong-duan">2.4.2 软中断</span><a href="#2-4-2-ruan-zhong-duan" class="header-anchor">#</a></h3><p>相对的，还可以人为地制造中断：软件中断(<code>soft irq</code>)，如下图所示：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/8.png" alt="image"></p>
<ol>
<li><p>软件中断何时生产？<br> 由软件决定，对于 X 号软件中断，只需要把它的 flag 设置为 1 就表示发生了该中断。</p>
</li>
<li><p>软件中断何时处理？<br> 软件中断嘛，并不是那么十万火急，有空再处理它好了,因此一般软件中断是硬件中断处理完后，顺便来处理软件中断。</p>
</li>
<li><p>有哪些软件中断？<br> 查内核源码<code> include/linux/interrupt.h</code><br> <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/9.png" alt="image"><br> 怎么设置使用软中断，比如<code>tasklet </code>（后面会讲中断上半部分， 和中断下半部分）就是使用软件中断实现的。还有上一节<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器</a>也是利用软中断实现的。</p>
</li>
</ol>
<p>  3.1 设置软件中断的处理函数：<br>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/10.png" alt="image"><br>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11.png" alt="image"><br>  最核心的函数是 <code>raise_softirq</code>，简单地理解就是设置<code> softirq_veq[nr]</code>的标记位，设置后表示使能该软中断号。</p>
<h3><span id="2-4-3-ying-jian-zhong-duan-he-ruan-jian-qu-bie">2.4.3 硬件中断和软件区别</span><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-jian-qu-bie" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/12.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/13.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息<br><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</span><a href="#2-5-zhong-duan-chu-li-yuan-ze" class="header-anchor">#</a></h2><h3><span id="2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</span><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao" class="header-anchor">#</a></h3><p>中断 A 正在处理的过程中，假设又发生了中断 B，那么在栈里要保存 A 的现场，然后处理 B。在处理 B 的过程中又发生了中断 C，那么在栈里要保存 B 的现场，然后处理C。<br>如果中断嵌套突然暴发，那么栈将越来越大，栈终将耗尽。<br>为了防止这种情况发生，也是为了简单化中断的处理，在 Linux 系统上规定中断无法嵌套：即当前中断 A 没处理完之前，不会响应另一个中断 B(即使它的优先级更高)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br></pre></td></tr></table></figure>
<h3><span id="2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</span><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao" class="header-anchor">#</a></h3><p>在单核心芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。</p>
<h3><span id="2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</span><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu" class="header-anchor">#</a></h3><p>当处理某个中断要做的事情就是很多，没办法加快。比如对于按键中断，我们需要等待几十毫秒消除机械抖动。难道要在<code>irq_handler</code> 中等待吗？对于计算机来说，这可是一个段很长的时间。又比如图像处理中，当一个硬件IP处理完成一张图像的操作，那么对这张图像的后处理操作难道要放在中断服务中来操作嘛，显然这个耗时是非常久的。<br>那么中断操作切分为中断上半部、下半部。上半部分关中断，清中断执行关键紧急的事情，下半部分去处理耗时久的事情，如下图：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/14.png" alt="image"><br>中断下半部的实现有很多种方法： ①<code>tasklet</code>(小任务)、②<code>work queue</code>(工作队列)， ③<code>threaded irq</code>等。</p>
<h3><span id="2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</span><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian" class="header-anchor">#</a></h3><p>中断上半部、下半部的执行过程中，不能休眠：中断休眠的话，以后谁来调度进程啊？</p>
<h2><span id="2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</span><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa" class="header-anchor">#</a></h2><h3><span id="2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</span><a href="#2-6-1-xiao-ren-wu-tasklet" class="header-anchor">#</a></h3><p><code>tasklet</code> 是使用软中断来实现的：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/15.png" alt="image"><br><strong>中断上半部和下半部的处理流程：</strong><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/16.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/17.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 中断源产生中断，执行irq_enter(), 最开始preempt_count=<span class="number">0</span>，preempt_count++后为<span class="number">1</span>, generic_handle_irq中会找到该中断源对应的中断服务程序</span><br><span class="line"><span class="number">2.</span> 执行irq函数，执行中断上半部，（注意执行上半部分时是无法被中断的，调用了local_irq_disable()）</span><br><span class="line"><span class="number">3.</span> irq_exit(),preempt_count-- 后为<span class="number">0</span>，</span><br><span class="line"><span class="number">4.</span> 判断preempt_count是否等于<span class="number">0</span>，此时等于<span class="number">0</span>，也就是执行下半部分，也叫做软中断流程</span><br><span class="line"><span class="number">5.</span> 下半部过程中会对preempt_count++，开始软件中断</span><br><span class="line"><span class="number">6.</span> 由于是软件中断，开总中断，允许其他的硬件中断响应local_irq_enable();</span><br><span class="line"><span class="number">7.</span> 根据软中断号找到服务函数，执行所谓的中断下半部分（可以进行耗时的一些操作，因为有使能中断）</span><br><span class="line"><span class="number">8.</span> 下半部分执行完后，local_irq_disable()</span><br><span class="line"><span class="number">9.</span> preempt_count--，preempt_count又回到<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上半部中断（硬件中断）有<code>local_irq_disable()</code>，中断是不允许被另一个中断打断的。而下半部（软件中断）时中断是开的，它可以被其他中断打断<code>local_irq_enable()</code>。</p>
<p>那么软中断（下半部）A还没有执行到<code>⑨preempt_count--</code>，当被其他中断B打断时，又执行<code>①preempt_count++</code>，等于2，又进入了下一个硬件中断B流程。当下一个硬件中断B流程执行完后，<code>preempt_count--</code>，等于1，此时不会进入软总断流程直接结束，然后恢复A中断的下半部，继续执行完A中断下半部分的代码。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/18.png" alt="image"><br>那这样B的下半部怎么执行呢？难道不要了吗？注意：<code>步骤7</code>中的中断下半部处理过程中，它处理的是所有中断的下半部分，处理完A的下半部后会继续处理B中断的下半部。所以，多个中断的下半部，是汇集在一起处理的。<br>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.中断的处理可以分为上半部，下半部</span><br><span class="line">2.中断上半部，用来处理紧急的事，它是在关中断的状态下执行的</span><br><span class="line">3.中断下半部，用来处理耗时的、不那么紧急的事，它是在开中断的状态下执行的. 中断下半部执行时，有可能会被其他硬件中断打断</span><br><span class="line">4.中断上半部、下半部的执行过程中，不能休眠</span><br></pre></td></tr></table></figure>
<h3><span id="2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</span><a href="#2-6-2-gong-zuo-dui-lie-workqueue" class="header-anchor">#</a></h3><p>如果下半部要做的事情太多，那么<code>tasklet</code>就有点不太符合需求了，我们希望建立一个线程来专门执行中断后处理，用内核线程来做：在中断上半部唤醒内核线程。<br>在linux操作系统中，有一个内核线程**<code>kworker</code>** 线程，是系统帮我们创建的。内核中有很多这样的线程：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/19.png" alt="image"><br><code>kworker</code> 线程要去<code>“工作队列”(work queue)</code>上取出一个一个<code>“工作”(work)</code>，来执行它里面的函数。</p>
<p>1.创建 <code>work</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/20.png" alt="image"></p>
<p>2.要执行这个函数时，把<code> work</code> 提交给 <code>work queue </code>就可以了<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/21.png" alt="image"><br>上述函数会把 <code>work</code> 提供给**<code>系统默认的 work queue：system_wq</code>**，它是一个队列。<code>schedule_work</code> 函数不仅仅是把 <code>work </code>放入队列，还会把<code>kworker </code>线程唤醒。</p>
<p>3.什么时候把 <code>work </code>提交给 <code>work queue</code>？<br>在中断场景中，可以在中断上半部调用 <code>schedule_work</code> 函数。<br>因此耗时久的中断下半部分，应该利用线程化处理方式，比如使用工作队列<code>workqueue</code>，上半部调用<code>schedule_work </code>函数，触发<code> work</code> 的处理。</p>
<h3><span id="2-6-3-threaded-irq">2.6.3 threaded irq</span><a href="#2-6-3-threaded-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/22.png" alt="image"><br><code>threaded_irq</code>：下半部也是利用线程化处理。前面的<code>workqueue</code>处理使用方法太麻烦，需要在上半部进行<code>work</code>定义，<code>schedule_work</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数handler:上半部分可以为空</span><br><span class="line">参数：thread_fn，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数</span><br></pre></td></tr></table></figure>
<p>以前用 <code>work </code>来线程化地处理中断，一个 <code>worker </code>线程只能由一个 CPU 执行，多个中断的 <code>work</code> 都由同一个<code> worker</code> 线程来处理，在单 CPU 系统中也只能忍着了。但是在 SMP 系统中，明明有那么多 CPU 空着，你偏偏让多个中断挤在这个CPU 上？<br>新技术 <code>threaded irq</code>，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个 CPU 上执行，这提高了效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" data-id="clzh7occg0000vkufb2sg40vd" data-title="字符设备驱动-9-中断子系统-中断引入" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-8-内核定时器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-04T06:49:31.000Z" itemprop="datePublished">2024-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ding-shi-qi">1 引入定时器</a><ul>
<li><a href="#1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</a></li>
<li><a href="#1-1-timer-nei-he-han-shu">1.1 timer内核函数</a></li>
<li><a href="#1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</a><ul>
<li><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</a></li>
<li><a href="#1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</a><ul>
<li><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</a></li>
<li><a href="#1-2-2-2-usleep-range">1.2.2.2 usleep_range</a></li>
</ul>
</li>
<li><a href="#1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</a><ul>
<li><a href="#2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</a></li>
</ul>
</li>
<li><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</a><ul>
<li><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</a></li>
<li><a href="#3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</a></li>
<li><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-ding-shi-qi">1 引入定时器</span><a href="#1-yin-ru-ding-shi-qi" class="header-anchor">#</a></h1><p>前面的<code>阻塞非阻塞IO, 休眠唤醒，poll查询，异步通知</code>小结内容都是针对按键驱动为例进行的演示。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制 | Hexo (fuzidage.github.io)</a>引入了中断，当按键按下会记录按键信息，理想状况是按下一次按键记录一组数据，但实际上按下机械振动导致电平反复跳动最后才稳定，按下一次gpio irq会触发多次，这个被叫做<strong>“抖动”</strong>，那么可以利用定时器进行<strong>“去抖”</strong>。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p>
<h2><span id="1-0-ding-shi-qi-timer-list-jie-gou">1.0 定时器timer_list结构</span><a href="#1-0-ding-shi-qi-timer-list-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"></p>
<p>到<code>linux_5.10</code>版本<code>struct timer_list</code>变成了<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> expires; <span class="comment">//设定的超时的值</span></span><br><span class="line"><span class="type">void</span>(*function)(<span class="type">unsigned</span> <span class="type">long</span>); <span class="comment">//超时处理函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> data; <span class="comment">//超时处理函数参数</span></span><br></pre></td></tr></table></figure>
<h2><span id="1-1-timer-nei-he-han-shu">1.1 timer内核函数</span><a href="#1-1-timer-nei-he-han-shu" class="header-anchor">#</a></h2><p>在内核中使用定时器很简单，涉及这些函数(参考内核源码<code>include\linux\timer.h</code>)</p>
<ol>
<li><code>setup_timer(timer, fn, data)</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></li>
</ol>
<p>到<code>linux_5.10</code>版本变成了<code>timer_setup</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p>
<p>设置定时器，主要是初始化<code> timer_list</code> 结构体，设置其中的函数、参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还有一种用宏DEFINE_TIMER去定义和初始化一个timer_list</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_TIMER(_name, _function, _expires, _data)     \</span></span><br><span class="line"><span class="meta">    struct timer_list _name =               \</span></span><br><span class="line"><span class="meta">        TIMER_INITIALIZER(_function, _expires, _data)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TIMER_INITIALIZER(_function, _expires, _data, _flags) &#123; \</span></span><br><span class="line"><span class="meta">		.entry = &#123; .next = TIMER_ENTRY_STATIC &#125;,	\</span></span><br><span class="line"><span class="meta">		.function = (_function),			\</span></span><br><span class="line"><span class="meta">		.expires = (_expires),				\</span></span><br><span class="line"><span class="meta">		.data = (_data),				\</span></span><br><span class="line"><span class="meta">		.flags = (_flags),				\</span></span><br><span class="line"><span class="meta">		__TIMER_LOCKDEP_MAP_INITIALIZER(		\</span></span><br><span class="line"><span class="meta">			__FILE__ <span class="string">&quot;:&quot;</span> __stringify(__LINE__))	\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p><code> void add_timer(struct timer_list *timer)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"><br> 向内核添加定时器。<code>timer-&gt;expires</code>表示超时时间。<br> 当超时时间到达 ， 就会调用这个函数 ：<code>timer-&gt;function(timer-&gt;data)</code>。</p>
</li>
<li><p><code>int mod_timer(struct timer_list *timer, unsigned long expires)</code><br> <img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p>
<p> 修改定时器的超时时间:<br> 它等同于： </p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">del_timer(timer);</span><br><span class="line">timer-&gt;expires = expires;</span><br><span class="line">add_timer(timer);</span><br></pre></td></tr></table></figure>
<p> 但是更加高效。</p>
</li>
<li><p><code>int del_timer(struct timer_list *timer)</code><br>删除定时器。</p>
</li>
</ol>
<h2><span id="1-2-ding-shi-qi-shi-jian-dan-wei">1.2 定时器时间单位</span><a href="#1-2-ding-shi-qi-shi-jian-dan-wei" class="header-anchor">#</a></h2><p>可以在内核源码根目录下用<code>“ ls -a”</code>看到一个隐藏文件<code>.config</code>, 可以看到如下这项：会被内核转换成<code>include/generated/autoconf.h</code>，<code>HZ</code>定义头文件<code>uapi/asm-generic/param.h</code>和<code>include/asm-generic/param.h</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"></p>
<p><code>CONFIG_HZ=100</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"></p>
<p>这表示内核<strong>每秒中会发生 100 次系统滴答中断(tick)<strong>，这就像人类的心跳一样，这是 Linux 系统的心跳。</strong>每发生一次 tick 中断，全局变量 jiffies 就会累加 1</strong>。<br><code>CONFIG_HZ=100</code> 表示每个滴答是 10ms。<br>定时器的时间就是基于<code>jiffies</code>的，我们修改超时时间时，一般使用这 2 种方法：</p>
<ol>
<li><code>add_timer</code> 之前，直接修改：<br><code>imer.expires = jiffies + xxx; // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br><code>imer.expires = jiffies + 2*HZ; // HZ 等于 CONFIG_HZ， 2*HZ HZ是100个10ms, 就相当于 2 秒</code></li>
<li><code>add_timer</code> 之后，使用 <code>mod_timer</code> 修改：<br> <code>mod_timer(&amp;timer, jiffies + xxx); // xxx 表示多少个滴答后超时，也就是 xxx*10ms</code><br> <code>mod_timer(&amp;timer, jiffies + 2*HZ); // HZ 等于 CONFIG_HZ， 2*HZ 就相当于 2 秒</code></li>
</ol>
<h3><span id="1-2-1-jiffies-yu-miao-de-zhuan-huan">1.2.1 jiffies与秒的转换</span><a href="#1-2-1-jiffies-yu-miao-de-zhuan-huan" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将 jiffies转换为秒，可采用公式：(jiffies/HZ) 计算。</span><br><span class="line">将秒转换为jiffies，可采用公式：(seconds*HZ) 计算。</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-nei-he-shi-jian-huo-qu">1.2.2 内核时间获取</span><a href="#1-2-2-nei-he-shi-jian-huo-qu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get();<span class="comment">//不包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果：ktime_get:492257307974640 ns</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ktime_t</span> curTime = <span class="number">0</span>;</span><br><span class="line">curTime = ktime_get_boottime();<span class="comment">//包含了设备进入休眠的时间</span></span><br><span class="line">printk(<span class="string">&quot;ktime_get_boottime:%lld ns&quot;</span>, curTime);</span><br><span class="line"><span class="comment">//结果： ktime_get_boottime:581660801601637 ns</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ktime_get_ts64</span><span class="params">(<span class="keyword">struct</span> timespec64 *ts)</span>; <span class="comment">//这也是一种</span></span><br><span class="line"></span><br><span class="line"><span class="type">ktime_t</span> start, end, elapsed;</span><br><span class="line">start = ktime_get_boottime();</span><br><span class="line">...</span><br><span class="line">end = ktime_get_boottime();</span><br><span class="line">elapsed = ktime_sub(end, start);</span><br><span class="line">elapsed_msecs = ktime_to_ms(elapsed);</span><br><span class="line">printk(<span class="string">&quot;%d.%03d seconds&quot;</span>, elapsed_msecs / <span class="number">1000</span>,elapsed_msecs % <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan">1.2.2.1 秒-毫秒-微秒-纳秒和jiffies兑换</span><a href="#1-2-2-1-miao-hao-miao-wei-miao-na-miao-he-jiffies-dui-huan" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_msecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">jiffies_to_usecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line">u64 <span class="title function_">jiffies_to_nsecs</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> j)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">msecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> m)</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">usecs_to_jiffies</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> u)</span>;<span class="comment">//jiffies.h</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">nsecs_to_jiffies</span><span class="params">(u64 n)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_us</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;<span class="comment">//ktime.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ms</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> s64 <span class="title function_">ktime_to_ns</span><span class="params">(<span class="type">const</span> <span class="type">ktime_t</span> kt)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-2-usleep-range">1.2.2.2 usleep_range</span><a href="#1-2-2-2-usleep-range" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __sched <span class="title function_">usleep_range</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> min, <span class="type">unsigned</span> <span class="type">long</span> max)</span>；</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-clock-monotonic-yu-clock-realtime">1.2.3 CLOCK_MONOTONIC与CLOCK_REALTIME</span><a href="#1-2-3-clock-monotonic-yu-clock-realtime" class="header-anchor">#</a></h3><p><strong>CLOCK_MONOTONIC</strong>(即<code>monotonic time</code>)<br><code>CLOCK_MONOTONIC</code>：以绝对时间为准，获取的时间为系统重启到现在的时间，更改系统时间对它没有影响。<br>字面意义：单调时间，表示系统启动后流逝的时间，由变量jiffies来记录的。<br>系统每次启动时，<code>jiffies</code>初始化为0。每来一个<code>timer interrupt</code>，<code>jiffies</code>加1，即它代表系统启动后流逝的<code>tick</code>数。<br><code>jiffies</code>一定是单调递增的，因为时间不可逆。</p>
<p><strong>CLOCK_REALTIME</strong>(即<code>wall time</code>)<br><code>CLOCK_REALTIME</code>：相对时间，从<code>1970.1.1</code>到目前的时间。更改系统时间会更改获取的值。它以系统时间为坐标。<br>字面意思: <code>wall time</code>挂钟时间，表示现实的时间，由变量<code>xtime</code>来记录的。<br><strong>一些题外话</strong>：<br>一些应用软件可能就是用到了这个<code>wall time</code>。比如以前用<code>vmware workstation</code>，一启动提示试用期已过，但是只要把系统时间调整一下提前一年，再启动就不会有提示了。这很可能就是因为它启动时，用<code>gettimeofday</code>去读<code>wall time</code>，然后判断是否过期，只要将<code>wall time</code>改一下，就可以欺骗过去了。</p>
<h1><span id="2-nei-he-ding-shi-qi-shi-li">2 内核定时器实例</span><a href="#2-nei-he-ding-shi-qi-shi-li" class="header-anchor">#</a></h1><p>就前面讲到的gpio按键中断来举例，每次发生gpio 中断，irq中我们都去调用一次<code>mod_timer</code>函数判断是不是抖动带来的垃圾数据。如果是抖动，那么irq会一直触发，一直调用<code>mod_timer</code>，一直推迟定时器中断函数的触发。<br>当按下按键键值稳定下来后机械振动没了，电平数据趋于稳定了，那么gpio irq就不会一直响应了，也就是<code>mod_timer</code>函数不会一直调用了，那么等到timer超时，上报数据，整个流程如下图所示：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"><br>按键为下降沿触发，因此会在<code>t1、t2 和 t3</code> 这三个时刻会触发按键中断，每次进入中断处理函数都会重新开器定时器中断，但是 <code>t1~t2 </code>和<code>t2~t3</code>这两个时间段是小于我们设置的定时器中断周期(也就是消抖时间，比如 10ms)，所以虽然 t1 开启了定时器，但是定时器定时时间还没到呢 t2 时刻就重置了定时器，最终只有 t3 时刻开启的定时器能完整的完成整个定时周期并触发中断，我们就可以在中断处理函数里面做按键处理了，这就是定时器实现按键防抖的原理。</p>
<details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf</span></span><br><span class="line"><span class="params">	, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_isr key %d irq happened\n&quot;</span>, gpio_key-&gt;gpio);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span></span><br><span class="line">               , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span></span><br><span class="line">                   , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer</span><br><span class="line">                    , key_timer_expire</span><br><span class="line">                    , &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">			, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">			, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">			, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_key */</span></span><br><span class="line"></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, MKDEV(major, <span class="number">0</span>)</span><br><span class="line">				, <span class="literal">NULL</span></span><br><span class="line">				, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-shi-li-yuan-ma-fen-xi">2.2 实例源码分析</span><a href="#2-2-shi-li-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/13.png" alt="image"></p>
<p><code>linux_5.10</code>内核版本用法<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/14.png" alt="image"></p>
<p>probe函数进行初始化定时器，这里<code>add_timer</code>前修改<code>expires</code>，为了防止定时器中断提前触发（按键还没按下就触发了定时器中断），因此修改<code>expires</code>为一个最大值。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/15.png" alt="image"><br>当按下按键gpio_irq按键中断服务程序响应后，调用<code>mod_timer</code>进行修改定时器超时时间，用来去除 “抖动”。<code>jiffies + HZ/5</code>表示延时20个tick时钟滴答，也就是<code>20*10ms</code>，如果这个时间内有多次电平跳动，那么不会去上报数据，而是继续修改定时器超时时间，直到按键数据稳定后，也就是200ms已经到了但是没有人去修改定时器超时时间，那么将会触发定时器中断，上报按键数据。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/16.png" alt="image"><br><code>linux_5.10</code>内核版本用法:<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/17.png" alt="image"></p>
<h1><span id="3-shen-ru-li-jie-ding-shi-qi-zhong-duan">3 深入理解定时器中断</span><a href="#3-shen-ru-li-jie-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h1><h2><span id="3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan">3.1 提前引入硬件中断和软件中断</span><a href="#3-1-ti-qian-yin-ru-ying-jian-zhong-duan-he-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><p>《后面中断子系统会专门介绍》<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入</a></p>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/18.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/19.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="3-2-ding-shi-qi-di-ceng-yuan-li">3.2 定时器底层原理</span><a href="#3-2-ding-shi-qi-di-ceng-yuan-li" class="header-anchor">#</a></h2><p>定时器就是通过<code>软件中断</code>来实现的，它属于 <code>TIMER_SOFTIRQ </code>软中断<br>对于<code> TIMER_SOFTIRQ</code> 软中断，内核启动时会调用<code>start_kernel</code>初始化<code>init_timers();</code> 代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_timers</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	init_timer_cpus();</span><br><span class="line">	init_timer_stats();</span><br><span class="line">	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当发生硬件中断时，硬件中断处理完后，内核会调用软件中断的处理函数。<br>对于<code> TIMER_SOFTIRQ</code>，会调用<code> run_timer_softirq</code>，它的函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">run_timer_softirq</span><br><span class="line">	__run_timers(base);</span><br><span class="line">    <span class="keyword">while</span> (time_after_eq(jiffies, base-&gt;clk)) &#123;</span><br><span class="line">    ……</span><br><span class="line">    expire_timers(base, heads + levels);</span><br><span class="line">        fn = timer-&gt;function;</span><br><span class="line">        data = timer-&gt;data;</span><br><span class="line">        call_timer_fn(timer, fn, data);</span><br><span class="line">			fn(data);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/20.png" alt="image-20240804152644572"></p>
<p>简单地说， <code>add_timer</code> 函数会把 timer 放入内核里某个链表；在 <code>TIMER_SOFTIRQ</code> 的处理函数<code>run_timer_softirq</code>中，会从链表中把这些超时的 timer 取出来，<br>执行其中的函数。怎么判断是否超时？ <code>jiffies</code> 大于或等于 <code>timer-&gt;expires </code>时， timer 就超时，执行超时处理函数。</p>
<h2><span id="3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies">3.3 找到自己芯片的时钟滴答数-jiffies</span><a href="#3-3-zhao-dao-zi-ji-xin-pian-de-shi-zhong-di-da-shu-jiffies" class="header-anchor">#</a></h2><p>在开发板执行以下命令，可以看到 CPU0 下有一个数值变化特别快，它就是<code>滴答中断tick</code>，<code>jiffies</code>也叫做系统节拍数。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/21.png" alt="image"></p>
<p>以 <code>100ASK_IMX6ULL </code>为做，滴答中断名字就是<code>“ i.MX Timer Tick”</code>。在 Linux内核源码目录下执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;i.MX Timer Tick&quot;</span> * -nr</span><br><span class="line">drivers/clocksource/timer-imx-gpt.c:<span class="number">319</span>: act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>⚫ 打开 <code>timer-imx-gpt.c</code> <code>319 行</code>左右，可得如下源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">act-&gt;name = <span class="string">&quot;i.MX Timer Tick&quot;</span>;</span><br><span class="line">act-&gt;flags = IRQF_TIMER | IRQF_IRQPOLL;</span><br><span class="line">act-&gt;handler = mxc_timer_interrupt;</span><br><span class="line">act-&gt;dev_id = ced;</span><br><span class="line"><span class="keyword">return</span> setup_irq(imxtm-&gt;irq, act);</span><br></pre></td></tr></table></figure>
<p>⚫ <code>mxc_timer_interrupt</code> 应该就是滴答中断的处理函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">mxc_timer_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">clock_event_device</span> *<span class="title">ced</span> =</span> dev_id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_timer</span> *<span class="title">imxtm</span> =</span> to_imx_timer(ced);</span><br><span class="line">	<span class="type">uint32_t</span> tstat;</span><br><span class="line">	tstat = readl_relaxed(imxtm-&gt;base + imxtm-&gt;gpt-&gt;reg_tstat);<span class="number">472</span> / <span class="number">573</span></span><br><span class="line">	imxtm-&gt;gpt-&gt;gpt_irq_acknowledge(imxtm);</span><br><span class="line">	ced-&gt;event_handler(ced);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看<code>ced-&gt;event_handler(ced);</code>调用：</p>
<p><code>ced-&gt;event_handler(ced)</code>是哪一个函数？不太好找，使用 <code>QEMU</code> 来调试内核，在 <code>mxc_timer_interrupt</code> 中打断点跟踪代码发现它对应 <code>tick_handle_periodic</code>。<br><code>tick_handle_periodic</code> 位于 <code>kernel\time\tick-common.c </code>中，它里面的调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tick_handle_periodic</span><br><span class="line">	<span class="title function_">tick_periodic</span><span class="params">(cpu)</span>;</span><br><span class="line">		do_timer(<span class="number">1</span>);</span><br><span class="line">		jiffies_64 += ticks; <span class="comment">// jiffies 就是 jiffies_64</span></span><br></pre></td></tr></table></figure>
<p>为何说<code>jiffies</code>就是<code> jiffies_64</code>？在 <code>arch\arm\kernel\vmlinux.lds.S</code> 有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARMEB__</span></span><br><span class="line">jiffies = jiffies_64;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">jiffies = jiffies_64 + <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>上述代码说明了，对于大字节序的 CPU， <code>jiffies</code> 指向<code> jiffies_64</code> 的高 4字节；对于小字节序的 CPU，<code> jiffies</code> 指向 <code>jiffies_64 </code>的低 4 字节。对<code> jiffies_64</code> 的累加操作，就是对 <code>jiffies </code>的累加操作。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 __cacheline_aligned_in_smp jiffies_64; <span class="comment">//include/linux/jiffies.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> __cacheline_aligned_in_smp __jiffy_arch_data jiffies;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" data-id="clzfa8obt0000poufep942iyu" data-title="字符设备驱动-8-内核定时器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-7-异步通知" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/" class="article-date">
  <time class="dt-published" datetime="2024-08-04T05:33:59.000Z" itemprop="datePublished">2024-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/">字符设备驱动-7-异步通知</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-bu-tong-zhi-gai-shu">1.异步通知概述</a><ul>
<li><a href="#1-1-sigaction-han-shu">1.1 sigaction函数</a></li>
<li><a href="#1-2-signal-han-shu">1.2 signal函数</a><ul>
<li><a href="#1-2-1-shi-li-1">1.2.1 示例1</a></li>
<li><a href="#1-2-2-shi-li-2">1.2.2 示例2</a></li>
<li><a href="#1-1-3-shi-li-3">1.1.3 示例3</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng">2 异步通知的实现原理流程</a><ul>
<li><a href="#2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng">2.1. 异步通知的信号流程</a></li>
</ul>
</li>
<li><a href="#3-qu-dong-dai-ma-bian-xie">3.驱动代码编写</a><ul>
<li><a href="#3-1-kai-qi-async">3.1 开启async</a></li>
<li><a href="#3-2-fa-sigio-xin-hao">3.2 发SIGIO信号</a></li>
</ul>
</li>
<li><a href="#4-ying-yong-bian-xie">4.应用编写</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yi-bu-tong-zhi-gai-shu">1.异步通知概述</span><a href="#1-yi-bu-tong-zhi-gai-shu" class="header-anchor">#</a></h1><p>前面讲到<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17080773.html">APP 读取按键方式</a>里面包含4种方式：1.查询方式，2.休眠唤醒，3，poll机制的休眠唤醒，4.异步通知<br><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/#1-app-du-qu-an-jian-fang-shi">字符设备驱动-3-GPIO驱动KEY示例 | Hexo (fuzidage.github.io)</a><br>什么是异步通知？<br>你去买奶茶：<br>◼ 你在旁边等着，眼睛盯着店员，生怕别人插队，他一做好你就知道：你是主动等待他做好，这叫 “同步”。<br>◼ 你付钱后就去玩手机了，店员做好后他会打电话告诉你：你是被动获得结果，这叫“异步”。<br>同理，还是以<code>gpio_key</code>的例子，app想要判断按键是否有按下，无需去查询或者休眠，只需要注册<code>SIGIO信号</code>给driver, 当按键按下，driver中会自己主动通知app，给app发送<code>SIGIO信号</code>，app上层收到<code>信号SIGIO</code>会执行事先注册的<code>信号处理函数</code>。</p>
<p>异步通知使用信号来实现。在 Linux 内核源文件 <code>include\uapi\asmgeneric\signal.h</code> 中:<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/1.png" alt="image"></p>
<h2><span id="1-1-sigaction-han-shu">1.1 sigaction函数</span><a href="#1-1-sigaction-han-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为信号的值， 可以是除SIGKILL及SIGSTOP外的任何一个特定有效的信号。</span><br><span class="line">第二个参数是指向结构体sigaction的一个实例的指针， 在结构体sigaction的实例中， </span><br><span class="line">    指定了对特定信号的处理函数， 若为空， 则进程会以缺省方式对信号处理；</span><br><span class="line">第三个参数oldact指向的对象用来保存原来对相应信号的处理函数， 可指定oldact为<span class="literal">NULL</span>。</span><br><span class="line">    如果把第二、 第三个参数都设为<span class="literal">NULL</span>， 那么该函数可用于检查信号的有效性。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction *act,<span class="keyword">struct</span> sigaction *oldact)</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">	<span class="type">sigset_t</span> sa_mask;</span><br><span class="line">	<span class="type">int</span> sa_flags;</span><br><span class="line">	<span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sa_flags：用来设置信号处理的其他相关操作，下列的数值可用：</span></span><br><span class="line"><span class="comment">        1.SA RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值；</span></span><br><span class="line"><span class="comment">        2.SIG DFLSA RESTART：如果信号中断了进程的某个系统调用，</span></span><br><span class="line"><span class="comment">        	则系统自动启动该系统调用；</span></span><br><span class="line"><span class="comment">        3.SA NODEFER：当信号处理函数运行时，内核将阻塞该给定信号。</span></span><br><span class="line"><span class="comment">        	但是如果设置了 SA NODEFER标记， 那么在该信号处理函数运行*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _SAMPLE_PLAT_SYS_HandleSig(<span class="type">int</span> nSignal, <span class="type">siginfo_t</span> *si, <span class="type">void</span> *arg) &#123;</span><br><span class="line">        _SAMPLE_PLAT_ERR_Exit();</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sigaction));</span><br><span class="line">sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">sa.sa_sigaction = _SAMPLE_PLAT_SYS_HandleSig;</span><br><span class="line">sa.sa_flags = SA_SIGINFO|SA_RESETHAND;  <span class="comment">// Reset signal handler to</span></span><br><span class="line"><span class="comment">//system default after signal triggered</span></span><br><span class="line">sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h2><span id="1-2-signal-han-shu">1.2 signal函数</span><a href="#1-2-signal-han-shu" class="header-anchor">#</a></h2><h3><span id="1-2-1-shi-li-1">1.2.1 示例1</span><a href="#1-2-1-shi-li-1" class="header-anchor">#</a></h3><p>按下<code>“Ctrl+C”</code>将向其发出<code>SIGINT</code>信号， 正在运行kill的进程将向其发出<code>SIGTERM</code>信号， 以下代码的进程可捕获这两个信号并输出信号值：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigterm_handler</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Have caught sig N.O. %d\n&quot;</span>,signo);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        signal(SIGINT,sigterm_handler);</span><br><span class="line">        signal(SIGTERM,sigterm_handler);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">        return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>可以看到对应<code>SIGINT</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/2.png" alt="image"><br>输入<code>kill [pid]</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/3.png" alt="image"><br>可以看到对应<code>SIGTERM</code>信号<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/4.png" alt="image"></p>
<h3><span id="1-2-2-shi-li-2">1.2.2 示例2</span><a href="#1-2-2-shi-li-2" class="header-anchor">#</a></h3><p>通过<code>signal(SIGIO, input_handler);</code> 对标准输入文件描述符<code>STDIN_FILENO</code>启动信号机制.用户输入后， 应用程序将接收到<code>SIGIO</code>信号， 其处理函数<code>input_handler()</code>将被调用.</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_handler</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data[MAX_LEN];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="comment">/* 读取并输出STDIN_FILENO上的输入 */</span></span><br><span class="line">	len = read(STDIN_FILENO, &amp;data, MAX_LEN);</span><br><span class="line">	data[len] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;input available:%s\n&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> oflags;</span><br><span class="line">	<span class="comment">/* 启动信号驱动机制 */</span></span><br><span class="line">	<span class="comment">/*为SIGIO信号安装input_handler()作为处理函数*/</span></span><br><span class="line">	signal(SIGIO, input_handler);</span><br><span class="line">	<span class="comment">/*设置本进程为STDIN_FILENO文件的拥有者，</span></span><br><span class="line"><span class="comment">	没有这一步，内核不会知道应该将信号发给哪个进程*/</span></span><br><span class="line">	fcntl(STDIN_FILENO, F_SETOWN, getpid());</span><br><span class="line">	<span class="comment">/*而为了启用异步通知机制， 还需对设备设置FASYNC标志，下面两行行代码可实现此目的。 */</span></span><br><span class="line">	oflags = fcntl(STDIN_FILENO, F_GETFL);</span><br><span class="line">	fcntl(STDIN_FILENO, F_SETFL, oflags | FASYNC);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/5.png" alt="image"></p>
<h3><span id="1-1-3-shi-li-3">1.1.3 示例3</span><a href="#1-1-3-shi-li-3" class="header-anchor">#</a></h3><p>手动对app进程发送<code>SIGIO</code>信号</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig_func</span><span class="params">(<span class="type">int</span> signo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get a signal : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGIO, my_sig_func);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, world %d!\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>发送<code>SIGIO</code>信号给进程，也就是<code>kill -29 [pid]</code><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/6.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/7.png" alt="image"></p>
<h1><span id="2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng">2 异步通知的实现原理流程</span><a href="#2-yi-bu-tong-zhi-de-shi-xian-yuan-li-liu-cheng" class="header-anchor">#</a></h1><p>驱动程序怎么通知 APP：发信号，这只有 3 个字，却可以引发很多问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 谁发：驱动程序发</span><br><span class="line"><span class="number">2.</span> 发什么：信号</span><br><span class="line"><span class="number">3.</span> 发什么信号：SIGIO</span><br><span class="line"><span class="number">4.</span> 怎么发：内核里提供有函数</span><br><span class="line"><span class="number">5.</span> 发给谁：APP，APP 要把自己告诉驱动</span><br><span class="line"><span class="number">6.</span> APP 收到后做什么：执行信号处理函数</span><br><span class="line"><span class="number">7.</span> 信号处理函数和信号，之间怎么挂钩：APP 注册信号处理函数</span><br></pre></td></tr></table></figure>
<p>Linux系统中也有很多信号，内核源文件<code>include\uapi\asmgeneric\signal.h</code>中，有很多信号的宏定义：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/8.png" alt="image"><br>就APP而言，你想处理 <code>SIGIO </code>信息，那么需要提供信号处理函数，并且要跟<code>SIGIO </code>挂钩。这可以通过一个 signal 函数来 “给某个信号注册处理函数”，用法如下：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/9.png" alt="image"><br>APP 还要做什么事？想想这几个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a) 内核里有那么多驱动，你想让哪一个驱动给你发 SIGIO 信号？APP 要打开驱动程序的设备节点。</span><br><span class="line">b) 驱动程序怎么知道要发信号给你而不是别人？APP 要把自己的进程 ID 告诉驱动程序。</span><br><span class="line">c) APP 有时候想收到信号，有时候又不想收到信号应该可以把 APP 的意愿告诉驱动。</span><br></pre></td></tr></table></figure>
<p>驱动程序要做什么？发信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a) APP 设置进程 ID 时，驱动程序要记录下进程 ID；</span><br><span class="line">b) APP 还要使能驱动程序的异步通知功能，驱动中有对应的函数：APP 打开驱动程序时，</span><br><span class="line">    内核会创建对应的 file 结构体，file 中有 f_flags；</span><br><span class="line">c) FASYNC 位:</span><br><span class="line">flags 中有一个 FASYNC 位，它被设置为 <span class="number">1</span> 时表示使能异步通知功能。</span><br><span class="line">    当 f_flags 中的 FASYNC 位发生变化时，驱动程序的 fasync 函数被调用;</span><br><span class="line">d) 发生中断时，有数据时，驱动程序调用内核辅助函数发信号。这个辅助函数名为 kill_fasync.</span><br></pre></td></tr></table></figure>


<h2><span id="2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng">2.1. 异步通知的信号流程</span><a href="#2-1-yi-bu-tong-zhi-de-xin-hao-liu-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/10.png" alt="image"><br>① APP open，在drv中调用<code>drv_open</code>，进行注册按键中断服务函数<code>gpio_key_irq</code>;<br>② APP 给<code>SIGIO</code>信号注册<code>信号处理函数func</code>, 以后 APP 收到 <code>SIGIO</code>信号时，这个函数会被自动调用;<br>③ APP 调用<code>fcntl</code>, 把PID(进程 ID)告诉驱动程序，这个调用不涉及驱动程序，只是在内核的文件系统层次<code>sys_cntl</code>,记录 PID在<code>filp</code>中（<code>sys_call</code>会建立<code>filp</code>结构)；<br>④ APP 调用<code>fcntl</code>, 读取驱动程序文件 Flag；<br>⑤ 设置 Flag 里面的<code>FASYNC</code>位为 1：当 <code>FASYNC</code> 位发生变化时，会导致驱动程序的<code>fasync</code>被调用；<br>⑥⑦ 调 用<code> faync_helper</code> ， 它 会 根 据<code>FAYSNC</code>的值决定是否设置<code>button_async-&gt;fa_file = 驱动文件filp</code>：<br>驱动文件<code>filp</code>结构体里面含有之前设置的 PID。<br>⑧ APP 可以做其他事；<br>⑨⑩ 按下按键，发生中断，驱动程序的中断服务程序被调用，里面调用<code>kill_fasync</code> 发信号；<br>⑪⑫⑬ APP 收到信号后，它的信号处理函数被自动调用，可以在里面调用read 函数读取按键。</p>
<h1><span id="3-qu-dong-dai-ma-bian-xie">3.驱动代码编写</span><a href="#3-qu-dong-dai-ma-bian-xie" class="header-anchor">#</a></h1><p>先修改<code>Linux-4.9.88/arch/arm/boot/dts/100ask_imx6ull-14x14.dts</code>建立dts节点，<code>“100ask，gpio_key”</code>和<code>platform drvier</code>中保持一致。这里将<code>goio-keys</code> <code>disabled</code>掉是为了drv去匹配新添加的这个节点。<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/11.png" alt="image"></p>
<p>使用异步通知时，驱动程序的核心有2个：<br>① 提供对应的<code>drv_fasync</code>函数；<br>② 并在合适的时机发信号。</p>
<h2><span id="3-1-kai-qi-async">3.1 开启async</span><a href="#3-1-kai-qi-async" class="header-anchor">#</a></h2><p><code>drv_fasync</code> 函数很简单，调用 <strong><code>fasync_helper</code></strong> 函数就可以，如下：<br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/12.png" alt="image"><br><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/13.png" alt="image"><br><code>fasync_helper</code> 函 数 会 分 配 、 构 造 一 个 <code>fasync_struct</code> 结构体<code>button_async</code>：<br>⚫ 驱动文件的 flag 被设置为 <code>FAYNC 时</code>：<br><code>button_async-&gt;fa_file = filp; // filp 表示驱动程序文件，里面含有之前设置的 PID</code><br>⚫ 驱动文件被设置为非<code>FASYNC</code> 时：<br><code>button_async-&gt;fa_file = NULL;</code><br>以后想发送信号时，使用 <code>button_async</code> 作为参数就可以，它里面 “可能” 含有 PID。</p>
<h2><span id="3-2-fa-sigio-xin-hao">3.2 发SIGIO信号</span><a href="#3-2-fa-sigio-xin-hao" class="header-anchor">#</a></h2><p>什么时候发信号呢？在本例中，在 GPIO 中断服务程序中发信号。<br>怎么发信号呢？代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill_fasync(&amp;button_async, SIGIO, POLL_IN);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/14.png" alt="image"><br>第 1 个参数：<code>button_async-&gt;fa_file</code> 非空时，可以从中得到 PID，表示发给哪一个 APP；<br>第 2 个参数表示发什么信号：<code>SIGIO</code>；<br>第 3 个参数表示为什么发信号：<code>POLL_IN</code>，有数据可以读了。(APP 用不到这个参数)</p>
<details>
<summary>点击查看完整驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, </span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span></span><br><span class="line">               , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span></span><br><span class="line">                   , __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">                          , IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                          ,<span class="string">&quot;100ask_gpio_key&quot;</span></span><br><span class="line">                          ,&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line"></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span></span><br><span class="line">                  , MKDEV(major, <span class="number">0</span>)</span><br><span class="line">                  , <span class="literal">NULL</span></span><br><span class="line">                  , <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="4-ying-yong-bian-xie">4.应用编写</span><a href="#4-ying-yong-bian-xie" class="header-anchor">#</a></h1><p>应用程序要做的事情有这几件：</p>
<ol>
<li><p>编写信号处理函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册信号处理函数：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGIO, sig_func);</span><br></pre></td></tr></table></figure></li>
<li><p>打开驱动：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(argv[<span class="number">1</span>], O_RDWR);<span class="comment">//./aout /dev/100ask_gpio_key</span></span><br></pre></td></tr></table></figure></li>
<li><p>把进程 ID 告诉驱动：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_SETOWN, getpid());</span><br></pre></td></tr></table></figure>
<p> 使能驱动的 FASYNC 功能：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | FASYNC);</span><br></pre></td></tr></table></figure></li>
</ol>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_func</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	signal(SIGIO, sig_func);</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fcntl(fd, F_SETOWN, getpid());</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags | FASYNC);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;www.100ask.net \n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/" data-id="clzf6gi8f00005suf3csghjjj" data-title="字符设备驱动-7-异步通知" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-6-poll底层驱动机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-07-30T15:52:56.000Z" itemprop="datePublished">2024-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/">字符设备驱动-6-poll底层驱动机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-qian-yan-yin-ru">1 前言引入</a><ul>
<li><a href="#1-1-zu-sai-yu-fei-zu-sai-io">1.1 阻塞与非阻塞IO</a></li>
<li><a href="#1-2-dai-chao-shi-de-zu-sai-io-poll-select">1.2 带超时的阻塞IO(poll&#x2F;select)</a><ul>
<li><a href="#1-2-1-select">1.2.1 select</a><ul>
<li><a href="#1-2-1-1-select-shi-yong-shi-li">1.2.1.1 select使用示例</a></li>
</ul>
</li>
<li><a href="#1-2-2-poll">1.2.2 poll</a><ul>
<li><a href="#1-2-2-1-polls-shi-yong-shi-li">1.2.2.1 polls使用示例</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-xiu-mian-huan-xing">1.3 休眠唤醒</a><ul>
<li><a href="#1-3-1-deng-dai-dui-lie">1.3.1 等待队列</a></li>
<li><a href="#1-3-2-deng-dai-dui-lie-xiang">1.3.2 等待队列项</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-poll-ji-zhi-qu-dong-di-ceng-yuan-li">3 poll机制驱动底层原理</a><ul>
<li><a href="#3-1-wo-men-qi-wang-de-poll-liu-cheng">3.1 我们期望的poll流程</a></li>
<li><a href="#3-2-linux-nei-he-shi-ji-de-poll-ji-zhi">3.2 Linux内核实际的poll机制</a></li>
</ul>
</li>
<li><a href="#4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li">4 poll驱动编程实例（gpio key为例）</a><ul>
<li><a href="#4-1-probe-han-shu-fen-xi">4.1 probe函数分析</a></li>
<li><a href="#4-2-drv-poll-han-shu-fen-xi">4.2 drv_poll函数分析</a></li>
<li><a href="#4-3-drv-read-han-shu-fen-xi">4.3 drv_read函数分析</a></li>
<li><a href="#4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi">4.4 按键中断服务函数分析</a></li>
<li><a href="#4-5-ce-shi">4.5 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-qian-yan-yin-ru">1 前言引入</span><a href="#1-qian-yan-yin-ru" class="header-anchor">#</a></h1><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/">字符设备驱动-3-GPIO驱动KEY示例 | Hexo (fuzidage.github.io)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17080773.html">字符设备驱动-3.gpio驱动(按键) - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>就引入了poll机制，那么底层驱动的poll机制实现原理到底是什么呢？</p>
<h2><span id="1-1-zu-sai-yu-fei-zu-sai-io">1.1 阻塞与非阻塞IO</span><a href="#1-1-zu-sai-yu-fei-zu-sai-io" class="header-anchor">#</a></h2><p>APP 调用 open 函数时，不要传入<code>“ O_NONBLOCK”</code>。APP  调用 read 函数读取数据时,为<code>阻塞io</code>。<br>APP 调用 open 函数时，传入<code>“ O_NONBLOCK”</code>表示<code>“非阻塞”</code>。APP 调用 read 函数读取数据时，如果驱动程序中有数据，那么 APP 的 read函数会返回数据，否则也会立刻返回错误。这种需要APP反复主动去”轮询”设备，否则无法及时响应。<br>注意：对于普通文件、块设备文件，<code>O_NONBLOCK</code>不起作用。<br>注意：对于字符设备文件，<code>O_NONBLOCK </code>起作用的前提是驱动程序针对<code>O_NONBLOCK</code>做了处理<br>只能在 open 时表明 <code>O_NONBLOCK </code>吗？<br>在 open 之后，也可以通过 fcntl 修改为阻塞或非阻塞：<br>⚫ open 时设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(“/dev/xxx”, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞方式 */</span></span><br><span class="line"><span class="type">int</span> fd = open(“/dev/xxx”, O_RDWR ); <span class="comment">/* 阻塞方式 */</span></span><br></pre></td></tr></table></figure>
<p>⚫ open 之后设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">/* 非阻塞方式 */</span></span><br><span class="line">fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK); <span class="comment">/* 阻塞方式 */</span></span><br></pre></td></tr></table></figure>

<p>驱动<code>O_NONBLOCK </code>flag的话，如果没有数据read函数立即返回。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/1.png" alt="image"></p>
<h2><span id="1-2-dai-chao-shi-de-zu-sai-io-poll-x2f-select">1.2 带超时的阻塞IO(poll&#x2F;select)</span><a href="#1-2-dai-chao-shi-de-zu-sai-io-poll-x2f-select" class="header-anchor">#</a></h2><p><code>POLL </code>机制、<code>SELECT</code>机制是完全一样的，只是 APP 接口函数不一样。简单地说，它们就是 <code>“定个闹钟” </code>：在调用 poll、 select 函数时可以传入<code>“超时时间”</code>。在这段时间内，条件合适时(比如有数据可读、有空间可写)就会立刻返回，否则等到“超时时间”结束时返回错误。<br>使用 poll 时，如果传入的超时时间不为 0，这种访问方法也是阻塞的。<br>使用 poll 时，可以设置超时时间为 0，这样即使没有数据它也会立刻返回，这就是非阻塞方式。</p>
<h3><span id="1-2-1-select">1.2.1 select</span><a href="#1-2-1-select" class="header-anchor">#</a></h3><p>select会循环遍历它所监测的<code>fd_set</code>内的所有文件描述符对应的驱动程序的poll函数。select通过每个设备文件对应的poll函数提供的信息判断当前是否有资源可用(如可读或写)，如果有的话则返回可用资源的文件描述符个数，没有的话则睡眠，等待有资源变为可用时再被唤醒继续执行。</p>
<p>那么select会有2个结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, 查询到资源，返回查询到的fd总数。</span><br><span class="line"><span class="number">2</span>，没查到，则睡眠</span><br><span class="line">	①带timeout参数，timeout后，唤醒退出，此时fd总数为<span class="number">0</span></span><br><span class="line">	②不带timeout, 阻塞且睡眠中，直到有资源可用才唤醒</span><br></pre></td></tr></table></figure>

<p>fd_set结构体就是一个可用资源文件描述符的集合。</p>
<h4><span id="1-2-1-1-select-shi-yong-shi-li">1.2.1.1 select使用示例</span><a href="#1-2-1-1-select-shi-yong-shi-li" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_SET(<span class="type">int</span> fd, fd_set *fdset);       <span class="comment">//将fd加入set集合</span></span><br><span class="line">FD_CLR(<span class="type">int</span> fd, fd_set *fdset);       <span class="comment">//将fd从set集合中清除</span></span><br><span class="line">FD_ISSET(<span class="type">int</span> fd, fd_set *fdset);     <span class="comment">//检测fd是否在set集合中，不在则返回0</span></span><br><span class="line">FD_ZERO(fd_set *fdset);              <span class="comment">//将set清零使集合中不含任何fd</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<p>该示例假如传入200us的timeout，表示200us内有被驱动唤醒就可以检测到fd在set集合中，从而调用read读取数据。假如不传入timeout，那么select查询会立即返回。</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(&amp;wfds);</span><br><span class="line">FD_SET(fd, &amp;wfds);</span><br><span class="line">tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">tv.tv_usec = <span class="number">100</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">clock_gettime(CLOCK_MONOTONIC, &amp;start);</span><br><span class="line"></span><br><span class="line">ret = select(fd + <span class="number">1</span>, <span class="literal">NULL</span>, &amp;wfds, <span class="literal">NULL</span>, &amp;tv)) == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;select error(%s)\n&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;select timeout\n&quot;</span>);</span><br><span class="line">	ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(fd, &amp;wfds)) &#123;</span><br><span class="line">	<span class="comment">//start write data to drv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>该示例传入100ms的timeout，表示100ms内有被驱动唤醒就可以检测到fd在set集合中，从而<code>start write data to drv</code>, 否则<code>select timeout</code>.</p>
<h3><span id="1-2-2-poll">1.2.2 poll</span><a href="#1-2-2-poll" class="header-anchor">#</a></h3><p>使用休眠唤醒机制，实现简单。比如前面所讲的一个按键字符设备驱动中，read函数中进行等待队列<code>wait_event</code>, 然后当按键按下，中断服务程序进行唤醒等待队列wake_up，read函数将会从休眠中唤醒返回数据给用户。</p>
<p>但是这种有一个缺点，如果要等很久，那么这种方式明显不好。 如果按键一直不去按下，read函数将会一直休眠，应用程序用户线程被一直阻塞。</p>
<pre><code>1. 那么poll机制就是给它加一个超时机制，防止一直休眠和用户线程被阻塞。
2. APP 不知道驱动程序中是否有数据，可以先调用 poll 函数查询一下， poll 函数可以传入超时时间；
3. APP 进入内核态，调用到驱动程序的 poll 函数
    3.1 如果发现没有数据时就休眠一段时间；当超时时间到了之后，内核也会唤醒 APP；
    3.2 当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒 APP；
4. APP 根据 poll 函数的返回值就可以知道是否有数据，如果有数据就调用read 得到数据
</code></pre>
<h4><span id="1-2-2-1-polls-shi-yong-shi-li">1.2.2.1 polls使用示例</span><a href="#1-2-2-1-polls-shi-yong-shi-li" class="header-anchor">#</a></h4><p>poll&#x2F;select 监测的事件<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line"><span class="type">nfds_t</span> nfds = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">	fds[<span class="number">0</span>].events  = POLLIN;</span><br><span class="line">	fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">	ret = poll(fds, nfds, <span class="number">5000</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fds[<span class="number">0</span>].revents == POLLIN) &#123;</span><br><span class="line">			<span class="keyword">while</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;time out\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;poll err\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>打开设备文件。</li>
<li>设置 pollfd 结构体：<br>   想查询哪个文件(fd)？<br>   想查询什么事件(POLLIN)？<br>   先清除 “返回的事件” (revents)。<br>   使用 poll 函数查询事件，指定超时时间为 5000(ms)。</li>
</ol>
<h2><span id="1-3-xiu-mian-huan-xing">1.3 休眠唤醒</span><a href="#1-3-xiu-mian-huan-xing" class="header-anchor">#</a></h2><p>这里由于poll底层机制提前用到了一个休眠唤醒机制，也就是<code>等待队列wait_queue</code>。先提前引入概念，</p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制 | Hexo (fuzidage.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制 - fuzidage - 博客园 (cnblogs.com)</a> 有展开细讲。</p>
<h3><span id="1-3-1-deng-dai-dui-lie">1.3.1 等待队列</span><a href="#1-3-1-deng-dai-dui-lie" class="header-anchor">#</a></h3><p><strong>wait_event_interruptible_timeout:</strong><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_waitqueue_head</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_interruptible</span><span class="params">(<span class="type">wait_queue_head_t</span> *q)</span></span><br><span class="line"><span class="title function_">wait_event</span><span class="params">(wq, condition)</span>;</span><br><span class="line">wait_event_timeout(wq, condition, timeout);</span><br><span class="line">wait_event_interruptible(wq, condition);</span><br><span class="line">wait_event_interruptible_timeout(wq, condition, timeout);</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-2-deng-dai-dui-lie-xiang">1.3.2 等待队列项</span><a href="#1-3-2-deng-dai-dui-lie-xiang" class="header-anchor">#</a></h3><p>利用等待队列项来实现read函数的阻塞式访问，底层驱动去进行状态切换。下图把wait_event的方式换成等待队列项。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="3-poll-ji-zhi-qu-dong-di-ceng-yuan-li">3 poll机制驱动底层原理</span><a href="#3-poll-ji-zhi-qu-dong-di-ceng-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-wo-men-qi-wang-de-poll-liu-cheng">3.1 我们期望的poll流程</span><a href="#3-1-wo-men-qi-wang-de-poll-liu-cheng" class="header-anchor">#</a></h2><p>我们期望的大致流程如下：<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<pre><code>1. app进行open, drv进行drv_open，注册好中断服务
2. app进行poll , drv进行drv_poll
3. 第一次如果没有数据到来，那么会执行else进行休眠，加入等待队列。
    要么被中断服务程序唤醒，进入for循环此时有数据到来返回；
    要么超时，也会从等待队列唤醒回来，进入for循环此时返回超时
</code></pre>
<p>可以看到会查询判断2次，但实际上内核做的更好，我们drv_poll中只需要（这些流程内核帮我们已经做好了）：</p>
<pre><code>1.把线程放入wq等待队列，并不会调用休眠
2.返回event状态
</code></pre>
<h2><span id="3-2-linux-nei-he-shi-ji-de-poll-ji-zhi">3.2 Linux内核实际的poll机制</span><a href="#3-2-linux-nei-he-shi-ji-de-poll-ji-zhi" class="header-anchor">#</a></h2><p>实际内核中poll函数流程如下：内核把poll抽出去了，调用<code>sys_poll</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<pre><code>1. app进行open, drv进行drv_open，注册好中断服务
2. app进行poll , 内核文件系统进行sys_poll
3. 调用驱动开发者实现的drv_poll
    调用poll_wait,把线程加入wq，但是不会进入休眠
    而是直接返回event状态
4. drv_poll返回后，sys_poll中进行数据判断（如果第一次进入没有数据到来，执行else, 将线程休眠（可以看到休眠是drv_poll上层sys_poll已经帮我们做好了），如果有数据则直接返回,那么就只会进入一次drv_poll）
   sys_poll函数执行else休眠的过程中，会被event唤醒or被超时唤醒
   第2进入for循环执行drv_poll，如果被event唤醒了，则返回数据，否则说明是超时唤醒，返回超时
5.最终内核文件系统sys_poll返回，唤醒userspace线程
</code></pre>
<p>可以看到当用户调用poll函数，在底层drv下可能会调用2次<code>drv_poll</code>。用户线程不会被一直阻塞休眠，要么有数据时中断的<code>event</code>唤醒，要么超时唤醒。我们只要实现<code>drv_poll</code>的部分，也就是紫色绿色的提示部分。</p>
<h1><span id="4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li">4 poll驱动编程实例（gpio key为例）</span><a href="#4-poll-qu-dong-bian-cheng-shi-li-gpio-key-wei-li" class="header-anchor">#</a></h1><p>使用 poll 机制时，驱动程序的核心就是提供对应的 drv_poll 函数。在drv_poll 函数中要做 2 件事：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 把当前线程挂入队列 wq： poll_wait</span><br><span class="line">	a) APP 调用一次 poll，可能会 drv_poll 被调用 2 次，但是我们并不需要把当前线程挂入队列 2 次。</span><br><span class="line">	b) 可以使用内核的函数 poll_wait 把线程挂入队列，如果线程已经在队列里了，它就不会再次挂入。</span><br><span class="line">2. 返回设备状态：</span><br><span class="line">	APP 调用 poll 函数时，有可能是查询“有没有数据可以读”： POLLIN</span><br><span class="line">	也有可能是查询“你有没有空间给我写数据”： POLLOUT。</span><br><span class="line">	所以 drv_poll 要返回自己的当前状态： (POLLIN | POLLRDNORM) 或 (POLLOUT | POLLWRNORM)。</span><br><span class="line">a) POLLRDNORM 等同于 POLLIN，为了兼容某些 APP 把它们一起返回。</span><br><span class="line">b) POLLWRNORM 等同于 POLLOUT ，为了兼容某些 APP 把它们一起返回。</span><br></pre></td></tr></table></figure>
<p>APP 调用 poll 后，很有可能会休眠。对应的，在中断服务程序中，也要有唤醒操作。<br>完整驱动代码如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty()) &#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (file-&gt;f_flags &amp; O_NONBLOCK) &#123; <span class="comment">/* 非阻塞访问 */</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="type">atomic_read</span>(&amp;dev-&gt;releasekey) == <span class="number">0</span>) <span class="comment">/* 没有按键按下 */</span></span><br><span class="line">			<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">		key = get_key();</span><br><span class="line">		err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 			&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);<span class="comment">/* /sys/class/100ask_gpio_key_class */</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="4-1-probe-han-shu-fen-xi">4.1 probe函数分析</span><a href="#4-1-probe-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/9.png" alt="image"></p>
<p>定义gpio_key:<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/10.png" alt="image"><br>先确保dts中含有<code>gpio_key</code>设备树节点，才能通过<code>.compatible = &quot;100ask,gpio_key&quot;</code>匹配<code>plateform_device</code>和<code>platform_driver</code>, 当<code>insmod ko</code>时probe函数被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;<span class="comment">//可以从platform_device获取到device_node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/11.png" alt="image"><br><code>of_gpio_count</code>可以根据设备树节点获取到gpio的数量。</p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/12.png" alt="image"><br><code>of_get_gpio_flags</code>可以根据设备树节点获取到gpio编号和<code>gpio flags</code></p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/13.png" alt="image"><br>获取gpio描述子和gpio中断号</p>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/14.png" alt="image"><br>注册中断服务程序<code>gpio_key_isr</code>，当按键按下会触发gpio中断，执行<code>gpio_key_isr</code>.</p>
<h2><span id="4-2-drv-poll-han-shu-fen-xi">4.2 drv_poll函数分析</span><a href="#4-2-drv-poll-han-shu-fen-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br></pre></td></tr></table></figure>
<p>这里先定义并初始化一个<code>wait_queue gpio_key_wait</code>,也就是等待队列。（等待队列使用详见kernel下include\linux\wait.h）<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<ol>
<li><p><code>drv_poll</code>函数中call <code>poll_wait</code>将线程加入等待队列，并返回<code>event</code>。 </p>
<ol>
<li>可以看到如果有数据，返回<code>POLLIN | POLLRDNORM</code>(那么<code>drv_poll</code>只会被调用1次)； 回到<code>sys_poll</code></li>
<li>如果没有数据则返回0, 也回到<code>sys_poll</code></li>
</ol>
</li>
<li><p>回到<code>sys_poll</code>后发现:</p>
</li>
<li><p>如果有数据，直接返回</p>
</li>
<li><p>如果没有数据则进入休眠，当超时或者被<code>event</code>唤醒后，<code>sys_poll</code>又会再次进入<code>drv_poll</code>，此时判断<code>is_key_buf_empty</code>，如果是按键按下触发中断响应，那么就有数据，返回<code>POLLIN | POLLRDNORM</code>，否则无数据表示是被超时唤醒，event为0。这种就是<code>sys_poll</code>调用2次。</p>
</li>
</ol>
<pre><code>3.`sys_poll`最终返回，回到`userspace`线程
</code></pre>
<h2><span id="4-3-drv-read-han-shu-fen-xi">4.3 drv_read函数分析</span><a href="#4-3-drv-read-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/16.png" alt="image"><br>当userspace得知驱动有数据时，调用read函数，进入<code>drv_read</code>中调用<code>wait_event_interruptible</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/17.png" alt="image"><br>这里是利用等待队列，等待队列<code>gpio_key_wait</code>的<code>event</code>为true后，<code>wait_event_interruptible</code>该函数会返回。那么在对应的中断处理函数中，需要call <code>wake_up</code>函数来唤醒等待队列，并且把<code>event</code>设置成true，也就是把<code>wait_event_interruptible</code>的<code>condition</code>设置成true.</p>
<h2><span id="4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi">4.4 按键中断服务函数分析</span><a href="#4-4-an-jian-zhong-duan-fu-wu-han-shu-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/18.png" alt="image"><br><code>put_key</code>是将<code>event</code>设置成true,这样表示有数据了，<code>is_key_buf_empty</code>非空了。调用<code>wake_up_interrptible</code>函数唤醒等待队列<code>gpio_key_wait</code>，因此<code>drv_read</code>函数就能立马返回数据。</p>
<h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><p>测试demo用户态程序如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_gpio_key</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fds[<span class="number">0</span>].fd = fd;</span><br><span class="line">	fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		ret = poll(fds, <span class="number">1</span>, timeout_ms);</span><br><span class="line">		<span class="keyword">if</span> ((ret == <span class="number">1</span>) &amp;&amp; (fds[<span class="number">0</span>].revents &amp; POLLIN))&#123;</span><br><span class="line">			read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/" data-id="clza4viul000254ufbxw2gro2" data-title="字符设备驱动-6-poll底层驱动机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-6-pre-休眠唤醒机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-07-30T13:52:56.000Z" itemprop="datePublished">2024-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xiu-mian-yu-huan-xing">1 休眠与唤醒</a><ul>
<li><a href="#1-0-yin-ru-shang-xia-wen-gai-nian">1.0 引入上下文概念</a><ul>
<li><a href="#1-0-1-jin-cheng-shang-xia-wen">1.0.1 进程上下文</a></li>
<li><a href="#1-0-1-zhong-duan-shang-xia-wen">1.0.1 中断上下文</a></li>
</ul>
</li>
<li><a href="#1-1-xiu-mian-han-shu">1.1 休眠函数</a></li>
<li><a href="#1-2-huan-xing-han-shu">1.2 唤醒函数</a></li>
<li><a href="#1-3-shi-yong">1.3 使用</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xiu-mian-yu-huan-xing">1 休眠与唤醒</span><a href="#1-xiu-mian-yu-huan-xing" class="header-anchor">#</a></h1><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/1.png" alt="image"></p>
<pre><code>1.APP 调用 read 等函数试图读取数据，比如读取按键；
2.APP 进入内核态，也就是调用驱动中的对应函数，发现有数据则复制到用户空间并马上返回；
3.如果 APP 在内核态，也就是在驱动程序中发现没有数据，则 APP 休眠；
4.当有数据时，比如当按下按键时，驱动程序的中断服务程序被调用，它会记录数据、唤醒 APP；
5.APP 继续运行它的内核态代码，也就是驱动程序中的函数，复制数据到用户空间并马上返回
</code></pre>
<p>drv_read函数当没有数据时需要休眠等待有数据唤醒。当按下按键，驱动程序中的中断服务程序被调用，它会记录数据，并唤醒 APP的read函数。</p>
<h2><span id="1-0-yin-ru-shang-xia-wen-gai-nian">1.0 引入上下文概念</span><a href="#1-0-yin-ru-shang-xia-wen-gai-nian" class="header-anchor">#</a></h2><p>app执行整个过程如下图，可以把它看作被拆分成2段：被叫做<code>“上下文”</code>。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h3><span id="1-0-1-jin-cheng-shang-xia-wen">1.0.1 进程上下文</span><a href="#1-0-1-jin-cheng-shang-xia-wen" class="header-anchor">#</a></h3><p>或者这样说：红实线所涉及的代码，都是APP调用的，被叫做<code>进程上下文</code>，drv_read中有数据直接返回数据，没有数据的话让出CPU休眠等待。</p>
<h3><span id="1-0-1-zhong-duan-shang-xia-wen">1.0.1 中断上下文</span><a href="#1-0-1-zhong-duan-shang-xia-wen" class="header-anchor">#</a></h3><p>但是按键的中断服务程序，不属于APP的 <code>“上下文”</code>，这是突如其来的，当中断发生时，APP1 正在休眠呢。在 APP 的<code>“上下文”</code>，也就是在 APP的执行过程中，它是可以休眠的。<br>在中断的处理过程中，也就是<code>gpio_key_irq</code>的执行过程中，它不能休眠：<code>“中断”</code>怎么能休眠？<code>“中断”</code>休眠了，谁来调度其他 APP 啊？<br>所以<strong>：在中断处理函数中，不能休眠，也就不能调用会导致休眠的函数</strong>, 被叫做<code>中断上下文</code>。</p>
<h2><span id="1-1-xiu-mian-han-shu">1.1 休眠函数</span><a href="#1-1-xiu-mian-han-shu" class="header-anchor">#</a></h2><p>内核源码：<code>include\linux\wait.h</code><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/3.png" alt="image"><br>参数1：<code>wq:</code> <code>waitqueue</code>等待队列<br>用来等待条件值，<code>condition</code>不为0则立即返回<br>参数2：<code>condition</code><br>这可以是一个变量，也可以是任何表达式。表示“一直等待，直到 <code>condition</code>为真</p>
<h2><span id="1-2-huan-xing-han-shu">1.2 唤醒函数</span><a href="#1-2-huan-xing-han-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<h2><span id="1-3-shi-yong">1.3 使用</span><a href="#1-3-shi-yong" class="header-anchor">#</a></h2><p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<p>1.read函数中进行<code>wait_event_interruptible</code>，因此需要初始化一个<code>wq</code>, 用<code>init_waitqueue_head</code>函数进行初始化等待队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wait_queue_head_t</span> job_done_wq;</span><br><span class="line">init_waitqueue_head(&amp;job-&gt;job_done_wq);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/6.png" alt="image"><br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/7.png" alt="image"><br>或者用<code>DECLARE_WAIT_QUEUE_HEAD</code>声明定义初始化一起。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br></pre></td></tr></table></figure>
<p>read函数判断是否有key，有key则直接返回，否则<code>wait_event_interruptible</code>休眠。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/9.png" alt="image"></p>
<pre><code>wait_event_interruptible(gpio_key_wait, g_key);
</code></pre>
<p>2.如果按键按下了，中断isr进行响应，调用<code>wake_up_interruptible</code>,并且设置<code>condition</code>为true.驱动的read函数将会被唤醒。<br><img src="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_key = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	wait_event_interruptible(gpio_key_wait, g_key);</span><br><span class="line">	err = copy_to_user(buf, &amp;g_key, <span class="number">4</span>);</span><br><span class="line">	g_key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	g_key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 			&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>驱动代码2(使用环形buf存放键值)</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 环形缓冲区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, 		&amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>app代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		read(fd, &amp;val, <span class="number">4</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;get button : 0x%x\n&quot;</span>, val);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/" data-id="clza4viuj000054ufcjvvfgt3" data-title="字符设备驱动-6-pre-休眠唤醒机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-5-设备树函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T12:22:21.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/">字符设备驱动-5-设备树函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</a></li>
<li><a href="#2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</a><ul>
<li><a href="#2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</a></li>
<li><a href="#2-2-zhao-jie-dian">2.2 找节点</a></li>
<li><a href="#2-3-zhao-dao-shu-xing">2.3 找到属性</a><ul>
<li><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</a></li>
<li><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</a></li>
</ul>
</li>
<li><a href="#2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</a></li>
<li><a href="#2-5-du-zheng-shu-u32-u64">2.5 读整数 u32&#x2F;u64</a></li>
<li><a href="#2-6-du-shu-zu">2.6 读数组</a></li>
<li><a href="#2-7-du-zi-fu-chuan">2.7 读字符串</a></li>
<li><a href="#2-8-qi-ta-of-han-shu">2.8 其他of函数</a></li>
</ul>
</li>
<li><a href="#3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</a><ul>
<li><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</a></li>
<li><a href="#3-2-qu-dong-cheng-xu">3.2 驱动程序</a></li>
</ul>
</li>
<li><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</a><ul>
<li><a href="#4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</a><ul>
<li><a href="#4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</a></li>
<li><a href="#4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</a></li>
<li><a href="#4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</a><ul>
<li><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</a><ul>
<li><a href="#4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</a></li>
</ul>
</li>
<li><a href="#4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</a><ul>
<li><a href="#5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</a></li>
<li><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</a></li>
<li><a href="#5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</span><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian" class="header-anchor">#</a></h1><p>1.处理 <code>DTB</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of_fdt.h <span class="comment">// dtb 文件的相关操作函数, 我们一般用不到,</span></span><br><span class="line"><span class="comment">// 因为 dtb 文件在内核中已经被转换为 device_node 树(它更易于使用)</span></span><br></pre></td></tr></table></figure>
<p>2.处理 <code>device_node</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">of.h <span class="comment">// 提供设备树的一般处理函数,</span></span><br><span class="line"><span class="comment">// 比如 of_property_read_u32(读取某个属性的 u32 值),</span></span><br><span class="line"><span class="comment">// of_get_child_count(获取某个 device_node 的子节点数)</span></span><br><span class="line">of_address.h <span class="comment">// 地址相关的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_get_address(获得 reg 属性中的 addr, size 值)</span></span><br><span class="line"><span class="comment">// of_match_device (从 matches 数组中取出与当前设备最匹配的一项)</span></span><br><span class="line">of_dma.h <span class="comment">// 设备树中 DMA 相关属性的函数</span></span><br><span class="line">of_gpio.h <span class="comment">// GPIO 相关的函数</span></span><br><span class="line">of_graph.h <span class="comment">// GPU 相关驱动中用到的函数, 从设备树中获得 GPU 信息</span></span><br><span class="line">of_iommu.h <span class="comment">// 很少用到</span></span><br><span class="line">of_irq.h <span class="comment">// 中断相关的函数</span></span><br><span class="line">of_mdio.h <span class="comment">// MDIO (Ethernet PHY) API</span></span><br><span class="line">of_net.h <span class="comment">// OF helpers for network devices.</span></span><br><span class="line">of_pci.h <span class="comment">// PCI 相关函数</span></span><br><span class="line">of_pdt.h <span class="comment">// 很少用到</span></span><br><span class="line">of_reserved_mem.h <span class="comment">// reserved_mem 的相关函数</span></span><br></pre></td></tr></table></figure>
<p>3.处理<code> platform_device</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">of_platform.h <span class="comment">// 把 device_node 转换为 platform_device 时用到的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_device_alloc(根据 device_node 分配设置 platform_device),</span></span><br><span class="line"><span class="comment">// of_find_device_by_node (根据 device_node 查找到 platform_device),</span></span><br><span class="line"><span class="comment">// of_platform_bus_probe (处理 device_node 及它的子节点)</span></span><br><span class="line">of_device.h <span class="comment">// 设备相关的函数, 比如 of_match_device</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</span><a href="#2-she-bei-shu-xiang-guan-de-han-shu" class="header-anchor">#</a></h1><h2><span id="2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</span><a href="#2-1-zhao-res-shu-xing-he-platform-device" class="header-anchor">#</a></h2><p><strong>of_find_device_by_node</strong><br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_find_device_by_node</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span>;</span><br></pre></td></tr></table></figure>
<p>设备树中的每一个节点，在内核里都有一个 <code>device_node</code>；你可以使用device_node 去找到对应的 <code>platform_device</code>。</p>
<p><strong>platform_get_resource</strong><br>这 个 函 数 跟 设 备 树 没 什 么 关 系 ， 但 是 设 备 树 中 的 节 点 被 转 换 为<code> platform_device</code> 后，设备树中的<code> reg 属性、interrupts 属性</code>也会被转换为<code>“resource”</code>。 这时，你可以使用这个函数取出这些资源。<br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* platform_get_resource - get a resource for a device</span></span><br><span class="line"><span class="comment">* @dev: platform device</span></span><br><span class="line"><span class="comment">* @type: resource type // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG</span></span><br><span class="line"><span class="comment">* // IORESOURCE_IRQ 等</span></span><br><span class="line"><span class="comment">* @num: resource index // 这类资源中的哪一个？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>
<p>对于设备树节点中的 reg 属性，它对应 <code>IORESOURCE_MEM</code> 类型的资源； 对于设备树节点中的 interrupts 属性，它对应 <code>IORESOURCE_IRQ</code> 类型的资源。</p>
<h2><span id="2-2-zhao-jie-dian">2.2 找节点</span><a href="#2-2-zhao-jie-dian" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/1.png" alt="image"></p>
<p><strong>of_find_node_by_path</strong><br>根据路径找到节点，比如<code>“/”</code>就对应根节点，<code>“/memory”</code>对应 memory 节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;c</span><br></pre></td></tr></table></figure>

<p><strong>of_find_node_by_name</strong><br>根据名字找到节点，节点如果定义了 name 属性，那我们可以根据名字找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from,<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“name”</code>属性，所以这函数也不建议 使用。<br><strong>of_find_node_by_type</strong><br>根据类型找到节点，节点如果定义了 device_type 属性，那我们可以根据类型找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“device_type”</code>属性，所以这函数也不建议使用。<br><strong>of_find_compatible_node</strong><br>根据<code> device_type</code>和<code>compatible</code> 找到节点，节点如果定义了 <code>compatible</code> 属性，那我们可以根据 <code>compatible </code>属性找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <code>from </code>表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
<li>参数 <code>compat </code>是一个字符串，用来指定 <code>compatible </code>属性的值；</li>
<li>参数<code>type </code>是一个字符串，用来指定 <code>device_type</code> 属性的值，可以传入 NULL。</li>
</ul>
<p><strong>of_find_node_by_phandle</strong><br>根据 <code>phandle </code>找到节点。<code>dts</code> 文件被编译为 <code>dtb </code>文件时，每一个节点都有一个数字 ID，这些数字 ID 彼此不同。可以使用数字 ID 来找到 <code>device_node</code>。 这些数字 ID 就是<code> phandle</code>。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_phandle</span><span class="params">(phandle handle)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>of_find_matching_node_and_match</strong><br>通过<code> of_device_id</code> 匹配表来查找指定的节点.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</span></span><br><span class="line"><span class="comment">//matches：of_device_id 匹配表，也就是在此匹配表里面查找节点。</span></span><br><span class="line"><span class="comment">//match：找到的匹配的 of_device_id。</span></span><br><span class="line"><span class="comment">//返回值：找到的节点，如果为 NULL 表示查找失败</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br></pre></td></tr></table></figure>

<p><strong>of_get_parent</strong><br>找到 <code>device_node</code> 的父节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_parent</strong><br>这个函数名比较奇怪，怎么可能有<code>“next parent”</code>？<br>它实际上也是找到 device_node 的父节点，跟<code> of_get_parent</code> 的返回结果是一样的。差别在于它多调用下列函数，把 node 节点的引用计数减少了 1。这意味着 调用<code> of_get_next_parent</code> 之后，你不再需要调用<code> of_node_put</code> 释放 node 节点。<br><code>of_node_put(node);</code><br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_parent</span><span class="params">(<span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_child</strong><br>取出下一个子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p>不断调用 <code>of_get_next_child </code>时，不断更新<code>pre</code>参数，就可以得到所有的子节点。<br><strong>of_get_next_available_child</strong><br>取出下一个 “可用” 的子节点，有些节点的 status 是<code>“disabled”</code>，那就会跳过这些节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_available_child</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p><strong>of_get_child_by_name</strong><br>根据名字取出子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_child_by_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>name 表示子节点的名字。</li>
</ul>
<h2><span id="2-3-zhao-dao-shu-xing">2.3 找到属性</span><a href="#2-3-zhao-dao-shu-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2.png" alt="image"></p>
<p><strong>of_find_property</strong><br>内核源码 <code>incldue/linux/of.h </code>中声明了 device_node 的操作函数，当然也包括属性的操作函数：<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: proper = of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数np表示节点，我们要在这个节点中找到名为 name 的属性。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<h3><span id="2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</span><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ion_heap0: heap_carveout@<span class="number">0</span> &#123;</span><br><span class="line">	memory-region = &lt;&amp;ion_for_npu&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_parse_phandle</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *phandle_name, <span class="type">int</span> index)</span>；</span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="comment">// get reserved memory-region</span></span><br><span class="line">res_node = of_parse_phandle(np, <span class="string">&quot;memory-region&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res_node) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get memory region node\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">ret = of_address_to_resource(res_node, <span class="number">0</span>, res);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get reserved region address\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</span><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> resource *r)</span>；</span><br></pre></td></tr></table></figure>
<h2><span id="2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</span><a href="#2-4-huo-qu-shu-xing-de-zhi" class="header-anchor">#</a></h2><p><strong>of_get_property</strong><br>根据名字找到节点的属性，并且返回它的值。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Find a property with a given name for a given node</span></span><br><span class="line"><span class="comment">* and return the value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">of_get_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数 np 表示节点，我们要在这个节点中找到名为 name 的属性，然后返回它的值。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<p><strong>of_property_count_elems_of_size</strong><br>根据名字找到节点的属性，确定它的值有多少个元素(elem)。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* of_property_count_elems_of_size - Count the number of elements in a property</span><br><span class="line">*</span><br><span class="line">* @np:</span><br><span class="line">* device node from which the property value is to be read.</span><br><span class="line">* @propname: name of the property to be searched.</span><br><span class="line">* @elem_size: size of the individual element</span><br><span class="line">*</span><br><span class="line">* Search <span class="keyword">for</span> a property in a device node and count the number of elements of</span><br><span class="line">* size elem_size in it. Returns number of elements on sucess, -EINVAL <span class="keyword">if</span> the</span><br><span class="line">* property does not exist or its length does not match a multiple of elem_size</span><br><span class="line">* and -ENODATA <span class="keyword">if</span> the property does not have a value.</span><br><span class="line">*/</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_count_elems_of_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">int</span> elem_size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数 np 表示节点，我们要在这个节点中找到名为 propname 的属性，然后返回下列结果：<br>  <code>return prop-&gt;length / elem_size;</code><br>  在设备树中，节点大概是这样：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	xxx_pp_name = &lt;<span class="number">0x50000000</span> <span class="number">1024</span>&gt; &lt;<span class="number">0x60000000</span> <span class="number">2048</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>of_property_count_elems_of_size(np, “xxx_pp_name”, 8)</code>时，返回值是 2；</p>
</li>
<li><p>调用<code> of_property_count_elems_of_size(np, “xxx_pp_name”, 4)</code>时，返回值是 4。</p>
</li>
</ul>
<h2><span id="2-5-du-zheng-shu-u32-x2f-u64">2.5 读整数 u32&#x2F;u64</span><a href="#2-5-du-zheng-shu-u32-x2f-u64" class="header-anchor">#</a></h2><p><strong>of_property_read_u32</strong><br><strong>of_property_read_u64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_value)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u64</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name1 = &lt;<span class="number">0x50000000</span>&gt;;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name1”, &amp;val)</code>时，val 将得到值 0x50000000；</li>
<li>调用 <code>of_property_read_u64 (np, “name2”, &amp;val)</code>时，val 将得到值 0x6000000050000000。</li>
</ul>
<p><strong>读某个整数 u32&#x2F;u64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u32_index</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 index, u32 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name2”, 1, &amp;val)</code>时，val 将得到值 0x60000000。</li>
</ul>
<h2><span id="2-6-du-shu-zu">2.6 读数组</span><a href="#2-6-du-shu-zu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u8_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u8 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u16_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u16 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u64_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000012</span> <span class="number">0x60000034</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述例子中属性 name2 的值，长度为 8。</p>
<ul>
<li>调用 <code>of_property_read_variable_u8_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 8 个字节： <code>0x12,0x00,0x00,0x50,0x34,0x00,0x00,0x60</code>。</li>
<li>调用 <code>of_property_read_variable_u16_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 4 个 16 位数值： <code>0x0012, 0x5000,0x0034,0x6000</code>。<br>总之，这些函数要么能取到全部的数值，要么一个数值都取不到；</li>
<li>如果值的长度在 <code>sz_min</code> 和 <code>sz_max</code> 之间，就返回全部的数值；</li>
<li>否则一个数值都不返回。</li>
</ul>
<h2><span id="2-7-du-zi-fu-chuan">2.7 读字符串</span><a href="#2-7-du-zi-fu-chuan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">const</span> <span class="type">char</span> **out_string)</span>;</span><br><span class="line"><span class="comment">// eg:of_property_read_string(dtsled.nd, &quot;status&quot;, &amp;str);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回节点 np 的属性(名为 <code>propname</code>)的值; </li>
<li><code>(*out_string)</code>指向这个值，把它当作字符串</li>
</ul>
<h2><span id="2-8-qi-ta-of-han-shu">2.8 其他of函数</span><a href="#2-8-qi-ta-of-han-shu" class="header-anchor">#</a></h2><p><strong>of_device_is_compatible</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_device_is_compatible</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">	device_node *device, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<p>检查设备节点的兼容性, 用于查看节点的 <code>compatible</code>属性是否有包含 <code>compat</code>指定的字符。</p>
<p><strong>of_translate_address</strong><br>函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> __be32 *addr)</span>；</span><br></pre></td></tr></table></figure>

<p><strong>of_address_to_resource</strong><br>根据设备节点转成资源信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index, <span class="keyword">struct</span> resource *r)</span>;</span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//index：地址资源标号。</span></span><br><span class="line"><span class="comment">//r：得到的 resource 类型的资源值。</span></span><br><span class="line"><span class="comment">//返回值：0，成功；负值，失败。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2-1.png" alt="image"><br><code>IIC、 SPI、 GPIO</code>等这些外设都有对应的寄存器，这些寄存器其实就是一组内存 空间， Linux内核使用 resource结构体来描述一段内存空间。<br>对于 32位的 SOC来说，<code> resource_size_t</code>是 u32类型的。其中 start表示开始地址， end表示结束地址， name是这个资源的名字， flags是资源标志位，一般表示资源类型，可选的资源标志定义在文件 <code>include/linux/ioport.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM          0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_REG          0x00000300      <span class="comment">/* Register offsets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ          0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA          0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS          0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_PREFETCH     0x00002000      <span class="comment">/* No side effects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_READONLY     0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_CACHEABLE    0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_RANGELENGTH  0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SHADOWABLE   0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SIZEALIGN    0x00040000      <span class="comment">/* size indicates alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_STARTALIGN   0x00080000      <span class="comment">/* start field is alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM_64       0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_WINDOW       0x00200000      <span class="comment">/* forwarded by bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MUXED        0x00400000      <span class="comment">/* Resource is software muxed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXT_TYPE_BITS 0x01000000     <span class="comment">/* Resource extended types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM       0x01000000      <span class="comment">/* System RAM (modifier) */</span></span></span><br><span class="line"><span class="comment">/* IORESOURCE_SYSRAM specific bits. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_DRIVER_MANAGED        0x02000000 <span class="comment">/* Always detected via a driver. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_MERGEABLE             0x04000000 <span class="comment">/* Resource can be merged. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXCLUSIVE    0x08000000      <span class="comment">/* Userland may not map this resource */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DISABLED     0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_UNSET        0x20000000      <span class="comment">/* No address assigned yet */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_AUTO         0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUSY         0x80000000      <span class="comment">/* Driver has marked this resource busy */</span></span></span><br></pre></td></tr></table></figure>

<p>常 见 的 资 源 标 志 就 是<code> IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ</code>。</p>
<p><strong>of_iomap</strong><br>以前我们会通过<code>ioremap</code>函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过<code> of_iomap</code> 函数来获取内存地址所对应的虚拟地址，不需要使用 <code>ioremap</code> 函数。<br><code>of_iomap </code>函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __iomem *<span class="title function_">of_iomap</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</span><a href="#3-shi-yong-she-bei-shu-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</span><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian" class="header-anchor">#</a></h2><p>led灯dts定义在根节点下,作为根节点子节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alphaled &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-led&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	reg = &lt; <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">/* CCM_CCGR1_BASE */</span></span><br><span class="line">	<span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">/* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">/* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">/* GPIO1_DR_BASE */</span></span><br><span class="line">	<span class="number">0X0209C004</span> <span class="number">0X04</span> &gt;; <span class="comment">/* GPIO1_GDIR_BASE */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-qu-dong-cheng-xu">3.2 驱动程序</span><a href="#3-2-qu-dong-cheng-xu" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_CNT			1		  	<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_NAME			<span class="string">&quot;dtsled&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 					0			<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 					1			<span class="comment">/* 开灯 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> <span class="title">dtsled</span>;</span>	<span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(sta == LEDON) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LEDOFF) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;dtsled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		led_switch(LEDON);		<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		led_switch(LEDOFF);	<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dtsled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	u32 regdata[<span class="number">14</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取设备树中的属性数据 */</span></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：alphaled */</span></span><br><span class="line">	dtsled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(dtsled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node nost find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、获取compatible属性内容 */</span></span><br><span class="line">	proper = of_find_property(dtsled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(proper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible = %s\r\n&quot;</span>, (<span class="type">char</span>*)proper-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、获取status属性内容 */</span></span><br><span class="line">	ret = of_property_read_string(dtsled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;status read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、获取reg属性内容 */</span></span><br><span class="line">	ret = of_property_read_u32_array(dtsled.nd, <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u8 i = <span class="number">0</span>;</span><br><span class="line">		printk(<span class="string">&quot;reg data:\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">		printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化LED */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 1、寄存器地址映射 */</span></span><br><span class="line">	IMX6U_CCM_CCGR1 = ioremap(regdata[<span class="number">0</span>], regdata[<span class="number">1</span>]);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="number">2</span>], regdata[<span class="number">3</span>]);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="number">4</span>], regdata[<span class="number">5</span>]);</span><br><span class="line">	GPIO1_DR = ioremap(regdata[<span class="number">6</span>], regdata[<span class="number">7</span>]);</span><br><span class="line">	GPIO1_GDIR = ioremap(regdata[<span class="number">8</span>], regdata[<span class="number">9</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, <span class="number">0</span>);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">1</span>);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">2</span>);</span><br><span class="line">	GPIO1_DR = of_iomap(dtsled.nd, <span class="number">3</span>);</span><br><span class="line">	GPIO1_GDIR = of_iomap(dtsled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、使能GPIO1时钟 */</span></span><br><span class="line">	val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">	val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 清楚以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 设置新值 */</span></span><br><span class="line">	writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment">	 *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment">	 *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment">	 *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">	val = readl(GPIO1_GDIR);</span><br><span class="line">	val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 设置为输出 */</span></span><br><span class="line">	writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">	val = readl(GPIO1_DR);</span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">	writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dtsled.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		dtsled.devid = MKDEV(dtsled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT, DTSLED_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		dtsled.major = MAJOR(dtsled.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		dtsled.minor = MINOR(dtsled.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;dtsled major=%d,minor=%d\r\n&quot;</span>,dtsled.major, dtsled.minor);	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">	dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">	cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dtsled.class = class_create(THIS_MODULE, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 取消映射 */</span></span><br><span class="line">	iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">	iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">	iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">	iounmap(GPIO1_DR);</span><br><span class="line">	iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">	cdev_del(&amp;dtsled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(dtsled.devid, DTSLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">	class_destroy(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</span><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng" class="header-anchor">#</a></h1><h2><span id="4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</span><a href="#4-1-jie-xi-root-dts-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>;</span></span><br><span class="line">    mdesc = setup_machine_fdt(__atags_pointer);</span><br><span class="line">    ...</span><br><span class="line">    arm_memblock_init(mdesc);</span><br><span class="line">    ...</span><br><span class="line">    unflatten_device_tree();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_machine_fdt() </code>根据传入的设备树dtb的首地址完成一些初始化操作。<br><code>arm_memblock_init()</code> 主要是内存相关，为设备树保留相应的内存空间，保证设备树dtb本身存在于内存中而不被覆盖。<br><code>unflatten_device_tree()</code>对设备树具体的解析，将设备树各节点转换成相应的struct device_node结构体.</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/3.png" alt="image-20240728203202947"></p>
<h3><span id="4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</span><a href="#4-1-1-setup-machine-fdt" class="header-anchor">#</a></h3><p>参数<code>__atags_pointer</code>就是 r2 的寄存器值，是设备树在内存中的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> * <span class="function">__init <span class="title">setup_machine_fdt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dt_phys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> *mdesc, *mdesc_best = <span class="literal">NULL</span>;                    </span><br><span class="line">    <span class="keyword">if</span> (!dt_phys || !<span class="built_in">early_init_dt_verify</span>(<span class="built_in">phys_to_virt</span>(dt_phys)))           ——————part <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mdesc = <span class="built_in">of_flat_dt_match_machine</span>(mdesc_best, arch_get_next_mach);       ——————part <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">early_init_dt_scan_nodes</span>();                                             ——————part <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一部分先将设备树在内存中的物理地址转换为虚拟地址，uboot 传递给内核的设备树地址为物理地址，因为设备树被放置在内存的线性映射区，因此可以简单地通过偏移计算得出其对应的虚拟地址，然后再<code>early_init_dt_verify</code>检查该地址上是否有设备树的魔数(<code>magic</code>)。检查设备树是否匹配成功。最后将设备树地址赋值给全局变量 <code>initial_boot_params</code>。</p>
</li>
<li><p><code>of_flat_dt_match_machine(mdesc_best, arch_get_next_mach)</code>，逐一读取dts根目录下的 compatible 属性, 返回<code>machine_desc</code>结构体。</p>
</li>
<li><p>第三部分就是扫描设备树中的各节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">early_init_dt_scan_nodes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line">    <span class="comment">//boot_command_line是一个静态数组，存放着启动参数,</span></span><br><span class="line">    <span class="comment">//而of_scan_flat_dt()函数的作用就是扫描设备树中的节点，然后对各节点分别调用传入的回调函数。</span></span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这3个函数分别是处理<code>chosen</code>节点、root节点中除子节点外的属性信息、memory节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">early_init_dt_scan_chosen</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    p = <span class="built_in">of_get_flat_dt_prop</span>(node, <span class="string">&quot;bootargs&quot;</span>, &amp;l);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; l &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">strlcpy</span>(data, p, <span class="built_in">min</span>((<span class="type">int</span>)l, COMMAND_LINE_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>获取<code> bootargs</code>，然后将<code>bootargs</code>放入<code>boot_command_line</code>中，作为启动参数，而并非处理整个chosen节点。</p>
<p>再看第二个函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_root</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;</span><br><span class="line">    dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#size-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">   		dt_root_size_cells = be32_to_cpup(prop);</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#address-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">    	dt_root_addr_cells = be32_to_cpup(prop);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 root 节点中的<code>#size-cells</code>和 <code>#address-cells</code>属性提取出来，并非获取root节点中所有的属性，放到全局变量<code>dt_root_size_cells</code>和<code>dt_root_addr_cells</code>中。</p>
<p>接下来看第三个函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_memory</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PPC32) || depth != <span class="number">1</span> || <span class="built_in">strcmp</span>(uname, <span class="string">&quot;memory@0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    reg = of_get_flat_dt_prop(node, <span class="string">&quot;reg&quot;</span>, &amp;l);</span><br><span class="line">    endp = reg + (l / <span class="keyword">sizeof</span>(__be32));</span><br><span class="line">    <span class="keyword">while</span> ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123;</span><br><span class="line">    base = dt_mem_next_cell(dt_root_addr_cells, &amp;reg);</span><br><span class="line">    size = dt_mem_next_cell(dt_root_size_cells, &amp;reg);</span><br><span class="line">    early_init_dt_add_memory_arch(base, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数先判断节点的<code>uname</code>是<code>memory@0</code>,如果不是，则返回。然后将所有memory相关的reg属性取出来，根据<code>address-cell</code>和<code>size-cell</code>的值进行解析，然后调用<code>early_init_dt_add_memory_arch()</code>来申请相应的内存空间。</p>
<p>到这里，<code>setup_machine_fdt()</code>函数对于设备树的第一次扫描解析就完成了，主要是获取了一些设备树提供的总览信息。</p>
<h3><span id="4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</span><a href="#4-1-2-arm-memblock-init" class="header-anchor">#</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __init <span class="title">arm_memblock_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> machine_desc *mdesc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">early_init_fdt_reserve_self</span>();</span><br><span class="line">    <span class="built_in">early_init_fdt_scan_reserved_mem</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描设备树节点中的<code>&quot;reserved-memory&quot;</code>节点，为其分配保留空间。</p>
<h3><span id="4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</span><a href="#4-1-3-unflatten-device-tree" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/4.png" alt="image"></p>
<p>第一步是<code>__unflatten_device_tree</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/5.png" alt="image"></p>
<p><code>unflatten_dt_nodes</code>被调用两次，第一次是扫描得出设备树转换成device node需要的空间，然后系统申请内存空间，第二次就进行真正的解析工作。</p>
<h4><span id="4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</span><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/6.png" alt="image"></p>
<p>从根节点开始，对子节点依次调用<code>populate_node()</code>，从函数命名上来看，这个函数就是填充节点，为节点分配内存。</p>
<h5><span id="4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</span><a href="#4-1-3-1-1-populate-node" class="header-anchor">#</a></h5><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/7.png" alt="image"></p>
<p>为当前节点申请内存空间，使用<code>of_node_init() </code>函数对node进行初始化，<code>populate_properties</code>设置node属性。<code>populate_properties</code>设置节点的属性。</p>
<h4><span id="4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</span><a href="#4-1-3-2-of-alias-scan" class="header-anchor">#</a></h4><p><code>/* Get pointer to &quot;/chosen&quot; and &quot;/aliases&quot; nodes for use everywhere */</code>。</p>
<p>这句就能看出它是用来处理<code>aliases，chosen</code>等特殊节点的。处理带有别名的节点，函数实现细节如下：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/8.png" alt="image"></p>
<p>1.先处理<code>chosen</code>节点中的<code>&quot;stdout-path&quot;</code>或者<code>&quot;stdout&quot;</code>属性(两者最多存在其一)，然后将<code>stdout</code>指定的path赋值给全局变量<code>of_stdout_options</code>，并将返回的全局struct device_node类型数据赋值给<code>of_stdout</code>，指定系统启动时的log输出。</p>
<p>2.接下来为<code>aliases</code>节点申请内存空间，如果一个节点中同时没有 <code>name/phandle/linux,phandle</code>，则被定义为特殊节点，对于这些特殊节点将不会申请内存空间。</p>
<p>3.<code>of_alias_add</code>添加到alias链表。</p>
<h1><span id="5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</span><a href="#5-device-node-zhuan-huan-cheng-platform-device" class="header-anchor">#</a></h1><h2><span id="5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</span><a href="#5-0-zhuan-huan-guo-cheng-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">of_platform_default_populate_init()</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_default_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_bus_create()</span><br><span class="line">                    _____________________|_________________</span><br><span class="line">                    |                                      |</span><br><span class="line">            of_platform_device_create_pdata()       of_platform_bus_create()</span><br><span class="line">            _________________|____________________</span><br><span class="line">           |                                      |</span><br><span class="line">     of_device_alloc()                        of_device_add()</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</span><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian" class="header-anchor">#</a></h2><ul>
<li>一般情况下，只对设备树中根的一级子节点进行转换，也就是子节点的子节点并不处理。但是存在一种特殊情况，就是当某个根子节点的<code>compatible</code>属性为<code>&quot;simple-bus&quot;、&quot;simple-mfd&quot;、&quot;isa&quot;、&quot;arm,amba-bus&quot;</code>时，当前节点中的子节点将会被转换成platform_device节点。</li>
<li>节点中必须有<code>compatible</code>属性。</li>
</ul>
<p>设备树节点的<code>reg</code>和 <code>interrupts </code>资源将会被转换成 platform_device 内的 <code>struct resources </code>资源。</p>
<h2><span id="5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</span><a href="#5-2-zhuan-huan-guo-cheng-jie-xi" class="header-anchor">#</a></h2><p>展开<code>of_platform_device_create_pdata</code>:</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/9.png" alt="image"></p>
<p>调用<code>of_device_alloc</code>，可以看到为设备树节点分配了一个<code>dev(struct platform_device)</code>，展开<code>of_device_alloc</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/10.png" alt="image"></p>
<p>可以看到把设备树节点的属性转成platform_device的<code>io，irq等资源</code>信息。同时将<code>device_node *np</code>指针记录到<code>dev-&gt;dev.of_node</code>。这样就建立了设备树节点到platform_device的转换关系。</p>
<p>然后调用<code>of_device_add</code>注册到系统device中去。</p>
<p>最后调用<code>of_platform_bus_create</code>在用户空间创建相应的访问节点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/" data-id="clz5jnp3u0000kouff86g0luq" data-title="字符设备驱动-5-设备树函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-4-设备树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T11:23:03.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/">字符设备驱动-4-设备树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-yong-she-bei-shu">1 引用设备树</a><ul>
<li><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</a></li>
</ul>
</li>
<li><a href="#2-she-bei-shu-de-yu-fa">2 设备树的语法</a><ul>
<li><a href="#2-1-dts-wen-jian">2.1 DTS 文件</a><ul>
<li><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</a></li>
<li><a href="#2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</a></li>
<li><a href="#2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</a><ul>
<li><a href="#2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</a></li>
<li><a href="#2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</a></li>
</ul>
</li>
<li><a href="#2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</a><ul>
<li><a href="#2-1-4-1-address-cells">2.1.4.1 #address-cells</a></li>
<li><a href="#2-1-4-2-size-cells">2.1.4.2 #size-cells</a></li>
<li><a href="#2-1-4-3-compatible">2.1.4.3 compatible</a></li>
<li><a href="#2-1-4-4-model">2.1.4.4 model</a></li>
<li><a href="#2-1-4-5-phandle">2.1.4.5 phandle</a></li>
<li><a href="#2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</a></li>
<li><a href="#2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</a></li>
<li><a href="#2-1-4-8-reg">2.1.4.8 reg</a></li>
<li><a href="#2-1-4-8-status">2.1.4.8 status</a></li>
<li><a href="#2-1-4-9-ranges">2.1.4.9 ranges</a></li>
<li><a href="#2-1-4-10-device-type">2.1.4.10 device_type</a></li>
</ul>
</li>
<li><a href="#2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</a><ul>
<li><a href="#2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</a></li>
<li><a href="#2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</a></li>
</ul>
</li>
<li><a href="#2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</a><ul>
<li><a href="#2-1-6-1-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</a></li>
<li><a href="#2-1-6-2-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</a></li>
<li><a href="#2-1-6-3-gen-jie-dian">2.1.6.3 &#x2F;根节点</a></li>
</ul>
</li>
<li><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</a></li>
<li><a href="#2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</a></li>
<li><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</a><ul>
<li><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</a></li>
<li><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</a><ul>
<li><a href="#2-1-9-2-1-documentation-devicetree-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-dtb-wen-jian">2.2 DTB文件</a><ul>
<li><a href="#2-2-1-struct-ftd-header">2.2.1 struct ftd_header</a></li>
<li><a href="#2-2-2-memory-reservation-block">2.2.2 memory reservation block</a></li>
<li><a href="#2-2-3-structure-block">2.2.3 structure block</a></li>
<li><a href="#2-2-4-strings-block">2.2.4 strings block</a></li>
</ul>
</li>
<li><a href="#2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</a><ul>
<li><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</a></li>
<li><a href="#2-3-2-shou-gong-bian-yi">2.3.2 手工编译</a></li>
<li><a href="#2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</a></li>
</ul>
</li>
<li><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</a><ul>
<li><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</a></li>
<li><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</a></li>
<li><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wan-zheng-dts-shi-li">3 完整dts示例</a><ul>
<li><a href="#3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</a></li>
<li><a href="#3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</a><ul>
<li><a href="#3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</a></li>
<li><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</a><ul>
<li><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yin-yong-she-bei-shu">1 引用设备树</span><a href="#1-yin-yong-she-bei-shu" class="header-anchor">#</a></h1><p>在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如 A 板用 GPIO A，B 板用 GPIO B， 如果用<code>plateform_device</code>定义资源信息，那么每次单板硬件资源变动后，都要改驱动程序源码，重新编译驱动，重新加载驱动，非常麻烦。<br>随着 ARM 芯片的流行，内核中针对这些 ARM 板保存有大量的、没有技术含量的文件。 Linus 大发雷霆：<code>&quot;this whole ARM thing is a f*cking pain in the ass&quot;</code>。于是，Linux 内核开始引入设备树。 设备树并不是重新发明出来的，在 Linux 内核中其他平台如 <code>PowerPC</code>，早就使用设备树来描述硬件了。<br>设备树只是用来给内核里的驱动程序，指定硬件的信息。</p>
<h2><span id="1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</span><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/1.png" alt="image"></p>
<p>烧录的dtb文件,显然两者是完全相同的。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/2.png" alt="image"></p>
<p>除了原始的dtb文件，根文件系统还以目录结构的方式呈现dtb文件,在<code>devicetree</code>目录下，则有一个<code>base</code>目录，这个base目录，就对应着根节点。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/3.png" alt="image"></p>
<p>base目录下，每一个节点对应一个目录, 每一个属性对应一个文件. 这些属性的值如果是字符串，可以使用 cat 命令把它打印出来。对于数值，可以用 <code>hexdump</code> 把它打印出来。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/4.png" alt="image-20240728192831389"></p>
<p>进入<code>led</code>目录，里面一共有三个文件，除<code>name</code>外，分别对应着led节点的两个属性，cat属性如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/5.png" alt="image"></p>
<p><code>pin</code>属性的值为<code>0x00 05 00 05</code>，也就是<code>GPF5</code>.<br>如果节点没有设置<code>name</code>属性，那么转换为<code>device_node</code>时，会将节点自己的名称作为<code>name</code>属性值。 所以这里<code>name</code>是<code>led</code>.<br>根文件系统下也可以查看<code>platform_device</code>。系统中所有的<code>platform_device</code>，都可以在<code>/sys/devices/platform/</code>路径下查看。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/6.png" alt="image"></p>
<p>另外，系统中所有的<code>platform_device</code>，有来自设备树的，也有来自<code>.c</code>文件中注册的。那么，我们怎么知道哪些<code>platform_device</code>是来自设备树，哪些是来自.c文件中注册的？</p>
<pre><code>答：可以查看该platform_device的相关目录下，是否有of_node，如果有of_node，那么这个platform_device就来自于设备树；否则，来自.c文件。
</code></pre>
<p>以<code>led</code>为例，进入led目录，可以看到有<code>of_node</code>，说明这个<code>platform_device</code>来自设备树。同时，可以看到这个<code>of_node</code>是一个链接文件，指向的是<code>/sys/firmware/devicetree/base/led</code>。也就是说，可以进入 <code>/sys/devices/platform/&lt;设备名&gt;/of_node</code> 查看它的设备树属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/7.png" alt="image"></p>
<p>在&#x2F;proc下有一个链接文件<code>device-tree</code>，它指向的是<code>/sys/firmware/devicetree/base</code><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/8.png" alt="image"></p>
<h1><span id="2-she-bei-shu-de-yu-fa">2 设备树的语法</span><a href="#2-she-bei-shu-de-yu-fa" class="header-anchor">#</a></h1><p>设备树文件(<code>dts: device tree source</code>)，它需要编译为<code> dtb(device tree blob)</code>文件，内核使用的是 dtb 文件。</p>
<h2><span id="2-1-dts-wen-jian">2.1 DTS 文件</span><a href="#2-1-dts-wen-jian" class="header-anchor">#</a></h2><h3><span id="2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</span><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju" class="header-anchor">#</a></h3><p>设备树源文件通常以dts为后缀，其总体布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">[memory reservations]</span><br><span class="line">/&#123;</span><br><span class="line">	[property definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上各项的含义分别为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dts-v1&#x2F;</td>
<td>设备树文件的版本</td>
</tr>
<tr>
<td>memory reservations</td>
<td>指定保留内存，内核不会使用保留内存</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>根节点（使用花括号括出属于根节点的内容）</td>
</tr>
<tr>
<td>property definitions</td>
<td>根节点的属性，用来描述硬件</td>
</tr>
<tr>
<td>child nodes</td>
<td>孩子节点（使用花括号括出属于孩子节点的内容）</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</span><a href="#2-1-2-memory-reservations-de-ge-shi" class="header-anchor">#</a></h3><p>该项是可选项，如果想要保留一段内存不让内核使用，可用如下格式指定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	address    指定要保留的内存的起始地址</span></span><br><span class="line"><span class="comment">	length     指定要保留的内存的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">/memreserve/&lt;address&gt;&lt;length&gt;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>address</code>和&#96;length都是64位。</p>
<h3><span id="2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</span><a href="#2-1-3-shu-xing-de-ge-shi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 属性有值 [label:] property-name = value;</span><br><span class="line">• 属性没有值 [label:] property-name;</span><br></pre></td></tr></table></figure>
<p>其中各项的含义：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>标签</td>
</tr>
<tr>
<td>property-name</td>
<td>属性名</td>
</tr>
<tr>
<td>value</td>
<td>属性值</td>
</tr>
</tbody></table>
<h4><span id="2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</span><a href="#2-1-3-1-you-guan-shu-xing-ming" class="header-anchor">#</a></h4><p>属性名的长度为<code>1~31</code>个字符，可以自己取，只要能够提供可以解读该属性名的驱动即可。也有一些属性名有着特定的含义，比如<code>compatible</code>用于表示哪个或哪些驱动支持该设备。对于自己命名的属性，并非所有字符均可组成属性名，它需要由以下字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/9.png" alt="image"></p>
<h4><span id="2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</span><a href="#2-1-3-2-you-guan-shu-xing-zhi" class="header-anchor">#</a></h4><p>属性值有以下四种：</p>
<ol>
<li><p><code>array of cells</code> 一个cell就是一个u32类型的数据，一个或多个cell用尖括号括起来，并以空格隔开就可以作为一种合法的属性值，如</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = &lt;<span class="number">0x1</span> <span class="number">0x2</span> <span class="number">0x3</span>&gt;;。</span><br></pre></td></tr></table></figure></li>
<li><p>含有结束符的<strong>字符串</strong> 如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = <span class="string">&quot;example value&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>字节序列</strong> 用方括号括起一个或多个字节，字节之间可用也可不用空格隔开，且字节以两位16进制数表示，如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = [<span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];</span><br></pre></td></tr></table></figure></li>
<li><p><strong>以上三种值的混合</strong>（以逗号隔开） 如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,mpc8641&quot;</span>, <span class="string">&quot;ns16550&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ 文本字符串（包含’\0’结束符）用双引号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>-property=<span class="string">&quot;a string&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ Cells（32位无符号整数）用尖括号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell-property = &lt;<span class="number">0xbeef</span> <span class="number">123</span> <span class="number">0xabcd1234</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 64bit 数据使用 2 个 cell 来表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;; </span><br></pre></td></tr></table></figure>
<p> ◆ 二进制数据用方括号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary-property=[<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>];</span><br></pre></td></tr></table></figure>
<p> ◆ 类型不同的数据的组合也是可以的，但需要用逗号隔开：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed-property=<span class="string">&quot;a string&quot;</span>, [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>], &lt;<span class="number">0x12345678</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 逗号同样用于创建字符串列表：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>-<span class="built_in">list</span> = <span class="string">&quot;red fish&quot;</span>, <span class="string">&quot;blue fish&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">	node1 &#123;</span><br><span class="line">		a-<span class="built_in">string</span>-property = <span class="string">&quot;A string&quot;</span>;</span><br><span class="line">		a-<span class="built_in">string</span>-<span class="built_in">list</span>-property = <span class="string">&quot;first string&quot;</span>, <span class="string">&quot;second string&quot;</span>;</span><br><span class="line">		a-byte-data-property = [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x34</span> <span class="number">0x56</span>];</span><br><span class="line">		child-node1 &#123;</span><br><span class="line">			first-child-property;</span><br><span class="line">			second-child-property = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">			a-<span class="built_in">string</span>-property = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		child-node2 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	node2 &#123;</span><br><span class="line">		an-empty-property;</span><br><span class="line">		a-cell-property = &lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;; <span class="comment">/* each number (cell) is a uint32 */</span></span><br><span class="line">		child-node1 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</span><a href="#2-1-4-yi-xie-te-ding-de-shu-xing" class="header-anchor">#</a></h3><p>设备树文件中有一些特定的属性，他们拥有约定俗成的名称和含义，在<code>devicetree-specification</code>中，这些属性被称为<code>Standard Properties</code>，我们在使用这些属性时，应当遵守相应的约定。这些属性有很多，我将在下文中介绍它们中的一部分。</p>
<h4><span id="2-1-4-1-address-cells">2.1.4.1 #address-cells</span><a href="#2-1-4-1-address-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用使用多少个cell，也即使用多少个u32整数来表示地址（对于32位系统，一个u32整数就够了；而对于64位系统，需要两个u32整数）。</p>
<h4><span id="2-1-4-2-size-cells">2.1.4.2 #size-cells</span><a href="#2-1-4-2-size-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用多少个cell，也即使用多少个u32整数来表示大小（一段地址空间的长度）。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/10.png" alt="image"></p>
<h4><span id="2-1-4-3-compatible">2.1.4.3 compatible</span><a href="#2-1-4-3-compatible" class="header-anchor">#</a></h4><p>其值为一个或多个字符串，用来描述支持该设备的驱动程序。比如，该属性位于根节点时，用于指定内核中哪个<code>machine_desc</code>可以支持本设备，即当前设备与哪些平台兼容。其值的格式一般是<code>&quot;manufacturer, model&quot;</code>，其中<code>manufacturer</code>表示厂家，<code>model</code>表示型号（厂家的哪型产品）。<br>当该属性的值有多个字符串时，从左往右，从最特殊到最一般。举例来说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;samsung,smdk2416&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>&quot;samsung, s3c2416&quot;</code> 作为根节点的属性时，第一个字符串指示了一个具体的开发板型号，而第二个字符串要更一般，只指示了SoC的型号。在linux初始化时，会优先找支持<code>&quot;samsung,smdk2416&quot;</code>的<code>machine_desc</code>用以初始化硬件，找不到时才退而求其次找到<code>&quot;samsung, s3c2416&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">led &#123; </span><br><span class="line">	compatible = “A”, “B”, “C”; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p><code>“compatible”</code>表示“兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱 动都支持它。</p>
<h4><span id="2-1-4-4-model">2.1.4.4 model</span><a href="#2-1-4-4-model" class="header-anchor">#</a></h4><p>其值为一个字符串，用来描述当前设备的型号（单板的名字）。当多个设备的<code>compatible</code>相同时，可以通过model来进一步区分多个设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>, <span class="string">&quot;samsung,mini2440&quot;</span>; </span><br><span class="line">	model = <span class="string">&quot;jz2440_v3&quot;</span>; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>它表示<code>jz2440_v3</code>这个单板，可以兼容内核中的<code>“smdk2440”</code>，也兼容<code>“mini2440”</code>.</p>
<h4><span id="2-1-4-5-phandle">2.1.4.5 phandle</span><a href="#2-1-4-5-phandle" class="header-anchor">#</a></h4><p>该属性可以为节点指定一个全局唯一的数字标识符。这个标识符可以被需要引用该节点的另一个节点使用。举例来说，现有一个中断控制器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一个可以产生中断的设备，且这个设备的中断信号线连接到了上述中断控制器，为了描述清楚这种关系，该设备的设备节点就需要引用中断控制器的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</span><a href="#2-1-4-6-interrupt-controller" class="header-anchor">#</a></h4><p>这是一个没有值的属性，用在中断控制器的设备节点中，以表明这个节点描述的是一个中断控制器。</p>
<h4><span id="2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</span><a href="#2-1-4-7-interrupt-parent" class="header-anchor">#</a></h4><p>该属性用于可以产生中断，且中断信号连接到某中断控制器的设备的设备节点，用于表示该设备的中断信号连接到了哪个中断控制器。该属性的值通常是中断控制器设备节点的数字标识（<code>phandle</code>），具体示例在上文已经出现过了。</p>
<h4><span id="2-1-4-8-reg">2.1.4.8 reg</span><a href="#2-1-4-8-reg" class="header-anchor">#</a></h4><p>reg属性描述了设备资源在其父总线定义的地址空间内的地址。通俗的说，该属性使用一对或多对（地址，长度）来描述设备所占的地址空间。至于地址和长度使用多少个cell来表示呢？这取决于上文介绍的<code>#address-cells、#size-cells</code>属性的值。<br>举个例子，当：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x3000</span> <span class="number">0x20</span> <span class="number">0xFE00</span> <span class="number">0x100</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>那么<code>reg = &lt;0x3000 0x20 0xFE00 0x100&gt;</code>，表示该属性所属的设备占据了两块内存空间，第一块是以0x3000为起始的32字节内存块；第二块是以0xFE00为起始的256字节内存块。</p>
<h4><span id="2-1-4-8-status">2.1.4.8 status</span><a href="#2-1-4-8-status" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;uart1 &#123;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-9-ranges">2.1.4.9 ranges</span><a href="#2-1-4-9-ranges" class="header-anchor">#</a></h4><p><code>ranges</code>属性值可以为空或者按照 (<code>child-bus-address,parent-bus-address,length</code>)格式编写的数字组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">child-bus-address<span class="comment">//子总线地址空间的物理地址，由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">parent-bus-address<span class="comment">//父总线地址空间的物理地址，同样由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">length<span class="comment">//子地址空间的长度，由父节点的 #size-cells确定此地址长度所占用的字长。</span></span><br><span class="line"></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	interrupt-parent = &lt;&amp;gpc&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ranges</code>属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">soc &#123; </span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	ranges = &lt;<span class="number">0x0</span> <span class="number">0xe0000000</span> <span class="number">0x00100000</span>&gt;; </span><br><span class="line">	serial &#123; </span><br><span class="line">		device_type = <span class="string">&quot;serial&quot;</span>; </span><br><span class="line">		compatible = <span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x4600</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>soc定义的 ranges属性，值为<code> &lt;0x0 0xe0000000 0x00100000&gt;</code>，此属性值指定了一个 <code>1024KB(0x00100000)</code>的地址范围，子地址空间的物理起始地址为 <code>0x0</code>，父地址空间的物理起始地址为<code> 0xe0000000</code>。</p>
<p>serial是串口设备节点， reg属性定义了 serial设备寄存器的起始地址为 <code>0x4600</code>寄存器长度为<code> 0x100</code>。经过地址转换， serial设备可以从 <code>0xe0004600</code>开始进行读写操作，<code>0xe0004600=0x4600+0xe0000000</code>。</p>
<h4><span id="2-1-4-10-device-type">2.1.4.10 device_type</span><a href="#2-1-4-10-device-type" class="header-anchor">#</a></h4><p>此属性也被抛弃了。此属性只能用于 cpu节点或者 memory节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">    A53_0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span>&gt;;</span><br><span class="line">        enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        next-level-cache = &lt;&amp;CA53_L2&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</span><a href="#2-1-5-jie-dian-de-ge-shi" class="header-anchor">#</a></h3><p>节点的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:]node-name[@unit-address]&#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以uart节点为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	uart0: uart@fe001000 &#123; </span><br><span class="line">		compatible=<span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg=&lt;<span class="number">0xfe001000</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>节点名(<code>node-name</code>)长为1~31个字符，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/12.png" alt="image"></p>
<p>每个设备节点代表一个设备，因此节点名的命名通常要和设备相应，比如以太网控制器，我们可以给其取名<code>ethernet</code>。考虑到一个SoC中可能有多个以太网控制器，为了做区分，我们通常在其<strong>节点名后面加上设备的地址</strong>，也就是上文中出现的可选部分<code>@unit-address</code>。仍以以太网控制器为例，假如两个以太网控制器的寄存器组的首地址分别为<code>0xfe002000</code>和<code>0xfe003000</code>，那么相应的节点名可以取为<code>ethernet@fe002000</code>和<code>ethernet@fe003000</code>。<br>不难看出，设备节点允许嵌套，假设节点b嵌套于节点a中，那么节点a是节点b的父节点。根节点的名字比较特殊，就是一个斜杠&#x2F;，其他的设备节点都是根节点的孩子，或者孩子的孩子…因此，所有的设备节点呈现出一个树状的层次结构（设备树因此得名），下图就是一个例子：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/13.png" alt="image"></p>
<h4><span id="2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</span><a href="#2-1-5-1-tui-jian-de-jie-dian-ming" class="header-anchor">#</a></h4><p>关于节点的命名，官方有一些推荐的命名，具体可见<code>devicetree-specification-v0.3</code>的2.2.2节。</p>
<h4><span id="2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</span><a href="#2-1-5-2-jie-dian-de-lu-jing-ming" class="header-anchor">#</a></h4><p>在文件系统中有个术语叫文件的路径名（<code>pathname</code>），在按照树状结构组织的众多文件中，用以唯一标识某个文件。类似的，节点也有路径名的概念。将根节点类比为根目录，以上图为例，其中cpu0节点的路径名为<code>/cpus/cpu@0</code>。我们在给节点命名时，必须<strong>保证每个节点拥有唯一的路径名</strong>（注意区别于每个节点拥有唯一的节点名）。</p>
<h3><span id="2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</span><a href="#2-1-6-yi-xie-te-shu-de-jie-dian" class="header-anchor">#</a></h3><p>有一些特殊的节点不代表任何设备，而是有着特定的用途，本节就将介绍一些这样的节点。</p>
<h4><span id="2-1-6-1-x2f-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</span><a href="#2-1-6-1-x2f-aliases-jie-dian" class="header-anchor">#</a></h4><p><code>/aliases</code>节点应当作为根节点的孩子节点，用于定义一个或多个别名属性，每条别名属性会为一个设备节点的路径名设置一个别名，如下面这个例子所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">	serial0 =<span class="string">&quot;/simple-bus@fe000000/serial@llc500&quot;</span>;</span><br><span class="line">	ethernet0 =<span class="string">&quot;/simple-bus@fe000000/ethernet@31c000&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>别名只能由<code>1~31</code>个下面的字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/14.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/15.png" alt="image"></p>
<p><strong>别名通常以数字结尾</strong>，比如别名为<code>i2c1</code>，设备树的初始化程序在解析别名属性时，会将数字1记录在<code>struct alias_prop</code>结构的<code>id</code>成员中，使用<code>of_alias_get_id</code>可以获得这个数字。因为本文主要介绍设备树文件的格式，因此这里不再深究这部分内容。</p>
<h4><span id="2-1-6-2-x2f-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</span><a href="#2-1-6-2-x2f-chosen-jie-dian" class="header-anchor">#</a></h4><p><code>/chosen</code>节点应当用作根节点的孩子节点，有以下可选属性：<br>    • <code>bootargs</code><br>    • <code>stdout-path</code><br>    • <code>stdin-path</code><br>顾名思义，该节点可以指定启动参数、标准输出和标准输入，一个例子如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	......</span><br><span class="line">	chosen &#123;</span><br><span class="line">		bootargs =<span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上图中<code>chosen</code>节点仅仅设置了属性<code>“ stdout-path”</code>，表示标准输出使用 uart0。但是当我们进入到 <code>/proc/device-tree/chosen</code>目录里面，会发现多了<code> bootargs</code>属性，原因如下:<br><code>do_bootm_linux </code>函数会通过一系列复杂的调用，最终通过<code>fdt_chosen </code>函数在<code>chosen </code>节点中加入<br>了<code>bootargs </code>属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/17.png" alt="image"></p>
<p><code>do_bootm_linux</code>细节见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17960265">uboot-5_bootm&#x2F;bootz启动内核过程 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/">uboot-bootm和bootz启动内核 | Hexo (fuzidage.github.io)</a></p>
<h4><span id="2-1-6-3-x2f-gen-jie-dian">2.1.6.3 &#x2F;根节点</span><a href="#2-1-6-3-x2f-gen-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	model = <span class="string">&quot;SMDK24440&quot;</span>; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>根节点中必须有这些属性： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述地址(address) </span></span></span><br><span class="line"><span class="meta">#size-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述大小(size) </span></span></span><br><span class="line">compatible <span class="comment">// 定义一系列的字符串, 用来指定内核中哪个 machine_desc 可以支持本设备 (即这个板子兼容哪些平台) </span></span><br><span class="line">model <span class="comment">// 咱这个板子是什么</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/18.png" alt="image"><br>Linux内核通过根节点<code> compatible</code>属性找到对应的设备的函数调用过程如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/19.png" alt="image"></p>
<h3><span id="2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</span><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing" class="header-anchor">#</a></h3><p>一个完整的设备树文件（DTS文件），有一些节点是必须要有的，这些必要的节点有：</p>
<table>
<thead>
<tr>
<th>节点名</th>
<th>节点的必要属性</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>#address-cells、#size-cells、model、compatible</td>
</tr>
<tr>
<td>&#x2F;memory</td>
<td>device_type、reg</td>
</tr>
<tr>
<td>&#x2F;cpus</td>
<td>#address-cells、#size-cells</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*</td>
<td>device_type、reg、clock-frequency、timebase-frequency</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*&#x2F;l?-cache</td>
<td>compatible、cache-level</td>
</tr>
</tbody></table>
<h3><span id="2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</span><a href="#2-1-8-label-biao-qian-de-shi-yong" class="header-anchor">#</a></h3><p>在上文就提到过标签，只是没有细说，这里就介绍一下标签的使用。首先，标签名可由<code>1~31</code>个字符组成，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/20.png" alt="image"></p>
<p>接下来仍以中断控制器的例子来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">	&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>如果我们使用phandle来标识设备，当设备多了，数字标识符是比较难记忆的，可读性也差，此时可以使用标签：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PIC:pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;&amp;PIC&gt;;<span class="comment">/* 用标签来引用设备节点 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种常见的标签的用法，当我们需要修改某设备节点的属性，但又不想直接在原地修改（保持原来的内容不被破坏），此时可以在设备树文件的末尾重写该设备节点的相应属性，从而覆盖之前的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">/&#123;</span><br><span class="line">	device-node &#123;<span class="comment">/* 因此这样写比较麻烦（特别是在路径比较深的时候） */</span></span><br><span class="line">		p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么使用标签的写法就简单很多：标签名DN.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	DN:device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">&amp;DN&#123;</span><br><span class="line">	p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>修改节点</strong>，节点追加内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i2c0: i2c@<span class="number">29000000</span> &#123;</span><br><span class="line">	 compatible = <span class="string">&quot;snps,designware-i2c&quot;</span>;</span><br><span class="line">	 clocks = &lt;&amp;clk ATHENA2_CLK_I2C0&gt;;</span><br><span class="line">	 reg = &lt;<span class="number">0x0</span> <span class="number">0x29000000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	 clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line">	 <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">	 <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">	 resets = &lt;&amp;rst RST_I2C0&gt;;</span><br><span class="line">	 reset-names = <span class="string">&quot;i2c0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再另一个dts中使用i2c0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">		clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123; </span><br><span class="line">			compatible = <span class="string">&quot;fsl,mag3110&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0x0e</span>&gt;; </span><br><span class="line">			position = &lt;<span class="number">2</span>&gt;; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</span><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian" class="header-anchor">#</a></h3><h4><span id="2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</span><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian" class="header-anchor">#</a></h4><p>编写设备树文件时，我们通常会把多型设备的共性抽出来，写在<code>DTSI</code>文件（后缀为<code>.dtsi</code>）中，其语法与DTS文件一样。比如，多款使用了<code>am335x</code>的板子，因为使用了同一款SoC，描述设备时肯定会有一些相同的部分，可以把这部分抽出来，写到<code>am335x.dts</code>i中，然后在具体的某型板子的设备树中包含相应的DTSI文件，包含的方式有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/include/ “xxx.dtsi”</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “xxx.dtsi”</span></span><br></pre></td></tr></table></figure>

<p>设备树编译器还支持c语言的头文件，因此，如果有需要可以定义一些宏并在设备树文件中使用。</p>
<h4><span id="2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</span><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei" class="header-anchor">#</a></h4><h5><span id="2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</span><a href="#2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings" class="header-anchor">#</a></h5><p>设备树写出来是给驱动程序看的，也就是说驱动程序怎么写的，相应的设备树就该怎么写；或者反过来，先约定好设备树怎么写，在相应的设计驱动。驱动和设备树有着对应的关系，这种对应关系也被称为<code>bindings</code>。具体的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于上游芯片厂商，应当按照devicetree-specification推荐的设备树写法，遵守各种约定，确定好如何规范的描述设备，并提供相应的驱动程序。devicetree-specification-v0<span class="number">.3</span>的第四章给出了一些推荐的做法。</span><br><span class="line">对于下游产品厂商，当使用芯片厂商的芯片做产品时，芯片厂商通常会提供驱动程序和设备树文件编写的参考文档，这些文档位于linux内核源码树的Documentation/devicetree/bindings目录下。如果芯片厂商没提供相应文档的话，就要读驱动的源码，知道驱动怎么写的，自然也就知道如何写设备树了。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-dtb-wen-jian">2.2 DTB文件</span><a href="#2-2-dtb-wen-jian" class="header-anchor">#</a></h2><p>DTS文件只是文本文件，需要使用<strong>设备树编译器（DTC）将其编译为DTB文件（二进制文件）</strong>，然后才能传递给内核，内核解析的是DTB文件。dtb文件由四个部分组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/21.png" alt="image"></p>
<h3><span id="2-2-1-struct-ftd-header">2.2.1 struct ftd_header</span><a href="#2-2-1-struct-ftd-header" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">fdt32_t</span> magic;           <span class="comment">/* magic word FDT_MAGIC */</span></span><br><span class="line">    <span class="type">fdt32_t</span> totalsize;       <span class="comment">/* total size of DT block */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_struct;       <span class="comment">/* offset to structure */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_strings;      <span class="comment">/* offset to strings */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_mem_rsvmap;      <span class="comment">/* offset to memory reserve map */</span></span><br><span class="line">    <span class="type">fdt32_t</span> version;         <span class="comment">/* format version */</span></span><br><span class="line">    <span class="type">fdt32_t</span> last_comp_version;   <span class="comment">/* last compatible version */</span></span><br><span class="line">    <span class="comment">/* version 2 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> boot_cpuid_phys;     <span class="comment">/* Which physical CPU id we&#x27;re</span></span><br><span class="line"><span class="comment">    booting on */</span></span><br><span class="line">    <span class="comment">/* version 3 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_strings;     <span class="comment">/* size of the strings block */</span></span><br><span class="line">    <span class="comment">/* version 17 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_struct;      <span class="comment">/* size of the structure block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>totalsize</strong>:<br>这个设备树的size，也可以理解为所占用的实际内存空间。<br><strong>off_dt_struct</strong>:<br><code>offset to dt_struct</code>，表示整个dtb中<code>structure</code>部分所在内存相对头部的偏移地址<br><strong>off_dt_strings</strong>:<br><code>offset to dt_string</code>，表示整个dtb中<code>string</code>部分所在内存相对头部的偏移地址<br><strong>off_mem_rsvmap</strong>:<br><code>offset to memory reserve map</code>，dtb中<code>memory reserve map</code>所在内存相对头部的偏移地址</p>
<h3><span id="2-2-2-memory-reservation-block">2.2.2 memory reservation block</span><a href="#2-2-2-memory-reservation-block" class="header-anchor">#</a></h3><p>该部分由<code>memory reservations</code>编译得来，由一个或多个表项组成，每一项都描述了一块要保留的内存区域，每项由两个64位数值（起始地址、长度）组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/23.png" alt="image"></p>
<p>reserved memory作用：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17664807.html">设备驱动-15.内核kmalloc&#x2F;vmalloc及CMA内存介绍 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/">Linux内核-kmalloc与vmalloc及CMA内存 | Hexo (fuzidage.github.io)</a></p>
<h3><span id="2-2-3-structure-block">2.2.3 structure block</span><a href="#2-2-3-structure-block" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/24.png" alt="image"></p>
<h3><span id="2-2-4-strings-block">2.2.4 strings block</span><a href="#2-2-4-strings-block" class="header-anchor">#</a></h3><p>该部分类似于ELF文件中的字符串表，存储了所有属性名（字符串），考虑到很多节点拥有一些同名的属性，集中存放属性名可以有效的节约DTB文件的空间，存放有属性的<code>structure block</code>部分只需要保存一个32位的偏移值——属性名的起始位置在<code>strings block</code>中的偏移。</p>
<h2><span id="2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</span><a href="#2-3-dtb-wen-jian-de-bian-yi" class="header-anchor">#</a></h2><h3><span id="2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</span><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make" class="header-anchor">#</a></h3><p>进入内核源码的目录，执行如下命令即可编译 dtb 文件。<code>make all</code>命令是编译 Linux源码中的所有东西，包括 <code>zImage，dtb，.ko</code>驱动模块以及设备树，如果只是编译设备树的话建议使用<code>“ make dtbs”</code>命令。</p>
<pre><code>make dtbs V=1
</code></pre>
<h3><span id="2-3-2-shou-gong-bian-yi">2.3.2 手工编译</span><a href="#2-3-2-shou-gong-bian-yi" class="header-anchor">#</a></h3><p>内核目录下 <code>scripts/dtc/dtc</code> 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用<code>“#include”</code>，而必须使用<code>“/incldue”</code>。</p>
<p><strong>编译</strong>、反编译的示例命令如下，<code>“-I”</code>指定输入格式，<code>“-O”</code>指定输出格式，<code>“-o”</code>指定输出文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts <span class="comment">// 编译 dts 为 dtb </span></span><br><span class="line">./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb <span class="comment">// 反编译 dtb 为 dts </span></span><br></pre></td></tr></table></figure>

<p>DTC工具源码在 Linux内核的 <code>scripts/dtc</code>目录下，<code>scripts/dtc/Makefile</code>文件内容如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/25.png" alt="image"></p>
<h3><span id="2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</span><a href="#2-3-3-fan-bian-yi-dtb" class="header-anchor">#</a></h3><p>cd 板子所用的内核源码目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</span><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/26.png" alt="image"></p>
<p>① dts 在 PC 机上被编译为 dtb 文件；<br>② u-boot 把 dtb 文件传给内核；<br>③ 内核解析 dtb 文件，把每一个节点都转换为 <code>device_node</code> 结构体；<br>④ 对于某些 <code>device_node</code> 结构体，会被<code>platform_device</code> 结构体获取资源信息<br><strong>dts解析过程:</strong><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/27.png" alt="image"><br>最终实际dts解析的函数为<code>unflatten_dt_node</code>。</p>
<h3><span id="2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</span><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/28.png" alt="image"></p>
<p>根节点被保存在全局变量 <code>of_root</code> 中，从 <code>of_root </code>开始可以访问到任意节点。</p>
<h3><span id="2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</span><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/&#123; </span><br><span class="line">	mytest &#123;</span><br><span class="line">		compatile = <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		mytest@<span class="number">0</span> &#123; </span><br><span class="line">			compatile = <span class="string">&quot;mytest_0&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	i2c &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,i2c&quot;</span>; </span><br><span class="line">		at24c02 &#123; </span><br><span class="line">			compatile = <span class="string">&quot;at24c02&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">	spi &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,spi&quot;</span>; </span><br><span class="line">		flash@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;winbond,w25q32dw&quot;</span>; </span><br><span class="line">			spi-max-frequency = &lt;<span class="number">25000000</span>&gt;; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>①根节点下含有 <code>compatile</code> 属性的子节点<br>②含有特定 <code>compatile</code> 属性的节点的子节点 :</p>
<pre><code>如果一个节点的 compatile 属性，它的值是这 4 者之一：&quot;simple-bus&quot;,&quot;simple-mfd&quot;,&quot;isa&quot;,&quot;arm,amba-bus&quot;, 那 么 它 的 子结点 ( 需 含compatile 属性)也可以转换为 platform_device。 
</code></pre>
<p>③总线 I2C、SPI 节点下的子节点：不转换为<code>platform_device</code><br>    某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为<code> platform_device</code>。<br>    比如以下的节点中： </p>
<pre><code>⚫ /mytest 会被转换为 platform_device, 因为它兼容&quot;simple-bus&quot;; 它的子节点/mytest/mytest@0 也会被转换为 platform_device 
⚫ /i2c 节点一般表示 i2c 控制器, 它会被转换为 platform_device, 在内核 中有对应的 platform_driver; 
⚫ /i2c/at24c02 节点不会被转换为 platform_device, 它被如何处理完全由父节点的 platform_driver 决定, 一般是被创建为一个 i2c_client。 
⚫ 类似的也有/spi 节点, 它一般也是用来表示 SPI 控制器, 它会被转换为 platform_device, 在内核中有对应的 platform_driver; 
⚫ /spi/flash@0 节点不会被转换为 platform_device, 它被如何处理完全由 父节点的 platform_driver 决定, 一般是被创建为一个 spi_device。 
</code></pre>
<h3><span id="2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</span><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><pre><code>⚫ platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性; 
⚫ platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性
</code></pre>
<h1><span id="3-wan-zheng-dts-shi-li">3 完整dts示例</span><a href="#3-wan-zheng-dts-shi-li" class="header-anchor">#</a></h1><p>编写设备树之前要先定义一个设备，我们就以<code> I.MX6ULL</code>这个 SOC为例，我们需要在设备树里面描述的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①、 I.MX6ULL这个 Cortex-A7架构的 <span class="number">32</span>位 CPU。</span><br><span class="line">②、 I.MX6ULL内部 ocram，起始地址 <span class="number">0x00900000</span>，大小为 <span class="number">128</span>KB(<span class="number">0x20000</span>)。</span><br><span class="line">③、 I.MX6ULL内部 aips1域下的 ecspi1外设控制器，寄存器起始地址为 <span class="number">0x02008000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">④、 I.MX6ULL内部 aips2域下的 usbotg1外设控制器，寄存器起始地址为 <span class="number">0x02184000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">⑤、 I.MX6ULL内部 aips3域下的 rngb外设控制器，寄存器起始地址为 <span class="number">0x02284000</span>，大小为 <span class="number">0x4000</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</span><a href="#3-1-tian-jia-cpus-jie-dian" class="header-anchor">#</a></h2><p>cpu节点，<code> I.MX6ULL</code>采用<code> Cortex-A7</code>架构，而且只有一个 CPU，因此只有一个cpu0节点，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">	cpus &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">		<span class="comment">//CPU0节点 </span></span><br><span class="line">		cpu0: cpu@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>; </span><br><span class="line">			device_type = <span class="string">&quot;cpu&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</span><a href="#3-2-tian-jia-soc-jie-dian" class="header-anchor">#</a></h2><p>像<code> uart iic</code>控制器等等这些都属于 SOC内部外设，因此一般会创建一个叫做 <code>soc</code>的父节点来管理这些 SOC内部外设的子节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	<span class="comment">//soc节点 </span></span><br><span class="line">	soc &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		ranges; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>soc节点设置 <code>#address-cells = &lt;1&gt;</code>，<code>#size-cells = &lt;1&gt;</code>，这样 soc子节点的 reg属性中起始地占用一个字长，地址空间长度也占用一个字长。<code>ranges</code>属性为空，说明子空间和父空间地址范围相同。</p>
<h3><span id="3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</span><a href="#3-2-1-tian-jia-ocram-jie-dian" class="header-anchor">#</a></h3><p>根据第②点的要求，添加<code> ocram</code>节点，<code> ocram</code>是<code> I.MX6ULL</code>内部 RAM，因此 <code>ocram</code>节点应该是 soc节点的子节点。 <code>ocram</code>起始地址为 <code>0x00900000</code>，大小为<code>128KB(0x20000)</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//soc节点 </span></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	ranges; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//ocram节点 </span></span><br><span class="line">	ocram: sram@<span class="number">00900000</span> &#123; </span><br><span class="line">		compatible = <span class="string">&quot;fsl,lpm-sram&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x00900000</span> <span class="number">0x20000</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</span><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian" class="header-anchor">#</a></h3><p><code>IMX6ULL</code>外设控制分为三个域： <code>aips1~3</code>，这三个域分管不同的外设控制器，<code>aips1~3</code>这三个域都属于 soc节点的子节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aips1节点</span></span><br><span class="line">aips1: aips-bus@<span class="number">02000000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02000000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips2: aips-bus@<span class="number">02100000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02100000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips3: aips-bus@<span class="number">02200000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02200000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</span><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian" class="header-anchor">#</a></h4><p>每个域节点下都添加一个外设节点。<code>ecspi1</code>属于 <code>aips1</code>的子节点，<code> usbotg1</code>属于 <code>aips2</code>的子节点， <code>rngb</code>属于 <code>aips3</code>的子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ecspi1节点 </span></span><br><span class="line">ecspi1: ecspi@<span class="number">02008000</span> &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usbotg1节点 </span></span><br><span class="line">usbotg1: usb@<span class="number">02184000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="string">&quot;fsl,imx27-usb&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02184000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rngb节点 </span></span><br><span class="line">rngb: rngb@<span class="number">02284000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="string">&quot;fsl,imx-rng&quot;</span>, <span class="string">&quot;imx-rng&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02284000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/" data-id="clz5iydfx0000xguf751m1p0w" data-title="字符设备驱动-4-设备树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-3-GPIO驱动KEY示例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T09:51:13.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/">字符设备驱动-3-GPIO驱动KEY示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</a><ul>
<li><a href="#1-1-cha-xun-fang-shi">1.1 查询方式</a></li>
<li><a href="#1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</a></li>
<li><a href="#1-3-poll-fang-shi">1.3 poll 方式</a></li>
<li><a href="#1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</a></li>
<li><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</a></li>
</ul>
</li>
<li><a href="#2-gpio-an-jian-qu-dong">2 GPIO按键驱动</a><ul>
<li><a href="#2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</a><ul>
<li><a href="#2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</a></li>
<li><a href="#2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</a></li>
</ul>
</li>
<li><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</a><ul>
<li><a href="#2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</a></li>
<li><a href="#2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</a></li>
<li><a href="#2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</a></li>
<li><a href="#2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ce-shi">3 测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</span><a href="#1-app-du-qu-an-jian-fang-shi" class="header-anchor">#</a></h1><ol>
<li>查询方式</li>
<li>休眠-唤醒方式</li>
<li>poll 方式</li>
<li>异步通知方式</li>
</ol>
<p>第2、3、4种方法，都涉及中断服务程序。</p>
<h2><span id="1-1-cha-xun-fang-shi">1.1 查询方式</span><a href="#1-1-cha-xun-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/1.png" alt="image"></p>
<p>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO 为输入引脚。 APP 调用 read 时，导致驱动中对应的 read 函数被调用，它读取寄存器，把引脚状态直接返回给 APP,APP需要反复read查询引脚电平状态。</p>
<p>很明显，查询方式用的非阻塞IO（<code>O_NONBLOCK</code>）。</p>
<h2><span id="1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</span><a href="#1-2-xiu-mian-huan-xing-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/2.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 read 时，导致驱动中对应的 read 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态read函数中休眠。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，read函数被唤醒，执行驱动代码，把按键数据返回给APP(用户空间)。</li>
</ol>
<h2><span id="1-3-poll-fang-shi">1.3 poll 方式</span><a href="#1-3-poll-fang-shi" class="header-anchor">#</a></h2><p>上面的休眠-唤醒方式有个缺点：如果一直没操作按键，那么 APP 就会永远休眠。<br>我们可以给 APP 定个闹钟，这就是 poll 方式。当超时后就直接返回不再休眠。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/3.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 poll 或 select 函数，意图是“查询”是否有数据，这 2 个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的 <code>drv_poll</code> 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态休眠一段时间。</li>
<li>当按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的 APP。如果用户没按下按键，但是超时时间到了，内核也会唤醒 APP。</li>
</ol>
<p>所以 APP 被唤醒有 2 种原因：用户操作了按键或者超时。被唤醒的 APP 在内核态继续运行，即继续执行驱动代码，把 “状态” 返回给 APP(用户空间)。APP 得到 <code>poll/select </code>函数的返回结果后，如果确认是有数据的，则再调用 read 函数，这会导致驱动中的 read 函数被调用，这时驱动程序中含有数据，会直接返回数据。</p>
<h2><span id="1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</span><a href="#1-4-yi-bu-tong-zhi-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/4.png" alt="image"><br>异步通知的实现原理是：内核给 APP 发信号。信号有很多种，这里发的是SIGIO。<br>驱动程序中构造、注册一个<code> file_operations</code> 结构体，里面提供有对应的<code>open,read,fasync</code> 函数。</p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 给信号 <code>SIGIO</code> 注册自己的处理函数： <code>my_signal_fun</code>。</li>
<li>APP 调用<code>fcntl</code>函数，把驱动程序的 flag 改为 <code>FASYNC</code>，这会导致驱动程序的<code>fasync</code>函数被调用，它只是简单记录进程 PID。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程 PID 发送 <code>SIGIO</code> 信号。</li>
<li>APP 收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用 read 函数读取按键值。</li>
<li>信号处理函数返回后， APP 会继续执行原先被打断的代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig_func</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get a signal : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGIO, my_sig_func);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, world %d!\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/5.png" alt="image-20240728184640793"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/6.png" alt="image"><br>发送一个SIGIO讯号给进程<code>3581339</code> <code>my_sig_func</code>函数，可以看到打印<code>”get a signal 29“</code>，即为<code>SIGIO</code>信号。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/7.png" alt="image"></p>
<h2><span id="1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</span><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi" class="header-anchor">#</a></h2><p>关于这几种方式的具体原理和示例后面会进行深度剖析：</p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-6.POLL底层驱动机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17438371.html">字符设备驱动-7.异步通知 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h1><span id="2-gpio-an-jian-qu-dong">2 GPIO按键驱动</span><a href="#2-gpio-an-jian-qu-dong" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</span><a href="#2-1-an-jian-qu-dong-kuang-jia" class="header-anchor">#</a></h2><p>按键驱动程序最简单的方法：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/8.png" alt="image"></p>
<p>我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为<strong>上下两层</strong>：</p>
<ol>
<li><code>button_drv.c</code> 分配&#x2F;设置&#x2F;注册<code> file_operations</code> 结构体起承上启下的作用，向上提供 <code>button_open</code>,<code>button_read </code>供 APP 调用。而这 2 个函数又会调用底层硬件提供的 <code>p_button_opr </code>中的 init、 read 函数操作硬件。</li>
<li><code>board_xxx.c</code> 实现 <code>p_button_opr</code>结构体，这个结构体是我们自己抽象出来的，里面定义<code>单板 xxx</code> 的按键操作函数。这样的结构易于扩展，对于不同的单板，只需要替换<code>board_xxx.c</code>提供自己的 <code>button_operations</code> 结构体即可。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/9.png" alt="image"></li>
</ol>
<h3><span id="2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</span><a href="#2-1-1-button-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.h</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">void</span> (*init) (<span class="type">int</span> which);</span><br><span class="line">    <span class="type">int</span> (*read) (<span class="type">int</span> which);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>board_xxx.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_xxx_button_init_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, init gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_xxx_button_read_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, read gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span>&#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init  = board_xxx_button_init_gpio,</span><br><span class="line">    .read  = board_xxx_button_read_gpio,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_xxx_button_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_xxx_button_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_xxx_button_init);</span><br><span class="line">module_exit(board_xxx_button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
board_xxx.c里面实现了具体单板的button_operations，当insmod这个驱动时，调用 register_button_operations 函数，把my_buttons_ops这个结构体注册到上层驱动中，这里.init .read函数先不去实现。

<h3><span id="2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</span><a href="#2-1-2-file-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> *<span class="title">p_button_opr</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">button_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">button_open</span> <span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">    p_button_opr-&gt;init(minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">button_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = iminor(file_inode(file));</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    level = p_button_opr-&gt;read(minor);</span><br><span class="line">    err = copy_to_user(buf, &amp;level, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">button_fops</span> =</span> &#123;</span><br><span class="line">    .open = button_open,</span><br><span class="line">    .read = button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p_button_opr = opr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_create(button_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;100ask_button%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_button_opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(button_class, MKDEV(major, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_button_operations);</span><br><span class="line">EXPORT_SYMBOL(unregister_button_operations);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">button_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_button&quot;</span>, &amp;button_fops);</span><br><span class="line">    button_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(button_class))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    class_destroy(button_class);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(button_init);</span><br><span class="line">module_exit(button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
上层是 `button_drv.c`，按照字符设备驱动标准框架编写，`register_button_operations`实现了将底层具体的`button_operations`对象注册进来，调用`open/read`时便可操作具体的单板，`device_create`为单板的具体按键创建设备节点。注意`insmod`顺序要先安装`button_drv.ko`, 具体单板驱动要后安装，否则`register_button_operations`函数是未定义的。



<h2><span id="2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</span><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong" class="header-anchor">#</a></h2><p>以<code>imx6ull</code>单板为例，按键引脚为 <code>GPIO5_IO01</code>、 <code>GPIO4_IO14</code>，平时按键电平为高，按下按键后电平为低，如下图：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/10.png" alt="image"></p>
<ol>
<li>使能电源&#x2F;时钟控制器</li>
<li>配置引脚模式成gpio</li>
<li>配置引脚方向为输入</li>
<li>读取电平<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/11.png" alt="image"></li>
</ol>
<h3><span id="2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</span><a href="#2-2-1-ccm-shi-zhong-shi-neng" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/12.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/13.png" alt="image"><br>设置<code> CCM_CCGR1[31:30]</code>、<code> CCM_CCGR3[13:12]</code>就可以使能<code> GPIO5</code>、<code>GPIO4</code>，设置为什么值呢？<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/14.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>：该 GPIO 模块全程被关闭</span><br><span class="line"><span class="number">01</span>：该 GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭</span><br><span class="line"><span class="number">10</span>：保留</span><br><span class="line"><span class="number">11</span>：该 GPIO 模块全程使能</span><br></pre></td></tr></table></figure>

<p>那么将<code>CCM_CCGR1[31:30]</code>、 <code>CCM_CCGR3[13:12]</code>设置成<code>0b11</code>即可。</p>
<h3><span id="2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</span><a href="#2-2-2-pei-cheng-gpio-mo-shi" class="header-anchor">#</a></h3><ol>
<li><code>GPIO5_IO01</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/15.png" alt="image"><ol start="2">
<li><code>GPIO4_IO14</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/16.png" alt="image"></li>
</ol>
</li>
</ol>
<h3><span id="2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</span><a href="#2-2-3-gpio-pei-cheng-shu-ru" class="header-anchor">#</a></h3><p><code>GPIO4,GPIO5</code>寄存器地址:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/17.png" alt="image"><br>方向设置寄存器:(<code>offset 04</code>)<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/18.png" alt="image"></p>
<h3><span id="2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</span><a href="#2-2-4-du-qu-gpio-dian-ping" class="header-anchor">#</a></h3><p>注意输入模式下，gpio电平状态得从<code>GPIOx_PSR</code>得到（<code>offset 08</code>）<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/19.png" alt="image"></p>
<details>
<summary>button_board_imx6ull.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR3; </span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set GPIO5_IO03 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1;</span><br><span class="line"><span class="comment">/* set GPIO4_IO14 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio4</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio5</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_imx6ull_button_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化button, which-哪个button */</span>      </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CCM_CCGR1)&#123;</span><br><span class="line">        CCM_CCGR1 = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">        CCM_CCGR3 = ioremap(<span class="number">0x20C4074</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = ioremap(<span class="number">0x229000C</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B        = ioremap(<span class="number">0x20E01B0</span>, <span class="number">4</span>);</span><br><span class="line">        gpio4 = ioremap(<span class="number">0x020A8000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">        gpio5 = ioremap(<span class="number">0x20AC000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO5 </span></span><br><span class="line"><span class="comment">         * CG15, b[31:30] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO5_IO01 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO5_IO01 as input </span></span><br><span class="line"><span class="comment">         * GPIO5 GDIR, b[1] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio5-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO4 </span></span><br><span class="line"><span class="comment">         * CG6, b[13:12] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR3 |= (<span class="number">3</span>&lt;&lt;<span class="number">12</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO4_IO14 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO4_IO14 as input </span></span><br><span class="line"><span class="comment">         * GPIO4 GDIR, b[14] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio4-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_imx6ull_button_read</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 读button, which-哪个 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (gpio5-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (gpio4-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span> &#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init = board_imx6ull_button_init,</span><br><span class="line">    .read = board_imx6ull_button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_imx6ull_button_drv_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_imx6ull_button_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_imx6ull_button_drv_init);</span><br><span class="line">module_exit(board_imx6ull_button_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>具体单板驱动insmod会调用<code> register_button_operations</code>把具体的<code>my_buttons_ops</code>注册进去。当用户open,就会进行<code>board_imx6ull_button_init</code>进行按键寄存器配置。当用户read的时候调用<code>board_imx6ull_button_read</code>读取按键值。</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/20.png" alt="image"></p>
<h1><span id="3-ce-shi">3 测试</span><a href="#3-ce-shi" class="header-anchor">#</a></h1><details>
<summary>Makefile</summary>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o button_test button_test.c </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f ledtest</span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line">obj-m	+= button_drv.o</span><br><span class="line">obj-m	+= board_xxx.o</span><br></pre></td></tr></table></figure>

</details>

<details>
<summary>测试代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 3. 写文件 */</span></span><br><span class="line">	read(fd, &amp;val, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : %d\n&quot;</span>, val);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/21.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/" data-id="clz5dxju40000mcufh9hk39pe" data-title="字符设备驱动-3-GPIO驱动KEY示例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-2-总线模型和平台设备驱动" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time class="dt-published" datetime="2024-07-25T16:38:15.000Z" itemprop="datePublished">2024-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">字符设备驱动-2-总线模型和平台设备驱动</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</a><ul>
<li><a href="#1-1-zong-xian-ping-tai-she-bei-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</a><ul>
<li><a href="#1-1-1-struct-bus-type">1.1.1 struct bus_type</a></li>
<li><a href="#1-1-2-struct-platform-driver">1.1.2 struct platform_driver</a></li>
<li><a href="#1-1-3-struct-platform-device">1.1.3 struct platform_device</a></li>
<li><a href="#1-1-4-zong-xian-she-bei-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</a></li>
</ul>
</li>
<li><a href="#1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</a></li>
<li><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</a><ul>
<li><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</a><ul>
<li><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</a><ul>
<li><a href="#1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</a></li>
<li><a href="#1-3-1-1-2-id-table">1.3.1.1.2 ID table</a></li>
<li><a href="#1-3-1-1-3-name">1.3.1.1.3 name</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</a></li>
<li><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</a></li>
</ul>
</li>
<li><a href="#1-4-zong-jie-ping-tai-she-bei-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</a></li>
<li><a href="#1-6-ping-tai-she-bei-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</a><ul>
<li><a href="#1-6-1-zhu-ce-fan-zhu-ce">1.6.1 注册&#x2F;反注册</a></li>
<li><a href="#1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</a><ul>
<li><a href="#1-6-2-1-io-resource">1.6.2.1 IO resource</a></li>
<li><a href="#1-6-2-2-irq">1.6.2.2 IRQ</a></li>
<li><a href="#1-6-2-3-gpio">1.6.2.3 GPIO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</a><ul>
<li><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</a></li>
<li><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</a></li>
<li><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</a></li>
<li><a href="#2-4-ce-shi">2.4 测试</a><ul>
<li><a href="#2-4-1-makefile">2.4.1 Makefile</a></li>
<li><a href="#2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</a></li>
</ul>
</li>
<li><a href="#2-5-is-err-err-ptr-ptr-err-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</a><ul>
<li><a href="#2-5-1-is-err">2.5.1 IS_ERR</a></li>
<li><a href="#2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</a></li>
<li><a href="#2-5-3-ptr-err">2.5.3 PTR_ERR</a></li>
<li><a href="#2-5-4-err-ptr">2.5.4 ERR_PTR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-yin-ru-sysfs">3 引入sysfs</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</span><a href="#1-zong-xian-she-bei-qu-dong-mo-xing" class="header-anchor">#</a></h1><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/1.png" alt="img"></p>
<p>设备定义资源，<code>platform_device</code>结构体</p>
<p>驱动定义<code>platform_driver</code>结构体，实现<code>probe, file_operations</code></p>
<p>总线驱动模型优点：</p>
<p>驱动只是一套控制驱动框架，基本不用修改，和单板硬件相关的都在设备代码里面，硬件修改只需要修改设备资源相关的代码，不用关心具体的函数实现和寄存器控制。</p>
<h2><span id="1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</span><a href="#1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-1-1-struct-bus-type">1.1.1 struct bus_type</span><a href="#1-1-1-struct-bus-type" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/2.png" alt="img"></p>
<p>有一个很关键的函数，<code>match</code>函数。当设备与设备枚举过程中match函数会按照规则进行匹配,规则见<code>1.3.1</code>。</p>
<h3><span id="1-1-2-struct-platform-driver">1.1.2 struct platform_driver</span><a href="#1-1-2-struct-platform-driver" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/3.png" alt="img"></p>
<h3><span id="1-1-3-struct-platform-device">1.1.3 struct platform_device</span><a href="#1-1-3-struct-platform-device" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4.png" alt="img"></p>
<h3><span id="1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</span><a href="#1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi" class="header-anchor">#</a></h3><ol>
<li><p>系统启动后，会调用<code>buses_init()</code>函数创建<code>/sys/bus</code>文件目录。</p>
</li>
<li><p>接下来就是通过总线注册函数<code>bus_register()</code>进行总线注册，注册完成后，在<code>/sys/bus</code>目录下生成device文件夹和driver文件夹。</p>
</li>
<li><p>最后分别通过<code>device_register()</code>和<code>driver_register()</code>函数注册对应的设备和驱动。<br><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4_1.png" alt="image-20240727214421349"></p>
</li>
</ol>
<h2><span id="1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</span><a href="#1-2-platform-device-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/5.png" alt="image-20240727164939263"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/6.png" alt="image-20240726004737362"></p>
<ol>
<li>系统初始化时，调用<code>platform_add_devices</code>函数，把所有放置在板级<code>platform_device</code>数组中的<code>platform_device</code>注册到系统中去。</li>
</ol>
<ul>
<li><p>1.1 此函数循环调用<code>platform_device_register</code>函数，来注册每个<code>platform_device</code>。</p>
</li>
<li><p>1.2 而<code>platform_device_register</code>中会调用<code>platform_device_add</code>函数。</p>
</li>
</ul>
<ol start="2">
<li><code>platform_device</code>全部注册到系统之后，便可以通过<code>platform</code>的操作接口，来获取<code>platform_device</code>中的resource资源。</li>
</ol>
<ul>
<li><p>2.1 比如地址、中断号等，以进行<code>request_mem_region</code>、<code>ioremap</code>（将resource分配的物理地址映射到kernel的虚拟空间来）和<code>request_irq</code>操作。</p>
</li>
<li><p>2.2 <code>platform</code>的操作接口包括<code>platform_get_irq</code>、<code>platform_get_irq_byname</code>、<code>platform_get_resource</code>、<code>platform_get_resource_byname</code>等。这个后面设备树专题会专门介绍<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-5.设备树函数 - fuzidage - 博客园 (cnblogs.com)</a>。</p>
</li>
</ul>
<h2><span id="1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</span><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p>当<code>insmod</code>设备驱动的时候会透过<code>module_init</code>调用, 过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">platform_driver_register()</span><br><span class="line">	driver_register()</span><br><span class="line">		bus_add_driver<span class="comment">//加入driver链表</span></span><br><span class="line">			driver_attach()</span><br><span class="line">				bus_for_each_dev()</span><br><span class="line">					__driver_attach()</span><br><span class="line">						driver_match_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">							platform_match</span><br><span class="line">    					driver_probe_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">    						drv-&gt;probe(dev);</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</span><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/7.png" alt="image-20240727170404969"></p>
<h4><span id="1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</span><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu" class="header-anchor">#</a></h4><p>一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，<code>platform_driver</code>中使用不同的成员来进行相应的匹配。系统为platform总线定义了一个<code>bus_type 的实例platform_bus_type</code>, 会不断循环呼叫<code>platform_match函数</code>去遍历所有设备和驱动:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/8.png" alt="img"></p>
<p>匹配优先级顺序实现位于<code>drivers/base/platform.c</code>的platform_match函数，下面按照优先级由高到底的匹配顺序介绍：</p>
<h5><span id="1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</span><a href="#1-3-1-1-1-of-match-table" class="header-anchor">#</a></h5><p><code>of_match_table</code>就是从dts中对应node的<code>compatible属性</code>去匹配设备和驱动。</p>
<p><code>compatible</code>属性也叫做<code>“兼容性”</code>属性，是一个字符串列表, 格式如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“manufacturer,model”</span><br></pre></td></tr></table></figure>

<p><code>manufacturrer</code>表示厂商，<code>model</code>表示驱动名字，该属性用于将设备和驱动绑定起来。</p>
<p><code>platform_device.dev.of_node </code>和 <code>platform_driver.driver.of_match_table</code>介绍：</p>
<p>由设备树节点转换得来的 <code>platform_device </code>中，含有一个结构体：<code>of_node</code>。 它的类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/9.png" alt="img"></p>
<p><code>platform_driver.driver.of_match_table </code>类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/10.png" alt="img"></p>
<p>一般驱动程序都会有一个<code>of_match_table</code>匹配表，此<code>of_match_table</code>匹配表保存着一些<code>compatible</code>值，如果dts中的<code>compatible</code>属性值和<code>of_match_table</code>匹配表中的有一个值相等，那么就表示设备可以使用这个驱动。</p>
<p>如下图dts定义了一个<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/11.png" alt="img"></p>
<p>驱动程序中的定义如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/12.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/13.png" alt="img"></p>
<p>那么这里驱动程序中的<code>.of_match_table</code>和dts能够匹配，那么就说明<code>match</code>成功，匹配成功后调用<code>platform driver</code>的<code>probe</code>函数。一般在驱动程序<code>module int</code>的时候，也就是<code>insmod</code>的时候，会用<code>platform_driver_register</code>来进行match过程。</p>
<h5><span id="1-3-1-1-2-id-table">1.3.1.1.2 ID table</span><a href="#1-3-1-1-2-id-table" class="header-anchor">#</a></h5><p>下面这个例子就是用一个驱动来匹配两个分别叫<code>&quot;demo0&quot;</code>和<code>&quot;demo1&quot;</code>的设备，注意，数组最后的{}是一定要的，这个是内核判断数组已经结束的标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> <span class="title">tbl</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;demo0&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;demo1&quot;</span>&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(platform, tbl);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/14.png" alt="image-20240727174003803"></p>
<h5><span id="1-3-1-1-3-name">1.3.1.1.3 name</span><a href="#1-3-1-1-3-name" class="header-anchor">#</a></h5><p>假如前面两项匹配规则都不满足，那么最后可以是用name来匹配。例如：上面的<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/15.png" alt="image-20240727174511089"></p>
<p>转换后就对应一个<code>platform_device</code>，<code>platform_device</code>中<code>.name= “cif”</code>,利用名字也能匹配上。</p>
<h3><span id="1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</span><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/16.png" alt="image-20240727171618120"></p>
<p>drvier匹配device成功调用driver的probe函数。一般平台设备都不需要驱动代码去定义，而是直接放入设备树作为设备树节点，内核启动后遍历设备树节点，将其转换成<code>platform_device</code>。</p>
<h3><span id="1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</span><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/17.png" alt="image-20240727170620921"></p>
<h2><span id="1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</span><a href="#1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/18.png" alt="img"></p>
<h2><span id="1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</span><a href="#1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api" class="header-anchor">#</a></h2><h3><span id="1-6-1-zhu-ce-x2f-fan-zhu-ce">1.6.1 注册&#x2F;反注册</span><a href="#1-6-1-zhu-ce-x2f-fan-zhu-ce" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\include\linux\platform_device.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">　platform_device_register/ platform_device_unregister</span><br><span class="line">　platform_driver_register/ platform_driver_unregister</span><br><span class="line"></span><br><span class="line">　platform_add_devices <span class="comment">// 注册多个 device</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/19.png" alt="image-20240727175522278"></p>
<h3><span id="1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</span><a href="#1-6-2-zi-yuan-huo-qu-shi-fang" class="header-anchor">#</a></h3><h4><span id="1-6-2-1-io-resource">1.6.2.1 IO resource</span><a href="#1-6-2-1-io-resource" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kernel\include\linux\ioport.h</code>中有<code>resource结构</code>。用来描述hw设备的资源信息, <code>include\linux\ioport.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/20.png" alt="img"></p>
<p>flags一般有以下几种：比如中断资源， IO端口资源， IO内存资源， DMA资源</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/21.png" alt="img"></p>
<ul>
<li><code>IORESOURCE_IO</code>：表示IO资源，cpu需要用特殊指令才能访问或需要用特殊访问方式才能访问,不能直接用指针来寻址</li>
<li><code>IORESOURCE_MEM</code>：表示IO内存，可以直接用指针引用来直接寻址操作</li>
</ul>
<p>这里举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/22.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/23.png" alt="img"></p>
<p>打印如下：那这里的<code>pdev</code>对应dts中的<code>mipi_rx</code>节点。<code>platform_get_resource</code>可以从dts <code>node</code>中找到io内存资源。</p>
<p>那这里循环获取4次，如下所示地址范围和上面的dts节点一致：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/24.png" alt="img"></p>
<h4><span id="1-6-2-2-irq">1.6.2.2 IRQ</span><a href="#1-6-2-2-irq" class="header-anchor">#</a></h4><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/25.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/26.png" alt="img"></p>
<ul>
<li>IORESOURCE_IRQ: 中断irq资源</li>
</ul>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/27.png" alt="img"></p>
<p>中断触发类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include\linux\platform_device.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING 1     <span class="comment">//上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING 2    <span class="comment">//下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING) <span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH 4    <span class="comment">//电平触发-高电平</span></span></span><br></pre></td></tr></table></figure>

<p>这里又要引入新概念GIC: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17551724.html">设备驱动-10.中断子系统-3.中断设备树表述与解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>Dts中描述到了GIC相关基础知识。(<code>Generic Interrupt Controller</code>)是ARM公司提供的一个通用的中断控制器。</p>
<p>GIC <strong>3要素</strong>：</p>
<ul>
<li><ul>
<li>中断类型</li>
<li>中断号</li>
<li>中断触发方式这三个要素</li>
</ul>
</li>
</ul>
<ol>
<li>GIC的外设中断（除去SGI）类型有两类：</li>
</ol>
<ul>
<li><ul>
<li>SPI，共享外设中断(由GIC内部的<code>distributor</code>来分发到相关CPU)，中断号：<code>32~1019</code></li>
<li>PPI，私有外设中断(指定CPU接收)，中断号：<code>16~31</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>外设中断号的分配规则如下：</li>
</ol>
<ul>
<li><ul>
<li><code>32~1019</code>给SPI</li>
<li><code>16~31</code>给PPI</li>
</ul>
</li>
</ul>
<ol start="3">
<li>所有外设中断都支持四种触发方式:</li>
</ol>
<ul>
<li><ul>
<li>上升沿触发</li>
<li>下降沿触发</li>
<li>高电平触发</li>
<li>低电平触发</li>
</ul>
</li>
</ul>
<p>所以DTS中接在GIC的<code>device node</code>的<code>interrupts</code>属性也是用这三个要素来描述一个具体的中断。</p>
<p>格式如：<code>interrupts = &lt;interruptType interruptNumber triggerType&gt; </code></p>
<table>
<thead>
<tr>
<th><strong>Interrrupt Types</strong></th>
<th><strong>Interrrupt Number</strong></th>
<th><strong>Trigger Type</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0 &#x3D; SPI,  1 &#x3D; PPI</td>
<td>32… …1019</td>
<td>1 &#x3D; low to high, 2 &#x3D; high to low, 4 &#x3D; high level, 8 &#x3D; low level</td>
</tr>
</tbody></table>
<p><code>sample code</code>如下:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/28.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/29.png" alt="img"></p>
<p>打印结果如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/30.png" alt="img"></p>
<p> 那么最后dts解析的结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">155</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br><span class="line"></span><br><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">156</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br></pre></td></tr></table></figure>

<p><code>platform_get_irq</code>返回一个虚拟中断号，这里对应的是<code>27， 28</code>.</p>
<p><code>devm_request_irq</code>用来申请中断，分配<code>isr中断处理函数</code>。该函数可以在驱动卸载时不用主动调用<code>free_irq</code>显示释放中断请求。</p>
<p>可以看到两次call <code>devm_request_irq</code>却是用的同一个中断服务程序<code>cif_isr</code>，这也是允许的，我们看一下函数原型：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/31.png" alt="image-20240727182250194"></p>
<p><code>devm_request_irq</code>会建立中断号<code>irq_num</code>和中断服务程序<code>isr</code>的绑定，最后一个参数会传给中断服务程序<code>isr</code>.</p>
<p>中断服务程序<code>isr</code>能够根据中断号<code>irq_num</code>和传进的参数进行区分中断源。</p>
<h4><span id="1-6-2-3-gpio">1.6.2.3 GPIO</span><a href="#1-6-2-3-gpio" class="header-anchor">#</a></h4><p><code>of_get_named_gpio_flags</code>获取dts中<code>gpio</code> 编号，并且会找到<code>device_node</code>，找到<code>of_gpio_flags</code>。</p>
<p><code>gpio_request</code>申请<code>gpio</code></p>
<p><code>gpio_direction_output</code>设置成<code>output</code>且<code>set gpio val</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio_flags</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *list_name,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> index, <span class="keyword">enum</span> of_gpio_flags *flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span>;		    </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">//include\asm-generic\gpio.h</span></span><br><span class="line"><span class="comment">//include\linux\gpio.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/32.png" alt="image-20240727183103383"></p>
<p>举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/33.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_HIGH 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_LOW 1</span></span><br><span class="line"><span class="comment">//include\linux\gpio\machine.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/34.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/35.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/36.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/37.png" alt="img"></p>
<p>这里的<code>gpio 编号=411 = GPIO_D + offset = 404 + 7 =411</code>(也就是dts中配置的<code>portd 7</code>)，这里由于是<code>of_gpio_flags </code>是<code>OF_GPIO_ACTIVE_LOW =0x01</code>，所以<code>snsr_rst_pol = 1</code>.</p>
<h1><span id="2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</span><a href="#2-ping-tai-she-bei-qu-dong-shi-li" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">        <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>①分配&#x2F;设置&#x2F;注册<code>platform_device</code>结构体 在里面定义所用资源，指定设备名字。-<code>Board_A_led.c</code></p>
<p>②分配&#x2F;设置&#x2F;注册 <code>platform_driver </code>结构体 在其中的 probe 函数里，分配&#x2F;设置&#x2F;注册 <code>file_operations </code>结构体， 并从 <code>platform_device </code>中确实所用硬件资源。 指定 <code>platform_driver</code> 的名字。 -<code>Chip_demo_gpio.c</code></p>
<h2><span id="2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</span><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">                                                               */</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span> &#123;</span><br><span class="line">        p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">        err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">        p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="type">int</span> minor = iminor(node);</span><br><span class="line">        <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">        p_led_opr-&gt;init(minor);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">        .owner         = THIS_MODULE,</span><br><span class="line">        .open    = led_drv_open,</span><br><span class="line">        .read    = led_drv_read,</span><br><span class="line">        .write   = led_drv_write,</span><br><span class="line">        .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);</span><br><span class="line">        led_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">        err = PTR_ERR(led_class);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">                printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">                unregister_chrdev(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        class_destroy(led_class);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里只实现一个框架, 具体的opr操作函数需要具体单板去实现。先注册字符设备驱动，确定好class和主设备号。</p>
<p>因为暂时还不知道具体led驱动是啥，因此需要外部去注册具体的led驱动，交给<code>platform_driver</code>去建立。</p>
<p>暂时先不建立设备节点，设备节点交给<code>platform_device</code>去建立，因为暂时不知道设备的led资源信息。</p>
<p><code>EXPORT_SYMBOL</code>导出<code>led_class_create_device</code>，<code>led_class_destroy_device</code>， <code>register_led_operations</code>函数。</p>
<h2><span id="2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</span><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="comment">/* GPIO3_0 */</span></span><br><span class="line"><span class="comment">/* bit[31:16] = group */</span></span><br><span class="line"><span class="comment">/* bit[15:0]  = which pin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP(x) (x&gt;&gt;16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN(x)   (x&amp;0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>Board_A_led.c</code>这里实现了单板的资源定义，这里是<code>gpio3_1</code>,<code>gpio5_8</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">resources</span>[] =</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">5</span>,<span class="number">8</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">board_A_led_dev</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .num_resources = ARRAY_SIZE(resources),</span><br><span class="line">        .resource = resources,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">                .release = led_dev_release,</span><br><span class="line">         &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_device_register(&amp;board_A_led_dev);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_device_unregister(&amp;board_A_led_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);　</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果<code>platform_device</code>中不提供 <code>release </code>函数，如下图所示不提供红框部分的函数:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/38.png" alt="img"></p>
<p>则在调用 <code>platform_device_unregister</code> 时会出现警告，如下图所示, 因此我们可以将<code>release</code>实现为空。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/39.png" alt="img"></p>
<h2><span id="2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</span><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LEDDRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LEDDRV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _LEDDRV_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>Chip_demo_gpio.c</code>实现opr的gpio控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leddrv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span>      </span><br><span class="line">&#123;  </span><br><span class="line">    printk(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i++);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        g_ledpins[g_ledcnt] = res-&gt;start;<span class="comment">//获取gpio num</span></span><br><span class="line">        led_class_create_device(g_ledcnt);<span class="comment">//利用EXPORT_SYMBOL导出的函数为每个led创建设备节点</span></span><br><span class="line">        g_ledcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        led_class_destroy_device(i);</span><br><span class="line">        i++;</span><br><span class="line">        g_ledcnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_demo_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;chip_demo_gpio_driver);</span><br><span class="line">    register_led_operations(&amp;board_demo_led_opr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>platform_device</code>和<code>platform_driver</code>都<code>insmod</code>（注册）后，总线设备驱动模型会进行<code>match</code>匹配，匹配成功调用<code>probe</code>函数，这里使用name进行匹配的。</p>
<ol>
<li><code>chip_demo_gpio_probe</code>中, 获取单板定义的资源信息，依次创建设备节点。</li>
<li><code>register_led_operations</code>注册了具体chip的opr操作函数(寄存器操作不具体展开实现，opr暂定为空)。</li>
</ol>
<p>当用户调用open&#x2F;write时便可操作具体chip的led驱动方法。</p>
<h2><span id="2-4-ce-shi">2.4 测试</span><a href="#2-4-ce-shi" class="header-anchor">#</a></h2><h3><span id="2-4-1-makefile">2.4.1 Makefile</span><a href="#2-4-1-makefile" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line"> </span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"> </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">        <span class="variable">$(CROSS_COMPILE)</span>gcc -o ledtest ledtest.c </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">        rm -rf modules.order</span><br><span class="line">        rm -f ledtest</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line"></span><br><span class="line">obj-m += leddrv.o chip_demo_gpio.o board_A_led.o</span><br></pre></td></tr></table></figure>

<p>编译出3个ko，依次insmod <code>leddrv.ko</code> <code>chip_demo_gpio.ko</code> <code>board_A_led.ko</code></p>
<h3><span id="2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</span><a href="#2-4-2-ledtest-ce-shi-cheng-xu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 on</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on | off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>))&#123;</span><br><span class="line">                status = <span class="number">1</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                status = <span class="number">0</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/40.png" alt="img"></p>
<h2><span id="2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</span><a href="#2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu" class="header-anchor">#</a></h2><p><code>include\linux\err.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/41.png" alt="image-20240727204217358"></p>
<p>内核中的函数常常返回指针，如果出错，也希望能够通过返回的指针体现出来。那么有三种情况：<code>合法指针，NULL指针和非法指针</code>。</p>
<p>1.<code>合法指针</code>：内核函数返回的指针一般是4K对齐，即 ptr &amp; 0xfff &#x3D;&#x3D; 0，也就是0x1000的倍数。其中Linux采用分页机制管理内存，而CPU访问的是线性地址需要通过页表转化成物理地址。所以内核就约定留出最后一页4k（<code>0xfffffffffffff000 ~ 0xffffffffffffffff</code>）用来记录内核空间的错误指针(32位的话就是（<code>0xfffff000 ~ 0xffffffff</code>）).</p>
<p>2.<code>非法指针</code>：一般内核函数地址不会落在<code>（0xfffff000，0xffffffff）</code>之间，而一般内核的出错代码也是一个小负数，在<code>-4095到0</code>之间，转变成<code>unsigned long</code>，正好在<code>（0xfffff000，0xffffffff)</code>之间。因此可以用 <code>(unsigned long)ptr &gt; (unsigned long)-1000L</code></p>
<p><code>-1000L</code>正好是<code>0xfffff000</code>。</p>
<p>3.linux内核中有一个宏<code>MAX_ERRNO = 4095</code>。errno见如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/<span class="keyword">asm</span>-generic/errno-base.h  <span class="comment">//1-34</span></span><br><span class="line">include\uapi\<span class="keyword">asm</span>-generic\errno.h  <span class="comment">//35-133</span></span><br><span class="line">include\linux\errno.h <span class="comment">//512-530</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-1-is-err">2.5.1 IS_ERR</span><a href="#2-5-1-is-err" class="header-anchor">#</a></h3><p>作用：判断是否无效非法指针。</p>
<p>实现见上面图片，例如一个地址<code>0xfffff,ffaa</code>，那么代入后：很明显返回1,是一个错误非法指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xfffffffaa</span> &gt; <span class="number">0xfffff000</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</span><a href="#2-5-2-is-err-or-null" class="header-anchor">#</a></h3><p>和IS_ERR基本等同，会先提前判断一下是否空。</p>
<h3><span id="2-5-3-ptr-err">2.5.3 PTR_ERR</span><a href="#2-5-3-ptr-err" class="header-anchor">#</a></h3><p>作用：将非法指针转成错误码返回。</p>
<p>实现见上面图片. 将传入的<code>void *</code>类型指针强转为long类型，并返回</p>
<h3><span id="2-5-4-err-ptr">2.5.4 ERR_PTR</span><a href="#2-5-4-err-ptr" class="header-anchor">#</a></h3><p>将传入的long类型强转为<code>void *</code>类型指针，并返回</p>
<h1><span id="3-yin-ru-sysfs">3 引入sysfs</span><a href="#3-yin-ru-sysfs" class="header-anchor">#</a></h1><p>讲到总线设备驱动模型，那不能少了sysfs。<code>sysfs</code>是一种虚拟文件系统，旨在提供一种访问内核数据结构的方法，从而允许用户空间程序查看和控制系统的设备和资源。</p>
<p>例如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18114131">设备驱动-16-Linux 内核LED子系统 - fuzidage - 博客园 (cnblogs.com)</a> 操作led：</p>
<p><code>echo 1 &gt; /sys/class/leds/red/brightness</code></p>
<p>又例如某个驱动修改设置module_param:</p>
<p><code>echo &quot;8&quot; &gt;/sys/module/my_drv/parameters/lg_lv</code></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/42.png" alt="image-20240727220331721"></p>
<p> <code>kobject</code> 和 <code>kset</code> 是构成 <code>/sys</code> 目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，<code>kobject、kset </code>数据结构都能表示一个目录或者文件节点。在这个目录下面的每一个子目录，其实都是相同类型的kobject集合。然后不同的kset组织成树状层次的结构，就构成了sysfs子系统。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/43.png" alt="image-20240727220824743"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-id="clz45pg950000xcuf3b3ddv86" data-title="字符设备驱动-2-总线模型和平台设备驱动" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 17px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 19px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 17px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 16px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 18px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 20px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 17px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/">字符设备驱动-9-中断子系统-GICv2架构解析</a>
          </li>
        
          <li>
            <a href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入</a>
          </li>
        
          <li>
            <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>
          </li>
        
          <li>
            <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-7-%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/">字符设备驱动-7-异步通知</a>
          </li>
        
          <li>
            <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/">字符设备驱动-6-poll底层驱动机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>