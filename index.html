<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-s3c2440裸机编程-ADC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/" class="article-date">
  <time class="dt-published" datetime="2024-04-16T11:57:19.000Z" itemprop="datePublished">2024-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-adc-ying-jian-yuan-li">1 ADC硬件原理</a><ul>
<li><a href="#1-1-adc-shu-xing">1.1 ADC属性</a></li>
<li><a href="#1-2-adc-kuang-tu">1.2 ADC框图</a></li>
</ul>
</li>
<li><a href="#2-adc-ji-cun-qi">2 ADC寄存器</a><ul>
<li><a href="#2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</a></li>
<li><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</a></li>
<li><a href="#2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</a></li>
</ul>
</li>
<li><a href="#3-bian-cheng-ce-shi">3 编程测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-adc-ying-jian-yuan-li">1 ADC硬件原理</span><a href="#1-adc-ying-jian-yuan-li" class="header-anchor">#</a></h1><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p>
<p>如图，把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。以s3c2440为例：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/1.jpg"></p>
<h2><span id="1-1-adc-shu-xing">1.1  ADC属性</span><a href="#1-1-adc-shu-xing" class="header-anchor">#</a></h2><p>对于数字信号我们需要得到它的2个属性：</p>
<ol>
<li><p>转换精度：<br>用多少位来存储这个数据（假如是10 bit）。那么最大值0b111111111对应3.3v， 0b0对应0v。</p>
</li>
<li><p>采样&#x2F;转换速度：</p>
</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/2.png"><br>可以看出s3c2440的转换精度可达10 bit, 转换速率可达 500ksps.</p>
<h2><span id="1-2-adc-kuang-tu">1.2 ADC框图</span><a href="#1-2-adc-kuang-tu" class="header-anchor">#</a></h2><p>下图是s3c2440芯片的ADC转换框图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/3.png"></p>
<p>可以看出AD converter前有一个MUX选择器，用来选择模拟输入源，这里选择A[3:0]作为输入源。</p>
<p>下面是编写程序要做的步骤：</p>
<pre><code>1.确定是哪一路信号：设置8：1MUX
2.设置工作时钟
3.启动ADC
4.读状态，判断ADC转换是否成功。
5.读数据
</code></pre>
<h1><span id="2-adc-ji-cun-qi">2 ADC寄存器</span><a href="#2-adc-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</span><a href="#2-1-kong-zhi-ji-cun-qi-adccon" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/4.png"></p>
<pre><code>bit[15]：只读，用来表示转换是否完成
bit[14:6]:用来设置adc频率（如果是auto TSC则不用设置该位）
bit[5：3]:用来选择模拟输入源
bit[2]:用来设置是否待机
bit[0]:用来启动adc
</code></pre>
<h2><span id="2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</span><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/5.png"></p>
<h2><span id="2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</span><a href="#2-3-shu-ju-ji-cun-qi-adcdat0" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/6.png"></p>
<pre><code>bit[9:0]表示转换后的数据
</code></pre>
<h1><span id="3-bian-cheng-ce-shi">3 编程测试</span><a href="#3-bian-cheng-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/7.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//设置输入源AIN0, ADC时钟为1Mhz,并且使能预分频</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_read_ain0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		<span class="comment">/* 启动ADC */</span></span><br><span class="line">	ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!(ADCCON &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)));  <span class="comment">/* 等待ADC结束 */</span></span><br><span class="line">	<span class="keyword">return</span> ADCDAT0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/" data-id="clv2cd3zx00004slp4us4gvts" data-title="s3c2440裸机编程-ADC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机-异常中断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/" class="article-date">
  <time class="dt-published" datetime="2024-04-16T06:55:01.000Z" itemprop="datePublished">2024-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</a><ul>
<li><a href="#1-1-cpu-mo-shi">1.1 CPU模式</a></li>
<li><a href="#1-2-gong-zuo-state">1.2 工作State</a></li>
<li><a href="#1-3-arm-ji-cun-qi">1.3 ARM寄存器</a><ul>
<li><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</a></li>
<li><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</a></li>
</ul>
</li>
<li><a href="#1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</a></li>
</ul>
</li>
<li><a href="#2-yi-chang-chu-li-liu-cheng">2 异常处理流程</a><ul>
<li><a href="#2-1-zhong-duan-qian">2.1 中断前</a><ul>
<li><a href="#2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</a></li>
</ul>
</li>
<li><a href="#2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</a><ul>
<li><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</a></li>
</ul>
</li>
<li><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</a></li>
</ul>
</li>
<li><a href="#3-zhong-duan-shi-li">3 中断实例</a><ul>
<li><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</a><ul>
<li><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</a></li>
<li><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</a></li>
<li><a href="#3-1-3-shi-li-gai-jin">3.1.3 示例改进</a><ul>
<li><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</a></li>
<li><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</a></li>
<li><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-swi-ruan-zhong-duan">3.2 swi-软中断</a><ul>
<li><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</a><ul>
<li><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</a><ul>
<li><a href="#3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</a></li>
<li><a href="#3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</a><ul>
<li><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</a></li>
<li><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</a></li>
<li><a href="#3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</a></li>
<li><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</a><ul>
<li><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</a><ul>
<li><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</a><ul>
<li><a href="#3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</a></li>
<li><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</a><ul>
<li><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</a></li>
<li><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</a></li>
</ul>
</li>
<li><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</a><ul>
<li><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</a></li>
<li><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</a><ul>
<li><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</a></li>
<li><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</span><a href="#1-yi-chang-zhong-duan-yin-ru" class="header-anchor">#</a></h1><p>在arm架构的处理器中，cpu有7中工作模式，2中工作状态。</p>
<h2><span id="1-1-cpu-mo-shi">1.1 CPU模式</span><a href="#1-1-cpu-mo-shi" class="header-anchor">#</a></h2><pre><code>7种Mode: 除了usr/sys，其他5种都是异常模式。我们知道中断属于异常的2中，中断有irq,fiq。
</code></pre>
<table>
<thead>
<tr>
<th>usr</th>
<th>sys</th>
<th>undefined(und)</th>
<th>Supervisor(svc)</th>
<th>Abort(abt)</th>
<th>irq</th>
<th>fiq</th>
</tr>
</thead>
<tbody><tr>
<td>用户模式</td>
<td>系统模式</td>
<td>未定义指令异常模</td>
<td>svc管理模式</td>
<td>终止模式（1.指令预取终止(读写某条错误的指令导致终止运行)；2.数据访问终止(读写某个非法地址程序终止)）</td>
<td>irq中断</td>
<td>快中断</td>
</tr>
</tbody></table>
<p>除了usr模式，其他6中为特权模式。 CPU无法从usr模式直接进入特权模式。不能直接进入特权模式，那么<strong>怎么进入特权模式</strong>呢？</p>
<p>可以通过<strong>设置CPSR</strong>进入其他模式。</p>
<h2><span id="1-2-gong-zuo-state">1.2 工作State</span><a href="#1-2-gong-zuo-state" class="header-anchor">#</a></h2><pre><code>ARM state
Thumb state(几乎用不上)
</code></pre>
<h2><span id="1-3-arm-ji-cun-qi">1.3 ARM寄存器</span><a href="#1-3-arm-ji-cun-qi" class="header-anchor">#</a></h2><pre><code>(1)通用寄存器:
(2)备份寄存器(banked register):
    CPSR:当前程序状态寄存器(Current Program Status Register) 反映程序处在那种状态
    SPSR:CPSR的备份寄存器 (Saved Program Status Register)  用来保存&quot;被中断前的CPSR&quot;
</code></pre>
<p>下图是我们arm状态下的通用寄存器和程序状态寄存器<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/1.png"></p>
<p><strong>R13是SP（栈指针）</strong><br><strong>R14是LR</strong>（link register），程序跳转或者发成异常时的返回地址<br><strong>R15是PC</strong>（程序计数器）</p>
<p>假设cpu执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov R0, R8</span><br><span class="line">mov R0,R8_fiq</span><br></pre></td></tr></table></figure>

<p>在usr&#x2F;System 模式下访问的R8, 但是在FIQ模式下，访问R8是访问FIQ模式专属的R8寄存器，不是同一个物理上的寄存器。<br>在5种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈)， R14(LR)是用来保存发生异常时的指令地址。</p>
<p>为什么快中断(FIQ)有那么多专属寄存器?<br>这些寄存器称为备份寄存器，我们先看下<strong>中断处理流程</strong>：</p>
<pre><code>1 保存现场(保存被中断模式的寄存器)---(比如程序正在sys/usr模式下运行，当发生中断时，需要把R0-R14这些寄存器全部保存下来)
2 异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
3 恢复现场(恢复被中断时保存下来的寄存器R0-R14)
</code></pre>
<p>但如果是快中断，那么我就不需要保存系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，因为在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度，所以它才称得上快中断。</p>
<h3><span id="1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</span><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>在异常中断中PSR寄存器会使用的很频繁，PSR寄存器的格式如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/2.png"></p>
<p>我们再来看看下表，反映的是PSR的 M[4:0]与arm工作模式的关系：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/3.png"></p>
<p>我们可以按照上图的对应关系设置CPSR，让其进入与之对应的模式。</p>
<h3><span id="1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</span><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h2><span id="1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</span><a href="#1-4-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p><strong>异常向量</strong>：不同的异常有不同的入口函数，那么这个异常入口函数的地址就是存放在该异常向量的位置。从该异常向量读取到的数据就是异常入口函数的地址。<br><strong>异常向量表</strong>：就是由异常向量组成的集合。</p>
<p>下图是从uboot源代码中截取的smdk2410 的异常向量表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:	b       reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>异常向量表对应的地址如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/4.png"></p>
<h1><span id="2-yi-chang-chu-li-liu-cheng">2 异常处理流程</span><a href="#2-yi-chang-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>CPU是如何进入到中断模式，执行中断服务程序的？</p>
<h2><span id="2-1-zhong-duan-qian">2.1 中断前</span><a href="#2-1-zhong-duan-qian" class="header-anchor">#</a></h2><p>下图是中断未触发前的程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/5.png"></p>
<h3><span id="2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</span><a href="#2-1-1-chu-shi-hua-zhong-duan" class="header-anchor">#</a></h3><pre><code>1，设置中断源（使中断能够产生，让CPU知道是哪个中断）
2，设置中断控制器（设置中断屏蔽，中断优先级）
3，设置中断总开关CPSR (使能中断)
</code></pre>
<h2><span id="2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</span><a href="#2-2-zhong-duan-chan-sheng-hou" class="header-anchor">#</a></h2><p>举个栗子：按键按下，产生按键irq。</p>
<h3><span id="2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</span><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h3><p>cpu强制跳转到异常向量表上对应的_irq异常向量（0x18）去读取指令（这个是CPU强制执行的，不需要我们去控制）。</p>
<p>具体的进入中断向量和中断返回流程见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/6.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入：</span><br><span class="line">	 (<span class="number">1</span>) LR_异常=PC + offset（具体多少看下图）</span><br><span class="line">	（<span class="number">2</span>）SPSR_异常=被中断前的程序模式CPSR</span><br><span class="line">	 (<span class="number">3</span>) CPSR被设置成对应的异常模式</span><br><span class="line">	（<span class="number">4</span>）跳转到对应的异常向量去执行</span><br><span class="line">退出（返回）：进入和退出就是一个逆过程</span><br><span class="line">	（<span class="number">1</span>）PC= LR_异常 -offset</span><br><span class="line">	（<span class="number">2</span>）被中断前的程序模式CPSR = SPSR_异常</span><br><span class="line">	（<span class="number">3</span>）中断结束，清中断</span><br></pre></td></tr></table></figure>

<p>进入异常和返回异常时pc和lr的关系如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/7.png"></p>
<p>从图中我们发现进入不同异常，offset的值也是有差异的。</p>
<h2><span id="2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</span><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h2><pre><code>1.当跳转到irq异常向量(0x18)后，发现该处是一条跳转指令“ldr pc, _irq”,
那么会通过ldr绝对跳转指令跳到到真正的中断处理函数_irq去执行。
2.那么在_irq的函数中我们需要按照之前说的**中断处理流程**去执行：
    （1）保存现场
    （2）异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
    （3）恢复现场
</code></pre>
<p>流程图总结下中断产生后的详细处理过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/8.png"></p>
<h1><span id="3-zhong-duan-shi-li">3 中断实例</span><a href="#3-zhong-duan-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</span><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang" class="header-anchor">#</a></h2><p>先来看下当cpu解析到什么样的指令才会触发未定义指令异常呢？</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/9.png"></p>
<p>从上面的arm指令格式中可知，只要指令码属于划线的格式，就属于未定义指令异常。</p>
<h3><span id="3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</span><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can" class="header-anchor">#</a></h3><p>我们知道汇编给C语言函数传参是通过r0，r1，…通过堆栈的方式去传递的参数，比如r0&#x3D;1, r1&#x3D;2;那么在被调用的c函数中argv0就是r0, argv1就是r1…,那么我们如果通过汇编给C函数传递字符串呢？</p>
<p>声明und_string为一个字符串:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>ldr r1, =und_string</code>，这样r1中就保存了und_string的地址。<br>这样调用我们的c函数就可以把und_string传入进去。</p>
<h3><span id="3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</span><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	sdram</span></span><br><span class="line"><span class="comment">	设置SP</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">	...</span><br><span class="line">	bl print1</span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>; <span class="comment">/*定义一条未定义指令*/</span></span><br><span class="line">	<span class="comment">/*故意以一个数据的方式引入一条未定义指令，当cpu执行到这里，读取0xdeadc0de指令码的时候，</span></span><br><span class="line"><span class="comment">	发现无法识别这条指令，就发生未定义指令异常，就跳转到0x4的中断向量去执行*/</span></span><br><span class="line">	</span><br><span class="line">	bl print2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>


<p>在未定义指令异常前后加上打印print1, print2，<strong>如果出现未定义指令异常后，就会跳到0x4的地方去读取指令，print2也就没法执行</strong>。</p>
<p>当跳转到0x4的中断向量后，发现此处是一条跳转指令<code>bl do_und</code>, 我们再到未定义指令异常的服务程序do_und中打印出und_string这个字符串的内容。<br>现在开始写指令异常的服务程序do_und，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>

<p>下面来分析一下这个未定义指令异常服务程序:</p>
<ol>
<li><p>进入未定义指令异常服务do_und之前硬件自动完成的事情如下：</p>
<ol>
<li>lr_und保存有被中断模式中的下一条即将执行的指令的地址</li>
<li>SPSR_und保存有被中断模式的CPSR</li>
<li>CPSR中的M4-M0被设置为11011, 进入到und模式</li>
<li>跳到0x4的地方执行程序 （bl do_und）</li>
</ol>
</li>
<li><p>进入指令异常服务程序do_und后，我们需要保存现场，处理und异常,恢复现场，<strong>注意：由于发生了cpu模式切换，如果要用到栈，那么先要设置对应模式的栈。</strong>由于栈的地址是向下生长的，这里我就用sdram的末位地址作为栈指针，把sp_und&#x3D;0x34000000。</p>
</li>
<li><p>在und异常服务程序中有可能会用到栈, 所以先保存现场，通过<code>stmdb sp!, &#123;r0-r12, lr&#125;</code>语句把栈中的值备份到r0-r12和lr，然后恢复现场的时候通过<code>ldmia sp!, &#123;r0-r12, pc&#125;^</code>，详见上面的注释。</p>
</li>
<li><p>我们看到保存现场后，我们把cpsr的值放到r0, 把und_string放到r1, 然后用bl printException调用c函数，这样我们的c函数printException就能收到汇编传过来的参数，一个是cpsr模式（r0），一个是und_string汇编传过来的字符串(r1)。我们用C函数实现printException：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printException</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpsr, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Exception! cpsr = &quot;</span>);</span><br><span class="line">	printHex(cpsr);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line"></span><br><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_und保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为11011, 进入到und模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x4的地方执行程序 （bl do_und）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">	<span class="comment">/* sdram */</span>	</span><br><span class="line">	bl copy2sdram</span><br><span class="line">	bl clean_bss</span><br><span class="line"></span><br><span class="line">	bl uart0_init</span><br><span class="line"></span><br><span class="line">	bl print1</span><br><span class="line">	<span class="comment">/* 故意加入一条未定义指令 */</span></span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>  <span class="comment">/* 未定义指令 */</span></span><br><span class="line">	bl print2</span><br><span class="line"></span><br><span class="line">	<span class="comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong>如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/10.png"></p>
<p>打印出print1中的字符串‘abc’后，紧接着打印printException函数中的结果，cpsr&#x3D;0x600000db,那么对应的M[4:0]&#x3D;11011， 对应下图为und模式。然后从und异常返回，恢复原来的模式继续执行。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/11.png"></p>
<h3><span id="3-1-3-shi-li-gai-jin">3.1.3 示例改进</span><a href="#3-1-3-shi-li-gai-jin" class="header-anchor">#</a></h3><h4><span id="3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</span><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi" class="header-anchor">#</a></h4><p>我们将上面的代码的und_string字符串修改一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编译烧录再次运行，发现没有任何打印输出，这是为什么呢？我明明只是把und_string字符串改了一下呀。</p>
<p>查看反汇编：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/12.png"></p>
<p>我们发现reset的地址是0x30000032，竟然不是4字节对齐的，我们知道arm指令集是以4字节为基本单位的，那么这里没有对齐，肯定无法解析指令。那么我们手工改进代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br></pre></td></tr></table></figure>

<font color="red" size="2.5">
.align 4
</font>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/13.png"></p>
<p>我们再来看看反汇编，发现reset的地址是30000040，是以4字节对齐的，再次烧录运行，发现能够正常输出print1, 能够进入未定义指令异常。</p>
<h4><span id="3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</span><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang" class="header-anchor">#</a></h4><p>如果我们程序非常大，中断向量入口代码的地址可能会大于sram的容量4k，比如do_und和do_swi，那么这个时候就需要用绝对跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">    b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br></pre></td></tr></table></figure>

<p>将上面的相对跳转换成如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">	ldr pc, und_addr </span><br><span class="line">    ldr pc, swi_addr</span><br><span class="line">    ...</span><br><span class="line">    ... </span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">    .word do_swi</span><br></pre></td></tr></table></figure>

<p>这样我们的do_und， do_swi就可放在4k之外的地方, 放到sdram。</p>
<h4><span id="3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</span><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing" class="header-anchor">#</a></h4><p>我们现在不断增加的程序代码量，那么有可能在 <code>ldr pc, =main</code> 这条指令执行之前程序就已经超过4k。那么我们当从nand启动的时候，还没执行到ldr pc, &#x3D;main这句来，就无法取指令执行了。nor同理超过2M也就无法取指令执行了。 所以我们干脆重定位完代码后就直接跳转到sdram上去执行,代码简要概述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">ldr pc, =sdram</span><br><span class="line">sdram：</span><br><span class="line">   ...</span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<p>我们再来分析下整个程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/14.jpg"></p>
<pre><code>1.一上电，cpu从0地址执行，执行b reset（进行初始化硬件）
2.重定位程序
3.跳转到sdram去继续执行
4.执行到 deadc0de,发生未定义指令异常
5.跳转到异常向量表的0x4地址去执行
6.跳转到sdram上执行异常处理函数（do_und）
7.异常返回，继续执行
</code></pre>
<h2><span id="3-2-swi-ruan-zhong-duan">3.2 swi-软中断</span><a href="#3-2-swi-ruan-zhong-duan" class="header-anchor">#</a></h2><p>arm有7中工作模式，除了usr模式，其他6种都是特权模式。</p>
<p>我们知道usr模式无法修改CPSR直接进入其他特权模式，但linux应用程序一般运行在usr模式，既然usr模式权限非常低，是无法直接访问硬件寄存器的，那么它是如何访问硬件的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux应用程序是通过系统调用，从而进入内核态，运行驱动程序来访问的硬件，那么系统调用又是如何实现的呢，就是通过软中断swi指令来进入svc模式，进入到svc模式后当然就能访问硬件啦。</span><br></pre></td></tr></table></figure>

<p>所以我们的应用程序在usr模式想访问硬件，必须切换模式:</p>
<p>有以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 发生异常或中断(被动的)</span><br><span class="line"><span class="number">2.</span> swi + 某个值(主动的)</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</span><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi" class="header-anchor">#</a></h3><p>s3c2440 一上电会跳到0地址（reset复位）执行代码，此时CPU处于svc模式，2440异常向量表如下图所示:<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/15.png"></p>
<p>为了验证usr模式能够主动的通过swi软中断指令来进入svc模式, 我们先将模式切换到usr模式，那么这个时候就不能访问硬件了，也不能直接修改cpsr直接进入其他模式。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/16.png"></p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/17.png"></p>
<p>从上图我们设置CPSR让M4-M0处在10000，这样就进入了usr模式。修改start.s如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>那么当执行到swi 0x123，就会触发SWI异常, 进入0x8的向量去执行，调用do_swi，我们参考do_und实现我们的软中断服务程序do_swi。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理swi异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">		b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>do_swi中调用printException，打印出了软中断异常的字符串和CPSR对应的svc模式。</p>
<h4><span id="3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</span><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao" class="header-anchor">#</a></h4><p>我们要读出swi 0x123指令，我们知道当执行完swi 0x123指令以后，会发生swi异常，那么lr_svc &#x3D; PC + offset。从下图看出offset是4：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/18.png"></p>
<p>修改中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;</span><br></pre></td></tr></table></figure>

<p>我们要把lr拿出来保存,因为bl printException会破坏lr，那么把lr保存在哪个个寄存器比较好呢？</p>
<p>我们知道当调用<code>bl printException</code>可能会修改某些寄存器，但是又会恢复这些寄存器，那么得知道它会保护哪些些寄存器。<br>来看下ATPCS规则：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/19.png" alt="img"></p>
<p>在子程序中,使用R4~R11来保存局部变量,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值。所以对于 r4 ~ r11在C函数里会保存这几个寄存器，执行完C函数再把它释放掉并且恢复原来的值。我们把lr 保存在r4寄存器里，r4寄存器不会被C语言破坏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov r4, lr</span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string</span><br><span class="line">bl printException</span><br></pre></td></tr></table></figure>

<p>当执行完<code>swi 0x123</code>指令后，会发生swi异常，swi异常模式里的lr寄存器会保存下一条指令的地址（即’ldr pc, &#x3D;main’），我们把lr寄存器的地址减去4就是<code>swi 0x123</code>这条指令的地址。</p>
<p>把r4的寄存器赋给r0让后打印我们得写出打印函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    mov r0, r4</span><br><span class="line"></span><br><span class="line">    sub r0, r4, #<span class="number">4</span>	<span class="comment">//得到swi指令的地址</span></span><br><span class="line">    bl printSWIVal</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>在uart.c添加printSWIVal打印函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printSWIVal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSWI)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SWI val = &quot;</span>);</span><br><span class="line">	printHEx(*pSWI &amp; ~<span class="number">0xff000000</span>); <span class="comment">//高8位忽略掉  </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</span><a href="#3-3-irq-wai-bu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</span><a href="#3-3-1-yin-ru-wai-bu-zhong-duan" class="header-anchor">#</a></h3><p>我们想实现一个按键点灯程序，我们知道有以下两种方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>轮询方案:轮询检测按键的电平状态，当检测到被按下后，对应的gpio会拉低，点亮对应的led;(略)</span><br><span class="line"><span class="number">2.</span>中断方案:将按键配置成外部中断源，当有按键按下，触发中断，在中断服务程序（isr）中去完成点灯。</span><br></pre></td></tr></table></figure>

<p>我们用按键作为外部中断源，我们把按键对应的gpio配置成中断引脚，当按键按下，相应的gpio产生了电平跳变，就会触发外部中断。</p>
<h3><span id="3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</span><a href="#3-3-2-wai-bu-zhong-duan-shi-li" class="header-anchor">#</a></h3><p>我们想达到按下按键灯亮, 松开按键灯灭这种效果（配成双边沿触发，按下的时候产生下降沿中断，进行点亮，松开产生上升沿中断，进行熄灭）。当然也可做成按一下点亮，再按一下熄灭的效果（设成单边沿触发，每来一次中断，对led电平进行一次取反）。<br>原理图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/20.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/21.png"></p>
<p>从按键的原理图中得知，当按键没有按下时，接上拉电阻，按键为高电平状态。当按键按下时，电位被拉低，按键处于低电平状态。s2-s5分别对应GPF0，GPF2，GPG3，GPG11; D10-D12这3盏led所对应的gpio分别是GPF4，GPF5，GPF6。</p>
<p>那么我们让s2,s3,s4分别控制D10,D11,D12；s5对D10-D12同时控制（按下s5同时点亮3个led）。</p>
<h4><span id="3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</span><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan" class="header-anchor">#</a></h4><p>配置D10-D12的gpio为输出模式，s2-s4的gpio为外部中断模式。</p>
<p>打开芯片手册找到第九章 IO ports，找到对应的gpio控制寄存器，将对应的gpio配置成中断模式。</p>
<ol>
<li>配置GPF GPIO为中断引脚：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/22.png"><br>同理GPG的寄存器类似。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">4</span>));	<span class="comment">//先把eint0和eint2这两个引脚清零</span></span><br><span class="line">GPFCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">4</span>));   <span class="comment">//S2,S3被配置为中断引脚</span></span><br><span class="line"></span><br><span class="line">GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">22</span>));</span><br><span class="line">GPGCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">22</span>));   <span class="comment">//S4,S5被配置为中断引脚</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置中断触发方式:</li>
</ol>
<p>当电平从高变低时，此时表示按键按下，当电平由低变高，表示松开按键。不妨设置中断方式为双边沿触发，按下按键，触发下降沿中断，中断服务程序就可以去点亮led，反之，松开触发上升沿中断，就可以去熄灭led。<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/23.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/24.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTINT0 |= (<span class="number">7</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">7</span>&lt;&lt;<span class="number">8</span>);     <span class="comment">/* S2,S3 */</span></span><br><span class="line">EXTINT1 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S4 */</span></span><br><span class="line">EXTINT2 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S5 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置外部中断屏蔽寄存器EINTMASK：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/26.png"></li>
</ol>
<p>从上图我们知道外部中断0-3是直接连接到中断控制器，而外部中断4-7、外部中断8-23还要经过EINTMASK,那么我们需要配置EINTMASK来打开中断的通道：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/27.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EINTMASK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">19</span>));    <span class="comment">//打开外部中断通道</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>外部中断挂起寄存器EINTPEND:</li>
</ol>
<p>当一个外部中断（EINT4-EINT23）发生后，那么相应的位会被置1, 所以中断结束后需要清除对应位。这个寄存器可以用来区分外部中断4-23的哪一个中断源。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/28.png"></p>
<h4><span id="3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</span><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi" class="header-anchor">#</a></h4><p>我们先来看下中断控制器的总框图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/29.png"></p>
<p><strong>1. 首先是SRCPND:用来表示哪个中断源发出了中断请求。</strong></p>
<p>先看下中断源:<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/30.png"></p>
<p>从上图我们发现外部中断有24个外部中断，除了外部中断EINT，还有定时器中断，ADC中断，UART中断等…。</p>
<p>我们来认识下SRCPND寄存器：（用来表示哪个（哪些）中断源已产生中断请求，中断结束后要清中断）<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/31.png"></p>
<p>从上图中我们发现EINT4-7共用1bit，EINT8-23共用1bit，那么肯定有其他寄存器来区分它们，那就是EINTPEND寄存器（后面5会讲）。</p>
<p><strong>2. 然后到达INTMSK：（中断屏蔽寄存器）</strong></p>
<p>我们需要把INTMSK寄存器配置成非屏蔽状态，默认是中断源时屏蔽的，见下图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/32.png"></p>
<p><strong>3.INTMOD（中断模式，是fiq还是irq）</strong><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/33.png"></p>
<p><strong>4.Priroty:</strong></p>
<p><strong>5.INTPND:</strong><br>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p>中断发生后，SRCPND中会有bit置1，可能好几个（因为同时可能发生几个中断），这些中断会由优先级仲裁器选出一个最紧迫的，然后把INTPND中相应位置1。所以只有INTPND置1，CPU才会处理。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/34.png"></p>
<p>我们知道有可能同时出现多个中断请求，那么INTPND就挑选出当前优先级最高的、正在发生的中断。</p>
<p>当产生irq后，要去分辨是哪个中断源，根据不同的中断源去中断服务程序isr中做不同的事情，那么如何得知当前产生的中断是哪一个外部中断源产生的呢？那么就可以访问这个INTPND寄存器。</p>
<p>可是我们要去手工去解析INTPND里面的位，才能知道是哪个中断源产生了中断请求。那么有没有什么比较快捷的方式自动帮我们解析INTPND呢，直接返回中断号给我们？</p>
<p>当然有啦，有一个INTOFFSET寄存器的值就是代表哪个中断请求产生了，如果INTOFFSET&#x3D;0表示EINT0产生了中断请求，INTOFFSET&#x3D;2表示EINT2产生了中断请求。具体见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/35.png"></p>
<p>我们从上图看到ENIT4-7共用一个offset， EINT8-23也共用一个offset，那么要通过访问EINTPEND寄存器来区分它们。</p>
<p>中断控制器设置代码入下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化中断控制器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19</span></span><br><span class="line">    INTMSK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)); </span><br><span class="line">    <span class="comment">//INTMOD默认是irq，可以不设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</span><a href="#3-3-3-3-zhong-duan-zong-kai-guan" class="header-anchor">#</a></h4><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/36.png"></p>
<p>CPSR有I位，是irq的总开关，我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把bit7这一位清零 */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</span><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>到这里中断前的初始化工作知识点就已经讲完了，当然要提前准备好led初始化工作（就是将led对应的gpio配置成输出模式，这个不讲解）。</p>
<p>那么中断产生后，我们之前讲过，会跳转到0x18异常向量，执行跳转指令<code>ldr pc, =_irq</code>，和之前的swi异常，und异常框架一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	ldr pc, und_addr <span class="comment">/* vector 4 : und（绝对跳转） */</span></span><br><span class="line">	ldr pc, swi_addr <span class="comment">/* vector 8 : swi */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x0c : prefetch aboot */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x10 : data abort */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x14 : reserved */</span></span><br><span class="line">	ldr pc, irq_addr <span class="comment">/* vector 0x18 : irq */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x1c : fiq */</span></span><br><span class="line"></span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">	.word do_swi</span><br><span class="line">irq_addr:</span><br><span class="line">	.word do_irq</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/*初始化时钟*/</span></span><br><span class="line">	<span class="comment">/*初始化sdram,设置栈*/</span></span><br><span class="line">	<span class="comment">/*代码重定位,清bss*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把bit7这一位清零(打开中断总开关) */</span></span><br><span class="line">	bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">	msr cpsr, r0</span><br><span class="line"></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>1.我们在start.s中用汇编代码设置cpsr的I位，开启中断开关；</p>
<p>2.在main函数中初始化中断源key_eint_init，初始化中断控制器interrupt_init；</p>
<p>3.然后继续执行main主函数。</p>
<p>4.当中断产生，触发irq异常，进入0x18异常向量，执行do_irq。</p>
<p>do_irq实现如下（和do_und, do_swi类似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">do_irq:</span><br><span class="line">	<span class="comment">/* 执行到这里之前: */</span></span><br><span class="line">	<span class="comment">/* 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址 */</span></span><br><span class="line">	<span class="comment">/* 2. SPSR_irq保存有被中断模式的CPSR */</span></span><br><span class="line">	<span class="comment">/* 3. CPSR中的M4-M0被设置为10010, 进入到irq模式 */</span></span><br><span class="line">	<span class="comment">/* 4. 跳到0x18的地方执行程序 */</span> </span><br><span class="line">	<span class="comment">/* sp_irq未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33d00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	sub lr, lr, #<span class="number">4</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">		</span><br><span class="line">	<span class="comment">/* 处理irq异常 */</span></span><br><span class="line">	bl handle_irq_c</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>


<p>handle_irq_c函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_eint_irq</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = EINTPEND;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val1 = GPFDAT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val2 = GPGDAT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (irq == <span class="number">0</span>) <span class="comment">/* eint0 : s2 控制 D12 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) <span class="comment">/* s2 --&gt; gpf6 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">2</span>) <span class="comment">/* eint2 : s3 控制 D11 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) <span class="comment">/* s3 --&gt; gpf5 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">5</span>) <span class="comment">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) <span class="comment">/* eint11 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) <span class="comment">/* s4 --&gt; gpf4 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下 */</span></span><br><span class="line">				GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">19</span>)) <span class="comment">/* eint19 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				<span class="comment">/* 熄灭所有LED */</span></span><br><span class="line">				GPFDAT |= ((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下: 点亮所有LED */</span></span><br><span class="line">				GPFDAT &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EINTPEND = val; 	<span class="comment">/* 清中断 : 源头*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*INTOFFSET中哪一位被设置成1，就表示哪一个 中断源*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);<span class="comment">/*清EINT0，EINT2，EINT5*/</span></span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</span><a href="#3-4-irq-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</span><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi" class="header-anchor">#</a></h3><p>s3c2440共有2种定时器：</p>
<pre><code>1.Watchdog看门狗定时器
2.PWM脉冲可调制定时器
</code></pre>
<p>下面详细介绍2种定时器的原理，来了解定时器是如何产生定时器中断的。</p>
<h4><span id="3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</span><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>Watchdog定时器的原理很简单，寄存器很少，框图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/37.png"></p>
<ol>
<li>定时器，定时器那肯定是需要用到时钟的，从框图中可以看到Watchdog定时器采用的时钟源是PCLK，从<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中也可以体现出来，接的是APB总线。</li>
<li>然后到达一个8 bit的分频器，可以通过配置WTCON[15:8]来设置分频器的预设值。</li>
<li>再设置WTCON[4:3]来设置除数因子来进一步分频。<br>所以最终的Watchdog定时器的时钟周期<code>t_watchdog = 1/[ PCLK / (Prescaler value + 1) / Division_factor ]</code></li>
<li>到达WTCNT：看门狗递减寄存器。WTCNT里的数据就开始在输入时钟频率下递减。WTCNT的值由WTDAT寄存器提供。</li>
<li>WTDAT：WTDAT寄存器用于指定计数器的初始值，也就是它的超时时间，<strong>系统上电之后硬件自动的将0x8000的初始值载入到WTCNT里，在发生了第一次超时操作时，WTDAT的值才会载入到WTCNT寄存器</strong>。</li>
</ol>
<p>当WTCNT的值减到0时，就会触发看门狗定时器中断，进而产生复位。中断框图中可以看到可以设置WTCON[2]来设置是否产生中断信号，可以设置WTCON[0]来设置是否产生复位信号。</p>
<h5><span id="3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</span><a href="#3-4-1-1-1-wtcon-ji-cun-qi" class="header-anchor">#</a></h5><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/38.png"></p>
<h5><span id="3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</span><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi" class="header-anchor">#</a></h5><p> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/39.png"></p>
<h3><span id="3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</span><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li" class="header-anchor">#</a></h3><h4><span id="3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</span><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>在之前的章节中，我们在start.s启动代码中首先做的就是关闭看门狗，把WTCON[5]&#x3D;0，也就是把Watchdog timer给disable。那么Watchdog Timer就不再工作了，这样做是为了防止在启动代码进行硬件初始化的时候出现超时，发出复位信号又去重启硬件，这样就陷入了不断重启过程中。因为s3c2440芯片默认WTCON[5]是1，也就是Watchdog Timer默认是处于使能状态。</p>
<p>从<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中配置了PCLK&#x3D;50M Hz, 那么让WTDAT取默认值0x8000，那么根据公式算出从开机到触发复位重启的时间：</p>
<p><code>t=WTDAT*( 1/[ PCLK / (Prescaler value + 1) / Division_factor ])</code>。</p>
<p>根据WTCON寄存器配置Prescaler value&#x3D;255，配置Division_factor&#x3D;128，这样最终定时器分得的频率更低，那么减数器递减的更慢，也就代表从开机到触发复位重启的时间:</p>
<p><code>T=0x8000 * (1/[50*10^6/(255+1)/128]) = 21474836.48us = 21s</code>。</p>
<p>之前的start.s中把看门狗已经关闭了，那么我们在跳转到main函数中调用wtd_timer_init函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//使能定时器，开启reset复位</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看测试结果：<br>果然初始化wtd_timer_init后，过21s后板子重启了，说明我们watchdog定时器功能已经OK了。</p>
<p>现在修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//使能定时器，开启watchdog定时器中断</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">	WTDAT = <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到我们现在定时器的初值被修改成了0x4000, 相对于默认值少了一半，那么触发wtd_timer中断的时间应该减半，也就是约等于10s。</p>
<h4><span id="3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</span><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>那么需要写一个wtd_timer的中断服务程序，同样需要先在do_irq中去保护现场、调用handle_irq_c、恢复现场。查看INTOFFSET寄存器：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/40.png"></p>
<p>得知：<br>handle_irq_c代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        这里还需区分子中断源</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看芯片手册查找“INT_WDT_AC97”如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/41.png"></p>
<p>从上图可以看到SRCPND和SUBSRCPND的映射关系。<br>SUBSRCPND寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/42.png"></p>
<p>我们可以读取SUBSRCPND来区分到底是哪一个子中断源产生了中断，当SUBSRCPND中哪一位被置1，表示对应的中断源发生了中断。</p>
<p>前面做完wtd_timer_init，还要进行中断控制器的初始化，查看INTMSK寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/43.png"></p>
<p>查看INTSUBMSK寄存器如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/44.png"></p>
<p>在interrupt_init中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//不屏蔽INT_WDT_AC97</span></span><br><span class="line">INTSUBMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//不屏蔽INT_AC97</span></span><br></pre></td></tr></table></figure>

<p>修改handle_irq_c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">9</span>)<span class="comment">//INTOFFSET==9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SUBSRCPND &amp; <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;watchdog timer interrupt occured.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</span><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi" class="header-anchor">#</a></h3><p>PWM（Pulse Width Modulation），字面上是脉冲可调制的意思，就是可以调节占空比。</p>
<p>s3c2440有5个定时器，其中定时器0、1、2和3具有脉宽调制（PWM）功能。定时器4是一个无输出引脚的内部定时器。</p>
<p>先认识下s3c2440的pwm timer的框架：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/45.jpg"></p>
<pre><code>1.时钟源为PCLK
2.pclk经过8 bit的预分频系数（Prescaler），和4 bit的时钟除数因子（clock divider）,进行分频
3.经过MUX选择器选择用哪个定时器（5选1）
4.设置TCMPB0和TCNTB0和TCONn寄存器
</code></pre>
<h4><span id="3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</span><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>pwm定时器的逻辑控制单元结构如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/46.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> TCMPBn和TCNTBn寄存器中的值分别加载到TCMPn和TCNTn寄存器</span><br><span class="line"><span class="number">2</span> 每来一个clk(时钟)这个TCNTn减去<span class="number">1</span></span><br><span class="line"><span class="number">3</span> 当TCNTn == TCMPn时，可以产生中断，pwm输出引脚反转</span><br><span class="line"><span class="number">4</span> TCNTn继续减<span class="number">1</span>，当TCNTn == <span class="number">0</span>时，又产生一次中断，pwm引脚再次反转</span><br><span class="line"><span class="number">5</span> 重复<span class="number">1</span><span class="number">-4</span>过程</span><br></pre></td></tr></table></figure>

<p>设置TCNTBn寄存器来设置加载初值，设置后TCNTn中的值就会按照时钟周期递减。<br>设置TCMPBn寄存器来设置占空比，从而控制高低电平持续时间的比例。</p>
<h4><span id="3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</span><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian" class="header-anchor">#</a></h4><p>要开始一个PWM定时器功能的步骤如下：(假设使用的是timer0)</p>
<h5><span id="3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</span><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi" class="header-anchor">#</a></h5><p>定义一个pwm_timer_init()函数。</p>
<ol>
<li><p>设置时钟：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/47.png"><br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/48.png"></p>
<p> 分别设置定时器0的预分频器值(prescaler)和时钟分频值(clock divider)，从而控制TCNT0减数器的频率。</p>
</li>
</ol>
<p>根据公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwm Timer clk = PCLK / &#123;(预分频数)prescaler value+<span class="number">1</span>&#125; / &#123;divider value(<span class="number">5.1</span>MUX值)&#125; </span><br></pre></td></tr></table></figure>
<p>PCLK是50M，设置prescaler value&#x3D;99， divider value&#x3D;16,所以pwm Timer clk&#x3D; 50000000&#x2F;(99+1)&#x2F;16 &#x3D; 31250 Hz</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCFG0 = <span class="number">99</span>; </span><br><span class="line">TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">TCFG1 |= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置初值：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置比较缓存寄存器TCMPB0和计数缓存寄存器TCNTB0的初始值*/</span></span><br><span class="line">TCNTB0 = <span class="number">31250</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">/* 2s中断一次 */</span></span><br><span class="line">TCMPB0 = <span class="number">31250</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* 设置占空比*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>开启定时器0的手动更新TCNTB0&amp;TCMPB0功能(设置TCON的第1位)：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/49.png"></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开始需要手工更新,这样才能将TCNTB0&amp;TCMPB0同步到TCNT0&amp;TCMP0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启定时器0的自动加载：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开启自动加载要先清除手动更新</span></span><br><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动定时器0(设置TCON的第0位)；</li>
</ol>
<p>	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>初始化中断控制器:</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/50.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interrupt_init()&#123;</span><br><span class="line">	...</span><br><span class="line">	INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* enable timer0 int */</span>		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完这些初始化工作，就可以产生定时器中断了,同样我们需要在handle_irq_c函数中区分中断源：</p>
<h5><span id="3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</span><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h5><p>我们可以通过查看TCNTO0寄存器来查看当前TCNT的值。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/52.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>) <span class="comment">//INT_WDT_AC97</span></span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">10</span>) <span class="comment">//timer0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timer0 interrupt occured.\n&quot;</span>);</span><br><span class="line">		print_hex(TCNTO0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</span><a href="#3-5-irq-de-you-hua-gai-jin" class="header-anchor">#</a></h2><p>我们对比irq外部中断， irq定时器中断，发现每增加一个中断源，又要去修改中断控制器的初始化interrupt_init()和handle_irq_c(),要在handle_irq_c()中去添加分支去执行不同的中断服务。</p>
<p>那么我们现在不去改变interrupt文件，在timer.c、key_eint.c中去注册自己的中断服务程序即可，这里我们使用<strong>函数指针数组</strong>，建立一个中断号和中断服务程序的映射关系。这样就可以根据中断号来执行对应的中断服务程序，即在handle_irq_c()中去回调不同类型的中断源注册下来的函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义函数指针数组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUM	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*irq_func)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">irq_func irq_array[IRQ_NUM];</span><br></pre></td></tr></table></figure>

<p>然后实现一个register_irq(…)如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_irq</span> <span class="params">(<span class="type">int</span> irq, irq_func fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_array[irq] = fp;</span><br><span class="line">	INTMASK &amp;= ~(<span class="number">1</span> &lt;&lt; irq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_irq_c()修改实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	irq_array[bit](bit); <span class="comment">//根据中断号回调不同的中断处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 清中断 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们的irq中断就被统一管理了起来，只要在其他各中断模块初始化的时候调用register_irq(…)注册即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/" data-id="clv2aig4400006slp2w7r1a9l" data-title="s3c2440裸机-异常中断" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-代码重定位和清bss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/" class="article-date">
  <time class="dt-published" datetime="2024-04-15T07:28:42.000Z" itemprop="datePublished">2024-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</a><ul>
<li><a href="#1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</a></li>
<li><a href="#1-2-lian-jie-jiao-ben">1.2 链接脚本</a><ul>
<li><a href="#1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</a><ul>
<li><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</a></li>
<li><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</a></li>
</ul>
</li>
<li><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</a></li>
<li><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</a><ul>
<li><a href="#1-2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-qing-chu-bss">2 清除bss</a><ul>
<li><a href="#2-1-bss-duan-jie-shao">2.1 bss段介绍</a></li>
<li><a href="#2-2-qing-bss">2.2 清bss</a></li>
<li><a href="#2-3-qing-bss-you-hua">2.3 清bss优化</a><ul>
<li><a href="#2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</a></li>
<li><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wei-zhi-wu-guan-ma">3 位置无关码</a><ul>
<li><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</a><ul>
<li><a href="#3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</a></li>
<li><a href="#3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</a></li>
<li><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</span><a href="#1-yin-ru-dai-ma-chong-ding-wei" class="header-anchor">#</a></h1><p>s3c2440的cpu默认是从0地址开始取指令执行，当从nor启动时,0地址对应nor, nor可以像内存一样读，但不能像内存一样写，前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a> 讲过，写入norflash要进行按照spec进行命令表写入。因此我们能够从nor上取指令执行。</p>
<p>当nand启动的时候，我们nand中的前4K指令会变自动加载到sram中去，这时的0地址对应sram。那么我们的程序如果大于4K,要从nand启动，sram只拷贝了nand中的前4K代码，那么如何解决这个问题呢？</p>
<p>就需要重定位代码到dram(ddr)中去，dram的容量较大，又可以直接被cpu访问。</p>
<h2><span id="1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</span><a href="#1-1-cheng-xu-di-zhi-kong-jian" class="header-anchor">#</a></h2><p>我们知道，程序包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text）</span><br><span class="line">数据段(.data):存放初始值不为<span class="number">0</span>的全局变量/静态变量</span><br><span class="line">rodata段(.rodata)：<span class="type">const</span>修饰的全局变量或静态变量</span><br><span class="line">bss段(.bss)：存放初始值为<span class="number">0</span>或者未初始化的全局变量/静态变量</span><br><span class="line">commen段(.commen):注释</span><br></pre></td></tr></table></figure>

<p>下面展开一个实验引入为什么要代码重定位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharB = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharC = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharD = <span class="string">&#x27;D&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_roval = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效，由于nor启动，nor上不可写 */</span></span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将上面的代码编译出的裸机程序分别烧录到nand和nor flash，看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 烧录到nor flash, 程序一直输出`AAAA`。</span><br><span class="line">2. 烧录到nand flash,程序无任何输出。</span><br></pre></td></tr></table></figure>

<p>我们发现nor启动时, 对全局变量g_char++无效, nand启动程序无任何输出。我们对程序进行反汇编处理：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/1.png"></p>
<p>可以看到.text段是从0地址开始的，证明cpu的确从0地址取指令进行译码、执行。<br>当从nor启动时，0地址对应nor；当从nand启动时，0地址对应sram，所以无论从nand还是从nor启动cpu都能取指令执行。</p>
<p>再进一步分析反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/2.png"></p>
<p>可以看到.data段的起始地址是0x8474(即g_Char变量的地址为0x8474）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当把程序烧录进nor,  .data段在nor上的某一段区域, 由于nor能像内存一样读，但不能像内存一样直接写，因此对<span class="string">&#x27;g_Char&#x27;</span>修改无效。</span><br><span class="line"><span class="number">2.</span> 当把程序烧录进nand, .data段在nand的某一区域，nand启动时硬件会自动把nand上的前<span class="number">4</span>K数据copy到SRAM,然后cpu从sram取指令执行。但是.data段的起始地址<span class="number">0x8474</span>&gt;<span class="number">0x1000</span>，超过了<span class="number">4</span>K, cpu没法把.data段也copy到SRAM,所以当访问<span class="string">&#x27;g_Char&#x27;</span>时，发生了异常（abt数据访问终止，这个异常后面有在下一节“异常与中断”里面专门讲解)，因此程序卡死。</span><br></pre></td></tr></table></figure>

<p>再仔细看看反汇编，发现.rodata段和.text段是连续的,但是.rodata段和.data段中间有一段”空洞”。用图形表示更形象，bin文件的内容分布如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/3.png"><br>那么我们怎么去掉空洞，让.data段了紧接着.rodata段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 链接脚本(后面1.2有专门讲)</span><br><span class="line">2. 直接在编译的时候用 &quot;-Tdata 0x800&quot;，这样指定.data段基地址为0x800,这样nand启动时.data就能自动copy到SRAM了。</span><br></pre></td></tr></table></figure>

<p>我们现在使用<code>-Tdata 0x800</code>编译出裸机程序，对应反汇编如下：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/4.png"></p>
<p>这时我们烧录程序到nand，从nand启动，发现能输出<code>ABCDEFG</code>了，这就对了，因为.data段数据从nand自动拷贝到了sram。</p>
<p>有人说为什么不吧.data段指向到dram呢，这样无论时nor启动还是nand启动不就都能对全局变量写了？<br>当然这个没错，我做了这个尝试，编译时用<code>-Tdata 0x30000000</code>, 发现编译出来的bin文件有800多M,为什么有这么大呢？由于我们指定.data段存放在0x30000000(sdram的基地址)，这时bin文件的内部结构如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/5.png"></p>
<p>这么大的bin文件根本无法烧录。通过上面的例子，现在总结下为什么要代码重定位:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.nand启动，前4K代码被自动copy到sram，当程序大于4K的时候需要重定位代码到sdram。</span><br><span class="line">2.nor启动， 全局变量在nor上，不能像内存一样直接写该全局变量，那么也需要重定位到sdram。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-lian-jie-jiao-ben">1.2 链接脚本</span><a href="#1-2-lian-jie-jiao-ben" class="header-anchor">#</a></h2><h3><span id="1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</span><a href="#1-2-1-chong-ding-wei-data-duan" class="header-anchor">#</a></h3><p>我们发现<code>arm-linux-ld -Ttext 0 -Tdata 0x30000000</code>这种方式编译出来的bin文件有800多M,这肯定是不行的。可以通过AT参数指定.data段在编译时的存放位置，我们发现这样指定太不方便了，而且不好确定要放在bin文件的哪个位置。这里就要引入链接脚本，它可以帮我们解决这个不必要的麻烦。</p>
<h4><span id="1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</span><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/6.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x00000000</span>; <span class="comment">//表示当前地址为0</span></span><br><span class="line">	. = ALIGN(<span class="number">4</span>);  <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.text  :   </span><br><span class="line">	&#123;</span><br><span class="line">	  cpu/arm920t/start.o	(.text)</span><br><span class="line">	  board/lyb2440/boot_init.o (.text)</span><br><span class="line">	  *(.text)</span><br><span class="line">	&#125;	<span class="comment">//表示.text段从0x4开始存放,其中可以手动调整代码段的位置，</span></span><br><span class="line">	    <span class="comment">//比如让start.o，boot_init.o中的函数放在最前面,然后存放剩余的代码段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.rodata : &#123; *(.rodata) &#125; <span class="comment">//从该位置开始存放所有的.rodata段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.data : <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//从该位置开始存放所有的.data段 设置运行</span></span><br><span class="line"></span><br><span class="line">	__bss_start = .; <span class="comment">//设置.bss段的起始位置</span></span><br><span class="line">	.bss : &#123; *(.bss) &#125; <span class="comment">//从该位置开始存放所有的.bss段</span></span><br><span class="line">	_end = .;<span class="comment">//设置.bss段的结束位置（也就是整个链接脚本的结束为止）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是从uboot中裁剪过来的链接脚本，注释已经链接脚本的结构讲解的差不多了。这里.data段指定了程序的<strong>运行（链接）地址为sdram的base_addr（0x30000000）</strong>，通过<strong>AT指定加载（在bin文件的存放）地址0x800</strong>。</p>
<h4><span id="1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</span><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi" class="header-anchor">#</a></h4><p>对于nor启动时，我们可以直接从nor上取指令执行，所以可以只进行数据段的重定位（数据段需要写入），我们编写链接脚本sdram.lds如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .text   <span class="number">0</span>  : &#123; *(.text) &#125;<span class="comment">//所有文件的.text</span></span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125; <span class="comment">//只读数据段</span></span><br><span class="line">    .data <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//放在0x800,但运行时在0x3000000</span></span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;<span class="comment">//所有文件的bss段，所有文件的.COMMON段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序烧录进nor flash，程序运行时会将.data拷贝到0x0x30000000也就是sdram中去。只重定位数据段的过程用下图更直观:</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/7.png"></p>
<p>因此就可以对g_char进行写入了。Makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">       arm-linux-gcc -c -o led.o led.c</span><br><span class="line">       arm-linux-gcc -c -o uart.o uart.c</span><br><span class="line">       arm-linux-gcc -c -o init.o init.c</span><br><span class="line">       arm-linux-gcc -c -o main.o main.c</span><br><span class="line">       arm-linux-gcc -c -o start.o start.S</span><br><span class="line">       <span class="comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span></span><br><span class="line">       arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf</span><br><span class="line">       arm-linux-objcopy -O binary -S sdram.elf sdram.bin</span><br><span class="line">       arm-linux-objdump -D sdram.elf &gt; sdram.dis</span><br></pre></td></tr></table></figure>

<p>修改start.s进行.data段的重定位。我们需要将以0x800为.data段基地址的整个数据段copy到0x30000000处:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		/* 关闭看门狗 */</span><br><span class="line">		/* 初始化时钟 */</span><br><span class="line">		/* 设置栈 */</span><br><span class="line">		/*初始化sdram*/</span><br><span class="line">	...</span><br><span class="line">		/* 重定位data段，把加载地址0x800（bin文件中在nor中）的数据段的内容重定位到sdram的baseaddr */</span><br><span class="line">		mov r1, #0x800</span><br><span class="line">		ldr r0, [r1]</span><br><span class="line">		mov r1, #0x30000000</span><br><span class="line">		str r0, [r1]</span><br><span class="line">	</span><br><span class="line">		bl main</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>用几行简单的数据加载存储指令即可实现数据段的重定位，这里是用的相对跳转指令bl main，因为还没有重定位整个完整的代码，所以不能用ldr绝对跳转。前面的初始化时钟、sdram我就不写了，参考<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> , <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>。</p>
<p>缺点：<br>这里只是人为的对.data段写死了,那么当我有多个全局变量时，还要计算重定位的次数,而且我们也不知道有多少个全局变量，所以这重定位方式有缺陷。那么我们对这种重定位.data断的方法做一个改进，将链接脚本修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    .text   0  : &#123; *(.text) &#125;</span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125;</span><br><span class="line">    .data 0x30000000 : AT(0x800) </span><br><span class="line">    &#123; </span><br><span class="line">    data_load_addr = LOADADDR(.data);	/* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    data_start = . ;			/* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    *(.data) 				</span><br><span class="line">    data_end = . ;			/* data段结束地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本用一个变量data_load_addr指定了加载地址(data段在bin文件中的地址，即0x800），用变量data_start指定了运行地址（即为0x30000000），那么用data_end - data_start就是我们数据段的总长度。</p>
<p>对start.s重定位过程做出如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 重定位data段 */</span><br><span class="line">    ldr r1, =data_load_addr  /* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    ldr r2, =data_start 	 /* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    ldr r3, =data_end 	     /* data段结束地址 */</span><br><span class="line">cpy:</span><br><span class="line">    ldrb r4, [r1]</span><br><span class="line">    strb r4, [r2] /*r2存入data_load_addr 0x400, 然后，r2,r1依次自加*/</span><br><span class="line">    add r1, r1, #1</span><br><span class="line">    add r2, r2, #1</span><br><span class="line">    cmp r2, r3</span><br><span class="line">    ble cpy</span><br><span class="line"></span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">    b halt</span><br></pre></td></tr></table></figure>

<p>这里start.s中用到了链接脚本中的label地址。</p>
<h3><span id="1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</span><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan" class="header-anchor">#</a></h3><p>由于我们的程序可能会大于SRAM或者nor的容量，那么就必须连代码段也一起进行重定位，这种重定位方式更好，在实际应用中也是用的这种方式去做的重定位。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/8.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码段的地址设置为0x3000_0004，然后紧接着放.rodata段，然后再紧接着放.data段。这样我们的bin文件就不再有“空洞”了。再来看重定位代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		...</span><br><span class="line">		/* 重定位text, rodata, data段整个程序 */</span><br><span class="line">		mov r1, #0</span><br><span class="line">		ldr r2, =_start 	    /* 第1条指令运行时的地址，也就是.text段的runtime addr，在这里是0x3000_0004*/</span><br><span class="line">		ldr r3, =__bss_start    /* bss段的起始地址,也就是整个程序的结束地址  */</span><br><span class="line">	cpy:</span><br><span class="line">		ldrb r4, [r1]</span><br><span class="line">		strb r4, [r2]</span><br><span class="line">		add r1, r1, #1</span><br><span class="line">		add r2, r2, #1</span><br><span class="line">		cmp r2, r3</span><br><span class="line">		ble cpy</span><br><span class="line">	</span><br><span class="line">		bl main  	</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>整个bin文件程序的长度（.text + .rodata + .data）为__bss_start - _start,那么我们是把bin文件从存储介质的0地址copy到程序的运行地址0x3000_0004，这样我们访问.data段时就是访问sdram中重定位后的数据段了。</p>
<h3><span id="1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</span><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua" class="header-anchor">#</a></h3><h4><span id="1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h4><p>前面重定位时，我们使用的是ldrb命令从的Nor Flash读取1字节数据，再用strb命令将1字节数据写到SDRAM里面。<br>我们开发板的Nor Flash是16位，SDRAM是32位。 假设现在需要复制16byte数据。</p>
<table>
<thead>
<tr>
<th>不同的读写指令</th>
<th>cpu读取nor的次数</th>
<th>cpu写入sdram的次数</th>
</tr>
</thead>
<tbody><tr>
<td>ldrb、strb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>ldr、str</td>
<td>8</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以看出我们更换读写指令后读写次数变少了，提升了cpu的访问效率。修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cpy:</span><br><span class="line">    ldr r4, [r1]</span><br><span class="line">    str r4, [r2]</span><br><span class="line">    add r1, r1, #4 //r1加4</span><br><span class="line">    add r2, r2, #4 //r2加4</span><br><span class="line">    cmp r2, r3 //如果r2 =&lt; r3继续拷贝</span><br><span class="line">    ble cpy</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</span><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x30000000</span>;</span><br><span class="line">    __code_start = .;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> 	&#123;</span><br><span class="line">    <span class="comment">//要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line">    <span class="comment">//然后从0地址把数据复制到__code_start</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dest &lt; end) &#123;</span><br><span class="line">        *dest++ = *src++; <span class="comment">//从0地址依次copy到__code_start(代码段的运行地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start.s中设置栈指针sp后，即可执行bl copy2sdram进行重定位代码。如何设置栈指针参考<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> 有实现，重复代码我就不贴上来了。</p>
<h1><span id="2-qing-chu-bss">2 清除bss</span><a href="#2-qing-chu-bss" class="header-anchor">#</a></h1><h2><span id="2-1-bss-duan-jie-shao">2.1 bss段介绍</span><a href="#2-1-bss-duan-jie-shao" class="header-anchor">#</a></h2><p>bss段是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效 ，重定位到sdram的baseaddr后有效*/</span></span><br><span class="line">		<span class="built_in">putchar</span>(g_Char3);</span><br><span class="line">		g_Char3++;</span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把程序烧进去，然后打印g_A，但是发现g_A这个值并不是0，而是一个随机值。我们学习linux时知道全局变量g_A, g_B输出肯定是0，裸机输出不是0，为什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原因：程序执行汇编过程做完了重定位后把代码copy到了sdram上，然后sdram上紧接着的地址就是.bss的基地址了，这时候bss段的这块内存没有经过任何处理，所以是随机的。</span><br><span class="line">那么我们重定位完代码后需要进行清除sdram上.bss段的数据，因为我们知道bss是未初始化和初始值为<span class="number">0</span>的全局变量。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-qing-bss">2.2 清bss</span><a href="#2-2-qing-bss" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x30000000;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .text      :&#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除bss段的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 清除BSS段 */</span><br><span class="line">	ldr r1, =__bss_start</span><br><span class="line">	ldr r2, =_end</span><br><span class="line">	mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">	strb r3, [r1]</span><br><span class="line">	add r1, r1, #1</span><br><span class="line">	cmp r1, r2</span><br><span class="line">	ble clean</span><br><span class="line"></span><br><span class="line">	bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>我们把程序再烧进去，然后打印g_A，但是发现g_A的值是0了。本质上就是对重定位后的bss段数据清0。</p>
<h2><span id="2-3-qing-bss-you-hua">2.3 清bss优化</span><a href="#2-3-qing-bss-you-hua" class="header-anchor">#</a></h2><h3><span id="2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    ldr r1, =__bss_start</span><br><span class="line">    ldr r2, =_end</span><br><span class="line">    mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">    str r3, [r1]</span><br><span class="line">    add r1, r1, #4</span><br><span class="line">    cmp r1, r2</span><br><span class="line">    ble clean</span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</span><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_bss</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 从lds文件中获得 __bss_start, _end*/</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> _end, __bss_start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *start = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">		*start++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：汇编代码获取的是链接脚本中的变量的地址，而C语言代码中获取的是链接脚本中的变量的值</strong>，所以这里的用C语言改进重定位还是清bss都是要加取址符。</p>
<h3><span id="2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</span><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi" class="header-anchor">#</a></h3><p>前面为了加快重定位和清bss的速度,用到了ldr,str这样以4字节为单位进行读写，但是还可能导致一个问题，假设现在链接脚本没有进行用ALIGN(4)让不同的段以4字节对齐，那么就会出现访问错乱的情况。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链接脚本中.data段和.bss之间的**ALIGN(4)**去掉。那么我们会发现程序执行的时候输出的g_A&#x3D;0，为什么呢，我们明明初始化g_A&#x3D;‘A’呀？</p>
<p>打开反汇编分析：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/9.png"></p>
<p>我们的.bss段紧接着.data段后面，可知在对bss段进行清除的时候，由于我们是以4字节为单位操作的，所以我们清除g_A的时候，连带g_Char,g_Char的值也一起清除了。</p>
<p>所以data段和数据段之间添加ALIGN(4)。修改后就会发现bss段的地址以0x30000248开始了，如下图：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/10.png"></p>
<h1><span id="3-wei-zhi-wu-guan-ma">3 位置无关码</span><a href="#3-wei-zhi-wu-guan-ma" class="header-anchor">#</a></h1><h2><span id="3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</span><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</span><a href="#3-1-1-xiang-dui-tiao-zhuan" class="header-anchor">#</a></h3><p>使用b, bl跳转指令。</p>
<p>对<code>bl sdram_test</code>指令进行分析，查看反汇编, 代码段的链接地址为0x3000,0000。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/11.png"><br><code>这里的bl 3000036c不是跳转到3000036c，这个时候sdram并未初始化,那么这个物理地址是无法访问的.</code></p>
<p>为了验证，我们做另一个实验，修改连接脚本sdram.lds, 链接地址改为0x3000,0800，编译查看反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/12.png"><br><code>可以看到现在变成了bl 300003ec,但两个的机器码e1a0c00d都是一样的，机器码一样，执行的内容肯定都是一样的。 因此这里并不是跳转到显示的地址，而是跳转到: pc + offset，这个由链接器决定。</code></p>
<p>假设程序从0x30000000执行，当前指令地址：0x3000005c ,那么就是跳到0x3000036c；如果程序从0运行，当前指令地址:0x5c 跳到：0x000003ec。<br>因此：跳转到某个地址并不是由bl指令所决定，而是由当前pc值和offset偏移量决定。反汇编显示这个值只是为了方便读代码。</p>
<p>结论： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。</p>
<h3><span id="3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</span><a href="#3-1-2-jue-dui-tiao-zhuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</span><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao" class="header-anchor">#</a></h3><p>怎么写位置无关码？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用相对跳转命令 b或bl;</span><br><span class="line">重定位之前，不可使用绝对地址(因为你sdram还没初始化，没有重定位代码过去，跳转过去不就死机了)，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；</span><br><span class="line">重定位之后，使用ldr pc = xxx，跳转到/runtime地址；</span><br><span class="line">写位置无关码，其实就是不使用绝对地址</span><br></pre></td></tr></table></figure>

<p>因此，前面的重定位和清bss例子，程序使用bl命令相对跳转，程序仍在NOR&#x2F;sram执行，要想让main函数在SDRAM执行，需要修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/" data-id="clv203uf80000oglp2fbz0ixr" data-title="s3c2440裸机编程-代码重定位和清bss" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-内存控制器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T11:57:48.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul>
<li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li>
<li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul>
<li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li>
<li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul>
<li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li>
<li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li>
<li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li>
<li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li>
<li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li>
</ul>
</li>
<li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul>
<li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li>
</ul>
</li>
<li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li>
<li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul>
<li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li>
<li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li>
<li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li>
<li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li>
<li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul>
<li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li>
<li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li>
<li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li>
<li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li>
<li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li>
<li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul>
<li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li>
<li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li>
<li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li>
<li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li>
<li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li>
<li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul>
<li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul>
<li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul>
<li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li>
<li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul>
<li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul>
<li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul>
<li><a href="#7-1-1-reset">7.1.1 reset</a></li>
<li><a href="#7-1-2-du-id">7.1.2 读ID</a></li>
<li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li>
<li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li>
<li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul>
<li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li>
<li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul>
<li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li>
<li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li>
<li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul>
<li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul>
<li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li>
<li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li>
<li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li>
</ul>
</li>
<li><a href="#8-2-du-shu-ju">8.2 读数据</a></li>
<li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li>
<li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p>
<h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p>
<h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p>
<p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure>

<p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p>
<p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p>
<p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]		bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">...				...</span><br><span class="line"><span class="number">0b110</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure>

<p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p>
<h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p>
<h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p>
<h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p>
<h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p>
<h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p>
<h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p>
<h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure>

<p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure>

<p>用表格更好理解：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址</th>
<th>ROM返回数据</th>
<th>内存控制器挑选出数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000011</td>
<td>0b000011</td>
<td>编号3的存储单元中的8数据</td>
<td>编号3的存储单元中的8数据</td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000011</td>
<td>0b000001</td>
<td>编号1的存储单元中的16数据</td>
<td>根据”A0&#x3D;1”,挑出低8bit数据</td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000011</td>
<td>0b000000</td>
<td>编号0的存储单元中的32数据</td>
<td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td>
</tr>
</tbody></table>
<p>对上图的数据再次整理：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址（内存控制器转发给rom）</th>
<th>ROM返回数据</th>
<th>内存控制器组装数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000100</td>
<td>0b000100</td>
<td>地址4的一个1byte数据</td>
<td>组装地址7、6、5、4数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000101</td>
<td>地址5的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000110</td>
<td>地址6的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000111</td>
<td>地址7的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000100</td>
<td>0b00010</td>
<td>地址2的一个2byte数据</td>
<td>组装地址3、2的数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b00011</td>
<td>地址3的一个2byte数据</td>
<td></td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000100</td>
<td>0b00001</td>
<td>地址1的一个4byte数据</td>
<td>直接返回4字节数据</td>
</tr>
</tbody></table>
<p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure>

<p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure>

<p>我们知道CPU发出的是32bit地址,那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p>
<h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p>
<table>
<thead>
<tr>
<th>外设类型</th>
<th>接内存控制器的哪个片选</th>
<th>基地址</th>
<th>占用CPU的地址总线</th>
<th>地址范围(offset + size)</th>
</tr>
</thead>
<tbody><tr>
<td>nor</td>
<td>nGCS0</td>
<td>0x0000,0000</td>
<td>ADDR0-ADDR20</td>
<td>0x0000,0000 ~ 0x001f,ffff(2M)</td>
</tr>
<tr>
<td>dm9000网卡</td>
<td>nGCS4</td>
<td>0x2000,0000</td>
<td>ADDR0和ADDR2</td>
<td>0x2000,0000 ~ 0x2000,0005(5byte)</td>
</tr>
<tr>
<td>sdram</td>
<td>nGCS6</td>
<td>0x3000,0000</td>
<td>ADDR0-ADDR25</td>
<td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td>
</tr>
</tbody></table>
<p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p>
<h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p>
<h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p>
<h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p>
<p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p>
<p>引脚说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p>
<p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p>
<p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p>
<p>框图翻译成中文形式：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure>

<h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p>
<p>答：当然是<strong>拆分地址了，多次传输</strong>。</p>
<p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p>
<p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr	r0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure>

<p>然后从sdram规格书确定行列地址的数目：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure>

<p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p>
<h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p>
<h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p>
<p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">	BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">	BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">	REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">	BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">	MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">	MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// write sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">		led_test();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p>
<h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Nor</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>XIP(片上执行)</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能(擦除)</td>
<td>非常慢(5s,块太大)</td>
<td>快(3ms)</td>
</tr>
<tr>
<td>性能(写)</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>性能(读)</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>一般（容易出现位反转）</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000 ~ 100000</td>
<td>100000 ~ 1000000</td>
</tr>
<tr>
<td>接口</td>
<td>与ram类似，可直接访问任意地址</td>
<td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>容量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>常用文件系统类型</td>
<td>jffs</td>
<td>yaffs</td>
</tr>
</tbody></table>
<p>nor有以下优缺点相对nand：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure>

<h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p>
<h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p>
<p>引脚信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure>

<p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p>
<h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p>
<h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p>
<p>时序含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure>
<p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure>

<p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p>
<p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p>
<p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p>
<h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p>
<h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p>
<p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p>
<p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p>
<h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	unsigned <span class="built_in">char</span> c;</span><br><span class="line">	uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">	puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		c = getchar();</span><br><span class="line">		putchar(c);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">			bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">			puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p>
<p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p>
<p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p>
<h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p>
<p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p>
<h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p>
<p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p>
<h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p>
<h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)	</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure>

<p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p>
<table>
<thead>
<tr>
<th>cpu地址</th>
<th>nor地址</th>
</tr>
</thead>
<tbody><tr>
<td>A15~A1</td>
<td>A14~A0</td>
</tr>
</tbody></table>
<p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p>
<p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p>
<table>
<thead>
<tr>
<th>Nor Flash的操作</th>
<th>cpu的操作</th>
<th>U-BOOT上的操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写入AAH(解锁)</td>
<td>往地址AAAH写入AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写入55H(解锁)</td>
<td>往地址554H写入55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写入90H(命令)</td>
<td>往地址AAAH写入90H(命令)</td>
<td>mw.w aaa 90</td>
</tr>
<tr>
<td>读0地址得到厂家ID(C2H)</td>
<td>读0地址得到厂家ID(C2H)</td>
<td>md.w 0 1 (1:表示读一次)</td>
</tr>
<tr>
<td>读1地址得到设备ID(22DAH或225BH)</td>
<td>读2地址得到设备ID(22DAH或225BH)</td>
<td>md.w 2 1</td>
</tr>
<tr>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>mw.w 0 f0</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p>
<p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p>
<h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p>
<p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p>
<h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p>
<p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p>
<p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p>
<p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p>
<p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Nor Flash上操作cfi</th>
<th>2440上操作cfi</th>
<th>U-BOOT上操作cfi</th>
</tr>
</thead>
<tbody><tr>
<td>往55H地址写入98H（进入cfi模式）</td>
<td>往AAH地址写入98H</td>
<td>mw.w aa 98</td>
</tr>
<tr>
<td>读地址10H得到0051（’q’）</td>
<td>读地址20H得到0051</td>
<td>md.w 20 1</td>
</tr>
<tr>
<td>读地址11H得到0052(‘r’)</td>
<td>读地址22H得到0052</td>
<td>md.w 22 1</td>
</tr>
<tr>
<td>读地址12H得到0059(‘y’)</td>
<td>读地址24H得到0059</td>
<td>md.w 24 1</td>
</tr>
<tr>
<td>读地址27H得到容量</td>
<td>读地址4EH得到容量</td>
<td>md.w 4e 1</td>
</tr>
<tr>
<td>读地址1BH得到VCCmin</td>
<td>读地址36H得到VCCmin</td>
<td>md.w 36 1</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p>
<p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p>
<h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p>
<ol>
<li><p>我们在Nor Flash地址0x10000读数据</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p>
<p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash上写操作</th>
<th>2440上写操作</th>
<th>U-BOOT上写操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH(解锁)</td>
<td>往地址AAAH写AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写55H(解锁)</td>
<td>往地址554H写55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写A0H</td>
<td>往地址AAAH写A0H</td>
<td>mw.w aaa a0</td>
</tr>
<tr>
<td>往地址PA写PD</td>
<td>往地址0x100000写1234h</td>
<td>mw.w 100000 1234</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p>
</li>
</ol>
<p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p>
<p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure>

<p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p>
<h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash擦操作</th>
<th>u-boot擦操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址555H写80H</td>
<td>mw.w    aaa   80</td>
</tr>
<tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址PA写30H</td>
<td>mw.w  100000  30</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p>
<p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p>
<h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p>
<p>现在数据就变成我们的0x5678了。</p>
<p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p>
<h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p>
<h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p>
<h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p>
<p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p>
<p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p>
<h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p>
<h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p>
<h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p>
<h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> regions, i;</span><br><span class="line">	<span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line">	<span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vendor, device;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">	vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">	device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);	<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">	str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);	<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">	str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);	<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">	str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印容量 */</span></span><br><span class="line">	size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line">	<span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment">	 * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment">	 * Erase block region[i] information:</span></span><br><span class="line"><span class="comment">	 *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment">	 *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">	regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">		blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">			<span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line">			<span class="built_in">printHex</span>(block_addr);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			block_addr += block_size;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		region_info_base += <span class="number">4</span>;	<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 退出CFI模式 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p>
<p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p>
<h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p>
<p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">	pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">		pre = val;</span><br><span class="line">		val = nor_dat(addr&gt;&gt;<span class="number">1</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>);	 <span class="comment">/* erase sector */</span></span><br><span class="line">	</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>);	 <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p>
<p>可以看到擦除后这个block就是全0xffff了。</p>
<h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">		val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 烧写 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">		nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">		<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">		wait_ready(addr);</span><br><span class="line"></span><br><span class="line">		i += <span class="number">2</span>;</span><br><span class="line">		j += <span class="number">2</span>;</span><br><span class="line">		addr += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val = str[i];</span><br><span class="line">	<span class="comment">/* 烧写 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">	<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p>
<p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p>
<p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" data-id="cluwd3f3800004clpelfk4m06" data-title="s3c2440裸机编程-内存控制器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-UART体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T09:11:05.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-UART体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li>
<li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li>
<li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul>
<li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul>
<li><a href="#3-1-1-rs232">3.1.1 RS232</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li>
<li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul>
<li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul>
<li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li>
<li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul>
<li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li>
<li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li>
<li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li>
<li><a href="#5-3-puts">5.3 puts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure>
<p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">	奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">	偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">	举个栗子：</span><br><span class="line">	‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’	</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure>
<h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p>
<pre><code>1.双方约定好波特率（每一位占据的时间）
2.规定传输协议
</code></pre>
<p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p>
<pre><code>1.arm拉低uart总线1bit的时间（起始位）
2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位
</code></pre>
<p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p>
<p>TTL&#x2F;CMOS逻辑电平：</p>
<pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;
1（高电平2-5v）  表示逻辑&#39;1&#39;
</code></pre>
<p>RS-232逻辑电平：</p>
<pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;
(-12V ~ -3V) 表示逻辑&#39;1&#39;
</code></pre>
<p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p>
<p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p>
<pre><code>    arm				pc
TxD=data[0:]，    data[0:]=RxD
TxD=data[1:]，    data[1:]=RxD
...	
TxD=data[7:]，    data[7:]=RxD
</code></pre>
<h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p>
<p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p>
<h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p>
<p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p>
<p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p>
<p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p>
<h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p>
<ol>
<li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li>
<li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure>
<img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li>
</ol>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p>
<h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p>
<h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p>
<h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。
getchar就是从接受寄存器(URXH0)取出值。
无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。
</code></pre>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p>
<pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；
查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">	UTXH0 = (unsigned <span class="built_in">char</span>)c;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line">	<span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s)&#123;</span><br><span class="line">		putchar(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" data-id="cluv1rvd100001slp8vylg2v7" data-title="s3c2440裸机编程-UART体系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-时钟体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T08:49:52.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-kuang-jia">1 总线框架</a></li>
<li><a href="#2-shi-zhong-kuang-jia">2 时钟框架</a><ul>
<li><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</a></li>
<li><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</a></li>
</ul>
</li>
<li><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</a><ul>
<li><a href="#3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</a></li>
<li><a href="#3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</a><ul>
<li><a href="#3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</a></li>
<li><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</a></li>
<li><a href="#3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-zong-xian-kuang-jia">1 总线框架</span><a href="#1-zong-xian-kuang-jia" class="header-anchor">#</a></h1><p>下图是s3c2440的总线框架，其中有AHB(Advanced High performance Bus)高速总线,APB(Advanced Peripheral Bus)外围总线。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/1.jpg"></p>
<p>不同总线对应不同的时钟。</p>
<pre><code>SOC &lt;-&gt; FCLK
AHB &lt;-&gt; HCLK	
APB &lt;-&gt; PCLK 
</code></pre>
<p>其中：</p>
<p>1.使用AHB总线的有：LCD控制器、usb控制器、中断控制器、内存控制器等…<br>2.使用APB总线的有：i2c、spi、timer、gpio、adc等…具体上图。</p>
<h1><span id="2-shi-zhong-kuang-jia">2 时钟框架</span><a href="#2-shi-zhong-kuang-jia" class="header-anchor">#</a></h1><p>下图表示s3c2440 Soc的时钟框图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/2.png"></p>
<p>下面从细节上讲解时钟体系：</p>
<h2><span id="2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</span><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan" class="header-anchor">#</a></h2><p>s3c2440时钟源有2个，一个是OSC，一个是外部时钟EXTCLK,上面的时钟框图有标记，当然大家也可以查看手册“Figure 7-1. Clock Generator Block Diagram”。</p>
<p>那么如何选择是OSC还是EXTCLK呢？</p>
<p>打开原理图，OM3,OM2的引脚接地，那么OM[3,2]&#x3D;00.所以根据手册“Table 7-1. Clock Source Selection at Boot-Up”可知时钟源为OSC晶振。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/3.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/4.png"></p>
<h2><span id="2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</span><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk" class="header-anchor">#</a></h2><p>先了解下PLL, DIV</p>
<pre><code>PLL:用锁相环进行倍频
DIV:用分频器进行分频
</code></pre>
<p>如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/5.png"></p>
<p>生成的MPLL(Main PLL)和UPLL(USB PLL)，MPLL直接提供给FCLK，通过HDIVN分频给HCLK，通过PDIVN分频给PCLK，再传给下面的各个设备。<br>osc经过UPLL(USB PLL)得到UCLK。</p>
<h1><span id="3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</span><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</span><a href="#3-1-s3c2440-shi-zhong-shi-xu" class="header-anchor">#</a></h2><p>下图是2440时钟配置时序：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/6.jpg"></p>
<p>1.上电后，nRESET复位信号拉低，此时cpu还无法取指令工作。<br>2.nRESET复位信号结束后变为高电平，此时cpu开始工作。此时cpu主频FCLK&#x3D;osc。<br>3.此时可以配置PLL，经过lock time后，FCLK倍频成新的时钟。</p>
<h2><span id="3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</span><a href="#3-2-ru-he-pei-zhi-shi-zhong" class="header-anchor">#</a></h2><p>在参考手册的特性里介绍了S3C2440的工作频率，Fclk最高400MHz，Hclk最高136MHz，Pclk最高68MHz。那么 我们干脆配置FCLK：HCLK:PCLK&#x3D; 400：100：50 (MHz).</p>
<h3><span id="3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</span><a href="#3-2-1-pei-zhi-lock-time" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/7.png"></p>
<pre><code>我们取芯片手册上的推荐值。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</span><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/8.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/9.png"></p>
<p>也可参考配置表取值<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/10.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** MPLL(FCLK) = 2*m*Fin/(p*2^s)</span><br><span class="line">** 不妨取：</span><br><span class="line">** m = MDIV+8 = 92+8=100</span><br><span class="line">** p = PDIV+2 = 1+2 = 3</span><br><span class="line">** s = SDIV = 1</span><br><span class="line">** 则：</span><br><span class="line">** FCLK= 2*100*12/(3*2^1)=400M</span><br><span class="line">*/</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果也要配置了UPLL,那么先配置UPLL,要个7个NOP后才能再配置MPLL.</p>
<p>###3,配置CLKDIVN得到HCLK,PCLK<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果HDIV设置为非0，CPU的总线模式要进行改变，默认情况下FCLK &#x3D; HCLK，CPU工作在fast bus mode快速总线模式下，HDIV设置为非0后， FCLK与HCLK不再相等，要将CPU改为asynchronous bus mod异步总线模式.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15, 0, r1, c1, c0, 0         /* 读取CP15 C1寄存器 */ </span><br><span class="line">orr r1, r1, #0xc0000000           /* 设置CPU总线模式 */ </span><br><span class="line">mcr p15, 0, r1, c1, c0, 0         /* 写回CP15 C1寄存器 */</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</span><a href="#3-2-2-wan-zheng-hui-bian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">ldr r0, =0x53000000</span><br><span class="line">ldr r1, =0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15,0,r0,c1,c0,0</span><br><span class="line">orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,0,r0,c1,c0,0</span><br><span class="line"></span><br><span class="line">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span><br><span class="line"> *  m = MDIV+8 = 92+8=100</span><br><span class="line"> *  p = PDIV+2 = 1+2 = 3</span><br><span class="line"> *  s = SDIV = 1</span><br><span class="line"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span><br><span class="line"> */</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span><br><span class="line"> * 然后CPU工作于新的频率FCLK</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 设置内存: sp 栈 */</span><br><span class="line">/* 分辨是nor/nand启动</span><br><span class="line"> * 写0到0地址, 再读出来</span><br><span class="line"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line"> * 否则就是nor启动</span><br><span class="line"> */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">str r1, [r1] /* 0-&gt;[0] */ </span><br><span class="line">ldr r2, [r1] /* r2=[0] */</span><br><span class="line">cmp r1, r2</span><br><span class="line">ldr sp, =0x40000000+4096</span><br><span class="line">moveq sp, #4096  /* r1=r2， nand启动，修改栈指针=4096（此时sram对应0地址） */</span><br><span class="line">streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" data-id="cluv08wwj0000vklp90kke7lk" data-title="s3c2440裸机编程-时钟体系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-循环队列FIFO原理图解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T07:18:51.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/">循环队列FIFO原理图解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</a><ul>
<li><a href="#1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</a></li>
<li><a href="#1-2-fifo-chu-shi-hua">1.2 FIFO初始化</a></li>
<li><a href="#1-3-fifo-xiao-hui">1.3 FIFO销毁</a></li>
<li><a href="#1-4-ru-dui-lie">1.4 入队列</a></li>
<li><a href="#1-5-chu-dui-lie">1.5 出队列</a></li>
<li><a href="#1-6-fifo-pan-kong">1.6 FIFO判空</a></li>
<li><a href="#1-6-fifo-pan-man">1.6 FIFO判满</a></li>
<li><a href="#1-7-fifo-rong-liang">1.7 FIFO容量</a></li>
<li><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</a></li>
<li><a href="#1-9-fifo-bian-li">1.9 FIFO遍历</a></li>
<li><a href="#1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</a><ul>
<li><a href="#1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</a></li>
<li><a href="#1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ce-shi-yong-li">2 测试用例</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</span><a href="#1-xun-huan-dui-lie-fifo-jie-shao" class="header-anchor">#</a></h1><p>循环队列是把<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/1.png" alt="img"></p>
<p>入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针。</p>
<h2><span id="1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</span><a href="#1-1-xun-huan-dui-lie-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_HEAD(name, type)                                          \</span></span><br><span class="line">        <span class="keyword">struct</span> name &#123;                                                  \</span><br><span class="line">                <span class="keyword">struct</span> type *fifo;                                     \</span><br><span class="line">                <span class="built_in">int</span> front, tail, capacity;                             \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">front表示首元素索引</span><br><span class="line">tail表示最后一个元素索引</span><br><span class="line">capacity表示队列的长度</span><br><span class="line">struct type fifo表示该队列中的元素指针，可以指向任意结构体指针</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">struct</span> person_q &#123;                                                        \</span><br><span class="line">    <span class="keyword">struct</span> person* *fifo;                                        \</span><br><span class="line">        <span class="built_in">int</span> front, tail, capacity;                                \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-fifo-chu-shi-hua">1.2 FIFO初始化</span><a href="#1-2-fifo-chu-shi-hua" class="header-anchor">#</a></h2><p>分配一个连续的空间存储队列元素。用户自定义队列容量。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/2.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_INIT(head, _capacity) do &#123;                                  \</span></span><br><span class="line">        (head)-&gt;fifo = malloc(<span class="keyword">sizeof</span>(*(head)-&gt;fifo) * _capacity);        \</span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                               \</span><br><span class="line">        (head)-&gt;capacity = _capacity;                                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-fifo-xiao-hui">1.3 FIFO销毁</span><a href="#1-3-fifo-xiao-hui" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EXIT(head) do &#123;                                                \</span></span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                                \</span><br><span class="line">        (head)-&gt;capacity = <span class="number">0</span>;                                                \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;fifo)                                                \</span><br><span class="line">                free((head)-&gt;fifo);                                        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-ru-dui-lie">1.4 入队列</span><a href="#1-4-ru-dui-lie" class="header-anchor">#</a></h2><p>入队列就是尾元素的索引++，也就是tail++，让新元素放进队列的尾部。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PUSH(head, elm) do &#123;                                      \</span></span><br><span class="line">        <span class="keyword">if</span> (FIFO_EMPTY(head))                                          \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">0</span>;                      \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;tail = ((head)-&gt;tail == (head)-&gt;capacity - <span class="number">1</span>)  \</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;tail + <span class="number">1</span>;                        \</span><br><span class="line">        (head)-&gt;fifo[(head)-&gt;tail] = elm;                              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果队列是空的，则第一个元素入队列，front和tail索引都指向第一个元素，front &#x3D; tail &#x3D; 0;<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/3.png" alt="img"></p>
<p>其他情况入队，让tail++<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/4.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/5.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/6.png" alt="img"></p>
<h2><span id="1-5-chu-dui-lie">1.5 出队列</span><a href="#1-5-chu-dui-lie" class="header-anchor">#</a></h2><p>出队列就是让font对应的元素丢出去，font++。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_POP(head, pelm) do &#123;                                      \</span></span><br><span class="line">        *(pelm) = (head)-&gt;fifo[(head)-&gt;front];                         \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;front == (head)-&gt;tail)                             \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                     \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;front = ((head)-&gt;front == (head)-&gt;capacity - <span class="number">1</span>)\</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;front + <span class="number">1</span>;                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当front追上tail后，表示队列空了，重新设置起始点，需要将front &#x3D; tail &#x3D; -1 。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/7.png" alt="img"></p>
<p>其他情况出队，丢出front元素，让front++</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/8.png" alt="img"></p>
<h2><span id="1-6-fifo-pan-kong">1.6 FIFO判空</span><a href="#1-6-fifo-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EMPTY(head)    ((head)-&gt;front == -1)</span></span><br></pre></td></tr></table></figure>

<p>①队列初始化时，队列是空的，会让front为-1<br>②出队列时，font++, 当font追上tail表示空了，则可以重新设置起始点，令front &#x3D; tail &#x3D; -1<br>综合①②所以可以用-1判断</p>
<h2><span id="1-6-fifo-pan-man">1.6 FIFO判满</span><a href="#1-6-fifo-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FULL(head)     (((head)-&gt;front == ((head)-&gt;tail + 1)%(head)-&gt;capacity))</span></span><br></pre></td></tr></table></figure>

<p>①当front&#x3D;0时，那么tail到达capacity-1表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/9.png" alt="img"></p>
<p>②否则，tail追上front后(front &#x3D; tail + 1)表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/10.png" alt="img"></p>
<h2><span id="1-7-fifo-rong-liang">1.7 FIFO容量</span><a href="#1-7-fifo-rong-liang" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CAPACITY(head) ((head)-&gt;capacity)</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</span><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_SIZE(head)     (FIFO_EMPTY(head) ? \</span></span><br><span class="line">        <span class="number">0</span> : ((((head)-&gt;tail + (head)-&gt;capacity - (head)-&gt;front) % (head)-&gt;capacity) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>用tail - front就表示有效元素个数，不过由于循环FIFO,可能tail&lt;front,这个时候就需要取余运算，如下图:</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/11.png" alt="img"></p>
<h2><span id="1-9-fifo-bian-li">1.9 FIFO遍历</span><a href="#1-9-fifo-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FOREACH(var, head, idx) \</span></span><br><span class="line">　　<span class="keyword">for</span> (idx = (head)-&gt;front, <span class="keyword">var</span> = (head)-&gt;fifo[idx]; \</span><br><span class="line">　　　　idx &lt; (head)-&gt;front + FIFO_SIZE(head); \</span><br><span class="line">　　　　<span class="keyword">var</span> = (head)-&gt;fifo[++idx % (head)-&gt;capacity])</span><br></pre></td></tr></table></figure>

<h2><span id="1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</span><a href="#1-10-dui-lie-yuan-su-huo-qu" class="header-anchor">#</a></h2><h3><span id="1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</span><a href="#1-10-1-di-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_FRONT(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;front])</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</span><a href="#1-10-2-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_TAIL(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;tail])</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-ce-shi-yong-li">2 测试用例</span><a href="#2-ce-shi-yong-li" class="header-anchor">#</a></h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;fifo.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="keyword">struct</span> person_q person1_queue;</span><br><span class="line"><span class="keyword">struct</span> person_q person2_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">        FIFO_INIT(&amp;person1_queue, <span class="number">1</span>);</span><br><span class="line">        FIFO_INIT(&amp;person2_queue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person2_queue) != <span class="number">5</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">20</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1001</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person1_queue, person_a);<span class="comment">//把person_a这个结构体指针元素丢进FIFO,</span></span><br><span class="line">        <span class="comment">//后面对它pop出来又能拿到它，所以不用担心地址弄丢导致无法释放.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_FULL(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">30</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1002</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 3 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 4 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person1_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">20</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 5 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">40</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1003</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        FIFO_GET_FRONT(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_FRONT NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_GET_TAIL(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_TAIL NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 6 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 7 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_arr[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                person_arr[i] = malloc(<span class="keyword">sizeof</span>(*person_arr[<span class="number">0</span>]));</span><br><span class="line">                person_arr[i]-&gt;age = i;</span><br><span class="line">                person_arr[i]-&gt;id = <span class="number">1000</span> + i;</span><br><span class="line">                FIFO_PUSH(&amp;person2_queue, person_arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_EMPTY(&amp;person2_queue) &#123;</span><br><span class="line">                FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">                printf( <span class="string">&quot;age:%d, id:%d.\n&quot;</span>, person_a-&gt;age, person_a-&gt;id);</span><br><span class="line">                free(person_a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_EXIT(&amp;person1_queue);</span><br><span class="line">        FIFO_EXIT(&amp;person2_queue);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/12.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/" data-id="cluuyksbq0000eklpchefgzwv" data-title="循环队列FIFO原理图解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tailq队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/tailq%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T06:15:23.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/tailq%E9%98%9F%E5%88%97/">tailq队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tailq-dui-lie-jie-shao">1 tailq队列介绍</a><ul>
<li><a href="#1-1-queue-jian-jie">1.1 queue 简介</a></li>
<li><a href="#1-2-slist">1.2 SLIST</a></li>
<li><a href="#1-3-stailq">1.3 STAILQ</a></li>
<li><a href="#1-4-list">1.4 LIST</a></li>
<li><a href="#1-5-tailq">1.5 TAILQ</a></li>
<li><a href="#1-6-circleq">1.6 CIRCLEQ</a></li>
</ul>
</li>
<li><a href="#2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</a><ul>
<li><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</a></li>
<li><a href="#2-2-dui-lie-tou">2.2 队列头</a></li>
<li><a href="#2-3-chu-shi-hua">2.3 初始化</a></li>
<li><a href="#2-4-cha-ru-yuan-su">2.4 插入元素</a><ul>
<li><a href="#2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</a></li>
<li><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</a></li>
</ul>
</li>
<li><a href="#2-5-shan-chu-yuan-su">2.5 删除元素</a></li>
<li><a href="#2-6-di-yi-ge-yuan-su">2.6 第一个元素</a></li>
<li><a href="#2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</a></li>
<li><a href="#2-8-xia-yi-ge-yuan-su">2.8 下一个元素</a></li>
<li><a href="#2-9-qian-yi-ge-yuan-su">2.9 前一个元素</a></li>
<li><a href="#2-10-pan-kong">2.10 判空</a></li>
<li><a href="#2-11-pan-man">2.11 判满</a></li>
<li><a href="#2-12-bian-li">2.12 遍历</a></li>
<li><a href="#2-13-dao-bian-li">2.13 倒遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tailq-dui-lie-jie-shao">1 tailq队列介绍</span><a href="#1-tailq-dui-lie-jie-shao" class="header-anchor">#</a></h1><p>TAILQ队列是FreeBSD内核中的一种队列数据结构，主要是把队列头抽象成一个单独的结构体。它实现在Linux queue中。</p>
<h2><span id="1-1-queue-jian-jie">1.1 queue 简介</span><a href="#1-1-queue-jian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/1.png" alt="img"></p>
<p>可以include &lt;sys&#x2F;queue.h&gt;后直接使用。queue 分为 SLIST、LIST、STAILQ、TAILQ、CIRCLEQ 。queue 的所有源码都是宏定义，因此完全包含于queue.h当中，无需编译为库文件。</p>
<p>可以从toolchains或者系统路径&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;queue.h找到实现。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/2.png" alt="img"></p>
<h2><span id="1-2-slist">1.2 SLIST</span><a href="#1-2-slist" class="header-anchor">#</a></h2><p>SLIST 是Singly-linked List 的缩写，意为单向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/3.png" alt="img"></p>
<h2><span id="1-3-stailq">1.3 STAILQ</span><a href="#1-3-stailq" class="header-anchor">#</a></h2><p>单向有尾链表，节点n为尾节点。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/4.png" alt="img"></p>
<h2><span id="1-4-list">1.4 LIST</span><a href="#1-4-list" class="header-anchor">#</a></h2><p>双向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/5.png" alt="img"></p>
<h2><span id="1-5-tailq">1.5 TAILQ</span><a href="#1-5-tailq" class="header-anchor">#</a></h2><p>双向有尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/6.png" alt="img"></p>
<h2><span id="1-6-circleq">1.6 CIRCLEQ</span><a href="#1-6-circleq" class="header-anchor">#</a></h2><p>双向循环链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/7.png" alt="img"></p>
<h1><span id="2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</span><a href="#2-tailq-shi-xian-yuan-li-tu-jie" class="header-anchor">#</a></h1><p>双向有尾链表,也就是有一个表头和表尾，表头指向节点1和尾节点。</p>
<h2><span id="2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</span><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                                   \</span></span><br><span class="line"><span class="keyword">struct</span> &#123;                                                                    \</span><br><span class="line">    <span class="keyword">struct</span> type *tqe_next;      <span class="comment">/* next element */</span>                          \</span><br><span class="line">    <span class="keyword">struct</span> type **tqe_prev;     <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tqe_next是指向下一个元素的指针，tqe_prev是指向前一个元素的tqe_next地址，对它解引用后</span></span><br><span class="line"><span class="comment">（*tqe_priv）指向当前元素的地址。*/</span></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">struct</span> item&#123;</span><br><span class="line">　　<span class="built_in">int</span> val;</span><br><span class="line">　　TAILQ_ENTRY(item) entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/8.png" alt="img"></p>
<h2><span id="2-2-dui-lie-tou">2.2 队列头</span><a href="#2-2-dui-lie-tou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    TAILQ_HEAD(name, type)                        \</span></span><br><span class="line"><span class="keyword">struct</span> name &#123;                                \</span><br><span class="line">    <span class="keyword">struct</span> type *tqh_first;    <span class="comment">/* first element */</span>            \</span><br><span class="line">    <span class="keyword">struct</span> type **tqh_last;    <span class="comment">/* addr of last next element */</span>        \</span><br><span class="line">&#125;</span><br><span class="line">STAILQ_HEAD(my_tailq,  tailq_entry) queue_head;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/9.png" alt="img"></p>
<p>先看TAILQ_HEAD:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqh_first为队列第一个元素的地址；</span><br><span class="line">tqh_last为最后一个元素tqe_next的地址；</span><br><span class="line">tqh_last指向的指针为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>再看TAILQ_ENTRY:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqe_next为队列下一个元素的地址；</span><br><span class="line">tqe_prev为队列上一个元素tqe_next的地址；</span><br><span class="line">tqe_prev指向的指针为当前元素的地址；</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-chu-shi-hua">2.3 初始化</span><a href="#2-3-chu-shi-hua" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/10.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head) do &#123;                                               \</span></span><br><span class="line">    (head)-&gt;tqh_first = NULL;                                               \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-cha-ru-yuan-su">2.4 插入元素</span><a href="#2-4-cha-ru-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;                  \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = NULL;                                 \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;                     \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                                    \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</span><a href="#2-4-1-cha-ru-1-ge-yuan-su" class="header-anchor">#</a></h3><ol>
<li><p>将要插入的node加入到尾部：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/11.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next = NULL;                         </span><br><span class="line">(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;<span class="comment">//将要插入的节点prev指向最后一个node </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>更新头节点:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/12.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);          </span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</span><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su" class="header-anchor">#</a></h3><p>同理多个元素时尾插。</p>
<ol>
<li><p>将要插入的node加入到尾部:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/13.png" alt="img"></p>
</li>
<li><p>更新头节点:</p>
</li>
</ol>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/14.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);           <span class="comment">//尾节点指向新的尾巴</span></span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; <span class="comment">//head的last指向新的尾巴</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-shan-chu-yuan-su">2.5 删除元素</span><a href="#2-5-shan-chu-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;                       \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                          \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;      \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                           \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/15.png"></p>
<p>我们现在要把val&#x3D;3的elm删除：<br>elm中的tqe_next不为空，表示elm不是尾节点。那么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<p>这2句执行完后:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/16.png" alt="img"></p>
<p>然后free掉该elm,</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/17.png" alt="img"></p>
<p>同理再删除val&#x3D;2的elm：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/18.png" alt="img"></p>
<p>然后free掉该elm，</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/19.png" alt="img"></p>
<p>最后如果要把val&#x3D;4的elm删除：</p>
<p>elm中的tqe_next为空，表示elm是尾节点。那么，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;               <span class="comment">//让head的last指向新的尾巴        </span></span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;    <span class="comment">//让elm的前一个node的next指向该elm的后一个node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/20.png" alt="img"></p>
<h2><span id="2-6-di-yi-ge-yuan-su">2.6 第一个元素</span><a href="#2-6-di-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</span><a href="#2-7-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_LAST(head, headname) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这个实现看起来有点绕，我们先做一个实验:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> _QUEUE_ITEM &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    TAILQ_ENTRY(QUEUE_ITEM) entries;</span><br><span class="line">&#125;QUEUE_ITEM;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(TAIL_QUEUE, QUEUE_ITEM) queue_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    QUEUE_ITEM *item[<span class="number">5</span>];</span><br><span class="line">    TAILQ_INIT(&amp;queue_head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        item[i] = (<span class="keyword">struct</span> QUEUE_ITEM*)malloc(<span class="keyword">sizeof</span>(QUEUE_ITEM));</span><br><span class="line">        item[i]-&gt;<span class="keyword">value</span> = i;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;queue_head, item[i], entries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;item[%d]: item:%#x, next:%#x,&amp;next:%#x, prev:%#x, *prev:%#x\n&quot;</span>,</span><br><span class="line">　　　　　　　　i, item[i], item[i]-&gt;entries.tqe_next, &amp;(item[i]-&gt;entries.tqe_next), item[i]-&gt;entries.tqe_prev, *(item[i]-&gt;entries.tqe_prev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;queue_head:%#x, first:%#x, last:%#x\n&quot;</span>, &amp;queue_head, queue_head.tqh_first, queue_head.tqh_last);</span><br><span class="line">    printf(<span class="string">&quot;last item:%p\n&quot;</span>, TAILQ_LAST(&amp;queue_head, TAIL_QUEUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/21.png" alt="img"></p>
<p>可以用图形来描述:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/22.png" alt="img"></p>
<p><code>TAILQ_LAST(&amp;queue_head, TAIL_QUEUE);</code>这句话展开:<br><code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code></p>
<p><code>((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))</code>这句话,我们把地址0x601060代入进去得0x602098，即为：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/23.png" alt="img"></p>
<p>然后<code>(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last)</code>得到0x602078,<br>认真的同学此时已经发现，此时对应倒数第二元素的next地址，</p>
<p>最后取<code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code>得到0x602090,这就是最后一个元素的地址。</p>
<p><strong>总结：这里核心其实就是把最后一个元素的entries成员当成head指针来使用</strong>。因为本质上最后一个节点的TAILQ_ENTRY域和TAILQ_HEAD是同样的结构。</p>
<h2><span id="2-8-xia-yi-ge-yuan-su">2.8 下一个元素</span><a href="#2-8-xia-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_NEXT(elm, field)                ((elm)-&gt;field.tqe_next)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-9-qian-yi-ge-yuan-su">2.9 前一个元素</span><a href="#2-9-qian-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_PREV(elm, headname, field) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这里和TAILQ_LAST原理一样，将0x602090代入进去得:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/24.png" alt="img"><br>然后对*(0x602058)得0x602070,即得到了前一个node的地址。</p>
<h2><span id="2-10-pan-kong">2.10 判空</span><a href="#2-10-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_EMPTY(head)                ((head)-&gt;tqh_first == NULL)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-11-pan-man">2.11 判满</span><a href="#2-11-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-12-bian-li">2.12 遍历</span><a href="#2-12-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH(var, head, field)                                        \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = ((head)-&gt;tqh_first);                                \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = ((<span class="keyword">var</span>)-&gt;field.tqe_next))</span><br></pre></td></tr></table></figure>

<h2><span id="2-13-dao-bian-li">2.13 倒遍历</span><a href="#2-13-dao-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH_REVERSE(var, head, headname, field)                \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last));        \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((<span class="keyword">var</span>)-&gt;field.tqe_prev))-&gt;tqh_last)))</span><br></pre></td></tr></table></figure>

<p>当看懂之前的<strong>最后一个元素</strong>原理时，倒遍历的实现是不是超级简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/tailq%E9%98%9F%E5%88%97/" data-id="cluuupffs0000fklp0spu437f" data-title="tailq队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-union和bit-field巧妙进行寄存器位操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2024-04-04T10:15:23.000Z" itemprop="datePublished">2024-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/">union和bit_field巧妙进行寄存器位操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</a></li>
<li><a href="#2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</a><ul>
<li><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</a></li>
<li><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</a></li>
<li><a href="#2-3-du-qu-ji-cun-qi">2.3 读取寄存器</a></li>
<li><a href="#2-4-xie-ji-cun-qi">2.4 写寄存器</a></li>
<li><a href="#2-5-wei-du-qu">2.5 位读取</a></li>
<li><a href="#2-6-wei-xie-ru">2.6 位写入</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</span><a href="#1-union-jie-gou-qu-fen-da-xiao-duan" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_bits(stc, field)(&#123;stc.raw = 0x12345678; stc.bits.field;&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> raw;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_a : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_b : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_c : <span class="number">5</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_d : <span class="number">3</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_e : <span class="number">1</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">num</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#x, %#x, %#x, %#x, %#x\n&quot;</span>,</span><br><span class="line">        read_bits(num, bit_a),</span><br><span class="line">        read_bits(num, bit_b),</span><br><span class="line">        read_bits(num, bit_c),</span><br><span class="line">        read_bits(num, bit_d),</span><br><span class="line">        read_bits(num, bit_e));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1-1.png" alt="img"></p>
<p>这样的结果，原理如下图:</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="img"><br>那么从这里可以看出，低地址对应低字节， 因此我们的运行机器是Little Endian。</p>
<p>那么bit_a&#x3D;0x78; bit_b&#x3D;0x56; bit_c等于0x34取低5位，也就是0x14; bit_d 等于0x34取高3位，也就是0x1； bit_e等于0x12取最低位，也就是0。</p>
<p>由于这里的num是union结构，因此对.raw进行操作，那么也就等于对.bits也进行了操作，那么返回bit field是不是和寄存器的位操作很类似。下面详细介绍如何用union和bit field巧妙进行寄存器位操作。</p>
<h1><span id="2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</span><a href="#2-ji-cun-qi-de-wei-cao-zuo" class="header-anchor">#</a></h1><p>举个例子，这是mipi-rx DPHY的寄存器的部分截取：</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/2.png" alt="img"></p>
<p>那么我们可以对该module进行结构定义如下：(当然如果觉得手动去定义麻烦，网上有专门的python工具可以对excel到寄存器定义的转换)<br><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/3.png" alt="img"></p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/4.png" alt="img"></p>
<p>这里对该module的每个寄存器都定义成union。</p>
<h2><span id="2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</span><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃define <span class="title function_">offsetof</span><span class="params">(<span class="type">struct_t</span>,member)</span> <span class="params">( (<span class="type">int</span>)&amp;((<span class="type">struct_t</span> *)<span class="number">0</span>)-&gt;member )</span></span><br></pre></td></tr></table></figure>

<p>(struct_t <em>)0)，可以看到这里*<em>把一个0地址转换成一个指针，它表示一个结构体指针变量，并且是值&#x3D;0的指针</em></em>, 那么访问它的成员，成员的地址自然就会往后递增，因此该成员的地址那么就等于该成员的偏移量。</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么offsetof(struct student, id)就为100 + 4&#x3D;104，同理.name的offsetof为0，.age的offsetof为100，.sex的offsetof为108。</p>
<h2><span id="2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</span><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti" class="header-anchor">#</a></h2><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/5.png" alt="img"></p>
<p>该函数实现位于include&#x2F;linux&#x2F;kernel.h， 源码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span>(<span class="params"> ((type *</span>)0)-&gt;member ) *__mptr</span> = (ptr);    \</span><br><span class="line">    (type *)( (<span class="built_in">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个结构体成员指针mptr指向该成员，</li>
<li>用该成员指针减去该成员在结构体中的偏移量，不就是该结构体的起始地址</li>
</ol>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;.name=<span class="string">&quot;robin&quot;</span>, .age=<span class="number">18</span>, .id=<span class="number">123456</span>, .sex=<span class="string">&#x27;M&#x27;</span>&#125;, *pstu;</span><br><span class="line">pstu = container_of(&amp;stu.sex, <span class="keyword">struct</span> student, sex);</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-du-qu-ji-cun-qi">2.3 读取寄存器</span><a href="#2-3-du-qu-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_read(addr) readl((void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPHY_BA_ADDR (0x0300b000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFST(_BLK_T, _REG)       ((uint64_t)&amp;(((struct _BLK_T *)0)-&gt;_REG))//this is same with offsetof</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_REG(_BA, _BLK_T, _REG) \</span></span><br><span class="line">(_reg_read(_BA+_OFST(_BLK_T, _REG)))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RD_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了read。</p>
<h2><span id="2-4-xie-ji-cun-qi">2.4 写寄存器</span><a href="#2-4-xie-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_write(addr, data) writel(data, (void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR_REG(_BA, _BLK_T, _REG, _V) \</span></span><br><span class="line">                (_reg_write((_BA+_OFST(_BLK_T, _REG)), _V))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WR_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, <span class="number">0x3333ffff</span>);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了write, write的数据为0x3333ffff。</p>
<h2><span id="2-5-wei-du-qu">2.5 位读取</span><a href="#2-5-wei-du-qu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RD_BITS(_BA, _BLK_T, _REG, _FLD) \</span></span><br><span class="line">        (&#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD;\</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RD_BITS</span>(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，typeof表示对该成员取数据结构类型，然后把该寄存器里的值读出来，最后返回bit[31:16]。</p>
<h2><span id="2-6-wei-xie-ru">2.6 位写入</span><a href="#2-6-wei-xie-ru" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WR_BITS(_BA, _BLK_T, _REG, _FLD, _V) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD = _V;\</span><br><span class="line">                _reg_write((_BA+_OFST(_BLK_T, _REG)), _r.raw);\</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">WR_BITS(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1, <span class="number">0x1111</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，然后把该寄存器里的值读出来, 再把该寄存器的bit[31:16]写入0x1111。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/" data-id="clul3rpio0000n4ufea6ge1mg" data-title="union和bit_field巧妙进行寄存器位操作" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-卷帘快门RollingShutter与全局快门GlobalShutter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/" class="article-date">
  <time class="dt-published" datetime="2024-04-03T07:56:37.000Z" itemprop="datePublished">2024-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/">卷帘快门RollingShutter与全局快门GlobalShutter</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-global-shutter">1 Global Shutter</a></li>
<li><a href="#2-rolling-shutter">2 Rolling Shutter</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-global-shutter">1 Global Shutter</span><a href="#1-global-shutter" class="header-anchor">#</a></h1><p>通过整幅场景在同一时间曝光实现的。Sensor所有像素点同时收集光线，同时曝光。即在曝光开始的时候，Sensor开始收集光线；在曝光结束的时候，光线收集电路被切断。CCD就是Global shutter工作方式。所有像元同时曝光</p>
<h1><span id="2-rolling-shutter">2 Rolling Shutter</span><a href="#2-rolling-shutter" class="header-anchor">#</a></h1><p>与Global shutter不同，它是通过Sensor逐行曝光的方式实现的。在曝光开始的时候，Sensor逐行扫描逐行进行曝光，直至所有像素点都被曝光。</p>
<p>对比优缺点:</p>
<p>Global shutter： 曝光时间更短，但会增加读出噪声；</p>
<p>Rolling shutter：可以达到更高的帧速，噪声小，但是运动场景会产生果冻效应。</p>
<p>卷帘快门与全局快门大致原理如下图：</p>
<p align="left">&nbsp;<img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/1.gif" alt width="292" height="165" loading="lazy"></p>

<p>卷帘快门：</p>
<p><img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/2.gif" alt width="409" height="187" loading="lazy"></p>

<p><strong>适用性：</strong></p>
<table>
<thead>
<tr>
<th><strong>Global shutter</strong></th>
<th><strong>rolling shutter</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>曝光时间短的应用（如</strong><strong>&lt;500μs****）</strong></td>
<td><strong>曝光时间长（如大于<strong><strong>500μs</strong></strong>）的应用可以有更低的噪声和帧速</strong></td>
</tr>
<tr>
<td><strong>快速移动物体拍适合</strong></td>
<td><strong>静止的物体适合</strong></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/" data-id="clujiw5do0000hclpho7ib3u5" data-title="卷帘快门RollingShutter与全局快门GlobalShutter" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 15px;">arm裸机</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 20px;">linux嵌入式环境搭建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 10px;">mipi图像处理</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC</a>
          </li>
        
          <li>
            <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断</a>
          </li>
        
          <li>
            <a href="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss</a>
          </li>
        
          <li>
            <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>
          </li>
        
          <li>
            <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-UART体系</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>