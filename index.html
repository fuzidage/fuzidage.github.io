<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-IIO子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:59:20.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-IIO子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-iio-zi-xi-tong">1 引入IIO 子系统</a></li>
<li><a href="#2-iio-zi-xi-tong-qu-dong-kuang-jia">2 IIO 子系统驱动框架</a></li>
<li><a href="#3-shu-ju-jie-gou">3 数据结构</a><ul>
<li><a href="#3-1-iio-dev-iio-she-bei">3.1 iio_dev-iio设备</a><ul>
<li><a href="#3-1-1-iio-buffer-setup-ops">3.1.1 iio_buffer_setup_ops</a></li>
</ul>
</li>
<li><a href="#3-2-iio-info-shu-xing-he-han-shu-shi-xian">3.2 iio_info-属性和函数实现</a></li>
<li><a href="#3-3-iio-chan-spec-tong-dao-shu-xing">3.3 iio_chan_spec-通道属性</a></li>
<li><a href="#3-4-iio-trigger-hong-fa-shu-ju-cai-ji">3.4 iio_trigger-触发数据采集</a><ul>
<li><a href="#3-4-1-iio-trigger-ops">3.4.1 iio_trigger_ops</a></li>
</ul>
</li>
<li><a href="#3-5-iio-buffer-bao-cun-cai-ji-dao-de-shu-ju">3.5 iio_buffer-保存采集到的数据</a></li>
</ul>
</li>
<li><a href="#4-api">4 API</a><ul>
<li><a href="#4-1-iio-dev-zhu-ce-yu-zhu-xiao">4.1 iio_dev 注册与注销</a><ul>
<li><a href="#4-1-1-iio-device-register-sysfs-guo-cheng">4.1.1 <code>iio_device_register_sysfs</code>过程</a></li>
</ul>
</li>
<li><a href="#4-2-iio-init-zi-xi-tong-de-chu-shi-hua">4.2 iio_init-子系统的初始化</a></li>
</ul>
</li>
<li><a href="#5-iio-shi-yan-cao-zuo-icm20608">5 iio实验-操作ICM20608</a><ul>
<li><a href="#5-1-shi-neng-nei-he-iio">5.1 使能内核 IIO</a></li>
<li><a href="#5-2-qu-dong-dai-ma-fen-xi">5.2 驱动代码分析</a><ul>
<li><a href="#5-2-0-yuan-ma">5.2.0 源码</a></li>
<li><a href="#5-2-1-probe">5.2.1 probe</a></li>
<li><a href="#5-2-2-icm20608-read-raw">5.2.2 icm20608_read_raw</a><ul>
<li><a href="#5-2-2-1-du-raw-shu-ju">5.2.2.1 读raw数据</a></li>
<li><a href="#5-2-2-2-du-liang-cheng">5.2.2.2 读量程</a></li>
<li><a href="#5-2-2-3-du-offset">5.2.2.3 读offset</a></li>
</ul>
</li>
<li><a href="#5-2-3-icm20608-write-raw">5.2.3 icm20608_write_raw</a><ul>
<li><a href="#5-2-3-1-pei-zhi-liang-cheng">5.2.3.1 配置量程</a></li>
<li><a href="#5-2-3-2-pei-zhi-xiao-zhun-zhi">5.2.3.2 配置校准值</a></li>
</ul>
</li>
<li><a href="#5-2-4-icm20608-write-raw-get-fmt">5.2.4 icm20608_write_raw_get_fmt</a></li>
</ul>
</li>
<li><a href="#5-3-ce-shi">5.3 测试</a><ul>
<li><a href="#5-3-1-tong-dao-wen-jian-ming-ming-fang-shi">5.3.1 通道文件命名方式</a></li>
<li><a href="#5-3-2-du-qu-raw-shu-ju">5.3.2 读取raw数据</a></li>
<li><a href="#5-3-3-bian-xie-ying-yong-cheng-xu-ce-shi">5.3.3 编写应用程序测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-iio-shi-yan-cao-zuo-vf610-adc-c">6 IIO实验-操作vf610_adc.c</a><ul>
<li><a href="#6-1-dts-miao-shu">6.1 dts描述</a></li>
<li><a href="#6-2-shi-neng-adc-qu-dong">6.2 使能 ADC 驱动</a></li>
<li><a href="#6-3-qu-dong-dai-ma-fen-xi">6.3 驱动代码分析</a><ul>
<li><a href="#6-3-1-probe">6.3.1 probe</a></li>
<li><a href="#6-3-2-vf610-read-raw">6.3.2 vf610_read_raw</a></li>
</ul>
</li>
<li><a href="#6-4-yong-hu-tai-ce-shi">6.4 用户态测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-iio-zi-xi-tong">1 引入IIO 子系统</span><a href="#1-yin-ru-iio-zi-xi-tong" class="header-anchor">#</a></h1><p>随着手机、物联网、工业物联网和可穿戴设备的爆发，传感器的需求越来越多。比如手机或者手环里面的加速度计、光传感器、陀螺仪、气压计、磁力计等，这些传感器本质上都是 ADC。这些传感器对外通过 IIC 或者 SPI 接口来发送ADC转换后的原始数据。</p>
<p>Linux 内核为了管理这些日益增多的 ADC 类传感器，特地推出了 IIO 子系统。</p>
<p><code>IIO </code>全称是<code> Industrial I/O</code>，翻译过来就是工业 I&#x2F;O，常用的陀螺仪、加速度计、电压&#x2F;电流测量芯片、光照传感器、压力传感器等内部都是有个 ADC，内部 ADC 将原始的 模拟数据转换为数字量，然后通过其他的通信接口，比如 IIC、SPI 等传输给 SOC。</p>
<p>因此，当使用的传感器本质是 ADC器件的时候，可以优先考虑使用 IIO 驱动框架。</p>
<h1><span id="2-iio-zi-xi-tong-qu-dong-kuang-jia">2 IIO 子系统驱动框架</span><a href="#2-iio-zi-xi-tong-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<ul>
<li><strong>IIO sysfs</strong>对用户空间提供IIO设备访问和配置。</li>
<li><strong>IIO Core</strong>提供IIO设备、<code>IIO Trigger、IIO Buffer</code>分配、初始化、注册等工作。<ul>
<li><code>industrialio-core.c</code></li>
<li><code>industrialio-buffer.c</code></li>
<li><code>industrialio-event.c</code></li>
</ul>
</li>
<li><strong>IIO Driver</strong>不同IIO设备的驱动程序。</li>
</ul>
<h1><span id="3-shu-ju-jie-gou">3 数据结构</span><a href="#3-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="3-1-iio-dev-iio-she-bei">3.1 iio_dev-iio设备</span><a href="#3-1-iio-dev-iio-she-bei" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> &#123;</span></span><br><span class="line">      <span class="type">int</span> id;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">module</span>                   *<span class="title">driver_module</span>;</span></span><br><span class="line">      <span class="type">int</span> modes;<span class="comment">//设备支持的模式</span></span><br><span class="line">      <span class="type">int</span> currentmode;<span class="comment">//表示设备当前模式</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">device</span>                   <span class="title">dev</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_interface</span>      *<span class="title">event_interface</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span>               *<span class="title">buffer</span>;</span><span class="comment">//缓冲区</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>                <span class="title">buffer_list</span>;</span><span class="comment">//当前匹配的缓冲区列表</span></span><br><span class="line">      <span class="type">int</span> scan_bytes; <span class="comment">//捕获到，并且提供给缓冲区的字节数</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>                    <span class="title">mlock</span>;</span></span><br><span class="line">      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>             *available_scan_masks;<span class="comment">//扫描位掩码，使用触发缓冲区的时候可以通过</span></span><br><span class="line"><span class="comment">//设置掩码来确定使能哪些通道，使能以后的通道会将捕获到的数据发送到 IIO 缓冲区</span></span><br><span class="line">      <span class="type">unsigned</span> masklength;</span><br><span class="line">      <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>             *active_scan_mask;<span class="comment">//缓冲区已经开启的通道掩码</span></span><br><span class="line">      <span class="type">bool</span> scan_timestamp; </span><br><span class="line">      <span class="type">unsigned</span> scan_index_timestamp;<span class="comment">//扫描时间戳，如果使能以后会将捕获时间戳放到缓冲区里面</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span>              *<span class="title">trig</span>;</span><span class="comment">// IIO 设备当前触发器</span></span><br><span class="line">      <span class="type">bool</span> trig_readonly;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>            *<span class="title">pollfunc</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_poll_func</span>            *<span class="title">pollfunc_event</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">const</span>      *<span class="title">channels</span>;</span><span class="comment">//IIO设备通道列表</span></span><br><span class="line">      <span class="type">int</span> num_channels;<span class="comment">//IIO设备通道数</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>                <span class="title">channel_attr_list</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>          <span class="title">chan_attr_group</span>;</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span>                      *name;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span>           *<span class="title">info</span>;</span></span><br><span class="line">      <span class="type">clockid_t</span> clock_id;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>                    <span class="title">info_exist_lock</span>;</span></span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span>       *<span class="title">setup_ops</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span>                     <span class="title">chrdev</span>;</span></span><br><span class="line">&#125;;<span class="comment">//iio_dev用于描述一个具体IIO设备, include/linux/iio/iio.h</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Device operating modes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDIO_DIRECT_MODE		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDIO_BUFFER_TRIGGERED		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDIO_BUFFER_SOFTWARE		0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDIO_BUFFER_HARDWARE		0x08</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDIO_ALL_BUFFER_MODES					\</span></span><br><span class="line">	(INDIO_BUFFER_TRIGGERED | INDIO_BUFFER_HARDWARE | INDIO_BUFFER_SOFTWARE)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INDIO_DIRECT_MODE</td>
<td>提供 sysfs 接口</td>
</tr>
<tr>
<td>INDIO_BUFFER_TRIGGERED</td>
<td>支持硬件缓冲触发</td>
</tr>
<tr>
<td>INDIO_BUFFER_SOFTWARE</td>
<td>支持软件缓冲触发</td>
</tr>
<tr>
<td>INDIO_BUFFER_HARDWARE</td>
<td>支持硬件缓冲区</td>
</tr>
</tbody></table>
<h3><span id="3-1-1-iio-buffer-setup-ops">3.1.1 iio_buffer_setup_ops</span><a href="#3-1-1-iio-buffer-setup-ops" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_setup_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*preenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之前调用 */</span></span><br><span class="line">	<span class="type">int</span> (*postenable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区使能之后调用 */</span></span><br><span class="line">	<span class="type">int</span> (*predisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之前调用 */</span></span><br><span class="line">	<span class="type">int</span> (*postdisable)(<span class="keyword">struct</span> iio_dev *); <span class="comment">/* 缓冲区禁用之后调用 */</span></span><br><span class="line">	<span class="type">bool</span> (*validate_scan_mask)(<span class="keyword">struct</span> iio_dev *indio_dev, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *scan_mask); <span class="comment">/* 检查扫描掩码是否有效 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在使能或禁用缓冲区的时候会调用这些函数。</p>
<h2><span id="3-2-iio-info-shu-xing-he-han-shu-shi-xian">3.2 iio_info-属性和函数实现</span><a href="#3-2-iio-info-shu-xing-he-han-shu-shi-xian" class="header-anchor">#</a></h2><p><code>iio_info</code>包含每个iio设备的属性和具体实现函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>			*<span class="title">driver_module</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>		*<span class="title">event_attrs</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>	*<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*read_raw)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">			<span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line">			<span class="type">int</span> *val,</span><br><span class="line">			<span class="type">int</span> *val2,</span><br><span class="line">			<span class="type">long</span> mask);<span class="comment">//最终读写传感器设备内部数据的操作函数</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*read_raw_multi)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">			<span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line">			<span class="type">int</span> max_len,</span><br><span class="line">			<span class="type">int</span> *vals,</span><br><span class="line">			<span class="type">int</span> *val_len,</span><br><span class="line">			<span class="type">long</span> mask);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*write_raw)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">			 <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line">			 <span class="type">int</span> val,</span><br><span class="line">			 <span class="type">int</span> val2,</span><br><span class="line">			 <span class="type">long</span> mask);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*write_raw_get_fmt)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">			 <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span><br><span class="line">			 <span class="type">long</span> mask);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*read_event_config)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				 <span class="type">const</span> <span class="keyword">struct</span> iio_chan_spec *chan,</span><br><span class="line">				 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">				 <span class="keyword">enum</span> iio_event_direction dir);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*write_event_config)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				  <span class="type">const</span> <span class="keyword">struct</span> iio_chan_spec *chan,</span><br><span class="line">				  <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">				  <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">				  <span class="type">int</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*read_event_value)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				<span class="type">const</span> <span class="keyword">struct</span> iio_chan_spec *chan,</span><br><span class="line">				<span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">				<span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">				<span class="keyword">enum</span> iio_event_info info, <span class="type">int</span> *val, <span class="type">int</span> *val2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*write_event_value)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				 <span class="type">const</span> <span class="keyword">struct</span> iio_chan_spec *chan,</span><br><span class="line">				 <span class="keyword">enum</span> iio_event_type type,</span><br><span class="line">				 <span class="keyword">enum</span> iio_event_direction dir,</span><br><span class="line">				 <span class="keyword">enum</span> iio_event_info info, <span class="type">int</span> val, <span class="type">int</span> val2);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*validate_trigger)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				<span class="keyword">struct</span> iio_trigger *trig);</span><br><span class="line">	<span class="type">int</span> (*update_scan_mode)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> *scan_mask);</span><br><span class="line">	<span class="type">int</span> (*debugfs_reg_access)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				  <span class="type">unsigned</span> reg, <span class="type">unsigned</span> writeval,</span><br><span class="line">				  <span class="type">unsigned</span> *readval);</span><br><span class="line">	<span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">			<span class="type">const</span> <span class="keyword">struct</span> of_phandle_args *iiospec);</span><br><span class="line">	<span class="type">int</span> (*hwfifo_set_watermark)(<span class="keyword">struct</span> iio_dev *indio_dev, <span class="type">unsigned</span> val);</span><br><span class="line">	<span class="type">int</span> (*hwfifo_flush_to_buffer)(<span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">				      <span class="type">unsigned</span> count);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>indio_dev</strong>：需要读写的 IIO 设备。</p>
<p><strong>chan</strong>：需要读取的通道。</p>
<p><strong>val，val2</strong>：对于 <code>read_raw </code>来说 val 和 val2 这两个就是应用程序从内核空间读取到数据，一般就是传感器指定通道值，或者传感器的量程、分辨率等。对于 <code>write_raw</code> 来说就是应用程序向设备写入的数据。val 和 val2 共同组成具体值，val 是整数部分，val2 是小数部分。Linux内核无法支持浮点运算，因此val2是放大后的值。扩大的倍数我们不能随便设置，而是要使用 Linux 定义的倍数，Linux 内核里面定义的数据扩大倍数：</p>
<table>
<thead>
<tr>
<th>组合宏</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IIO_VAL_INT</code></td>
<td>整数值，没有小数。比如 5000，那么就是 val&#x3D;5000，不 需要设置 val2</td>
</tr>
<tr>
<td><code>IIO_VAL_INT_PLUS_MICRO</code></td>
<td>小数部分扩大 1000000 倍，比如 <code>1.00236</code>，此时 val&#x3D;1， val2&#x3D;2360</td>
</tr>
<tr>
<td><code>IIO_VAL_INT_PLUS_NANO</code></td>
<td>小数部分扩大 1000000000 倍，同样是 <code>1.00236</code>，此时 val&#x3D;1，val2&#x3D;2360000</td>
</tr>
<tr>
<td><code>IIO_VAL_INT_PLUS_MICRO_DB</code></td>
<td>dB 数据，和<code>IIO_VAL_INT_PLUS_MICRO</code>数据形式一 样，只是在后面添加 db</td>
</tr>
<tr>
<td><code>IIO_VAL_INT_MULTIPLE</code></td>
<td>多个整数值，比如一次要传回 6 个整数值，那么 val 和 val2就不够用了。此宏主要用于<code>iio_info</code>的<code>read_raw_multi </code>函数</td>
</tr>
<tr>
<td><code>IIO_VAL_FRACTIONAL</code></td>
<td>分数值，也就是 <code>val/val2</code>。比如 val&#x3D;1，val2&#x3D;4，那么实际 值就是 <code>1/4</code></td>
</tr>
<tr>
<td><code>IIO_VAL_FRACTIONAL_LOG2</code></td>
<td>值为 <code>val&gt;&gt;val2</code>，也就是 val 右移 val2 位。比如 val&#x3D;25600， val2&#x3D;4 ， 那 么 真 正 的 值 就 是 25600 右 移 4 位 ， <code>25600&gt;&gt;4=1600</code></td>
</tr>
</tbody></table>
<p><strong>mask</strong>：掩码，用于指定我们读取的是什么数据，比如 <code>ICM20608</code> 这样的传感器，他既有原 始的测量数据，比如 <code>X,Y,Z </code>轴的陀螺仪、加速度计等，也有测量范围值，或者分辨率。比如加 速度计测量范围设置为<code>±16g</code>，那么分辨率就是 <code>32/65536≈0.000488</code>，我们只有读出原始值以及 对应的分辨率(量程)，才能计算出真实的重力加速度。此时就有两种数据值：传感器原始值、分辨率。Linux 内核使用 <code>IIO_CHAN_INFO_RAW</code> 和<code> IIO_CHAN_INFO_SCALE</code> 这两个宏来表示原 始值以及分辨率，这两个宏就是掩码。</p>
<p><code>write_raw_get_fmt </code>用于设置用户空间向内核空间写入的数据格式，<code>write_raw_get_fmt</code>函数决定了 <code>wtite_raw </code>函数中 val 和 val2 的意义，也就是表中的组合 形式。比如我们需要在应用程序中设置<code> ICM20608</code> 加速度计的量程为<code>±8g</code>，那么分辨率就是<code>16/65536≈0.000244</code>，我们在 <code>write_raw_get_fmt</code> 函数里面设置加速度计的数据格式为<code> IIO_VAL_INT_PLUS_MICRO</code>。那么我们在应用程序里面向指定的文件写入<code> 0.000244</code> 以后，最 终传递给内核驱动的就是 <code>0.000244*1000000=244</code>。也就是 <code>write_raw</code> 函数的 val 参数为 0，val2 参数为 244。</p>
<h2><span id="3-3-iio-chan-spec-tong-dao-shu-xing">3.3 iio_chan_spec-通道属性</span><a href="#3-3-iio-chan-spec-tong-dao-shu-xing" class="header-anchor">#</a></h2><p>一个IIO设备可能有多个通道，每个通道由<code>struct iio_chan_spec</code>表示。比如一个 ADC 芯片支持 8 路采集，那 么这个 ADC 就有 8 个通道。的 <code>ICM20608</code>六轴传感器，可以输出三轴陀螺仪<code>(X、Y、Z)</code>、三轴加速度计<code>(X、Y、Z)</code>和一路温度，共7路数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span>    <span class="title">type</span>;</span><span class="comment">//表示channel类型，电压、电流、加速度、电磁等等。</span></span><br><span class="line">    <span class="type">int</span>            channel;</span><br><span class="line">    <span class="type">int</span>            channel2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>        address;<span class="comment">//该通道对应的芯片数据寄存器地址</span></span><br><span class="line">    <span class="type">int</span>            scan_index;<span class="comment">//当使用触发缓冲区的时候，scan_index 是扫描索引</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">char</span>    sign;</span><br><span class="line">        u8    realbits;</span><br><span class="line">        u8    storagebits;</span><br><span class="line">        u8    shift;</span><br><span class="line">        u8    repeat;</span><br><span class="line">        <span class="class"><span class="keyword">enum</span> <span class="title">iio_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    &#125; scan_type;<span class="comment">//扫描数据的存储格式</span></span><br><span class="line">    <span class="type">long</span>            info_mask_separate;</span><br><span class="line">    <span class="type">long</span>            info_mask_separate_available;</span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_type;<span class="comment">//标记导出的信息由相同类型的通道共享,比如</span></span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_type_available;</span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_dir;</span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_dir_available;</span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_all;</span><br><span class="line">    <span class="type">long</span>            info_mask_shared_by_all_available;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_event_spec</span> *<span class="title">event_spec</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        num_event_specs;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec_ext_info</span> *<span class="title">ext_info</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>        *extend_name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>        *datasheet_name;</span><br><span class="line">    <span class="type">unsigned</span>        modified:<span class="number">1</span>;<span class="comment">//modified 为 1 的时候，channel2 为通道修饰符</span></span><br><span class="line">    <span class="type">unsigned</span>        indexed:<span class="number">1</span>;<span class="comment">// indexed 为 1时候，channel 为通道索引</span></span><br><span class="line">    <span class="type">unsigned</span>        output:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span>        differential:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">iio_chan_type</span> &#123;</span></span><br><span class="line">	IIO_VOLTAGE, <span class="comment">/* 电压类型 */</span></span><br><span class="line">	IIO_CURRENT, <span class="comment">/* 电流类型 */</span></span><br><span class="line">	IIO_POWER, <span class="comment">/* 功率类型 */</span></span><br><span class="line">	IIO_ACCEL, <span class="comment">/* 加速度类型 */</span></span><br><span class="line">	IIO_ANGL_VEL, <span class="comment">/* 角度类型(陀螺仪) */</span></span><br><span class="line">	IIO_MAGN, <span class="comment">/* 电磁类型(磁力计) */</span></span><br><span class="line">	IIO_LIGHT, <span class="comment">/* 灯光类型 */</span></span><br><span class="line">	IIO_INTENSITY, <span class="comment">/* 强度类型(光强传感器) */</span></span><br><span class="line">	IIO_PROXIMITY, <span class="comment">/* 接近类型(接近传感器) */</span></span><br><span class="line">	IIO_TEMP, <span class="comment">/* 温度类型 */</span></span><br><span class="line">	IIO_INCLI, <span class="comment">/* 倾角类型(倾角测量传感器) */</span></span><br><span class="line">	IIO_ROT, <span class="comment">/* 旋转角度类型 */</span></span><br><span class="line">	IIO_ANGL, <span class="comment">/* 转动角度类型(电机旋转角度测量传感器) */</span></span><br><span class="line">	IIO_TIMESTAMP, <span class="comment">/* 时间戳类型 */</span></span><br><span class="line">	IIO_CAPACITANCE, <span class="comment">/* 电容类型 */</span></span><br><span class="line">	IIO_ALTVOLTAGE, <span class="comment">/* 频率类型 */</span></span><br><span class="line">	IIO_CCT, <span class="comment">/* 笔者暂时未知的类型 */</span></span><br><span class="line">	IIO_PRESSURE, <span class="comment">/* 压力类型 */</span></span><br><span class="line">	IIO_HUMIDITYRELATIVE, <span class="comment">/* 湿度类型 */</span></span><br><span class="line">	IIO_ACTIVITY, <span class="comment">/* 活动类型(计步传感器) */</span></span><br><span class="line">	IIO_STEPS, <span class="comment">/* 步数类型 */</span></span><br><span class="line">	IIO_ENERGY, <span class="comment">/* 能量类型(卡路里) */</span></span><br><span class="line">	IIO_DISTANCE, <span class="comment">/* 距离类型 */</span></span><br><span class="line">	IIO_VELOCITY, <span class="comment">/* 速度类型 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果是 ICM20608 这样的多轴传感器，那么就是复合类型了，陀螺仪部分是 <code>IIO_ANGL_VEL </code>类型，加速度计部分是<code>IIO_ACCEL</code>，温度部分就是<code> IIO_TEMP</code>。</p>
<p>当成员变量 <code>modified 为 1 </code>的时候，<code>channel2 为通道修饰符</code>。Linux 内核给出了 可用的<code>通道修饰符</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">iio_modifier</span> &#123;</span></span><br><span class="line">	IIO_NO_MOD,</span><br><span class="line">	IIO_MOD_X, <span class="comment">/* X 轴 */</span></span><br><span class="line">	IIO_MOD_Y, <span class="comment">/* Y 轴 */</span></span><br><span class="line">	IIO_MOD_Z, <span class="comment">/* Z 轴 */</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如 <code>ICM20608 </code>的加速度计部分，类型设置为<code> IIO_ACCEL</code>，<code>X、Y、Z </code>这三个轴就用<code> channel2</code> 的<code>通道修饰符</code>来区分.</p>
<p><code>scan_type</code> 各个成员变量:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scan_type.sign：如果为‘u’表示数据为无符号类型，为‘s’的话为有符号类型。</span><br><span class="line"></span><br><span class="line">scan_type.realbits：数据真实的有效位数，比如很多传感器说的 10 位 ADC，其真实有效数</span><br><span class="line">据就是 10 位。</span><br><span class="line"></span><br><span class="line">scan_type.storagebits：存储位数，有效位数+填充位。比如有些传感器 ADC 是 12 位的，</span><br><span class="line">那么我们存储的话肯定要用到 2 个字节，也就是 16 位，这 16 位就是存储位数。</span><br><span class="line"></span><br><span class="line">scan_type.shift:右移位数，也就是存储位数和有效位数不一致的时候，需要右移的位数，这</span><br><span class="line">个参数不总是需要，一切以实际芯片的数据手册位数。</span><br><span class="line"></span><br><span class="line">scan_type.repeat：实际或存储位的重复数量。</span><br><span class="line">scan_type.endianness:数据的大小端模式，可设置为 IIO_CPU、IIO_BE(大端)或 IIO_LE(小</span><br><span class="line">端)。</span><br></pre></td></tr></table></figure>

<p><code>info_mask_separate</code> 将属性标记为特定于此通</p>
<p><code>info_mask_shared_by_type </code>标记导出的信息由相同类型的通道共享。<code>X、Y、Z </code>轴他们的 type 都 是<code> IIO_ACCEL</code>，也就是类型相同。而这三个轴的分辨率(量程)是一样的，那么这3个通道<code>info_mask_shared_by_type</code> 中使能<code>IO_CHAN_INFO_SCALE</code> 这个属性，表示 这三个通道的分辨率是共用的，这样在<code>sysfs</code>下就会只生成一个描述分辨率的文件，这三个通道 都可以使用这一个分辨率文件。</p>
<p><code>info_mask_shared_by_dir </code>标记某些导出的信息由相同方向的通道共享。</p>
<p><code>info_mask_shared_by_all </code>表设计某些信息所有的通道共享，无论这些通道的类 型、方向如何，全部共享。</p>
<p><code>output </code>表示为输出通道。</p>
<p><code>differential </code>表示为差分通道。</p>
<h2><span id="3-4-iio-trigger-hong-fa-shu-ju-cai-ji">3.4 iio_trigger-触发数据采集</span><a href="#3-4-iio-trigger-hong-fa-shu-ju-cai-ji" class="header-anchor">#</a></h2><p>触发器是基于某种信号来触发数据采集，比如：数据就绪中断；周期性中断；用户空间sysfs读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span>    *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>            *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">int</span>                id;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>            *name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>            <span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">alloc_list</span>;</span></span><br><span class="line">    <span class="type">atomic_t</span>            use_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>            <span class="title">subirq_chip</span>;</span></span><br><span class="line">    <span class="type">int</span>                subirq_base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iio_subirq</span> <span class="title">subirqs</span>[<span class="title">CONFIG_IIO_CONSUMERS_PER_TRIGGER</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pool[BITS_TO_LONGS(CONFIG_IIO_CONSUMERS_PER_TRIGGER)];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>            <span class="title">pool_lock</span>;</span></span><br><span class="line">    <span class="type">bool</span>                attached_own_device;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-1-iio-trigger-ops">3.4.1 iio_trigger_ops</span><a href="#3-4-1-iio-trigger-ops" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_trigger_ops</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*set_trigger_state)(<span class="keyword">struct</span> iio_trigger *trig, <span class="type">bool</span> state);--设置触发器状态，打开或关闭。</span><br><span class="line">    <span class="type">int</span> (*try_reenable)(<span class="keyword">struct</span> iio_trigger *trig);--当用户计数为<span class="number">0</span>时，重新使能接口。</span><br><span class="line">    <span class="type">int</span> (*validate_device)(<span class="keyword">struct</span> iio_trigger *trig,</span><br><span class="line">                   <span class="keyword">struct</span> iio_dev *indio_dev);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-5-iio-buffer-bao-cun-cai-ji-dao-de-shu-ju">3.5 iio_buffer-保存采集到的数据</span><a href="#3-5-iio-buffer-bao-cun-cai-ji-dao-de-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer</span> &#123;</span></span><br><span class="line">	<span class="type">int</span>					length;</span><br><span class="line">	<span class="type">int</span>					bytes_per_datum;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>			*<span class="title">scan_el_attrs</span>;</span></span><br><span class="line">	<span class="type">long</span>					*scan_mask;</span><br><span class="line">	<span class="type">bool</span>					scan_timestamp;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_buffer_access_funcs</span>	*<span class="title">access</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>			<span class="title">scan_el_dev_attr_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>			<span class="title">buffer_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span>			<span class="title">scan_el_group</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span>			pollq;</span><br><span class="line">	<span class="type">bool</span>					stufftoread;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>			**<span class="title">attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>			<span class="title">demux_list</span>;</span></span><br><span class="line">	<span class="type">void</span>					*demux_bounce;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>			<span class="title">buffer_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>				<span class="title">ref</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>				watermark;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1><span id="4-api">4 API</span><a href="#4-api" class="header-anchor">#</a></h1><h2><span id="4-1-iio-dev-zhu-ce-yu-zhu-xiao">4.1 iio_dev 注册与注销</span><a href="#4-1-iio-dev-zhu-ce-yu-zhu-xiao" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iio_dev *<span class="title function_">iio_device_alloc</span><span class="params">(<span class="type">int</span> sizeof_priv)</span><span class="comment">//申请 iio_dev</span></span><br><span class="line"><span class="keyword">struct</span> iio_dev *<span class="title function_">devm_iio_device_alloc</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">int</span> sizeof_priv)</span><span class="comment">//申请 iio_dev</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iio_device_free</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">devm_iio_device_free</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iio_dev *indio_dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">iio_device_register</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//注册iio设备</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">iio_device_unregister</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span><span class="comment">//注销iio设备</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iio_device_register(indio_dev) \</span></span><br><span class="line"><span class="meta">    __iio_device_register((indio_dev), THIS_MODULE)</span></span><br><span class="line"><span class="type">int</span> __<span class="title function_">iio_device_register</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev, <span class="keyword">struct</span> module *this_mod)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">iio_device_unregister</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> devm_iio_device_register(dev, indio_dev) \</span></span><br><span class="line"><span class="meta">    __devm_iio_device_register((dev), (indio_dev), THIS_MODULE);</span></span><br><span class="line"><span class="type">int</span> __devm_iio_device_register(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iio_dev *indio_dev,</span><br><span class="line">                   <span class="keyword">struct</span> module *this_mod);</span><br><span class="line"><span class="type">void</span> <span class="title function_">devm_iio_device_unregister</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> iio_dev *indio_dev)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">devm_iio_device_register/iio_device_register</span><br><span class="line">　　-&gt;__iio_device_register</span><br><span class="line">　　　　-&gt;iio_check_unique_scan_index</span><br><span class="line">　　　　-&gt;iio_device_register_debugfs</span><br><span class="line">　　　　　　-&gt;debugfs_create_file<span class="comment">//创建direct_reg_access调试节点，通过此节点可以直接读写寄存器。</span></span><br><span class="line">    		<span class="comment">//iio_debugfs_reg_fops调用IIO设备struct iio_dev-&gt;info-&gt;debugfs_reg_access()函数。</span></span><br></pre></td></tr></table></figure>

<h3><span id="4-1-1-iio-device-register-sysfs-guo-cheng">4.1.1 <code>iio_device_register_sysfs</code>过程</span><a href="#4-1-1-iio-device-register-sysfs-guo-cheng" class="header-anchor">#</a></h3><p><code>devm_iio_device_register</code>过程中会调用<code>iio_device_register_sysfs</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　-&gt;iio_buffer_alloc_sysfs_and_mask</span><br><span class="line">　　　　-&gt;iio_device_register_sysfs<span class="comment">//创建adc属性和每个channel属性。</span></span><br><span class="line">　　　　-&gt;cdev_init<span class="comment">//初始化cdev设备，操作函数集为iio_buffer_fileops。</span></span><br><span class="line">　　　　-&gt;cdev_device_add<span class="comment">//创建cdev设备/dev/iio:deviceX。</span></span><br></pre></td></tr></table></figure>

<p>展开<code>iio_device_register_sysfs</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iio_device_register_sysfs</span><br><span class="line">        ---&gt;  iio_device_add_channel_sysfs</span><br><span class="line">                ---&gt;  iio_device_add_info_mask_type</span><br><span class="line">                        ---&gt;  __iio_add_chan_devattr</span><br><span class="line">                                ---&gt;  __iio_device_attr_init</span><br></pre></td></tr></table></figure>

<p>其中在<code>iio_device_add_info_mask_type</code>中设置了读写回调函数，比如<code>cat in_voltage0_input</code>就会调用回调函数<code>iio_read_channel_info</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __iio_device_attr_init()</span><br><span class="line">&#123;...</span><br><span class="line">		<span class="keyword">case</span> IIO_SEPARATE:</span><br><span class="line">			<span class="keyword">if</span> (chan-&gt;indexed)</span><br><span class="line">				name = kasprintf(GFP_KERNEL, <span class="string">&quot;%s_%s%d_%s&quot;</span>,</span><br><span class="line">						    iio_direction[chan-&gt;output],</span><br><span class="line">						    iio_chan_type_name_spec[chan-&gt;type],</span><br><span class="line">						    chan-&gt;channel,</span><br><span class="line">						    full_postfix);</span><br><span class="line">    <span class="comment">//in_voltage0_input</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">      ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式为<code>%s_%s%d_%s&quot;</code>， 对应了<code>in_voltage0_input</code>，其中<code>iio_direction、iio_chan_type_name_spec、iio_chan_info_postfix</code>对应的值为<code> &quot;in&quot; 、&quot;voltage&quot; 、&quot;input&quot;</code></p>
<p>如下代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_direction[] = &#123;</span><br><span class="line">	[<span class="number">0</span>] = <span class="string">&quot;in&quot;</span>,</span><br><span class="line">	[<span class="number">1</span>] = <span class="string">&quot;out&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_chan_type_name_spec[] = &#123;</span><br><span class="line">	[IIO_VOLTAGE] = <span class="string">&quot;voltage&quot;</span>,</span><br><span class="line">	[IIO_CURRENT] = <span class="string">&quot;current&quot;</span>,</span><br><span class="line">	[IIO_POWER] = <span class="string">&quot;power&quot;</span>,</span><br><span class="line">	[IIO_ACCEL] = <span class="string">&quot;accel&quot;</span>,</span><br><span class="line">	<span class="comment">// 以下省略</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* relies on pairs of these shared then separate */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_chan_info_postfix[] = &#123;</span><br><span class="line">	[IIO_CHAN_INFO_RAW] = <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_PROCESSED] = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_SCALE] = <span class="string">&quot;scale&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_OFFSET] = <span class="string">&quot;offset&quot;</span>,</span><br><span class="line">    <span class="comment">// 以下省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="4-2-iio-init-zi-xi-tong-de-chu-shi-hua">4.2 iio_init-子系统的初始化</span><a href="#4-2-iio-init-zi-xi-tong-de-chu-shi-hua" class="header-anchor">#</a></h2><p>IIO子系统初始化包括：</p>
<ul>
<li>iio总线注册</li>
<li>分配IIO字符设备号</li>
<li>创建IIO设备<code>debugfs</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iio_init</span><br><span class="line">　　-&gt;bus_register<span class="comment">//注册iio bus。</span></span><br><span class="line">　　-&gt;alloc_chrdev_region<span class="comment">//创建iio cdev设备编号iio_devt。</span></span><br><span class="line">　　-&gt;debugfs_create_dir<span class="comment">//创建/sys/kernel/debug/iio调试目录iio_debugfs_dentry。</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-iio-shi-yan-cao-zuo-icm20608">5 iio实验-操作ICM20608</span><a href="#5-iio-shi-yan-cao-zuo-icm20608" class="header-anchor">#</a></h1><h2><span id="5-1-shi-neng-nei-he-iio">5.1  使能内核 IIO</span><a href="#5-1-shi-neng-nei-he-iio" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line"> -&gt; Industrial I/O <span class="title function_">support</span> <span class="params">(IIO [=y])</span> </span><br><span class="line"> 	-&gt; [*]Enable buffer support within IIO <span class="comment">//选中</span></span><br><span class="line"> 	-&gt; &lt;*&gt;Industrial I/O buffering based on kfifo <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<h2><span id="5-2-qu-dong-dai-ma-fen-xi">5.2 驱动代码分析</span><a href="#5-2-qu-dong-dai-ma-fen-xi" class="header-anchor">#</a></h2><h3><span id="5-2-0-yuan-ma">5.2.0 源码</span><a href="#5-2-0-yuan-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;icm20608reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/regmap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/iio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/sysfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/trigger.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/triggered_buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/iio/trigger_consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unaligned/be_byteshift.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_NAME	<span class="string">&quot;icm20608&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_TEMP_OFFSET	     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_TEMP_SCALE		     326800000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CHAN(_type, _channel2, _index)                \</span></span><br><span class="line"><span class="meta">	&#123;                                                          \</span></span><br><span class="line"><span class="meta">		.type = _type,                                        \</span></span><br><span class="line"><span class="meta">		.modified = 1,                                        \</span></span><br><span class="line"><span class="meta">		.channel2 = _channel2,                                \</span></span><br><span class="line"><span class="meta">		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \</span></span><br><span class="line"><span class="meta">		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |	      \</span></span><br><span class="line"><span class="meta">				      BIT(IIO_CHAN_INFO_CALIBBIAS),   \</span></span><br><span class="line"><span class="meta">		.scan_index = _index,                                 \</span></span><br><span class="line"><span class="meta">		.scan_type = &#123;                                        \</span></span><br><span class="line"><span class="meta">				.sign = <span class="string">&#x27;s&#x27;</span>,                          \</span></span><br><span class="line"><span class="meta">				.realbits = 16,                       \</span></span><br><span class="line"><span class="meta">				.storagebits = 16,                    \</span></span><br><span class="line"><span class="meta">				.shift = 0,                           \</span></span><br><span class="line"><span class="meta">				.endianness = IIO_BE,                 \</span></span><br><span class="line"><span class="meta">			     &#125;,                                       \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * ICM20608的扫描元素，3轴加速度计、</span></span><br><span class="line"><span class="comment"> * 3轴陀螺仪、1路温度传感器，1路时间戳 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">inv_icm20608_scan</span> &#123;</span></span><br><span class="line">	INV_ICM20608_SCAN_ACCL_X,</span><br><span class="line">	INV_ICM20608_SCAN_ACCL_Y,</span><br><span class="line">	INV_ICM20608_SCAN_ACCL_Z,</span><br><span class="line">	INV_ICM20608_SCAN_TEMP,</span><br><span class="line">	INV_ICM20608_SCAN_GYRO_X,</span><br><span class="line">	INV_ICM20608_SCAN_GYRO_Y,</span><br><span class="line">	INV_ICM20608_SCAN_GYRO_Z,</span><br><span class="line">	INV_ICM20608_SCAN_TIMESTAMP,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span>;</span>		<span class="comment">/* spi设备 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *<span class="title">regmap</span>;</span>				<span class="comment">/* regmap */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap_config</span> <span class="title">regmap_config</span>;</span>	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icm20608陀螺仪分辨率，对应250、500、1000、2000，计算方法：</span></span><br><span class="line"><span class="comment"> * 以正负250度量程为例，500/2^16=0.007629，扩大1000000倍，就是7629</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gyro_scale_icm20608[] = &#123;<span class="number">7629</span>, <span class="number">15258</span>, <span class="number">30517</span>, <span class="number">61035</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * icm20608加速度计分辨率，对应2、4、8、16 计算方法：</span></span><br><span class="line"><span class="comment"> * 以正负2g量程为例，4/2^16=0.000061035，扩大1000000000倍，就是61035</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> accel_scale_icm20608[] = &#123;<span class="number">61035</span>, <span class="number">122070</span>, <span class="number">244140</span>, <span class="number">488281</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icm20608通道，1路温度通道，3路陀螺仪，3路加速度计</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_chan_spec</span> <span class="title">icm20608_channels</span>[] =</span> &#123;</span><br><span class="line">	<span class="comment">/* 温度通道 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		.type = IIO_TEMP,</span><br><span class="line">		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)</span><br><span class="line">				| BIT(IIO_CHAN_INFO_OFFSET)</span><br><span class="line">				| BIT(IIO_CHAN_INFO_SCALE),</span><br><span class="line">		.scan_index = INV_ICM20608_SCAN_TEMP,</span><br><span class="line">		.scan_type = &#123;</span><br><span class="line">				.sign = <span class="string">&#x27;s&#x27;</span>,</span><br><span class="line">				.realbits = <span class="number">16</span>,</span><br><span class="line">				.storagebits = <span class="number">16</span>,</span><br><span class="line">				.shift = <span class="number">0</span>,</span><br><span class="line">				.endianness = IIO_BE,</span><br><span class="line">			     &#125;,</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_ICM20608_SCAN_GYRO_X),	<span class="comment">/* 陀螺仪X轴 */</span></span><br><span class="line">	ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_ICM20608_SCAN_GYRO_Y),	<span class="comment">/* 陀螺仪Y轴 */</span></span><br><span class="line">	ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_ICM20608_SCAN_GYRO_Z),	<span class="comment">/* 陀螺仪Z轴 */</span></span><br><span class="line"></span><br><span class="line">	ICM20608_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_ICM20608_SCAN_ACCL_Y),	<span class="comment">/* 加速度X轴 */</span></span><br><span class="line">	ICM20608_CHAN(IIO_ACCEL, IIO_MOD_X, INV_ICM20608_SCAN_ACCL_X),	<span class="comment">/* 加速度Y轴 */</span></span><br><span class="line">	ICM20608_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_ICM20608_SCAN_ACCL_Z),	<span class="comment">/* 加速度Z轴 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 ret;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">	ret = regmap_read(dev-&gt;regmap, reg, &amp;data);</span><br><span class="line">	<span class="keyword">return</span> (u8)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">icm20608_write_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span></span><br><span class="line">&#123;</span><br><span class="line">	regmap_write(dev-&gt;regmap,  reg, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_reginit</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	u8 value = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	icm20608_write_onereg(dev, ICM20_PWR_MGMT_1, <span class="number">0x80</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	icm20608_write_onereg(dev, ICM20_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	value = icm20608_read_onereg(dev, ICM20_WHO_AM_I);</span><br><span class="line">	printk(<span class="string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);	</span><br><span class="line"></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_SMPLRT_DIV, <span class="number">0x00</span>); <span class="comment">/* 输出速率是内部采样率*/</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_GYRO_CONFIG, <span class="number">0x18</span>); <span class="comment">/* 陀螺仪±2000dps量程 */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); <span class="comment">/* 加速度计±16G量程 */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_CONFIG, <span class="number">0x04</span>); <span class="comment">/* 陀螺仪低通滤波BW=20Hz */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); <span class="comment">/* 加速度计低通滤波BW=21.2Hz */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_PWR_MGMT_2, <span class="number">0x00</span>); <span class="comment">/* 打开加速度计和陀螺仪所有轴 */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_LP_MODE_CFG, <span class="number">0x00</span>); <span class="comment">/* 关闭低功耗 */</span></span><br><span class="line">	icm20608_write_onereg(dev, ICM20_INT_ENABLE, <span class="number">0x01</span>);	<span class="comment">/* 使能FIFO溢出以及数据就绪中断	*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description  	: 设置ICM20608传感器，可以用于陀螺仪、加速度计设置</span></span><br><span class="line"><span class="comment">  * @param - dev	: icm20608设备 </span></span><br><span class="line"><span class="comment">  * @param - reg  	: 要设置的通道寄存器首地址。</span></span><br><span class="line"><span class="comment">  * @param - anix  	: 要设置的通道，比如X，Y，Z。</span></span><br><span class="line"><span class="comment">  * @param - val  	: 要设置的值。</span></span><br><span class="line"><span class="comment">  * @return			: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_sensor_set</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">int</span> reg,</span></span><br><span class="line"><span class="params">				<span class="type">int</span> axis, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ind, result;</span><br><span class="line">	__be16 d = cpu_to_be16(val);</span><br><span class="line"></span><br><span class="line">	ind = (axis - IIO_MOD_X) * <span class="number">2</span>;</span><br><span class="line">	result = regmap_bulk_write(dev-&gt;regmap, reg + ind, (u8 *)&amp;d, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description  	: 读取ICM20608传感器数据，可以用于陀螺仪、加速度计、温度的读取</span></span><br><span class="line"><span class="comment">  * @param - dev	: icm20608设备 </span></span><br><span class="line"><span class="comment">  * @param - reg  	: 要读取的通道寄存器首地址。</span></span><br><span class="line"><span class="comment">  * @param - anix  	: 需要读取的通道，比如X，Y，Z。</span></span><br><span class="line"><span class="comment">  * @param - val  	: 保存读取到的值。</span></span><br><span class="line"><span class="comment">  * @return			: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_sensor_show</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">int</span> reg,</span></span><br><span class="line"><span class="params">				   <span class="type">int</span> axis, <span class="type">int</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ind, result;</span><br><span class="line">	__be16 d;</span><br><span class="line"></span><br><span class="line">	ind = (axis - IIO_MOD_X) * <span class="number">2</span>;</span><br><span class="line">	result = regmap_bulk_read(dev-&gt;regmap, reg + ind, (u8 *)&amp;d, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	*val = (<span class="type">short</span>)be16_to_cpup(&amp;d);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> IIO_VAL_INT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description  		: 读取ICM20608陀螺仪、加速度计、温度通道值</span></span><br><span class="line"><span class="comment">  * @param - indio_dev	: iio设备 </span></span><br><span class="line"><span class="comment">  * @param - chan  		: 通道。</span></span><br><span class="line"><span class="comment">  * @param - val  		: 保存读取到的通道值。</span></span><br><span class="line"><span class="comment">  * @return				: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_channel_data</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params">					 <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span></span><br><span class="line"><span class="params">					 <span class="type">int</span> *val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> iio_priv(indio_dev);</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">	<span class="keyword">case</span> IIO_ANGL_VEL:	<span class="comment">/* 读取陀螺仪数据, channel2为X、Y、Z轴*/</span></span><br><span class="line">		ret = icm20608_sensor_show(dev, ICM20_GYRO_XOUT_H, chan-&gt;channel2, val);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IIO_ACCEL:		<span class="comment">/* 读取加速度计数据,channel2为X、Y、Z轴 */</span></span><br><span class="line">		ret = icm20608_sensor_show(dev, ICM20_ACCEL_XOUT_H, chan-&gt;channel2, val);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IIO_TEMP:		<span class="comment">/* 读取温度 */</span></span><br><span class="line">		ret = icm20608_sensor_show(dev, ICM20_TEMP_OUT_H, IIO_MOD_X, val);  </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description  	: 设置ICM20608的陀螺仪计量程(分辨率)</span></span><br><span class="line"><span class="comment">  * @param - dev	: icm20608设备</span></span><br><span class="line"><span class="comment">  * @param - val   	: 量程(分辨率值)。</span></span><br><span class="line"><span class="comment">  * @return			: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_write_gyro_scale</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, i;</span><br><span class="line">	u8 d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(gyro_scale_icm20608); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (gyro_scale_icm20608[i] == val) &#123;</span><br><span class="line">			d = (i &lt;&lt; <span class="number">3</span>);</span><br><span class="line">			result = regmap_write(dev-&gt;regmap, ICM20_GYRO_CONFIG, d);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description  	: 设置ICM20608的加速度计量程(分辨率)</span></span><br><span class="line"><span class="comment">  * @param - dev	: icm20608设备</span></span><br><span class="line"><span class="comment">  * @param - val   	: 量程(分辨率值)。</span></span><br><span class="line"><span class="comment">  * @return			: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_write_accel_scale</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, <span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> result, i;</span><br><span class="line">	u8 d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ARRAY_SIZE(accel_scale_icm20608); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (accel_scale_icm20608[i] == val) &#123;</span><br><span class="line">			d = (i &lt;&lt; <span class="number">3</span>);</span><br><span class="line">			result = regmap_write(dev-&gt;regmap, ICM20_ACCEL_CONFIG, d);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     	: 读函数，当读取sysfs中的文件的时候最终此函数会执行，此函数</span></span><br><span class="line"><span class="comment">  * 					：里面会从传感器里面读取各种数据，然后上传给应用。</span></span><br><span class="line"><span class="comment">  * @param - indio_dev	: iio_dev</span></span><br><span class="line"><span class="comment">  * @param - chan   	: 通道</span></span><br><span class="line"><span class="comment">  * @param - val   		: 读取的值，如果是小数值的话，val是整数部分。</span></span><br><span class="line"><span class="comment">  * @param - val2   	: 读取的值，如果是小数值的话，val2是小数部分。</span></span><br><span class="line"><span class="comment">  * @param - mask   	: 掩码。</span></span><br><span class="line"><span class="comment">  * @return				: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params">			   <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span></span><br><span class="line"><span class="params">			   <span class="type">int</span> *val, <span class="type">int</span> *val2, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> iio_priv(indio_dev);</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> regdata = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (mask) &#123;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_RAW:	<span class="comment">/* 读取ICM20608加速度计、陀螺仪、温度传感器原始值 */</span></span><br><span class="line">		mutex_lock(&amp;dev-&gt;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line">		ret = icm20608_read_channel_data(indio_dev, chan, val); <span class="comment">/* 读取通道值 */</span></span><br><span class="line">		mutex_unlock(&amp;dev-&gt;lock);<span class="comment">/* 释放锁 */</span></span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_SCALE:</span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_ANGL_VEL:</span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			regdata = (icm20608_read_onereg(dev, ICM20_GYRO_CONFIG) &amp; <span class="number">0X18</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">			*val  = <span class="number">0</span>;</span><br><span class="line">			*val2 = gyro_scale_icm20608[regdata];</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT_PLUS_MICRO;	<span class="comment">/* 值为val+val2/1000000 */</span></span><br><span class="line">		<span class="keyword">case</span> IIO_ACCEL:</span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			regdata = (icm20608_read_onereg(dev, ICM20_ACCEL_CONFIG) &amp; <span class="number">0X18</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">			*val = <span class="number">0</span>;</span><br><span class="line">			*val2 = accel_scale_icm20608[regdata];;</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT_PLUS_NANO;<span class="comment">/* 值为val+val2/1000000000 */</span></span><br><span class="line">		<span class="keyword">case</span> IIO_TEMP:					</span><br><span class="line">			*val = ICM20608_TEMP_SCALE/ <span class="number">1000000</span>;</span><br><span class="line">			*val2 = ICM20608_TEMP_SCALE % <span class="number">1000000</span>;</span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT_PLUS_MICRO;	<span class="comment">/* 值为val+val2/1000000 */</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_OFFSET:		<span class="comment">/* ICM20608温度传感器offset值 */</span></span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_TEMP:</span><br><span class="line">			*val = ICM20608_TEMP_OFFSET;</span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_CALIBBIAS:	<span class="comment">/* ICM20608加速度计和陀螺仪校准值 */</span></span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_ANGL_VEL:		<span class="comment">/* 陀螺仪的校准值 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			ret = icm20608_sensor_show(dev, ICM20_XG_OFFS_USRH, chan-&gt;channel2, val);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">case</span> IIO_ACCEL:			<span class="comment">/* 加速度计的校准值 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);	</span><br><span class="line">			ret = icm20608_sensor_show(dev, ICM20_XA_OFFSET_H, chan-&gt;channel2, val);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> ret -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     	: 写函数，当向sysfs中的文件写数据的时候最终此函数会执行，一般在此函数</span></span><br><span class="line"><span class="comment">  * 					：里面设置传感器，比如量程等。</span></span><br><span class="line"><span class="comment">  * @param - indio_dev	: iio_dev</span></span><br><span class="line"><span class="comment">  * @param - chan   	: 通道</span></span><br><span class="line"><span class="comment">  * @param - val   		: 应用程序写入的值，如果是小数值的话，val是整数部分。</span></span><br><span class="line"><span class="comment">  * @param - val2   	: 应用程序写入的值，如果是小数值的话，val2是小数部分。</span></span><br><span class="line"><span class="comment">  * @return				: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_write_raw</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> val, <span class="type">int</span> val2, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> iio_priv(indio_dev);</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (mask) &#123;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_SCALE:	<span class="comment">/* 设置陀螺仪和加速度计的分辨率 */</span></span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_ANGL_VEL:		<span class="comment">/* 设置陀螺仪 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			ret = icm20608_write_gyro_scale(dev, val2);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IIO_ACCEL:			<span class="comment">/* 设置加速度计 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			ret = icm20608_write_accel_scale(dev, val2);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_CALIBBIAS:	<span class="comment">/* 设置陀螺仪和加速度计的校准值*/</span></span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_ANGL_VEL:		<span class="comment">/* 设置陀螺仪校准值 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			ret = icm20608_sensor_set(dev, ICM20_XG_OFFS_USRH,</span><br><span class="line">									    chan-&gt;channel2, val);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> IIO_ACCEL:			<span class="comment">/* 加速度计校准值 */</span></span><br><span class="line">			mutex_lock(&amp;dev-&gt;lock);</span><br><span class="line">			ret = icm20608_sensor_set(dev, ICM20_XA_OFFSET_H,</span><br><span class="line">							             chan-&gt;channel2, val);</span><br><span class="line">			mutex_unlock(&amp;dev-&gt;lock);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ret = -EINVAL;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  * @description     	: 用户空间写数据格式，比如我们在用户空间操作sysfs来设置传感器的分辨率，</span></span><br><span class="line"><span class="comment">  * 					：如果分辨率带小数，那么这个小数传递到内核空间应该扩大多少倍，此函数就是</span></span><br><span class="line"><span class="comment">  *						: 用来设置这个的。</span></span><br><span class="line"><span class="comment">  * @param - indio_dev	: iio_dev</span></span><br><span class="line"><span class="comment">  * @param - chan   	: 通道</span></span><br><span class="line"><span class="comment">  * @param - mask   	: 掩码</span></span><br><span class="line"><span class="comment">  * @return				: 0，成功；其他值，错误</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_write_raw_get_fmt</span><span class="params">(<span class="keyword">struct</span> iio_dev *indio_dev,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> iio_chan_spec <span class="type">const</span> *chan, <span class="type">long</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (mask) &#123;</span><br><span class="line">	<span class="keyword">case</span> IIO_CHAN_INFO_SCALE:</span><br><span class="line">		<span class="keyword">switch</span> (chan-&gt;type) &#123;</span><br><span class="line">		<span class="keyword">case</span> IIO_ANGL_VEL:		<span class="comment">/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */</span></span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT_PLUS_MICRO;</span><br><span class="line">		<span class="keyword">default</span>:				<span class="comment">/* 用户空间写的加速度计分辨率数据要乘以1000000000 */</span></span><br><span class="line">			<span class="keyword">return</span> IIO_VAL_INT_PLUS_NANO;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> IIO_VAL_INT_PLUS_MICRO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">iio_info</span> <span class="title">icm20608_info</span> =</span> &#123;</span><br><span class="line">	.read_raw		= icm20608_read_raw,</span><br><span class="line">	.write_raw		= icm20608_write_raw,</span><br><span class="line">	.write_raw_get_fmt = &amp;icm20608_write_raw_get_fmt,	<span class="comment">/* 用户空间写数据格式 */</span></span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  1、申请iio_dev内存 */</span></span><br><span class="line">	indio_dev = devm_iio_device_alloc(&amp;spi-&gt;dev, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">	<span class="keyword">if</span> (!indio_dev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、获取icm20608_dev结构体地址 */</span></span><br><span class="line">	dev = iio_priv(indio_dev); </span><br><span class="line">	dev-&gt;spi = spi;</span><br><span class="line">	spi_set_drvdata(spi, indio_dev);    		<span class="comment">/* 将indio_de设置为spi-&gt;dev的driver_data */</span></span><br><span class="line">	mutex_init(&amp;dev-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、iio_dev的其他成员变量 */</span></span><br><span class="line">	indio_dev-&gt;dev.parent = &amp;spi-&gt;dev;</span><br><span class="line">	indio_dev-&gt;info = &amp;icm20608_info;</span><br><span class="line">	indio_dev-&gt;name = ICM20608_NAME;	</span><br><span class="line">	indio_dev-&gt;modes = INDIO_DIRECT_MODE;	<span class="comment">/* 直接模式，提供sysfs接口 */</span></span><br><span class="line">	indio_dev-&gt;channels = icm20608_channels;</span><br><span class="line">	indio_dev-&gt;num_channels = ARRAY_SIZE(icm20608_channels);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、注册iio_dev */</span></span><br><span class="line">	ret = iio_device_register(indio_dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;spi-&gt;dev, <span class="string">&quot;iio_device_register failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err_iio_register;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、初始化regmap_config设置 */</span></span><br><span class="line">	dev-&gt;regmap_config.reg_bits = <span class="number">8</span>;			<span class="comment">/* 寄存器长度8bit */</span></span><br><span class="line">	dev-&gt;regmap_config.val_bits = <span class="number">8</span>;			<span class="comment">/* 值长度8bit */</span></span><br><span class="line">	dev-&gt;regmap_config.read_flag_mask = <span class="number">0x80</span>;</span><br><span class="line">	<span class="comment">/* 读掩码设置为0X80，ICM20608使用SPI接口读的时候寄存器最高位应该为1 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 6、初始化SPI接口的regmap */</span></span><br><span class="line">	dev-&gt;regmap = regmap_init_spi(spi, &amp;dev-&gt;regmap_config);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev-&gt;regmap)) &#123;</span><br><span class="line">		ret = PTR_ERR(dev-&gt;regmap);</span><br><span class="line">		<span class="keyword">goto</span> err_regmap_init;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 7、初始化spi_device */</span></span><br><span class="line">	spi-&gt;mode = SPI_MODE_0;	<span class="comment">/*MODE0，CPOL=0，CPHA=0*/</span></span><br><span class="line">	spi_setup(spi);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化ICM20608内部寄存器 */</span></span><br><span class="line">	icm20608_reginit(dev);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err_regmap_init:</span><br><span class="line">    iio_device_unregister(indio_dev);</span><br><span class="line">err_iio_register:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iio_dev</span> *<span class="title">indio_dev</span> =</span> spi_get_drvdata(spi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	</span><br><span class="line">	dev = iio_priv(indio_dev);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、删除regmap */</span> </span><br><span class="line">	regmap_exit(dev-&gt;regmap);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、注销IIO */</span></span><br><span class="line">	iio_device_unregister(indio_dev);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">icm20608_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,icm20608&quot;</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">icm20608_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,icm20608&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">icm20608_driver</span> =</span> &#123;</span><br><span class="line">	.probe = icm20608_probe,</span><br><span class="line">	.remove = icm20608_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;icm20608&quot;</span>,</span><br><span class="line">		   	.of_match_table = icm20608_of_match,</span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">icm20608_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">icm20608_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(icm20608_init);</span><br><span class="line">module_exit(icm20608_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;ALIENTEK&quot;</span>);</span><br><span class="line">MODULE_INFO(intree, <span class="string">&quot;Y&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-1-probe">5.2.1 probe</span><a href="#5-2-1-probe" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p>还是按照<code>spi子系统框架</code>，<code>probe</code>时利用iio子系统，初始化<code>iio_dev</code>。</p>
<p><code>iio_info</code>属性赋值：</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p><code>iio_channels</code>属性赋值：</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p><strong>温度通道</strong>：</p>
<ol>
<li><p><code>info_mask_separate</code>设置为<code>IIO_CHAN_INFO_RAW,IIO_CHAN_INFO_SCALE, IIO_CHAN_INFO_OFFSET</code>此通。</p>
<p> <code>IIO_CHAN_INFO_RAW </code>为温度通道的原始值，<code>IIO_CHAN_INFO_OFFSET</code> 是 <code>ICM20608 </code>温度 offset 值，这个要查阅数 据手册。<code>IIO_CHAN_INFO_SCALE </code>是 <code>ICM20608</code> 的比例，也就是一个单位的原始值为多少℃， 这个也要查阅 <code>ICM20608 </code>的数据手册。</p>
</li>
<li><p>扫描元素设置成<code>SCAN_TEMP</code>。</p>
</li>
<li><p>扫描类型：有符号数据，数据位数16位，存储位数16位，右移位数0， 大端传输（一般MSB传输）</p>
</li>
</ol>
<p><strong>陀螺仪通道</strong>：</p>
<ol>
<li><p><code>modified </code>成员变量为 1，所以 <code>channel2 </code>就是<code>通道修饰符</code>，用来指定 X、Y、Z 轴。</p>
</li>
<li><p>扫描元素设置<code>SCAN_GYRO_X, Y,Z</code>。</p>
</li>
<li><p><code>info_mask_separate</code>设置为<code>IIO_CHAN_INFO_RAW, IIO_CHAN_INFO_CALIBBIAS</code>此通。“scale”是比例的意思，在这里就是量程(分辨率)，因为 ICM20608 的陀螺仪和加速度计的量程是可以调整的，量程不同分辨率也就不同。设置每个通道的<code>IIO_CHAN_INFO_RAW</code>和<code>IIO_CHAN_INFO_CALIBBIAS</code>这两个属性都是独立的，<code>IIO_CHAN_INFO_RAW </code>表示 ICM20608 每个通道的原始值，这个肯定 是每个通道独立的。<code>IIO_CHAN_INFO_CALIBBIAS</code> 是 ICM20608 每个通道的校准值，这个是 ICM20608 的特性，不是所有的传感器都有校准值，一切都要以实际所使用的传感器为准。</p>
</li>
<li><p><code>info_mask_shared_by_type</code>设置为<code>IIO_CHAN_INFO_SCALE</code>此通。表示量程分辨率共享对陀螺仪通道。</p>
</li>
<li><p>扫描类型：有符号数据，数据位数16位，存储位数16位，右移位数0， 大端传输（一般MSB传输）</p>
</li>
</ol>
<p><strong>加速度通道</strong>：同理与陀螺仪通道.</p>
<p><code>INDIO_DIRECT_MODE </code>直接模式，提供<code>sysfs</code>接口。</p>
<h3><span id="5-2-2-icm20608-read-raw">5.2.2 icm20608_read_raw</span><a href="#5-2-2-icm20608-read-raw" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="5-2-2-1-du-raw-shu-ju">5.2.2.1 读raw数据</span><a href="#5-2-2-1-du-raw-shu-ju" class="header-anchor">#</a></h4><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p><code>icm20608_read_raw</code>会传入具体通道和mask, 比如温度通道的raw,传入<code>ICM20_TEMP_OUT_H</code>寄存器，<code>IIO_MOD_X</code>那么<code>ind</code>就等于0，那么<code>regmap_bulk_read</code>出来就是一个16位的温度值。</p>
<p>同理，读加速度通道，传入<code>ICM20_ACCEL_XOUT_H</code>寄存器，<code>ind = (IIO_MOD_X - IIO_MOD_X )*2 = 0;</code>,因此读出16bit的x数据。再次传入<code>ind  = (IIO_MOD_Y - IIO_MOD_X)*2 = 2</code>,得到<code>ICM20_ACCEL_YOUT_H</code>寄存器，因此读取出16bit的y数据。再次传入<code>ind  = (IIO_MOD_Z - IIO_MOD_X)*2 = 4</code>,得到<code>ICM20_ACCEL_ZOUT_H</code>寄存器,因此读取出16bit的z数据。</p>
<p>同理，读陀螺仪通道。</p>
<h4><span id="5-2-2-2-du-liang-cheng">5.2.2.2 读量程</span><a href="#5-2-2-2-du-liang-cheng" class="header-anchor">#</a></h4><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>温度通道： 直接用预设量程即可或者<code>val1,val2</code>。分别表示整数，小数。</p>
<p>加速度通道: 获取量程参考数据手册：<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/#2-2-1-kong-zhi-ji-cun-qi">icm20608控制寄存器</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17780817.html">icm20608控制寄存器</a></p>
<p>根据读到的寄存器值：<code>regdata</code>配置量程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icm20608陀螺仪分辨率，对应250、500、1000、2000，计算方法：</span></span><br><span class="line"><span class="comment"> * 以正负250度量程为例，500/2^16=0.007629，扩大1000000倍，就是7629</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> gyro_scale_icm20608[] = &#123;<span class="number">7629</span>, <span class="number">15258</span>, <span class="number">30517</span>, <span class="number">61035</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * icm20608加速度计分辨率，对应2、4、8、16 计算方法：</span></span><br><span class="line"><span class="comment"> * 以正负2g量程为例，4/2^16=0.000061035，扩大1000000000倍，就是61035</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> accel_scale_icm20608[] = &#123;<span class="number">61035</span>, <span class="number">122070</span>, <span class="number">244140</span>, <span class="number">488281</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>陀螺仪通道：同理</p>
<p>陀螺仪量程计算：</p>
<p>可选的量程有<code>±250、±500、±1000 和±2000°/s</code>。以<code>± 250</code> 这个量程为例，每个数值对应的度数就是<code> 500/2^10≈0.007629°/s</code>。同理，<code>±500</code> 量程对应 的度数为<code> 0.015258</code>，<code>±1000</code> 量程对应的度数为<code> 0.030517</code>，<code>±2000 </code>量程为<code>0.061035</code>。假设现在设 置量程为<code>±2000</code>，读取到的原始值为 <code>12540</code>，那么对应的度数就是 <code>12540*0.061035≈765.37°/s</code>。 注意，这里扩大了 1000000 倍。</p>
<p>加速度量程计算：</p>
<p>计算方法和陀螺仪一样。这里扩大了 1000000000 倍。</p>
<h4><span id="5-2-2-3-du-offset">5.2.2.3 读offset</span><a href="#5-2-2-3-du-offset" class="header-anchor">#</a></h4><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>只有温度有<code>offset</code>。</p>
<h3><span id="5-2-3-icm20608-write-raw">5.2.3 icm20608_write_raw</span><a href="#5-2-3-icm20608-write-raw" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p>通过写寄存器来配置量程，校准值。</p>
<h4><span id="5-2-3-1-pei-zhi-liang-cheng">5.2.3.1 配置量程</span><a href="#5-2-3-1-pei-zhi-liang-cheng" class="header-anchor">#</a></h4><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>根据设置的<code>val</code>量程值，匹配到<code>i</code>量程等级，<code>d&lt;&lt;3</code>然后设置量程等级。</p>
<h4><span id="5-2-3-2-pei-zhi-xiao-zhun-zhi">5.2.3.2 配置校准值</span><a href="#5-2-3-2-pei-zhi-xiao-zhun-zhi" class="header-anchor">#</a></h4><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"></p>
<p>根据静态偏移寄存器，进行校准，写入校准值。</p>
<h3><span id="5-2-4-icm20608-write-raw-get-fmt">5.2.4 icm20608_write_raw_get_fmt</span><a href="#5-2-4-icm20608-write-raw-get-fmt" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>用户空间设置数据格式。</p>
<p>陀螺仪通道：规定用户空间写的陀螺仪分辨率数据要乘以1000000。</p>
<p>加速度通道：规定用户空间写的陀螺仪分辨率数据要乘以1000000000。</p>
<p>比如我们在用户空间要设置加速度计量程为<code>±4g</code>，只需要向 <code>in_accel_scale</code> 写 入<code> 0.000122070</code> ， 那 么 最 终 传 入 到 驱 动 里 面 的 就 是 <code>0.000122070*1000000000=122070</code>。</p>
<h2><span id="5-3-ce-shi">5.3 测试</span><a href="#5-3-ce-shi" class="header-anchor">#</a></h2><p>进入<code>“/sys/bus/iio/devices/”</code>目录：可以看到，此时有两个 IIO 设备<code>“iio:device0”，iio:device0 </code>是 I.MX6ULL 内 部 ADC，<code>iio:device1 </code>才是 ICM20608。</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></p>
<p>可以看出，<code>iio:device1 </code>对应<code>spi2.0</code> 上的设备，也就是<code> ICM20608</code>。</p>
<p>此目录下有 很多文件，比如<code>in_accel_scale、in_accel_x_calibias、in_accel_x_raw</code>等，这些就是我们设置的通道。<code>in_accel_scale </code>就是加速度计的比例，也就是分辨率(量程)，<code>in_accel_x_calibias </code>就是加速度 计 X 轴的校准值，<code>in_accel_x_raw </code>就是加速度计的 X 轴原始值。我们在配置通道的时候，设置 了类型相同的所有通道共用<code> SCALE</code>，所以这里只有一个<code> in_accel_scale</code>，而 X、Y、Z 轴的原始值和校准值每个轴都有一个文件，陀螺仪和温度计同理。</p>
<h3><span id="5-3-1-tong-dao-wen-jian-ming-ming-fang-shi">5.3.1 通道文件命名方式</span><a href="#5-3-1-tong-dao-wen-jian-ming-ming-fang-shi" class="header-anchor">#</a></h3><p>源码见4.1.1 <code>iio_device_register_sysfs</code>过程。</p>
<p><code>IIO_CHAN_INFO_RAW</code> 和<code> IIO_CHAN_INFO_CALIBBIAS</code>这两个专属属性，对应<code>in_accel_x_raw </code>和 <code>in_accel_x_calibias </code>这两个文件。</p>
<p>通道的命名:<code>[direction]_[type]_[index]_[modifier]_[info_mask]</code></p>
<p><strong>direction</strong>：为属性对应的方向</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_direction[] = &#123;</span><br><span class="line">	[<span class="number">0</span>] = <span class="string">&quot;in&quot;</span>,</span><br><span class="line">	[<span class="number">1</span>] = <span class="string">&quot;out&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>type</strong>：也就是配置通道的时候 type 值，type 对应的字符可以参考 <code>iio_chan_type_name_spec</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_chan_type_name_spec[] = &#123;</span><br><span class="line">	[IIO_VOLTAGE] = <span class="string">&quot;voltage&quot;</span>,</span><br><span class="line">	[IIO_CURRENT] = <span class="string">&quot;current&quot;</span>,</span><br><span class="line">	[IIO_POWER] = <span class="string">&quot;power&quot;</span>,</span><br><span class="line">	[IIO_ACCEL] = <span class="string">&quot;accel&quot;</span>,</span><br><span class="line">	[IIO_ANGL_VEL] = <span class="string">&quot;anglvel&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index</strong>：索引，如果配置通道的时候设置了 indexed&#x3D;1，那么就会使用通道的 channel 成员变 量来替代此部分命名。比如，有个 ADC 芯片支持 8 个通道，那么就可以使用 channel 来表示对 应的通道，最终在用户空间呈现的每个通道文件名的 index 部分就是通道号。</p>
<p><strong>modifier</strong>：当通道的 modified 成员变量为 1 的时候，channel2 就是修饰符, <code>iio_modifier_names</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_modifier_names[] = &#123;</span><br><span class="line">	[IIO_MOD_X] = <span class="string">&quot;x&quot;</span>,</span><br><span class="line">	[IIO_MOD_Y] = <span class="string">&quot;y&quot;</span>,</span><br><span class="line">	[IIO_MOD_Z] = <span class="string">&quot;z&quot;</span>,</span><br><span class="line">......</span><br><span class="line">	[IIO_MOD_PM4] = <span class="string">&quot;pm4&quot;</span>,</span><br><span class="line">	[IIO_MOD_PM10] = <span class="string">&quot;pm10&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>info_mask</strong>：属性掩码，也就是属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> iio_chan_info_postfix[] = &#123;</span><br><span class="line">	[IIO_CHAN_INFO_RAW] = <span class="string">&quot;raw&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_PROCESSED] = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_SCALE] = <span class="string">&quot;scale&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_OFFSET] = <span class="string">&quot;offset&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_CALIBSCALE] = <span class="string">&quot;calibscale&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_CALIBBIAS] = <span class="string">&quot;calibbias&quot;</span>,</span><br><span class="line">......</span><br><span class="line">	[IIO_CHAN_INFO_DEBOUNCE_TIME] = <span class="string">&quot;debounce_time&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_CALIBEMISSIVITY] = <span class="string">&quot;calibemissivity&quot;</span>,</span><br><span class="line">	[IIO_CHAN_INFO_OVERSAMPLING_RATIO] = <span class="string">&quot;oversampling_ratio&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>综上所述，<code>in_accel_x_raw </code>组成形式如图:</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"></p>
<h3><span id="5-3-2-du-qu-raw-shu-ju">5.3.2 读取raw数据</span><a href="#5-3-2-du-qu-raw-shu-ju" class="header-anchor">#</a></h3><p><code>进入“/sys/bus/iio/devices/”</code>目录,<code>cat iio:device1/in_ccel_x</code>,这时驱动中的<code>icm20608_read_raw</code>执行。</p>
<p>读取一下<code> in_accel_scale</code> 这个文件，这是加速度计的分辨率，我们默认设置了加速度计 量程为<code>±16g</code>，因此分辨率为 <code>0.000488281</code>。</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p>这时候有朋友可能会疑问,我们设置加速度计<code>±16g </code>的分辨率为 <code>488281</code>，也就是扩大了1000000000 倍，为啥这里读出来的是 <code>0.000488281</code> 这个原始值？</p>
<p>驱动返回的是<code>IIO_VAL_INT_PLUS_NANO</code>, 因 此 用 户 空 间 得 到 分 辨 率 以 后 会 除 以 1000000000 ， 得 到 真 实 的 分 辨 率 ， <code>488281/1000000000=0.000488281</code>。</p>
<p>再读取一下<code> in_accel_z_raw</code>，加速度计的 Z 轴原始值。静态情况 下 Z 轴应该是 1g 的重力加速度计。</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p><code>2074×0.000488281≈1.01g</code>，此时 Z 轴重力为 1g，结果正确。</p>
<h3><span id="5-3-3-bian-xie-ying-yong-cheng-xu-ce-shi">5.3.3 编写应用程序测试</span><a href="#5-3-3-bian-xie-ying-yong-cheng-xu-ce-shi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串转数字，将浮点小数字符串转换为浮点数数值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENSOR_FLOAT_DATA_GET(ret, index, str, member)\</span></span><br><span class="line"><span class="meta">	ret = file_data_read(file_path[index], str);\</span></span><br><span class="line"><span class="meta">	dev-&gt;member = atof(str);\</span></span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="comment">/* 字符串转数字，将整数字符串转换为整数数值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENSOR_INT_DATA_GET(ret, index, str, member)\</span></span><br><span class="line"><span class="meta">	ret = file_data_read(file_path[index], str);\</span></span><br><span class="line"><span class="meta">	dev-&gt;member = atoi(str);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/* icm20608 iio框架对应的文件路径 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *file_path[] = &#123;</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_scale&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_x_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_x_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_y_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_y_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_z_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_accel_z_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_scale&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_x_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_x_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_y_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_y_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_z_calibbias&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_anglvel_z_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_temp_offset&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_temp_raw&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device1/in_temp_scale&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件路径索引，要和file_path里面的文件顺序对应 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">path_index</span> &#123;</span></span><br><span class="line">	IN_ACCEL_SCALE = <span class="number">0</span>,</span><br><span class="line">	IN_ACCEL_X_CALIBBIAS,</span><br><span class="line">	IN_ACCEL_X_RAW,</span><br><span class="line">	IN_ACCEL_Y_CALIBBIAS,</span><br><span class="line">	IN_ACCEL_Y_RAW,</span><br><span class="line">	IN_ACCEL_Z_CALIBBIAS,</span><br><span class="line">	IN_ACCEL_Z_RAW,</span><br><span class="line">	IN_ANGLVEL_SCALE,</span><br><span class="line">	IN_ANGLVEL_X_CALIBBIAS,</span><br><span class="line">	IN_ANGLVEL_X_RAW,</span><br><span class="line">	IN_ANGLVEL_Y_CALIBBIAS,</span><br><span class="line">	IN_ANGLVEL_Y_RAW,</span><br><span class="line">	IN_ANGLVEL_Z_CALIBBIAS,</span><br><span class="line">	IN_ANGLVEL_Z_RAW,</span><br><span class="line">	IN_TEMP_OFFSET,</span><br><span class="line">	IN_TEMP_RAW,</span><br><span class="line">	IN_TEMP_SCALE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * icm20608数据设备结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> accel_x_calibbias, accel_y_calibbias, accel_z_calibbias;</span><br><span class="line">	<span class="type">int</span> accel_x_raw, accel_y_raw, accel_z_raw;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> gyro_x_calibbias, gyro_y_calibbias, gyro_z_calibbias;</span><br><span class="line">	<span class="type">int</span> gyro_x_raw, gyro_y_raw, gyro_z_raw;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> temp_offset, temp_raw;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> accel_scale, gyro_scale, temp_scale;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;</span><br><span class="line">	<span class="type">float</span> accel_x_act, accel_y_act, accel_z_act;</span><br><span class="line">	<span class="type">float</span> temp_act;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> <span class="title">icm20608</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description			: 读取指定文件内容</span></span><br><span class="line"><span class="comment"> * @param - filename 	: 要读取的文件路径</span></span><br><span class="line"><span class="comment"> * @param - str 		: 读取到的文件字符串</span></span><br><span class="line"><span class="comment"> * @return 				: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_data_read</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	FILE *data_stream;</span><br><span class="line"></span><br><span class="line">    data_stream = fopen(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">/* 只读打开 */</span></span><br><span class="line">    <span class="keyword">if</span>(data_stream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">fscanf</span>(data_stream, <span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">if</span>(!ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file read error!\r\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == EOF) &#123;</span><br><span class="line">        <span class="comment">/* 读到文件末尾的话将文件指针重新调整到文件头 */</span></span><br><span class="line">        fseek(data_stream, <span class="number">0</span>, SEEK_SET);  </span><br><span class="line">    &#125;</span><br><span class="line">	fclose(data_stream);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 获取ICM20608数据</span></span><br><span class="line"><span class="comment"> * @param - dev : 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 		: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">sensor_read</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、获取陀螺仪原始数据 */</span></span><br><span class="line">	SENSOR_FLOAT_DATA_GET(ret, IN_ANGLVEL_SCALE, str, gyro_scale);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ANGLVEL_X_RAW, str, gyro_x_raw);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ANGLVEL_Y_RAW, str, gyro_y_raw);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ANGLVEL_Z_RAW, str, gyro_z_raw);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、获取加速度计原始数据 */</span></span><br><span class="line">	SENSOR_FLOAT_DATA_GET(ret, IN_ACCEL_SCALE, str, accel_scale);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ACCEL_X_RAW, str, accel_x_raw);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ACCEL_Y_RAW, str, accel_y_raw);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_ACCEL_Z_RAW, str, accel_z_raw);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、获取温度值 */</span></span><br><span class="line">	SENSOR_FLOAT_DATA_GET(ret, IN_TEMP_SCALE, str, temp_scale);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_TEMP_OFFSET, str, temp_offset);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_TEMP_RAW, str, temp_raw);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、转换为实际数值 */</span></span><br><span class="line">	dev-&gt;accel_x_act = dev-&gt;accel_x_raw * dev-&gt;accel_scale;</span><br><span class="line">	dev-&gt;accel_y_act = dev-&gt;accel_y_raw * dev-&gt;accel_scale;</span><br><span class="line">	dev-&gt;accel_z_act = dev-&gt;accel_z_raw * dev-&gt;accel_scale;</span><br><span class="line"></span><br><span class="line">	dev-&gt;gyro_x_act = dev-&gt;gyro_x_raw * dev-&gt;gyro_scale;</span><br><span class="line">	dev-&gt;gyro_y_act = dev-&gt;gyro_y_raw * dev-&gt;gyro_scale;</span><br><span class="line">	dev-&gt;gyro_z_act = dev-&gt;gyro_z_raw * dev-&gt;gyro_scale;</span><br><span class="line"></span><br><span class="line">	dev-&gt;temp_act = ((dev-&gt;temp_raw - dev-&gt;temp_offset) / dev-&gt;temp_scale) + <span class="number">25</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: main主程序</span></span><br><span class="line"><span class="comment"> * @param - argc 	: argv数组元素个数</span></span><br><span class="line"><span class="comment"> * @param - argv 	: 具体参数</span></span><br><span class="line"><span class="comment"> * @return 			: 0 成功;其他 失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = sensor_read(&amp;icm20608);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n原始值:\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span></span><br><span class="line">                   , icm20608.gyro_x_raw, icm20608.gyro_y_raw, icm20608.gyro_z_raw);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span></span><br><span class="line">                   , icm20608.accel_x_raw, icm20608.accel_y_raw, icm20608.accel_z_raw);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;temp = %d\r\n&quot;</span>, icm20608.temp_raw);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;实际值:&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span></span><br><span class="line">                   , icm20608.gyro_x_act, icm20608.gyro_y_act, icm20608.gyro_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span></span><br><span class="line">                   , icm20608.accel_x_act, icm20608.accel_y_act, icm20608.accel_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act temp = %.2f°C\r\n&quot;</span>, icm20608.temp_act);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<h1><span id="6-iio-shi-yan-cao-zuo-vf610-adc-c">6 IIO实验-操作vf610_adc.c</span><a href="#6-iio-shi-yan-cao-zuo-vf610-adc-c" class="header-anchor">#</a></h1><p>以imx6ull芯片为例子，<code>drivers/iio/adc/vf610_adc.c</code></p>
<h2><span id="6-1-dts-miao-shu">6.1 dts描述</span><a href="#6-1-dts-miao-shu" class="header-anchor">#</a></h2><p>dtsi描述如下：默认是关闭的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adc1: adc@<span class="number">02198000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-adc&quot;</span>, <span class="string">&quot;fsl,vf610-adc&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02198000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">100</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_ADC1&gt;;</span><br><span class="line">	num-channels = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;adc&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们最后在<code> imx6ull-alientek-emmc.dts</code>添加节点内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_adc1: adc1grp &#123;</span><br><span class="line">	fsl,pins = &lt;MX6UL_PAD_GPIO1_IO01__GPIO1_IO01 <span class="number">0xb0</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">reg_vref_adc: regulator@<span class="number">2</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;regulator-fixed&quot;</span>;</span><br><span class="line">	regulator-name = <span class="string">&quot;VREF_3V3&quot;</span>;</span><br><span class="line">	regulator-min-microvolt = &lt;<span class="number">3300000</span>&gt;;</span><br><span class="line">	regulator-max-microvolt = &lt;<span class="number">3300000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;adc1 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_adc1&gt;;</span><br><span class="line">	num-channels = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	vref-supply = &lt;&amp;reg_vref_adc&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>添加 ADC 使用的<code>GPIO1_IO01</code>引脚配置信息</li>
<li><code>regulators </code>节点下添加参考电源子节点，最后status设置成okay</li>
</ol>
<h2><span id="6-2-shi-neng-adc-qu-dong">6.2 使能 ADC 驱动</span><a href="#6-2-shi-neng-adc-qu-dong" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Industrial I/O support</span><br><span class="line">		-&gt; Analog to digital converters</span><br><span class="line">			-&gt; &lt;*&gt; Freescale vf610 ADC driver <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p><code>drivers/iio/adc/</code>下的<code>makefile和Kconfig</code>:</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<h2><span id="6-3-qu-dong-dai-ma-fen-xi">6.3 驱动代码分析</span><a href="#6-3-qu-dong-dai-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<h3><span id="6-3-1-probe">6.3.1 probe</span><a href="#6-3-1-probe" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<p>申请初始化iio设备，alloc iio设备有多分一块内存给info结构体。</p>
<p>从dts获取寄存器地址信息，进行ioremap。获取中断号，注册中断服务程序。</p>
<p>获取时钟资源，电源资源，使能电源输出。并且获取电源参考电压<code>vref_uv</code>.</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<p>获取adc采样周期，<code>num-channels =2</code>.</p>
<p>中间<code>vf610_adc_cfg_init和vf610_adc_hw_init</code>是ADC controller的寄存器配置不展开介绍。可以参考裸机实验<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17798452.html">IMX6ULL ADC控制器</a></p>
<p>然后设置<code>iio_dev</code>结构体，最后注册iio设备。</p>
<h3><span id="6-3-2-vf610-read-raw">6.3.2 vf610_read_raw</span><a href="#6-3-2-vf610-read-raw" class="header-anchor">#</a></h3><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<p>读取 ADC 原始数据值，type 值为<code> IIO_VOLTAGE</code>，也就是读取电压值。这里<code>info-&gt;value</code>是怎么来的呢？</p>
<p>当然是中断服务程序进行ADC采样啊，如下：</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<h2><span id="6-4-yong-hu-tai-ce-shi">6.4 用户态测试</span><a href="#6-4-yong-hu-tai-ce-shi" class="header-anchor">#</a></h2><p>进入<code>/sys/bus/iio/devices/iio:device0 </code>目录下,该<code>iio</code>就是对应<code>vf610</code>这个ADC:</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p><code>in_voltage1_raw：</code>ADC1 通道 1 原始值文件。</p>
<p><code>in_voltage_scale：</code>ADC1 比例文件(分辨率)，单位为 mV。实际电压值<code>(mV)=in_voltage1_raw* in_voltage_scale</code></p>
<p> 我的开发板此时 <code>in_voltage1_raw</code> 和 <code>in_voltage_scale</code> 这两个文件内容如下：</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<p>经过计算，实际电压：<code>991*0.805664062≈798.4mV</code>，也就是<code> 0.7984V</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符串转数字，将浮点小数字符串转换为浮点数数值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENSOR_FLOAT_DATA_GET(ret, index, str, member)\</span></span><br><span class="line"><span class="meta">	ret = file_data_read(file_path[index], str);\</span></span><br><span class="line"><span class="meta">	dev-&gt;member = atof(str);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">/* 字符串转数字，将整数字符串转换为整数数值 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENSOR_INT_DATA_GET(ret, index, str, member)\</span></span><br><span class="line"><span class="meta">	ret = file_data_read(file_path[index], str);\</span></span><br><span class="line"><span class="meta">	dev-&gt;member = atoi(str);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *file_path[] = &#123;</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device0/in_voltage_scale&quot;</span>,</span><br><span class="line">	<span class="string">&quot;/sys/bus/iio/devices/iio:device0/in_voltage1_raw&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">path_index</span> &#123;</span></span><br><span class="line">	IN_VOLTAGE_SCALE = <span class="number">0</span>,</span><br><span class="line">	IN_VOLTAGE_RAW,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adc_dev</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> raw;</span><br><span class="line">	<span class="type">float</span> scale;</span><br><span class="line">	<span class="type">float</span> act;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">adc_dev</span> <span class="title">imx6ulladc</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_data_read</span><span class="params">(<span class="type">char</span> *filename, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	FILE *data_stream;</span><br><span class="line"></span><br><span class="line">    data_stream = fopen(filename, <span class="string">&quot;r&quot;</span>); <span class="comment">/* 只读打开 */</span></span><br><span class="line">    <span class="keyword">if</span>(data_stream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = <span class="built_in">fscanf</span>(data_stream, <span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">    <span class="keyword">if</span>(!ret) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;file read error!\r\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == EOF) &#123;</span><br><span class="line">        <span class="comment">/* 读到文件末尾的话将文件指针重新调整到文件头 */</span></span><br><span class="line">        fseek(data_stream, <span class="number">0</span>, SEEK_SET);  </span><br><span class="line">    &#125;</span><br><span class="line">	fclose(data_stream);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">adc_read</span><span class="params">(<span class="keyword">struct</span> adc_dev *dev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">	SENSOR_FLOAT_DATA_GET(ret, IN_VOLTAGE_SCALE, str, scale);</span><br><span class="line">	SENSOR_INT_DATA_GET(ret, IN_VOLTAGE_RAW, str, raw);</span><br><span class="line">	<span class="comment">/* 转换得到实际电压值mV */</span></span><br><span class="line">	dev-&gt;act = (dev-&gt;scale * dev-&gt;raw)/<span class="number">1000.f</span>;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = adc_read(&amp;imx6ulladc);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ADC原始值：%d，电压值：%.3fV\r\n&quot;</span>, imx6ulladc.raw, imx6ulladc.act);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意应用程序用到了浮点运算，因此：</p>
<p><code>arm-linux-gnueabihf-gcc -march=armv7-a -mfpu=neon -mfloat-abi=hard adcApp.c -o adcApp</code></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/33.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm1dc7q6j000018uf69j25er8" data-title="字符设备驱动-IIO子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-regmap子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-22T07:33:15.000Z" itemprop="datePublished">2024-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-regmap子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-regmap-de-jia-gou">1 regmap的架构</a></li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-regmap-jie-gou-ti">2.1 regmap 结构体</a></li>
<li><a href="#2-2-regmap-config">2.2 regmap_config</a></li>
</ul>
</li>
<li><a href="#3-api">3 API</a><ul>
<li><a href="#3-1-regmap-shen-qing-yu-chu-shi-hua">3.1 Regmap 申请与初始化</a></li>
<li><a href="#3-2-regmap-she-bei-fang-wen">3.2 regmap 设备访问</a></li>
<li><a href="#3-3-regmap-config-yan-ma-she-zhi">3.3 regmap_config 掩码设置</a></li>
</ul>
</li>
<li><a href="#4-regmap-cao-zuo-spi-icm20608-shi-yan">4 Regmap操作SPI-ICM20608实验</a><ul>
<li><a href="#4-1-chu-shi-hua-regmap">4.1 初始化 regmap</a></li>
<li><a href="#4-2-regmap-fang-wen-icm20608">4.2 regmap 访问icm20608</a></li>
</ul>
</li>
<li><a href="#5-regmap-cao-zuo-i2c-ap3216c-shi-yan">5 Regmap操作I2C-ap3216c实验</a><ul>
<li><a href="#5-1-chu-shi-hua-regmap">5.1 初始化 regmap</a></li>
<li><a href="#5-2-regmap-fang-wen-ap3216c">5.2 regmap 访问ap3216c</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-regmap-de-jia-gou">1 regmap的架构</span><a href="#1-regmap-de-jia-gou" class="header-anchor">#</a></h1><p><code>regmap</code>是为了方便操作寄存器而设计的，它将所有模块的寄存器(包括soc上模块的寄存器和外围设备的寄存器等)<br>抽象出来，用一套统一接口来操作寄存器，统一操作<code> i2c、i3c、spi、mmio、sccb、sdw、slimbus、irq</code>等。</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><code>regmap </code>框架分为三层：</p>
<p> ①、底层物理总线：<code> regmap</code> 支持的物理总线有<code> i2c、i3c、spi、mmio、sccb、sdw、slimbus、irq、spmi 和 w1</code>。</p>
<p> ②、<code>regmap </code>核心层：用于实现<code> regmap</code>核心。</p>
<p> ③、<code>regmapAPI </code> 抽象层，<code>regmap </code>向驱动编写人员提供的 API 接口。</p>
<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-regmap-jie-gou-ti">2.1 regmap 结构体</span><a href="#2-1-regmap-jie-gou-ti" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="type">spinlock_t</span> spinlock;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> spinlock_flags;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	regmap_lock lock;</span><br><span class="line">	regmap_unlock unlock;</span><br><span class="line">	<span class="type">void</span> *lock_arg; <span class="comment">/* This is passed to lock/unlock functions */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* Device we do I/O on */</span></span><br><span class="line">	<span class="type">void</span> *work_buf; <span class="comment">/* Scratch buffer used to format I/O */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">regmap_format</span> <span class="title">format</span>;</span> <span class="comment">/* Buffer format */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line">	<span class="type">void</span> *bus_context;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> async;</span><br><span class="line">	<span class="type">spinlock_t</span> async_lock;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> async_waitq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">async_free</span>;</span></span><br><span class="line">	<span class="type">int</span> async_ret;</span><br><span class="line">	...</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_register;</span><br><span class="line">	<span class="type">bool</span> (*writeable_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="type">bool</span> (*readable_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="type">bool</span> (*volatile_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="type">bool</span> (*precious_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">wr_table</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">rd_table</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">volatile_table</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">precious_table</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> (*reg_read)(<span class="type">void</span> *context, <span class="type">unsigned</span> <span class="type">int</span> reg,</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> *val);</span><br><span class="line">	<span class="type">int</span> (*reg_write)(<span class="type">void</span> *context, <span class="type">unsigned</span> <span class="type">int</span> reg,</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> val);</span><br><span class="line">	......</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">range_tree</span>;</span></span><br><span class="line">	<span class="type">void</span> *selector_work_buf; <span class="comment">/* Scratch buffer used for selector */</span></span><br><span class="line">&#125;;  <span class="comment">// drivers/base/regmap/internal.h</span></span><br></pre></td></tr></table></figure>

<p><code>regmap </code>的初始化通过结构体 <code>regmap_config</code>来完成。</p>
<h2><span id="2-2-regmap-config">2.2 regmap_config</span><a href="#2-2-regmap-config" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap_config</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//名字</span></span><br><span class="line">	<span class="type">int</span> reg_bits;<span class="comment">//寄存器地址位数，必填字段。</span></span><br><span class="line">	<span class="type">int</span> reg_stride;<span class="comment">//寄存器地址步长。</span></span><br><span class="line">	<span class="type">int</span> pad_bits; <span class="comment">//寄存器和值之间的填充位数</span></span><br><span class="line">	<span class="type">int</span> val_bits; <span class="comment">//寄存器值位数，必填字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可写回调函数</span></span><br><span class="line">	<span class="type">bool</span> (*writeable_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="comment">//可读回调函数</span></span><br><span class="line">    <span class="type">bool</span> (*readable_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="comment">//可缓存回调函数</span></span><br><span class="line">    <span class="type">bool</span> (*volatile_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	<span class="comment">//是否不能读回调函数，当寄存器不能读，就返回tree</span></span><br><span class="line">    <span class="type">bool</span> (*precious_reg)(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> reg);</span><br><span class="line">	regmap_lock lock;</span><br><span class="line">	regmap_unlock unlock;</span><br><span class="line">	<span class="type">void</span> *lock_arg;</span><br><span class="line">    <span class="comment">//读操作</span></span><br><span class="line">	<span class="type">int</span> (*reg_read)(<span class="type">void</span> *context, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> *val);</span><br><span class="line">	<span class="comment">//写操作</span></span><br><span class="line">    <span class="type">int</span> (*reg_write)(<span class="type">void</span> *context, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> val);</span><br><span class="line">	<span class="type">bool</span> fast_io;<span class="comment">//快速 I/O，使用 spinlock 替代 mutex 来提升锁性能。</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_register;<span class="comment">//有效的最大寄存器地址</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">wr_table</span>;</span><span class="comment">//可写的地址范围</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">rd_table</span>;</span><span class="comment">//可读的地址范围</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">volatile_table</span>;</span><span class="comment">//可缓存的地址范围</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_access_table</span> *<span class="title">precious_table</span>;</span><span class="comment">//不可读的地址范围</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">reg_default</span> *<span class="title">reg_defaults</span>;</span><span class="comment">//寄存器模式值,有两个成员变量：reg是寄存器地址，def是默认值</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_reg_defaults;<span class="comment">//默认寄存器表中的元素个数</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">regcache_type</span> <span class="title">cache_type</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *reg_defaults_raw;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_reg_defaults_raw;</span><br><span class="line"></span><br><span class="line">	u8 read_flag_mask; <span class="comment">//读标志掩码。</span></span><br><span class="line">	u8 write_flag_mask; <span class="comment">//写标志掩码</span></span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> use_single_rw;</span><br><span class="line">	<span class="type">bool</span> can_multi_write;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">regmap_endian</span> <span class="title">reg_format_endian</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">regmap_endian</span> <span class="title">val_format_endian</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_range_cfg</span> *<span class="title">ranges</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_ranges;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1><span id="3-api">3 API</span><a href="#3-api" class="header-anchor">#</a></h1><h2><span id="3-1-regmap-shen-qing-yu-chu-shi-hua">3.1 Regmap 申请与初始化</span><a href="#3-1-regmap-shen-qing-yu-chu-shi-hua" class="header-anchor">#</a></h2><p><code>regmap </code>支持多种物理总线，比如 I2C 和 SPI，我们需要根据所使用的接口来选 择合适的<code> regmap</code> 初始化函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> regmap * <span class="title function_">regmap_init_spi</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="keyword">struct</span> regmap_config *config)</span>;</span><br><span class="line"><span class="keyword">struct</span> regmap * <span class="title function_">regmap_init_i2c</span><span class="params">(<span class="keyword">struct</span> i2c_client *i2c, <span class="type">const</span> <span class="keyword">struct</span> regmap_config *config)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">regmap_exit</span><span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>)</span>;<span class="comment">//不管是什么物理接口，退出都用regmap_exit</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-regmap-she-bei-fang-wen">3.2 regmap 设备访问</span><a href="#3-2-regmap-she-bei-fang-wen" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">regmap_read</span><span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> *val)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">regmap_write</span><span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> val)</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>regmap_read</code> 和 <code>regmap_write</code> 的基础上还衍生出了其他一些 <code>regmap</code> 的 API 函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* regmap_update_bits函数，看名字就知道，此函数用来修改寄存器指定的 bit。</span></span><br><span class="line"><span class="comment">* mask：掩码，需要更新的位必须在掩码中设置为 1。</span></span><br><span class="line"><span class="comment">* val：需要更新的位值。</span></span><br><span class="line"><span class="comment">* 比如要将寄存器的 bit1 和 bit2 置 1，那么 mask 应该设置为 0X00000011，此时 val 的 bit1</span></span><br><span class="line"><span class="comment">和 bit2 应该设置为 1，也就是 0Xxxxxxx11。如果要清除寄存器的 bit4 和 bit7，那么 mask 应该</span></span><br><span class="line"><span class="comment">设置为 0X10010000，val 的 bit4 和 bit7 设置为 0，也就是 0X0xx0xxxx。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">regmap_update_bits</span> <span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">unsigned</span> <span class="type">int</span> mask, <span class="type">unsigned</span> <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取写入多个寄存器的值</span></span><br><span class="line"><span class="comment">//map：要操作的 regmap。</span></span><br><span class="line"><span class="comment">//reg：要读写的第一个寄存器。</span></span><br><span class="line"><span class="comment">//val：要读写的寄存器数据缓冲区。</span></span><br><span class="line"><span class="comment">//val_count：要读写的寄存器数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">regmap_bulk_read</span><span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">void</span> *val, <span class="type">size_t</span> val_count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">regmap_bulk_write</span><span class="params">(<span class="keyword">struct</span> regmap *<span class="built_in">map</span>, <span class="type">unsigned</span> <span class="type">int</span> reg, <span class="type">const</span> <span class="type">void</span> *val, <span class="type">size_t</span> val_count)</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-3-regmap-config-yan-ma-she-zhi">3.3 regmap_config 掩码设置</span><a href="#3-3-regmap-config-yan-ma-she-zhi" class="header-anchor">#</a></h2><p>结构体<code>regmap_config</code>里面有三个关于掩码的成员变量：<code>read_flag_mask </code>和 <code>write_flag_mask</code>.</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18194640">Linux下SPI子系统驱动</a>   <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统 | Hexo (fuzidage.github.io)</a></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>其中读操作要将寄存器的地址 <code>bit7 </code>置 1，表示这是 一个读操作。当我们使用<code>regmap</code>的时候就不需要手动将寄存器地址的 bit7 置 1，在初始化<code> regmap_config</code> 的时候直接将<code>read_flag_mask</code>设置为<code> 0X80</code> 即可，这样通过<code>regmap</code>读取 SPI 内部寄存器的时候就会将寄存器地址与<code>read_flag_mask</code>进行或运算，结果就是将 <code>bit7 </code>置 1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">regmap_bus</span> <span class="title">regmap_spi</span> =</span> &#123;</span><br><span class="line">	.write = regmap_spi_write,</span><br><span class="line">	.gather_write = regmap_spi_gather_write,</span><br><span class="line">	.async_write = regmap_spi_async_write,</span><br><span class="line">	.async_alloc = regmap_spi_async_alloc,</span><br><span class="line">	.read = regmap_spi_read,</span><br><span class="line">	.read_flag_mask = <span class="number">0x80</span>,</span><br><span class="line">	.reg_format_endian_default = REGMAP_ENDIAN_BIG,</span><br><span class="line">	.val_format_endian_default = REGMAP_ENDIAN_BIG,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">struct</span> regmap *<span class="title function_">regmap_init_spi</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="keyword">struct</span> regmap_config *config)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> regmap_init(&amp;spi-&gt;dev, &amp;regmap_spi, &amp;spi-&gt;dev, config);</span><br><span class="line">&#125;<span class="comment">// regmap-spi.c </span></span><br></pre></td></tr></table></figure>

<p>在 <code>regmap_init</code> 函数中找到如下所示内容:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (config-&gt;read_flag_mask || config-&gt;write_flag_mask) &#123;</span><br><span class="line">	<span class="built_in">map</span>-&gt;read_flag_mask = config-&gt;read_flag_mask;</span><br><span class="line">	<span class="built_in">map</span>-&gt;write_flag_mask = config-&gt;write_flag_mask;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bus) &#123;</span><br><span class="line">	<span class="built_in">map</span>-&gt;read_flag_mask = bus-&gt;read_flag_mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到初始化时用<code>regmap_config </code>中的读写掩码来初始化<code>regmap_bus</code>中的掩码。由于 <code>regmap_spi </code>默认将 <code>read_flag_mask </code>设置为 0X80，假如你所使用的 SPI 设备不需要读掩码，在初始 化<code>regmap_config</code>的时候一定要将 <code>read_flag_mask </code>设置为 0X00。</p>
<h1><span id="4-regmap-cao-zuo-spi-icm20608-shi-yan">4 Regmap操作SPI-ICM20608实验</span><a href="#4-regmap-cao-zuo-spi-icm20608-shi-yan" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18194640">Linux下SPI子系统驱动</a>  <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统 | Hexo (fuzidage.github.io)</a></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p>之前构造了<code>icm20608_dev</code>利用<code>spi子系统框架</code>通信。框架还是保持不变，添加<code>regmap和regmap_config</code>参数。</p>
<h2><span id="4-1-chu-shi-hua-regmap">4.1 初始化 regmap</span><a href="#4-1-chu-shi-hua-regmap" class="header-anchor">#</a></h2><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h2><span id="4-2-regmap-fang-wen-icm20608">4.2 regmap 访问icm20608</span><a href="#4-2-regmap-fang-wen-icm20608" class="header-anchor">#</a></h2><p>以前的读写寄存器操作要构造<code>spi_message,spi_transfer</code>:</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>现在直接套用<code>reg_map</code>函数,无需要调用spi数据传输相关api：</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>读多组寄存器也是一样，调用<code>regmap_bulk_read</code>。</p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<h1><span id="5-regmap-cao-zuo-i2c-ap3216c-shi-yan">5 Regmap操作I2C-ap3216c实验</span><a href="#5-regmap-cao-zuo-i2c-ap3216c-shi-yan" class="header-anchor">#</a></h1><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a>    <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="5-1-chu-shi-hua-regmap">5.1 初始化 regmap</span><a href="#5-1-chu-shi-hua-regmap" class="header-anchor">#</a></h2><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<h2><span id="5-2-regmap-fang-wen-ap3216c">5.2 regmap 访问ap3216c</span><a href="#5-2-regmap-fang-wen-ap3216c" class="header-anchor">#</a></h2><p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p><img src="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"></p>
<p>这里初始化<code>open fd</code>时，要用到<code>regmap_write</code>进行i2c从设备的寄存器写入初始化。然后调用read，调用<code>regmap_read</code>进行读操作，这里每次都只读取一个byte，不需要用到<code>regmap_bulk_read</code>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm1daap930000mgufepwi5m5y" data-title="字符设备驱动-regmap子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-UART子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-16T05:43:19.000Z" itemprop="datePublished">2024-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-UART子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-uart-gong-zuo-yuan-li">1 引入UART工作原理</a></li>
<li><a href="#2-linux-xia-tty-qu-dong-kuang-jia">2 Linux下TTY驱动框架</a><ul>
<li><a href="#2-1-she-bei-jie-dian-chai-bie">2.1 设备节点差别</a><ul>
<li><a href="#2-1-1-chuan-kou-zhong-duan-dev-ttys">2.1.1 串口终端（&#x2F;dev&#x2F;ttyS*）</a></li>
<li><a href="#2-1-2-kong-zhi-tai-zhong-duan-dev-console">2.1.2 控制台终端（&#x2F;dev&#x2F;console）</a></li>
<li><a href="#2-1-3-xu-ni-zhong-duan-dev-tty">2.1.3 虚拟终端（&#x2F;dev&#x2F;tty*）</a></li>
</ul>
</li>
<li><a href="#2-2-jia-gou-ceng-ci">2.2 架构层次</a></li>
<li><a href="#2-3-uart-qu-dong-zi-xi-tong">2.3 UART驱动子系统</a><ul>
<li><a href="#2-3-1-shu-ju-jie-gou-he-api">2.3.1 数据结构和API</a><ul>
<li><a href="#2-3-1-1-uart-driver">2.3.1.1 uart_driver</a><ul>
<li><a href="#2-3-1-1-1-uart-driver-zhu-ce-yu-zhu-xiao">2.3.1.1.1 uart_driver 注册与注销</a></li>
</ul>
</li>
<li><a href="#2-3-1-2-uart-port">2.3.1.2 uart_port</a><ul>
<li><a href="#2-3-1-2-1-uart-port-de-tian-jia-yu-yi-chu">2.3.1.2.1 uart_port 的添加与移除</a></li>
<li><a href="#2-3-1-2-2-uart-port-de-xiu-mian-yu-hui-fu">2.3.1.2.2 uart_port 的休眠与恢复</a></li>
</ul>
</li>
<li><a href="#2-3-1-3-uart-ops">2.3.1.3 uart_ops</a></li>
<li><a href="#2-3-1-4-console">2.3.1.4 console</a></li>
<li><a href="#2-3-1-5-bo-te-lu-xiang-guan">2.3.1.5 波特率相关</a></li>
<li><a href="#2-3-1-6-xiang-chuan-kou-xie-kong-zhi-tai-xin-xi">2.3.1.6 向串口写控制台信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-uart-kong-zhi-qi-shi-li-imx-wei-li">2.4 UART控制器示例-imx为例</a><ul>
<li><a href="#2-4-1-dts-miao-shu">2.4.1 dts描述</a></li>
<li><a href="#2-4-2-probe-chu-shi-hua">2.4.2 probe初始化</a></li>
<li><a href="#2-4-2-shou-ju-shou-fa-liu-cheng">2.4.2 收据收发流程</a><ul>
<li><a href="#2-4-2-1-open-guo-cheng">2.4.2.1 open过程</a></li>
<li><a href="#2-4-2-2-fa-song-jie-shou-zong-liu-cheng">2.4.2.2 发送接收总流程</a></li>
<li><a href="#2-4-2-3-fa-song-write-guo-cheng">2.4.2.3 发送-write过程</a><ul>
<li><a href="#2-4-2-3-1-yong-hu-xie-shu-ju-liu-cheng">2.4.2.3.1 用户写数据流程</a></li>
<li><a href="#2-4-2-3-2-ying-jian-xie-shu-ju-liu-cheng">2.4.2.3.2 硬件写数据流程</a></li>
</ul>
</li>
<li><a href="#2-4-2-4-jie-shou-read-guo-cheng">2.4.2.4 接收-read过程</a><ul>
<li><a href="#2-4-2-4-1-zhong-duan-chan-sheng-shu-ju-liu-cheng">2.4.2.4.1 中断产生数据流程</a></li>
<li><a href="#2-4-2-4-2-yong-hu-du-qu-shu-ju-liu-cheng">2.4.2.4.2 用户读取数据流程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-uart-yong-hu-tai-kong-zhi-han-shu">3 UART用户态控制函数</a><ul>
<li><a href="#3-1-api-shuo-ming">3.1 API说明</a><ul>
<li><a href="#3-1-1-she-zhi-can-shu">3.1.1 设置参数</a></li>
<li><a href="#3-1-2-cao-zuo-liu-cheng">3.1.2 操作流程</a></li>
</ul>
</li>
<li><a href="#3-2-demo-ju-li">3.2 demo举例</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-uart-gong-zuo-yuan-li">1 引入UART工作原理</span><a href="#1-yin-ru-uart-gong-zuo-yuan-li" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/12003751.html">uart硬件传输原理</a>。<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-UART体系</a>。</p>
<h1><span id="2-linux-xia-tty-qu-dong-kuang-jia">2 Linux下TTY驱动框架</span><a href="#2-linux-xia-tty-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>可以看到<code>tty框架</code>下不止包含uart,还有display设备，键盘设备。</p>
<p>详细展开如下，<code>tty_driver</code>位于<code>tty_io.c</code>， 调用底下的<code>uart_diver</code>位于<code>serial_core.c</code>。<code>uart_driver</code>子系统会被最底层的soc厂商拿去适配，调用<code>uart_register_driver</code>注册自己的uart控制器，去实现控制器要实现的<code>uart_fops</code>操作函数。<br><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<h2><span id="2-1-she-bei-jie-dian-chai-bie">2.1 设备节点差别</span><a href="#2-1-she-bei-jie-dian-chai-bie" class="header-anchor">#</a></h2><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/2-1.png" alt="image"></p>
<h3><span id="2-1-1-chuan-kou-zhong-duan-x2f-dev-x2f-ttys">2.1.1 串口终端（&#x2F;dev&#x2F;ttyS*）</span><a href="#2-1-1-chuan-kou-zhong-duan-x2f-dev-x2f-ttys" class="header-anchor">#</a></h3><p>串口终端是使用计算机串口连接的终端设备。Linux把每个串行端口都看做是一个字符设备。这些串行端口所对应的设备名称是<code>/dev/ttySAC*</code>;</p>
<h3><span id="2-1-2-kong-zhi-tai-zhong-duan-x2f-dev-x2f-console">2.1.2 控制台终端（&#x2F;dev&#x2F;console）</span><a href="#2-1-2-kong-zhi-tai-zhong-duan-x2f-dev-x2f-console" class="header-anchor">#</a></h3><p>在Linux系统中，计算机的输出设备通常被称为控制台终端，这里特指printk信息输出到设备。<code>/dev/console</code>是一个虚拟的设备，它需要映射到真正的tty上，比如通过内核启动参数<code>“console=ttySCA0”</code>就把console映射到了串口0</p>
<h3><span id="2-1-3-xu-ni-zhong-duan-x2f-dev-x2f-tty">2.1.3 虚拟终端（&#x2F;dev&#x2F;tty*）</span><a href="#2-1-3-xu-ni-zhong-duan-x2f-dev-x2f-tty" class="header-anchor">#</a></h3><p>当用户登录时，使用的是虚拟终端。使用<code>Ctcl+Alt[F1 - F6]</code>组合键时，我们就可以切换到tty1、tty2、tty3等上面去。tty*就称为虚拟终端，而tty0则是当前所使用虚拟终端的一个别名。</p>
<h2><span id="2-2-jia-gou-ceng-ci">2.2 架构层次</span><a href="#2-2-jia-gou-ceng-ci" class="header-anchor">#</a></h2><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>TTY核心层-&gt;线路规划层-&gt;tty驱动层。</p>
<h2><span id="2-3-uart-qu-dong-zi-xi-tong">2.3 UART驱动子系统</span><a href="#2-3-uart-qu-dong-zi-xi-tong" class="header-anchor">#</a></h2><h3><span id="2-3-1-shu-ju-jie-gou-he-api">2.3.1 数据结构和API</span><a href="#2-3-1-shu-ju-jie-gou-he-api" class="header-anchor">#</a></h3><h4><span id="2-3-1-1-uart-driver">2.3.1.1 uart_driver</span><a href="#2-3-1-1-uart-driver" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span> <span class="comment">/* 模块所属者 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *driver_name; <span class="comment">/* 驱动名字 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name; <span class="comment">/* 设备名字 */</span></span><br><span class="line">	<span class="type">int</span> major; <span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">int</span> minor; <span class="comment">/* 次设备号 */</span></span><br><span class="line">	<span class="type">int</span> nr; <span class="comment">/* 设备数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">cons</span>;</span> <span class="comment">/* 控制台 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* these are private; the low level driver should not</span></span><br><span class="line"><span class="comment">	* touch these; they should be initialised to NULL</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">tty_driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//include/linux/serial_core.h</span></span><br></pre></td></tr></table></figure>

<h5><span id="2-3-1-1-1-uart-driver-zhu-ce-yu-zhu-xiao">2.3.1.1.1 uart_driver 注册与注销</span><a href="#2-3-1-1-1-uart-driver-zhu-ce-yu-zhu-xiao" class="header-anchor">#</a></h5><p><code>int uart_register_driver(struct uart_driver *drv);</code></p>
<p><code>返回值：0，成功；负值，失败。</code></p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">retval = tty_register_driver(normal);</span><br><span class="line">	error = register_chrdev_region(dev, driver-&gt;num, driver-&gt;name);<span class="comment">//也是通过字符设备驱动框架注册</span></span><br><span class="line">		d = tty_register_device(driver, i, <span class="literal">NULL</span>);</span><br><span class="line">			tty_register_device_attr(driver, index, device, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">				retval = tty_cdev_add(driver, devt, index, <span class="number">1</span>);</span><br><span class="line">					driver-&gt;cdevs[index]-&gt;ops = &amp;tty_fops;</span><br><span class="line">					err = cdev_add(driver-&gt;cdevs[index], dev, count);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p>设置<code>uart_ops</code>为tty的<code>tty_operations</code>。然后调用<code>tty_register_driver</code>注册到tty子系统。</p>
<p><code>void uart_unregister_driver(struct uart_driver *drv);</code></p>
<h4><span id="2-3-1-2-uart-port">2.3.1.2 uart_port</span><a href="#2-3-1-2-uart-port" class="header-anchor">#</a></h4><p>描述串口端口的I&#x2F;O端口或I&#x2F;O内存地址、FIFO大小、端口类型、串口时钟等信息。实际上，一个<code>uart_port</code>实现对应一个串口设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> lock; <span class="comment">/* port lock */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> iobase; <span class="comment">/* in/out[bwl] */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> __iomem *membase; <span class="comment">/* read/write[bwl] */</span></span><br><span class="line">	..</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> custom_divisor;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> line; <span class="comment">/* port index */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> minor;</span><br><span class="line">	<span class="type">resource_size_t</span> mapbase; <span class="comment">/* for ioremap */</span></span><br><span class="line">	<span class="type">resource_size_t</span> mapsize;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* parent device */</span></span><br><span class="line">	..</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//include/linux/serial_core.h</span></span><br></pre></td></tr></table></figure>

<h5><span id="2-3-1-2-1-uart-port-de-tian-jia-yu-yi-chu">2.3.1.2.1 uart_port 的添加与移除</span><a href="#2-3-1-2-1-uart-port-de-tian-jia-yu-yi-chu" class="header-anchor">#</a></h5><p><code>int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport);</code></p>
<p><code>返回值：0，成功；负值，失败。</code></p>
<p><code>uart_port </code>和 <code>uart_driver </code>结合起来。</p>
<p><code>int uart_remove_one_port(struct uart_driver *drv, struct uart_port *uport);</code></p>
<h5><span id="2-3-1-2-2-uart-port-de-xiu-mian-yu-hui-fu">2.3.1.2.2 uart_port 的休眠与恢复</span><a href="#2-3-1-2-2-uart-port-de-xiu-mian-yu-hui-fu" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_suspend_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *port)</span>;<span class="comment">//挂起特定的串口端口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uart_resume_port</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv, <span class="keyword">struct</span> uart_port *port)</span>;</span><br><span class="line"><span class="comment">//唤醒上层因串口端口写数据而堵塞的进程，通常在串口发送中断处理函数中调用该函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_write_wakeup</span><span class="params">(<span class="keyword">struct</span> uart_port *port)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-3-uart-ops">2.3.1.3 uart_ops</span><a href="#2-3-1-3-uart-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uart_ops</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*tx_empty)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line">	<span class="type">void</span> (*set_mctrl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> mctrl);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_mctrl)</span><span class="params">(<span class="keyword">struct</span> uart_port *)</span>;</span><br><span class="line">	<span class="type">void</span> (*stop_tx)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*start_tx)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*throttle)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> uart_port *, <span class="type">char</span> ch);</span><br><span class="line">	<span class="type">void</span> (*stop_rx)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*enable_ms)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*break_ctl)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span> ctl);</span><br><span class="line">	<span class="type">int</span> (*startup)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *new,<span class="keyword">struct</span> ktermios *old);</span><br><span class="line">	<span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> ktermios *);</span><br><span class="line">	<span class="type">void</span> (*pm)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span> state,<span class="type">unsigned</span> <span class="type">int</span> oldstate);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Return a string describing the type of the port</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*type)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Release IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment">	* This includes iounmap if necessary.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">void</span> (*release_port)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Request IO and memory resources used by the port.</span></span><br><span class="line"><span class="comment">	* This includes iomapping the port if necessary.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="type">int</span> (*request_port)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*config_port)(<span class="keyword">struct</span> uart_port *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*verify_port)(<span class="keyword">struct</span> uart_port *, <span class="keyword">struct</span> serial_struct *);</span><br><span class="line">	<span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">	<span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> uart_port *, <span class="type">unsigned</span> <span class="type">char</span>);</span><br><span class="line">	<span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> uart_port *);</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-4-console">2.3.1.4 console</span><a href="#2-3-1-4-console" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span> &#123;</span></span><br><span class="line">      <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">      <span class="type">void</span>(*write)(<span class="keyword">struct</span> console *，<span class="type">const</span> <span class="type">char</span> *, unsigined);</span><br><span class="line">      <span class="type">int</span> (*read)(<span class="keyword">struct</span> console *, <span class="type">char</span> *, <span class="type">unsigned</span>);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *(<span class="keyword">struct</span> <span class="title">console</span> *,<span class="title">int</span>*);</span></span><br><span class="line">      <span class="type">void</span> (*unblank)(<span class="type">void</span>);</span><br><span class="line">      <span class="type">int</span>  (*setup)(<span class="keyword">struct</span> console *, <span class="type">char</span> *);</span><br><span class="line">      <span class="type">int</span>  (*early_setup)(<span class="type">void</span>);</span><br><span class="line">      <span class="type">short</span>  flags;</span><br><span class="line">      <span class="type">short</span>  index; <span class="comment">/*用来指定该console使用哪一个uart port (对应的uart_port中的line),</span></span><br><span class="line"><span class="comment">      如果为-1,kernel会自动选择第一个uart port*/</span></span><br><span class="line">      <span class="type">int</span>   cflag;</span><br><span class="line">      <span class="type">void</span>  *data;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span>   <span class="title">console</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-5-bo-te-lu-xiang-guan">2.3.1.5 波特率相关</span><a href="#2-3-1-5-bo-te-lu-xiang-guan" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*功能：uart_get_baud_rate通过解码termios结构体来获取指定串口的波特率</span></span><br><span class="line"><span class="comment"> *参数：</span></span><br><span class="line"><span class="comment"> *     port：要获取波特率的串口端口</span></span><br><span class="line"><span class="comment"> *     termios:当前期望的termios配置(包括串口波特率)</span></span><br><span class="line"><span class="comment"> *     old:以前的termios配置，可以为NULL</span></span><br><span class="line"><span class="comment"> *     min:可以接受的最小波特率</span></span><br><span class="line"><span class="comment"> *     max:可以接受的最大波特率</span></span><br><span class="line"><span class="comment"> *     返回值：串口波特率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">uart_get_baund_rate</span><span class="params">(<span class="keyword">struct</span> uart_port *port, <span class="keyword">struct</span> ktermios *termios</span></span><br><span class="line"><span class="params">                                 , <span class="keyword">struct</span> ktermios *old,<span class="type">unsigned</span> <span class="type">int</span> min, <span class="type">unsigned</span> <span class="type">int</span> max)</span>;</span><br><span class="line"><span class="comment">/*功能：uart_get_divisor 用于计算某一波特率的串口时钟分频数(串口波特率除数）</span></span><br><span class="line"><span class="comment"> *参数：</span></span><br><span class="line"><span class="comment"> *     port：要计算分频数的串口端口</span></span><br><span class="line"><span class="comment"> *     baud：期望的波特率</span></span><br><span class="line"><span class="comment"> *返回值：串口时钟分频数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">uart_get_divisor</span><span class="params">(<span class="keyword">struct</span> uart_port *port, <span class="type">unsigned</span> <span class="type">int</span> baund)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-6-xiang-chuan-kou-xie-kong-zhi-tai-xin-xi">2.3.1.6 向串口写控制台信息</span><a href="#2-3-1-6-xiang-chuan-kou-xie-kong-zhi-tai-xin-xi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*功能：uart_console_write用于向串口端口写一控制台信息</span></span><br><span class="line"><span class="comment"> *参数：</span></span><br><span class="line"><span class="comment"> *     port：要写信息的串口端口</span></span><br><span class="line"><span class="comment"> *     s:要写的信息</span></span><br><span class="line"><span class="comment"> *     count：信息的大小</span></span><br><span class="line"><span class="comment"> *     putchar：用于向串口端口写字符的函数，该函数有两个参数：串口端口和要写的字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Void <span class="title function_">uart_console_write</span><span class="params">(<span class="keyword">struct</span> uart_port *port,<span class="type">const</span> <span class="type">char</span> *s,</span></span><br><span class="line"><span class="params">     <span class="type">unsigned</span> <span class="type">int</span> count,viod(*<span class="built_in">putchar</span>)(<span class="keyword">struct</span> uart_port*, <span class="type">int</span>))</span>;</span><br></pre></td></tr></table></figure>



<h2><span id="2-4-uart-kong-zhi-qi-shi-li-imx-wei-li">2.4 UART控制器示例-imx为例</span><a href="#2-4-uart-kong-zhi-qi-shi-li-imx-wei-li" class="header-anchor">#</a></h2><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p>位于<code>drivers\tty\serial\imx.c</code>,使用platform_driver框架，调用<code>uart_register_driver</code>注册到uart子系统。</p>
<h3><span id="2-4-1-dts-miao-shu">2.4.1 dts描述</span><a href="#2-4-1-dts-miao-shu" class="header-anchor">#</a></h3><p>板子使用的是uart3,打开<code>imx6ul.dtsi</code>，可以看到默认status是disabled。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uart3: serial@<span class="number">021</span>ec000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-uart&quot;</span>,</span><br><span class="line">	<span class="string">&quot;fsl,imx6q-uart&quot;</span>, <span class="string">&quot;fsl,imx21-uart&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021ec000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">28</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_UART3_IPG&gt;,</span><br><span class="line">	&lt;&amp;clks IMX6UL_CLK_UART3_SERIAL&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	dmas = &lt;&amp;sdma <span class="number">29</span> <span class="number">4</span> <span class="number">0</span>&gt;, &lt;&amp;sdma <span class="number">30</span> <span class="number">4</span> <span class="number">0</span>&gt;;</span><br><span class="line">	dma-names = <span class="string">&quot;rx&quot;</span>, <span class="string">&quot;tx&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们再外面引用它，打开<code>imx6ull-alientek-emmc.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_uart3: uart3grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX <span class="number">0X1b0b1</span></span><br><span class="line">		MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX <span class="number">0X1b0b1</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;uart3 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_uart3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-2-probe-chu-shi-hua">2.4.2 probe初始化</span><a href="#2-4-2-probe-chu-shi-hua" class="header-anchor">#</a></h3><p>当dts和驱动的compatible匹配，那么probe执行如下：</p>
<p>初始化<code> uart_port</code>，然后将其添加到对应的 <code>uart_driver </code>中。</p>
<ol>
<li>解析dts, 设置中断号，io基地址后<code>ioremap</code>, 设置port属性。</li>
</ol>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol start="2">
<li>设置port属性的ops</li>
</ol>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<ol start="3">
<li>更具dts获取和设置时钟频率。</li>
<li>注册中断</li>
</ol>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<ol start="5">
<li><code>uart_add_one_port(&amp;imx_reg, &amp;sport-&gt;port);</code>添加端口到uart_driver。</li>
</ol>
<h3><span id="2-4-2-shou-ju-shou-fa-liu-cheng">2.4.2 收据收发流程</span><a href="#2-4-2-shou-ju-shou-fa-liu-cheng" class="header-anchor">#</a></h3><h4><span id="2-4-2-1-open-guo-cheng">2.4.2.1 open过程</span><a href="#2-4-2-1-open-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tty_io.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">tty_fops</span> =</span> &#123;</span><br><span class="line">	.read		= tty_read,</span><br><span class="line">	.write		= tty_write,</span><br><span class="line">	.open		= tty_open,</span><br><span class="line">	.release	= tty_release,</span><br><span class="line">     ······</span><br><span class="line">&#125;;<span class="comment">//open(&quot;/dev/tty&quot;);</span></span><br><span class="line"><span class="comment">//进入tty_open函数：</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">tty_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    ......</span><br><span class="line">	<span class="keyword">if</span> (tty-&gt;ops-&gt;open)	<span class="comment">/*即uart_open*/</span></span><br><span class="line">		retval = tty-&gt;ops-&gt;open(tty, filp);<span class="comment">//</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_open</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> *<span class="title">drv</span> =</span> (<span class="keyword">struct</span> uart_driver *)tty-&gt;driver-&gt;driver_state;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_state</span> *<span class="title">state</span> =</span> drv-&gt;state + line;</span><br><span class="line">	retval = uart_startup(tty, state, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state, <span class="type">int</span> init_hw)</span> &#123;</span><br><span class="line">	retval = uart_port_startup(tty, state, init_hw);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">uart_port_startup</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> uart_state *state, <span class="type">int</span> init_hw)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">uart_port</span> *<span class="title">uport</span> =</span> state-&gt;uart_port;</span><br><span class="line">	<span class="keyword">if</span> (!state-&gt;xmit.buf) &#123;</span><br><span class="line">		page = get_zeroed_page(GFP_KERNEL);		<span class="comment">/*分配了一页内存*/</span></span><br><span class="line">		state-&gt;xmit.buf = (<span class="type">unsigned</span> <span class="type">char</span> *) page;	<span class="comment">/*串口底层发送缓冲区*/</span></span><br><span class="line">		uart_circ_clear(&amp;state-&gt;xmit);</span><br><span class="line">	&#125;</span><br><span class="line">	retval = uport-&gt;ops-&gt;startup(uport);		<span class="comment">/*即imx_startup*/</span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">imx_startup</span><span class="params">(<span class="keyword">struct</span> uart_port *port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_port</span> *<span class="title">sport</span> =</span> (<span class="keyword">struct</span> imx_port *)port;</span><br><span class="line">	<span class="type">int</span> retval, i;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags, temp;</span><br><span class="line">    .....</span><br><span class="line">	<span class="comment">/* Can we enable the DMA support? */</span></span><br><span class="line">	<span class="keyword">if</span> (is_imx6q_uart(sport) &amp;&amp; !uart_console(port)</span><br><span class="line">		&amp;&amp; !sport-&gt;dma_is_inited)</span><br><span class="line">		imx_uart_dma_init(sport);  <span class="comment">//配置发送消息时DMA搬运的目标地址，接收消息时DMA搬运的源地址</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (sport-&gt;dma_is_inited)</span><br><span class="line">		INIT_DELAYED_WORK(&amp;sport-&gt;tsk_dma_tx, dma_tx_work);<span class="comment">//定义了一个延后工作任务</span></span><br><span class="line">    <span class="comment">//DMA发送搬运，在串口发送数据会唤醒调度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-2-2-fa-song-jie-shou-zong-liu-cheng">2.4.2.2 发送接收总流程</span><a href="#2-4-2-2-fa-song-jie-shou-zong-liu-cheng" class="header-anchor">#</a></h4><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<h4><span id="2-4-2-3-fa-song-write-guo-cheng">2.4.2.3 发送-write过程</span><a href="#2-4-2-3-fa-song-write-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 应用层调用write系统调用来写入数据</span><br><span class="line"><span class="number">2.</span> write系统调用会调用到tty_write函数，这个函数定义在driver/tty/tty_io.c文件中。</span><br><span class="line">    而在tty_write函数里面调用的是ld-&gt;ops-&gt;write函数，这个就是line discipline层的write函数。</span><br><span class="line"><span class="number">3.</span> line discipline层的write函数就是n_tty_write函数，这个函数定义在driver/tty/n_tty.c文件中。</span><br><span class="line">    n_tty_write函数会进一步调用到uart_write函数，这个函数是通过tty_operations结构体的指针来访问的。</span><br><span class="line"><span class="number">4.</span> uart_write函数会进一步调用到start_tx函数，这个函数也是通过tty_operations结构体的指针来访问的。</span><br><span class="line">    在i.MX6ULL平台上，这个函数对应的就是imx_start_tx函数。</span><br><span class="line"><span class="number">5.</span> 在imx_start_tx函数中，会通过设置UCR1寄存器的TXMPTYEN位来使能发送缓冲区空中断。</span><br><span class="line">    这个操作是通过调用writel(temp | UCR1_TXMPTYEN, sport-&gt;port.membase + UCR1)来完成的。</span><br><span class="line"><span class="number">6.</span> 当UART控制器的发送缓冲区空了之后，就会产生一个中断。这个中断会被内核的中断处理机制捕获，</span><br><span class="line">    并调用相应的中断处理程序来处理。</span><br><span class="line"><span class="number">7.</span> 在中断处理程序中，会从环形缓冲区中取出数据，并写入到UART控制器的发送缓冲区中。</span><br><span class="line">    然后UART控制器会自动将这些数据发送出去。</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-3-1-yong-hu-xie-shu-ju-liu-cheng">2.4.2.3.1 用户写数据流程</span><a href="#2-4-2-3-1-yong-hu-xie-shu-ju-liu-cheng" class="header-anchor">#</a></h5><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p>在<code>tty_write</code>中通过<code>ld-&gt;ops-&gt;write</code>调用了线路规程的write函数，也就是调用了<code>tty_ldisc_N_TTY</code>的<code>ntty_write</code>函数。</p>
<h5><span id="2-4-2-3-2-ying-jian-xie-shu-ju-liu-cheng">2.4.2.3.2 硬件写数据流程</span><a href="#2-4-2-3-2-ying-jian-xie-shu-ju-liu-cheng" class="header-anchor">#</a></h5><p><code>drivers\tty\serial\imx.c</code>的发送函数<code>imx_start_tx</code>和发送中断函数<code>imx_txint</code>。</p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>一开始时，发送buffer肯定为空，会立刻产生中断:</p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<h4><span id="2-4-2-4-jie-shou-read-guo-cheng">2.4.2.4 接收-read过程</span><a href="#2-4-2-4-jie-shou-read-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> UART硬件控制器的接收端接收到数据后，数据会被自动写入接收缓冲区。</span><br><span class="line">    如果接收缓冲区中的数据达到一定数量（例如，半满或者满），</span><br><span class="line">    或者在一定时间内没有新的数据到来，那么就会产生一个接收中断。</span><br><span class="line"><span class="number">2.</span> 执行中断服务程序。在i.MX6ULL平台上，对应imx_rxint函数，在drivers/tty/serial/imx.c文件中。</span><br><span class="line">    <span class="number">2.1</span> imx_rxint函数中，首先会得到数据，然后通知line_disciplie层来处理，</span><br><span class="line">    	调用line_disciplie层的n_tty_receive_buf函数。</span><br><span class="line">    <span class="number">2.2</span> n_tty_receive_buf调用n_tty_receive_buf_common__receive_buf。</span><br><span class="line">    	这个函数会根据TTY设备的配置来处理新的数据，例如进行字符映射、回显等操作。</span><br><span class="line">    	处理完之后，数据已经被存储在了环形缓冲区，并且也已经进行了必要的处理，接下来等待应用程序的read来读取。</span><br><span class="line"><span class="number">3.</span> 应用层的read来读取数据，调用tty层的tty_read函数，进一步调用line discipline层的read函数，</span><br><span class="line">    这个line discipline层的read函数就可以读取前面从底层传过来的数据了。  </span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-4-1-zhong-duan-chan-sheng-shu-ju-liu-cheng">2.4.2.4.1 中断产生数据流程</span><a href="#2-4-2-4-1-zhong-duan-chan-sheng-shu-ju-liu-cheng" class="header-anchor">#</a></h5><p><code>imx_rxint</code><br>    &#x2F;&#x2F; 读取硬件状态<br>    &#x2F;&#x2F; 得到数据<br>    &#x2F;&#x2F; 在对应的<code>uart_port</code>中更新统计信息, 比如<code>sport-&gt;port.icount.rx++</code>;<br>    &#x2F;&#x2F; 把数据存入<code>tty_port</code>里的<code>tty_buffer</code><br>   <code> tty_insert_flip_char(port, rx, flg)</code><br>    &#x2F;&#x2F; 通知行规程来处理<br>   <code> tty_flip_buffer_push(port);</code><br>    <code>tty_schedule_flip(port);</code><br> <code>   queue_work(system_unbound_wq, &amp;buf-&gt;work);</code> &#x2F;&#x2F; 使用工作队列来处理<br>    &#x2F;&#x2F; 对应flush_to_ldisc函数  </p>
<h5><span id="2-4-2-4-2-yong-hu-du-qu-shu-ju-liu-cheng">2.4.2.4.2 用户读取数据流程</span><a href="#2-4-2-4-2-yong-hu-du-qu-shu-ju-liu-cheng" class="header-anchor">#</a></h5><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>在<code>tty_read</code>中通过<code>ld-&gt;ops-&gt;read</code>调用了线路规程的read函数，也就是调用了<code>tty_ldisc_N_TTY</code>的<code>ntty_read</code>函数。</p>
<h1><span id="3-uart-yong-hu-tai-kong-zhi-han-shu">3 UART用户态控制函数</span><a href="#3-uart-yong-hu-tai-kong-zhi-han-shu" class="header-anchor">#</a></h1><h2><span id="3-1-api-shuo-ming">3.1 API说明</span><a href="#3-1-api-shuo-ming" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>tcgetatrr</td>
<td align="left">取属性（termios结构）</td>
</tr>
<tr>
<td>tcsetarr</td>
<td align="left">设置属性（termios结构）</td>
</tr>
<tr>
<td>cfgetispeed</td>
<td align="left">得到输入速度</td>
</tr>
<tr>
<td>cfsetispeed</td>
<td align="left">得到输出速度</td>
</tr>
<tr>
<td>cfstospeed</td>
<td align="left">设置输出速度</td>
</tr>
<tr>
<td>tcdrain</td>
<td align="left">等待所有输出都被传输</td>
</tr>
<tr>
<td>tcflow</td>
<td align="left">挂起传输或接收</td>
</tr>
<tr>
<td>tcflush</td>
<td align="left">刷请未决输出和&#x2F;或输入</td>
</tr>
<tr>
<td>tcsendbreak</td>
<td align="left">送BREAK字符</td>
</tr>
<tr>
<td>tcgetpgrp</td>
<td align="left">得到前台进程组ID</td>
</tr>
<tr>
<td>Tcsetpgrp</td>
<td align="left">设置前台进程组ID</td>
</tr>
</tbody></table>
<h3><span id="3-1-1-she-zhi-can-shu">3.1.1 设置参数</span><a href="#3-1-1-she-zhi-can-shu" class="header-anchor">#</a></h3><ol>
<li>获取属性， <code>tegetatrr(fd, &amp;oldtio);</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">termious</span> <span class="title">newtio</span>, <span class="title">oldtio</span>;</span></span><br><span class="line">tegetattr(fd, &amp;oldtio);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>激活选项有<code>CLOCAL</code>和<code>CREAD</code>，用于本地连接和接收使用</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtio.cflag |= CLOCAL|CREAD;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置波特率</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cflag = B115200;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置数据位，需使用掩码设置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cflag &amp;= ~CSIZE;</span><br><span class="line">Newtio.c_cflag |= CS8;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>设置停止位，通过激活<code>c_cflag</code>中的<code>CSTOP</code>实现。若停止位为1,则清除<code>CSTOPB</code>，若停止位为2，则激活<code>CSTOP</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cflag &amp;= ~CSTOPB; <span class="comment">/*停止位设置为1*/</span></span><br><span class="line">Newtio.c_cflag |= CSTOPB; <span class="comment">/*停止位设置为2 */</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>设置流控</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cfag |= CRTSCTS <span class="comment">/*开启硬件流控 */</span></span><br><span class="line">newtio.c_cfag |= (IXON | IXOFF | IXANY); <span class="comment">/*开启软件流控*/</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>奇偶检验位设置，使用<code>c_cflag</code>和<code>c_ifag</code>.<br>7.1 设置奇校验</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cflag |= PARENB;</span><br><span class="line">newtio.c_cflag |= PARODD;</span><br><span class="line">newtio.c_iflag |= (INPCK | ISTRIP);</span><br></pre></td></tr></table></figure>
<p>   7.2 设置偶校验</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_iflag |= (INPCK | ISTRIP);</span><br><span class="line">newtio.c_cflag |= PARENB;</span><br><span class="line">newtio.c_cflag |= ~PARODD;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>设置最少字符和等待时间，对于接收字符和等待时间没有什么特别的要求，可设置为0：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newtio.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">newtio.c_cc[VMIN]  = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>处理要写入的引用对象<br><code>tcflush</code>函数刷清(抛弃）输入缓冲（终端程序已经接收到，但用户程序尚未读）或输出缓冲（用户程序已经写，但未发送）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcflash</span><span class="params">(<span class="type">int</span> filedes, <span class="type">int</span> quene)</span></span><br><span class="line">quene数应当是下列三个常数之一:</span><br><span class="line">  *TCIFLUSH 刷清输入队列</span><br><span class="line">  *TCOFLUSH 刷清输出队列</span><br><span class="line">  *TCIOFLUSH 刷清输入、输出队列</span><br><span class="line">例如：</span><br><span class="line"><span class="title function_">tcflush</span><span class="params">(fd, TCIFLUSH)</span>;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>激活配置，在完成配置后，需要激活配置使其生效。使用<code>tcsetattr()</code>函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcsetarr</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> termios *termptr)</span>;</span><br><span class="line">opt 指定在什么时候新的终端属性才起作用，</span><br><span class="line">   *TCSANOW:更改立即发生</span><br><span class="line">   *TCSADRAIN:发送了所有输出后更改才发生。若更改输出参数则应使用此选项</span><br><span class="line">   *TCSAFLUSH:发送了所有输出后更改才发生。更进一步，在更改发生时未读的</span><br><span class="line">                 所有输入数据都被删除（刷清）</span><br><span class="line">例如：tcsetatrr(fd, TCSANOW, &amp;newtio);</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-cao-zuo-liu-cheng">3.1.2 操作流程</span><a href="#3-1-2-cao-zuo-liu-cheng" class="header-anchor">#</a></h3><ol>
<li>打开串口，例如<code>&quot;/dev/ttySLB0&quot;</code></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/ttySLB0&quot;</span>,O_RDWR | O_NOCTTY | O_NDELAY);</span><br><span class="line"><span class="comment">/*O_NOCTTY：是为了告诉Linux这个程序不会成为这个端口上的“控制终端”。</span></span><br><span class="line"><span class="comment">	如果不这样做的话，所有的输入，比如键盘上过来的Ctrl+C中止信号等等，会影响到你的进程。</span></span><br><span class="line"><span class="comment">O_NDELAY：这个标志则是告诉Linux这个程序并不关心DCD信号线的状态，</span></span><br><span class="line"><span class="comment">	也就是不管串口是否有数据到来，都是非阻塞的，程序继续执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>恢复串口状态为阻塞状态，用于等待串口数据的读入，用fcntl函数：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd,F_SETFL,<span class="number">0</span>);  <span class="comment">//F_SETFL：设置文件flag为0，即默认，即阻塞状态</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>接着测试打开的文件描述符是否应用一个终端设备，以进一步确认串口是否正确打开。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isatty(STDIN_FILENO);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>读写串口</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">串口的读写与普通文件一样，使用read，write函数</span><br><span class="line">read(fd, buf ,<span class="number">8</span>);</span><br><span class="line">write(fd,buff,<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-demo-ju-li">3.2 demo举例</span><a href="#3-2-demo-ju-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;log/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_DEVICE     <span class="string">&quot;/dev/ttySLB1&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">temp</span> &#123;</span></span><br><span class="line">	<span class="type">float</span> temp_max1;</span><br><span class="line">	<span class="type">float</span> temp_max2;</span><br><span class="line">	<span class="type">float</span> temp_max3;</span><br><span class="line">	<span class="type">float</span> temp_min;</span><br><span class="line">	<span class="type">float</span> temp_mean;</span><br><span class="line">	<span class="type">float</span> temp_enviromem;</span><br><span class="line">	<span class="type">char</span> temp_col[<span class="number">1536</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> count, i, fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">termios</span> <span class="title">oldtio</span>, <span class="title">newtio</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">temp</span> *<span class="title">temp</span>;</span></span><br><span class="line">	temp = (<span class="keyword">struct</span> temp *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> temp));</span><br><span class="line">	<span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> cmd_buf1[] = &#123; <span class="number">0xAA</span>, <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x10</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0xBB</span>&#125;;</span><br><span class="line">	<span class="type">char</span> cmd_buf2[] = &#123; <span class="number">0xAA</span>, <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA0</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0xBB</span>&#125;;</span><br><span class="line">	<span class="type">char</span> cmd_buf3[] = &#123; <span class="number">0xAA</span>, <span class="number">0x01</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x10</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0xBB</span>&#125;;</span><br><span class="line">	<span class="type">char</span> read_buf[<span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line">	fd = open(UART_DEVICE, O_RDWR | O_NOCTTY);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Open %s failed\n&quot;</span>, UART_DEVICE);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	tcgetattr(fd, &amp;oldtio);<span class="comment">//获取当前操作模式参数</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;newtio, <span class="number">0</span>, <span class="keyword">sizeof</span>(newtio));</span><br><span class="line">	<span class="comment">//波特率=230400 数据位=8 使能数据接收</span></span><br><span class="line">	newtio.c_cflag = B230400 | CS8 | CLOCAL | CREAD | CSTOPB;</span><br><span class="line">	newtio.c_iflag = IGNPAR;</span><br><span class="line">	tcflush(fd, TCIFLUSH);<span class="comment">//清空输入缓冲区和输出缓冲区</span></span><br><span class="line">	tcsetattr(fd, TCSANOW, &amp;newtio);<span class="comment">//设置新的操作参数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf(&quot;input: %s, len = %d\n&quot;, cmd_buf, strlen(cmd_buf));</span></span><br><span class="line">	<span class="comment">//------------向uart发送数据-------------------</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%#X &quot;</span>, cmd_buf1[i]);</span><br><span class="line"></span><br><span class="line">	count = write(fd, cmd_buf1, <span class="number">9</span>);</span><br><span class="line">	<span class="keyword">if</span> (count != <span class="number">9</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	usleep(<span class="number">500000</span>);</span><br><span class="line">	<span class="built_in">memset</span>(read_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	count = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++);</span><br><span class="line">		temp-&gt;temp_max1 = read_buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">6</span>];</span><br><span class="line">		temp-&gt;temp_max2 = read_buf[<span class="number">9</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">8</span>];</span><br><span class="line">		temp-&gt;temp_max3 = read_buf[<span class="number">11</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">10</span>];</span><br><span class="line">		temp-&gt;temp_min  = read_buf[<span class="number">13</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">12</span>];</span><br><span class="line">		temp-&gt;temp_mean = read_buf[<span class="number">15</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_max1 = %f\n&quot;</span>, temp-&gt;temp_max1 * <span class="number">0.01</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_max2 = %f\n&quot;</span>, temp-&gt;temp_max2 * <span class="number">0.01</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_max3 = %f\n&quot;</span>, temp-&gt;temp_max3 * <span class="number">0.01</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_min  = %f\n&quot;</span>, temp-&gt;temp_min  * <span class="number">0.01</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_mean = %f\n&quot;</span>, temp-&gt;temp_mean * <span class="number">0.01</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read temp failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count = write(fd, cmd_buf3, <span class="number">9</span>);</span><br><span class="line">	<span class="keyword">if</span> (count != <span class="number">9</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	usleep(<span class="number">365</span>);</span><br><span class="line">	<span class="built_in">memset</span>(read_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	count = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++);</span><br><span class="line">		temp-&gt;temp_enviromem = read_buf[<span class="number">7</span>] &lt;&lt; <span class="number">8</span> | read_buf[<span class="number">6</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;temp-&gt;temp_enviromem = %f\n&quot;</span>, temp-&gt;temp_enviromem * <span class="number">0.01</span>);	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read enviromem failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count = write(fd, cmd_buf2, <span class="number">9</span>);</span><br><span class="line">	<span class="keyword">if</span> (count != <span class="number">9</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;send failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	usleep(<span class="number">70000</span>);</span><br><span class="line">	<span class="built_in">memset</span>(read_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	<span class="built_in">memset</span>(temp-&gt;temp_col, <span class="number">0</span>, <span class="keyword">sizeof</span>(temp-&gt;temp_col));</span><br><span class="line">	count = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;count = %d\n&quot;</span>, count);</span><br><span class="line">	<span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count - <span class="number">7</span>; i++)</span><br><span class="line">		temp-&gt;temp_col[i] = read_buf[i+<span class="number">6</span>];</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1536</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!(i%<span class="number">10</span>))</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%#X &quot;</span>, temp-&gt;temp_col[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read temp colour failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(temp); </span><br><span class="line">	close(fd);</span><br><span class="line">	tcsetattr(fd, TCSANOW, &amp;oldtio); <span class="comment">//恢复原先的设置</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"></p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm14wn6by0000psuf9q4xb7am" data-title="字符设备驱动-UART子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-RTC子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-16T05:22:52.000Z" itemprop="datePublished">2024-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-RTC子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#linux-xia-rtc-zi-xi-tong-qu-dong">Linux下RTC子系统驱动</a></li>
<li><a href="#1-yin-ru-rtc">1 引入RTC</a></li>
<li><a href="#2-linux-nei-he-rtc-qu-dong-kuang-jia">2 Linux 内核 RTC 驱动框架</a><ul>
<li><a href="#2-1-rtc-zi-xi-tong-makefile">2.1 rtc子系统Makefile</a></li>
<li><a href="#2-2-rtc-shu-ju-jie-gou">2.2 rtc数据结构</a><ul>
<li><a href="#2-2-1-rtc-device">2.2.1 rtc_device</a></li>
<li><a href="#2-2-2-rtc-class-ops">2.2.2 rtc_class_ops</a></li>
<li><a href="#2-2-3-rtc-dev-fops">2.2.3 rtc_dev_fops</a></li>
</ul>
</li>
<li><a href="#2-3-rtc-zi-xi-tong-chu-shi-hua">2.3 rtc子系统初始化</a></li>
<li><a href="#2-4-rtc-she-bei-cao-zuo-api">2.4 rtc设备操作API</a></li>
<li><a href="#2-5-zhu-ce-rtc-she-bei">2.5 注册RTC设备</a></li>
</ul>
</li>
<li><a href="#3-rtc-qu-dong-shi-li">3 RTC驱动实例</a><ul>
<li><a href="#3-1-she-bei-shu-jie-dian">3.1 设备树节点</a></li>
<li><a href="#3-2-qu-dong-probe">3.2 驱动probe</a><ul>
<li><a href="#3-2-1-snvs-rtc-probe">3.2.1 snvs_rtc_probe</a></li>
<li><a href="#3-2-2-rtc-class-ops-shi-li">3.2.2 rtc_class_ops实例</a><ul>
<li><a href="#3-2-2-1-snvs-rtc-read-time">3.2.2.1 snvs_rtc_read_time</a></li>
<li><a href="#3-2-2-2-snvs-rtc-set-time">3.2.2.2 snvs_rtc_set_time</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-3-ying-yong-ce-shi">3.3 应用测试</a><ul>
<li><a href="#3-3-1-du-qu-rtc-shi-jian">3.3.1 读取rtc时间</a></li>
<li><a href="#3-3-2-she-zhi-rtc-shi-jian">3.3.2 设置rtc时间</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="linux-xia-rtc-zi-xi-tong-qu-dong">Linux下RTC子系统驱动</span><a href="#linux-xia-rtc-zi-xi-tong-qu-dong" class="header-anchor">#</a></h1><h1><span id="1-yin-ru-rtc">1 引入RTC</span><a href="#1-yin-ru-rtc" class="header-anchor">#</a></h1><p>CPU内部有很多定时器，像看门狗<code>WDT，PWM</code>定时器，高精度定时器Timer等等, 只在“启动”即“通电时”运行，断电时停止。</p>
<p>当然，如果时钟不能连续跟踪时间，则必须手动设置。那么当关机后就没办法自动计数统计时间了。<code>RTC</code> 就很好的解决了这个问题，RTC是实时时钟，用于记录当前系统时间。</p>
<h1><span id="2-linux-nei-he-rtc-qu-dong-kuang-jia">2 Linux 内核 RTC 驱动框架</span><a href="#2-linux-nei-he-rtc-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p>RTC在linux内核态也是用一个字符设备驱动去实现的。Linux 内核将 RTC 设备抽象为<code>rtc_device</code>结构体，定义在 <code>include/linux/rtc.h</code>, 进入<code>drivers/rtc</code>子系统目录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class.c：为底层驱动提供 <span class="keyword">register</span> 与 unregister 接口用于 RTC 设备的注册/注销。初始化 RTC 设备结构、sysfs、proc</span><br><span class="line">interface.c：提供用户程序与 RTC 的接口函数</span><br><span class="line">dev.c：将 RTC 设备抽象为通用的字符设备，提供文件操作函数集</span><br><span class="line">sysfs.c：管理 RTC 设备的 sysfs 属性，获取 RTC 设备名、日期、时间等</span><br><span class="line">proc.c：管理 RTC 设备的 procfs 属性，提供中断状态和标志查询</span><br><span class="line">lib.c：提供 RTC、Data 和 Time 之间的转换函数</span><br><span class="line">rtc-xxx.c：各平台 RTC 设备的实际驱动</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<h2><span id="2-1-rtc-zi-xi-tong-makefile">2.1 rtc子系统Makefile</span><a href="#2-1-rtc-zi-xi-tong-makefile" class="header-anchor">#</a></h2><p>rtc子系统Makefile如下， 可以根据配置宏去裁剪rtc子系统。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-<span class="variable">$(CONFIG_RTC_LIB)</span>           += lib.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_RTC_SYSTOHC)</span>       += systohc.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_RTC_CLASS)</span>         += rtc-core.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_RTC_MC146818_LIB)</span>  += rtc-mc146818-lib.o</span><br><span class="line">rtc-core-y                      := class.o interface.o</span><br><span class="line"></span><br><span class="line">rtc-core-<span class="variable">$(CONFIG_RTC_NVMEM)</span>            += nvmem.o</span><br><span class="line">rtc-core-<span class="variable">$(CONFIG_RTC_INTF_DEV)</span>         += dev.o</span><br><span class="line">rtc-core-<span class="variable">$(CONFIG_RTC_INTF_PROC)</span>        += proc.o</span><br><span class="line">rtc-core-<span class="variable">$(CONFIG_RTC_INTF_SYSFS)</span>       += sysfs.o</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p>Linux默认rtc是开启的。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">　　-&gt;Real Time Clock</span><br><span class="line">　　　　[]Set system time from RTC on startup and resume</span><br><span class="line">　　　　[](rtc0)  RTC used to set the system time</span><br><span class="line">　　　　[]Set the RTC time based on NTP synchronization</span><br><span class="line">　　　　[](rtc0)  RTC used to synchronize NTP adjustment</span><br><span class="line">　　　　[]RTC debug support</span><br><span class="line">　　　　[]RTC non volatile storage support</span><br><span class="line">　　　　[]/sys/class/rtc/rtcN (sysfs)</span><br><span class="line">　　　　[]/proc/driver/rtc (procfs for rtcN)</span><br><span class="line">　　　　[]/dev/rtcN (character devices)</span><br></pre></td></tr></table></figure>


<h2><span id="2-2-rtc-shu-ju-jie-gou">2.2 rtc数据结构</span><a href="#2-2-rtc-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-2-1-rtc-device">2.2.1 rtc_device</span><a href="#2-2-1-rtc-device" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> id; <span class="comment">/* ID, 当前rtc设备在rtc子系统的子序号*/</span></span><br><span class="line">	<span class="type">char</span> name[RTC_DEVICE_NAME_SIZE]; <span class="comment">/* 名字 */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> *<span class="title">ops</span>;</span> <span class="comment">/* RTC 设备底层操作函数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">ops_lock</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">char_dev</span>;</span> <span class="comment">/* 字符设备 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> irq_data;</span><br><span class="line">	<span class="type">spinlock_t</span> irq_lock;</span><br><span class="line">	<span class="type">wait_queue_head_t</span> irq_queue;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">async_queue</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_task</span> *<span class="title">irq_task</span>;</span></span><br><span class="line">	<span class="type">spinlock_t</span> irq_task_lock;</span><br><span class="line">	<span class="type">int</span> irq_freq;</span><br><span class="line">	<span class="type">int</span> max_user_freq;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timerqueue_head</span> <span class="title">timerqueue</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">aie_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_timer</span> <span class="title">uie_rtctimer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hrtimer</span> <span class="title">pie_timer</span>;</span> <span class="comment">/* sub second exp, so needs hrtimer */</span></span><br><span class="line">	<span class="type">int</span> pie_enabled;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">irqwork</span>;</span></span><br><span class="line">	<span class="comment">/* Some hardware can&#x27;t support UIE mode */</span></span><br><span class="line">	<span class="type">int</span> uie_unsupported;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-rtc-class-ops">2.2.2 rtc_class_ops</span><a href="#2-2-2-rtc-class-ops" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*open)(<span class="keyword">struct</span> device *);</span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> device *);</span><br><span class="line">	<span class="type">int</span> (*ioctl)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*read_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">	<span class="type">int</span> (*set_time)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_time *);</span><br><span class="line">	<span class="type">int</span> (*read_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">	<span class="type">int</span> (*set_alarm)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> rtc_wkalrm *);</span><br><span class="line">	<span class="type">int</span> (*proc)(<span class="keyword">struct</span> device *, <span class="keyword">struct</span> seq_file *);</span><br><span class="line">	<span class="type">int</span> (*set_mmss64)(<span class="keyword">struct</span> device *, <span class="type">time64_t</span> secs);</span><br><span class="line">	<span class="type">int</span> (*set_mmss)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">long</span> secs);</span><br><span class="line">	<span class="type">int</span> (*read_callback)(<span class="keyword">struct</span> device *, <span class="type">int</span> data);</span><br><span class="line">	<span class="type">int</span> (*alarm_irq_enable)(<span class="keyword">struct</span> device *, <span class="type">unsigned</span> <span class="type">int</span> enabled);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>rtc_class_ops </code>为 RTC 设备的<strong>最底层操作函数集合</strong>，包括从 RTC 设备中读取时间、向 RTC 设备写入新的时间值等，<strong>对接RTC硬件控制器</strong>，不直接对接应用。</p>
<h3><span id="2-2-3-rtc-dev-fops">2.2.3 rtc_dev_fops</span><a href="#2-2-3-rtc-dev-fops" class="header-anchor">#</a></h3><p>Linux 内核提供了一个 <strong>RTC 通用字符设备驱动文件</strong>，文件名为<code> drivers/rtc/rtc-dev.c</code>，r该文件提供了所有 RTC 设备共用的 <code>file_operations </code>函数操作集，<strong>对接应用ioctl</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> rtc_dev_fops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.llseek = no_llseek,</span><br><span class="line">	.read = rtc_dev_read,</span><br><span class="line">	.poll = rtc_dev_poll,</span><br><span class="line">	.unlocked_ioctl = rtc_dev_ioctl,</span><br><span class="line">	.open = rtc_dev_open,</span><br><span class="line">	.release = rtc_dev_release,</span><br><span class="line">	.fasync = rtc_dev_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用关系：以RTC_RD_TIME为例</span></span><br><span class="line">rtc_dev_ioctl</span><br><span class="line">	-&gt;rtc_read_time</span><br><span class="line">    	-&gt;rtc-&gt;ops-&gt;<span class="built_in">read_time</span>(rtc-&gt;dev.parent, tm);</span><br><span class="line"><span class="comment">//可以看出，rtc_read_time 函数最终会调用 rtc_class_ops 中的.read_time 来从 RTC 设备中获取当前时间</span></span><br></pre></td></tr></table></figure>

<p><code>rtc_dev_ioctl </code>函数对其他的命令处理都是类似的，比 如 <code>RTC_ALM_READ</code> 命令会通过<code>rtc_read_alarm</code>函数获取到闹钟值，而 <code>rtc_read_alarm </code>函数经过层层调用，最终会调用<code>rtc_class_ops</code>中的 <code>read_alarm </code>函数来获取闹钟值。上下调用关系如下：</p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<h2><span id="2-3-rtc-zi-xi-tong-chu-shi-hua">2.3 rtc子系统初始化</span><a href="#2-3-rtc-zi-xi-tong-chu-shi-hua" class="header-anchor">#</a></h2><p>rtc子系统初始化，主要分配<code>rtc_class类</code>，以及rtc设备的<code>rtc_devt</code>为设备号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rtc_init</span><br><span class="line">　　-&gt;class_create--创建rtc_class类。　　</span><br><span class="line">    -&gt;rtc_dev_init　　　</span><br><span class="line">    -&gt;alloc_chrdev_region--为rtc设备分配子设备号范围<span class="number">0</span>~<span class="number">15</span>。主设备号随机分配。最终结果放入rtc_devt。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p>系统启动时会将RTC时间设置到系统时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rtc_hctosys</span><br><span class="line">　　-&gt;rtc_read_time</span><br><span class="line">　　-&gt;rtc_tm_to_time64</span><br><span class="line">　　-&gt;do_settimeofday64</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-rtc-she-bei-cao-zuo-api">2.4 rtc设备操作API</span><a href="#2-4-rtc-she-bei-cao-zuo-api" class="header-anchor">#</a></h2><p>对rtc设备的操作主要有：alarm读取和设置、rtc time读取和设置、中断配置, 对应<code>drivers\rtc\interface.c</code>，头文件对应<code>include/linux/rtc.h</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_read_time</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="keyword">struct</span> rtc_time *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_set_time</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="keyword">struct</span> rtc_time *tm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_set_ntp_time</span><span class="params">(<span class="keyword">struct</span> timespec64 now, <span class="type">unsigned</span> <span class="type">long</span> *target_nsec)</span></span>;</span><br><span class="line"><span class="type">int</span> __rtc_read_alarm(<span class="keyword">struct</span> rtc_device *rtc, <span class="keyword">struct</span> rtc_wkalrm *alarm);</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_read_alarm</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc,<span class="keyword">struct</span> rtc_wkalrm *alrm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_set_alarm</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc,<span class="keyword">struct</span> rtc_wkalrm *alrm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_initialize_alarm</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc,<span class="keyword">struct</span> rtc_wkalrm *alrm)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">rtc_update_irq</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">unsigned</span> <span class="type">long</span> num, <span class="type">unsigned</span> <span class="type">long</span> events)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_irq_set_state</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="type">int</span> enabled)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_irq_set_freq</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="type">int</span> freq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_update_irq_enable</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="type">unsigned</span> <span class="type">int</span> enabled)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">rtc_alarm_irq_enable</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc, <span class="type">unsigned</span> <span class="type">int</span> enabled)</span></span>;</span><br></pre></td></tr></table></figure>

<h2><span id="2-5-zhu-ce-rtc-she-bei">2.5 注册RTC设备</span><a href="#2-5-zhu-ce-rtc-she-bei" class="header-anchor">#</a></h2><p><code>devm_rtc_device_register</code>或者<code>rtc_register_device</code>注册rtc设备到rtc子系统。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtc_device</span> *<span class="built_in">devm_rtc_device_register</span>(<span class="keyword">struct</span> device *dev,</span><br><span class="line">					    <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">					    <span class="type">const</span> <span class="keyword">struct</span> rtc_class_ops *ops,</span><br><span class="line">					    <span class="keyword">struct</span> <span class="keyword">module</span> *owner);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __rtc_register_device(<span class="keyword">struct</span> <span class="keyword">module</span> *owner, <span class="keyword">struct</span> rtc_device *rtc);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rtc_device_unregister</span><span class="params">(<span class="keyword">struct</span> rtc_device *rtc)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<h1><span id="3-rtc-qu-dong-shi-li">3 RTC驱动实例</span><a href="#3-rtc-qu-dong-shi-li" class="header-anchor">#</a></h1><p>以nxp的imx6ull芯片为例，打开<code>imx6ull.dtsi</code>，找到<code>snvs_rtc</code>设备节点。</p>
<h2><span id="3-1-she-bei-shu-jie-dian">3.1 设备树节点</span><a href="#3-1-she-bei-shu-jie-dian" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snvs_rtc: snvs-rtc-lp &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,sec-v4.0-mon-rtc-lp&quot;</span>;</span><br><span class="line">	regmap = &lt;&amp;snvs&gt;;</span><br><span class="line">	offset = &lt;<span class="number">0x34</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">19</span> IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI <span class="number">20</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应驱动文件<code> drivers/rtc/rtc-snvs.c</code>。</p>
<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h2><span id="3-2-qu-dong-probe">3.2 驱动probe</span><a href="#3-2-qu-dong-probe" class="header-anchor">#</a></h2><h3><span id="3-2-1-snvs-rtc-probe">3.2.1 snvs_rtc_probe</span><a href="#3-2-1-snvs-rtc-probe" class="header-anchor">#</a></h3><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li><p>Linux3.1 引入了一个全新的 regmap 机制(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18299108">Linux下regmap模型驱动 - fuzidage - 博客园 (cnblogs.com)</a>)，<code>devm_regmap_init_mmio</code>。regmap 用于提供一套方便的 API 函 数去操作底层硬件寄存器，以提高代码的可重用性。<code>snvs-rtc.c</code> 文件会采用 <code>regmap 机制</code>来读写 RTC 底层硬件寄存器。这里使用<code> devm_regmap_init_mmio</code> 函数将 RTC 的硬件寄存器转化为 regmap 形式，这样 regmap 机制的 <code>regmap_write</code>、<code>regmap_read </code>等 API 函数才能操作寄存器。</p>
</li>
<li><p>获取中断号，时钟，使能时钟。</p>
</li>
<li><p>设置 <code>RTC_ LPPGDR </code>寄存器值为 <code>SNVS_LPPGDR_INIT= 0x41736166</code>，这里就是用的 regmap 机制的 <code>regmap_write </code>函数完成对寄存器进行写操作。</p>
</li>
<li><p><code>RTC_LPSR</code> 寄存器，写入 <code>0xffffffff</code>，<code>LPSR</code> 是 <code>RTC 状态寄存器</code>，写 1 清零， 因此这一步就是清除<code> LPSR</code> 寄存器。</p>
</li>
<li><p>调用<code>snvs_rtc_enable</code>函数使能 RTC，此函数会设置 <code>RTC_LPCR </code>寄存器。</p>
</li>
<li><p><code>devm_request_irq</code>函数请求RTC中断，中断服务函数为<code>snvs_rtc_irq_handler</code>， 用于 RTC 闹钟中断。</p>
</li>
<li><p>设置<code>rtc_class_ops</code>，并且调用<code>rtc_register_device</code>注册rtc子系统。</p>
</li>
</ol>
<h3><span id="3-2-2-rtc-class-ops-shi-li">3.2.2 rtc_class_ops实例</span><a href="#3-2-2-rtc-class-ops-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtc_class_ops</span> <span class="title">snvs_rtc_ops</span> =</span> &#123;</span><br><span class="line">	.read_time = snvs_rtc_read_time,</span><br><span class="line">	.set_time = snvs_rtc_set_time,</span><br><span class="line">	.read_alarm = snvs_rtc_read_alarm,</span><br><span class="line">	.set_alarm = snvs_rtc_set_alarm,</span><br><span class="line">	.alarm_irq_enable = snvs_rtc_alarm_irq_enable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-1-snvs-rtc-read-time">3.2.2.1 snvs_rtc_read_time</span><a href="#3-2-2-1-snvs-rtc-read-time" class="header-anchor">#</a></h4><p>获取rtc时间的细节详见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17759700.html">IMX6ULL裸机-RTC定时器</a>。</p>
<p><code>SNVS_SRTCMR[14:0]</code>代表<code>SRTC计数器</code>的高15位<br><code>SNVS_SRTCLR[31:15]</code>代表<code>SRTC计数器</code>的低17位<br>注意：是以 1970 年 1 月 1 日0点0分0秒为起点，加上经过的总秒数即可得到现在的时间点。<br><code>SNVS_HPCOMR[31]</code>, <code>NPSWA_EN</code>位，非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 1。<br><code>SNVS_LPCR[0]</code>, <code>SRTC_ENV</code>位，使能 RTC 计数器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPREGISTER_OFFSET	0x34</span></span><br><span class="line"><span class="comment">/* These register offsets are relative to LP (Low Power) range */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPCR		0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPSR		0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPSRTCMR		0x1c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPSRTCLR		0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPTAR		0x24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPPGDR		0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPCR_SRTC_ENV	(1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPCR_LPTA_EN	(1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPCR_LPWUI_EN	(1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPSR_LPTA		(1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SNVS_LPPGDR_INIT	0x41736166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CNTR_TO_SECS_SH		15</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">snvs_rtc_read_time</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> rtc_time *tm)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">snvs_rtc_data</span> *<span class="title">data</span> =</span> dev_get_drvdata(dev);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> time;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span> (data-&gt;clk) &#123;</span><br><span class="line">		ret = clk_enable(data-&gt;clk);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time = rtc_read_lp_counter(data);</span><br><span class="line">	rtc_time64_to_tm(time, tm);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (data-&gt;clk)</span><br><span class="line">		clk_disable(data-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read 64 bit timer register, which could be in inconsistent state */</span></span><br><span class="line"><span class="type">static</span> u64 <span class="title function_">rtc_read_lpsrt</span><span class="params">(<span class="keyword">struct</span> snvs_rtc_data *data)</span>&#123;</span><br><span class="line">	u32 msb, lsb;</span><br><span class="line">	regmap_read(data-&gt;regmap, data-&gt;offset + SNVS_LPSRTCMR, &amp;msb);</span><br><span class="line">	regmap_read(data-&gt;regmap, data-&gt;offset + SNVS_LPSRTCLR, &amp;lsb);</span><br><span class="line">	<span class="keyword">return</span> (u64)msb &lt;&lt; <span class="number">32</span> | lsb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read the secure real time counter, taking care to deal with the cases of the</span></span><br><span class="line"><span class="comment"> * counter updating while being read.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> u32 <span class="title function_">rtc_read_lp_counter</span><span class="params">(<span class="keyword">struct</span> snvs_rtc_data *data)</span>&#123;</span><br><span class="line">	u64 read1, read2;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> timeout = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* As expected, the registers might update between the read of the LSB</span></span><br><span class="line"><span class="comment">	 * reg and the MSB reg.  It&#x27;s also possible that one register might be</span></span><br><span class="line"><span class="comment">	 * in partially modified state as well.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	read1 = rtc_read_lpsrt(data);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		read2 = read1;</span><br><span class="line">		read1 = rtc_read_lpsrt(data);</span><br><span class="line">	&#125; <span class="keyword">while</span> (read1 != read2 &amp;&amp; --timeout);</span><br><span class="line">	<span class="keyword">if</span> (!timeout)</span><br><span class="line">		dev_err(&amp;data-&gt;rtc-&gt;dev, <span class="string">&quot;Timeout trying to get valid LPSRT Counter read\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* Convert 47-bit counter to 32-bit raw second count */</span></span><br><span class="line">	<span class="keyword">return</span> (u32) (read1 &gt;&gt; CNTR_TO_SECS_SH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rtc_time64_to_tm</span><span class="params">(<span class="type">time64_t</span> time, <span class="keyword">struct</span> rtc_time *tm)</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> month, year, secs;</span><br><span class="line">	<span class="type">int</span> days;</span><br><span class="line">	<span class="comment">/* time must be positive */</span></span><br><span class="line">	days = <span class="built_in">div_s64_rem</span>(time, <span class="number">86400</span>, &amp;secs);</span><br><span class="line">	<span class="comment">/* day of the week, 1970-01-01 was a Thursday */</span></span><br><span class="line">	tm-&gt;tm_wday = (days + <span class="number">4</span>) % <span class="number">7</span>;</span><br><span class="line">	year = <span class="number">1970</span> + days / <span class="number">365</span>;</span><br><span class="line">	days -= (year - <span class="number">1970</span>) * <span class="number">365</span></span><br><span class="line">		+ <span class="built_in">LEAPS_THRU_END_OF</span>(year - <span class="number">1</span>)</span><br><span class="line">		- <span class="built_in">LEAPS_THRU_END_OF</span>(<span class="number">1970</span> - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> (days &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		year -= <span class="number">1</span>;</span><br><span class="line">		days += <span class="number">365</span> + <span class="built_in">is_leap_year</span>(year);</span><br><span class="line">	&#125;</span><br><span class="line">	tm-&gt;tm_year = year - <span class="number">1900</span>;</span><br><span class="line">	tm-&gt;tm_yday = days + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (month = <span class="number">0</span>; month &lt; <span class="number">11</span>; month++) &#123;</span><br><span class="line">		<span class="type">int</span> newdays;</span><br><span class="line">		newdays = days - <span class="built_in">rtc_month_days</span>(month, year);</span><br><span class="line">		<span class="keyword">if</span> (newdays &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		days = newdays;</span><br><span class="line">	&#125;</span><br><span class="line">	tm-&gt;tm_mon = month;</span><br><span class="line">	tm-&gt;tm_mday = days + <span class="number">1</span>;</span><br><span class="line">	tm-&gt;tm_hour = secs / <span class="number">3600</span>;</span><br><span class="line">	secs -= tm-&gt;tm_hour * <span class="number">3600</span>;</span><br><span class="line">	tm-&gt;tm_min = secs / <span class="number">60</span>;</span><br><span class="line">	tm-&gt;tm_sec = secs - tm-&gt;tm_min * <span class="number">60</span>;</span><br><span class="line">	tm-&gt;tm_isdst = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<ol>
<li><code>rtc_read_lpsrt</code>函数RTC定时器寄存器，得到64位原始数据。让后将其转换成按秒计算单位。可以看到就是设置读取RTC寄存器信息。</li>
<li>调用<code>drivers\rtc\lib.c</code>的<code>rtc_time64_to_tm</code>将秒数转换成<code>rtc_time</code>, 也就是年月日单位。</li>
</ol>
<h4><span id="3-2-2-2-snvs-rtc-set-time">3.2.2.2 snvs_rtc_set_time</span><a href="#3-2-2-2-snvs-rtc-set-time" class="header-anchor">#</a></h4><p>设置时钟，和<code>snvs_rtc_read_time</code>同理，也是寄存器操作，就不展开细节分析。</p>
<h2><span id="3-3-ying-yong-ce-shi">3.3 应用测试</span><a href="#3-3-ying-yong-ce-shi" class="header-anchor">#</a></h2><h3><span id="3-3-1-du-qu-rtc-shi-jian">3.3.1 读取rtc时间</span><a href="#3-3-1-du-qu-rtc-shi-jian" class="header-anchor">#</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@imx6ull]~# </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Thu Jan  1 08:00:13 CST 1970</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-she-zhi-rtc-shi-jian">3.3.2 设置rtc时间</span><a href="#3-3-2-she-zhi-rtc-shi-jian" class="header-anchor">#</a></h3><p><img src="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>现在我要设置当前时间为 2023 年 8 月 31 日 18:13:00。<br><code>date -s &quot;2023-08-31 18:13:00&quot;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@imx6ull]~<span class="comment"># date -s &quot;2023-08-31 18:13:00&quot;</span></span><br><span class="line">Thu Aug 31 18:13:00 CST 2023</span><br></pre></td></tr></table></figure>

<p>注意我们使用<code>“date -s”</code>命令仅仅是将当前系统时间设置了，此时间还没有写入到RTC 芯片里面，因此系统重启以后时间又会丢失。我们需要将 当前的时间写入到 RTC 里面，这里要用到 <code>hwclock </code>命令，输入如下命令将系统时间写入到 RTC 里面：<br><code>hwclock -w</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm14krhzy00005kuf7i807lmy" data-title="字符设备驱动-RTC子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-Framebuffer子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-01T05:28:35.000Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-framebuffer">1 引入Framebuffer</a></li>
<li><a href="#2-framebuffer-qu-dong-jie-shao">2 Framebuffer驱动介绍</a><ul>
<li><a href="#2-1-framebuffer-she-bei-jie-dian">2.1 Framebuffer设备节点</a></li>
<li><a href="#2-2-framebuffer-kuang-jia">2.2 Framebuffer框架</a></li>
<li><a href="#2-3-framebuffer-shu-ju-jie-gou">2.3 Framebuffer数据结构</a><ul>
<li><a href="#2-3-1-fb-info">2.3.1 fb_info</a><ul>
<li><a href="#2-3-1-1-fb-ops">2.3.1.1 fb_ops</a></li>
<li><a href="#2-3-1-2-fb-var-screeninfo">2.3.1.2 fb_var_screeninfo</a><ul>
<li><a href="#2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu">2.3.1.2.1 引入可视屏幕和虚拟屏幕</a></li>
</ul>
</li>
<li><a href="#2-3-1-3-fb-fix-screeninfo">2.3.1.3 fb_fix_screeninfo</a></li>
<li><a href="#2-3-1-4-fb-bitfield">2.3.1.4 fb_bitfield</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-framebuffer-yuan-ma-fen-xi">2.4 Framebuffer源码分析</a><ul>
<li><a href="#2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng">2.4.1 编写fb驱动大致流程</a></li>
<li><a href="#2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai">2.4.2 fb子系统注册卸载</a><ul>
<li><a href="#2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu">2.4.2.1 fb注册卸载相关函数</a><ul>
<li><a href="#2-4-2-1-1-framebuffer-alloc">2.4.2.1.1 framebuffer_alloc</a></li>
<li><a href="#2-4-2-1-2-register-framebuffer">2.4.2.1.2 register_framebuffer</a></li>
<li><a href="#2-4-2-1-3-unregister-framebuffer">2.4.2.1.3 unregister_framebuffer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-3-fb-ops-fen-xi">2.4.3 fb_ops分析</a><ul>
<li><a href="#2-4-3-1-fb-open">2.4.3.1 fb_open</a></li>
<li><a href="#2-4-3-2-fb-write">2.4.3.2 fb_write</a></li>
<li><a href="#2-4-3-3-fb-mmap">2.4.3.3 fb_mmap</a></li>
<li><a href="#2-4-3-4-fb-ioctl">2.4.3.4 fb_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-framebuffer-qu-dong-shi-li">3 Framebuffer驱动实例</a><ul>
<li><a href="#3-1-ding-yi-fb-info-shi-li">3.1定义fb_info实例</a><ul>
<li><a href="#3-1-0-kong-zhi-qi-dts-pei-zhi">3.1.0 控制器dts配置</a></li>
<li><a href="#3-1-1-mxsfb-probe-guo-cheng-fen-xi">3.1.1 mxsfb_probe过程分析</a></li>
</ul>
</li>
<li><a href="#3-2-lcd-ping-mu-dts-miao-shu">3.2 LCD屏幕dts描述</a><ul>
<li><a href="#3-2-1-ping-mu-io-pei-zhi">3.2.1 屏幕 IO 配置</a></li>
<li><a href="#3-2-2-ping-mu-jie-dian">3.2.2 屏幕节点</a></li>
<li><a href="#3-2-3-bei-guang-jie-dian">3.2.3 背光节点</a><ul>
<li><a href="#3-2-3-1-backlight-she-zhi">3.2.3.1 backlight设置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-lcd-ce-shi">4 LCD测试</a><ul>
<li><a href="#4-1-shi-neng-linux-logo">4.1 使能 Linux logo</a></li>
<li><a href="#4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console">4.2 LCD 作为终端控制台console</a></li>
<li><a href="#4-3-lcd-bei-guang-diao-jie-ming-ling">4.3 LCD 背光调节命令</a></li>
<li><a href="#4-4-lcd-ping-mu-zi-dong-xi-mie">4.4 LCD屏幕自动熄灭</a><ul>
<li><a href="#4-1-1-an-jian-pan-huan-xing">4.1.1 按键盘唤醒</a></li>
<li><a href="#4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping">4.1.2 关闭10分钟自动熄屏</a></li>
</ul>
</li>
<li><a href="#4-5-ce-shi-dai-ma">4.5 测试代码</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-framebuffer">1 引入Framebuffer</span><a href="#1-yin-ru-framebuffer" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13152010.html">s3c2440裸机-LCD编程一、LCD硬件原理</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/">s3c2440裸机编程-LDC | Hexo (fuzidage.github.io)</a></p>
<p>介绍了LDC的基本原理。裸机 LCD 驱动编写流程如下：</p>
<ol>
<li>初始化 I.MX6U 的 eLCDIF 控制器，屏幕宽(width)、高(height)、<code>hspw、 hbp、hfp、vspw、vbp 和 vfp</code> 等信息。</li>
<li>初始化 LCD 像素时钟。</li>
<li>设置 RGBLCD 显存属性。</li>
<li>应用程序直接通过操作显存来操作 LCD，实现在 LCD 上显示字符、图片等信息。</li>
</ol>
<p>同理linux系统下也是希望应用程序来直接操作一块内存来实现实现在 LCD 上显示字符、图片等信息，Framebuffer就是用来干这件事的。<code>Framebuffer</code> 翻译过来就是帧缓冲，简称<code> fb</code>。</p>
<p>作用：把显示设备描述成一个缓冲区，允许应用程序通过帧缓冲定义好的接口访问这些图形设备，从而不用关心具体的硬件细节。</p>
<p>因此需要在底层<code>framebuffer框架</code>去对接具体的显示设备，显示设备控制器。</p>
<h1><span id="2-framebuffer-qu-dong-jie-shao">2 Framebuffer驱动介绍</span><a href="#2-framebuffer-qu-dong-jie-shao" class="header-anchor">#</a></h1><h2><span id="2-1-framebuffer-she-bei-jie-dian">2.1 Framebuffer设备节点</span><a href="#2-1-framebuffer-she-bei-jie-dian" class="header-anchor">#</a></h2><p>当我们编写好 LCD 驱动以后会生成一个名为<code>/dev/fbX(X=0~n)</code>的设备，应用程序通 过访问<code>/dev/fbX </code>这个设备就可以访问 LCD。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/0.png" alt="image"></p>
<h2><span id="2-2-framebuffer-kuang-jia">2.2 Framebuffer框架</span><a href="#2-2-framebuffer-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<ul>
<li><code>drivers/video/fbmem.c</code>：主要任务是创建<code>graphics类</code>、注册FB的字符设备驱动（主设备号是29）、提供<code>register_framebuffer</code>接口给具体framebuffer驱动编写着来注册fb设备的。</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FB_MAJOR		29   /* /dev/fb* framebuffers */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>drivers/video/fbsys.c</code>：是<code>fbmem.c</code>引出来的，处理fb在<code>/sys/class/graphics/fb0</code>目录下的一些属性文件的。</p>
</li>
<li><p><code>xxx_fb.c</code>: 具体的显示设备控制器驱动代码，dts描述对应的显示设备，控制器去驱动显示设备。</p>
</li>
</ul>
<h2><span id="2-3-framebuffer-shu-ju-jie-gou">2.3 Framebuffer数据结构</span><a href="#2-3-framebuffer-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-3-1-fb-info">2.3.1 fb_info</span><a href="#2-3-1-fb-info" class="header-anchor">#</a></h3><p>fb_info结构体记录了帧缓冲设备的全部信息，包括设备的设置参数、状态以及操作函数指针，对于每一个帧缓冲设备都必须对应一个fb_info结构体实例。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_t</span> count;</span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="type">int</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 互斥锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span> <span class="comment">/* 互斥锁，用于 fb_mmap 和 smem_*域*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span> <span class="comment">/* 当前可变参数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span> <span class="comment">/* 当前固定参数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span> <span class="comment">/* 当前显示器特性 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span> <span class="comment">/* 帧缓冲事件队列 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span> <span class="comment">/* 图像硬件映射 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span> <span class="comment">/* 光标硬件映射 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span> <span class="comment">/* 当前调色板 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span> <span class="comment">/* 当前模式列表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span> <span class="comment">/* 当前视频模式 */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT <span class="comment">/* 如果 LCD 支持背光的话 */</span></span></span><br><span class="line">	<span class="comment">/* assigned backlight device */</span></span><br><span class="line">	<span class="comment">/* set before framebuffer registration,</span></span><br><span class="line"><span class="comment">	remove after unregister */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">backlight_device</span> *<span class="title">bl_dev</span>;</span> <span class="comment">/* 背光设备 */</span></span><br><span class="line">	<span class="comment">/* Backlight level curve */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">bl_curve_mutex</span>;</span></span><br><span class="line">	u8 bl_curve[FB_BACKLIGHT_LEVELS];</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span> <span class="comment">/* 帧缓冲操作函数集 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span> <span class="comment">/* 父设备 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span> <span class="comment">/* 当前 fb 设备 */</span></span><br><span class="line">	<span class="type">int</span> class_flag; <span class="comment">/* 私有 sysfs 标志 */</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">char</span> __iomem *screen_base; <span class="comment">/* 虚拟内存基地址(屏幕显存) */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> screen_size; <span class="comment">/* 虚拟内存大小(屏幕显存大小) */</span></span><br><span class="line">	<span class="type">void</span> *pseudo_palette; <span class="comment">/* 伪 16 位调色板 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-1-fb-ops">2.3.1.1 fb_ops</span><a href="#2-3-1-1-fb-ops" class="header-anchor">#</a></h4><p>帧缓冲操作函数集,包含open,release,read,write等操作函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Frame buffer operations</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LOCKING <span class="doctag">NOTE:</span> those functions must _ALL_ be called with the console</span></span><br><span class="line"><span class="comment"> * semaphore held, this is the only suitable locking mechanism we have</span></span><br><span class="line"><span class="comment"> * in 2.6. Some may be called at interrupt time at this point though.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The exception to this is the debug related hooks.  Putting the fb</span></span><br><span class="line"><span class="comment"> * into a debug state (e.g. flipping to the kernel console) and restoring</span></span><br><span class="line"><span class="comment"> * it must be done in a lock-free manner, so low level drivers should</span></span><br><span class="line"><span class="comment"> * keep track of the initial console (if applicable) and may need to</span></span><br><span class="line"><span class="comment"> * perform direct, unlocked hardware writes in these hooks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/* open/release and usage marking */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span> (*fb_open)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">	<span class="type">int</span> (*fb_release)(<span class="keyword">struct</span> fb_info *info, <span class="type">int</span> user);</span><br><span class="line">	<span class="comment">/* For framebuffers with strange non linear layouts or that do not</span></span><br><span class="line"><span class="comment">	 * work with normal memory mapped access</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">ssize_t</span> (*fb_read)(<span class="keyword">struct</span> fb_info *info, <span class="type">char</span> __user *buf,</span><br><span class="line">			   <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">	<span class="type">ssize_t</span> (*fb_write)(<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="type">char</span> __user *buf,</span><br><span class="line">			    <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos);</span><br><span class="line">	<span class="comment">/* checks var and eventually tweaks it to something supported,</span></span><br><span class="line"><span class="comment">	 * DO NOT MODIFY PAR */</span></span><br><span class="line">	<span class="type">int</span> (*fb_check_var)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set the video mode according to info-&gt;var */</span></span><br><span class="line">	<span class="type">int</span> (*fb_set_par)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set color register */</span></span><br><span class="line">	<span class="type">int</span> (*fb_setcolreg)(<span class="type">unsigned</span> regno, <span class="type">unsigned</span> red, <span class="type">unsigned</span> green,</span><br><span class="line">			    <span class="type">unsigned</span> blue, <span class="type">unsigned</span> transp, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* set color registers in batch */</span></span><br><span class="line">	<span class="type">int</span> (*fb_setcmap)(<span class="keyword">struct</span> fb_cmap *cmap, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* blank display */</span></span><br><span class="line">	<span class="type">int</span> (*fb_blank)(<span class="type">int</span> blank, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* pan display */</span></span><br><span class="line">	<span class="type">int</span> (*fb_pan_display)(<span class="keyword">struct</span> fb_var_screeninfo *var, <span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* Draws a rectangle */</span></span><br><span class="line">	<span class="type">void</span> (*fb_fillrect) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_fillrect *rect);</span><br><span class="line">	<span class="comment">/* Copy data from area to another */</span></span><br><span class="line">	<span class="type">void</span> (*fb_copyarea) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_copyarea *region);</span><br><span class="line">	<span class="comment">/* Draws a image to the display */</span></span><br><span class="line">	<span class="type">void</span> (*fb_imageblit) (<span class="keyword">struct</span> fb_info *info, <span class="type">const</span> <span class="keyword">struct</span> fb_image *image);</span><br><span class="line">	<span class="comment">/* Draws cursor */</span></span><br><span class="line">	<span class="type">int</span> (*fb_cursor) (<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> fb_cursor *cursor);</span><br><span class="line">	<span class="comment">/* wait for blit idle, optional */</span></span><br><span class="line">	<span class="type">int</span> (*fb_sync)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* perform fb specific ioctl (optional) */</span></span><br><span class="line">	<span class="type">int</span> (*fb_ioctl)(<span class="keyword">struct</span> fb_info *info, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line">	<span class="type">int</span> (*fb_compat_ioctl)(<span class="keyword">struct</span> fb_info *info, <span class="type">unsigned</span> cmd,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">	<span class="comment">/* perform fb specific mmap */</span></span><br><span class="line">	<span class="type">int</span> (*fb_mmap)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> vm_area_struct *vma);</span><br><span class="line">	<span class="comment">/* get capability given var */</span></span><br><span class="line">	<span class="type">void</span> (*fb_get_caps)(<span class="keyword">struct</span> fb_info *info, <span class="keyword">struct</span> fb_blit_caps *caps,</span><br><span class="line">			    <span class="keyword">struct</span> fb_var_screeninfo *var);</span><br><span class="line">	<span class="comment">/* teardown any resources to do with this framebuffer */</span></span><br><span class="line">	<span class="type">void</span> (*fb_destroy)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="comment">/* called at KDB enter and leave time to prepare the console */</span></span><br><span class="line">	<span class="type">int</span> (*fb_debug_enter)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">	<span class="type">int</span> (*fb_debug_leave)(<span class="keyword">struct</span> fb_info *info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-2-fb-var-screeninfo">2.3.1.2 fb_var_screeninfo</span><a href="#2-3-1-2-fb-var-screeninfo" class="header-anchor">#</a></h4><p>记录用户<strong>可修改的显示控制器参数</strong>，包括了屏幕的分辨率和每个像素点的比特数bpp,pixclock等。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> &#123;</span></span><br><span class="line">	__u32 xres;			<span class="comment">/* visible resolution		*/</span></span><br><span class="line">	__u32 yres;</span><br><span class="line">	__u32 xres_virtual;		<span class="comment">/* virtual resolution		*/</span></span><br><span class="line">	__u32 yres_virtual;</span><br><span class="line">	__u32 xoffset;			<span class="comment">/* offset from virtual to visible */</span></span><br><span class="line">	__u32 yoffset;			<span class="comment">/* resolution			*/</span></span><br><span class="line"></span><br><span class="line">	__u32 bits_per_pixel;		<span class="comment">/* guess what			*/</span></span><br><span class="line">	__u32 grayscale;		<span class="comment">/* 0 = color, 1 = grayscale,	*/</span></span><br><span class="line">					<span class="comment">/* &gt;1 = FOURCC			*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span>		<span class="comment">/* bitfield in fb mem if true color, */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span>	<span class="comment">/* else only length is significant */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span>	<span class="comment">/* transparency			*/</span>	</span><br><span class="line"></span><br><span class="line">	__u32 nonstd;			<span class="comment">/* != 0 Non standard pixel format */</span></span><br><span class="line"></span><br><span class="line">	__u32 activate;			<span class="comment">/* see FB_ACTIVATE_*		*/</span></span><br><span class="line"></span><br><span class="line">	__u32 height;			<span class="comment">/* height of picture in mm    */</span></span><br><span class="line">	__u32 width;			<span class="comment">/* width of picture in mm     */</span></span><br><span class="line"></span><br><span class="line">	__u32 accel_flags;		<span class="comment">/* (OBSOLETE) see fb_info.flags */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Timing: All values in pixclocks, except pixclock (of course) */</span></span><br><span class="line">	__u32 pixclock;			<span class="comment">/* pixel clock in ps (pico seconds) */</span></span><br><span class="line">	__u32 left_margin;		<span class="comment">/* time from sync to picture	*/</span></span><br><span class="line">	__u32 right_margin;		<span class="comment">/* time from picture to sync	*/</span></span><br><span class="line">	__u32 upper_margin;		<span class="comment">/* time from sync to picture	*/</span></span><br><span class="line">	__u32 lower_margin;</span><br><span class="line">	__u32 hsync_len;		<span class="comment">/* length of horizontal sync	*/</span></span><br><span class="line">	__u32 vsync_len;		<span class="comment">/* length of vertical sync	*/</span></span><br><span class="line">	__u32 sync;			<span class="comment">/* see FB_SYNC_*		*/</span></span><br><span class="line">	__u32 vmode;			<span class="comment">/* see FB_VMODE_*		*/</span></span><br><span class="line">	__u32 rotate;			<span class="comment">/* angle we rotate counter clockwise */</span></span><br><span class="line">	__u32 colorspace;		<span class="comment">/* colorspace for FOURCC-based modes */</span></span><br><span class="line">	__u32 reserved[<span class="number">4</span>];		<span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5><span id="2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu">2.3.1.2.1 引入可视屏幕和虚拟屏幕</span><a href="#2-3-1-2-1-yin-ru-ke-shi-ping-mu-he-xu-ni-ping-mu" class="header-anchor">#</a></h5><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)可视屏幕：LCD分辨率，这是硬件相关的。比如：LCD屏幕的分辨率是<span class="number">800</span>x480，那可视屏幕的最大分辨率就是<span class="number">800</span>x480；</span><br><span class="line">(<span class="number">2</span>)虚拟屏幕：我们在内核中开辟的帧缓冲区的大小。比如：屏幕分辨率是<span class="number">800</span>x480，但是我们可以将帧缓冲区开辟成<span class="number">1920</span>x1080，</span><br><span class="line">    在刷新屏幕时可以直接将<span class="number">1080</span>p的图像一次性刷新到帧缓冲区中；</span><br><span class="line">(<span class="number">3</span>)虚拟屏到可视屏的偏移量：虚拟屏大小是超过可视屏幕的大小，偏移量决定了可视屏显示虚拟屏的哪一个部分；</span><br><span class="line">(<span class="number">4</span>)总结：通过改变虚拟屏到可视屏的偏移量，可以将虚拟屏的不同部分图像显示到可视屏中，而不需要每次都刷新帧缓冲区；</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-3-fb-fix-screeninfo">2.3.1.3 fb_fix_screeninfo</span><a href="#2-3-1-3-fb-fix-screeninfo" class="header-anchor">#</a></h4><p>记录了用户<strong>不能修改的显示控制器的参数</strong>，比如说屏幕缓冲区的物理地址、长度。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];            <span class="comment">/* identification string eg &quot;TT Builtin&quot; */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> smem_start;    <span class="comment">/* Start of frame buffer mem */</span></span><br><span class="line">                    <span class="comment">/* (physical address) */</span></span><br><span class="line">    __u32 smem_len;            <span class="comment">/* Length of frame buffer mem */</span></span><br><span class="line">    __u32 type;            <span class="comment">/* see FB_TYPE_*        */</span></span><br><span class="line">    __u32 type_aux;            <span class="comment">/* Interleave for interleaved Planes */</span></span><br><span class="line">    __u32 visual;            <span class="comment">/* see FB_VISUAL_*        */</span> </span><br><span class="line">    __u16 xpanstep;            <span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">    __u16 ypanstep;            <span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">    __u16 ywrapstep;        <span class="comment">/* zero if no hardware ywrap    */</span></span><br><span class="line">    __u32 line_length;        <span class="comment">/* length of a line in bytes    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmio_start;    <span class="comment">/* Start of Memory Mapped I/O   */</span></span><br><span class="line">                    <span class="comment">/* (physical address) */</span></span><br><span class="line">    __u32 mmio_len;            <span class="comment">/* Length of Memory Mapped I/O  */</span></span><br><span class="line">    __u32 accel;            <span class="comment">/* Indicate to driver which    */</span></span><br><span class="line">                    <span class="comment">/*  specific chip/card we have    */</span></span><br><span class="line">    __u16 capabilities;        <span class="comment">/* see FB_CAP_*            */</span></span><br><span class="line">    __u16 reserved[<span class="number">2</span>];        <span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-1-4-fb-bitfield">2.3.1.4 fb_bitfield</span><a href="#2-3-1-4-fb-bitfield" class="header-anchor">#</a></h4><p>描述每一像素缓冲区的组织方式，包括域偏移、位域长度和MSB指示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> &#123;</span></span><br><span class="line">    __u32 offset;            <span class="comment">/* beginning of bitfield    */</span></span><br><span class="line">    __u32 length;            <span class="comment">/* length of bitfield        */</span></span><br><span class="line">    __u32 msb_right;        <span class="comment">/* != 0 : Most significant bit is */</span> </span><br><span class="line">                    <span class="comment">/* right */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-framebuffer-yuan-ma-fen-xi">2.4 Framebuffer源码分析</span><a href="#2-4-framebuffer-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3><span id="2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng">2.4.1 编写fb驱动大致流程</span><a href="#2-4-1-bian-xie-fb-qu-dong-da-zhi-liu-cheng" class="header-anchor">#</a></h3><ol>
<li>构建fb_info结构体</li>
<li><code>register_framebuffer</code>注册<code>fb_info</code>到<code>fb框架</code>中，驱动框架会自动创建<code>/dev/fbx</code>设备节点</li>
<li>app通过open、ioctl等函数接口去操作设备节点<code>/dev/fb0</code>，驱动框架就会调用fb_info实例化中对应的open、ioctl接口去完成具体的硬件操作。</li>
</ol>
<h3><span id="2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai">2.4.2 fb子系统注册卸载</span><a href="#2-4-2-fb-zi-xi-tong-zhu-ce-xie-zai" class="header-anchor">#</a></h3><p>如果定义了<code>MODULE</code>宏就表示要fb子系统单独编译成ko文件，否则用<code>subsys_initcall</code>编译进内核。入口在<code>drivers\video\fbdev\core\fbmem.c</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<ol>
<li><p>创建proc条目<code>/proc/fb</code></p>
</li>
<li><p>注册成字符设备，fb主设备号定义在<code>include\uapi\linux\major.h</code></p>
<p><code>#define FB_MAJOR		29   /* /dev/fb* framebuffers */</code></p>
</li>
<li><p>建立<code>graphics</code>类。</p>
</li>
</ol>
<h4><span id="2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu">2.4.2.1 fb注册卸载相关函数</span><a href="#2-4-2-1-fb-zhu-ce-xie-zai-xiang-guan-han-shu" class="header-anchor">#</a></h4><h5><span id="2-4-2-1-1-framebuffer-alloc">2.4.2.1.1 framebuffer_alloc</span><a href="#2-4-2-1-1-framebuffer-alloc" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> fb_info *<span class="title function_">framebuffer_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//计算私有数据起始地址需要补齐的字节数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BYTES_PER_LONG (BITS_PER_LONG/8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PADDING (BYTES_PER_LONG - (sizeof(struct fb_info) % BYTES_PER_LONG))</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> fb_info_size = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		fb_info_size += PADDING;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//申请内存</span></span><br><span class="line">	p = kzalloc(fb_info_size + size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	info = (<span class="keyword">struct</span> fb_info *) p;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将申请的私有数据的地址赋值给info-&gt;par</span></span><br><span class="line">	<span class="keyword">if</span> (size)</span><br><span class="line">		info-&gt;par = p + fb_info_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设备的父节点</span></span><br><span class="line">	info-&gt;device = dev;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FB_BACKLIGHT</span></span><br><span class="line">	mutex_init(&amp;info-&gt;bl_curve_mutex);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> info;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> PADDING</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> BYTES_PER_LONG</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1)famebuffer_alloc函数是用来申请一个struct fb_info结构体的，传参的size是设备私有数据的大小；</span><br><span class="line">(2)申请sizeof(struct fb_info) + PADDING + size大小的空间分配给fb_info结构体类型的指针info，</span><br><span class="line">	加上PADDING 字节是为了后面的设备私有数据保持BYTES_PER_LONG字节对齐；</span><br><span class="line">(3)将fb_info结构体后面size大小且BYTES_PER_LONG 字节的设备私有数据地址赋值info-&gt;par;</span><br><span class="line">(4)将传入的参数dev赋值给info-&gt;device，作为父设备；</span><br><span class="line">(5)返回创建好的struct fb_into结构体指针info；</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-1-2-register-framebuffer">2.4.2.1.2 register_framebuffer</span><a href="#2-4-2-1-2-register-framebuffer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_framebuffer</span><span class="params">(<span class="keyword">struct</span> fb_info *fb_info)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> <span class="title">mode</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查已经注册的帧缓冲设备是否已经达到上限</span></span><br><span class="line">	<span class="keyword">if</span> (num_registered_fb == FB_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ENXIO;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断 fb_ info-&gt;flags 标志中关于控制器大小端的设置是否正确</span></span><br><span class="line">	<span class="keyword">if</span> (fb_check_foreignness(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在registered_fb数组中找一个空闲的变量</span></span><br><span class="line">	num_registered_fb++;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; FB_MAX; i++)</span><br><span class="line">		<span class="keyword">if</span> (!registered_fb[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将申请到的变量在数组中的下标赋值给fb_info-&gt;node</span></span><br><span class="line">	fb_info-&gt;node = i;</span><br><span class="line">		</span><br><span class="line">	mutex_init(&amp;fb_info-&gt;lock);</span><br><span class="line">	mutex_init(&amp;fb_info-&gt;mm_lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建帧缓冲设备</span></span><br><span class="line">	fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,</span><br><span class="line">				     MKDEV(FB_MAJOR, i), <span class="literal">NULL</span>, <span class="string">&quot;fb%d&quot;</span>, i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(fb_info-&gt;dev)) &#123;</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Unable to create device for framebuffer %d; errno = %ld\n&quot;</span>, </span><br><span class="line">               i, PTR_ERR(fb_info-&gt;dev));</span><br><span class="line">		fb_info-&gt;dev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//初始化帧缓冲设备，创建更多设备属性文件</span></span><br><span class="line">		fb_init_device(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化fb_info-&gt;pixmap，该变量的作用是将用于显示的硬件无关数据转换为设备需要的格式</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;pixmap.addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		fb_info-&gt;pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (fb_info-&gt;pixmap.addr) &#123;</span><br><span class="line">			fb_info-&gt;pixmap.size = FBPIXMAPSIZE;</span><br><span class="line">			fb_info-&gt;pixmap.buf_align = <span class="number">1</span>;</span><br><span class="line">			fb_info-&gt;pixmap.scan_align = <span class="number">1</span>;</span><br><span class="line">			fb_info-&gt;pixmap.access_align = <span class="number">32</span>;</span><br><span class="line">			fb_info-&gt;pixmap.flags = FB_PIXMAP_DEFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	fb_info-&gt;pixmap.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_x)</span><br><span class="line">		fb_info-&gt;pixmap.blit_x = ~(u32)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_y)</span><br><span class="line">		fb_info-&gt;pixmap.blit_y = ~(u32)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化显示模式链表 fb_ info-&gt;modelist</span></span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;modelist.prev || !fb_info-&gt;modelist.next)</span><br><span class="line">		INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据fb_info-&gt;var设置一个 mode</span></span><br><span class="line">	fb_var_to_videomode(&amp;mode, &amp;fb_info-&gt;var);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将该mode添加到fb_info-&gt;modelist中</span></span><br><span class="line">	fb_add_videomode(&amp;mode, &amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将fb_info注册到registered_fb结构体中</span></span><br><span class="line">	registered_fb[i] = fb_info;</span><br><span class="line"></span><br><span class="line">	event.info = fb_info;</span><br><span class="line">	<span class="keyword">if</span> (!lock_fb_info(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//〕通知发生了FB_EVENT_FB_REGISTERED事件(帧缓冲设备注册事件)</span></span><br><span class="line">	fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &amp;event);</span><br><span class="line">	unlock_fb_info(fb_info);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-1-3-unregister-framebuffer">2.4.2.1.3 unregister_framebuffer</span><a href="#2-4-2-1-3-unregister-framebuffer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">unregister_framebuffer</span><span class="params">(<span class="keyword">struct</span> fb_info *fb_info)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span></span><br><span class="line">	<span class="type">int</span> i, ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//检查传入的fb_info是否已经注册过</span></span><br><span class="line">	i = fb_info-&gt;node;</span><br><span class="line">	<span class="keyword">if</span> (!registered_fb[i]) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!lock_fb_info(fb_info))</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	event.info = fb_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通知发生FB_EVENT_FB_UNBIND事件，绑定了该帧缓冲设备的都解绑</span></span><br><span class="line">	ret = fb_notifier_call_chain(FB_EVENT_FB_UNBIND, &amp;event);</span><br><span class="line">	unlock_fb_info(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		ret = -EINVAL;</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//释放掉申请的fb_info-&gt;pixmap.addr</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;pixmap.addr &amp;&amp;</span><br><span class="line">	    (fb_info-&gt;pixmap.flags &amp; FB_PIXMAP_DEFAULT))</span><br><span class="line">		kfree(fb_info-&gt;pixmap.addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁fb_info-&gt;modelist模式链表</span></span><br><span class="line">	fb_destroy_modelist(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将占用的registered_fb数组中的变量置为NULL，表示空闲</span></span><br><span class="line">	registered_fb[i]=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//内核中注册的帧缓冲设备数量减一</span></span><br><span class="line">	num_registered_fb--;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁点帧缓冲设备的属性文件</span></span><br><span class="line">	fb_cleanup_device(fb_info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//销毁掉帧缓冲设备</span></span><br><span class="line">	device_destroy(fb_class, MKDEV(FB_MAJOR, i));</span><br><span class="line">	event.info = fb_info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通知发生了FB_EVENT_FB_UNREGISTERED事件，表示该帧缓冲设备已经被注销掉</span></span><br><span class="line">	fb_notifier_call_chain(FB_EVENT_FB_UNREGISTERED, &amp;event);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果fb_info结构体中有销毁函数就调用销毁函数</span></span><br><span class="line">	<span class="comment">/* this may free fb info */</span></span><br><span class="line">	<span class="keyword">if</span> (fb_info-&gt;fbops-&gt;fb_destroy)</span><br><span class="line">		fb_info-&gt;fbops-&gt;fb_destroy(fb_info);</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-3-fb-ops-fen-xi">2.4.3  fb_ops分析</span><a href="#2-4-3-fb-ops-fen-xi" class="header-anchor">#</a></h3><p><code>fb_ops</code>中的操作函数属于框架部分，并不和具体的硬件相关，在进行一些处理后最后都是调用<code>struct fb_info</code>结构体中<code>fb_ops</code>定义的操作方法；</p>
<p>!<img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="2-4-3-1-fb-open">2.4.3.1 fb_open</span><a href="#2-4-3-1-fb-open" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fb_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">__<span class="title function_">acquires</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">__<span class="title function_">releases</span><span class="params">(&amp;info-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(inode);</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span>;</span></span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断次设备号是否在合法范围</span></span><br><span class="line">	<span class="keyword">if</span> (fbidx &gt;= FB_MAX)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据次设备号找到对应的struct fb_info结构体指针</span></span><br><span class="line">	info = registered_fb[fbidx];</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="comment">//如果数组下标fbidx的变量是NULL，手动加载帧缓冲设备</span></span><br><span class="line">		request_module(<span class="string">&quot;fb%d&quot;</span>, fbidx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//再次从registered_fb数组中获取对应的struct fb_info结构体指针</span></span><br><span class="line">	info = registered_fb[fbidx];</span><br><span class="line">	<span class="keyword">if</span> (!info)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	mutex_lock(&amp;info-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (!try_module_get(info-&gt;fbops-&gt;owner)) &#123;</span><br><span class="line">		res = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将struct fb_info结构体指针保存到struct file结构体的私有数据指针中，后续的接口会用到</span></span><br><span class="line">	file-&gt;private_data = info;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用帧缓冲设备驱动的fb_open函数</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_open) &#123;</span><br><span class="line">		res = info-&gt;fbops-&gt;fb_open(info,<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (res)</span><br><span class="line">			module_put(info-&gt;fbops-&gt;owner);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;info-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-3-2-fb-write">2.4.3.2 fb_write</span><a href="#2-4-3-2-fb-write" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">fb_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span>&#123;</span><br><span class="line">	<span class="comment">//显示的偏移量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> p = *ppos;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取到设备节点的struct inode结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从inode节点中获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(inode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//以次设备号为下标在registered_fb数组中获取到对应的struct fb_info结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];</span><br><span class="line">	</span><br><span class="line">	u32 *buffer, *src;</span><br><span class="line">	u32 __iomem *dst;</span><br><span class="line">	<span class="type">int</span> c, i, cnt = <span class="number">0</span>, err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> total_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!info || !info-&gt;screen_base)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;state != FBINFO_STATE_RUNNING)</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果帧缓冲设备驱动中的struct fb_ops中有定义写帧缓冲的方法就执行</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_write)</span><br><span class="line">		<span class="keyword">return</span> info-&gt;fbops-&gt;fb_write(info, buf, count, ppos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*************执行通用的写帧缓冲的方法*************/</span></span><br><span class="line">	<span class="comment">//虚拟内存的大小</span></span><br><span class="line">	total_size = info-&gt;screen_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (total_size == <span class="number">0</span>)</span><br><span class="line">		total_size = info-&gt;fix.smem_len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p &gt; total_size)</span><br><span class="line">		<span class="keyword">return</span> -EFBIG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (count &gt; total_size) &#123;</span><br><span class="line">		err = -EFBIG;</span><br><span class="line">		count = total_size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查偏移量加上写入数据的大小是否超过虚拟内存的大小</span></span><br><span class="line">	<span class="keyword">if</span> (count + p &gt; total_size) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			err = -ENOSPC;</span><br><span class="line"></span><br><span class="line">		count = total_size - p;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buffer = kmalloc((count &gt; PAGE_SIZE) ? PAGE_SIZE : count,</span><br><span class="line">			 GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buffer)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//得到要写入帧缓冲区的起始地址:帧缓冲虚拟起始地址加上偏移量</span></span><br><span class="line">	dst = (u32 __iomem *) (info-&gt;screen_base + p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对于某些帧缓冲设备来说，必须等待它完成之前的显示处理操作，</span></span><br><span class="line">	<span class="comment">//才能继续向帧缓冲中送入显示数据，该方t法用于该过程的同步</span></span><br><span class="line">	<span class="keyword">if</span> (info-&gt;fbops-&gt;fb_sync)</span><br><span class="line">		info-&gt;fbops-&gt;fb_sync(info);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向帧缓冲写入count个字节数据，如果写入的数据超过一个页的大小，则分多次写入</span></span><br><span class="line">	<span class="keyword">while</span> (count) &#123;</span><br><span class="line">		<span class="comment">//将预写数据依次读到buffer中，每次写数据不超过PAGE_SIZE大小</span></span><br><span class="line">		c = (count &gt; PAGE_SIZE) ? PAGE_SIZE : count;</span><br><span class="line">		src = buffer;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//把数据从用户空间拷贝到内核空间</span></span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(src, buf, c)) &#123;</span><br><span class="line">			err = -EFAULT;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将数据写入到目标帧缓冲区地址</span></span><br><span class="line">		<span class="keyword">for</span> (i = c &gt;&gt; <span class="number">2</span>; i--; )</span><br><span class="line">			fb_writel(*src++, dst++);</span><br><span class="line">		<span class="keyword">if</span> (c &amp; <span class="number">3</span>) &#123;</span><br><span class="line">			u8 *src8 = (u8 *) src;</span><br><span class="line">			u8 __iomem *dst8 = (u8 __iomem *) dst;</span><br><span class="line">			<span class="keyword">for</span> (i = c &amp; <span class="number">3</span>; i--; )</span><br><span class="line">				fb_writeb(*src8++, dst8++);</span><br><span class="line">			dst = (u32 __iomem *) dst8;</span><br><span class="line">		&#125;</span><br><span class="line">		*ppos += c;</span><br><span class="line">		buf += c;</span><br><span class="line">		cnt += c;</span><br><span class="line">		count -= c;</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(buffer);</span><br><span class="line">	<span class="keyword">return</span> (cnt) ? cnt : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-3-3-fb-mmap">2.4.3.3 fb_mmap</span><a href="#2-4-3-3-fb-mmap" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fb_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct * vma)</span>&#123;</span><br><span class="line">	<span class="comment">//获取次设备号</span></span><br><span class="line">	<span class="type">int</span> fbidx = iminor(file-&gt;f_path.dentry-&gt;d_inode);</span><br><span class="line">	<span class="comment">//根据次设备号获取到struct fb_info 结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">info</span> =</span> registered_fb[fbidx];</span><br><span class="line">	<span class="comment">//得到驱动的fbops操作方法</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fb</span> =</span> info-&gt;fbops;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> off;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line">	u32 len;</span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_pgoff &gt; (~<span class="number">0UL</span> &gt;&gt; PAGE_SHIFT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	off = vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;</span><br><span class="line">	<span class="keyword">if</span> (!fb)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	mutex_lock(&amp;info-&gt;mm_lock);</span><br><span class="line">	<span class="comment">//如果fb_ops中实现了mmap方法，则调用之</span></span><br><span class="line">	<span class="keyword">if</span> (fb-&gt;fb_mmap) &#123;</span><br><span class="line">		<span class="type">int</span> res;</span><br><span class="line">		res = fb-&gt;fb_mmap(info, vma);</span><br><span class="line">		mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*******下面是通用的mmap方法********/</span></span><br><span class="line">	<span class="comment">/* 获取映射帧缓冲的物理起始地址和长度 */</span></span><br><span class="line">	start = info-&gt;fix.smem_start;</span><br><span class="line">	len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.smem_len);</span><br><span class="line">	<span class="keyword">if</span> (off &gt;= len) &#123;</span><br><span class="line">		<span class="comment">/* 如果off大于帧缓冲长度．则认为映射的是内存映射IO */</span></span><br><span class="line">		off -= len;</span><br><span class="line">		<span class="keyword">if</span> (info-&gt;var.accel_flags) &#123;</span><br><span class="line">			mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取内存映射IO的物理起始地址和长度</span></span><br><span class="line">		start = info-&gt;fix.mmio_start;</span><br><span class="line">		len = PAGE_ALIGN((start &amp; ~PAGE_MASK) + info-&gt;fix.mmio_len);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;info-&gt;mm_lock);</span><br><span class="line">	<span class="comment">//保证页对齐</span></span><br><span class="line">	start &amp;= PAGE_MASK;</span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start + off) &gt; len)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="comment">//现在off表示映射设备内存实际的物理地址</span></span><br><span class="line">	off += start;</span><br><span class="line">	vma-&gt;vm_pgoff = off &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="comment">/* This is an IO map - tell maydump to skip this VMA */</span></span><br><span class="line">	vma-&gt;vm_flags |= VM_IO | VM_RESERVED;</span><br><span class="line">	<span class="comment">//置页保护标识</span></span><br><span class="line">	fb_pgprotect(file, vma, off);</span><br><span class="line">	<span class="comment">//建立从物理页帧号为 off》PAGE SH 工FT的物理内存，到虚拟地址为 vma-&gt;vm start 、</span></span><br><span class="line">	<span class="comment">//大小为 vma-&gt;vm_end - vma-&gt;vm_start 、页保护标志为 vma-&gt;vm_page_prot的映射</span></span><br><span class="line">	<span class="keyword">if</span> (io_remap_pfn_range(vma, vma-&gt;vm_start, off &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			     vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="2-4-3-4-fb-ioctl">2.4.3.4 fb_ioctl</span><a href="#2-4-3-4-fb-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>FBIOGET_VSCREENINFO</td>
<td>获取屏幕可变参数</td>
</tr>
<tr>
<td>FBIOPUT_VSCREENINFO</td>
<td>设置屏幕可变参数</td>
</tr>
<tr>
<td>FBIOGET_FSCREENINFO</td>
<td>获取屏幕固定参数</td>
</tr>
<tr>
<td>FBIOPUTCMAP</td>
<td>设置颜色表</td>
</tr>
<tr>
<td>FBIOGETCMAP</td>
<td>获取颜色表</td>
</tr>
<tr>
<td>FBIOPAN_DISPLAY</td>
<td>动视窗显示</td>
</tr>
<tr>
<td>FBIO_CURSOR</td>
<td>光标设置，目前不支持</td>
</tr>
<tr>
<td>FBIOGET_CON2FBMAP</td>
<td>获取指定帧缓冲控制台对应的帧缓冲设备</td>
</tr>
<tr>
<td>FBIOPUT_CON2FBMAP</td>
<td>置指定的帧缓冲控制台对应的帧缓冲设备</td>
</tr>
<tr>
<td>FBIOBLANK</td>
<td>显示空白</td>
</tr>
</tbody></table>
<h1><span id="3-framebuffer-qu-dong-shi-li">3 Framebuffer驱动实例</span><a href="#3-framebuffer-qu-dong-shi-li" class="header-anchor">#</a></h1><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h2><span id="3-1-ding-yi-fb-info-shi-li">3.1定义fb_info实例</span><a href="#3-1-ding-yi-fb-info-shi-li" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>以飞思卡尔nxp的LCD控制器来说，叫做<code>lcdif</code>。位于<code>drivers/video/fbdev/mxsfb.c</code>,以像素时钟模式为例：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<h3><span id="3-1-0-kong-zhi-qi-dts-pei-zhi">3.1.0 控制器dts配置</span><a href="#3-1-0-kong-zhi-qi-dts-pei-zhi" class="header-anchor">#</a></h3><p>打开<code>imx6ull.dtsi</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lcdif: lcdif@<span class="number">021</span>c8000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx6u  l-lcdif&quot;</span>, <span class="string">&quot;fsl,imx28-lcdif&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x021c8000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">5</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        clocks = &lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_DUMMY&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;pix&quot;</span>, <span class="string">&quot;axi&quot;</span>, <span class="string">&quot;disp_axi&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>compatible</code>匹配，<code>probe</code>执行。</p>
<h3><span id="3-1-1-mxsfb-probe-guo-cheng-fen-xi">3.1.1 mxsfb_probe过程分析</span><a href="#3-1-1-mxsfb-probe-guo-cheng-fen-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxsfb_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">of_id</span> =</span></span><br><span class="line">			of_match_device(mxsfb_dt_ids, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxsfb_info</span> *<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fb_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line">	<span class="type">int</span> irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> gpio, ret;</span><br><span class="line">	<span class="keyword">if</span> (of_id)</span><br><span class="line">		pdev-&gt;id_entry = of_id-&gt;data;</span><br><span class="line">	gpio = of_get_named_gpio(pdev-&gt;dev.of_node, <span class="string">&quot;enable-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (gpio == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">return</span> -EPROBE_DEFER;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(gpio)) &#123;</span><br><span class="line">		ret = devm_gpio_request_one(&amp;pdev-&gt;dev, gpio, GPIOF_OUT_INIT_LOW, <span class="string">&quot;lcd_pwr_en&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;faild to request gpio %d, ret = %d\n&quot;</span>, gpio, ret);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!res) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Cannot get memory IO resource\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	host = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mxsfb_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!host) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate IO resource\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	fb_info = framebuffer_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> fb_info), &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!fb_info) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to allocate fbdev\n&quot;</span>);</span><br><span class="line">		devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	host-&gt;fb_info = fb_info;</span><br><span class="line">	fb_info-&gt;par = host;</span><br><span class="line">	ret = devm_request_irq(&amp;pdev-&gt;dev, irq, mxsfb_irq_handler, <span class="number">0</span>,</span><br><span class="line">			  dev_name(&amp;pdev-&gt;dev), host);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;request_irq (%d) failed with error %d\n&quot;</span>,</span><br><span class="line">				irq, ret);</span><br><span class="line">		ret = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;base)) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;ioremap failed\n&quot;</span>);</span><br><span class="line">		ret = PTR_ERR(host-&gt;base);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line">	host-&gt;pdev = pdev;</span><br><span class="line">	platform_set_drvdata(pdev, host);</span><br><span class="line"></span><br><span class="line">	host-&gt;devdata = &amp;mxsfb_devdata[pdev-&gt;id_entry-&gt;driver_data];</span><br><span class="line">	host-&gt;clk_pix = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;pix&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_pix)) &#123;</span><br><span class="line">		host-&gt;clk_pix = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_pix);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;clk_axi = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;axi&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_axi)) &#123;</span><br><span class="line">		host-&gt;clk_axi = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_axi);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;clk_disp_axi = devm_clk_get(&amp;host-&gt;pdev-&gt;dev, <span class="string">&quot;disp_axi&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;clk_disp_axi)) &#123;</span><br><span class="line">		host-&gt;clk_disp_axi = <span class="literal">NULL</span>;</span><br><span class="line">		ret = PTR_ERR(host-&gt;clk_disp_axi);</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	host-&gt;reg_lcd = devm_regulator_get(&amp;pdev-&gt;dev, <span class="string">&quot;lcd&quot;</span>);<span class="comment">//电流整流:和电源管理有关，实现低功耗</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(host-&gt;reg_lcd))</span><br><span class="line">		host-&gt;reg_lcd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	fb_info-&gt;pseudo_palette = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(u32) * <span class="number">16</span>,</span><br><span class="line">					       GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!fb_info-&gt;pseudo_palette) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fb_release;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);</span><br><span class="line"></span><br><span class="line">	pm_runtime_enable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = mxsfb_init_fbinfo(host);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line"></span><br><span class="line">	mxsfb_dispdrv_init(pdev, fb_info);</span><br><span class="line">	<span class="keyword">if</span> (!host-&gt;dispdrv) &#123;</span><br><span class="line">		pinctrl = devm_pinctrl_get_select_default(&amp;pdev-&gt;dev);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(pinctrl)) &#123;</span><br><span class="line">			ret = PTR_ERR(pinctrl);</span><br><span class="line">			<span class="keyword">goto</span> fb_pm_runtime_disable;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!host-&gt;enabled) &#123;</span><br><span class="line">		writel(<span class="number">0</span>, host-&gt;base + LCDC_CTRL);</span><br><span class="line">		mxsfb_set_par(fb_info);</span><br><span class="line">		mxsfb_enable_controller(fb_info);</span><br><span class="line">		pm_runtime_get_sync(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = register_framebuffer(fb_info);</span><br><span class="line">	<span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to register framebuffer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fb_destroy;</span><br><span class="line">	&#125;</span><br><span class="line">	console_lock();</span><br><span class="line">	ret = fb_blank(fb_info, FB_BLANK_UNBLANK);</span><br><span class="line">	console_unlock();</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Failed to unblank framebuffer\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> fb_unregister;</span><br><span class="line">	&#125;</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;initialized\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fb_unregister:</span><br><span class="line">	unregister_framebuffer(fb_info);</span><br><span class="line">fb_destroy:</span><br><span class="line">	<span class="keyword">if</span> (host-&gt;enabled)</span><br><span class="line">		clk_disable_unprepare(host-&gt;clk_pix);</span><br><span class="line">	fb_destroy_modelist(&amp;fb_info-&gt;modelist);</span><br><span class="line">fb_pm_runtime_disable:</span><br><span class="line">	pm_runtime_disable(&amp;host-&gt;pdev-&gt;dev);</span><br><span class="line">	devm_kfree(&amp;pdev-&gt;dev, fb_info-&gt;pseudo_palette);</span><br><span class="line">fb_release:</span><br><span class="line">	framebuffer_release(fb_info);</span><br><span class="line">	devm_kfree(&amp;pdev-&gt;dev, host);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>host</code> 结构体指针变量，表示<code>LDCIF</code>控制器，包含Framebuffer设备详细信息，比如<code>时钟</code>、<code>eLCDIF</code> 控制器<code>寄存器基地址</code>、<code>fb_info </code>等。</p>
</li>
<li><p>从dts中提取<code>gpio, irq, res,时钟</code>等信息。初始化<code>host, fb_info</code>等结构体。</p>
</li>
<li><p><code>host-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</code>对io内存进行<code>ioremap</code>, 把<code>eLCDIF </code>控制器地址映射成虚拟地址。</p>
</li>
<li><p><code>mxsfb_init_fbinfo</code>:</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<ol>
<li><p>设置<code>eLCDIF</code>控制器具体的<code>fb_ops</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> fb_ops mxsfb_ops = &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.fb_check_var = mxsfb_check_var,</span><br><span class="line">	.fb_set_par = mxsfb_set_par,</span><br><span class="line">	.fb_setcolreg = mxsfb_setcolreg,</span><br><span class="line">	.fb_ioctl = mxsfb_ioctl,</span><br><span class="line">	.fb_blank = mxsfb_blank,</span><br><span class="line">	.fb_pan_display = mxsfb_pan_display,</span><br><span class="line">	.fb_mmap = mxsfb_mmap,</span><br><span class="line">	.fb_fillrect = cfb_fillrect,</span><br><span class="line">	.fb_copyarea = cfb_copyarea,</span><br><span class="line">	.fb_imageblit = cfb_imageblit,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从dts获取LCD 的各个参数信息，然后调用<code>mxsfb_map_videomem</code>申请framebuffer空间，也就是显存。</p>
</li>
</ol>
</li>
<li><p><code>fb_videomode_to_var</code>设置ldc的可变属性</p>
</li>
<li><p>设置控制器寄存器信息</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">writel(<span class="number">0</span>, host-&gt;<span class="keyword">base</span> + LCDC_CTRL);</span><br><span class="line">mxsfb_set_par(fb_info);</span><br><span class="line">mxsfb_enable_controller(fb_info);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>register_framebuffer </code>函数向 Linux 内核注册 <code>fb_info</code>。</p>
</li>
</ol>
<p>在<code>mxsfb.c</code>中已经定义了<code> eLCDIF</code> 控制器各个寄存器相比于基地址的偏移值：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_CTRL			0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_CTRL1			0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_CTRL2			0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_TRANSFER_COUNT		0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_TRANSFER_COUNT		0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_CUR_BUF			0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_NEXT_BUF		0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_CUR_BUF			0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_NEXT_BUF		0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_TIMING			0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL0			0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL1			0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL2			0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL3			0xa0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_VDCTRL4			0xb0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL0			0xc0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL1			0xd0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL2			0xe0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL3			0xf0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_DVICTRL4			0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_DATA			0x180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_DATA			0x1b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V4_DEBUG0			0x1d0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCDC_V3_DEBUG0			0x1f0</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-lcd-ping-mu-dts-miao-shu">3.2 LCD屏幕dts描述</span><a href="#3-2-lcd-ping-mu-dts-miao-shu" class="header-anchor">#</a></h2><h3><span id="3-2-1-ping-mu-io-pei-zhi">3.2.1 屏幕 IO 配置</span><a href="#3-2-1-ping-mu-io-pei-zhi" class="header-anchor">#</a></h3><p>除了<code>eLCDIF</code> 控制器，对LCD设备也需要进行描述，主要是引脚pinmux。比如<code>imx6ull-alientek-emmc.dts</code>这块板子对应的LCD屏幕使用引脚如下，<code>iomuxc </code>节点下有如下节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_dat: lcdifdatgrp &#123;<span class="comment">//数据引脚，24根，rgb888</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  <span class="number">0x79</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_lcdif_ctrl: lcdifctrlgrp &#123;<span class="comment">//控制引脚，hsync vsync pixclk en等...</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_LCD_CLK__LCDIF_CLK        <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    <span class="number">0x79</span></span><br><span class="line">                MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    <span class="number">0x79</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_pwm1: pwm1grp &#123;<span class="comment">//背光亮度</span></span><br><span class="line">        fsl,pins = &lt;</span><br><span class="line">                MX6UL_PAD_GPIO1_IO08__PWM1_OUT   <span class="number">0x110b0</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以及iomixc_snvs下有一个reset节点：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_lcdif_dat，为 RGB LCD 的 24 根数据线配置项</span><br><span class="line">pinctrl_lcdif_ctrl，RGB LCD 的 4 根控制线配置项，包括 CLK、 ENABLE、VSYNC 和 HSYNC</span><br><span class="line">pinctrl_pwm1，LCD 背光 PWM 引脚配置项</span><br></pre></td></tr></table></figure>

<p>可以看到控制和数据引脚的电器属性默认nxp都帮我们设置成了0x79。</p>
<h3><span id="3-2-2-ping-mu-jie-dian">3.2.2 屏幕节点</span><a href="#3-2-2-ping-mu-jie-dian" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&amp;lcdif &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_lcdif_dat <span class="comment">/* 使用到的 IO */</span></span><br><span class="line">            &amp;pinctrl_lcdif_ctrl</span><br><span class="line">            &amp;pinctrl_lcdif_reset&gt;;</span><br><span class="line">	display = &lt;&amp;display0&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	display0: display &#123; <span class="comment">/* LCD 属性信息 */</span></span><br><span class="line">		bits-per-pixel = &lt;<span class="number">16</span>&gt;; <span class="comment">/* 一个像素占用几个 bit */</span></span><br><span class="line">		bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line">		display-timings &#123;</span><br><span class="line">			native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">			timing0: timing0 &#123;</span><br><span class="line">				clock-frequency = &lt;<span class="number">9200000</span>&gt;; <span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">				hactive = &lt;<span class="number">480</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">				vactive = &lt;<span class="number">272</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">				hfront-porch = &lt;<span class="number">8</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">				hback-porch = &lt;<span class="number">4</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">				hsync-len = &lt;<span class="number">41</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">				vback-porch = &lt;<span class="number">2</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">				vfront-porch = &lt;<span class="number">4</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">				vsync-len = &lt;<span class="number">10</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line">				hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">				vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">				de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">				pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>display0 </code>子节点，描述 LCD 的参数信息，包括<code>bpp, bus-width</code>,时序特性，这些参数跟随具体的屏厂屏幕规格走。例如另一款屏幕<code>ATK7016(7 寸 1024*600)</code>屏幕：可以看到这款屏幕是<code>RGB888</code>的，<code>bpp是3byte</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">display0: display &#123;</span><br><span class="line">	bits-per-pixel = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 一个像素占用 24bit */</span></span><br><span class="line">	bus-width = &lt;<span class="number">24</span>&gt;; <span class="comment">/* 总线宽度 */</span></span><br><span class="line">	display-timings &#123;</span><br><span class="line">		native-mode = &lt;&amp;timing0&gt;; <span class="comment">/* 时序信息 */</span></span><br><span class="line">		timing0: timing0 &#123;</span><br><span class="line">			clock-frequency = &lt;<span class="number">51200000</span>&gt;;<span class="comment">/* LCD 像素时钟，单位 Hz */</span></span><br><span class="line">			hactive = &lt;<span class="number">1024</span>&gt;; <span class="comment">/* LCD X 轴像素个数 */</span></span><br><span class="line">			vactive = &lt;<span class="number">600</span>&gt;; <span class="comment">/* LCD Y 轴像素个数 */</span></span><br><span class="line">			hfront-porch = &lt;<span class="number">160</span>&gt;; <span class="comment">/* LCD hfp 参数 */</span></span><br><span class="line">			hback-porch = &lt;<span class="number">140</span>&gt;; <span class="comment">/* LCD hbp 参数 */</span></span><br><span class="line">			hsync-len = &lt;<span class="number">20</span>&gt;; <span class="comment">/* LCD hspw 参数 */</span></span><br><span class="line">			vback-porch = &lt;<span class="number">20</span>&gt;; <span class="comment">/* LCD vbp 参数 */</span></span><br><span class="line">			vfront-porch = &lt;<span class="number">12</span>&gt;; <span class="comment">/* LCD vfp 参数 */</span></span><br><span class="line">			vsync-len = &lt;<span class="number">3</span>&gt;; <span class="comment">/* LCD vspw 参数 */</span></span><br><span class="line">			hsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* hsync 数据线极性 */</span></span><br><span class="line">			vsync-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* vsync 数据线极性 */</span></span><br><span class="line">			de-active = &lt;<span class="number">1</span>&gt;; <span class="comment">/* de 数据线极性 */</span></span><br><span class="line">			pixelclk-active = &lt;<span class="number">0</span>&gt;; <span class="comment">/* clk 数据线先极性 */</span></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-bei-guang-jie-dian">3.2.3 背光节点</span><a href="#3-2-3-bei-guang-jie-dian" class="header-anchor">#</a></h3><p>LCD 背光要用到 <code>PWM1</code>，因此也要设置 <code>PWM1</code> 节点，如果背光只用简单的<code>gpio</code>，那么只能控制亮灭。无法控制亮度, 在<code>imx6ull.dtsi</code>文件中找到<code>pwm1</code>描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm1: pwm@<span class="number">02080000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02080000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">83</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_PWM1&gt;,</span><br><span class="line">			&lt;&amp;clks IMX6UL_CLK_PWM1&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	<span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>imx6ull 的 PWM 驱动文件为<code> drivers/pwm/pwm-imx.c</code>，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18299086">Linux下PWM子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统 | Hexo (fuzidage.github.io)</a>。只要会使用pwm1即可，打开<code>imx6ull-alientek-emmc.dts</code>这块板子：</p>
<p>往pwm1添加如下内容,设置好pwm1对应的引脚：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm1 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也就是<code>MX6UL_PAD_GPIO1_IO08__PWM1_OUT</code>，将<code>gpio1_8</code>设成pwm输出。</p>
<h4><span id="3-2-3-1-backlight-she-zhi">3.2.3.1 backlight设置</span><a href="#3-2-3-1-backlight-she-zhi" class="header-anchor">#</a></h4><p>我们还需要一个节点来将 <code>LCD 背光</code>和<code> PWM1_OUT</code> 连接起来。这个节点就是 <code>backlight</code> ， <code>backlight </code>节点描述可以参考 <code>Documentation/devicetree/indings/video/backlight/pwm-backlight.txt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">	compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">	pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;</span><br><span class="line">	brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;</span><br><span class="line">	<span class="keyword">default</span>-brightness-level = &lt;<span class="number">6</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>设置背 <code>8 级背光(0~7)</code>，分别为 <code>0、4、8、16、32、64、128、255</code>，对应占空比为 <code>0%、1.57%、3.13%、6.27%、12.55%、25.1%、50.19%、100%</code>，如果嫌少的话可以自行添加一 些其他的背光等级值。 </p>
</li>
<li><p>设置默认背光等级为 6，也就是<code> 50.19%</code>的亮度</p>
</li>
</ol>
<p>backlight 节点说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 节点名称要为“backlight”</span><br><span class="line">2. compatible 属性值要为“pwm-backlight”，因此可以通过在 Linux 内核中搜索 “ pwm-backlight ” </span><br><span class="line">	来查找PWM背光控制驱动程序 ， 文件为 drivers/video/backlight/pwm_bl.c</span><br><span class="line">3. pwms属性用于描述背光所使用的PWM以及PWM频率，比如本章我们要使用的pwm1， pwm 频率设置为 200Hz</span><br><span class="line">4. brightness-levels 属性描述亮度级别，范围为 0~255，0 表示 PWM 占空比为 0%，也就 是亮度最低，</span><br><span class="line">	255 表示 100%占空比，也就是亮度最高</span><br><span class="line">5. default-brightness-level 属性为默认亮度级别</span><br></pre></td></tr></table></figure>

<h1><span id="4-lcd-ce-shi">4 LCD测试</span><a href="#4-lcd-ce-shi" class="header-anchor">#</a></h1><h2><span id="4-1-shi-neng-linux-logo">4.1 使能 Linux logo</span><a href="#4-1-shi-neng-linux-logo" class="header-anchor">#</a></h2><p>Linux 内核启动的时候可以选择显示小企鹅 logo，一般默认关闭。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Graphics support</span><br><span class="line">		-&gt; Bootup <span class="title function_">logo</span> <span class="params">(LOGO [=y])</span></span><br><span class="line">                -&gt; Standard black and white Linux logo</span><br><span class="line">                -&gt; Standard 16-color Linux logo</span><br><span class="line">                -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure>

<p>三个选项分别对应黑白、16 位、24 位色彩格式的 logo，我们把这三个都选 中，都编译进 Linux 内核里面。</p>
<h2><span id="4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console">4.2 LCD 作为终端控制台console</span><a href="#4-2-lcd-zuo-wei-zhong-duan-kong-zhi-tai-console" class="header-anchor">#</a></h2><ol>
<li><p>u-boot中bootargs设置</p>
<p><code>setenv bootargs &#39;console=tty1 console=ttymxc0,115200 root=/dev/nfs rw nfsroot=192.168.1.250: /home/zuozhongkai/linux/nfs/rootfs ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0: off&#39;</code></p>
<p>第一次设置 <code>console=tty1</code>， 也就是设置 LCD 屏幕为控制台，第二遍又设置<code> console=ttymxc0,115200</code>，也就是设置串口也作为控制台。大家重启开发板就会发 现 LCD 和串口都会显示 Linux 启动 log 信息。</p>
</li>
<li><p>修改<code>/etc/inittab</code></p>
<p>添加下面这行，</p>
<p><code>tty1::askfirst:-/bin/sh</code></p>
</li>
</ol>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>   修改完成以后保存<code>/etc/inittab </code>并退出，然后重启开发板，重启以后开发板 LCD 屏幕最后一 行会显示下面一行语句:</p>
<p>   <code>Please press Enter to activate this console</code></p>
<p>   为什么请参考: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18019053">linux内核-4.rootfs构建移植</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/">Linux内核-rootfs构建移植 | Hexo (fuzidage.github.io)</a></p>
<p>   大家也可以接上一个 USB 键盘，Linux 内核默认已经使能了 USB 键盘驱动 了，因此可以直接使用 USB 键盘Enter键。</p>
<p>   当然也可以利用input子系统来用一个gpio按键做成Enter键。见: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18114268">linux驱动-17-input子系统</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统 | Hexo (fuzidage.github.io)</a></p>
<h2><span id="4-3-lcd-bei-guang-diao-jie-ming-ling">4.3 LCD 背光调节命令</span><a href="#4-3-lcd-bei-guang-diao-jie-ming-ling" class="header-anchor">#</a></h2><p>前面背光设备树节点设置了 8 个等级的背光调节，可以设置为<code> 0~7</code>，我 们可以通过设置背光等级来实现 LCD 背光亮度的调节：</p>
<p>   <code>/sys/devices/platform/backlight/backlight/backlight</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p><code>echo 7 &gt; brightness</code>设置亮度为<code>100%</code>，<code> echo 0 &gt;brightness</code>设置成熄灭背光。</p>
<h2><span id="4-4-lcd-ping-mu-zi-dong-xi-mie">4.4 LCD屏幕自动熄灭</span><a href="#4-4-lcd-ping-mu-zi-dong-xi-mie" class="header-anchor">#</a></h2><h3><span id="4-1-1-an-jian-pan-huan-xing">4.1.1 按键盘唤醒</span><a href="#4-1-1-an-jian-pan-huan-xing" class="header-anchor">#</a></h3><p>默认情况下 10 分钟以后 LCD 就会熄屏，这个并不是代码有问题，而是 Linux 内核设置的。按下回车键就会唤醒屏幕。</p>
<h3><span id="4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping">4.1.2 关闭10分钟自动熄屏</span><a href="#4-1-2-guan-bi-10-fen-zhong-zi-dong-xi-ping" class="header-anchor">#</a></h3><ol>
<li><code>drivers/tty/vt/vt.c</code>中, <code>blankinterval</code> 变量控制着 LCD 关闭时间，默认是 <code>10*60</code>，也就是 10 分钟。将<code> blankinterval</code> 的值改为 0 即可关闭 10 分钟熄屏的功能。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">181</span> <span class="type">static</span> <span class="type">int</span> blankinterval = <span class="number">10</span>*<span class="number">60</span>;</span><br><span class="line"><span class="number">182</span> core_param(consoleblank, blankinterval, <span class="type">int</span>, <span class="number">0444</span>);</span><br></pre></td></tr></table></figure>


<ol start="2">
<li><code>echo -e &#39;\033[9;0]&#39; &gt; /dev/tty0</code></li>
</ol>
<h2><span id="4-5-ce-shi-dai-ma">4.5 测试代码</span><a href="#4-5-ce-shi-dai-ma" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAUSE()                                                                    \</span></span><br><span class="line"><span class="meta">    do &#123;    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;---------------press Enter key to continue!---------------\n&quot;</span>);    \</span></span><br><span class="line"><span class="meta">        getchar();                                                                 \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1	<span class="comment">// 32bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED      0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN    0xFF00FF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE     0xFF0000FF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW   0xFFFFFF00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE    0xFFFFFFFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK    0xFF000000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_color</span><span class="params">(<span class="type">uint32_t</span> *fb_addr, <span class="type">uint32_t</span> bit_map, <span class="type">int</span> psize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">        *fb_addr = bit_map;</span><br><span class="line">        fb_addr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">// 16bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED      0xFC00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN    0x83E0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE     0x801F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW   0xFFE0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WHITE    0xFFFF </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLACK    0x8000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fill_color</span><span class="params">(<span class="type">short</span> *fb_addr, <span class="type">short</span> bit_map, <span class="type">int</span> psize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;psize; i++) &#123;</span><br><span class="line">        *fb_addr = bit_map;</span><br><span class="line">        fb_addr++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _fb_get_info(<span class="type">int</span> fp, <span class="keyword">struct</span> fb_fix_screeninfo *finfo, <span class="keyword">struct</span> fb_var_screeninfo *vinfo)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> screensize=<span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOGET_FSCREENINFO, finfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading fixed information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOGET_VSCREENINFO, vinfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error reading variable information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    screensize = finfo-&gt;line_length * vinfo-&gt;yres;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The ID=%s\n&quot;</span>, finfo-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phy mem = 0x%x, total size = %d(byte)\n&quot;</span>, finfo-&gt;smem_start, finfo-&gt;smem_len);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;line length = %d(byte)\n&quot;</span>, finfo-&gt;line_length);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xres = %d, yres = %d, bits_per_pixel = %d\n&quot;</span>, vinfo-&gt;xres, vinfo-&gt;yres, vinfo-&gt;bits_per_pixel);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xresv = %d, yresv = %d\n&quot;</span>, vinfo-&gt;xres_virtual, vinfo-&gt;yres_virtual);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.xoffset = %d, vinfo.yoffset = %d\n&quot;</span>, vinfo-&gt;xoffset, vinfo-&gt;yoffset);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.vmode is :%d\n&quot;</span>, vinfo-&gt;vmode);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finfo.ypanstep is :%d\n&quot;</span>, finfo-&gt;ypanstep);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.red.offset=0x%x\n&quot;</span>, vinfo-&gt;red.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.red.length=0x%x\n&quot;</span>, vinfo-&gt;red.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.green.offset=0x%x\n&quot;</span>, vinfo-&gt;green.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.green.length=0x%x\n&quot;</span>, vinfo-&gt;green.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.blue.offset=0x%x\n&quot;</span>, vinfo-&gt;blue.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.blue.length=0x%x\n&quot;</span>, vinfo-&gt;blue.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.transp.offset=0x%x\n&quot;</span>, vinfo-&gt;transp.offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;vinfo.transp.length=0x%x\n&quot;</span>, vinfo-&gt;transp.length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Expected screensize = %d(byte), using %d frame\n&quot;</span>, screensize, finfo-&gt;smem_len/screensize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>   &#123;  </span><br><span class="line">    <span class="type">int</span> fp=<span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span>  </span><br><span class="line">    <span class="type">void</span> *fbp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="type">char</span> *test_fbp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">long</span> location = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> pix_size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fp = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fp &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error : Can not open framebuffer device/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-- Default fb info --\n&quot;</span>);</span><br><span class="line">    _fb_get_info(fp, &amp;finfo, &amp;vinfo);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    vinfo.xres = <span class="number">720</span>;</span><br><span class="line">    vinfo.yres = <span class="number">1280</span>;</span><br><span class="line">    <span class="keyword">if</span>(ioctl(fp, FBIOPUT_VSCREENINFO, &amp;vinfo))&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error putting variable information/n&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-- Updated fb info --\n&quot;</span>);</span><br><span class="line">    _fb_get_info(fp, &amp;finfo, &amp;vinfo);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    fbp = mmap(<span class="number">0</span>, finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fp, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fbp == MAP_FAILED)&#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Error: failed to map framebuffer device to memory.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">4</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get virt mem = %p\n&quot;</span>, fbp);  </span><br><span class="line"></span><br><span class="line">    pix_size = vinfo.xres * vinfo.yres;</span><br><span class="line">    <span class="comment">/* using first frame, for FBIOPAN_DISPLAY</span></span><br><span class="line"><span class="comment">     * 当刷新需要调用FBIOPAN_DISPLAY， 要告知驱动刷哪块帧， 用到下面两个参数</span></span><br><span class="line"><span class="comment">     * 如果使用第二帧buffer -&gt; vinfo.xoffset = 0; vinfo.yoffset = vinfo.yres;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vinfo.xoffset = <span class="number">0</span>;</span><br><span class="line">    vinfo.yoffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* show color loop */</span></span><br><span class="line">    <span class="keyword">while</span>(num--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing YELLOW......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, YELLOW, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing BLUE......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, BLUE, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\ndrawing RED......\n&quot;</span>);</span><br><span class="line">        fill_color(fbp, RED, pix_size);</span><br><span class="line">        <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">	PAUSE();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">/*这是你想画的点的位置坐标,(0，0)点在屏幕左上角*/</span></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    location = x * (vinfo.bits_per_pixel / <span class="number">8</span>) + y  *  finfo.line_length;</span><br><span class="line">    test_fbp = fbp + location;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;draw line.......\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (vinfo.xres - x); i++)</span><br><span class="line">        *test_fbp++ = i+<span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ioctl(fp, FBIOPAN_DISPLAY, &amp;vinfo);</span></span><br><span class="line">    PAUSE();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    munmap(fbp, finfo.smem_len); <span class="comment">/*解除映射*/</span></span><br><span class="line"></span><br><span class="line">    close (fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxoge90044qsuf89l81flc" data-title="字符设备驱动-Framebuffer子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-PWM子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-09-01T04:28:35.000Z" itemprop="datePublished">2024-09-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pwm-zi-xi-tong-kuang-jia">1 pwm子系统框架</a><ul>
<li><a href="#1-1-yuan-ma-jie-gou">1.1 源码结构</a></li>
<li><a href="#1-2-shu-ju-jie-gou">1.2 数据结构</a><ul>
<li><a href="#1-2-1-pwm-chip">1.2.1 <code>pwm_chip</code></a></li>
<li><a href="#1-2-2-pwm-ops">1.2.2 <code>pwm_ops</code></a></li>
<li><a href="#1-2-3-pwm-state">1.2.3 <code>pwm_state</code></a></li>
</ul>
</li>
<li><a href="#1-3-api">1.3 API</a><ul>
<li><a href="#1-3-1-pwmchip-add">1.3.1 <code>pwmchip_add</code></a></li>
<li><a href="#1-3-2-pwmchip-remove">1.3.2 <code>pwmchip_remove</code></a></li>
<li><a href="#1-3-3-pwm-request">1.3.3 pwm_request</a></li>
<li><a href="#1-3-4-pwm-free">1.3.4 pwm_free</a></li>
<li><a href="#1-3-5-pwm-config">1.3.5 <code>pwm_config</code></a></li>
<li><a href="#1-3-6-pwm-set-polarity">1.3.6 <code>pwm_set_polarity</code></a></li>
<li><a href="#1-3-6-pwm-enable">1.3.6 pwm_enable</a></li>
<li><a href="#1-3-7-pwm-disable">1.3.7 pwm_disable</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-pwm-qu-dong-shi-li">2 pwm驱动实例</a><ul>
<li><a href="#2-1-dts-miao-shu">2.1 dts描述</a></li>
<li><a href="#2-2-shi-neng-pwm-qu-dong">2.2 使能PWM驱动</a></li>
<li><a href="#2-3-pwm-bei-guang-she-zhi">2.3 PWM 背光设置</a></li>
<li><a href="#2-4-qu-dong-yuan-ma-fen-xi">2.4 驱动源码分析</a><ul>
<li><a href="#2-4-1-probe-guo-cheng">2.4.1 probe过程</a><ul>
<li><a href="#2-4-1-1-imx-chip">2.4.1.1 imx_chip</a></li>
</ul>
</li>
<li><a href="#2-4-2-imx-pwm-ops">2.4.2 imx_pwm_ops</a><ul>
<li><a href="#2-4-2-1-imx-pwm-config">2.4.2.1 imx_pwm_config</a></li>
<li><a href="#2-4-2-2-imx-pwm-enable">2.4.2.2 imx_pwm_enable</a></li>
<li><a href="#2-4-2-3-imx-pwm-disable">2.4.2.3 imx_pwm_disable</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ji-yu-pwm-sysfs-ce-shi">3 基于pwm sysfs测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pwm-zi-xi-tong-kuang-jia">1 pwm子系统框架</span><a href="#1-pwm-zi-xi-tong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>用户态：基于sysfs操作pwm</p>
<p>内核态分为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwm core：pwm_chip的添加删除，pwm_class类pwm_chip/pwm_device的sysfs创建。</span><br><span class="line"></span><br><span class="line">pwm driver：pwm_chip对象实例，注册添加到pwm core。</span><br><span class="line">	pwm_chip可以包含一个或多个pwm_device，每个pwm_device通过设置不同pwm_state来达到目的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="1-1-yuan-ma-jie-gou">1.1 源码结构</span><a href="#1-1-yuan-ma-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">drivers/pwm/</span><br><span class="line">	core.c <span class="comment">//pwm子系统核心。</span></span><br><span class="line">	sysfs.c<span class="comment">//pwm子系统的pwm_class注册，pwm_chip属性，pwm_device属性等定义。</span></span><br><span class="line">	pwm-imx.c<span class="comment">//imx的pwm_chip驱动。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p>我已经编译进<code>vmlinux</code>了，可以看到<code>built-in.o</code>。<code>Makefile</code>如下：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p><code>Kconfig</code>如下，我的内核<code>.config</code>配置选中了<code>PWM和PWM_IMX</code>，因此编译进了内核镜像。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<h2><span id="1-2-shu-ju-jie-gou">1.2 数据结构</span><a href="#1-2-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-2-1-pwm-chip">1.2.1 <code>pwm_chip</code></span><a href="#1-2-1-pwm-chip" class="header-anchor">#</a></h3><p>是对一个pwm控制器的抽象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_chip</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> base;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> npwm;<span class="comment">//pwm控制器的pwm数量。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> * (*<span class="title">of_xlate</span>)(<span class="keyword">struct</span> <span class="title">pwm_chip</span> *<span class="title">pc</span>,</span></span><br><span class="line"><span class="class">                    <span class="title">const</span> <span class="keyword">struct</span> <span class="title">of_phandle_args</span> *<span class="title">args</span>);</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> of_pwm_n_cells;</span><br><span class="line">    <span class="comment">/* only used internally by the PWM framework */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pwm_device</span> *<span class="title">pwms</span>;</span></span><br><span class="line">&#125;; <span class="comment">//include/linux/pwm.h</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-pwm-ops">1.2.2 <code>pwm_ops</code></span><a href="#1-2-2-pwm-ops" class="header-anchor">#</a></h3><p>pwm控制器的操作接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_ops</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*request)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//请求 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">void</span> (*<span class="built_in">free</span>)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//释放 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">int</span> (*config)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//配置 PWM 周期和占空比</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">	<span class="type">int</span> duty_ns, <span class="type">int</span> period_ns);</span><br><span class="line">	<span class="type">int</span> (*set_polarity)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//设置 PWM 极性</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm,</span><br><span class="line">	<span class="keyword">enum</span> pwm_polarity polarity);</span><br><span class="line">	<span class="type">int</span> (*enable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//使能 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="type">void</span> (*disable)(<span class="keyword">struct</span> pwm_chip *chip, <span class="comment">//关闭 PWM</span></span><br><span class="line">	<span class="keyword">struct</span> pwm_device *pwm);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-pwm-state">1.2.3 <code>pwm_state</code></span><a href="#1-2-3-pwm-state" class="header-anchor">#</a></h3><p>pwm_state就是控制占空比控制转速，亮度参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pwm_state</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> period; <span class="comment">//pwm的周期，单位ns。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> duty_cycle; <span class="comment">//占空比duty_cycle，单位ns。</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">pwm_polarity</span> <span class="title">polarity</span>;</span><span class="comment">//PWM_POLARITY_NORMAL表示高电平持续duty_cycle，</span></span><br><span class="line">    <span class="comment">//然后是低电平持续剩余时间。PWM_POLARITY_INVERSED表示低电平持续duty_cycle，然后是高电平持续剩余时间。</span></span><br><span class="line">    <span class="type">bool</span> enabled; <span class="comment">//是否使能</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-api">1.3 API</span><a href="#1-3-api" class="header-anchor">#</a></h2><p>api声明见<code>linux\include\linux\pwm.h</code>，实现<code>linux\drivers\pwm\core.c</code></p>
<h3><span id="1-3-1-pwmchip-add">1.3.1 <code>pwmchip_add</code></span><a href="#1-3-1-pwmchip-add" class="header-anchor">#</a></h3><p>向<code>pwm</code>子系统注册一个<code>pwm_chip</code>。</p>
<p><code>int pwmchip_add(struct pwm_chip *chip);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwmchip_add</span><br><span class="line">	pwmchip_add_with_polarity</span><br><span class="line">		-&gt;pwm_ops_check   <span class="comment">//检查pwm_ops是否支持apply等。</span></span><br><span class="line">		-&gt;alloc_pwms     <span class="comment">//为pwm_chip的pwm_device分配allocated_pwms。</span></span><br><span class="line">		-&gt;<span class="comment">//初始化每个pwm_device，并加入pwm_tree。</span></span><br><span class="line">		-&gt;pwmchip_sysfs_export</span><br><span class="line">			-&gt;pwmchip_sysfs_export <span class="comment">//创建pwm_class类设备pwmchpX，位于/sys/class/pwm/pwmchipX。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h3><span id="1-3-2-pwmchip-remove">1.3.2 <code>pwmchip_remove</code></span><a href="#1-3-2-pwmchip-remove" class="header-anchor">#</a></h3><p><code>int pwmchip_remove(struct pwm_chip *chip);</code></p>
<p>删除一个<code>pwm_chip</code>。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h3><span id="1-3-3-pwm-request">1.3.3 pwm_request</span><a href="#1-3-3-pwm-request" class="header-anchor">#</a></h3><p>请求 PWM。</p>
<p><code>struct pwm_device *pwm_request(int pwm, const char *label)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>可以看到就是调用具体pwm示例的request函数。</p>
<h3><span id="1-3-4-pwm-free">1.3.4 pwm_free</span><a href="#1-3-4-pwm-free" class="header-anchor">#</a></h3><p>释放 PWM。</p>
<p><code>void pwm_free(struct pwm_device *pwm)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<h3><span id="1-3-5-pwm-config">1.3.5 <code>pwm_config</code></span><a href="#1-3-5-pwm-config" class="header-anchor">#</a></h3><p>配置 PWM 周期和占空比,操作具体pwm实例。</p>
<p><code>int pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<h3><span id="1-3-6-pwm-set-polarity">1.3.6 <code>pwm_set_polarity</code></span><a href="#1-3-6-pwm-set-polarity" class="header-anchor">#</a></h3><p>设置 PWM 极性。</p>
<p><code>int pwm_set_polarity(struct pwm_device *pwm, enum pwm_polarity polarity)</code></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<h3><span id="1-3-6-pwm-enable">1.3.6 pwm_enable</span><a href="#1-3-6-pwm-enable" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<h3><span id="1-3-7-pwm-disable">1.3.7 pwm_disable</span><a href="#1-3-7-pwm-disable" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p>从<code>1.3.3</code>到<code>1.3.7</code>本质都是调用<code>pwm_ops</code>。</p>
<h1><span id="2-pwm-qu-dong-shi-li">2 pwm驱动实例</span><a href="#2-pwm-qu-dong-shi-li" class="header-anchor">#</a></h1><p><code>I.MX6ULL </code>有 8 路 PWM 控制器。这 8 路 PWM 都属于<code>I.MX6ULL 的 AIPS-1</code>域，但是在设备树<code>imx6ull.dtsi</code>中 分为了两部分，<code>PWM1~PWM4 </code>在一起，<code>PWM5~PWM8</code> 在一起。以<code>pwm3</code>为例：</p>
<h2><span id="2-1-dts-miao-shu">2.1 dts描述</span><a href="#2-1-dts-miao-shu" class="header-anchor">#</a></h2><p>打开<code>imx6ull.dtsi</code>：可以看到<code>pwm3</code>的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwm3: pwm@<span class="number">02088000</span> &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-pwm&quot;</span>, <span class="string">&quot;fsl,imx27-pwm&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x02088000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">85</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_PWM3&gt;,</span><br><span class="line">	&lt;&amp;clks IMX6UL_CLK_PWM3&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">	<span class="meta">#pwm-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关 于<code>I.MX6ULL</code>的<code>PWM dts</code>节点描述参考对应的绑定文档 ：<code> Documentation/devicetree/bindings/pwm/ imx-pwm.txt</code></p>
<p><code>GPIO1_IO04 </code>这里作为<code>PWM3</code>的输出引脚，所以我们需要在设备树里面添加 <code>GPIO1_IO04 </code>的引脚信息以及<code>PWM3</code>控制器对应的节点信息:</p>
<p>打开<code> imx6ull-alientek-emmc.dts</code>, 添加<code>iomux</code>配置信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_pwm3: pwm3grp &#123;</span><br><span class="line">	fsl,pins = &lt;MX6UL_PAD_GPIO1_IO04__PWM3_OUT <span class="number">0x110b0</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;pwm3 &#123;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_pwm3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-shi-neng-pwm-qu-dong">2.2 使能PWM驱动</span><a href="#2-2-shi-neng-pwm-qu-dong" class="header-anchor">#</a></h2><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>从<code>.config</code>中已经使能了，但是为了学习， 我们还是需要知道怎么使能。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">    -&gt; Pulse-Width Modulation (PWM) Support</span><br><span class="line">        -&gt; &lt;*&gt; i.MX PWM support</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-pwm-bei-guang-she-zhi">2.3 PWM 背光设置</span><a href="#2-3-pwm-bei-guang-she-zhi" class="header-anchor">#</a></h2><p> <code>linux</code> 内核里面关于 <code>backlight(背光)</code>的绑定文档，路径为<code> Documentation/devicetree/bindings/video/backlight/pwm-backlight.txt</code>，此文档描述了如何创建<code> backlight 节点</code>来使用<code>linux</code>内核自带的<code>pwm</code>背光驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compatible：内容必须为“pwm-backlight”，通过这个可以匹配到内核自带的 PWM 背光驱</span><br><span class="line">动，驱动文件为 drivers/video/backlight/pwm_bl.c，这里就不去分析驱动源码了。</span><br><span class="line"></span><br><span class="line">pwms：此属性指定背光使用哪一路 PWM，以及 PWM 相关的属性。</span><br><span class="line"></span><br><span class="line">brightness-levels：背光等级数组，范围 <span class="number">0</span>~<span class="number">255</span>，对应占空比为 <span class="number">0</span>%~<span class="number">100</span>%。数组内的值必须</span><br><span class="line">从 <span class="number">0</span> 开始，也就是 <span class="number">0</span>%占空比，最后一个值必须是 <span class="number">255</span>，也就是 <span class="number">100</span>%占空比。数组中间值的个</span><br><span class="line">数以及值大小可以自行定义。</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>-brightness-level：默认的背光等级，也就是 brightness-levels 属性中第几个值，注意</span><br><span class="line">这里是数索引编号，不是具体的数值！</span><br><span class="line"></span><br><span class="line">power-supply：支持的电压，此属性可以不需要</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">backlight &#123;</span><br><span class="line">    compatible = <span class="string">&quot;pwm-backlight&quot;</span>;</span><br><span class="line">    pwms = &lt;&amp;pwm1 <span class="number">0</span> <span class="number">5000000</span>&gt;;<span class="comment">// PWM 周期为 5000000ns，频率为 200Hz</span></span><br><span class="line">    brightness-levels = &lt;<span class="number">0</span> <span class="number">4</span> <span class="number">8</span> <span class="number">16</span> <span class="number">32</span> <span class="number">64</span> <span class="number">128</span> <span class="number">255</span>&gt;;</span><br><span class="line">    <span class="keyword">default</span>-brightness-level = &lt;<span class="number">7</span>&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-qu-dong-yuan-ma-fen-xi">2.4 驱动源码分析</span><a href="#2-4-qu-dong-yuan-ma-fen-xi" class="header-anchor">#</a></h2><h3><span id="2-4-1-probe-guo-cheng">2.4.1 probe过程</span><a href="#2-4-1-probe-guo-cheng" class="header-anchor">#</a></h3><h4><span id="2-4-1-1-imx-chip">2.4.1.1 imx_chip</span><a href="#2-4-1-1-imx-chip" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>定义了<code>imx_chip</code>，包装了<code>pwm_chip</code>结构。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p>probe时，先分配内存，从dts获取<code>per, ipg</code>等时钟信息，设置pwm的ops为<code>imx_pwm_ops</code>。最后<code>pwmchip_add</code>注册进pwm子系统。注意这里有一个<code>of_id-&gt;data</code>,对应如下：可以看到有<code>v1,v2两2版本</code>，到时候会被ops中的函数调用。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></p>
<p>同理，驱动卸载最后调用<code>pwmchip_remove</code>注销pwm。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"></p>
<h3><span id="2-4-2-imx-pwm-ops">2.4.2 imx_pwm_ops</span><a href="#2-4-2-imx-pwm-ops" class="header-anchor">#</a></h3><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<h4><span id="2-4-2-1-imx-pwm-config">2.4.2.1 imx_pwm_config</span><a href="#2-4-2-1-imx-pwm-config" class="header-anchor">#</a></h4><p>配置 PWM 周期和占空比。根据dts描述(<code>”imx27-pwm“</code>)我们使用的是v2。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p><code>PWMv2</code>会有4 word的采样fifo, 为了避免采样FIFO溢出，当pwm关闭时，对所有采样FIFO进行软件复位。当pwm使能后处于工作中，要等待完整的 PWM 周期以保证pwm空闲。</p>
<p>然后设置<code>PWM 周期period_cycles</code>，和<code>占空比duty_cycles</code>。</p>
<p>最后调用<code>writel</code>写入寄存器。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<h4><span id="2-4-2-2-imx-pwm-enable">2.4.2.2 imx_pwm_enable</span><a href="#2-4-2-2-imx-pwm-enable" class="header-anchor">#</a></h4><p>控制<code>MX3_PWMCR</code>寄存器，使能关闭开关。</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h4><span id="2-4-2-3-imx-pwm-disable">2.4.2.3 imx_pwm_disable</span><a href="#2-4-2-3-imx-pwm-disable" class="header-anchor">#</a></h4><p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<h1><span id="3-ji-yu-pwm-sysfs-ce-shi">3 基于pwm sysfs测试</span><a href="#3-ji-yu-pwm-sysfs-ce-shi" class="header-anchor">#</a></h1><p><code>alpha</code>开发板 <code>JP2 排针</code>上的 <code>GPIO_4(GPIO1_IO04)</code>引脚连接到 示波器上。等下看pwm信号效果。</p>
<p>可以看到一共8 路 PWM 控制器：</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<p>我们使用的<code>pwm3</code>,对应出<code> pwmchip2</code>, 导出chip2通道的0设备文件:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip2/export</span><br></pre></td></tr></table></figure>

<p>执行完成会在<code>pwmchip2 </code>目录下生成一个名为<code>“pwm0”</code>的子目录:</p>
<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/class/pwm/pwmchip2/pwm0/enable <span class="comment">#使能pwm3</span></span><br><span class="line"><span class="built_in">echo</span> 50000 &gt; /sys/class/pwm/pwmchip2/pwm0/period <span class="comment">#设置周期值，单位为 ns，比如 20KHz 频率的周期就是 50000ns</span></span><br><span class="line"><span class="built_in">echo</span> 10000 &gt; /sys/class/pwm/pwmchip2/pwm0/duty_cycle <span class="comment">#20%占空比</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p>总结：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">导出chip1通道的0设备文件：<span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip1/export</span><br><span class="line">配置chip1通道0的周期： <span class="built_in">echo</span> 10000000 &gt; /sys/class/pwm/pwmchip1 /pwm0/period</span><br><span class="line">配置chip1通道0的占空比:<span class="built_in">echo</span> 4000000 &gt;/sys/class/pwm/pwmchip1/pwm0/duty_cycle</span><br><span class="line">配置片chip通道0使能： <span class="built_in">echo</span> 1 &gt; /sys/class/pwm/pwmchip1/pwm0/enable</span><br><span class="line">配置片chip通道0禁能： <span class="built_in">echo</span> 0 &gt; /sys/class/pwm/pwmchip1/pwm0/enable</span><br><span class="line">取消导出片chip通道0设备文件： <span class="built_in">echo</span> 0 &gt;/sys/class/pwm/pwmchip1/unexport</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxogea004bqsuf0zrf93cq" data-title="字符设备驱动-PWM子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-input子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T12:02:38.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</a><ul>
<li><a href="#1-0-shu-ju-jie-gou">1.0 数据结构</a><ul>
<li><a href="#1-0-1-input-dev">1.0.1 input_dev</a></li>
</ul>
</li>
<li><a href="#1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</a><ul>
<li><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</a></li>
<li><a href="#1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</a><ul>
<li><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</a></li>
</ul>
</li>
<li><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</a></li>
<li><a href="#1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-input-zi-xi-tong-shi-li">2 input子系统示例</a><ul>
<li><a href="#2-1-ding-yi-input-dev">2.1 定义input_dev</a></li>
<li><a href="#2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</a></li>
<li><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</a></li>
<li><a href="#2-4-shi-fang-input-dev">2.4 释放input_dev</a></li>
</ul>
</li>
<li><a href="#3-app-ce-shi">3 APP测试</a></li>
<li><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</a><ul>
<li><a href="#4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</a><ul>
<li><a href="#4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</a><ul>
<li><a href="#4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</a></li>
<li><a href="#4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-ce-shi-yan-zheng">4.2 测试验证</a></li>
</ul>
</li>
<li><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</a><ul>
<li><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</a><ul>
<li><a href="#5-1-1-te-xing">5.1.1 特性</a></li>
<li><a href="#5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</a></li>
<li><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</a></li>
<li><a href="#5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</a></li>
</ul>
</li>
<li><a href="#5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</a><ul>
<li><a href="#5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</a><ul>
<li><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</a></li>
<li><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</a></li>
<li><a href="#5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</a></li>
<li><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</a></li>
</ul>
</li>
<li><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</a></li>
<li><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</a></li>
<li><a href="#5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</a><ul>
<li><a href="#5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-duo-dian-hong-mo-api">5.3 多点触摸API</a><ul>
<li><a href="#5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</a></li>
<li><a href="#5-3-2-input-mt-slot">5.3.2 input_mt_slot</a></li>
<li><a href="#5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</a></li>
<li><a href="#5-3-4-input-report-abs">5.3.4 input_report_abs</a></li>
<li><a href="#5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</a></li>
</ul>
</li>
<li><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</a><ul>
<li><a href="#5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</a><ul>
<li><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</a></li>
<li><a href="#5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</a></li>
</ul>
</li>
<li><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</a><ul>
<li><a href="#5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</a></li>
<li><a href="#5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</a></li>
<li><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</a></li>
</ul>
</li>
<li><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</a><ul>
<li><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</a></li>
</ul>
</li>
<li><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</span><a href="#1-input-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>按键、鼠标、键盘、触摸屏等都属于输入(<code>input</code>)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。<br>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。</p>
<h2><span id="1-0-shu-ju-jie-gou">1.0  数据结构</span><a href="#1-0-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-0-1-input-dev">1.0.1 input_dev</span><a href="#1-0-1-input-dev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">   <span class="number">2</span>:      <span class="type">const</span> <span class="type">char</span> *name;      <span class="comment">//设备名</span></span><br><span class="line">   <span class="number">3</span>:      <span class="type">const</span> <span class="type">char</span> *phys;     <span class="comment">// 设备在系统中路径</span></span><br><span class="line">   <span class="number">4</span>:      <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">   <span class="number">5</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//与input_handler匹配用的id;</span></span><br><span class="line"></span><br><span class="line">   <span class="number">9</span>:      <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">//设备所支持事件类型主要有EV_SYNC,EV_KEY,EV_REL,EV_ABS</span></span><br><span class="line">  <span class="number">10</span>:      <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 按键所对应的位图</span></span><br><span class="line">  <span class="number">11</span>:      <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];<span class="comment">//  相对坐标对应位图</span></span><br><span class="line">  <span class="number">12</span>:      <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];<span class="comment">// 绝对坐标对应位图</span></span><br><span class="line">  <span class="number">13</span>:      <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];<span class="comment">//支持其它事件</span></span><br><span class="line">  <span class="number">14</span>:      <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];<span class="comment">//支持led事件</span></span><br><span class="line">  <span class="number">15</span>:      <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">//支持声音事件</span></span><br><span class="line">  <span class="number">16</span>:      <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];<span class="comment">//支持受力事件</span></span><br><span class="line">  <span class="number">17</span>:      <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];<span class="comment">//支持开关机事件</span></span><br><span class="line">  <span class="number">18</span>:   </span><br><span class="line">  <span class="number">19</span>:      <span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;</span><br><span class="line">  <span class="number">21</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodemax;</span><br><span class="line">  <span class="number">22</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodesize;</span><br><span class="line">  <span class="number">23</span>:      <span class="type">void</span> *keycode;</span><br><span class="line">  <span class="number">24</span>:   </span><br><span class="line">  <span class="number">25</span>:      <span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">26</span>:                <span class="type">const</span> <span class="keyword">struct</span> input_keymap_entry *ke,</span><br><span class="line">  <span class="number">27</span>:                <span class="type">unsigned</span> <span class="type">int</span> *old_keycode);</span><br><span class="line">  <span class="number">28</span>:      <span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">29</span>:                <span class="keyword">struct</span> input_keymap_entry *ke);</span><br><span class="line">  <span class="number">30</span>:   </span><br><span class="line">  <span class="number">31</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span></span><br><span class="line">  <span class="number">33</span>:      <span class="type">unsigned</span> <span class="type">int</span> repeat_key;<span class="comment">//最近一次的按键值</span></span><br></pre></td></tr></table></figure>



<h2><span id="1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</span><a href="#1-1-input-qu-dong-bian-xie-liu-cheng" class="header-anchor">#</a></h2><h3><span id="1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</span><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li" class="header-anchor">#</a></h3><p><code>drivers/input/input.c</code>就是input子系统的核心层，此文件里面有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">input_class</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">	.devnode = input_devnode,</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = class_register(&amp;input_class);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">		INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail2: input_proc_exit();</span><br><span class="line">fail1: class_unregister(&amp;input_class);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册一个 input 类，这样系统启动以后就会在&#x2F;sys&#x2F;class 目录下有一个 input 子目录:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>创建<code>proc/input</code>信息，申请主设备号为<code> INPUT_MAJOR, INPUT_MAJOR</code> 定义在 <code>include/uapi/linux/major.h</code>:<br><code>#define INPUT_MAJOR 13</code><br>因此，input 子系统的所有设备主设备号都为 <code>13</code>，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 <code>input_device </code>即可。</p>
<h3><span id="1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</span><a href="#1-1-1-zhu-ce-input-dev" class="header-anchor">#</a></h3><p>使用 input 子系统的时候我们只需要注册一个 input 设备即可，<code>input_dev</code> 结构体表示<code> input设备</code>，此结构体定义在 <code>include/linux/input.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">/* sound 有关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">	.....</span><br><span class="line">	<span class="type">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>evbit </code>表示输入事件类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br></pre></td></tr></table></figure>

<p><code>evbit、keybit、relbit </code>等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></span><br></pre></td></tr></table></figure>

<p>我们可以将开发板上的按键值设置为任意一个，比如就叫<code>KEY_0</code>。</p>
<p><strong>申请input内存：</strong><br><code>struct input_dev *input_allocate_device(void);</code></p>
<p><strong>释放input内存：</strong><br><code>void input_free_device(struct input_dev *dev);</code></p>
<p><strong>注册input设备：</strong><br><code>int input_register_device(struct input_dev *dev);</code></p>
<p><strong>注销input设备：</strong><br><code>void input_unregister_device(struct input_dev *dev);</code></p>
<h4><span id="1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</span><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span> <span class="comment">/* input 结构体变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	inputdev = input_allocate_device(); <span class="comment">/* 申请 input_dev */</span></span><br><span class="line">	inputdev-&gt;name = <span class="string">&quot;test_inputdev&quot;</span>; <span class="comment">/* 设置 input_dev 名字 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*********第一种设置事件和事件值的方法***********/</span></span><br><span class="line">	 __set_bit(EV_KEY, inputdev-&gt;evbit); <span class="comment">/* 设置产生按键事件 */</span></span><br><span class="line">	 __set_bit(EV_REP, inputdev-&gt;evbit); <span class="comment">/* 重复事件 */</span></span><br><span class="line">	 __set_bit(KEY_0, inputdev-&gt;keybit); <span class="comment">/*设置产生哪些按键值 */</span></span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">/*********第二种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |=</span><br><span class="line">	T_MASK(KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">/*********第三种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 input_register_device(inputdev);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">	 input_unregister_device(inputdev); <span class="comment">/* 注销 input_dev */</span></span><br><span class="line">	 input_free_device(inputdev); <span class="comment">/* 删除 input_dev */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</span><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h3><p>当输入设备中断到来，我们需要上报input输入事件给linux内核的input核心层，比如按键：我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。<br>不同的事件，上报事件的 API 函数不一样:<br><strong>input_event:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	dev：需要上报的 input_dev。</span></span><br><span class="line"><span class="comment">	type: 上报的事件类型，比如 EV_KEY。</span></span><br><span class="line"><span class="comment">	code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</span></span><br><span class="line"><span class="comment">	value：事件值，比如 1 表示按键按下，0 表示按键松开。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当然linux系统帮我们也封装了一层api去使用：<br><strong>input_report_key：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的还有一些其他的事件上报函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>
<p>我们上报事件以后还需要使用<code>input_sync</code>函数来告诉 Linux 内核 input 子系统上报结束，<code>input_sync </code>函数本质是上报一个同步事件:<br><code>void input_sync(struct input_dev *dev);</code><br>举个例子，按键中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于按键消抖的定时器服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; <span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1，按下 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 按键松开 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0，松开 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3><span id="1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</span><a href="#1-1-3-input-event-jie-gou-ti" class="header-anchor">#</a></h3><p><code>include/uapi/linux/input.h</code> 文件中:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p><code>type</code>：事件类型，比如 EV_KEY，表示此次事件为<code>按键事件</code>，此成员变量为 16 位。<br><code>code</code>：事件码，比如在 EV_KEY 事件中 code 就表示具体的<code>按键码</code>，如：<code>KEY_0、KEY_1</code>等等这些按键。此成员变量为 16 位。<br><code>value</code>：值，比如 EV_KEY 事件中 value 就是<code>按键值</code>，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了</p>
<p><code>input_envent </code>这个结构体非常重要,用户态的应用程序也是通过 <code>input_event </code>来获取到具体的输入事件或相关的值，比如按键值等。</p>
<h1><span id="2-input-zi-xi-tong-shi-li">2 input子系统示例</span><a href="#2-input-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>还是以之前的按键来举例，利用input子系统来做一个按键驱动程序：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_NAME		<span class="string">&quot;keyinput&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span>		<span class="comment">/* input结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> <span class="title">keyinputdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123;<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span></span><br><span class="line">        <span class="comment">/* 最后一个参数表示按下还是松开，1为按下，0为松开 */</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">1</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">0</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	keyinputdev.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (keyinputdev.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取GPIO */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		keyinputdev.irqkeydesc[i].gpio = of_get_named_gpio(keyinputdev.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (keyinputdev.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化key所使用的IO，并且设置成中断模式 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(keyinputdev.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(keyinputdev.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(keyinputdev.irqkeydesc[i].gpio, name);</span><br><span class="line">		gpio_direction_input(keyinputdev.irqkeydesc[i].gpio);	</span><br><span class="line">		keyinputdev.irqkeydesc[i].irqnum = irq_of_parse_and_map(keyinputdev.nd, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].value = KEY_0;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(keyinputdev.irqkeydesc[i].irqnum, keyinputdev.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING,</span><br><span class="line">                         keyinputdev.irqkeydesc[i].name, &amp;keyinputdev);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, keyinputdev.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建定时器 */</span></span><br><span class="line">	init_timer(&amp;keyinputdev.timer);</span><br><span class="line">	keyinputdev.timer.function = timer_function;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请input_dev */</span></span><br><span class="line">	keyinputdev.inputdev = input_allocate_device();</span><br><span class="line">	keyinputdev.inputdev-&gt;name = KEYINPUT_NAME;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些事件 */</span></span><br><span class="line">	__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 设置产生按键事件          */</span></span><br><span class="line">	__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 重复事件，比如按下去不放开，就会一直输出信息*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些按键 */</span></span><br><span class="line">	__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册输入设备 */</span></span><br><span class="line">	ret = input_register_device(keyinputdev.inputdev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">&quot;register input device failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">keyinput_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">keyinput_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;keyinputdev.timer);	<span class="comment">/* 删除定时器 */</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(keyinputdev.irqkeydesc[i].irqnum, &amp;keyinputdev);</span><br><span class="line">	&#125;</span><br><span class="line">	input_unregister_device(keyinputdev.inputdev);</span><br><span class="line">	input_free_device(keyinputdev.inputdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(keyinput_init);</span><br><span class="line">module_exit(keyinput_exit);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-ding-yi-input-dev">2.1 定义input_dev</span><a href="#2-1-ding-yi-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h2><span id="2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</span><a href="#2-2-chu-shi-hua-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<ol>
<li><code>input_allocate_device</code>分配内存</li>
<li>设置事件和事件值，<code>input_event</code>类型是<code>EV_KEY</code>,键值<code>KEY_0</code>,<code> evbit</code>为<code>EV_KEY | EV_REP</code></li>
<li>注册input设备</li>
</ol>
<h2><span id="2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</span><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h2><span id="2-4-shi-fang-input-dev">2.4 释放input_dev</span><a href="#2-4-shi-fang-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h1><span id="3-app-ce-shi">3 APP测试</span><a href="#3-app-ce-shi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">inputevent</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		err = read(fd, &amp;inputevent, <span class="keyword">sizeof</span>(inputevent));</span><br><span class="line">		<span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123; <span class="comment">/* 读取数据成功 */</span></span><br><span class="line">			<span class="keyword">switch</span> (inputevent.type) &#123;</span><br><span class="line">				<span class="keyword">case</span> EV_KEY:</span><br><span class="line">					<span class="keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="comment">/* 键盘键值 */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;key %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;button %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">/* 其他类型的事件，自行处理 */</span></span><br><span class="line">				<span class="keyword">case</span> EV_REL:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EV_ABS:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;读取数据失败\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们向 Linux 内核成功注册 input_dev 设备以后，会在<code>/dev/input </code>目录下生成一个名为<code>“eventX(X=0….n)”</code>的文件，这个<code>/dev/input/eventX </code>就是对应的 input 设备文件。</p>
<p>测试：<br>在加载<code>keyinput.ko</code>驱动模块之前，先看一下<code>/dev/input </code>目录下都有哪些文件：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br><code>modprobe keyinput.ko</code> 可以看到多一个<code>input1</code>,就是我们刚创建的设备节点：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"><br>运行app:<br><code>./keyinputApp /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 <code>KEY_0</code> 为 <code>11</code>。<br>另外，我们也可以不用<code>keyinputApp</code>来测试驱动，可以直接使用<code>hexdump</code>命令来查看<code>/dev/input/event1 </code>文件内容，输入如下命令：<br><code>hexdump /dev/input/event1</code><br>这就是<code>input_event</code> 类型的原始事件数据值：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>含义如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"><br><code>type </code>为事件类型，<code>EV_KEY </code>事件值为 1，<code>EV_SYN </code>事件值为0。因此第 1 行表示 <code>EV_KEY </code>事件，第 2 行表示 <code>EV_SYN </code>事件。code 为事件编码，也就是按键号，<code>KEY_0</code> 这个按键编号为 11，对应的十六进制为 <code>0xb</code>，因此第1 行表示 <code>KEY_0 </code>这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。<br>综上所述，上述原始事件值含义如下：<br>第 1 行，按键<code>(KEY_0)</code>按下事件。<br>第 2 行，<code>EV_SYN</code> 同步事件，因为每次上报按键事件以后都要同步的上报一个 <code>EV_SYN</code> 事件。<br>第 3 行，按键<code>(KEY_0)</code>松开事件。<br>第 4 行，<code>EV_SYN </code>同步事件，和第 2 行一样。</p>
<h1><span id="4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</span><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong" class="header-anchor">#</a></h1><p>Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Input device support</span><br><span class="line">		-&gt; Generic input <span class="title function_">layer</span> <span class="params">(needed <span class="keyword">for</span> keyboard, mouse, ...)</span> <span class="params">(INPUT [=y])</span></span><br><span class="line">			-&gt; <span class="title function_">Keyboards</span> <span class="params">(INPUT_KEYBOARD [=y])</span></span><br><span class="line">				-&gt;GPIO Buttons</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>选中以后就会在<code>.config</code> 文件中出现<code>“CONFIG_KEYBOARD_GPIO=y”</code>这一行，Linux 内核<br>就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。Linux 内核自带的 KEY 驱动文件为<br><code>drivers/input/keyboard/gpio_keys.c</code>，<code>gpio_keys.c </code>采用了 platform 驱动框架，在 KEY 驱动上使用<br>了 input 子系统实现。</p>
<h2><span id="4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</span><a href="#4-1-gpio-keys-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>要使用 Linux 内 核 自 带 的 按 键 驱 动 程 序 很 简 单 ， 只 需 要 根 据<code>Documentation/devicetree/bindings/input/gpio-keys.txt </code>这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①、节点名字为“gpio-keys”。</span><br><span class="line">②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</span><br><span class="line">③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：</span><br><span class="line">	gpios：KEY 所连接的 GPIO 信息。</span><br><span class="line">	interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。</span><br><span class="line">	label：KEY 名字</span><br><span class="line">	linux,code：KEY 要模拟的按键，也就是示例代码</span><br><span class="line">④、如果按键要支持连按的话要加入 autorepeat。</span><br></pre></td></tr></table></figure>
<p>打开<code> imx6ull-alientek-emmc.dts</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	autorepeat;</span><br><span class="line">	key0 &#123;</span><br><span class="line">		label = <span class="string">&quot;GPIO Key Enter&quot;</span>;</span><br><span class="line">		linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ALPHA 开发板 KEY 按键信息，名字设置为<code>“GPIO Key Enter”</code>，这里我们将开发板上的 KEY 按键设置为<code>“EKY_ENTER”</code>这个按键，也就是回车键，效果和键盘上的回车键一样。</p>
<h3><span id="4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</span><a href="#4-1-1-gpio-keys-probe-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br>可以看到就是对<code>input</code>子系统的调用封装，实例化了一个利用input子系统写的驱动程序。<br>调用<code> gpio_keys_get_devtree_pdata</code> 函数从设备树中获取到 KEY 相关的设备节点信息。<br>使用 <code>devm_input_allocate_device</code> 函数申请 input_dev。<br>初始化<code> input_dev</code>。<br>设置<code> input_dev 事件</code>，这里设置了<code> EV_REP</code> 事件.<br><strong>调用 <code>gpio_keys_setup_key</code> 函数继续设置 KEY，此函数会设置 input_dev 的EV_KEY 事件已经事件码(也就是 KEY 模拟为哪个按键)</strong><br>调用 <code>input_register_device</code> 函数向 Linux 系统注册<code> input_dev</code>。</p>
<h4><span id="4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</span><a href="#4-1-1-1-gpio-keys-setup-key" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>调用<code> input_set_capability</code> 函数设置<code> EV_KEY</code> 事件以及 KEY 的按键类型，也就是 KEY 作为哪个按键？我们会在设备树里面设置指定的 KEY 作为哪个按键.</p>
<h4><span id="4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</span><a href="#4-1-1-2-gpio-keys-irq-isr" class="header-anchor">#</a></h4><p>当dts对应的按键按下后，中断进行响应，函数如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"><br>可以看到同理还是调用input_event， input_sync进行上报事件。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image-20240825144156414"></p>
<h2><span id="4-2-ce-shi-yan-zheng">4.2 测试验证</span><a href="#4-2-ce-shi-yan-zheng" class="header-anchor">#</a></h2><p>烧录新的dtb和kernel进去，可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用<br>hexdump 命令来查看<code>/dev/input/event1 </code>文件：<br><code>hexdump /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"><br>大家如果发现按下 KEY 按键以后没有反应，那么请检查一下三方面：<br>①、是否使能 Linux 内核 KEY 驱动。<br>②、设备树中 <code>gpio-keys</code> 节点是否创建成功。<br>③、在设备树中是否有其他外设也使用了 KEY 按键对应的 GPIO，但是我们并没有删除掉这些外设信息。检查 Linux 启动 log 信息，看看是否有类似下面这条信息:<br><code>gpio-keys gpio_keys：Failed to request GPIO 18, error -16</code></p>
<h1><span id="5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</span><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong" class="header-anchor">#</a></h1><h2><span id="5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</span><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie" class="header-anchor">#</a></h2><h3><span id="5-1-1-te-xing">5.1.1 特性</span><a href="#5-1-1-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p>特性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 自动模式切换。</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span>hz采样率</span><br><span class="line"><span class="number">3.</span> 自动校准</span><br><span class="line"><span class="number">4.</span> i2c接口，速率高达<span class="number">400</span>k</span><br><span class="line"><span class="number">5.</span> <span class="number">12</span>位ADC精度转换</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p>触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。</p>
<h3><span id="5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</span><a href="#5-1-2-i2c-chuan-shu-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.1.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p>可以看到slave addr是7位，第8位表示方向。数据是每次传输1byte。</p>
<h3><span id="5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</span><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu" class="header-anchor">#</a></h3><p><a name="power_on_sequence"></a></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</span><a href="#5-1-4-ji-cun-qi-miao-shu" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<h2><span id="5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</span><a href="#5-2-duo-dian-hong-mo-mt-xie-yi" class="header-anchor">#</a></h2><p>多点电容触摸屏协议，文档路径为：<code>Documentation/input/multitouch-protocol.txt。</code></p>
<p>老版本的 2.x 版本 linux 内核是不支持多点电容触摸的(<code>Multi-touch，简称 MT</code>)，MT 协议是后面加入 的。</p>
<p>MT 协议被分为两种类型，<code>Type A</code> 和 <code>TypeB</code>，这两种类型的区别如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)。</span><br><span class="line">Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个 触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</span><a href="#5-2-1-abs-mt-shi-jian" class="header-anchor">#</a></h3><p>ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 <code>include/uapi/linux/input.h</code> 中,  上报给 linux 内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_SLOT 0x2f <span class="comment">/* MT slot being modified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MAJOR 0x30 <span class="comment">/* Major axis of touching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MINOR 0x31 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MAJOR 0x32 <span class="comment">/* Major axis of approaching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MINOR 0x33 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_ORIENTATION 0x34 <span class="comment">/* Ellipse orientation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_X 0x35 <span class="comment">/* Center X touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_Y 0x36 <span class="comment">/* Center Y touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_TYPE 0x37 <span class="comment">/* Type of touching device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_BLOB_ID 0x38 <span class="comment">/* Group a set of packets as a blob */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TRACKING_ID 0x39 <span class="comment">/* Unique ID of initiated contact */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_PRESSURE 0x3a <span class="comment">/* Pressure on contact area */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_DISTANCE 0x3b <span class="comment">/* Contact hover distance */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_X 0x3c <span class="comment">/* Center X tool position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_Y 0x3d <span class="comment">/* Center Y tool position */</span></span></span><br></pre></td></tr></table></figure>

<p><code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>用来上 报触摸 点的 (X,Y) 坐标 信息。<code>ABS_MT_SLOT </code>用来上 报触摸点 ID ， 对 于 Type B 类型的设备，需要用到 <code>ABS_MT_TRACKING_ID </code>事件来区分触摸点。</p>
<h4><span id="5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</span><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code> Type A</code> 类型的设备，通过<code> input_mt_sync()</code>函数来隔离不同的触摸点数据信息。<code>nput_mt_sync() </code>函数会触发 <code>SYN_MT_REPORT </code>事件，此事件会通知接收者获取当前触摸数据，并且准备接收 下一个触摸点数据。</p>
<p><code>void input_mt_sync(struct input_dev *dev);</code></p>
<h4><span id="5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</span><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code>Type B</code>类型的设备，上报触摸点信息的时候需要通过<code> input_mt_slot()</code>函数区分是哪一 个触摸点。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是 哪个触摸点信息。<code>input_mt_slot()</code>函数会触发 <code>ABS_MT_SLOT </code>事件，此事件会告诉接收者当前 正在更新的是哪个触摸点(slot)的数据。</p>
<h4><span id="5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</span><a href="#5-2-1-3-input-sync-jie-shu-shang-bao" class="header-anchor">#</a></h4><p>不管是哪个类型的设备，最终都要调用<code> input_sync()</code>函数来标识多点触摸信息传输完成，告 诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p>
<p>可以通过 slot 的 <code>ABS_MT_TRACKING_ID </code>来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个 新加的触摸点，一个 ID 如果再也不存在了就表示删除了。上报 <code>SYN_REPORT </code>事件。</p>
<h4><span id="5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</span><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao" class="header-anchor">#</a></h4><p>上报触摸屏原始数据。</p>
<p><code>void input_report_abs(struct input_dev *dev, unsigned int code, int value);</code></p>
<h3><span id="5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</span><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据，通过input_report_abs 函数实现，下面同理</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报第一个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line"></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//上报第二个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件,通知接收者获取坐标</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核里面也有<code> Type A</code> 类型的多点触摸驱动，如<code> st2332.c</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image-20240825151728439"></p>
<h3><span id="5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</span><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><p>对于<code>Type B</code>类型的设备，发送触摸点信息的时序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT <span class="number">0</span> <span class="comment">/* 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line"><span class="comment">    每次上报一个触摸点坐标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID，需要由触摸 IC 提供</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span> <span class="comment">/*根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过</span></span><br><span class="line"><span class="comment">	修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到</span></span><br><span class="line"><span class="comment">	的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数</span></span><br><span class="line"><span class="comment">	active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指</span></span><br><span class="line"><span class="comment">	定具体的 ABS_MT_TRACKING_ID 值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 y 轴坐标</span></span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span> <span class="comment">//同理， 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>] <span class="comment">//坐标1的x</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>] <span class="comment">//坐标1的y</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>当一个触摸点移除以后，同样需要通过 SLOT 关联的<code>ABS_MT_TRACKING_ID</code>来处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_TRACKING_ID <span class="number">-1</span> <span class="comment">/*当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一</span></span><br><span class="line"><span class="comment">个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的</span></span><br><span class="line"><span class="comment">第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure>

<p>Linux 内核里面有大量的 <code>Type B</code> 类型的多点触摸驱动程序,<code>drivers/input/touchscreen/ili210x.c </code>上报示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ili210x_report_events</span><span class="params">(<span class="keyword">struct</span> input_dev *input, <span class="type">const</span> <span class="keyword">struct</span> touchdata *touchdata)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">bool</span> touch;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">finger</span> *<span class="title">finger</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_TOUCHES; i++) &#123;</span><br><span class="line">		input_mt_slot(input, i);<span class="comment">//上报ABS_MT_SLOT事件</span></span><br><span class="line">		finger = &amp;touchdata-&gt;finger[i];</span><br><span class="line">		touch = touchdata-&gt;status &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="comment">//上报ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件</span></span><br><span class="line">		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);</span><br><span class="line">		<span class="keyword">if</span> (touch) &#123;</span><br><span class="line">			x = finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			y = finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_X, x);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_Y, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	input_mt_report_pointer_emulation(input, <span class="literal">false</span>);</span><br><span class="line">	input_sync(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</span><a href="#5-2-4-abs-mt-qi-ta-shi-jian" class="header-anchor">#</a></h3><p>如果设备支持的话，还可以使用 <code>ABS_MT_TOUCH_MAJOR</code> 和 <code>ABS_MT_WIDTH_MAJOR</code> 这两个消息上报触摸面积信息，关于 其他 ABS_MT 事件的具体含义大家可以查看 Linux 内核中的 <code>multi-touch-protocol.txt</code> 文档。</p>
<h4><span id="5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</span><a href="#5-2-4-1-abs-mt-tool-type" class="header-anchor">#</a></h4><p>上报触摸工具类型。</p>
<p>很多内核驱动都不能区分出触摸设备类型 ，是手指还是触摸 笔？ 这种情况下， 这个事件可以忽略掉 。目前的协议支持 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MT_TOOL_FINGER(手指)</span><br><span class="line">MT_TOOL_PEN(笔)</span><br><span class="line">MT_TOOL_PALM(手掌)这三种触摸设备类型</span><br></pre></td></tr></table></figure>

<p>要 上 报 ABS_MT_TOOL_TYPE 事件，那么可以使用<code> input_mt_report_slot_state</code> 函数来完成此工作。</p>
<h2><span id="5-3-duo-dian-hong-mo-api">5.3 多点触摸API</span><a href="#5-3-duo-dian-hong-mo-api" class="header-anchor">#</a></h2><h3><span id="5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</span><a href="#5-3-1-input-mt-init-slots" class="header-anchor">#</a></h3><p>初始化 MT 的输入 slots槽，<code>drivers/input/input-mt.c</code>。</p>
<p><code>int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots, unsigned int flags);</code></p>
<p>num_slots: 要使用的 SLOT 数量，也就是触摸点的数量。</p>
<p>flags：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_POINTER 0x0001 <span class="comment">/* pointer device, e.g. trackpad */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DIRECT 0x0002 <span class="comment">/* direct device, e.g. touchscreen */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DROP_UNUSED0x0004 <span class="comment">/* drop contacts not seen in frame */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_TRACK 0x0008 <span class="comment">/* use in-kernel tracking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_SEMI_MT 0x0010 <span class="comment">/* semi-mt device, finger count handled manually */</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="5-3-2-input-mt-slot">5.3.2 input_mt_slot</span><a href="#5-3-2-input-mt-slot" class="header-anchor">#</a></h3><p> Type B类型，此函数用于产生 <code>ABS_MT_SLOT </code>事件，告诉内核当前上报的是哪个触摸点的坐标数据，定义在文件<code> include/linux/input/mt.h</code>。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。</p>
<h3><span id="5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</span><a href="#5-3-3-input-mt-report-slot-state" class="header-anchor">#</a></h3><p>Type B类型，用于产生<code>ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE </code>事件 ，<code>ABS_MT_TRACKING_ID</code>事件给slot关联一个<code>ABS_MT_TRACKING_ID </code>，<code> ABS_MT_TOOL_TYPE</code>事件指定触摸类型（是笔还是手指等 ）。此函数定义在文件<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, bool active);</code></p>
<p>tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或 MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。 </p>
<p>active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。 false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸 点溢出。</p>
<h3><span id="5-3-4-input-report-abs">5.3.4 input_report_abs</span><a href="#5-3-4-input-report-abs" class="header-anchor">#</a></h3><p>上报<code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>事件，上报坐标。include&#x2F;linux&#x2F;input.h。</p>
<p><code>void input_report_abs( struct input_dev *dev, unsigned int code, int value);</code></p>
<p><code>code</code>：要上报的是什么数据，设置为<code> ABS_MT_POSITION_X</code> 或 <code>ABS_MT_POSITION_Y</code></p>
<p><code>value</code>：具体的 X 轴或 Y 轴坐标数据值。</p>
<h3><span id="5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</span><a href="#5-3-5-input-mt-report-pointer-emulation" class="header-anchor">#</a></h3><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 <code>BTN_TOOL_TAP</code> 事件来通 知用户空间当前追踪到的触摸点总数量，然后调用<code>input_mt_report_pointer_emulation</code>函数将 <code>use_count</code> 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)，<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count);</code></p>
<p><code>use_count</code>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量.</p>
<h2><span id="5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</span><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426" class="header-anchor">#</a></h2><h3><span id="5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</span><a href="#5-4-1-she-bei-shu-tian-jia" class="header-anchor">#</a></h3><h4><span id="5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</span><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_tsc: tscgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="number">0xF080</span> <span class="comment">/* TSC_INT */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_tsc_reset: tsc_reset &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 <span class="number">0x10B0</span> <span class="comment">/* TSC_RST */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;</span><br><span class="line">pinctrl_i2c2: i2c2grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART5_TX_DATA__I2C2_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART5_RX_DATA__I2C2_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>触摸屏要用到4个IO, i2c 2个引脚和1个<code>RST</code>, 1个<code>INT</code>引脚。</p>
<h4><span id="5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</span><a href="#5-4-1-2-ft5426-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">	clock_frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c2&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	......</span><br><span class="line">	ft5426: ft5426@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">		pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">		pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_tsc</span><br><span class="line">			&amp;pinctrl_tsc_reset&gt;;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">		interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">		reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		interrupt-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>找到<code>i2c2</code>节点，引用<code>pinctrl_i2c2</code>，设置好I2c的iomux。设置时钟100k, status开启okay。</p>
<p>添加子节点<code>ft5426</code>，器件地址为 <code>0X38</code>，引用<code>pinctrl_tsc</code>， <code>pinctrl_tsc_reset</code>设置<code>rst</code>和<code>int</code>引脚的iomux。</p>
<p><code>interrupt-parent</code> 属性描述中断 IO 对应的 GPIO 组为<code> GPIO1</code>。</p>
<p><code>interrupts</code> 属性描述中断 IO 对应的是 GPIO1 组的<code> IOI09</code>。</p>
<p><code>reset-gpios </code>属性描述复位 IO 对应的 GPIO 为 <code>GPIO5_IO09</code>。</p>
<p><code>interrupt-gpios </code>属性描述中断 IO 对应的 GPIO 为 <code>GPIO1_IO09</code>。</p>
<h3><span id="5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</span><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi" class="header-anchor">#</a></h3><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ft5x06.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ratelimit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/debugfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/mt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/edt-ft5x06.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SUPPORT_POINTS		5			<span class="comment">/* 5点触摸 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_DOWN		0x00		<span class="comment">/* 按下 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_UP			0x01		<span class="comment">/* 抬起 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_ON			0x02		<span class="comment">/* 接触 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_RESERVED	0x03		<span class="comment">/* 保留 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FT5X06寄存器相关宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_TD_STATUS_REG	0X02		<span class="comment">/*	状态寄存器地址 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5x06_DEVICE_MODE_REG	0X00 		<span class="comment">/* 模式寄存器 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5426_IDG_MODE_REG		0XA4		<span class="comment">/* 中断模式				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_READLEN			29			<span class="comment">/* 要读取的寄存器个数 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 				<span class="comment">/* 设备节点 		*/</span></span><br><span class="line">	<span class="type">int</span> irq_pin,reset_pin;					<span class="comment">/* 中断和复位IO		*/</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号    		*/</span></span><br><span class="line">	<span class="type">void</span> *private_data;						<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span>				<span class="comment">/* input结构体 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span>				<span class="comment">/* I2C客户端 		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> <span class="title">ft5x06</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_reset</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;reset_pin)) &#123;</span><br><span class="line">		<span class="comment">/* 申请复位IO，并且默认输出低电平 */</span></span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev,	</span><br><span class="line">					dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,</span><br><span class="line">					<span class="string">&quot;edt-ft5x06 reset&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		msleep(<span class="number">5</span>);</span><br><span class="line">		gpio_set_value(dev-&gt;reset_pin, <span class="number">1</span>);<span class="comment">/* 输出高电平，停止复位 */</span></span><br><span class="line">		msleep(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_read_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;					<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;					<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;						<span class="comment">/* reg长度*/</span></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;			<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;					<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;					<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ft5x06_write_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ft5x06_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">ft5x06_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> *<span class="title">multidata</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">	u8 rdbuf[<span class="number">29</span>];</span><br><span class="line">	<span class="type">int</span> i, type, x, y, id;</span><br><span class="line">	<span class="type">int</span> offset, tplen;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">bool</span> down;</span><br><span class="line"></span><br><span class="line">	offset = <span class="number">1</span>; 	<span class="comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span></span><br><span class="line">	tplen = <span class="number">6</span>;		<span class="comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(rdbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(rdbuf));		<span class="comment">/* 清除 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span></span><br><span class="line">	ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 上报每一个触摸点坐标 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">		u8 *buf = &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span></span><br><span class="line"><span class="comment">		 * bit5:4  保留</span></span><br><span class="line"><span class="comment">		 * bit3:0  X轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		type = buf[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>;     <span class="comment">/* 获取触摸类型 */</span></span><br><span class="line">		<span class="keyword">if</span> (type == TOUCH_EVENT_RESERVED)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span></span><br><span class="line">		x = ((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">3</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		y = ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span></span><br><span class="line"><span class="comment">		 * bit3:0  Y轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		id = (buf[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">		down = type != TOUCH_EVENT_UP;</span><br><span class="line"></span><br><span class="line">		input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">		input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!down)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_mt_report_pointer_emulation(multidata-&gt;input, <span class="literal">true</span>);</span><br><span class="line">	input_sync(multidata-&gt;input);</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_irq</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;irq_pin)) &#123;</span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,</span><br><span class="line">					GPIOF_IN, <span class="string">&quot;edt-ft5x06 irq&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,</span><br><span class="line">				dev-&gt;irq_pin, ret);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line">					ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">					client-&gt;name, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;client-&gt;dev, <span class="string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06.client = client;</span><br><span class="line"></span><br><span class="line">	ft5x06.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;interrupt-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	ft5x06.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_reset(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_irq(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4，初始化FT5X06 */</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, <span class="number">0</span>); 	<span class="comment">/* 进入正常模式 	*/</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, <span class="number">1</span>); 		<span class="comment">/* FT5426中断模式	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5，input设备注册 */</span></span><br><span class="line">	ft5x06.input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!ft5x06.input) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ft5x06.input-&gt;name = client-&gt;name;</span><br><span class="line">	ft5x06.input-&gt;id.bustype = BUS_I2C;</span><br><span class="line">	ft5x06.input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line">	__set_bit(EV_KEY, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(EV_ABS, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_X, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_Y, <span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,<span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,<span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);	     </span><br><span class="line">	ret = input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = input_register_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span>&#123;</span><br><span class="line">	input_unregister_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_ts_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5206&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5426&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ft5x06_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_ts_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.name = <span class="string">&quot;edt_ft5x06&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(ft5x06_of_match),</span><br><span class="line">	&#125;,</span><br><span class="line">	.id_table = ft5x06_ts_id,</span><br><span class="line">	.probe    = ft5x06_ts_probe,</span><br><span class="line">	.remove   = ft5x06_ts_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ft5x06_ts_driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ft5x06_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ft5x06_init);</span><br><span class="line">module_exit(ft5x06_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

</details>

<h4><span id="5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</span><a href="#5-4-2-1-probe-guo-cheng" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<p>dts中的<code>compatible</code>和驱动匹配，<code>of_match_table</code>匹配，因此触发probe函数。可以看到FT5426使用的标准I2C从设备驱动框架<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统 | Hexo (fuzidage.github.io)</a>。因为使用的I2c2。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p>由于<code>i2c_client</code>描述i2c从设备的i2c相关硬件信息。 一个<code>i2c_driver</code>可以支持多个同类型的<code>i2c_client</code>。<code>i2c_client</code>一般描述在设备树中, 这里<code>对应i2c2的ft5426子节点</code>。</p>
<ol>
<li><p>当驱动和设备匹配，<code>ft5x06_ts_probe</code>执行。首先获取dts中的属性<code>reset-gpios</code>,<code>interrupt-gpios</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.1.png" alt="image"></p>
</li>
<li><p>对复位引脚进行复位。（参考<a href="#power_on_sequence">5.1.3上电复位时序</a>）</p>
</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<ol start="3">
<li>注册中断服务</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/33.png" alt="image"></p>
<ol start="4">
<li><p>初始化ft5426内部寄存器</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/34.png" alt="image"></p>
</li>
<li><p>利用input子系统设置MT协议参数，并且注册input设备。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/35.png" alt="image"></p>
</li>
</ol>
<p>需要上报的事件为 <code>EV_KEY 和 EV_ABS</code>，需要上报的按键码为<code> BTN_TOUCH</code>(<code>BTN_TOUCH见include\uapi\linux\input-event-codes.h</code>)。<code>EV_KEY </code>是按键事件，用于上报触摸屏是否被按下，相当于把触摸屏当做一个按键。<code>EV_ABS </code>是触摸点坐标数据，<code>BTN_TOUCH </code>表示将触摸屏的按下和抬起用作 <code>BTN_TOUCH </code>按键。</p>
<p><code>input_set_abs_params </code>函数设置 EV_ABS 事件需要上报 <code>ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y</code>。单点触摸需要上报<code>ABS_X</code> 和<code> ABS_Y</code>，对于多点触摸需要上报 <code>ABS_MT_POSITION_X </code>和<code> ABS_MT_POSITION_Y</code>。</p>
<p><code>input_mt_init_slots</code> 函数初始 化 slots，也就是最大触摸点数量，FT5426 是个 5 点电容触摸芯片，因此一共 5 个 slot。</p>
<h4><span id="5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</span><a href="#5-4-2-2-i2c-shu-ju-chuan-shu" class="header-anchor">#</a></h4><p>其实就是i2c数据传输的应用。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统 | Hexo (fuzidage.github.io)</a>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/36.png" alt="image"></p>
<p>读过程：</p>
<p>构造<code>i2c_msg[0]</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要读哪个寄存器地址。</p>
<p>构造<code>i2c_msg[1]</code>，flag&#x3D;1表示读，先发送i2c从设备器件地址0x38。然后传入要读的buf。</p>
<p>写过程：</p>
<p>构造<code>i2c_msg</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要写哪个寄存器地址和写入的内容。</p>
<h4><span id="5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</span><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/37.png" alt="image"></p>
<ol>
<li>通过<code>I2c_read</code>获取寄存器值。一共29个寄存器，读出29 byte。从0X02寄存器开始读。</li>
<li>for循环内部用来拆解坐标信息，上报每一个点的坐标。</li>
<li>最后调用<code>input_sync</code>上传上报<code>SYN_REPORT</code>事件。</li>
</ol>
<h3><span id="5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</span><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/38.png" alt="image"></p>
<p>驱动加载成功以后就会生成<code>/dev/input/eventX</code>(X&#x3D;1,2,3…)</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/39.png" alt="image"></p>
<h4><span id="5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</span><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi" class="header-anchor">#</a></h4><p><code>hexdump /dev/input/event2</code>可以查看原始数据。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/40.png" alt="image"></p>
<p>第1行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x2f</code>，为<code>ABS_MT_SLOT</code>，因此这一行就是<code>input_mt_slot</code>函数上报的<code>ABS_MT_SLOT</code>事件。value&#x3D;0，说明接下来上报的是第一个触摸点坐标。</p>
<p>第2行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，这一行就是<code>input_mt_report_slot_state</code>函数上报<code>ABS_MT_TRACKING_ID</code>事件。<code>value=5</code>说明给<code>SLOT0</code>分配的ID为5。</p>
<p>​		第3行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x35</code>，为<code>ABS_MT_POSITION_X</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_X</code>事件，也就是触摸点的X轴坐标。<code>value=0x03ec=1004</code>，说明触摸点X轴坐标为1004，属于屏幕右上角区域。</p>
<p>​		第4行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x36</code>，为<code>ABS_MT_POSITION_Y</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_Y</code>事件，也就是触摸点的Y轴坐标。<code>value=0x17=23</code>，说明Y轴坐标为23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</p>
<p>​		第5行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x1</code>表示触摸屏被按下。</p>
<p>​		第6行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x0</code>，为<code>ABS_X</code>，用于单点触摸的时候上报X轴坐标。在这里和<code>ABS_MT_POSITION_X</code>相同，<code>value也为0x3f0=1008</code>。ABS_X是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>​		第7行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x1</code>，为<code>ABS_Y</code>，用于单点触摸的时候上报Y轴坐标。在这里和<code>ABS_MT_POSITION_Y</code>相同，<code>value也为0x17=23</code>。ABS_Y是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>第8行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>第9行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，<code>value=0xffffffff=-1</code>，说明触摸点离开了屏幕。</p>
<p>第10行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x0</code>表示手指离开触摸屏，也就是触摸屏没有被按下了。</p>
<p>第11行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>以上就是一个触摸点的坐标上报过程。</p>
<h2><span id="5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</span><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong" class="header-anchor">#</a></h2><p>打开<code>driver/input/touchscreen/Makefile</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/41.png" alt="image"></p>
<p>linux内核默认已经帮我们实现了这款<code>edt-ft5x06.c</code>触摸屏驱动。此驱动文件不仅仅 能够驱动 <code>FT5426，FT5206、FT5406 </code>这些都可以驱动。</p>
<p><code>make menuconfig</code>,选中这款触摸屏即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line"> -&gt; Device Drivers</span><br><span class="line"> 	-&gt; Input device support</span><br><span class="line"> 		-&gt; Generic input layer (needed <span class="keyword">for</span> keyboard, mouse, ...) (INPUT [=y])</span><br><span class="line">			-&gt; Touchscreens (INPUT_TOUCHSCREEN [=y])</span><br><span class="line">				-&gt; &lt;*&gt; EDT FocalTech FT5x06 I2C Touchscreen support</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/42.png" alt="image"></p>
<p>编译后开机如下打印：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/43.png" alt="image"></p>
<p>直接运行 ts_test_mt 来测试触摸屏是否可以使用。</p>
<h1><span id="6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</span><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux/kconfig.h:<span class="number">73</span>:<span class="meta">#<span class="keyword">define</span> IS_ENABLED(option) __or(IS_BUILTIN(option), IS_MODULE(option))</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxogeb004oqsuf7aku34qn" data-title="字符设备驱动-input子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-SPI子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T11:02:38.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-spi-qu-dong-kuang-jia">1 Linux SPI驱动框架</a><ul>
<li><a href="#1-1-spi-he-xin-ceng">1.1 spi核心层</a><ul>
<li><a href="#1-1-1-he-xin-ceng-chu-shi-hua">1.1.1 核心层初始化</a><ul>
<li><a href="#1-1-1-1-spi-init">1.1.1.1 spi_init</a></li>
<li><a href="#1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei">1.1.1.2 spi从设备和驱动的匹配</a></li>
</ul>
</li>
<li><a href="#1-1-2-he-xin-ceng-api">1.1.2 核心层API</a><ul>
<li><a href="#1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong">1.1.2.1 spi_register_master-(供适配层调用)</a><ul>
<li><a href="#1-1-2-1-1-spi-controller-initialize-queue-spi-master-initialize-queue">1.1.2.1.1 spi_controller_initialize_queue&#x2F;spi_master_initialize_queue</a></li>
</ul>
</li>
<li><a href="#1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong">1.1.2.2 spi_message_init-(供从设备调用)</a></li>
<li><a href="#1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong">1.1.2.3 spi_message_add_tail-(供从设备调用)</a></li>
<li><a href="#1-1-2-4-spi-async-gong-cong-she-bei-diao-yong">1.1.2.4 spi_async-(供从设备调用)</a><ul>
<li><a href="#1-1-2-4-1-spi-queued-transfer">1.1.2.4.1 spi_queued_transfer</a></li>
</ul>
</li>
<li><a href="#1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong">1.1.2.4 spi_sync-(供从设备调用)</a></li>
<li><a href="#1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong">1.1.2.5 spi_bitbang_start-(供适配层调用)</a><ul>
<li><a href="#1-1-2-5-1-spi-register-master">1.1.2.5.1 spi_register_master</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-spi-kong-zhi-qi-qu-dong-ceng">1.2 SPI控制器驱动层</a><ul>
<li><a href="#1-2-1-spi-kong-zhi-qi-api">1.2.1 SPI控制器API</a><ul>
<li><a href="#1-2-1-1-spi-alloc-master">1.2.1.1 spi_alloc_master</a></li>
<li><a href="#1-2-1-2-spi-master-put">1.2.1.2 spi_master_put</a></li>
<li><a href="#1-2-1-3-spi-register-master-spi-register-controller">1.2.1.3 spi_register_master&#x2F;spi_register_controller</a></li>
<li><a href="#1-2-1-4-spi-unregister-master-spi-unregister-controller">1.2.1.4 spi_unregister_master&#x2F;spi_unregister_controller</a></li>
</ul>
</li>
<li><a href="#1-2-2-spi-kong-zhi-qi-shi-li">1.2.2 SPI控制器示例</a><ul>
<li><a href="#1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu">1.2.2.1 spi控制器设备树描述</a></li>
<li><a href="#1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong">1.2.2.2 imx6ul spi控制器驱动</a><ul>
<li><a href="#1-2-2-2-1-probe-chu-shi-hua-spi-master">1.2.2.2.1 probe-(初始化spi_master)</a></li>
<li><a href="#1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi">1.2.2.2.2 spi_imx_setupxfer-(设置位宽和配置控制器)</a></li>
<li><a href="#1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa">1.2.2.2.3 spi_imx_transfer-(数据收发)</a></li>
<li><a href="#1-2-2-2-4-spi-imx-isr">1.2.2.2.4 spi_imx_isr</a></li>
<li><a href="#1-2-2-2-5-spi-imx-chipselect-pian-xuan">1.2.2.2.5 spi_imx_chipselect-(片选)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-spi-cong-she-bei-qu-dong-ceng">1.3 SPI从设备驱动层</a><ul>
<li><a href="#1-3-1-spi-cong-she-bei-api">1.3.1 SPI从设备API</a><ul>
<li><a href="#1-3-1-1-spi-message-init">1.3.1.1 spi_message_init</a></li>
<li><a href="#1-3-1-2-spi-message-add-tail">1.3.1.2 spi_message_add_tail</a></li>
<li><a href="#1-3-1-3-spi-async">1.3.1.3 spi_async</a></li>
<li><a href="#1-3-1-4-spi-sync">1.3.1.4 spi_sync</a></li>
<li><a href="#1-3-1-5-spi-register-driver">1.3.1.5 spi_register_driver</a></li>
<li><a href="#1-3-1-6-spi-unregister-driver">1.3.1.6 spi_unregister_driver</a></li>
<li><a href="#1-3-1-7-spi-read-spi-write">1.3.1.7 spi_read&#x2F;spi_write</a></li>
</ul>
</li>
<li><a href="#1-3-2-spi-cong-she-bei-shi-li-icm-20608-g">1.3.2 SPI从设备示例-ICM-20608-G</a><ul>
<li><a href="#1-3-2-1-dts-miao-shu">1.3.2.1 dts描述</a><ul>
<li><a href="#1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze">1.3.2.1.1 spi从设备dts描述规则</a></li>
</ul>
</li>
<li><a href="#1-3-2-2-icm20608-qu-dong">1.3.2.2 ICM20608驱动</a><ul>
<li><a href="#1-3-2-2-1-icm20608reg-h">1.3.2.2.1 icm20608reg.h</a></li>
<li><a href="#1-3-2-2-2-icm20608-c">1.3.2.2.2 icm20608.c</a><ul>
<li><a href="#1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi">1.3.2.2.2.1 驱动过程分析</a></li>
</ul>
</li>
<li><a href="#1-3-2-2-3-icm20608app-c">1.3.2.2.3 icm20608App.c</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c">1.3.3 SPI万能从设备驱动-spidev.c</a><ul>
<li><a href="#1-3-3-1-spidev-init">1.3.3.1 spidev_init</a></li>
<li><a href="#1-3-3-2-spidev-de-probe">1.3.3.2 spidev的probe</a></li>
<li><a href="#1-3-3-3-spidev-fops">1.3.3.3 spidev_fops</a><ul>
<li><a href="#1-3-3-3-1-spidev-read">1.3.3.3.1 spidev_read</a></li>
<li><a href="#1-3-3-3-2-spidev-write">1.3.3.3.2 spidev_write</a></li>
<li><a href="#1-3-3-3-3-spidev-ioctl">1.3.3.3.3 spidev_ioctl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.4 使用SPI万能驱动oled举例</a><ul>
<li><a href="#1-3-4-1-spi-oled-yuan-li">1.3.4.1 spi oled原理</a></li>
<li><a href="#1-3-4-2-spi-oled-c">1.3.4.2 spi_oled.c</a><ul>
<li><a href="#1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi">1.3.4.2.1 用户态驱动分析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.5 不使用SPI万能驱动oled举例</a><ul>
<li><a href="#1-3-5-1-dts-miao-shu">1.3.5.1 dts描述</a></li>
<li><a href="#1-3-5-2-oled-drv-c">1.3.5.2 oled_drv.c</a><ul>
<li><a href="#1-3-5-2-1-qu-dong-fen-xi">1.3.5.2.1 驱动分析</a></li>
</ul>
</li>
<li><a href="#1-3-5-3-spi-oled-c-ying-yong-ce-shi">1.3.5.3 spi_oled.c应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-spi-master-spi-controller">2.1 spi_master&#x2F;spi_controller</a></li>
<li><a href="#2-2-spi-driver">2.2 spi_driver</a></li>
<li><a href="#2-3-spi-device">2.3 spi_device</a></li>
<li><a href="#2-4-spi-message-spi-transfer">2.4 spi_message&#x2F;spi_transfer</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-linux-spi-qu-dong-kuang-jia">1 Linux SPI驱动框架</span><a href="#1-linux-spi-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>linux SPI驱动框架层次如上图：</p>
<p>除开硬件和用户态应用程序，由上到下分成3层：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设备驱动层: spi框架使用者</span><br><span class="line">核心层：spi框架搭建者</span><br><span class="line">控制器驱动层： spi框架适配者</span><br></pre></td></tr></table></figure>

<h2><span id="1-1-spi-he-xin-ceng">1.1 spi核心层</span><a href="#1-1-spi-he-xin-ceng" class="header-anchor">#</a></h2><p>SPI核心层代码位于<code>linux_5.10\drivers\spi</code>目录:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPDX-License-Identifier: GPL-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Makefile for kernel SPI drivers.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">ccflags-<span class="variable">$(CONFIG_SPI_DEBUG)</span> := -DDEBUG</span><br><span class="line"><span class="comment"># small core, mostly translating board-specific</span></span><br><span class="line"><span class="comment"># config declarations into driver model code</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MASTER)</span>		+= spi.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MEM)</span>			+= spi-mem.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_MUX)</span>			+= spi-mux.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_SPIDEV)</span>		+= spidev.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_LOOPBACK_TEST)</span>		+= spi-loopback-test.o</span><br><span class="line"><span class="comment"># SPI master controller drivers (bus)</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ALTERA)</span>		+= spi-altera.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AR934X)</span>		+= spi-ar934x.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ARMADA_3700)</span>		+= spi-armada-3700.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATMEL)</span>			+= spi-atmel.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATMEL_QUADSPI)</span>		+= atmel-quadspi.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AT91_USART)</span>		+= spi-at91-usart.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_ATH79)</span>			+= spi-ath79.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AU1550)</span>		+= spi-au1550.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_AXI_SPI_ENGINE)</span>	+= spi-axi-spi-engine.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_SPI_BCM2835)</span>		+= spi-bcm2835.o</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">drivers/spi/spi.c spi-mem.c spi-mux.c</span><br><span class="line">include/linux/spi/spi.h</span><br><span class="line">spi.c：</span><br><span class="line">    一方面对SPI子系统进行初始化工作，注册spi bus，注册spi_master <span class="class"><span class="keyword">class</span>，</span></span><br><span class="line"><span class="class">    同时提供<span class="title">spi</span>设备驱动对<span class="title">spi</span>总线进行操作的<span class="title">API</span>。</span></span><br><span class="line"><span class="class">    另一方面<span class="title">SPI</span>子系统对<span class="title">spi</span>控制器层，提供注册控制器的<span class="title">api</span>和回调操作函数。</span></span><br><span class="line"><span class="class"><span class="title">spi</span>.<span class="title">h</span>包含了<span class="title">spi</span>核心层的一些重要数据结构，<span class="keyword">struct</span> <span class="title">spi_master</span>;</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>;</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span>，以及一些实现比较简单的函数等。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">spi</span>-<span class="title">gpio</span>.<span class="title">c</span>：<span class="title">SPI</span> <span class="title">GPIO</span>框架：<span class="title">SPI</span>子系统提供了一个名为<span class="title">spi</span>-<span class="title">gpio</span>的框架，</span></span><br><span class="line"><span class="class">        可使用<span class="title">GPIO</span>引脚模拟<span class="title">SPI</span>总线，<span class="title">gpio</span>模拟<span class="title">spi</span>代码在<span class="title">drivers</span>/<span class="title">spi</span>/<span class="title">spi</span>-<span class="title">gpio</span>.<span class="title">c</span>中。</span></span><br><span class="line"><span class="class">        这个框架允许将<span class="title">GPIO</span>引脚配置为<span class="title">SPI</span>总线的时钟、片选、输入和输出信号，</span></span><br><span class="line"><span class="class">        并提供了对应的接口函数供驱动程序使用。</span></span><br><span class="line"><span class="class"><span class="title">spi</span>-<span class="title">bitbang</span>：<span class="title">spi</span>-<span class="title">bitbang</span>是<span class="title">Linux</span>内核中提供的一个通用框架，用于在没有硬件<span class="title">SPI</span>控制器</span></span><br><span class="line"><span class="class">        或需要灵活控制<span class="title">SPI</span>时序和配置的系统中模拟<span class="title">SPI</span>总线的通信。代码在<span class="title">spi</span>-<span class="title">bitbang</span>.<span class="title">c</span>中</span></span><br></pre></td></tr></table></figure>

<p>核心层的作用:</p>
<p>对上层的使用者，也就是SPI设备驱动：提供标准的spi收发API，以及设备注册函数。<br>对底下的适配者，也就是控制器驱动层：提供注册控制器接口，并提供一些需要控制器驱动实现的回调函数。</p>
<h3><span id="1-1-1-he-xin-ceng-chu-shi-hua">1.1.1 核心层初始化</span><a href="#1-1-1-he-xin-ceng-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="1-1-1-1-spi-init">1.1.1.1 spi_init</span><a href="#1-1-1-1-spi-init" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span>	status;</span><br><span class="line">	buf = kmalloc(SPI_BUFSIZ, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!buf) &#123;</span><br><span class="line">		status = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> err0;</span><br><span class="line">	&#125;</span><br><span class="line">	status = bus_register(&amp;spi_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	status = class_register(&amp;spi_master_class);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_SPI_SLAVE)) &#123;</span><br><span class="line">		status = class_register(&amp;spi_slave_class);</span><br><span class="line">		<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> err3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_OF_DYNAMIC))</span><br><span class="line">		WARN_ON(of_reconfig_notifier_register(&amp;spi_of_notifier));</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_ACPI))</span><br><span class="line">		WARN_ON(acpi_reconfig_notifier_register(&amp;spi_acpi_notifier));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err3:</span><br><span class="line">	class_unregister(&amp;spi_master_class);</span><br><span class="line">err2:</span><br><span class="line">	bus_unregister(&amp;spi_bus_type);</span><br><span class="line">err1:</span><br><span class="line">	kfree(buf);</span><br><span class="line">	buf = <span class="literal">NULL</span>;</span><br><span class="line">err0:</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spi子系统初始化函数，仅仅是注册了<code>spi bus</code>，以及<code>spi_master class</code>。</p>
<p>成功注册后，在<code>/sys/bus </code>下即可找到spi 文件目录，在<code>/sys/class</code>下可以看到spi_master目录:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<h4><span id="1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei">1.1.1.2 spi从设备和驱动的匹配</span><a href="#1-1-1-2-spi-cong-she-bei-he-qu-dong-de-pi-pei" class="header-anchor">#</a></h4><p>当spi总线和类注册后，当有驱动和设备匹配上就会调用<code>spi_match_device</code>，也就是<code>spi_bus_type.match</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_match_device</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span> =</span> to_spi_device(dev);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span>	*<span class="title">sdrv</span> =</span> to_spi_driver(drv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check override first, and if set, only use the named driver */</span></span><br><span class="line">	<span class="keyword">if</span> (spi-&gt;driver_override)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;driver_override, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Then try ACPI */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdrv-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> !!spi_match_id(sdrv-&gt;id_table, spi);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strcmp</span>(spi-&gt;modalias, drv-&gt;name) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>通过<code>of_match_table</code>的<code>compatible</code>和设备树匹配；</li>
<li>通过<code>acpi_match_table</code>的<code>compatible</code>和<code>device</code>的<code>of_node</code>的<code>compatible</code>匹配；</li>
<li>通过驱动和设备的<code>id_table</code>去匹配。</li>
<li>最后通过驱动和设备的<code>名字</code>去匹配。</li>
</ol>
<p>匹配过程参考[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17031328.html">字符设备驱动-2.总线&#x2F;平台设备&#x2F;平台驱动模型</a></p>
<p> <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">字符设备驱动-2-总线模型和平台设备驱动 | Hexo (fuzidage.github.io)</a>。</p>
<h3><span id="1-1-2-he-xin-ceng-api">1.1.2 核心层API</span><a href="#1-1-2-he-xin-ceng-api" class="header-anchor">#</a></h3><h4><span id="1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong">1.1.2.1 spi_register_master-(供适配层调用)</span><a href="#1-1-2-1-spi-register-master-gong-gua-pei-ceng-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_register_master</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	status = of_spi_register_master(master);</span><br><span class="line">	<span class="keyword">if</span> (status)</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	...</span><br><span class="line">	dev_set_name(&amp;master-&gt;dev, <span class="string">&quot;spi%u&quot;</span>, master-&gt;bus_num);</span><br><span class="line">	status = device_add(&amp;master-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;registered master %s%s\n&quot;</span>, dev_name(&amp;master-&gt;dev),</span><br><span class="line">			dynamic ? <span class="string">&quot; (dynamic)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (master-&gt;transfer)</span><br><span class="line">		dev_info(dev, <span class="string">&quot;master is unqueued, this is deprecated\n&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		status = spi_master_initialize_queue(master);</span><br><span class="line">		<span class="keyword">if</span> (status) &#123;</span><br><span class="line">			device_del(&amp;master-&gt;dev);</span><br><span class="line">			<span class="keyword">goto</span> done;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	mutex_lock(&amp;board_lock);</span><br><span class="line">	list_add_tail(&amp;master-&gt;<span class="built_in">list</span>, &amp;spi_master_list);</span><br><span class="line">	list_for_each_entry(bi, &amp;board_list, <span class="built_in">list</span>)</span><br><span class="line">		spi_match_master_to_boardinfo(master, &amp;bi-&gt;board_info);</span><br><span class="line">	mutex_unlock(&amp;board_lock);</span><br><span class="line">	...</span><br><span class="line">	of_register_spi_devices(master);</span><br><span class="line">	...</span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>of_spi_register_master</code>，根据设备树节点中的<code>&quot;cs-gpios&quot;</code>，向<code>struct spi_master</code>添加gpio cs引脚。</p>
</li>
<li><p><code>device_add</code>将device注册到设备模型中。</p>
</li>
<li><p>如果控制器驱动没有自己实现<code>transfer</code>函数，则初始化发送队列<code>spi_master_initialize_queue</code>。（核心层填充默认transfer函数)</p>
</li>
<li><p><code>spi_match_master_to_boardinfo</code>老的方式，遍历所有<code>spi_board_info</code>数据结构，并注册<code>spi_device</code></p>
</li>
<li><p><code>of_register_spi_devices</code>新的设备树方式，遍历spi控制器节点下所有子节点，并注册成对应的<code>spi_device</code>设备</p>
</li>
</ol>
<h5><span id="1-1-2-1-1-spi-controller-initialize-queue-x2f-spi-master-initialize-queue">1.1.2.1.1 spi_controller_initialize_queue&#x2F;spi_master_initialize_queue</span><a href="#1-1-2-1-1-spi-controller-initialize-queue-x2f-spi-master-initialize-queue" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<p>可以看到是对控制器<code>spi_master（或者叫做spi_controller）</code>成员函数赋值。<code>transfer_one_message</code>或者<code>transfer</code>赋值成默认的函数。然后调用<code>spi_init_queue</code>和<code>spi_start_queue</code>函数初始化队列并启动工作线程。<code>spi_init_queue</code>函数最主要的作用就是建立一个内核工作线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_init_queue</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	kthread_init_worker(&amp;master-&gt;kworker);</span><br><span class="line">	master-&gt;kworker_task = kthread_run(kthread_worker_fn,</span><br><span class="line">            &amp;master-&gt;kworker, <span class="string">&quot;%s&quot;</span>, dev_name(&amp;master-&gt;dev));</span><br><span class="line">	......</span><br><span class="line">	kthread_init_work(&amp;master-&gt;pump_messages, spi_pump_messages);</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spi_start_queue</span><span class="params">(<span class="keyword">struct</span> spi_master *master)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	master-&gt;running = <span class="literal">true</span>;</span><br><span class="line">	master-&gt;cur_msg = <span class="literal">NULL</span>;</span><br><span class="line">	......</span><br><span class="line">	kthread_queue_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* spi_init_queue函数先初始化kthread_worker，为kthread_worker创建一个内核线程来处理work，</span></span><br><span class="line"><span class="comment">		随后初始化kthread_work,设置work执行函数，work执行函数为spi_pump_messages</span></span><br><span class="line"><span class="comment">spi_start_queue就相对简单了，只是唤醒该工作线程而已；自此，队列化的相关工作已经完成，</span></span><br><span class="line"><span class="comment">		系统等待message请求被发起，然后在工作线程中处理message的传送工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4><span id="1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong">1.1.2.2 spi_message_init-(供从设备调用)</span><a href="#1-1-2-2-spi-message-init-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p>对<code>spi_massage</code>进行初始化.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init_no_memset</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	INIT_LIST_HEAD(&amp;m-&gt;transfers);</span><br><span class="line">	INIT_LIST_HEAD(&amp;m-&gt;resources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init</span><span class="params">(<span class="keyword">struct</span> spi_message *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span> *m);</span><br><span class="line">	spi_message_init_no_memset(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong">1.1.2.3 spi_message_add_tail-(供从设备调用)</span><a href="#1-1-2-3-spi-message-add-tail-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">spi_message_add_tail</span><span class="params">(<span class="keyword">struct</span> spi_transfer *t, <span class="keyword">struct</span> spi_message *m)</span> &#123;</span><br><span class="line">	list_add_tail(&amp;t-&gt;transfer_list, &amp;m-&gt;transfers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到就是把<code>spi_transfer</code>这个<code>buffer</code>添加到<code>spi_message</code>传输链表中。</p>
<h4><span id="1-1-2-4-spi-async-gong-cong-she-bei-diao-yong">1.1.2.4 spi_async-(供从设备调用)</span><a href="#1-1-2-4-spi-async-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p>发起数据传输。可以看到就是调用控制器内部的<code>master-&gt;transfer</code>。既然是<code>async</code>那就是异步执行的，不会等待传输是否完成，就直接返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spi_async-&gt;</span><br><span class="line">		__spi_async-&gt;</span><br><span class="line">				master-&gt;transfer</span><br></pre></td></tr></table></figure>

<p>那假如<code>master-&gt;transfer</code>控制器这边没有去实现。内核会自己填充默认的transfer函数<code>spi_queued_transfer</code>.</p>
<h5><span id="1-1-2-4-1-spi-queued-transfer">1.1.2.4.1 spi_queued_transfer</span><a href="#1-1-2-4-1-spi-queued-transfer" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spi_queued_transfer(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_message *msg) &#123;</span><br><span class="line">		__spi_queued_transfer(spi, msg, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __spi_queued_transfer(<span class="keyword">struct</span> spi_device *spi,</span><br><span class="line">				 <span class="keyword">struct</span> spi_message *msg,</span><br><span class="line">				 <span class="type">bool</span> need_pump) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> *<span class="title">master</span> =</span> spi-&gt;master;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span><br><span class="line">	...</span><br><span class="line">	list_add_tail(&amp;msg-&gt;<span class="built_in">queue</span>, &amp;master-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	<span class="keyword">if</span> (!master-&gt;busy &amp;&amp; need_pump)</span><br><span class="line">		kthread_queue_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span><br><span class="line">	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到默认的<code>spi_queued_transfer</code>就是去把<code>message</code>添加到<code>master</code>的发送链表中。接下来就交给工作服务线程<code>__spi_pump_messages</code>去处理<code>message</code>。</p>
<h4><span id="1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong">1.1.2.4 spi_sync-(供从设备调用)</span><a href="#1-1-2-4-spi-sync-gong-cong-she-bei-diao-yong" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p>同理，<code>spi_sync</code>就是用来同步传输 <code>spi_message</code>, 完成传输后会调用<code>spi_comlete</code>唤醒等待的线程。</p>
<p>那假如<code>master-&gt;transfer</code>控制器这边没有去实现。内核也会自己填充默认的transfer函数<code>spi_queued_transfer</code>.可以看到<code>need_pump=false</code>,因此还是一样就是去把message添加到master的发送链表中。</p>
<p>然后调用<code>__spi_pump_messages</code>，也就是工作线程服务，交给工作服务线程去处理message。</p>
<p>最后调用<code>wait_for_completion</code>去等待传输完成。</p>
<h4><span id="1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong">1.1.2.5 spi_bitbang_start-(供适配层调用)</span><a href="#1-1-2-5-spi-bitbang-start-gong-gua-pei-ceng-diao-yong" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spi_bitbang_start</span><span class="params">(<span class="keyword">struct</span> spi_bitbang *bitbang)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> *<span class="title">master</span> =</span> bitbang-&gt;master;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master || !bitbang-&gt;chipselect)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;bitbang-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!master-&gt;mode_bits)</span><br><span class="line">        master-&gt;mode_bits = SPI_CPOL | SPI_CPHA | bitbang-&gt;flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;transfer || master-&gt;transfer_one_message)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    master-&gt;prepare_transfer_hardware = spi_bitbang_prepare_hardware;</span><br><span class="line">    master-&gt;unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;</span><br><span class="line">    master-&gt;transfer_one = spi_bitbang_transfer_one;</span><br><span class="line">    master-&gt;set_cs = spi_bitbang_set_cs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!bitbang-&gt;txrx_bufs) &#123;</span><br><span class="line">        bitbang-&gt;use_dma = <span class="number">0</span>;</span><br><span class="line">        bitbang-&gt;txrx_bufs = spi_bitbang_bufs;</span><br><span class="line">        <span class="keyword">if</span> (!master-&gt;setup) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!bitbang-&gt;setup_transfer)</span><br><span class="line">                bitbang-&gt;setup_transfer =</span><br><span class="line">                     spi_bitbang_setup_transfer;</span><br><span class="line">            master-&gt;setup = spi_bitbang_setup;</span><br><span class="line">            master-&gt;cleanup = spi_bitbang_cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* driver may get busy before register() returns, especially</span></span><br><span class="line"><span class="comment">     * if someone registered boardinfo for devices</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = spi_register_master(spi_master_get(master));</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        spi_master_put(master);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>如果主设备结构体中的传输模式位字段 <code>mode_bits</code> 未设置，则设置为默认的模式位，包括 <code>SPI_CPOL</code>、<code>SPI_CPHA </code>和<code>位移传输控制</code>结构体中的标志位。</p>
</li>
<li><p>检查主设备结构体中的传输函数是否已经定义，如果已定义则返回错误码<code> -EINVAL</code>。</p>
</li>
<li><p>设置主设备结构体中的准备硬件传输函数、释放硬件传输函数、单次传输函数和片选信号控制函数，分别对应位移传输控制结构体中的对应函数。</p>
</li>
<li><p>如果位移传输控制结构体中的数据缓冲区传输函数未定义，则设置使用 DMA 标志为 0，并将数据缓冲区传输函数设置为默认的位移传输函数 <code>spi_bitbang_bufs</code>。如果主设备结构体中的设置函数未定义，则设置使用默认的设置函数 <code>spi_bitbang_setup</code> 和清理函数 <code>spi_bitbang_cleanup</code>。</p>
</li>
<li><p>注册 SPI 主设备，将其添加到系统中。</p>
</li>
</ol>
<h5><span id="1-1-2-5-1-spi-register-master">1.1.2.5.1 spi_register_master</span><a href="#1-1-2-5-1-spi-register-master" class="header-anchor">#</a></h5><h2><span id="1-2-spi-kong-zhi-qi-qu-dong-ceng">1.2 SPI控制器驱动层</span><a href="#1-2-spi-kong-zhi-qi-qu-dong-ceng" class="header-anchor">#</a></h2><p>控制器驱动就是用来实现<code>spi_master</code>中的成员函数。如<code>transfer, transfer_one_message</code>。基本流程是：申请 <code>spi_master</code>，然后初始化<code> spi_master</code>，最后向 Linux 内核注册 <code>spi_master</code>。</p>
<h3><span id="1-2-1-spi-kong-zhi-qi-api">1.2.1 SPI控制器API</span><a href="#1-2-1-spi-kong-zhi-qi-api" class="header-anchor">#</a></h3><h4><span id="1-2-1-1-spi-alloc-master">1.2.1.1 spi_alloc_master</span><a href="#1-2-1-1-spi-alloc-master" class="header-anchor">#</a></h4><p>申请spi控制器内存。</p>
<p><code>struct spi_master *spi_alloc_master(struct device *dev, unsigned size);</code></p>
<p>dev：设备，一般是 platform_device 中的 dev 成员变量。 </p>
<p>size：私有数据大小，可以通过<code> spi_master_get_devdata</code> 函数获取到这些私有数据。</p>
<p> 返回值：申请到的 spi_master。</p>
<h4><span id="1-2-1-2-spi-master-put">1.2.1.2 spi_master_put</span><a href="#1-2-1-2-spi-master-put" class="header-anchor">#</a></h4><p> <code>spi_master </code>的释放通过 <code>spi_master_put</code>函数来完成，当我们删除一个 SPI 主机驱动的时候就 需要释放掉前面申请的 spi_master，<code>spi_master_put </code>函数原型如下： </p>
<p><code>void spi_master_put(struct spi_master *master);</code></p>
<p>释放spi控制器内存。</p>
<h4><span id="1-2-1-3-spi-register-master-x2f-spi-register-controller">1.2.1.3 spi_register_master&#x2F;spi_register_controller</span><a href="#1-2-1-3-spi-register-master-x2f-spi-register-controller" class="header-anchor">#</a></h4><p>当 spi_master 初始化完成以后就需要将其注册到 Linux 内核，<code>spi_register_master</code>注册spi控制器。</p>
<p><code>int spi_register_master(struct spi_master *master);</code></p>
<h4><span id="1-2-1-4-spi-unregister-master-x2f-spi-unregister-controller">1.2.1.4 spi_unregister_master&#x2F;spi_unregister_controller</span><a href="#1-2-1-4-spi-unregister-master-x2f-spi-unregister-controller" class="header-anchor">#</a></h4><p>spi控制器卸载。</p>
<p><code>void spi_unregister_master(struct spi_master *master);</code></p>
<h3><span id="1-2-2-spi-kong-zhi-qi-shi-li">1.2.2 SPI控制器示例</span><a href="#1-2-2-spi-kong-zhi-qi-shi-li" class="header-anchor">#</a></h3><p>以飞思卡尔nxp官方spi驱动为例，文件位于<code>linux\drivers\spi\spi-imx.c</code></p>
<h4><span id="1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu">1.2.2.1 spi控制器设备树描述</span><a href="#1-2-2-1-spi-kong-zhi-qi-she-bei-shu-miao-shu" class="header-anchor">#</a></h4><p>打开设备树文件<code>imx6ul.dtsi</code>：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ecspi3: spi@<span class="number">2010000</span> &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x02010000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;GIC_SPI <span class="number">33</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">        clocks = &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;,</span><br><span class="line">                 &lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;;</span><br><span class="line">        clock-names = <span class="string">&quot;ipg&quot;</span>, <span class="string">&quot;per&quot;</span>;</span><br><span class="line">        dmas = &lt;&amp;sdma <span class="number">7</span> <span class="number">7</span> <span class="number">1</span>&gt;, &lt;&amp;sdma <span class="number">8</span> <span class="number">7</span> <span class="number">2</span>&gt;;</span><br><span class="line">        dma-names = <span class="string">&quot;rx&quot;</span>, <span class="string">&quot;tx&quot;</span>;</span><br><span class="line">        status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong">1.2.2.2 imx6ul spi控制器驱动</span><a href="#1-2-2-2-imx6ul-spi-kong-zhi-qi-qu-dong" class="header-anchor">#</a></h4><h5><span id="1-2-2-2-1-probe-chu-shi-hua-spi-master">1.2.2.2.1 probe-(初始化spi_master)</span><a href="#1-2-2-2-1-probe-chu-shi-hua-spi-master" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li><p>解析设备树，初始化控制器</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<p>配置master和spi_imx。包括传输函数，片选函数，片选引脚。<code>master</code>作为平台设备的dev的driver_data, <code>spi_imx</code>作为master的dev的driver_data。</p>
<p>获取irq, res等信息，进行ioremap和注册irq。</p>
<p>设置时钟，开启时钟。</p>
<p>初始话dma寄存器。进行控制器初始化和复位。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/9-1.png" alt="image"></p>
</li>
<li><p>申请并初始化 spi_master， 调用 <code>spi_bitbang_start</code> 函数(<code>spi_bitbang_start 会调用 spi_register_master 函数</code>)向 Linux 内核注册 spi_master。</p>
</li>
</ol>
<h5><span id="1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi">1.2.2.2.2 spi_imx_setupxfer-(设置位宽和配置控制器)</span><a href="#1-2-2-2-2-spi-imx-setupxfer-she-zhi-wei-kuan-he-pei-zhi-kong-zhi-qi" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>设置 <code>spi_imx</code> 的 tx 和 rx 传输函数。根据要发送的数据数据位宽的不 同，分别有 8 位、16 位和 32 位的发送函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spi_imx_buf_tx_u8</span><br><span class="line">spi_imx_buf_tx_u16</span><br><span class="line">spi_imx_buf_tx_u32</span><br><span class="line">spi_imx_buf_rx_u8</span><br><span class="line">spi_imx_buf_rx_u16</span><br><span class="line">spi_imx_buf_rx_u32</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_RX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_rx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;	    <span class="comment">//将要接收的数据值读到 ECSPI 的 MXC_CSPIRXDATA 寄存器里面去	\</span></span><br><span class="line">	unsigned <span class="built_in">int</span> val = readl(spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPIRXDATA);	\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;rx_buf) &#123;						\</span><br><span class="line">		*(type *)spi_imx-&gt;rx_buf = val;				\</span><br><span class="line">		spi_imx-&gt;rx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_TX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_tx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	type val = <span class="number">0</span>;							\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;tx_buf) &#123;						\</span><br><span class="line">		val = *(type *)spi_imx-&gt;tx_buf;				\</span><br><span class="line">		spi_imx-&gt;tx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">									\</span><br><span class="line">	spi_imx-&gt;count -= <span class="keyword">sizeof</span>(type);					\</span><br><span class="line"><span class="comment">//将要发送的数据值写入到 ECSPI 的 TXDATA 寄存器里面去		\</span></span><br><span class="line">	writel(val, spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPITXDATA);	\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MXC_SPI_BUF_RX(u8)</span><br><span class="line">MXC_SPI_BUF_TX(u8)</span><br><span class="line">MXC_SPI_BUF_RX(u16)</span><br><span class="line">MXC_SPI_BUF_TX(u16)</span><br><span class="line">MXC_SPI_BUF_RX(u32)</span><br><span class="line">MXC_SPI_BUF_TX(u32)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p>调用关系如下：<code>mx51_ecspi_config</code>就是最底层<code>SPI controller</code>的寄存器配置，这里不做分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spi_imx-&gt;bitbang.setup_transfer = spi_imx_setupxfer</span><br><span class="line">	spi_imx-&gt;devtype_data-&gt;config = mx51_ecspi_config</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa">1.2.2.2.3 spi_imx_transfer-(数据收发)</span><a href="#1-2-2-2-3-spi-imx-transfer-shu-ju-shou-fa" class="header-anchor">#</a></h5><p>数据收发函数为<code> spi_imx_transfer</code>:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spi_imx_transfer</span><br><span class="line">    -&gt; spi_imx_pio_transfer</span><br><span class="line">        -&gt; spi_imx_push</span><br><span class="line">        	-&gt; spi_imx-&gt;tx</span><br></pre></td></tr></table></figure>

<p><code>spi_imx</code> 是个 <code>spi_imx_data </code>类型的机构指针变量，其中 tx 和 rx 这两个成员变量分别为 SPI 数据发送和接收函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spi_bitbang_start中</span><br><span class="line">    -&gt;master-&gt;transfer_one = spi_bitbang_transfer_one;</span><br><span class="line">当spi_bitbang_transfer_on时</span><br><span class="line">    bitbang-&gt;txrx_bufs(spi,t) = spi_imx_transfer</span><br><span class="line">    也就是spi_imx-&gt;tx就可以spi_imx_buf_tx_u8</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-4-spi-imx-isr">1.2.2.2.4 spi_imx_isr</span><a href="#1-2-2-2-4-spi-imx-isr" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>中断服务程序，只要rx_available,启用spi_imx-&gt;rx。从<code>MXC_CSPIRXDATA</code> 寄存器读出数据。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __<span class="function">maybe_unused <span class="title">mx51_ecspi_rx_available</span>(<span class="params"><span class="keyword">struct</span> spi_imx_data *spi_imx</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> readl(spi_imx-&gt;<span class="keyword">base</span> + MX51_ECSPI_STAT) &amp; MX51_ECSPI_STAT_RR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MXC_SPI_BUF_RX(type)						\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> spi_imx_buf_rx_<span class="meta">##type(struct spi_imx_data *spi_imx)		\</span></span><br><span class="line">&#123;									\</span><br><span class="line">	unsigned <span class="built_in">int</span> val = readl(spi_imx-&gt;<span class="keyword">base</span> + MXC_CSPIRXDATA);	\</span><br><span class="line">									\</span><br><span class="line">	<span class="keyword">if</span> (spi_imx-&gt;rx_buf) &#123;						\</span><br><span class="line">		*(type *)spi_imx-&gt;rx_buf = val;				\</span><br><span class="line">		spi_imx-&gt;rx_buf += <span class="keyword">sizeof</span>(type);			\</span><br><span class="line">	&#125;								\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="1-2-2-2-5-spi-imx-chipselect-pian-xuan">1.2.2.2.5 spi_imx_chipselect-(片选)</span><a href="#1-2-2-2-5-spi-imx-chipselect-pian-xuan" class="header-anchor">#</a></h5><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<p>设置片选gpio电平。</p>
<h2><span id="1-3-spi-cong-she-bei-qu-dong-ceng">1.3 SPI从设备驱动层</span><a href="#1-3-spi-cong-she-bei-qu-dong-ceng" class="header-anchor">#</a></h2><h3><span id="1-3-1-spi-cong-she-bei-api">1.3.1 SPI从设备API</span><a href="#1-3-1-spi-cong-she-bei-api" class="header-anchor">#</a></h3><h4><span id="1-3-1-1-spi-message-init">1.3.1.1 spi_message_init</span><a href="#1-3-1-1-spi-message-init" class="header-anchor">#</a></h4><p><code>void spi_message_init(struct spi_message *m);</code></p>
<p>在使用<code>spi_message</code>之前需要对其进行初始化。</p>
<h4><span id="1-3-1-2-spi-message-add-tail">1.3.1.2 spi_message_add_tail</span><a href="#1-3-1-2-spi-message-add-tail" class="header-anchor">#</a></h4><p><code>void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m);</code></p>
<p><code>spi_message </code>初始化完成以后需要将 <code>spi_transfer</code> 添加到 <code>spi_message</code> 队列中。</p>
<h4><span id="1-3-1-3-spi-async">1.3.1.3 spi_async</span><a href="#1-3-1-3-spi-async" class="header-anchor">#</a></h4><p>参考核心层api有介绍。</p>
<h4><span id="1-3-1-4-spi-sync">1.3.1.4 spi_sync</span><a href="#1-3-1-4-spi-sync" class="header-anchor">#</a></h4><p>参考核心层api有介绍。</p>
<h4><span id="1-3-1-5-spi-register-driver">1.3.1.5 spi_register_driver</span><a href="#1-3-1-5-spi-register-driver" class="header-anchor">#</a></h4><h4><span id="1-3-1-6-spi-unregister-driver">1.3.1.6 spi_unregister_driver</span><a href="#1-3-1-6-spi-unregister-driver" class="header-anchor">#</a></h4><h4><span id="1-3-1-7-spi-read-x2f-spi-write">1.3.1.7 spi_read&#x2F;spi_write</span><a href="#1-3-1-7-spi-read-x2f-spi-write" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">spi_message_init_with_transfers</span><span class="params">(<span class="keyword">struct</span> spi_message *m,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> spi_transfer *xfers, <span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	spi_message_init(m);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_xfers; ++i)</span><br><span class="line">		spi_message_add_tail(&amp;xfers[i], m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_sync_transfer</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="keyword">struct</span> spi_transfer *xfers,</span></span><br><span class="line"><span class="params">             <span class="type">unsigned</span> <span class="type">int</span> num_xfers)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">msg</span>;</span></span><br><span class="line">	spi_message_init_with_transfers(&amp;msg, xfers, num_xfers);</span><br><span class="line">	<span class="keyword">return</span> spi_sync(spi, &amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_read</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.rx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">spi_write</span><span class="params">(<span class="keyword">struct</span> spi_device *spi, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span>	<span class="title">t</span> =</span> &#123;</span><br><span class="line">			.tx_buf		= buf,</span><br><span class="line">			.len		= len,</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> spi_sync_transfer(spi, &amp;t, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>spi_read, spi_write</code>本质还是调用<code>spi_sync</code>传输函数，做了一层封装把<code>spi_transfrer</code>和<code>spi_message</code>包装好了。</p>
<h3><span id="1-3-2-spi-cong-she-bei-shi-li-icm-20608-g">1.3.2 SPI从设备示例-ICM-20608-G</span><a href="#1-3-2-spi-cong-she-bei-shi-li-icm-20608-g" class="header-anchor">#</a></h3><p>该传感器详细介绍：<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">6轴陀螺仪加速度传感器ICM-20608-G</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17780817.html">IMX6ULL SPI应用-6轴陀螺仪加速度传感器ICM-20608-G - fuzidage - 博客园 (cnblogs.com)</a></p>
<h4><span id="1-3-2-1-dts-miao-shu">1.3.2.1 dts描述</span><a href="#1-3-2-1-dts-miao-shu" class="header-anchor">#</a></h4><p>打开自己board对应的dts,我这里是<code>imx6ull-alientek-emmc.dts</code>。我们修改<code>ecspi3 spi控制器</code>。我的spi3接了一个<code>ICM-20608</code>。资源定义如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>根据原理图接线先配置<code>iomux</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_ecspi3: icm20608 &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART2_TX_DATA__GPIO1_IO20 <span class="number">0x10b0</span> <span class="comment">/* CS */</span></span><br><span class="line">		MX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK <span class="number">0x10b1</span> <span class="comment">/* SCLK */</span></span><br><span class="line">		MX6UL_PAD_UART2_RTS_B__ECSPI3_MISO <span class="number">0x10b1</span> <span class="comment">/* MISO */</span></span><br><span class="line">		MX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI <span class="number">0x10b1</span> <span class="comment">/* MOSI */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UART2_TX_DATA </code>这个 IO 是<code> ICM20608</code> 的片选信号，这里我们并没有将其复用为 ECSPI3 的<code>SS0</code>信号，而是将其复用为了普通的 GPIO。因为我们需要自己控制片选信号，所以将其复 用为普通的 GPIO。</p>
<p><code>imx6ull-alientek-emmc.dts</code>重新修改<code>ecspi3</code>节点，追加从设备描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi3 &#123;</span><br><span class="line">	fsl,spi-num-chipselects = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">20</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi3&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	spidev: icm20608@<span class="number">0</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,icm20608&quot;</span>;</span><br><span class="line">		spi-max-frequency = &lt;<span class="number">8000000</span>&gt;;</span><br><span class="line">		reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置当前片选数量为 1，因为就只接了一个<code> ICM20608</code>。</li>
<li>一定要使用 <code>“cs-gpios”</code>属性来描述片选引脚，SPI 主机驱动就会控制片选引脚。 </li>
<li><code>imx6ull.dtsi</code> 文件中默认将 <code>ecspi3</code> 节点状态(status)设置为<code>“disable”</code>，这里我们要将 其改为<code>“okay”</code>。 </li>
<li><code>icm20608</code> 设备子节点，因为 <code>icm20608 </code>连接在<code>ECSPI3</code>的第 0 个通道上，因此 @后面为 0。<ol>
<li>设置节点属性兼容值为<code>“alientek,icm20608”</code>。</li>
<li>设置 SPI 最大时钟频 率为 <code>8MHz</code>，这是 ICM20608 的 SPI 接口所能支持的最大的时钟频率。</li>
<li>icm20608 连接 在<code>通道 0 </code>上，因此 reg 为 0。</li>
</ol>
</li>
</ol>
<h5><span id="1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze">1.3.2.1.1 spi从设备dts描述规则</span><a href="#1-3-2-1-1-spi-cong-she-bei-dts-miao-shu-gui-ze" class="header-anchor">#</a></h5><p>打开<code>linux\Documentation\devicetree\bindings\spi\spi-bus.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SPI slave nodes must be children of the SPI master node and can</span><br><span class="line">contain the following properties.</span><br><span class="line">- reg             - (required) chip select address of device.</span><br><span class="line">- compatible      - (required) name of SPI device following generic names</span><br><span class="line">    		recommended practice</span><br><span class="line">- spi-max-frequency - (required) Maximum SPI clocking speed of device in Hz</span><br><span class="line">- spi-cpol        - (optional) Empty property indicating device requires</span><br><span class="line">    		inverse clock <span class="title function_">polarity</span> <span class="params">(CPOL)</span> mode</span><br><span class="line">- spi-cpha        - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		shifted clock <span class="title function_">phase</span> <span class="params">(CPHA)</span> mode</span><br><span class="line">- spi-cs-high     - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		chip select active high</span><br><span class="line">- spi-3wire       - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">    		    3-wire mode.</span><br><span class="line">- spi-lsb-first   - <span class="params">(optional)</span> Empty property indicating device requires</span><br><span class="line">		LSB first mode.</span><br><span class="line">- spi-tx-bus-width - <span class="params">(optional)</span> The bus <span class="title function_">width</span><span class="params">(number of data wires)</span> that</span><br><span class="line">                      used <span class="keyword">for</span> MOSI. Defaults to 1 <span class="keyword">if</span> not present.</span><br><span class="line">- spi-rx-bus-width - <span class="params">(optional)</span> The bus <span class="title function_">width</span><span class="params">(number of data wires)</span> that</span><br><span class="line">                      used <span class="keyword">for</span> MISO. Defaults to 1 <span class="keyword">if</span> not present.</span><br></pre></td></tr></table></figure>

<h4><span id="1-3-2-2-icm20608-qu-dong">1.3.2.2 ICM20608驱动</span><a href="#1-3-2-2-icm20608-qu-dong" class="header-anchor">#</a></h4><h5><span id="1-3-2-2-1-icm20608reg-h">1.3.2.2.1 icm20608reg.h</span><a href="#1-3-2-2-1-icm20608reg-h" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ICM20608_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_H</span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">文件名		: icm20608reg.h</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608G_ID			0XAF	<span class="comment">/* ID值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608D_ID			0XAE	<span class="comment">/* ID值 */</span></span></span><br><span class="line"><span class="comment">/* ICM20608寄存器 </span></span><br><span class="line"><span class="comment"> *复位后所有寄存器地址都为0，除了</span></span><br><span class="line"><span class="comment"> *Register 107(0X6B) Power Management 1 	= 0x40</span></span><br><span class="line"><span class="comment"> *Register 117(0X75) WHO_AM_I 				= 0xAF或0xAE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FSYNC_INT				0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_ENABLE			0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_STATUS			0x3A</span></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_USER_CTRL				0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_R_W				0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5><span id="1-3-2-2-2-icm20608-c">1.3.2.2.2 icm20608.c</span><a href="#1-3-2-2-2-icm20608-c" class="header-anchor">#</a></h5><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;icm20608reg.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_NAME	<span class="string">&quot;icm20608&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;				<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>			<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>		<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 	<span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;					<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;			<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc;		<span class="comment">/* 陀螺仪X轴原始值 	 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_adc;		<span class="comment">/* 陀螺仪Y轴原始值		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_adc;		<span class="comment">/* 陀螺仪Z轴原始值 		*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc;		<span class="comment">/* 加速度计X轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_adc;		<span class="comment">/* 加速度计Y轴原始值	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_adc;		<span class="comment">/* 加速度计Z轴原始值 	*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;		<span class="comment">/* 温度原始值 			*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> <span class="title">icm20608dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 从icm20608读取多个寄存器数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  读取到的数据</span></span><br><span class="line"><span class="comment"> * @param - len:  要读取的数据长度</span></span><br><span class="line"><span class="comment"> * @return 		: 操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_read_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, <span class="type">void</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> txdata[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> * rxdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">    </span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rxdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>) * len, GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!rxdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，一共要读取len个字节长度的数据，*/</span></span><br><span class="line">	txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;		<span class="comment">/* 写数据的时候首寄存器地址bit8要置1 */</span>			</span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">    t-&gt;rx_buf = rxdata;			<span class="comment">/* 要读取的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//第一步，发送寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg | <span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步，读取数据</span></span><br><span class="line">    txdata[<span class="number">0</span>] = <span class="number">0xff</span>;</span><br><span class="line">    t-&gt;rx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out2;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf , rxdata+<span class="number">1</span>, len);  <span class="comment">/* 只需要读取的数据 */</span></span><br><span class="line">out2:</span><br><span class="line">	kfree(rxdata);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:	</span><br><span class="line">	kfree(t);						<span class="comment">/* 释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608多个寄存器写入数据</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写入的寄存器首地址</span></span><br><span class="line"><span class="comment"> * @param - val:  要写入的数据缓冲区</span></span><br><span class="line"><span class="comment"> * @param - len:  要写入的数据长度</span></span><br><span class="line"><span class="comment"> * @return 	  :   操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">icm20608_write_regs</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 *buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *txdata;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> *<span class="title">t</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">spi</span> =</span> (<span class="keyword">struct</span> spi_device *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> spi_transfer), GFP_KERNEL);	<span class="comment">/* 申请内存 */</span></span><br><span class="line">	<span class="keyword">if</span>(!t) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	txdata = kzalloc(<span class="keyword">sizeof</span>(<span class="type">char</span>)+len, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span>(!txdata) &#123;</span><br><span class="line">		<span class="keyword">goto</span> out1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 一共发送len+1个字节的数据，第一个字节为</span></span><br><span class="line"><span class="comment">	寄存器首地址，len为要写入的寄存器的集合，*/</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">	*txdata = reg &amp; ~<span class="number">0x80</span>;	<span class="comment">/* 写数据的时候首寄存器地址bit8要清零 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(txdata+<span class="number">1</span>, buf, len);	<span class="comment">/* 把len个寄存器拷贝到txdata里，等待发送 */</span></span><br><span class="line">	t-&gt;tx_buf = txdata;			<span class="comment">/* 要发送的数据 */</span></span><br><span class="line">	t-&gt;len = len+<span class="number">1</span>;				<span class="comment">/* t-&gt;len=发送的长度+读取的长度 */</span></span><br><span class="line">	spi_message_init(&amp;m);		<span class="comment">/* 初始化spi_message */</span></span><br><span class="line">	spi_message_add_tail(t, &amp;m);<span class="comment">/* 将spi_transfer添加到spi_message队列 */</span></span><br><span class="line">	ret = spi_sync(spi, &amp;m);	<span class="comment">/* 同步发送 */</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">//第一步，发送寄存器地址</span></span><br><span class="line">    txdata[<span class="number">0</span>] = reg &amp; ~<span class="number">0x80</span>;</span><br><span class="line">    t-&gt;tx_buf = txdata;</span><br><span class="line">    t-&gt;len = <span class="number">1</span>;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二步，写入数据</span></span><br><span class="line">    t-&gt;tx_buf = buf;</span><br><span class="line">    t-&gt;len = len;</span><br><span class="line">    spi_message_init(&amp;m);</span><br><span class="line">	spi_message_add_tail(t, &amp;m);</span><br><span class="line">	ret = spi_sync(spi, &amp;m);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span>(ret) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    &#125;</span><br><span class="line">out2:</span><br><span class="line">	kfree(txdata);				<span class="comment">/* 释放内存 */</span></span><br><span class="line">out1:</span><br><span class="line">	kfree(t);					<span class="comment">/* 释放内存 */</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取icm20608指定寄存器值，读取一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要读取的寄存器</span></span><br><span class="line"><span class="comment"> * @return 	  :   读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line">	icm20608_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 向icm20608指定寄存器写入指定的值，写一个寄存器</span></span><br><span class="line"><span class="comment"> * @param - dev:  icm20608设备</span></span><br><span class="line"><span class="comment"> * @param - reg:  要写的寄存器</span></span><br><span class="line"><span class="comment"> * @param - data: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return   :    无</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">icm20608_write_onereg</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev, u8 reg, u8 value)</span> &#123;</span><br><span class="line">	u8 buf = value;</span><br><span class="line">	icm20608_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_readdata</span><span class="params">(<span class="keyword">struct</span> icm20608_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	icm20608_read_regs(dev, ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	dev-&gt;accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]); </span><br><span class="line">	dev-&gt;accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]); </span><br><span class="line">	dev-&gt;accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]); </span><br><span class="line">	dev-&gt;temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]); </span><br><span class="line">	dev-&gt;gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]); </span><br><span class="line">	dev-&gt;gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">	dev-&gt;gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;icm20608dev; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">icm20608_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span>&#123;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> data[<span class="number">7</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> icm20608_dev *)filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	icm20608_readdata(dev);</span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;gyro_x_adc;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;gyro_y_adc;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;gyro_z_adc;</span><br><span class="line">	data[<span class="number">3</span>] = dev-&gt;accel_x_adc;</span><br><span class="line">	data[<span class="number">4</span>] = dev-&gt;accel_y_adc;</span><br><span class="line">	data[<span class="number">5</span>] = dev-&gt;accel_z_adc;</span><br><span class="line">	data[<span class="number">6</span>] = dev-&gt;temp_adc;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">icm20608_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = icm20608_open,</span><br><span class="line">	.read = icm20608_read,</span><br><span class="line">	.release = icm20608_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_reginit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	u8 value = <span class="number">0</span>;</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x80</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_1, <span class="number">0x01</span>);</span><br><span class="line">	mdelay(<span class="number">50</span>);</span><br><span class="line">	value = icm20608_read_onereg(&amp;icm20608dev, ICM20_WHO_AM_I);</span><br><span class="line">	printk(<span class="string">&quot;ICM20608 ID = %#X\r\n&quot;</span>, value);	</span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_SMPLRT_DIV, <span class="number">0x00</span>); 	<span class="comment">/* 输出速率是内部采样率					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_GYRO_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 陀螺仪±2000dps量程 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 加速度计±16G量程 					*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_CONFIG, <span class="number">0x04</span>); 		<span class="comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); <span class="comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_PWR_MGMT_2, <span class="number">0x00</span>); 	<span class="comment">/* 打开加速度计和陀螺仪所有轴 				*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_LP_MODE_CFG, <span class="number">0x00</span>); 	<span class="comment">/* 关闭低功耗 						*/</span></span><br><span class="line">	icm20608_write_onereg(&amp;icm20608dev, ICM20_FIFO_EN, <span class="number">0x00</span>);		<span class="comment">/* 关闭FIFO						*/</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (icm20608dev.major) &#123;</span><br><span class="line">		icm20608dev.devid = MKDEV(icm20608dev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(icm20608dev.devid, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;icm20608dev.devid, <span class="number">0</span>, ICM20608_CNT, ICM20608_NAME);</span><br><span class="line">		icm20608dev.major = MAJOR(icm20608dev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;icm20608dev.cdev, &amp;icm20608_ops);</span><br><span class="line">	cdev_add(&amp;icm20608dev.cdev, icm20608dev.devid, ICM20608_CNT);</span><br><span class="line"></span><br><span class="line">	icm20608dev.class = class_create(THIS_MODULE, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.class);</span><br><span class="line">	&#125;</span><br><span class="line">	icm20608dev.device = device_create(icm20608dev.class, <span class="literal">NULL</span>, icm20608dev.devid, <span class="literal">NULL</span>, ICM20608_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(icm20608dev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(icm20608dev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化spi_device */</span></span><br><span class="line">	spi-&gt;mode = SPI_MODE_0;	<span class="comment">/*MODE0，CPOL=0，CPHA=0*/</span></span><br><span class="line">	spi_setup(spi);</span><br><span class="line">	icm20608dev.private_data = spi; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="comment">/* 初始化ICM20608内部寄存器 */</span></span><br><span class="line">	icm20608_reginit();		</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">icm20608_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">	cdev_del(&amp;icm20608dev.cdev);</span><br><span class="line">	unregister_chrdev_region(icm20608dev.devid, ICM20608_CNT);</span><br><span class="line">	device_destroy(icm20608dev.class, icm20608dev.devid);</span><br><span class="line">	class_destroy(icm20608dev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 传统匹配方式ID列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> <span class="title">icm20608_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,icm20608&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备树匹配列表 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">icm20608_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,icm20608&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SPI驱动结构体 */</span>	</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">icm20608_driver</span> =</span> &#123;</span><br><span class="line">	.probe = icm20608_probe,</span><br><span class="line">	.remove = icm20608_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;icm20608&quot;</span>,</span><br><span class="line">		   	.of_match_table = icm20608_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = icm20608_id,</span><br><span class="line">&#125;;</span><br><span class="line">		   </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">icm20608_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> spi_register_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">icm20608_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	spi_unregister_driver(&amp;icm20608_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(icm20608_init);</span><br><span class="line">module_exit(icm20608_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

</details>

<h6><span id="1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi">1.3.2.2.2.1 驱动过程分析</span><a href="#1-3-2-2-2-1-qu-dong-guo-cheng-fen-xi" class="header-anchor">#</a></h6><ol>
<li><p>作为一个spi从设备驱动，需要定义一个<code>spi_driver</code> <code>icm20608_driver</code>。通过<code>spi_register_driver</code>、<code>spi_unregister_driver</code>注册卸载。</p>
</li>
<li><p><code>compatible</code>匹配执行probe。</p>
<ol>
<li>定一个<code>icm20608_dev</code>，按照字符设备框架，注册字符设备。</li>
<li><code>spi_setup</code>设置<code>spi_device</code>从设备, 设置spi设备的模式和速率。<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image-20240831182608432"></li>
<li>初始化<code>ICM20608</code>内部寄存器（发起spi传输）。<ol>
<li>设置启动时序，使能读写。</li>
<li>读id。</li>
<li>设置量程，速率。</li>
</ol>
</li>
</ol>
</li>
<li><p><code>ICM20608</code>的读写</p>
</li>
<li><p><code>icm20608_read</code>调用<code>icm20608_readdata</code>，调用<code>icm20608_read_regs</code></p>
</li>
<li><p><code>icm20608_write_regs</code>， <code>icm20608_read_regs</code>用来spi协议让主控去读写spi从设备，都是通过<code>spi_sync</code>进行数据传输。</p>
</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<pre><code>  将函数精简话一下：
</code></pre>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"></p>
<p>注意精简后有个bug, 就是调用spi_write后，又继续调用spi_read。这时imx6ul spi控制器驱动内部会帮忙控制cs片选信号。又会重新拉高，再拉低cs片选。因此导致数据传输异常。nxp官方也是用的gpio作为cs片选，软件手动去控制的。因此优化如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p>probe读出icm20608 <code>id</code>为：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<h5><span id="1-3-2-2-3-icm20608app-c">1.3.2.2.3 icm20608App.c</span><a href="#1-3-2-2-3-icm20608app-c" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> databuf[<span class="number">7</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc, gyro_y_adc, gyro_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc, accel_y_adc, accel_z_adc;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;</span><br><span class="line"></span><br><span class="line">	<span class="type">float</span> gyro_x_act, gyro_y_act, gyro_z_act;</span><br><span class="line">	<span class="type">float</span> accel_x_act, accel_y_act, accel_z_act;</span><br><span class="line">	<span class="type">float</span> temp_act;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			gyro_x_adc = databuf[<span class="number">0</span>];</span><br><span class="line">			gyro_y_adc = databuf[<span class="number">1</span>];</span><br><span class="line">			gyro_z_adc = databuf[<span class="number">2</span>];</span><br><span class="line">			accel_x_adc = databuf[<span class="number">3</span>];</span><br><span class="line">			accel_y_adc = databuf[<span class="number">4</span>];</span><br><span class="line">			accel_z_adc = databuf[<span class="number">5</span>];</span><br><span class="line">			temp_adc = databuf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 计算实际值 */</span></span><br><span class="line">			gyro_x_act = (<span class="type">float</span>)(gyro_x_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_y_act = (<span class="type">float</span>)(gyro_y_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			gyro_z_act = (<span class="type">float</span>)(gyro_z_adc)  / <span class="number">16.4</span>;</span><br><span class="line">			accel_x_act = (<span class="type">float</span>)(accel_x_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_y_act = (<span class="type">float</span>)(accel_y_adc) / <span class="number">2048</span>;</span><br><span class="line">			accel_z_act = (<span class="type">float</span>)(accel_z_adc) / <span class="number">2048</span>;</span><br><span class="line">			temp_act = ((<span class="type">float</span>)(temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\r\n原始值:\r\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;gx = %d, gy = %d, gz = %d\r\n&quot;</span>, gyro_x_adc, gyro_y_adc, gyro_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ax = %d, ay = %d, az = %d\r\n&quot;</span>, accel_x_adc, accel_y_adc, accel_z_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;temp = %d\r\n&quot;</span>, temp_adc);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;实际值:&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act gx = %.2f°/S, act gy = %.2f°/S, act gz = %.2f°/S\r\n&quot;</span>, gyro_x_act, gyro_y_act, gyro_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act ax = %.2fg, act ay = %.2fg, act az = %.2fg\r\n&quot;</span>, accel_x_act, accel_y_act, accel_z_act);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;act temp = %.2f°C\r\n&quot;</span>, temp_act);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">100000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<h3><span id="1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c">1.3.3 SPI万能从设备驱动-spidev.c</span><a href="#1-3-3-spi-wan-neng-cong-she-bei-qu-dong-spidev-c" class="header-anchor">#</a></h3><p>万能SPI从设备驱动对应spidev， 驱动代码位于<code>/drivers/spi/spidev.c</code>。不用为每个spi从设备去写一个驱动，linux内核有一个万能通用的从设备驱动。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<p>为什么说<code>spidev.c</code>是一个通用的从设备驱动。</p>
<p>spidev不是专门针对某一SPI硬件设备做的驱动，只是简单的注册字符设备，用户空间通过<code>read、write、ioctl</code>，直接对spi进行操作，相当于是用户空间和spi设备的桥梁。用户空间操作时，打开设备节点，然后通过IOCTL设置模式、速度等参数，然后就可以调用<code>read write</code>进行操作了。</p>
<h4><span id="1-3-3-1-spidev-init">1.3.3.1 spidev_init</span><a href="#1-3-3-1-spidev-init" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p>注册了字符设备，主设备号<code>SPIDEV_MAJOR= 153</code>，绑定<code>spidev_fops</code>。</p>
<p>创建了spidev的class，创建完成后在用户空间<code>/sys/class/</code>下可以看到spidev目录结构。</p>
<p><code>spi_register_driver</code>按照标准流程注册spidev从设备驱动。</p>
<h4><span id="1-3-3-2-spidev-de-probe">1.3.3.2 spidev的probe</span><a href="#1-3-3-2-spidev-de-probe" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">spidev_dt_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;rohm,dh2228fv&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;lineartechnology,ltc2488&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;ge,achc&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;nanopi,spidev&quot;</span> &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;semtech,sx1301&quot;</span> &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spidev_spi_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name =		<span class="string">&quot;spidev&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(spidev_dt_ids),</span><br><span class="line">		.acpi_match_table = ACPI_PTR(spidev_acpi_ids),</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe =	spidev_probe,</span><br><span class="line">	.remove =	spidev_remove,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="type">int</span>			status;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		minor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (spi-&gt;dev.of_node &amp;&amp; !of_match_device(spidev_dt_ids, &amp;spi-&gt;dev)) &#123;</span><br><span class="line">		dev_err(&amp;spi-&gt;dev, <span class="string">&quot;buggy DT: spidev listed directly in DT\n&quot;</span>);</span><br><span class="line">		WARN_ON(spi-&gt;dev.of_node &amp;&amp;</span><br><span class="line">			!of_match_device(spidev_dt_ids, &amp;spi-&gt;dev));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spidev_probe_acpi(spi);</span><br><span class="line">	<span class="comment">/* Allocate driver data */</span></span><br><span class="line">	spidev = kzalloc(<span class="keyword">sizeof</span>(*spidev), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!spidev)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	<span class="comment">/* Initialize the driver data */</span></span><br><span class="line">	spidev-&gt;spi = spi;</span><br><span class="line">	spin_lock_init(&amp;spidev-&gt;spi_lock);</span><br><span class="line">	mutex_init(&amp;spidev-&gt;buf_lock);</span><br><span class="line">	INIT_LIST_HEAD(&amp;spidev-&gt;device_entry);</span><br><span class="line">	<span class="comment">/* If we can allocate a minor number, hook up this device.</span></span><br><span class="line"><span class="comment">	 * Reusing minors is fine so long as udev or mdev is working.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;device_list_lock);</span><br><span class="line">	minor = find_first_zero_bit(minors, N_SPI_MINORS);</span><br><span class="line">	<span class="keyword">if</span> (minor &lt; N_SPI_MINORS) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">		spidev-&gt;devt = MKDEV(SPIDEV_MAJOR, minor);</span><br><span class="line">		dev = device_create(spidev_class, &amp;spi-&gt;dev, spidev-&gt;devt,</span><br><span class="line">				    spidev, <span class="string">&quot;spidev%d.%d&quot;</span>,</span><br><span class="line">				    spi-&gt;master-&gt;bus_num, spi-&gt;chip_select);</span><br><span class="line">		status = PTR_ERR_OR_ZERO(dev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;no minor number available!\n&quot;</span>);</span><br><span class="line">		status = -ENODEV;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">		set_bit(minor, minors);</span><br><span class="line">		list_add(&amp;spidev-&gt;device_entry, &amp;device_list);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;device_list_lock);</span><br><span class="line">	spidev-&gt;speed_hz = spi-&gt;max_speed_hz;</span><br><span class="line">	<span class="keyword">if</span> (status == <span class="number">0</span>)</span><br><span class="line">		spi_set_drvdata(spi, spidev);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		kfree(spidev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>device_create</code>创建了<code>/dev/</code>下的<code>spidev</code>节点,主设备号<code>SPIDEV_MAJOR= 153</code>，如<code>spi总线0</code>上<code>cs1</code>设备，则设备名为<code>/dev/spidev0.1</code>，其他以此类推。</p>
<h4><span id="1-3-3-3-spidev-fops">1.3.3.3 spidev_fops</span><a href="#1-3-3-3-spidev-fops" class="header-anchor">#</a></h4><h5><span id="1-3-3-3-1-spidev-read">1.3.3.3.1 spidev_read</span><a href="#1-3-3-3-1-spidev-read" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spidev_read</span><br><span class="line">	-&gt;spidev_sync_read</span><br><span class="line">		-&gt;spidev_sync</span><br><span class="line">			-&gt;spi_sync</span><br></pre></td></tr></table></figure>

<h5><span id="1-3-3-3-2-spidev-write">1.3.3.3.2 spidev_write</span><a href="#1-3-3-3-2-spidev-write" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spidev_write</span><br><span class="line">	-&gt;spidev_sync_write</span><br><span class="line">		-&gt;spidev_sync</span><br><span class="line">			-&gt;spi_sync</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<p>构造<code>spi_message</code>,<code>spi_transfer</code>调用<code>spi_sync</code>进行数据传输。</p>
<h5><span id="1-3-3-3-3-spidev-ioctl">1.3.3.3.3 spidev_ioctl</span><a href="#1-3-3-3-3-spidev-ioctl" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">spidev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span>			retval = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spidev_data</span>	*<span class="title">spidev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line">	u32			tmp;</span><br><span class="line">	<span class="type">unsigned</span>		n_ioc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_ioc_transfer</span>	*<span class="title">ioc</span>;</span></span><br><span class="line">    <span class="comment">/* Check type and command number */</span></span><br><span class="line">    <span class="keyword">if</span> (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)</span><br><span class="line">        <span class="keyword">return</span> -ENOTTY;</span><br><span class="line">    <span class="comment">/* guard against device removal before, or while,</span></span><br><span class="line"><span class="comment">     * we issue this ioctl.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    spidev = filp-&gt;private_data;</span><br><span class="line">    spin_lock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line">    spi = spi_dev_get(spidev-&gt;spi);</span><br><span class="line">    spin_unlock_irq(&amp;spidev-&gt;spi_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (spi == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ESHUTDOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use the buffer lock here for triple duty:</span></span><br><span class="line"><span class="comment">     *  - prevent I/O (from us) so calling spi_setup() is safe;</span></span><br><span class="line"><span class="comment">     *  - prevent concurrent SPI_IOC_WR_* from morphing</span></span><br><span class="line"><span class="comment">     *    data fields while SPI_IOC_RD_* reads them;</span></span><br><span class="line"><span class="comment">     *  - SPI_IOC_MESSAGE needs the buffer locked &quot;normally&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex_lock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="comment">/* read requests */</span></span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MODE:</span><br><span class="line">        retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">                    (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MODE32:</span><br><span class="line">        retval = put_user(spi-&gt;mode &amp; SPI_MODE_MASK,</span><br><span class="line">                    (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_LSB_FIRST:</span><br><span class="line">        retval = put_user((spi-&gt;mode &amp; SPI_LSB_FIRST) ?  <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_BITS_PER_WORD:</span><br><span class="line">        retval = put_user(spi-&gt;bits_per_word, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_RD_MAX_SPEED_HZ:</span><br><span class="line">        retval = put_user(spidev-&gt;speed_hz, (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write requests */</span></span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MODE:</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MODE32:</span><br><span class="line">        <span class="keyword">if</span> (cmd == SPI_IOC_WR_MODE)</span><br><span class="line">            retval = get_user(tmp, (u8 __user *)arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            retval = get_user(tmp, (u32 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span> *<span class="title">ctlr</span> =</span> spi-&gt;controller;</span><br><span class="line">            u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; ~SPI_MODE_MASK) &#123;</span><br><span class="line">                retval = -EINVAL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ctlr-&gt;use_gpio_descriptors &amp;&amp; ctlr-&gt;cs_gpiods &amp;&amp;</span><br><span class="line">                ctlr-&gt;cs_gpiods[spi-&gt;chip_select])</span><br><span class="line">                tmp |= SPI_CS_HIGH;</span><br><span class="line"></span><br><span class="line">            tmp |= spi-&gt;mode &amp; ~SPI_MODE_MASK;</span><br><span class="line">            spi-&gt;mode = (u16)tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;mode = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;spi mode %x\n&quot;</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_LSB_FIRST:</span><br><span class="line">        retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u32	save = spi-&gt;mode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp)</span><br><span class="line">                spi-&gt;mode |= SPI_LSB_FIRST;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                spi-&gt;mode &amp;= ~SPI_LSB_FIRST;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;mode = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%csb first\n&quot;</span>,</span><br><span class="line">                        tmp ? <span class="string">&#x27;l&#x27;</span> : <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_BITS_PER_WORD:</span><br><span class="line">        retval = get_user(tmp, (__u8 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u8	save = spi-&gt;bits_per_word;</span><br><span class="line"></span><br><span class="line">            spi-&gt;bits_per_word = tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">                spi-&gt;bits_per_word = save;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d bits per word\n&quot;</span>, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPI_IOC_WR_MAX_SPEED_HZ:</span><br><span class="line">        retval = get_user(tmp, (__u32 __user *)arg);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            u32	save = spi-&gt;max_speed_hz;</span><br><span class="line"></span><br><span class="line">            spi-&gt;max_speed_hz = tmp;</span><br><span class="line">            retval = spi_setup(spi);</span><br><span class="line">            <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">                spidev-&gt;speed_hz = tmp;</span><br><span class="line">                dev_dbg(&amp;spi-&gt;dev, <span class="string">&quot;%d Hz (max)\n&quot;</span>,</span><br><span class="line">                    spidev-&gt;speed_hz);</span><br><span class="line">            &#125;</span><br><span class="line">            spi-&gt;max_speed_hz = save;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">/* segmented and/or full-duplex I/O request */</span></span><br><span class="line">        <span class="comment">/* Check message and copy into scratch area */</span></span><br><span class="line">        ioc = spidev_get_ioc_message(cmd,</span><br><span class="line">                (<span class="keyword">struct</span> spi_ioc_transfer __user *)arg, &amp;n_ioc);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(ioc)) &#123;</span><br><span class="line">            retval = PTR_ERR(ioc);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ioc)</span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">/* n_ioc is also 0 */</span></span><br><span class="line">        <span class="comment">/* translate to spi_message, execute */</span></span><br><span class="line">        retval = spidev_message(spidev, ioc, n_ioc);</span><br><span class="line">        kfree(ioc);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;spidev-&gt;buf_lock);</span><br><span class="line">    spi_dev_put(spi);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<p>这些SPI_IOC命令就是一些设置速率参数，spi模式啊，然后就可以通过read,write操作<code>/dev/spidev%d.%d</code>设备了。</p>
<h3><span id="1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.4 使用SPI万能驱动oled举例</span><a href="#1-3-4-shi-yong-spi-wan-neng-qu-dong-oled-ju-li" class="header-anchor">#</a></h3><h4><span id="1-3-4-1-spi-oled-yuan-li">1.3.4.1 spi oled原理</span><a href="#1-3-4-1-spi-oled-yuan-li" class="header-anchor">#</a></h4><p>见<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/#3-spi-luo-ji-shi-li">SPI-OLED显示面板介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15668520.html">S3c2440裸机-spi编程-2.OLED显示面板 - fuzidage - 博客园 (cnblogs.com)</a> </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15697593.html">S3c2440裸机-spi编程-3.gpio模拟spi驱动OLED - fuzidage - 博客园 (cnblogs.com)</a>。</p>
<h4><span id="1-3-4-2-spi-oled-c">1.3.4.2 spi_oled.c</span><a href="#1-3-4-2-spi-oled-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_spidev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dc_pin_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dc_pin_init</span><span class="params">(<span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// echo 509 &gt; /sys/class/gpio/export</span></span><br><span class="line">	<span class="comment">// echo out &gt; /sys/class/gpio/gpio509/direction	</span></span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">100</span>];</span><br><span class="line">	dc_pin_num = number;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %d &gt; /sys/class/gpio/export&quot;</span>, number);</span><br><span class="line">	system(cmd);</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo out &gt; /sys/class/gpio/gpio%d/direction&quot;</span>, number);</span><br><span class="line">	system(cmd);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_set_dc_pin</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* echo 1 &gt; /sys/class/gpio/gpio509/value</span></span><br><span class="line"><span class="comment">	 * echo 0 &gt; /sys/class/gpio/gpio509/value</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">100</span>];</span><br><span class="line">	<span class="built_in">sprintf</span>(cmd, <span class="string">&quot;echo %d &gt; /sys/class/gpio/gpio%d/value&quot;</span>, val, dc_pin_num);</span><br><span class="line">	system(cmd);	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">spi_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd_spidev, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line">	spi_write_datas(buf, len);</span><br><span class="line">&#125;</span><br><span class="line">  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： oled_write_cmd</span></span><br><span class="line"><span class="comment">	 * 功能描述： oled向特定地址写入数据或者命令</span></span><br><span class="line"><span class="comment">	 * 输入参数：@uc_data :要写入的数据</span></span><br><span class="line"><span class="comment">	 			@uc_cmd:为1则表示写入数据，为0表示写入命令</span></span><br><span class="line"><span class="comment">	 * 输出参数：无</span></span><br><span class="line"><span class="comment">	 * 返 回 值： 无</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_cmd_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> uc_data,<span class="type">unsigned</span> <span class="type">char</span> uc_cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> uc_read=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(uc_cmd==<span class="number">0</span>)</span><br><span class="line">		oled_set_dc_pin(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line"></span><br><span class="line">	spi_write_datas(&amp;uc_data, <span class="number">1</span>);<span class="comment">//写入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">oled_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> uc_dev_id = <span class="number">0</span>;</span><br><span class="line">		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line">	oled_write_cmd_data(<span class="number">0xae</span>,OLED_CMD);<span class="comment">//关闭显示</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//设置 lower column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//设置 higher column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//设置 display start line</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//设置page address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x81</span>,OLED_CMD);<span class="comment">// contract control</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x66</span>,OLED_CMD);<span class="comment">//128</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa1</span>,OLED_CMD);<span class="comment">//设置 segment remap</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa6</span>,OLED_CMD);<span class="comment">//normal /reverse</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa8</span>,OLED_CMD);<span class="comment">//multiple ratio</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//duty = 1/64</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xc8</span>,OLED_CMD);<span class="comment">//com scan direction</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd3</span>,OLED_CMD);<span class="comment">//set displat offset</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd9</span>,OLED_CMD);<span class="comment">//ser pre-charge period</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x1f</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xda</span>,OLED_CMD);<span class="comment">//set com pins</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xdb</span>,OLED_CMD);<span class="comment">//set vcomh</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x8d</span>,OLED_CMD);<span class="comment">//set charge pump disable </span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xaf</span>,OLED_CMD);<span class="comment">//set dispkay on</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： oled_fill_data</span></span><br><span class="line"><span class="comment">	 * 功能描述： 整个屏幕显示填充某个固定数据</span></span><br><span class="line"><span class="comment">	 * 输入参数：@fill_Data：要填充的数据</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">oled_fill_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line">	<span class="keyword">for</span>(x=<span class="number">0</span>;x&lt;<span class="number">8</span>;x++) &#123;</span><br><span class="line">		oled_write_cmd_data(<span class="number">0xb0</span>+x,OLED_CMD);		<span class="comment">//page0-page1</span></span><br><span class="line">		oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);		<span class="comment">//low column start address</span></span><br><span class="line">		oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);		<span class="comment">//high column start address	</span></span><br><span class="line">		<span class="keyword">for</span>(y=<span class="number">0</span>;y&lt;<span class="number">128</span>;y++)</span><br><span class="line">			oled_write_cmd_data(fill_Data,OLED_DATA);<span class="comment">//填充数据				</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Clear</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        <span class="comment">//for (x = 0; x &lt; 128; x++)</span></span><br><span class="line">        <span class="comment">//    oled_write_cmd_data(0, OLED_DATA); /* 清零 */</span></span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： OLED_DIsp_All</span></span><br><span class="line"><span class="comment">	 * 功能描述： 整个屏幕显示全部点亮，可以用于检查坏点</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_All</span><span class="params">(<span class="type">void</span>)</span>  </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++)</span><br><span class="line">	&#123;</span><br><span class="line">		OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">		<span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">128</span>; x++)</span><br><span class="line">			oled_write_cmd_data(<span class="number">0xff</span>, OLED_DATA); <span class="comment">/* 全点亮 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//坐标设置</span></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment">	 * 函数名称： OLED_DIsp_Set_Pos</span></span><br><span class="line"><span class="comment">	 * 功能描述：设置要显示的位置</span></span><br><span class="line"><span class="comment">	 * 输入参数：@ x ：要显示的column address</span></span><br><span class="line"><span class="comment">	 			@y :要显示的page address</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	oled_write_cmd_data(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	oled_write_cmd_data((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">	oled_write_cmd_data(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 得到字模 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 发给OLED */</span></span><br><span class="line">	OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">	<span class="comment">//	oled_write_cmd_data(dots[i], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">	OLED_DIsp_Set_Pos(x, y+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">		<span class="comment">//oled_write_cmd_data(dots[i+8], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">8</span>], <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_String</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[j])&#123;		</span><br><span class="line">		OLED_DIsp_Char(x, y, str[j]);<span class="comment">//显示单个字符</span></span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">127</span>)&#123;</span><br><span class="line">			x = <span class="number">0</span>;</span><br><span class="line">			y += <span class="number">2</span>;</span><br><span class="line">		&#125;<span class="comment">//移动显示位置</span></span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;wiki.100ask.net&quot;</span>);</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&quot;book.100ask.net&quot;</span>);</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">4</span>, <span class="string">&quot;bbs.100ask.net&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* spi_oled /dev/spidevB.D &lt;DC_pin_number&gt; */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> dc_pin;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev/spidevB.D&gt; &lt;DC_pin_number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);<span class="comment">//B表示spi bus, D表示cs片选</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	fd_spidev = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_spidev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open %s err\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	dc_pin = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	dc_pin_init(dc_pin);</span><br><span class="line"> </span><br><span class="line">	oled_init();</span><br><span class="line">	OLED_DIsp_Clear();</span><br><span class="line">	OLED_DIsp_Test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi">1.3.4.2.1 用户态驱动分析</span><a href="#1-3-4-2-1-yong-hu-tai-qu-dong-fen-xi" class="header-anchor">#</a></h5><p>有了spidev.c万能SPI从设备驱动，就不需要去写spi从设备驱动了，直接用户态去读写spidev即可。</p>
<ol>
<li><code>open(&quot;/dev/spi%d.%d&quot;, O_RDWR);</code>&#x2F;&#x2F;根据自己外设使用的spi bus和cs片选去设置</li>
<li>对外设oled进行初始化<code>D/C（data or cmd ）引脚</code>, 利用gpio子系统的命令去设置gpio模式为输出。</li>
<li>利用spi协议发送初始化序列：<ol>
<li><code>spi_write_datas</code>就是操作<code>spidev</code>，write数据到底层<code>spidev</code>，再调用对应的fops中的<code>spidev_write</code>，最终调用<code>spi_sync</code>传输数据。这里是每次传输1byte，把初始化序列利用spi协议写完。</li>
</ol>
</li>
<li>清屏并且测试<code>oled</code>显示字符。</li>
</ol>
<h3><span id="1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li">1.3.5 不使用SPI万能驱动oled举例</span><a href="#1-3-5-bu-shi-yong-spi-wan-neng-qu-dong-oled-ju-li" class="header-anchor">#</a></h3><h4><span id="1-3-5-1-dts-miao-shu">1.3.5.1 dts描述</span><a href="#1-3-5-1-dts-miao-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&amp;ecspi1 &#123;</span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_ecspi1&gt;;</span><br><span class="line">    fsl,spi-num-chipselects = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">    cs-gpios = &lt;&amp;gpio4 <span class="number">26</span> GPIO_ACTIVE_LOW&gt;, &lt;&amp;gpio4 <span class="number">24</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    oled: oled &#123;</span><br><span class="line">        compatible = <span class="string">&quot;100ask,oled&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        spi-max-frequency = &lt;<span class="number">10000000</span>&gt;;</span><br><span class="line">        dc-gpios = &lt;&amp;gpio4 <span class="number">20</span> GPIO_ACTIVE_HIGH&gt;; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spi1</code>下接了一个<code>spi oled</code>，修改对应dts文件，修改<code>ecspi1</code>节点，添加oled子节点。oled有一个<code>dc引脚</code>，叫做<code>data/cmd</code>引脚，选择是发送数据还是命令。参考spi oled原理。</p>
<h4><span id="1-3-5-2-oled-drv-c">1.3.5.2 oled_drv.c</span><a href="#1-3-5-2-oled-drv-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/acpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_INIT 			123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_SET_POS 		124</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//为0 表示命令，为1表示数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD 	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 	1</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> *<span class="title">oled</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">dc_gpio</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dc_pin_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	gpiod_direction_output(dc_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_set_dc_pin</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">	gpiod_set_value(dc_gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">spi_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	spi_write(oled, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">oled_write_cmd_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> uc_data,<span class="type">unsigned</span> <span class="type">char</span> uc_cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(uc_cmd==<span class="number">0</span>)</span><br><span class="line">		oled_set_dc_pin(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line"></span><br><span class="line">	spi_write_datas(&amp;uc_data, <span class="number">1</span>);<span class="comment">//写入</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">oled_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	oled_write_cmd_data(<span class="number">0xae</span>,OLED_CMD);<span class="comment">//关闭显示</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//设置 lower column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x10</span>,OLED_CMD);<span class="comment">//设置 higher column address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x40</span>,OLED_CMD);<span class="comment">//设置 display start line</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xB0</span>,OLED_CMD);<span class="comment">//设置page address</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x81</span>,OLED_CMD);<span class="comment">// contract control</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x66</span>,OLED_CMD);<span class="comment">//128</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa1</span>,OLED_CMD);<span class="comment">//设置 segment remap</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa6</span>,OLED_CMD);<span class="comment">//normal /reverse</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xa8</span>,OLED_CMD);<span class="comment">//multiple ratio</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x3f</span>,OLED_CMD);<span class="comment">//duty = 1/64</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xc8</span>,OLED_CMD);<span class="comment">//com scan direction</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd3</span>,OLED_CMD);<span class="comment">//set displat offset</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x00</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd5</span>,OLED_CMD);<span class="comment">//set osc division</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x80</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xd9</span>,OLED_CMD);<span class="comment">//ser pre-charge period</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x1f</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xda</span>,OLED_CMD);<span class="comment">//set com pins</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x12</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xdb</span>,OLED_CMD);<span class="comment">//set vcomh</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x30</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x8d</span>,OLED_CMD);<span class="comment">//set charge pump disable </span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0x14</span>,OLED_CMD);<span class="comment">//</span></span><br><span class="line">	oled_write_cmd_data(<span class="number">0xaf</span>,OLED_CMD);<span class="comment">//set dispkay on</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;		  			 		  						  					  				 	   		  	  	 	  </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	oled_write_cmd_data(<span class="number">0xb0</span>+y,OLED_CMD);</span><br><span class="line">	oled_write_cmd_data((x&amp;<span class="number">0x0f</span>),OLED_CMD); </span><br><span class="line">	oled_write_cmd_data(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>,OLED_CMD);</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">spidev_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="comment">/* 根据cmd操作硬件 */</span></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> OLED_IOC_INIT: <span class="comment">/* init */</span></span><br><span class="line">		&#123;</span><br><span class="line">			dc_pin_init();</span><br><span class="line">			oled_init();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> OLED_IOC_SET_POS: <span class="comment">/* set pos */</span></span><br><span class="line">		&#123;</span><br><span class="line">			x = arg &amp; <span class="number">0xff</span>;</span><br><span class="line">			y = (arg &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">			OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">spidev_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *ker_buf;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	ker_buf = kmalloc(count, GFP_KERNEL);</span><br><span class="line">	err = copy_from_user(ker_buf, buf, count);</span><br><span class="line">	oled_set_dc_pin(<span class="number">1</span>);<span class="comment">//拉高，表示写入数据</span></span><br><span class="line">	spi_write_datas(ker_buf, count);</span><br><span class="line">	kfree(ker_buf);</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">spidev_fops</span> =</span> &#123;</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.write =	spidev_write,</span><br><span class="line">	.unlocked_ioctl = spidev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">spidev_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">spidev_dt_ids</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;100ask,oled&quot;</span> &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_probe</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span></span><br><span class="line">&#123;</span><br><span class="line">	oled = spi;</span><br><span class="line"> </span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_oled&quot;</span>, &amp;spidev_fops);</span><br><span class="line">	spidev_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_oled&quot;</span>);</span><br><span class="line">	device_create(spidev_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_oled&quot;</span>);	</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 3. 获得GPIO引脚 */</span></span><br><span class="line">	dc_gpio = gpiod_get(&amp;spi-&gt;dev, <span class="string">&quot;dc&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spidev_remove</span><span class="params">(<span class="keyword">struct</span> spi_device *spi)</span> &#123;</span><br><span class="line">	gpiod_put(dc_gpio);</span><br><span class="line">	device_destroy(spidev_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(spidev_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;cumtchw_oled&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> <span class="title">spidev_spi_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name =		<span class="string">&quot;cumtchw_spi_oled_drv&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(spidev_dt_ids),</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe =	spidev_probe,</span><br><span class="line">	.remove =	spidev_remove,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">spidev_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line">	status = spi_register_driver(&amp;spidev_spi_driver);</span><br><span class="line">	<span class="keyword">if</span> (status &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">spidev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	spi_unregister_driver(&amp;spidev_spi_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(spidev_init);</span><br><span class="line">module_exit(spidev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5><span id="1-3-5-2-1-qu-dong-fen-xi">1.3.5.2.1 驱动分析</span><a href="#1-3-5-2-1-qu-dong-fen-xi" class="header-anchor">#</a></h5><ol>
<li>调用<code>spi_register_driver</code>注册SPI从设备驱动，probe函数中利用标准字符设备驱动框架编写的驱动，注册字符设备，添加类。</li>
<li>当用户调用<code>open(&quot;/dev/100ask_oled&quot;)</code>后，就可以调用read,write函数读写oled。<ol>
<li>spidev_ioctl提供了2个ioctl命令，用来初始化oled和设置坐标位置。用<code>spi_write_datas</code>写入初始化序列，每次写1byte。</li>
<li><code>spi_write_datas</code>调用标准的SPI从设备驱动API(<code>spi_write</code>)传输数据。</li>
</ol>
</li>
<li>spi oled初始化完后就可以使用另一个<code>OLED_IOC_SET_POS</code> ioctl命令设置坐标位置。</li>
<li>调用spidev_write写入数据。</li>
</ol>
<h4><span id="1-3-5-3-spi-oled-c-ying-yong-ce-shi">1.3.5.3 spi_oled.c应用测试</span><a href="#1-3-5-3-spi-oled-c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/spi/spidev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;font.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_INIT 			123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_IOC_SET_POS 		124</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//为0 表示命令，为1表示数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_CMD 	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OLED_DATA 	1</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd_spidev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dc_pin_num;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">oled_write_datas</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	write(fd_spidev, buf, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Clear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_All</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x, y;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0xff</span>, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">8</span>; y++) &#123;</span><br><span class="line">        OLED_DIsp_Set_Pos(<span class="number">0</span>, y);</span><br><span class="line">        oled_write_datas(buf, <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Set_Pos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123; 	</span><br><span class="line">	ioctl(fd_spidev, OLED_IOC_SET_POS, x  | (y &lt;&lt; <span class="number">8</span>));</span><br><span class="line">&#125;   	      	   			 </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* 得到字模 */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* 发给OLED */</span></span><br><span class="line">	OLED_DIsp_Set_Pos(x, y);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">	<span class="comment">//	oled_write_cmd_data(dots[i], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">0</span>], <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">	OLED_DIsp_Set_Pos(x, y+<span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">	<span class="comment">//for (i = 0; i &lt; 8; i++)</span></span><br><span class="line">		<span class="comment">//oled_write_cmd_data(dots[i+8], OLED_DATA);</span></span><br><span class="line">	oled_write_datas(&amp;dots[<span class="number">8</span>], <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_String</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[j]) &#123;		</span><br><span class="line">		OLED_DIsp_Char(x, y, str[j]);<span class="comment">//显示单个字符</span></span><br><span class="line">		x += <span class="number">8</span>;</span><br><span class="line">		<span class="keyword">if</span>(x &gt; <span class="number">127</span>) &#123;</span><br><span class="line">			x = <span class="number">0</span>;</span><br><span class="line">			y += <span class="number">2</span>;</span><br><span class="line">		&#125;<span class="comment">//移动显示位置</span></span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DIsp_Test</span><span class="params">(<span class="type">void</span>)</span> &#123; 	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	OLED_DIsp_String(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;100ask test&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;	</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s /dev/cumtchw_oled\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	fd_spidev = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd_spidev &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;open %s err\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ioctl(fd_spidev, OLED_IOC_INIT);</span><br><span class="line">	OLED_DIsp_Clear();</span><br><span class="line">	OLED_DIsp_Test();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-spi-master-x2f-spi-controller">2.1 spi_master&#x2F;spi_controller</span><a href="#2-1-spi-master-x2f-spi-controller" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_master</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>	<span class="title">dev</span>;</span>	<span class="comment">/* SPI设备的device数据结构 */</span></span><br><span class="line">	s16			bus_num;		<span class="comment">/* SPI总线序号 */</span></span><br><span class="line">	u16			num_chipselect;	<span class="comment">/* 片选信号数量 */</span></span><br><span class="line">	u16			dma_alignment;	<span class="comment">/* SPI控制器DMA缓冲区对齐定义 */</span></span><br><span class="line">	u16			mode_bits;		<span class="comment">/* 工作模式位，由驱动定义 */</span></span><br><span class="line">	u32			min_speed_hz;	<span class="comment">/* 最小速度 */</span></span><br><span class="line">	u32			max_speed_hz;	<span class="comment">/* 最小速度 */</span></span><br><span class="line">	u16			flags;			<span class="comment">/* 限制条件标志 */</span></span><br><span class="line">	<span class="type">int</span>			(*setup)(<span class="keyword">struct</span> spi_device *spi);   <span class="comment">/* 设置SPI设备的工作参数 */</span></span><br><span class="line">	<span class="type">int</span>			(*transfer)(<span class="keyword">struct</span> spi_device *spi,	<span class="comment">/* SPI发送函数1 */</span></span><br><span class="line">						<span class="keyword">struct</span> spi_message *mesg);</span><br><span class="line">	<span class="type">void</span>		(*cleanup)(<span class="keyword">struct</span> spi_device *spi);	<span class="comment">/* SPI清除函数，当spi_master被释放时调用 */</span></span><br><span class="line">	<span class="type">int</span> (*transfer_one_message)(<span class="keyword">struct</span> spi_master *master,	<span class="comment">/* SPI发送函数2 */</span></span><br><span class="line">	<span class="type">int</span> (*transfer_one)(<span class="keyword">struct</span> spi_master *master, <span class="keyword">struct</span> spi_device *spi,<span class="comment">/* SPI发送函数3 */</span></span><br><span class="line">			    <span class="keyword">struct</span> spi_transfer *transfer);</span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct <code>spi_master</code>描述一个spi控制器，包扩spi控制器的属性描述信息，spi的一些操作回调函数，如<code>transfer</code>，<code>setup</code>。</p>
<h2><span id="2-2-spi-driver">2.2 spi_driver</span><a href="#2-2-spi-driver" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_driver</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">spi_device_id</span> *<span class="title">id_table</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*probe)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">int</span>			(*remove)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="type">void</span>			(*shutdown)(<span class="keyword">struct</span> spi_device *spi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span>	<span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来描述一个spi从设备驱动。用来和spi从设备匹配。</p>
<h2><span id="2-3-spi-device">2.3 spi_device</span><a href="#2-3-spi-device" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">controller</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_controller</span>	*<span class="title">master</span>;</span>	<span class="comment">/* compatibility layer */</span></span><br><span class="line">	u32			max_speed_hz;</span><br><span class="line">	u8			chip_select;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPHA	0x01			<span class="comment">/* clock phase */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CPOL	0x02			<span class="comment">/* clock polarity */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_0	(0|0)			<span class="comment">/* (original MicroWire) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_1	(0|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_2	(SPI_CPOL|0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_HIGH	0x04			<span class="comment">/* chipselect active high? */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LSB_FIRST	0x08			<span class="comment">/* per-word bits-on-wire */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE	0x10			<span class="comment">/* SI/SO signals shared */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_LOOP	0x20			<span class="comment">/* loopback mode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_NO_CS	0x40			<span class="comment">/* 1 dev/bus, no chipselect */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_READY	0x80			<span class="comment">/* slave pulls low to pause */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_DUAL	0x100			<span class="comment">/* transmit with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_QUAD	0x200			<span class="comment">/* transmit with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_DUAL	0x400			<span class="comment">/* receive with 2 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_QUAD	0x800			<span class="comment">/* receive with 4 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_CS_WORD	0x1000			<span class="comment">/* toggle cs after each word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_TX_OCTAL	0x2000			<span class="comment">/* transmit with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_RX_OCTAL	0x4000			<span class="comment">/* receive with 8 wires */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	SPI_3WIRE_HIZ	0x8000			<span class="comment">/* high impedance turnaround */</span></span></span><br><span class="line">	<span class="type">int</span>			irq;</span><br><span class="line">	<span class="type">void</span>			*controller_state;</span><br><span class="line">	<span class="type">void</span>			*controller_data;</span><br><span class="line">	<span class="type">char</span>			modalias[SPI_NAME_SIZE];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*driver_override;</span><br><span class="line">	<span class="type">int</span>			cs_gpio;	<span class="comment">/* LEGACY: chip select gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span>	*<span class="title">cs_gpiod</span>;</span>	<span class="comment">/* chip select gpio desc */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_delay</span>	<span class="title">word_delay</span>;</span> <span class="comment">/* inter-word delay */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用来描述一个spi从设备。用来和spi从设备驱动匹配。</p>
<h2><span id="2-4-spi-message-x2f-spi-transfer">2.4 spi_message&#x2F;spi_transfer</span><a href="#2-4-spi-message-x2f-spi-transfer" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_transfer</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span>	*tx_buf;</span><br><span class="line">	<span class="type">void</span>		*rx_buf;</span><br><span class="line">	<span class="type">unsigned</span>	len;</span><br><span class="line">	...</span><br><span class="line">	u8		bits_per_word;</span><br><span class="line">	u16		delay_usecs;</span><br><span class="line">	u32		speed_hz;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">transfer_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spi_message</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">transfers</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">spi_device</span>	*<span class="title">spi</span>;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="type">void</span>			(*complete)(<span class="type">void</span> *context);</span><br><span class="line">	<span class="type">void</span>			*context;</span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">queue</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>spi_message</code>是发起一次数据传输，里面的<code>transfers</code>构成基本输入输出数据，通过<code>spi_sync</code>函数或<code>spi_async</code>函数发送。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxogea004fqsuf1zlc0eh5" data-title="字符设备驱动-SPI子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-I2C子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T08:23:34.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</a></li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</a><ul>
<li><a href="#2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</a></li>
<li><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</a></li>
</ul>
</li>
<li><a href="#2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</a><ul>
<li><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</a></li>
<li><a href="#2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</a><ul>
<li><a href="#2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</a></li>
</ul>
</li>
<li><a href="#3-i2c-zi-xi-tong-api">3 I2C子系统API</a><ul>
<li><a href="#3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</a><ul>
<li><a href="#3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</a></li>
<li><a href="#3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</a></li>
</ul>
</li>
<li><a href="#3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</a><ul>
<li><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</a></li>
<li><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</a></li>
<li><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</a></li>
<li><a href="#3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</a><ul>
<li><a href="#3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</a></li>
<li><a href="#3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</a></li>
<li><a href="#3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</a><ul>
<li><a href="#4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</a><ul>
<li><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</a></li>
</ul>
</li>
<li><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</a><ul>
<li><a href="#4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</a><ul>
<li><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</a></li>
<li><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</a></li>
</ul>
</li>
<li><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</a><ul>
<li><a href="#4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</a></li>
<li><a href="#4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</a><ul>
<li><a href="#4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</a><ul>
<li><a href="#4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</a><ul>
<li><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</a></li>
<li><a href="#4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</a></li>
</ul>
</li>
<li><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</a><ul>
<li><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</a></li>
<li><a href="#4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</a></li>
<li><a href="#4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</a></li>
<li><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</span><a href="#1-linux-i2c-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>由上到下分为3层结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i2c设备驱动层: 作为client使用者使用i2c子系统。提供操作接口给应用层，与应用层交互数据。</span><br><span class="line"></span><br><span class="line">I2C核心层：提供transfer send recv函数。把client设备挂载到I2C总线上；</span><br><span class="line">    维护i2c driver和i2c client 链表 ，实现i2c_client和i2c_driver匹配。</span><br><span class="line"></span><br><span class="line">I2C适配器层：底层SOC I2C控制器驱动，实现i2c时序，实现i2c总线发送和接收数据的方法。</span><br></pre></td></tr></table></figure>

<p>目录结构位于drivers&#x2F;i2c：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/robin.lee/zip/A2/linux_5.10/drivers/i2c$ <span class="built_in">ls</span></span><br><span class="line">algos            i2c-core-acpi.c  i2c-core-of.c     i2c-dev.c           i2c-slave-testunit.c  Kconfig</span><br><span class="line">busses           i2c-core-base.c  i2c-core-slave.c  i2c-mux.c           i2c-smbus.c           Makefile</span><br><span class="line">i2c-boardinfo.c  i2c-core.h       i2c-core-smbus.c  i2c-slave-eeprom.c  i2c-stub.c            muxes</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</span><a href="#2-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</span><a href="#2-1-1-i2c-adapter-kong-zhi-qi" class="header-anchor">#</a></h3><p> I2C 适配器，也就是 SOC 的 I2C 控制器。<code>i2c_adapter</code> 结构体定义在<code> include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="type">int</span> nr;   <span class="comment">//总线的编号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>适配器的类类型，在一些口I2C设备驱动中会检查该成员，以判断设备能否被该适配器操作</td>
</tr>
<tr>
<td>algo</td>
<td>指向该造配器通信方法描述结构的指针，就是该适配器具体操作I2C控制器的函数</td>
</tr>
<tr>
<td>algo_data</td>
<td>指向通信方法数据的指针，该成员不会被I2C核心层修改，仅供具体的 i2c_algorithm使用</td>
</tr>
<tr>
<td>timeout</td>
<td>传输超时时间</td>
</tr>
<tr>
<td>retries</td>
<td>传输超时的重试次数</td>
</tr>
<tr>
<td>name</td>
<td>适配器名称，该名称可以通过<code>sys/bus/i2c/devices/i2c-x/name</code> (x&#x3D;0,1,2 … ）来访问</td>
</tr>
<tr>
<td>nr</td>
<td>总线编号（也是适配器编号），同时对应设备节点<code>／dev/i2c-x</code> (x&#x3D;0,1,2 …）中的 x</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</span><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa" class="header-anchor">#</a></h3><p>对于一个 I2C 适配器，肯定要对外提供读 写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。<code>i2c_algorithm </code>就是 I2C 适 配器与 IIC 设备进行通信的方法。包括<code>transfer send recv</code>等函数<code>。i2c_algorithm </code>结构体定义在 <code>include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>master_xfer </code>就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之 间的通信。 用于产生I2C访问周期需要的信号， 以<code>i2c_msg</code>为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<p><code>smbus_xfer</code> 是 SMBUS 总线协议的传输函数。</p>
<p><code>functionality</code>：查看适配的能力。这些功能都是以宏定义的方式表示，定义在<code>include/linux/i2c.h</code>中，以<code>I2C_FUNC</code>开头：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To determine what functionality is present */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_10BIT_ADDR		0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_IGNORE_NAK etc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_NOSTART		0x00000010 /* I2C_M_NOSTART */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SLAVE			0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_HOST_NOTIFY	0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br></pre></td></tr></table></figure>



<h2><span id="2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</span><a href="#2-2-ke-hu-duan-xiang-guan" class="header-anchor">#</a></h2><p>i2c 设备(client使用者)驱动要使用<code>i2c_driver</code> 和<code>i2c_client</code>数据结构并填充i2c_driver中的成员函数。</p>
<h3><span id="2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</span><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong" class="header-anchor">#</a></h3><p>代表一个i2c使用者设备驱动。结构体定义在 include&#x2F;linux&#x2F;i2c.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);<span class="comment">//类似于ioctl 的命令控制函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> </span><br><span class="line">	<span class="type">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attach_adapter</td>
<td>依附i2c_adapter的函数指针</td>
</tr>
<tr>
<td>detach_adapter</td>
<td>脱离i2c_adapter的函数指针</td>
</tr>
<tr>
<td>probe</td>
<td>设备和驱动匹配时调用</td>
</tr>
<tr>
<td>driver</td>
<td>在注册i2c_driver对象时，i2c_driver-&gt;driver的总线类型被指定为<code>i2c_bus_type</code></td>
</tr>
<tr>
<td>id_table</td>
<td>匹配列表，驱动和设备匹配时会用到</td>
</tr>
<tr>
<td>detect</td>
<td>基于设备探测机制实现的 12C 设备驱动：设备探测的回调函数</td>
</tr>
<tr>
<td>address_list</td>
<td>设备探测的地址范围</td>
</tr>
<tr>
<td>clients</td>
<td>探测到的设备列表</td>
</tr>
</tbody></table>
<p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;rtc-ds1307&quot;</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</span><a href="#2-2-2-i2c-client-cong-she-bei" class="header-anchor">#</a></h3><p>代表一个连接到<code>i2c_bus</code>总线上的从设备，结构体定义在 <code>include/linux/i2c.h</code>。描述i2c从设备的i2c相关硬件信息。 一个i2c_driver可以支持多个同类型的i2c_client。i2c_client一般描述再设备树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>&#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> flags;   <span class="comment">//描述从设备的一些特性，如I2C_CLIENT_TEN---使用的10位地址</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> addr;   <span class="comment">//设备的i2c地址，7位地址用低7位，10位地址用低10位。</span></span><br><span class="line"> 	<span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line"></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>   <span class="comment">//所属的适配器i2c_adapter,挂载在哪条i2c物理总线上</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>  *<span class="title">driver</span>;</span>    <span class="comment">//匹配成功的i2c_driver</span></span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</span><a href="#2-2-2-1-i2c-board-info" class="header-anchor">#</a></h4><p>也是描述从设备i2c硬件属性。通常情况下先填充i2c_board_info对象的成员，然后去初始化i2c_client对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> type[I2C_NAME_SIZE];<span class="comment">//名字，驱动层和设备层匹配参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//设备地址位数，一般不填或填0表示7位地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">//IIC设备地址</span></span><br><span class="line">    <span class="type">void</span> *platform_data;<span class="comment">//私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> irq;<span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</span><a href="#2-3-i2c-msg-xiao-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* 从机在I2C总线上的地址*/</span></span><br><span class="line">	__u16 flags;	<span class="comment">/* 消息特征的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的宏定义就是消息特征的标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* 消息数据长度，单位是字节 */</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* 指向存放消息数据的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息。</p>
<h1><span id="3-i2c-zi-xi-tong-api">3 I2C子系统API</span><a href="#3-i2c-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</span><a href="#3-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</span><a href="#3-1-1-zhu-ce-kong-zhi-qi" class="header-anchor">#</a></h3><p>通过<code>i2c_add_numbered_adapter</code>或 <code>i2c_add_adapter</code> 这两个函数向系统注册设置好的 i2c_adapter。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter 使用静态总线号。</p>
<h3><span id="3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</span><a href="#3-1-2-xie-zai-kong-zhi-qi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</span><a href="#3-2-ke-hu-duan-she-bei-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</span><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">i2c_register_driver</span>(<span class="params"><span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver</span>)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver);</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</span><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</span><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong" class="header-anchor">#</a></h3><p>在编写从设备驱动时为了方便也可以直接调用<code>module_i2c_driver</code>完成i2c驱动的<code>module_init</code>。或者使用<code>builtin_i2c_driver</code>完成i2c驱动的<code>device_initcall</code>。两者区别一个是编译成内核模块，一个是编译进内核镜像。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_init(__driver<span class="meta">##_init); \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit __driver<span class="meta">##_exit(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	__unregister(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_exit(__driver<span class="meta">##_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * builtin_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in init and have no exit. This eliminates some boilerplate.</span></span><br><span class="line"><span class="comment"> * Each driver may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * device_initcall (or in some cases, the legacy __initcall).  This is</span></span><br><span class="line"><span class="comment"> * meant to be a direct parallel of module_driver() above but without</span></span><br><span class="line"><span class="comment"> * the __exit stuff that is not used for builtin cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> builtin_driver(__driver, __register, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">device_initcall(__driver<span class="meta">##_init);</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</span><a href="#3-2-4-shu-ju-chuan-shu" class="header-anchor">#</a></h3><h4><span id="3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</span><a href="#3-2-4-1-i2c-transfer" class="header-anchor">#</a></h4><p>发送或接收指定字节数的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</span><a href="#3-2-4-2-i2c-master-recv" class="header-anchor">#</a></h4><p>接收指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</span><a href="#3-2-4-3-i2c-master-send" class="header-anchor">#</a></h4><p>发送指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</span><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</span><a href="#4-1-he-xin-core-ceng-zhu-ce" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i2c-core.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,	<span class="comment">//总线上驱动和设备的匹配函数</span></span><br><span class="line">	.probe		= i2c_device_probe,	<span class="comment">//总线上设备和驱动匹配时调用</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">	.pm		= &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">dummy_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;dummy&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">dummy_driver</span> =</span> &#123;</span><br><span class="line">	.driver.name	= <span class="string">&quot;dummy&quot;</span>,</span><br><span class="line">	.probe		= dummy_probe,</span><br><span class="line">	.remove		= dummy_remove,</span><br><span class="line">	.id_table	= dummy_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="comment">//注册I2C总线</span></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;	</span><br><span class="line">	<span class="comment">//向I2C总线注册一个名字为dummy的驱动，这个驱动没什么实际的功能，空实现的驱动</span></span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">class_err:</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">i2c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//删除dummy驱动</span></span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="comment">//卸载I2C总线</span></span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must initialize early, because some subsystems register i2c drivers</span></span><br><span class="line"><span class="comment"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到内核启动阶段就调用i2c_init 注册了I2C总线和注册了I2C设备驱动<code>dummy_driver</code>；</p>
<h3><span id="4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</span><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="title function_">i2c_match_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	driver = to_i2c_driver(drv);</span><br><span class="line">	<span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向I2C总线注册I2C驱动或者I2C设备时，会逐一将I2C驱动的名字和I2C设备的名字进行匹配，如果匹配上则调用I2C总线的probe方法；</p>
<p>I2C总线的probe方法就是进一步调用i2c_driver的probe方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C设备结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C驱动结构体</span></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 把I2C设备驱动和I2C设备绑定，将来可以互相查找到对方</span></span><br><span class="line">	client-&gt;driver = driver;</span><br><span class="line">	<span class="keyword">if</span> (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">					client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用I2C驱动的probe函数</span></span><br><span class="line">	status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		client-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		i2c_set_clientdata(client, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</span><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</span><a href="#4-2-1-gua-pei-qi-zhu-ce" class="header-anchor">#</a></h3><h4><span id="4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</span><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu" class="header-anchor">#</a></h4><p>以nxp的imx6ull芯片为例，在<code>imx6ull.dtsi</code>文件中找到 I2C1 控制器节点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1节点的compatible属性值有两个：<code>fsl,imx6ul-i2c</code>和<code>fsl,imx21-i2c</code>，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件为<code>drivers/i2c/busses/i2c-imx.c</code>。</p>
<h4><span id="4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</span><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>I2C 适配器驱动也是使用标准的 platform 驱动框架。<code>compatible</code> 属性匹配成功后就会调用probe函数如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.1.png" alt="image"></p>
<details>
<summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_hwdata</span> *<span class="title">match</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	match = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (match)</span><br><span class="line">		i2c_imx-&gt;hwdata = match;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line">	ACPI_COMPANION_SET(&amp;i2c_imx-&gt;adapter.dev, ACPI_COMPANION(&amp;pdev-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get I2C clock */</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(&amp;pdev-&gt;dev, PTR_ERR(i2c_imx-&gt;clk),</span><br><span class="line">				     <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init queue */</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up adapter data */</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up platform driver data */</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, I2C_PM_TIMEOUT);</span><br><span class="line">	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Request IRQ */</span></span><br><span class="line">	ret = request_threaded_irq(irq, i2c_imx_isr, <span class="literal">NULL</span>, IRQF_SHARED,</span><br><span class="line">				   pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up clock divider */</span></span><br><span class="line">	i2c_imx-&gt;bitrate = I2C_MAX_STANDARD_MODE_FREQ;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line">	i2c_imx-&gt;clk_change_nb.notifier_call = i2c_imx_clk_notifier_call;</span><br><span class="line">	clk_notifier_register(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	i2c_imx_set_clk(i2c_imx, clk_get_rate(i2c_imx-&gt;clk));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init optional bus recovery function */</span></span><br><span class="line">	ret = i2c_imx_init_recovery_info(i2c_imx, pdev);</span><br><span class="line">	<span class="comment">/* Give it another chance if pinctrl used is not ready yet */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add I2C adapter */</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	pm_runtime_mark_last_busy(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init DMA config if supported */</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_notifier_unregister:</span><br><span class="line">	clk_notifier_unregister(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	free_irq(irq, i2c_imx);</span><br><span class="line">rpm_disable:</span><br><span class="line">	pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ol>
<li><p><code>platform_get_irq</code> 函数获取中断号。</p>
</li>
<li><p><code>platform_get_resource </code>函数从设备树中获取 I2C1 控制器寄存器物理基 地址，也就是 <code>0X021A0000</code>。使用 <code>devm_ioremap_resource </code>函数对其进 行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p>
</li>
<li><p>使用 <code>imx_i2c_struct </code>结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使 用 <code>devm_kzalloc</code> 函数来申请内存。</p>
</li>
<li><p>初始化<code>i2c_adapter</code>。设置i2c_adapter 的algo成员变量为<code>i2c_imx_algo</code>， 也就是设置<code> i2c_algorithm</code>。</p>
</li>
<li><p>开启i2c时钟。</p>
</li>
<li><p>注册 I2C 控制器中断，中断服务函数为<code> i2c_imx_isr</code>。</p>
</li>
<li><p>设置 I2C 频率默认为 <code>IMX_I2C_BIT_RATE=100KHz</code>，如果设备树节点设 置了<code>“clock-frequency”</code>属性的话 I2C 频率就使用 <code>clock-frequency</code> 属性值。</p>
</li>
<li><p>设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image-20240825172735043"></p>
</li>
<li><p>调用 <strong>i2c_add_numbered_adapter</strong> 函数向 Linux 内核注册 i2c_adapter。</p>
</li>
</ol>
<h3><span id="4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</span><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">    .master_xfer = i2c_imx_xfer,</span><br><span class="line">    .functionality = i2c_imx_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</span><a href="#4-2-2-1-i2c-imx-func" class="header-anchor">#</a></h4><p><code>functionality</code>用于返回此I2C适配器支持什么样的通信协议， 在这里<code> functionality</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">i2c_imx_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</span><a href="#4-2-2-2-i2c-imx-xfer" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = pm_runtime_get_sync(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">false</span>);</span><br><span class="line">	pm_runtime_mark_last_busy(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	pm_runtime_put_autosuspend(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_atomic</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = clk_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">true</span>);</span><br><span class="line">	clk_disable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</span><a href="#4-2-2-2-1-i2c-imx-xfer-common" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_msg *msgs,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> num, <span class="type">bool</span> atomic)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start I2C transfer */</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">	<span class="keyword">if</span> (result) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Bus recovery uses gpiod_get_value_cansleep() which is not</span></span><br><span class="line"><span class="comment">		 * allowed within atomic context.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!atomic &amp;&amp; i2c_imx-&gt;adapter.bus_recovery_info) &#123;</span><br><span class="line">			i2c_recover_bus(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">			result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line">	<span class="comment">/* read/write data */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);</span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>, atomic);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);</span><br><span class="line">		<span class="comment">/* write/read data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_DEBUG_BUS</span></span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2CR_IEN ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_IIEN ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_MSTA ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_MTX ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_TXAK ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_RSTA ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2SR_ICF ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAAS ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_IBB ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAL ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_SRW ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IIF ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_RXAK ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg, atomic);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!atomic &amp;&amp;</span><br><span class="line">			    i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i], atomic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">/* Stop I2C transfer */</span></span><br><span class="line">	i2c_imx_stop(i2c_imx, atomic);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,</span><br><span class="line">		(result &lt; <span class="number">0</span>) ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;success msg&quot;</span>,</span><br><span class="line">			(result &lt; <span class="number">0</span>) ? result : num);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用<code>i2c_imx_start</code>函数开启 I2C 通信。</li>
<li>读数据的话就调用 <code>i2c_imx_read</code> 函数。</li>
<li>向 I2C 设备写数据，如果要用 DMA 的话就使用<code> i2c_imx_dma_write</code> 函数来 完成写数据。如果不使用 DMA 的话就使用 <code>i2c_imx_write</code> 函数完成写数据。</li>
<li>I2C 通信完成以后调用<code>i2c_imx_stop</code>函数停止 I2C 通信。</li>
</ol>
<p><code>i2c_imx_start</code>、<code>i2c_imx_read</code>、<code>i2c_imx_write</code> 和 <code>i2c_imx_stop</code> 这些函数就是 I2C 寄存器的具体操作函数，按照<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15384523.html">i2c协议</a>。</p>
<h2><span id="4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</span><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</span><a href="#4-3-1-i2c-cong-she-bei-miao-shu" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</span><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu" class="header-anchor">#</a></h4><p>在未使用设备树的时候需要在 BSP 里面使用<code>i2c_board_info</code>结构体来描 述一个具体的 I2C 设备。</p>
<p>举个例子，<code>arch/arm/mach-imx/mach-mx27_3ds.c</code>， <code>OV2640 摄像头</code>使用的 I2C 设备信息描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">mx27_3ds_i2c_camera</span> =</span> &#123;</span><br><span class="line">	I2C_BOARD_INFO(<span class="string">&quot;ov2640&quot;</span>, <span class="number">0x30</span>),</span><br><span class="line">&#125;;<span class="comment">//从设备OV2640 的名字和i2c地址</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</span><a href="#4-3-1-2-shi-yong-dts-miao-shu" class="header-anchor">#</a></h4><p>比如NXP 官方的 EVK 开发 板在<code> I2C1</code> 上接了 <code>mag3110 </code>这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然 后在这个子节点内描述 mag3110 这个i2c外设的相关信息。打开 <code>imx6ull-14x14-evk.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点 是 <code>compatible </code>属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</p>
<h3><span id="4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</span><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</span><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi" class="header-anchor">#</a></h4><p>AP3216C是一个三合一环境传感器，包含<code>环境光强度(ALS)、接近距离(PS)和红外线强度(IR)</code>这 三个环境参数检测。接开发板子的<code>i2c1</code>。因此用这个外设作为i2c从设备来举例。</p>
<p>AP3216C 的特点 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. I2C 接口，快速模式下波特率可以到 400Kbit/S</span><br><span class="line">2. 多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等。</span><br><span class="line">3. 内建温度补偿电路。</span><br><span class="line">4. 宽工作温度范围(-30°C ~ +80°C)。</span><br><span class="line">5. 超小封装，4.1mm x 2.4mm x 1.35mm</span><br><span class="line">6. 环境光传感器具有 16 位分辨率。</span><br><span class="line">7. 接近传感器和红外传感器具有 10 位分辨率</span><br></pre></td></tr></table></figure>

<p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</span><a href="#4-3-2-2-dts-she-zhi" class="header-anchor">#</a></h4><p>打开 <code>imx6ull-alientek-emmc.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1使用<code>pinctrl子系统</code>配置了iomux属性。<code>pinctrl_i2c1</code> 就是 I2C1 的 IO 节点，这里将<code> UART4_TXD</code> 和 <code>UART4_RXD </code>这两个 IO 分别 复用为<code> I2C1_SCL</code> 和<code> I2C1_SDA</code>，电气属性都设置为 <code>0x4001b8b0</code>。</p>
<p>默认i2c1 节点下并不是对应 <code>ap3216c</code> 从设备，而是<code>mag3110</code>。修改dts如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ap3216c </code>子节点，@后面的<code>“1e”</code>是 ap3216c 的<code>器件地址</code>。</p>
<p>reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 <code>0x1e</code>。</p>
<p>修改编译启动linux，可以看到<code>/sys/bus/i2c/devices </code>目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在 <code>/sys/bus/i2c/devices </code>目录下看到一个名为<code>“0-001e”</code>的子目录：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p><code>“0-001e”</code>就是 ap3216c 的设备目录，<code>“1e”</code>就是 ap3216c 器件地址。进入<code> 0-001e</code> 目录，可以看到<code>“name”</code>文件，name 问价就保存着此设备名字，在这里就是<code>“ap3216c”</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</span><a href="#4-3-2-3-ap3216c-qu-dong-shi-li" class="header-anchor">#</a></h4><p><code>ap3216creg.h</code>定义<code>AP3216C 的寄存器</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AP3216C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ADDR    	0X1E	<span class="comment">/* AP3216C器件地址  */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_SYSTEMCONG	0x00	<span class="comment">/* 配置寄存器       */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTSTATUS	0X01	<span class="comment">/* 中断状态寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTCLEAR	0X02	<span class="comment">/* 中断清除寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATALOW	0x0A	<span class="comment">/* IR数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATAHIGH	0x0B	<span class="comment">/* IR数据高字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATALOW	0x0C	<span class="comment">/* ALS数据低字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATAHIGH	0X0D	<span class="comment">/* ALS数据高字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATALOW	0X0E	<span class="comment">/* PS数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATAHIGH	0X0F	<span class="comment">/* PS数据高字节     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ap3216c.c:</p>
<details>     <summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME	<span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;			<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;	<span class="comment">/* 私有数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;		<span class="comment">/* 三个光传感器数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;			<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;			<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;				<span class="comment">/* reg长度*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;		<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;		<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;				<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;			<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">		</span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_read_byte_data(client, reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ap3216c_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)	</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) 	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ir = <span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取IR传感器的数据*/</span></span><br><span class="line">		dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>); 			</span><br><span class="line">	</span><br><span class="line">	dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* 读取ALS传感器的数据*/</span>  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>)	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ps = <span class="number">0</span>;    													</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取PS传感器的数据    */</span></span><br><span class="line">		dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">	<span class="comment">/* 初始化AP3216C */</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);<span class="comment">/* 复位AP3216C */</span></span><br><span class="line">	mdelay(<span class="number">50</span>);	<span class="comment">/* AP3216C复位最少10ms 	*/</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0X03</span>);<span class="comment">/* 开启ALS、PS+IR */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">	<span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">	ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = ap3216c_open,</span><br><span class="line">	.read = ap3216c_read,</span><br><span class="line">	.release = ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">		ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">		ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">	cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line">	ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid,</span><br><span class="line">                                      <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">	unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line">	device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">	class_destroy(ap3216cdev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">	.probe = ap3216c_probe,</span><br><span class="line">	.remove = ap3216c_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">		   	.of_match_table = ap3216c_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">module_i2c_driver(ap3216c_driver);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</details>

<ol>
<li>典型的i2c驱动框架编写的从设备驱动示例，<code>i2c_add_driver/i2c_del_driver</code>添加和删除从设备驱动。</li>
<li><code>ap3216c_of_match</code>中<code>compatible</code>匹配上，执行<code>ap3216c_probe</code>，把从设备ap3216c按照字符设备框架构造驱动。</li>
<li><code>ap3216cdev.private_data = client</code>， <code>private_data </code>成员变量用于存放 <code>ap3216c </code>对 应的 <code>i2c_client</code>。</li>
<li><code>ap3216c_open</code>初始化<code>ap3216c</code>。</li>
<li>传感器数据获取</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ap3216c_read</span><br><span class="line">   	ap3216c_readdata<span class="comment">//读取数据6字节</span></span><br><span class="line">   		ap3216c_read_reg<span class="comment">//读取一个字节</span></span><br><span class="line">   			ap3216c_read_regs<span class="comment">//构造i2c_msg[2]调用i2c_transfer获取1个字节传感器数据</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>ap3216c_write_reg</code>调用<code>ap3216c_write_regs</code>再调用<code>i2c_transfer</code>写入数据到指定地址寄存器。</li>
</ol>
<h4><span id="4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</span><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> databuf[<span class="number">3</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			ir =  databuf[<span class="number">0</span>]; 	<span class="comment">/* ir传感器数据 */</span></span><br><span class="line">			als = databuf[<span class="number">1</span>]; 	<span class="comment">/* als传感器数据 */</span></span><br><span class="line">			ps =  databuf[<span class="number">2</span>]; 	<span class="comment">/* ps传感器数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">200000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行程序如下：</span><br><span class="line">./a.out /dev/ap3216c</span><br></pre></td></tr></table></figure>

<p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxoge90046qsuf5v1d1eeo" data-title="字符设备驱动-I2C子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-内核led子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T09:01:56.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</a><ul>
<li><a href="#1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</a></li>
<li><a href="#1-2-jie-gou-ti-miao-shu">1.2 结构体描述</a><ul>
<li><a href="#1-2-1-led-classdev">1.2.1 led_classdev</a></li>
<li><a href="#1-2-2-gpio-led">1.2.2 gpio_led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-led-qu-dong-shi-neng">2 LED 驱动使能</a></li>
<li><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</a><ul>
<li><a href="#3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</a><ul>
<li><a href="#3-1-1-create-gpio-led">3.1.1 create_gpio_led</a></li>
<li><a href="#3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</a><ul>
<li><a href="#4-1-dts-bian-xie">4.1 dts编写</a></li>
<li><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</a></li>
</ul>
</li>
<li><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</a><ul>
<li><a href="#5-1-dian-liang-led">5.1 点亮 LED</a></li>
<li><a href="#5-2-shan-shuo">5.2 闪烁</a></li>
<li><a href="#5-3-guan-bi-led">5.3 关闭 LED</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</span><a href="#1-led-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>用来管理控制板子的led灯，比如系统心跳灯，普通的硬盘指示灯光，颜色灯，休眠唤醒灯等等。</p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>led 子系统相关描述可在内核源码 <code>Documentation/leds/leds-class.txt </code>了解。</p>
<p>led 子系统是一个简单的 Linux 子系统 ，在目录 <code>/sys/class/leds</code> 下展示该子系统设备，每个设备都有自己的属性：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brightness：设置 LED 亮度，范围 <span class="number">0</span> ~ max_brightness</span><br><span class="line">max_brightness：最大亮度（<span class="number">255</span> 或其他数字）</span><br><span class="line">trigger：触发方式，如 heartbeat、mmc0、backlight、gpio</span><br><span class="line">delay_off、delay_on：trigger为timer时，LED亮灭的时间，单位ms</span><br></pre></td></tr></table></figure>

<p><code>kernel/include/linux/leds.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span> &#123;</span></span><br><span class="line">	LED_OFF  = <span class="number">0</span>,    <span class="comment">//全暗</span></span><br><span class="line">	LED_HALF = <span class="number">127</span>,  <span class="comment">//一半亮度</span></span><br><span class="line">	LED_FULL = <span class="number">255</span>,  <span class="comment">//最大亮度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</span><a href="#1-1-dai-ma-kuang-jia-fen-xi" class="header-anchor">#</a></h2><p><code>led-class.c</code> (led 子系统框架的入口)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有 LED 设备，为 LED 设备提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_classdev_register()</span><br><span class="line">devm_led_classdev_register()</span><br><span class="line"></span><br><span class="line">注销操作函数:</span><br><span class="line">led_classdev_unregister()</span><br><span class="line">devm_led_classdev_unregister();</span><br><span class="line"></span><br><span class="line">电源管理的休眠和恢复操作函数: </span><br><span class="line">led_classdev_suspend()</span><br><span class="line">led_classdev_resume();</span><br><span class="line"></span><br><span class="line">用户态操作接口:brightness 、max_brightness</span><br></pre></td></tr></table></figure>
<p><code>led-core.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象出 LED 操作逻辑，封装成函数导出，供其它文件使用:</span><br><span class="line"></span><br><span class="line">led_init_core(): 核心初始化;</span><br><span class="line">led_blink_set(): 设置led闪烁时间:</span><br><span class="line">led_blink_set_oneshot() : 闪烁一次</span><br><span class="line">led_stop_software_blink() : led停止闪烁</span><br><span class="line">led_set_brightness() : 设置led的亮度</span><br><span class="line">led_update_brightness : 更新亮度</span><br><span class="line">led_sysfs_disable : 用户态关闭</span><br><span class="line">led_sysfs enable : 用户态打开</span><br><span class="line">leds_list : leds链表;</span><br><span class="line">leds_list_lock : leds链表锁</span><br></pre></td></tr></table></figure>
<p><code>led-triggers.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有触发器，为触发器提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_trigger_register()</span><br><span class="line">devm_led_trigger_register()</span><br><span class="line">led_trigger_register_simple()</span><br><span class="line"></span><br><span class="line">注销操作函数: </span><br><span class="line">led_trigger_unregister()</span><br><span class="line">led_trigger_unregister_simple()</span><br><span class="line"></span><br><span class="line">以及其它触发器相关的操作函数</span><br></pre></td></tr></table></figure>
<p><code>ledtrig-timer.c、ledtrig-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以 ledtrig-timer.c 为例</span><br><span class="line"></span><br><span class="line">入口函数调用 led_trigger_register() 注册触发器，</span><br><span class="line">注册时候传入 led_trigger 结构体，里面有 activate 和 deactivate 成员函数指针，</span><br><span class="line">作用是生成 delay_on 、 delay_off 文件</span><br><span class="line"></span><br><span class="line">同时还提供 delay_on 和 delay_off 的用户态操作接口</span><br><span class="line">卸载时，使用 led_trigger_unregister() 注销触发器</span><br></pre></td></tr></table></figure>

<p><code>leds-gpio.c、leds-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以 leds-gpio.c 为例</span><br><span class="line"></span><br><span class="line">在通过设备树或者其它途径匹配到设备信息后，将调用 probe() 函数，</span><br><span class="line">然后再根据设备信息设置 led_classdev，</span><br><span class="line">最后调用 devm_led_classdev_register() 注册 LED 设备。</span><br></pre></td></tr></table></figure>

<p>对于驱动开发人员，LED框架已经有了，并不需要我们去熟悉，只要知道如何使用，它是如何与我们的硬件相关联的，只要熟悉<code>leds-gpio.c</code>。</p>
<h2><span id="1-2-jie-gou-ti-miao-shu">1.2 结构体描述</span><a href="#1-2-jie-gou-ti-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-2-1-led-classdev">1.2.1 led_classdev</span><a href="#1-2-1-led-classdev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_classdev</span> &#123;</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *name;<span class="comment">//名字</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">brightness</span>;</span><span class="comment">//亮度</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">max_brightness</span>;</span><span class="comment">//最大亮度</span></span><br><span class="line">	 <span class="type">int</span>    flags;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Lower 16 bits reflect status */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SUSPENDED  (1 &lt;&lt; 0)</span></span><br><span class="line">	 <span class="comment">/* Upper 16 bits reflect control information */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_CORE_SUSPENDRESUME (1 &lt;&lt; 16)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT (1 &lt;&lt; 17)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT_STOP (1 &lt;&lt; 18)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_INVERT (1 &lt;&lt; 19)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SYSFS_DISABLE (1 &lt;&lt; 20)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_ASYNC (1 &lt;&lt; 21)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_SYNC (1 &lt;&lt; 22)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_DEV_CAP_FLASH (1 &lt;&lt; 23)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置亮度API</span></span><br><span class="line">	 <span class="type">void</span>  (*brightness_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line">	 <span class="type">int</span>  (*brightness_set_sync)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取亮度API</span></span><br><span class="line">	 <span class="keyword">enum</span> <span class="title function_">led_brightness</span> <span class="params">(*brightness_get)</span><span class="params">(<span class="keyword">struct</span> led_classdev *led_cdev)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//闪烁时点亮和熄灭的时间设置</span></span><br><span class="line">	 <span class="type">int</span>  (*blink_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="type">unsigned</span> <span class="type">long</span> *delay_on,<span class="type">unsigned</span> <span class="type">long</span> *delay_off);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">device</span>  *<span class="title">dev</span>;</span></span><br><span class="line">	 <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//leds-list的node</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">//默认trigger的名字</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *default_trigger;</span><br><span class="line">	<span class="comment">//闪烁的开关时间</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>   blink_delay_on, blink_delay_off;</span><br><span class="line">	<span class="comment">//闪烁的定时器链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>  <span class="title">blink_timer</span>;</span></span><br><span class="line">	<span class="comment">//闪烁的亮度</span></span><br><span class="line">	 <span class="type">int</span>    blink_brightness;</span><br><span class="line">	 <span class="type">void</span>   (*flash_resume)(<span class="keyword">struct</span> led_classdev *led_cdev);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">set_brightness_work</span>;</span></span><br><span class="line">	 <span class="type">int</span>   delayed_set_value;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_LEDS_TRIGGERS</span></span><br><span class="line">	<span class="comment">//trigger的锁</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>  <span class="title">trigger_lock</span>;</span></span><br><span class="line">	<span class="comment">//led的trigger</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">led_trigger</span> *<span class="title">trigger</span>;</span></span><br><span class="line">	<span class="comment">//trigger的链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">trig_list</span>;</span></span><br><span class="line">	<span class="comment">//trigger的数据</span></span><br><span class="line">	 <span class="type">void</span>   *trigger_data;</span><br><span class="line">	 <span class="type">bool</span>   activated;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">led_access</span>;</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-2-gpio-led">1.2.2 gpio_led</span><a href="#1-2-2-gpio-led" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_led</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *default_trigger;</span><br><span class="line">	<span class="type">unsigned</span> 	gpio;</span><br><span class="line">	<span class="type">unsigned</span>	active_low : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	retain_state_suspended : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	panic_indicator : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	default_state : <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/* default_state should be one of LEDS_GPIO_DEFSTATE_(ON|OFF|KEEP) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>name</code>: led名字<br><code>default_trigger</code>:  LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br><code>default_state</code>: 默认状态，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define LEDS_GPIO_DEFSTATE_OFF		0</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_ON		1</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_KEEP		2</span><br></pre></td></tr></table></figure>
<p><code>gpiod</code>：是gpio描述，详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<h1><span id="2-led-qu-dong-shi-neng">2 LED 驱动使能</span><a href="#2-led-qu-dong-shi-neng" class="header-anchor">#</a></h1><p>输入<code>make menuconfig</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; LED Support (NEW_LEDS [=y])</span><br><span class="line">		-&gt;LED Support <span class="keyword">for</span> GPIO connected LEDs</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"><br>可 以 看 出 ， 把 Linux 内 部 自 带 的 LED 灯 驱 动 编 译 进 内 核 以 后，<code>CONFIG_LEDS_GPIO</code> 就会等于‘y’：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h1><span id="3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</span><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi" class="header-anchor">#</a></h1><p>LED 灯驱动文件为<code>/drivers/leds/leds-gpio.c</code>，大家可以打开<code>/drivers/leds/Makefile</code> 这个文件：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br>来看一下<code>leds-gpio.c</code>这个驱动文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_gpio_leds_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;gpio-leds&quot;</span>, &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_led_driver</span> =</span> &#123;</span><br><span class="line">	.probe = gpio_led_probe,</span><br><span class="line">	.remove = gpio_led_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">	.name = <span class="string">&quot;leds-gpio&quot;</span>,</span><br><span class="line">	.of_match_table = of_gpio_leds_match,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(gpio_led_driver);</span><br></pre></td></tr></table></figure>

<p>LED 驱动的匹配表，此表只有一个匹配项，<code>compatible</code> 内容为<code>“gpio-leds”</code>，<br>因此设备树中的 LED 灯设备节点的 <code>compatible </code>属性值也要为<code>“gpio-leds”</code>，否则设备和驱动匹<br>配不成功，驱动就没法工作。</p>
<p>利用内核自带LED子系统驱动，可以帮我们很好的控制板子产品的指示灯，不需要单独编写驱动程序。</p>
<h2><span id="3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</span><a href="#3-1-gpio-led-probe-han-shu-jian-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"><br>进入probe函数，pdata此时为空，<strong>进入gpio_leds_create</strong>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li>调用 <code>device_get_child_node_count</code> 函数统计子节点数量，一般在在设备树中创建<br>一个节点表示 LED 灯，然后在这个节点下面为每个 LED 灯创建一个子节点。因此子节点数量也是 LED 灯的数量。</li>
<li>遍历每个子节点，获取每个子节点的信息：<br> 2.1 <code>devm_get_gpiod_from_child</code>获取每个gpio灯的<code>gpio_desc</code>信息。<br> 2.2 获取<code>label</code>属性，<code>label</code>作为led的名字<br> 2.3 获取<code>“linux,default-trigger”</code>属性，可以通过此属性设置某个 LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br> 2.4 获取<code>“default-state”</code>属性值，也就是 LED 灯的默认状态属性<br> 2.5 <code>create_gpio_led </code>函数创建 LED 相关的 io，常用gpio操作，下面详细介绍</li>
</ol>
<h3><span id="3-1-1-create-gpio-led">3.1.1 create_gpio_led</span><a href="#3-1-1-create-gpio-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<ol>
<li>先获取<code>gpiod</code>信息</li>
<li>配置<code>led_dat</code>属性，包括<code>default_state, brightness</code>等信息</li>
<li>配置<code>gpio</code>方向</li>
<li>将led注册给LED子系统</li>
</ol>
<h3><span id="3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</span><a href="#3-1-2-kai-qi-guan-bi-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<h1><span id="4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</span><a href="#4-led-zi-xi-tong-ying-yong-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-dts-bian-xie">4.1 dts编写</span><a href="#4-1-dts-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建一个节点表示 LED 灯设备，比如<code> dtsleds</code>，如果板子上有多个 LED 灯的话每个 LED灯都作为 <code>dtsleds</code> 的子节点。</p>
<ol>
<li><code>dtsleds </code>节点的<code>compatible</code>属性值一定要为<code>“gpio-leds”</code>。</li>
<li>设置<code>label</code>属性，此属性为可选，每个子节点都有一个 label 属性，label 属性一般表示LED 灯的名字，比如以颜色区分的话就是 red、green 等等。</li>
<li>每个子节点必须要设置<code>gpios</code>属性值，表示此 LED 所使用的 GPIO 引脚！</li>
<li>可以设置<code>“linux,default-trigger”</code>属性值，也就是设置 LED 灯的默认功能，可以查阅<code>Documentation/devicetree/bindings/leds/common.txt </code>这个文档来查看可选功能，比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backlight：LED 灯作为背光。</span><br><span class="line"><span class="keyword">default</span>-on：LED 灯打开</span><br><span class="line">heartbeat：LED 灯作为心跳指示灯，可以作为系统运行提示灯。</span><br><span class="line">ide-disk：LED 灯作为硬盘活动指示灯。</span><br><span class="line">timer：LED 灯周期性闪烁，由定时器驱动，闪烁频率可以修改</span><br></pre></td></tr></table></figure></li>
<li>可以设置<code>“default-state”</code>属性值，可以设置为 on、off 或 keep，为 on 的时候 LED 灯默认打开，为 off 的话 LED 灯默认关闭，为 keep 的话 LED 灯保持当前模式</li>
</ol>
<p>启动开发板：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>进入到 leds 目录中：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //打开 <span class="title">LED0</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //关闭 <span class="title">LED0</span></span></span><br></pre></td></tr></table></figure>
<p>如果能正常的打开和关闭 LED 灯话就说明使用led子系统ok。</p>
<h2><span id="4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</span><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		linux,<span class="keyword">default</span>-trigger = <span class="string">&quot;heartbeat&quot;</span>;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置 LED0 为<code> heartbeat</code>。<br>第 8 行，默认打开 LED0。</p>
<h1><span id="5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</span><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong" class="header-anchor">#</a></h1><h2><span id="5-1-dian-liang-led">5.1 点亮 LED</span><a href="#5-1-dian-liang-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">255</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">max_brightness</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-shan-shuo">5.2 闪烁</span><a href="#5-2-shan-shuo" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">会看到 <span class="title">trigger_list</span></span></span><br><span class="line"><span class="class">[<span class="title">none</span>] <span class="title">mmc0</span> <span class="title">mmc1</span> <span class="title">mmc2</span> <span class="title">timer</span></span></span><br><span class="line"><span class="class">其中的 <span class="title">timer</span> 这个 <span class="title">trigger</span> 是 <span class="title">ledtrig</span>-<span class="title">timer</span>.<span class="title">c</span> 中模块初始化的时候注册进去的</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> <span class="title">timer</span> &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class">这一句会调用</span></span><br><span class="line"><span class="class"><span class="title">led_trigger_store</span>()-&gt;</span></span><br><span class="line">   led_trigger_set()-&gt;</span><br><span class="line">     trigger-&gt;activate(led_cdev);</span><br><span class="line">从而调用 ledtrig-timer.c 文件里 的timer_trig_activate()，</span><br><span class="line">在 /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/ 下创建 <span class="title">delay_on</span>、<span class="title">delay_off</span> 两个文件</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 100 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 200 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_off</span></span></span><br><span class="line"><span class="class">这样会闪烁，亮 100<span class="title">ms</span> 灭 200<span class="title">ms</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-3-guan-bi-led">5.3 关闭 LED</span><a href="#5-3-guan-bi-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class">或</span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0xxogec004sqsuf4bbx28z5" data-title="字符设备驱动-内核led子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.09px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.73px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.64px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 15.45px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-IIO子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-regmap子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-UART子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-RTC子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>