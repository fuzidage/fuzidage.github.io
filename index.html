<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-input子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T12:02:38.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</a><ul>
<li><a href="#1-0-shu-ju-jie-gou">1.0 数据结构</a><ul>
<li><a href="#1-0-1-input-dev">1.0.1 input_dev</a></li>
</ul>
</li>
<li><a href="#1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</a><ul>
<li><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</a></li>
<li><a href="#1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</a><ul>
<li><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</a></li>
</ul>
</li>
<li><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</a></li>
<li><a href="#1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-input-zi-xi-tong-shi-li">2 input子系统示例</a><ul>
<li><a href="#2-1-ding-yi-input-dev">2.1 定义input_dev</a></li>
<li><a href="#2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</a></li>
<li><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</a></li>
<li><a href="#2-4-shi-fang-input-dev">2.4 释放input_dev</a></li>
</ul>
</li>
<li><a href="#3-app-ce-shi">3 APP测试</a></li>
<li><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</a><ul>
<li><a href="#4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</a><ul>
<li><a href="#4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</a><ul>
<li><a href="#4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</a></li>
<li><a href="#4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-ce-shi-yan-zheng">4.2 测试验证</a></li>
</ul>
</li>
<li><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</a><ul>
<li><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</a><ul>
<li><a href="#5-1-1-te-xing">5.1.1 特性</a></li>
<li><a href="#5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</a></li>
<li><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</a></li>
<li><a href="#5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</a></li>
</ul>
</li>
<li><a href="#5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</a><ul>
<li><a href="#5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</a><ul>
<li><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</a></li>
<li><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</a></li>
<li><a href="#5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</a></li>
<li><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</a></li>
</ul>
</li>
<li><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</a></li>
<li><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</a></li>
<li><a href="#5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</a><ul>
<li><a href="#5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-duo-dian-hong-mo-api">5.3 多点触摸API</a><ul>
<li><a href="#5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</a></li>
<li><a href="#5-3-2-input-mt-slot">5.3.2 input_mt_slot</a></li>
<li><a href="#5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</a></li>
<li><a href="#5-3-4-input-report-abs">5.3.4 input_report_abs</a></li>
<li><a href="#5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</a></li>
</ul>
</li>
<li><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</a><ul>
<li><a href="#5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</a><ul>
<li><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</a></li>
<li><a href="#5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</a></li>
</ul>
</li>
<li><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</a><ul>
<li><a href="#5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</a></li>
<li><a href="#5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</a></li>
<li><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</a></li>
</ul>
</li>
<li><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</a><ul>
<li><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</a></li>
</ul>
</li>
<li><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-input-zi-xi-tong-jie-shao">1 input 子系统介绍</span><a href="#1-input-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>按键、鼠标、键盘、触摸屏等都属于输入(<code>input</code>)设备，Linux 内核为此专门做了一个叫做 input子系统的框架来处理输入事件。<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>input 子系统分为 input 驱动层、input 核心层、input 事件处理层，最终给用户空间提供可访问的设备节点。<br>驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。<br>核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。<br>事件层：主要和用户空间进行交互。</p>
<h2><span id="1-0-shu-ju-jie-gou">1.0  数据结构</span><a href="#1-0-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-0-1-input-dev">1.0.1 input_dev</span><a href="#1-0-1-input-dev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">   <span class="number">2</span>:      <span class="type">const</span> <span class="type">char</span> *name;      <span class="comment">//设备名</span></span><br><span class="line">   <span class="number">3</span>:      <span class="type">const</span> <span class="type">char</span> *phys;     <span class="comment">// 设备在系统中路径</span></span><br><span class="line">   <span class="number">4</span>:      <span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">   <span class="number">5</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//与input_handler匹配用的id;</span></span><br><span class="line"></span><br><span class="line">   <span class="number">9</span>:      <span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">//设备所支持事件类型主要有EV_SYNC,EV_KEY,EV_REL,EV_ABS</span></span><br><span class="line">  <span class="number">10</span>:      <span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];<span class="comment">// 按键所对应的位图</span></span><br><span class="line">  <span class="number">11</span>:      <span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)];<span class="comment">//  相对坐标对应位图</span></span><br><span class="line">  <span class="number">12</span>:      <span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];<span class="comment">// 绝对坐标对应位图</span></span><br><span class="line">  <span class="number">13</span>:      <span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];<span class="comment">//支持其它事件</span></span><br><span class="line">  <span class="number">14</span>:      <span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];<span class="comment">//支持led事件</span></span><br><span class="line">  <span class="number">15</span>:      <span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">//支持声音事件</span></span><br><span class="line">  <span class="number">16</span>:      <span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];<span class="comment">//支持受力事件</span></span><br><span class="line">  <span class="number">17</span>:      <span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)];<span class="comment">//支持开关机事件</span></span><br><span class="line">  <span class="number">18</span>:   </span><br><span class="line">  <span class="number">19</span>:      <span class="type">unsigned</span> <span class="type">int</span> hint_events_per_packet;</span><br><span class="line">  <span class="number">21</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodemax;</span><br><span class="line">  <span class="number">22</span>:      <span class="type">unsigned</span> <span class="type">int</span> keycodesize;</span><br><span class="line">  <span class="number">23</span>:      <span class="type">void</span> *keycode;</span><br><span class="line">  <span class="number">24</span>:   </span><br><span class="line">  <span class="number">25</span>:      <span class="type">int</span> (*setkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">26</span>:                <span class="type">const</span> <span class="keyword">struct</span> input_keymap_entry *ke,</span><br><span class="line">  <span class="number">27</span>:                <span class="type">unsigned</span> <span class="type">int</span> *old_keycode);</span><br><span class="line">  <span class="number">28</span>:      <span class="type">int</span> (*getkeycode)(<span class="keyword">struct</span> input_dev *dev,</span><br><span class="line">  <span class="number">29</span>:                <span class="keyword">struct</span> input_keymap_entry *ke);</span><br><span class="line">  <span class="number">30</span>:   </span><br><span class="line">  <span class="number">31</span>:      <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span></span><br><span class="line">  <span class="number">33</span>:      <span class="type">unsigned</span> <span class="type">int</span> repeat_key;<span class="comment">//最近一次的按键值</span></span><br></pre></td></tr></table></figure>



<h2><span id="1-1-input-qu-dong-bian-xie-liu-cheng">1.1 input 驱动编写流程</span><a href="#1-1-input-qu-dong-bian-xie-liu-cheng" class="header-anchor">#</a></h2><h3><span id="1-1-0-input-lei-de-jian-li-he-proc-jian-li">1.1.0 input类的建立和proc建立</span><a href="#1-1-0-input-lei-de-jian-li-he-proc-jian-li" class="header-anchor">#</a></h3><p><code>drivers/input/input.c</code>就是input子系统的核心层，此文件里面有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> <span class="title">input_class</span> =</span> &#123;</span><br><span class="line">	.name = <span class="string">&quot;input&quot;</span>,</span><br><span class="line">	.devnode = input_devnode,</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">input_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = class_register(&amp;input_class);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register input_dev class\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = input_proc_init();</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> fail1;</span><br><span class="line"></span><br><span class="line">	err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">		INPUT_MAX_CHAR_DEVICES, <span class="string">&quot;input&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;unable to register char major %d&quot;</span>, INPUT_MAJOR);</span><br><span class="line">		<span class="keyword">goto</span> fail2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail2: input_proc_exit();</span><br><span class="line">fail1: class_unregister(&amp;input_class);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册一个 input 类，这样系统启动以后就会在&#x2F;sys&#x2F;class 目录下有一个 input 子目录:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>创建<code>proc/input</code>信息，申请主设备号为<code> INPUT_MAJOR, INPUT_MAJOR</code> 定义在 <code>include/uapi/linux/major.h</code>:<br><code>#define INPUT_MAJOR 13</code><br>因此，input 子系统的所有设备主设备号都为 <code>13</code>，我们在使用 input 子系统处理输入设备的时候就不需要去注册字符设备了，我们只需要向系统注册一个 <code>input_device </code>即可。</p>
<h3><span id="1-1-1-zhu-ce-input-dev">1.1.1 注册 input_dev</span><a href="#1-1-1-zhu-ce-input-dev" class="header-anchor">#</a></h3><p>使用 input 子系统的时候我们只需要注册一个 input 设备即可，<code>input_dev</code> 结构体表示<code> input设备</code>，此结构体定义在 <code>include/linux/input.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *phys;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *uniq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> evbit[BITS_TO_LONGS(EV_CNT)]; <span class="comment">/* 事件类型的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> keybit[BITS_TO_LONGS(KEY_CNT)]; <span class="comment">/* 按键值的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> relbit[BITS_TO_LONGS(REL_CNT)]; <span class="comment">/* 相对坐标的位图 */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> absbit[BITS_TO_LONGS(ABS_CNT)]; <span class="comment">/* 绝对坐标的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)]; <span class="comment">/* 杂项事件的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ledbit[BITS_TO_LONGS(LED_CNT)]; <span class="comment">/*LED 相关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];<span class="comment">/* sound 有关的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ffbit[BITS_TO_LONGS(FF_CNT)]; <span class="comment">/* 压力反馈的位图 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> swbit[BITS_TO_LONGS(SW_CNT)]; <span class="comment">/*开关状态的位图 */</span></span><br><span class="line">	.....</span><br><span class="line">	<span class="type">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>evbit </code>表示输入事件类型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SYN 0x00 <span class="comment">/* 同步事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_KEY 0x01 <span class="comment">/* 按键事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REL 0x02 <span class="comment">/* 相对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_ABS 0x03 <span class="comment">/* 绝对坐标事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_MSC 0x04 <span class="comment">/* 杂项(其他)事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SW 0x05 <span class="comment">/* 开关事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_LED 0x11 <span class="comment">/* LED */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_SND 0x12 <span class="comment">/* sound(声音) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_REP 0x14 <span class="comment">/* 重复事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF 0x15 <span class="comment">/* 压力事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_PWR 0x16 <span class="comment">/* 电源事件 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EV_FF_STATUS 0x17 <span class="comment">/* 压力状态事件 */</span></span></span><br></pre></td></tr></table></figure>

<p><code>evbit、keybit、relbit </code>等等都是存放不同事件对应的值。比如我们本章要使用按键事件，因此要用到 keybit，keybit 就是按键事件使用的位图，Linux 内核定义了很多按键值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_RESERVED 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_ESC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_1 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_2 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_3 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_4 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_6 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_7 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_8 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_9 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_0 11</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY39 0x2e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_TRIGGER_HAPPY40 0x2e7</span></span><br></pre></td></tr></table></figure>

<p>我们可以将开发板上的按键值设置为任意一个，比如就叫<code>KEY_0</code>。</p>
<p><strong>申请input内存：</strong><br><code>struct input_dev *input_allocate_device(void);</code></p>
<p><strong>释放input内存：</strong><br><code>void input_free_device(struct input_dev *dev);</code></p>
<p><strong>注册input设备：</strong><br><code>int input_register_device(struct input_dev *dev);</code></p>
<p><strong>注销input设备：</strong><br><code>void input_unregister_device(struct input_dev *dev);</code></p>
<h4><span id="1-1-1-1-input-dev-zhu-ce-guo-cheng">1.1.1.1 input_dev 注册过程</span><a href="#1-1-1-1-input-dev-zhu-ce-guo-cheng" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span> <span class="comment">/* input 结构体变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	inputdev = input_allocate_device(); <span class="comment">/* 申请 input_dev */</span></span><br><span class="line">	inputdev-&gt;name = <span class="string">&quot;test_inputdev&quot;</span>; <span class="comment">/* 设置 input_dev 名字 */</span></span><br><span class="line"></span><br><span class="line">	 <span class="comment">/*********第一种设置事件和事件值的方法***********/</span></span><br><span class="line">	 __set_bit(EV_KEY, inputdev-&gt;evbit); <span class="comment">/* 设置产生按键事件 */</span></span><br><span class="line">	 __set_bit(EV_REP, inputdev-&gt;evbit); <span class="comment">/* 重复事件 */</span></span><br><span class="line">	 __set_bit(KEY_0, inputdev-&gt;keybit); <span class="comment">/*设置产生哪些按键值 */</span></span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 </span><br><span class="line">	 <span class="comment">/*********第二种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |=</span><br><span class="line">	T_MASK(KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">/*********第三种设置事件和事件值的方法***********/</span></span><br><span class="line">	 keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) |</span><br><span class="line">	T_MASK(EV_REP);</span><br><span class="line">	 input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line">	 <span class="comment">/************************************************/</span></span><br><span class="line">	 input_register_device(inputdev);</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">xxx_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">	 input_unregister_device(inputdev); <span class="comment">/* 注销 input_dev */</span></span><br><span class="line">	 input_free_device(inputdev); <span class="comment">/* 删除 input_dev */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian">1.1.2 中断上报输入事件</span><a href="#1-1-2-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h3><p>当输入设备中断到来，我们需要上报input输入事件给linux内核的input核心层，比如按键：我们需要在按键中断处理函数，或者消抖定时器中断函数中将按键值上报给 Linux 内核，这样 Linux 内核才能获取到正确的输入值。<br>不同的事件，上报事件的 API 函数不一样:<br><strong>input_event:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_event</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	dev：需要上报的 input_dev。</span></span><br><span class="line"><span class="comment">	type: 上报的事件类型，比如 EV_KEY。</span></span><br><span class="line"><span class="comment">	code：事件码，也就是我们注册的按键值，比如 KEY_0、KEY_1 等等。</span></span><br><span class="line"><span class="comment">	value：事件值，比如 1 表示按键按下，0 表示按键松开。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>当然linux系统帮我们也封装了一层api去使用：<br><strong>input_report_key：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">input_report_key</span><span class="params">(<span class="keyword">struct</span> input_dev *dev,<span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">	input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的还有一些其他的事件上报函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">input_report_rel</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_abs</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_ff_status</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_report_switch</span><span class="params">(<span class="keyword">struct</span> input_dev *dev, <span class="type">unsigned</span> <span class="type">int</span> code, <span class="type">int</span> value)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_mt_sync</span><span class="params">(<span class="keyword">struct</span> input_dev *dev)</span></span><br></pre></td></tr></table></figure>
<p>我们上报事件以后还需要使用<code>input_sync</code>函数来告诉 Linux 内核 input 子系统上报结束，<code>input_sync </code>函数本质是上报一个同步事件:<br><code>void input_sync(struct input_dev *dev);</code><br>举个例子，按键中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用于按键消抖的定时器服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); <span class="comment">/* 读取 IO 值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123; <span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">1</span>); <span class="comment">/* 最后一个参数 1，按下 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 按键松开 */</span></span><br><span class="line">		input_report_key(inputdev, KEY_0, <span class="number">0</span>); <span class="comment">/* 最后一个参数 0，松开 */</span></span><br><span class="line">		input_sync(inputdev); <span class="comment">/* 同步事件 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3><span id="1-1-3-input-event-jie-gou-ti">1.1.3 input_event 结构体</span><a href="#1-1-3-input-event-jie-gou-ti" class="header-anchor">#</a></h3><p><code>include/uapi/linux/input.h</code> 文件中:<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p><code>type</code>：事件类型，比如 EV_KEY，表示此次事件为<code>按键事件</code>，此成员变量为 16 位。<br><code>code</code>：事件码，比如在 EV_KEY 事件中 code 就表示具体的<code>按键码</code>，如：<code>KEY_0、KEY_1</code>等等这些按键。此成员变量为 16 位。<br><code>value</code>：值，比如 EV_KEY 事件中 value 就是<code>按键值</code>，表示按键有没有被按下，如果为 1 的话说明按键按下，如果为 0 的话说明按键没有被按下或者按键松开了</p>
<p><code>input_envent </code>这个结构体非常重要,用户态的应用程序也是通过 <code>input_event </code>来获取到具体的输入事件或相关的值，比如按键值等。</p>
<h1><span id="2-input-zi-xi-tong-shi-li">2 input子系统示例</span><a href="#2-input-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>还是以之前的按键来举例，利用input子系统来做一个按键驱动程序：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_CNT		1			<span class="comment">/* 设备号个数 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYINPUT_NAME		<span class="string">&quot;keyinput&quot;</span>	<span class="comment">/* 名字 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY0VALUE			0X01		<span class="comment">/* KEY0按键值 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INVAKEY				0XFF		<span class="comment">/* 无效的按键值 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NUM				1			<span class="comment">/* 按键数量 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;								<span class="comment">/* gpio */</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号     */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;					<span class="comment">/* 按键对应的键值 */</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];							<span class="comment">/* 名字 */</span></span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler)(<span class="type">int</span>, <span class="type">void</span> *);	<span class="comment">/* 中断服务函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> <span class="title">irqkeydesc</span>[<span class="title">KEY_NUM</span>];</span>	<span class="comment">/* 按键描述数组 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> curkeynum;				<span class="comment">/* 当前的按键号 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">inputdev</span>;</span>		<span class="comment">/* input结构体 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> <span class="title">keyinputdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">key0_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)dev_id;</span><br><span class="line"></span><br><span class="line">	dev-&gt;curkeynum = <span class="number">0</span>;</span><br><span class="line">	dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="type">long</span>)dev_id;</span><br><span class="line">	mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">10</span>));	<span class="comment">/* 10ms定时 */</span></span><br><span class="line">	<span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> num;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_keydesc</span> *<span class="title">keydesc</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">keyinput_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> keyinput_dev *)arg;</span><br><span class="line"></span><br><span class="line">	num = dev-&gt;curkeynum;</span><br><span class="line">	keydesc = &amp;dev-&gt;irqkeydesc[num];</span><br><span class="line">	value = gpio_get_value(keydesc-&gt;gpio); 	<span class="comment">/* 读取IO值 */</span></span><br><span class="line">	<span class="keyword">if</span>(value == <span class="number">0</span>)&#123;<span class="comment">/* 按下按键 */</span></span><br><span class="line">		<span class="comment">/* 上报按键值 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 1);</span></span><br><span class="line">        <span class="comment">/* 最后一个参数表示按下还是松开，1为按下，0为松开 */</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">1</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">/* 按键松开 */</span></span><br><span class="line">		<span class="comment">//input_event(dev-&gt;inputdev, EV_KEY, keydesc-&gt;value, 0);</span></span><br><span class="line">		input_report_key(dev-&gt;inputdev, keydesc-&gt;value, <span class="number">0</span>);</span><br><span class="line">		input_sync(dev-&gt;inputdev);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">keyio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	keyinputdev.nd = of_find_node_by_path(<span class="string">&quot;/key&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (keyinputdev.nd== <span class="literal">NULL</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;key node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 提取GPIO */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		keyinputdev.irqkeydesc[i].gpio = of_get_named_gpio(keyinputdev.nd ,<span class="string">&quot;key-gpio&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (keyinputdev.irqkeydesc[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;can&#x27;t get key%d\r\n&quot;</span>, i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 初始化key所使用的IO，并且设置成中断模式 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(keyinputdev.irqkeydesc[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));	<span class="comment">/* 缓冲区清零 */</span></span><br><span class="line">		<span class="built_in">sprintf</span>(keyinputdev.irqkeydesc[i].name, <span class="string">&quot;KEY%d&quot;</span>, i);		<span class="comment">/* 组合名字 */</span></span><br><span class="line">		gpio_request(keyinputdev.irqkeydesc[i].gpio, name);</span><br><span class="line">		gpio_direction_input(keyinputdev.irqkeydesc[i].gpio);	</span><br><span class="line">		keyinputdev.irqkeydesc[i].irqnum = irq_of_parse_and_map(keyinputdev.nd, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 申请中断 */</span></span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">	keyinputdev.irqkeydesc[<span class="number">0</span>].value = KEY_0;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		ret = request_irq(keyinputdev.irqkeydesc[i].irqnum, keyinputdev.irqkeydesc[i].handler, </span><br><span class="line">		                 IRQF_TRIGGER_FALLING|IRQF_TRIGGER_RISING,</span><br><span class="line">                         keyinputdev.irqkeydesc[i].name, &amp;keyinputdev);</span><br><span class="line">		<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;irq %d request failed!\r\n&quot;</span>, keyinputdev.irqkeydesc[i].irqnum);</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 创建定时器 */</span></span><br><span class="line">	init_timer(&amp;keyinputdev.timer);</span><br><span class="line">	keyinputdev.timer.function = timer_function;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 申请input_dev */</span></span><br><span class="line">	keyinputdev.inputdev = input_allocate_device();</span><br><span class="line">	keyinputdev.inputdev-&gt;name = KEYINPUT_NAME;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些事件 */</span></span><br><span class="line">	__set_bit(EV_KEY, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 设置产生按键事件          */</span></span><br><span class="line">	__set_bit(EV_REP, keyinputdev.inputdev-&gt;evbit);	<span class="comment">/* 重复事件，比如按下去不放开，就会一直输出信息*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化input_dev，设置产生哪些按键 */</span></span><br><span class="line">	__set_bit(KEY_0, keyinputdev.inputdev-&gt;keybit);	</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	keyinputdev.inputdev-&gt;keybit[BIT_WORD(KEY_0)] |= BIT_MASK(KEY_0);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	keyinputdev.inputdev-&gt;evbit[<span class="number">0</span>] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);</span><br><span class="line">	input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册输入设备 */</span></span><br><span class="line">	ret = input_register_device(keyinputdev.inputdev);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		printk(<span class="string">&quot;register input device failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">keyinput_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	keyio_init();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">keyinput_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	del_timer_sync(&amp;keyinputdev.timer);	<span class="comment">/* 删除定时器 */</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++) &#123;</span><br><span class="line">		free_irq(keyinputdev.irqkeydesc[i].irqnum, &amp;keyinputdev);</span><br><span class="line">	&#125;</span><br><span class="line">	input_unregister_device(keyinputdev.inputdev);</span><br><span class="line">	input_free_device(keyinputdev.inputdev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(keyinput_init);</span><br><span class="line">module_exit(keyinput_exit);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-1-ding-yi-input-dev">2.1 定义input_dev</span><a href="#2-1-ding-yi-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h2><span id="2-2-chu-shi-hua-input-dev">2.2 初始话input_dev</span><a href="#2-2-chu-shi-hua-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<ol>
<li><code>input_allocate_device</code>分配内存</li>
<li>设置事件和事件值，<code>input_event</code>类型是<code>EV_KEY</code>,键值<code>KEY_0</code>,<code> evbit</code>为<code>EV_KEY | EV_REP</code></li>
<li>注册input设备</li>
</ol>
<h2><span id="2-3-zhong-duan-shang-bao-shu-ru-shi-jian">2.3 中断上报输入事件</span><a href="#2-3-zhong-duan-shang-bao-shu-ru-shi-jian" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h2><span id="2-4-shi-fang-input-dev">2.4 释放input_dev</span><a href="#2-4-shi-fang-input-dev" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<h1><span id="3-app-ce-shi">3 APP测试</span><a href="#3-app-ce-shi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">inputevent</span>;</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		err = read(fd, &amp;inputevent, <span class="keyword">sizeof</span>(inputevent));</span><br><span class="line">		<span class="keyword">if</span> (err &gt; <span class="number">0</span>) &#123; <span class="comment">/* 读取数据成功 */</span></span><br><span class="line">			<span class="keyword">switch</span> (inputevent.type) &#123;</span><br><span class="line">				<span class="keyword">case</span> EV_KEY:</span><br><span class="line">					<span class="keyword">if</span> (inputevent.code &lt; BTN_MISC) &#123; <span class="comment">/* 键盘键值 */</span></span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;key %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;button %d %s\r\n&quot;</span>, inputevent.code,</span><br><span class="line">                               inputevent.value ? <span class="string">&quot;press&quot;</span> : <span class="string">&quot;release&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">/* 其他类型的事件，自行处理 */</span></span><br><span class="line">				<span class="keyword">case</span> EV_REL:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> EV_ABS:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;读取数据失败\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们向 Linux 内核成功注册 input_dev 设备以后，会在<code>/dev/input </code>目录下生成一个名为<code>“eventX(X=0….n)”</code>的文件，这个<code>/dev/input/eventX </code>就是对应的 input 设备文件。</p>
<p>测试：<br>在加载<code>keyinput.ko</code>驱动模块之前，先看一下<code>/dev/input </code>目录下都有哪些文件：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br><code>modprobe keyinput.ko</code> 可以看到多一个<code>input1</code>,就是我们刚创建的设备节点：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"><br>运行app:<br><code>./keyinputApp /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>可以看出，当我们按下或者释放开发板上的按键以后都会在终端上输出相应的内容，提示我们哪个按键按下或释放了，在 Linux 内核中 <code>KEY_0</code> 为 <code>11</code>。<br>另外，我们也可以不用<code>keyinputApp</code>来测试驱动，可以直接使用<code>hexdump</code>命令来查看<code>/dev/input/event1 </code>文件内容，输入如下命令：<br><code>hexdump /dev/input/event1</code><br>这就是<code>input_event</code> 类型的原始事件数据值：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>含义如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"><br><code>type </code>为事件类型，<code>EV_KEY </code>事件值为 1，<code>EV_SYN </code>事件值为0。因此第 1 行表示 <code>EV_KEY </code>事件，第 2 行表示 <code>EV_SYN </code>事件。code 为事件编码，也就是按键号，<code>KEY_0</code> 这个按键编号为 11，对应的十六进制为 <code>0xb</code>，因此第1 行表示 <code>KEY_0 </code>这个按键事件，最后的 value 就是按键值，为 1 表示按下，为 0 的话表示松开。<br>综上所述，上述原始事件值含义如下：<br>第 1 行，按键<code>(KEY_0)</code>按下事件。<br>第 2 行，<code>EV_SYN</code> 同步事件，因为每次上报按键事件以后都要同步的上报一个 <code>EV_SYN</code> 事件。<br>第 3 行，按键<code>(KEY_0)</code>松开事件。<br>第 4 行，<code>EV_SYN </code>同步事件，和第 2 行一样。</p>
<h1><span id="4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong">4 Linux input子系统补充-Linux 自带按键驱动</span><a href="#4-linux-input-zi-xi-tong-bu-chong-linux-zi-dai-an-jian-qu-dong" class="header-anchor">#</a></h1><p>Linux 内核也自带了 KEY 驱动，如果要使用内核自带的 KEY 驱动的话需要配置 Linux 内核，不过 Linux 内核一般默认已经使能了 KEY 驱动。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; Input device support</span><br><span class="line">		-&gt; Generic input <span class="title function_">layer</span> <span class="params">(needed <span class="keyword">for</span> keyboard, mouse, ...)</span> <span class="params">(INPUT [=y])</span></span><br><span class="line">			-&gt; <span class="title function_">Keyboards</span> <span class="params">(INPUT_KEYBOARD [=y])</span></span><br><span class="line">				-&gt;GPIO Buttons</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<p>选中以后就会在<code>.config</code> 文件中出现<code>“CONFIG_KEYBOARD_GPIO=y”</code>这一行，Linux 内核<br>就会根据这一行来将 KEY 驱动文件编译进 Linux 内核。Linux 内核自带的 KEY 驱动文件为<br><code>drivers/input/keyboard/gpio_keys.c</code>，<code>gpio_keys.c </code>采用了 platform 驱动框架，在 KEY 驱动上使用<br>了 input 子系统实现。</p>
<h2><span id="4-1-gpio-keys-yuan-ma-fen-xi">4.1 gpio_keys源码分析</span><a href="#4-1-gpio-keys-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>要使用 Linux 内 核 自 带 的 按 键 驱 动 程 序 很 简 单 ， 只 需 要 根 据<code>Documentation/devicetree/bindings/input/gpio-keys.txt </code>这个文件在设备树中添加指定的设备节点即可，节点要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">①、节点名字为“gpio-keys”。</span><br><span class="line">②、gpio-keys 节点的 compatible 属性值一定要设置为“gpio-keys”。</span><br><span class="line">③、所有的 KEY 都是 gpio-keys 的子节点，每个子节点可以用如下属性描述自己：</span><br><span class="line">	gpios：KEY 所连接的 GPIO 信息。</span><br><span class="line">	interrupts：KEY 所使用 GPIO 中断信息，不是必须的，可以不写。</span><br><span class="line">	label：KEY 名字</span><br><span class="line">	linux,code：KEY 要模拟的按键，也就是示例代码</span><br><span class="line">④、如果按键要支持连按的话要加入 autorepeat。</span><br></pre></td></tr></table></figure>
<p>打开<code> imx6ull-alientek-emmc.dts</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gpio-keys &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-keys&quot;</span>;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line">	autorepeat;</span><br><span class="line">	key0 &#123;</span><br><span class="line">		label = <span class="string">&quot;GPIO Key Enter&quot;</span>;</span><br><span class="line">		linux,code = &lt;KEY_ENTER&gt;;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ALPHA 开发板 KEY 按键信息，名字设置为<code>“GPIO Key Enter”</code>，这里我们将开发板上的 KEY 按键设置为<code>“EKY_ENTER”</code>这个按键，也就是回车键，效果和键盘上的回车键一样。</p>
<h3><span id="4-1-1-gpio-keys-probe-fen-xi">4.1.1 gpio_keys_probe分析</span><a href="#4-1-1-gpio-keys-probe-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br>可以看到就是对<code>input</code>子系统的调用封装，实例化了一个利用input子系统写的驱动程序。<br>调用<code> gpio_keys_get_devtree_pdata</code> 函数从设备树中获取到 KEY 相关的设备节点信息。<br>使用 <code>devm_input_allocate_device</code> 函数申请 input_dev。<br>初始化<code> input_dev</code>。<br>设置<code> input_dev 事件</code>，这里设置了<code> EV_REP</code> 事件.<br><strong>调用 <code>gpio_keys_setup_key</code> 函数继续设置 KEY，此函数会设置 input_dev 的EV_KEY 事件已经事件码(也就是 KEY 模拟为哪个按键)</strong><br>调用 <code>input_register_device</code> 函数向 Linux 系统注册<code> input_dev</code>。</p>
<h4><span id="4-1-1-1-gpio-keys-setup-key">4.1.1.1 gpio_keys_setup_key</span><a href="#4-1-1-1-gpio-keys-setup-key" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p>调用<code> input_set_capability</code> 函数设置<code> EV_KEY</code> 事件以及 KEY 的按键类型，也就是 KEY 作为哪个按键？我们会在设备树里面设置指定的 KEY 作为哪个按键.</p>
<h4><span id="4-1-1-2-gpio-keys-irq-isr">4.1.1.2 gpio_keys_irq_isr</span><a href="#4-1-1-2-gpio-keys-irq-isr" class="header-anchor">#</a></h4><p>当dts对应的按键按下后，中断进行响应，函数如下：<br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"><br>可以看到同理还是调用input_event， input_sync进行上报事件。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image-20240825144156414"></p>
<h2><span id="4-2-ce-shi-yan-zheng">4.2 测试验证</span><a href="#4-2-ce-shi-yan-zheng" class="header-anchor">#</a></h2><p>烧录新的dtb和kernel进去，可以看出存在 event1 这个文件，这个文件就是 KEY 对应的设备文件，使用<br>hexdump 命令来查看<code>/dev/input/event1 </code>文件：<br><code>hexdump /dev/input/event1</code><br><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image"><br>大家如果发现按下 KEY 按键以后没有反应，那么请检查一下三方面：<br>①、是否使能 Linux 内核 KEY 驱动。<br>②、设备树中 <code>gpio-keys</code> 节点是否创建成功。<br>③、在设备树中是否有其他外设也使用了 KEY 按键对应的 GPIO，但是我们并没有删除掉这些外设信息。检查 Linux 启动 log 信息，看看是否有类似下面这条信息:<br><code>gpio-keys gpio_keys：Failed to request GPIO 18, error -16</code></p>
<h1><span id="5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong">5 Linux input子系统-电容触摸屏应用</span><a href="#5-linux-input-zi-xi-tong-dian-rong-hong-mo-ping-ying-yong" class="header-anchor">#</a></h1><h2><span id="5-1-ft5426-dian-rong-hong-mo-ping-jian-jie">5.1 FT5426电容触摸屏简介</span><a href="#5-1-ft5426-dian-rong-hong-mo-ping-jian-jie" class="header-anchor">#</a></h2><h3><span id="5-1-1-te-xing">5.1.1 特性</span><a href="#5-1-1-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image"></p>
<p>特性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 自动模式切换。</span><br><span class="line"><span class="number">2.</span> <span class="number">100</span>hz采样率</span><br><span class="line"><span class="number">3.</span> 自动校准</span><br><span class="line"><span class="number">4.</span> i2c接口，速率高达<span class="number">400</span>k</span><br><span class="line"><span class="number">5.</span> <span class="number">12</span>位ADC精度转换</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"></p>
<p>触摸 IC 提供了中断信号引脚(INT)，可以通过中断来获取触摸信息。电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。</p>
<h3><span id="5-1-2-i2c-chuan-shu-ge-shi">5.1.2 i2c传输格式</span><a href="#5-1-2-i2c-chuan-shu-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/23.1.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"></p>
<p>可以看到slave addr是7位，第8位表示方向。数据是每次传输1byte。</p>
<h3><span id="5-1-3-shang-dian-ji-fu-wei-shi-xu">5.1.3 上电及复位时序</span><a href="#5-1-3-shang-dian-ji-fu-wei-shi-xu" class="header-anchor">#</a></h3><p><a name="power_on_sequence"></a></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-1-4-ji-cun-qi-miao-shu">5.1.4 寄存器描述</span><a href="#5-1-4-ji-cun-qi-miao-shu" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"></p>
<h2><span id="5-2-duo-dian-hong-mo-mt-xie-yi">5.2 多点触摸(MT)协议</span><a href="#5-2-duo-dian-hong-mo-mt-xie-yi" class="header-anchor">#</a></h2><p>多点电容触摸屏协议，文档路径为：<code>Documentation/input/multitouch-protocol.txt。</code></p>
<p>老版本的 2.x 版本 linux 内核是不支持多点电容触摸的(<code>Multi-touch，简称 MT</code>)，MT 协议是后面加入 的。</p>
<p>MT 协议被分为两种类型，<code>Type A</code> 和 <code>TypeB</code>，这两种类型的区别如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据(此类型在实际使用中非常少)。</span><br><span class="line">Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备通过 slot 更新某一个 触摸点的信息，FT5426 就属于此类型，一般的多点电容触摸屏 IC 都有此能力。</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-1-abs-mt-shi-jian">5.2.1 ABS_MT 事件</span><a href="#5-2-1-abs-mt-shi-jian" class="header-anchor">#</a></h3><p>ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 <code>include/uapi/linux/input.h</code> 中,  上报给 linux 内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_SLOT 0x2f <span class="comment">/* MT slot being modified */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MAJOR 0x30 <span class="comment">/* Major axis of touching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOUCH_MINOR 0x31 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MAJOR 0x32 <span class="comment">/* Major axis of approaching ellipse */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_WIDTH_MINOR 0x33 <span class="comment">/* Minor axis (omit if circular) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_ORIENTATION 0x34 <span class="comment">/* Ellipse orientation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_X 0x35 <span class="comment">/* Center X touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_POSITION_Y 0x36 <span class="comment">/* Center Y touch position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_TYPE 0x37 <span class="comment">/* Type of touching device */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_BLOB_ID 0x38 <span class="comment">/* Group a set of packets as a blob */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TRACKING_ID 0x39 <span class="comment">/* Unique ID of initiated contact */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_PRESSURE 0x3a <span class="comment">/* Pressure on contact area */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_DISTANCE 0x3b <span class="comment">/* Contact hover distance */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_X 0x3c <span class="comment">/* Center X tool position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ABS_MT_TOOL_Y 0x3d <span class="comment">/* Center Y tool position */</span></span></span><br></pre></td></tr></table></figure>

<p><code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>用来上 报触摸 点的 (X,Y) 坐标 信息。<code>ABS_MT_SLOT </code>用来上 报触摸点 ID ， 对 于 Type B 类型的设备，需要用到 <code>ABS_MT_TRACKING_ID </code>事件来区分触摸点。</p>
<h4><span id="5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian">5.2.1.1 input_mt_sync-隔离typeA类的不同触摸点</span><a href="#5-2-1-1-input-mt-sync-ge-chi-typea-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code> Type A</code> 类型的设备，通过<code> input_mt_sync()</code>函数来隔离不同的触摸点数据信息。<code>nput_mt_sync() </code>函数会触发 <code>SYN_MT_REPORT </code>事件，此事件会通知接收者获取当前触摸数据，并且准备接收 下一个触摸点数据。</p>
<p><code>void input_mt_sync(struct input_dev *dev);</code></p>
<h4><span id="5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian">5.2.1.2 input_mt_slot-区分typeB类的不同触摸点</span><a href="#5-2-1-2-input-mt-slot-qu-fen-typeb-lei-de-bu-tong-hong-mo-dian" class="header-anchor">#</a></h4><p>对于<code>Type B</code>类型的设备，上报触摸点信息的时候需要通过<code> input_mt_slot()</code>函数区分是哪一 个触摸点。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>第一个参数是 input_dev 设备，第二个参数 slot 用于指定当前上报的是 哪个触摸点信息。<code>input_mt_slot()</code>函数会触发 <code>ABS_MT_SLOT </code>事件，此事件会告诉接收者当前 正在更新的是哪个触摸点(slot)的数据。</p>
<h4><span id="5-2-1-3-input-sync-jie-shu-shang-bao">5.2.1.3 input_sync-结束上报</span><a href="#5-2-1-3-input-sync-jie-shu-shang-bao" class="header-anchor">#</a></h4><p>不管是哪个类型的设备，最终都要调用<code> input_sync()</code>函数来标识多点触摸信息传输完成，告 诉接收者处理之前累计的所有消息，并且准备好下一次接收。</p>
<p>可以通过 slot 的 <code>ABS_MT_TRACKING_ID </code>来新增、替换或删除触摸点。一个非负数 的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个 新加的触摸点，一个 ID 如果再也不存在了就表示删除了。上报 <code>SYN_REPORT </code>事件。</p>
<h4><span id="5-2-1-4-input-report-abs-shang-bao-zuo-biao">5.2.1.4 input_report_abs-上报坐标</span><a href="#5-2-1-4-input-report-abs-shang-bao-zuo-biao" class="header-anchor">#</a></h4><p>上报触摸屏原始数据。</p>
<p><code>void input_report_abs(struct input_dev *dev, unsigned int code, int value);</code></p>
<h3><span id="5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.2 Type A 触摸点信息上报流程</span><a href="#5-2-2-type-a-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第一个触摸点的 X 坐标数据，通过input_report_abs 函数实现，下面同理</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>]<span class="comment">//上报第一个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件，通过调用 input_mt_sync 函数来实现。</span></span><br><span class="line"></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>]<span class="comment">//通过 ABS_MT_POSITION_X 事件上报第二个触摸点的 X 坐标数据</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>]<span class="comment">//上报第二个触摸点的 Y 坐标数据</span></span><br><span class="line">SYN_MT_REPORT <span class="comment">//上报 SYN_MT_REPORT 事件,通知接收者获取坐标</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核里面也有<code> Type A</code> 类型的多点触摸驱动，如<code> st2332.c</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image-20240825151728439"></p>
<h3><span id="5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng">5.2.3 Type B 触摸点信息上报流程</span><a href="#5-2-3-type-b-hong-mo-dian-xin-xi-shang-bao-liu-cheng" class="header-anchor">#</a></h3><p>对于<code>Type B</code>类型的设备，发送触摸点信息的时序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT <span class="number">0</span> <span class="comment">/* 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line"><span class="comment">    每次上报一个触摸点坐标之前要先使用input_mt_slot函数上报当前触摸点SLOT，触摸点的SLOT其实就是触摸点ID，需要由触摸 IC 提供</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">45</span> <span class="comment">/*根据 Type B 的要求，每个 SLOT 必须关联一个 ABS_MT_TRACKING_ID，通过</span></span><br><span class="line"><span class="comment">	修改 SLOT 关联的 ABS_MT_TRACKING_ID 来完成对触摸点的添加、替换或删除。具体用到</span></span><br><span class="line"><span class="comment">	的函数就是 input_mt_report_slot_state，如果是添加一个新的触摸点，那么此函数的第三个参数</span></span><br><span class="line"><span class="comment">	active 要设置为 true，linux 内核会自动分配一个 ABS_MT_TRACKING_ID 值，不需要用户去指</span></span><br><span class="line"><span class="comment">	定具体的 ABS_MT_TRACKING_ID 值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 X 轴坐标，使用函数 input_report_abs 来完成</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">0</span>] <span class="comment">//上报触摸点 0 的 y 轴坐标</span></span><br><span class="line"></span><br><span class="line">ABS_MT_SLOT <span class="number">1</span> <span class="comment">//同理， 上报 ABS_MT_SLOT 事件。</span></span><br><span class="line">ABS_MT_TRACKING_ID <span class="number">46</span></span><br><span class="line">ABS_MT_POSITION_X x[<span class="number">1</span>] <span class="comment">//坐标1的x</span></span><br><span class="line">ABS_MT_POSITION_Y y[<span class="number">1</span>] <span class="comment">//坐标1的y</span></span><br><span class="line">SYN_REPORT <span class="comment">//最后，上报 SYN_REPORT 事件，通过调用 input_sync 函数实现。</span></span><br></pre></td></tr></table></figure>

<p>当一个触摸点移除以后，同样需要通过 SLOT 关联的<code>ABS_MT_TRACKING_ID</code>来处理:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_TRACKING_ID <span class="number">-1</span> <span class="comment">/*当一个触摸点(SLOT)移除以后，需要通过 ABS_MT_TRACKING_ID 事件发送一</span></span><br><span class="line"><span class="comment">个-1 给内核。方法很简单，同样使用 input_mt_report_slot_state 函数来完成，只需要将此函数的</span></span><br><span class="line"><span class="comment">第三个参数 active 设置为 false 即可，不需要用户手动去设置-1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure>

<p>Linux 内核里面有大量的 <code>Type B</code> 类型的多点触摸驱动程序,<code>drivers/input/touchscreen/ili210x.c </code>上报示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ili210x_report_events</span><span class="params">(<span class="keyword">struct</span> input_dev *input, <span class="type">const</span> <span class="keyword">struct</span> touchdata *touchdata)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">bool</span> touch;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">finger</span> *<span class="title">finger</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_TOUCHES; i++) &#123;</span><br><span class="line">		input_mt_slot(input, i);<span class="comment">//上报ABS_MT_SLOT事件</span></span><br><span class="line">		finger = &amp;touchdata-&gt;finger[i];</span><br><span class="line">		touch = touchdata-&gt;status &amp; (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="comment">//上报ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件</span></span><br><span class="line">		input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);</span><br><span class="line">		<span class="keyword">if</span> (touch) &#123;</span><br><span class="line">			x = finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			y = finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; <span class="number">8</span>);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_X, x);</span><br><span class="line">			input_report_abs(input, ABS_MT_POSITION_Y, y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	input_mt_report_pointer_emulation(input, <span class="literal">false</span>);</span><br><span class="line">	input_sync(input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-4-abs-mt-qi-ta-shi-jian">5.2.4 ABS_MT其他事件</span><a href="#5-2-4-abs-mt-qi-ta-shi-jian" class="header-anchor">#</a></h3><p>如果设备支持的话，还可以使用 <code>ABS_MT_TOUCH_MAJOR</code> 和 <code>ABS_MT_WIDTH_MAJOR</code> 这两个消息上报触摸面积信息，关于 其他 ABS_MT 事件的具体含义大家可以查看 Linux 内核中的 <code>multi-touch-protocol.txt</code> 文档。</p>
<h4><span id="5-2-4-1-abs-mt-tool-type">5.2.4.1 ABS_MT_TOOL_TYPE</span><a href="#5-2-4-1-abs-mt-tool-type" class="header-anchor">#</a></h4><p>上报触摸工具类型。</p>
<p>很多内核驱动都不能区分出触摸设备类型 ，是手指还是触摸 笔？ 这种情况下， 这个事件可以忽略掉 。目前的协议支持 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MT_TOOL_FINGER(手指)</span><br><span class="line">MT_TOOL_PEN(笔)</span><br><span class="line">MT_TOOL_PALM(手掌)这三种触摸设备类型</span><br></pre></td></tr></table></figure>

<p>要 上 报 ABS_MT_TOOL_TYPE 事件，那么可以使用<code> input_mt_report_slot_state</code> 函数来完成此工作。</p>
<h2><span id="5-3-duo-dian-hong-mo-api">5.3 多点触摸API</span><a href="#5-3-duo-dian-hong-mo-api" class="header-anchor">#</a></h2><h3><span id="5-3-1-input-mt-init-slots">5.3.1 input_mt_init_slots</span><a href="#5-3-1-input-mt-init-slots" class="header-anchor">#</a></h3><p>初始化 MT 的输入 slots槽，<code>drivers/input/input-mt.c</code>。</p>
<p><code>int input_mt_init_slots( struct input_dev *dev, unsigned int num_slots, unsigned int flags);</code></p>
<p>num_slots: 要使用的 SLOT 数量，也就是触摸点的数量。</p>
<p>flags：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_POINTER 0x0001 <span class="comment">/* pointer device, e.g. trackpad */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DIRECT 0x0002 <span class="comment">/* direct device, e.g. touchscreen */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_DROP_UNUSED0x0004 <span class="comment">/* drop contacts not seen in frame */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_TRACK 0x0008 <span class="comment">/* use in-kernel tracking */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_MT_SEMI_MT 0x0010 <span class="comment">/* semi-mt device, finger count handled manually */</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="5-3-2-input-mt-slot">5.3.2 input_mt_slot</span><a href="#5-3-2-input-mt-slot" class="header-anchor">#</a></h3><p> Type B类型，此函数用于产生 <code>ABS_MT_SLOT </code>事件，告诉内核当前上报的是哪个触摸点的坐标数据，定义在文件<code> include/linux/input/mt.h</code>。</p>
<p><code>void input_mt_slot(struct input_dev *dev, int slot);</code></p>
<p>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。</p>
<h3><span id="5-3-3-input-mt-report-slot-state">5.3.3 input_mt_report_slot_state</span><a href="#5-3-3-input-mt-report-slot-state" class="header-anchor">#</a></h3><p>Type B类型，用于产生<code>ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE </code>事件 ，<code>ABS_MT_TRACKING_ID</code>事件给slot关联一个<code>ABS_MT_TRACKING_ID </code>，<code> ABS_MT_TOOL_TYPE</code>事件指定触摸类型（是笔还是手指等 ）。此函数定义在文件<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_slot_state( struct input_dev *dev, unsigned int tool_type, bool active);</code></p>
<p>tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或 MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。 </p>
<p>active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给 slot。 false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸 点溢出。</p>
<h3><span id="5-3-4-input-report-abs">5.3.4 input_report_abs</span><a href="#5-3-4-input-report-abs" class="header-anchor">#</a></h3><p>上报<code>ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y </code>事件，上报坐标。include&#x2F;linux&#x2F;input.h。</p>
<p><code>void input_report_abs( struct input_dev *dev, unsigned int code, int value);</code></p>
<p><code>code</code>：要上报的是什么数据，设置为<code> ABS_MT_POSITION_X</code> 或 <code>ABS_MT_POSITION_Y</code></p>
<p><code>value</code>：具体的 X 轴或 Y 轴坐标数据值。</p>
<h3><span id="5-3-5-input-mt-report-pointer-emulation">5.3.5 input_mt_report_pointer_emulation</span><a href="#5-3-5-input-mt-report-pointer-emulation" class="header-anchor">#</a></h3><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 <code>BTN_TOOL_TAP</code> 事件来通 知用户空间当前追踪到的触摸点总数量，然后调用<code>input_mt_report_pointer_emulation</code>函数将 <code>use_count</code> 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)，<code>drivers/input/input-mt.c</code></p>
<p><code>void input_mt_report_pointer_emulation(struct input_dev *dev, bool use_count);</code></p>
<p><code>use_count</code>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量.</p>
<h2><span id="5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426">5.4 Linux触摸屏驱动示例-FT5426</span><a href="#5-4-linux-hong-mo-ping-qu-dong-shi-li-ft5426" class="header-anchor">#</a></h2><h3><span id="5-4-1-she-bei-shu-tian-jia">5.4.1 设备树添加</span><a href="#5-4-1-she-bei-shu-tian-jia" class="header-anchor">#</a></h3><h4><span id="5-4-1-1-iomux-yin-jiao-pei-zhi">5.4.1.1 iomux引脚配置</span><a href="#5-4-1-1-iomux-yin-jiao-pei-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_tsc: tscgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 <span class="number">0xF080</span> <span class="comment">/* TSC_INT */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">pinctrl_tsc_reset: tsc_reset &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 <span class="number">0x10B0</span> <span class="comment">/* TSC_RST */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;</span><br><span class="line">pinctrl_i2c2: i2c2grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART5_TX_DATA__I2C2_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART5_RX_DATA__I2C2_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>触摸屏要用到4个IO, i2c 2个引脚和1个<code>RST</code>, 1个<code>INT</code>引脚。</p>
<h4><span id="5-4-1-2-ft5426-jie-dian">5.4.1.2 ft5426节点</span><a href="#5-4-1-2-ft5426-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c2 &#123;</span><br><span class="line">	clock_frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c2&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	......</span><br><span class="line">	ft5426: ft5426@<span class="number">38</span> &#123;</span><br><span class="line">		compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x38</span>&gt;;</span><br><span class="line">		pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">		pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_tsc</span><br><span class="line">			&amp;pinctrl_tsc_reset&gt;;</span><br><span class="line">		interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">		interrupts = &lt;<span class="number">9</span> <span class="number">0</span>&gt;;</span><br><span class="line">		reset-gpios = &lt;&amp;gpio5 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		interrupt-gpios = &lt;&amp;gpio1 <span class="number">9</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>找到<code>i2c2</code>节点，引用<code>pinctrl_i2c2</code>，设置好I2c的iomux。设置时钟100k, status开启okay。</p>
<p>添加子节点<code>ft5426</code>，器件地址为 <code>0X38</code>，引用<code>pinctrl_tsc</code>， <code>pinctrl_tsc_reset</code>设置<code>rst</code>和<code>int</code>引脚的iomux。</p>
<p><code>interrupt-parent</code> 属性描述中断 IO 对应的 GPIO 组为<code> GPIO1</code>。</p>
<p><code>interrupts</code> 属性描述中断 IO 对应的是 GPIO1 组的<code> IOI09</code>。</p>
<p><code>reset-gpios </code>属性描述复位 IO 对应的 GPIO 为 <code>GPIO5_IO09</code>。</p>
<p><code>interrupt-gpios </code>属性描述中断 IO 对应的 GPIO 为 <code>GPIO1_IO09</code>。</p>
<h3><span id="5-4-2-ft5426-qu-dong-yuan-ma-jie-xi">5.4.2 FT5426驱动源码解析</span><a href="#5-4-2-ft5426-qu-dong-yuan-ma-jie-xi" class="header-anchor">#</a></h3><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ft5x06.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ratelimit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/debugfs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/mt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input/edt-ft5x06.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SUPPORT_POINTS		5			<span class="comment">/* 5点触摸 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_DOWN		0x00		<span class="comment">/* 按下 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_UP			0x01		<span class="comment">/* 抬起 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_ON			0x02		<span class="comment">/* 接触 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOUCH_EVENT_RESERVED	0x03		<span class="comment">/* 保留 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* FT5X06寄存器相关宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_TD_STATUS_REG	0X02		<span class="comment">/*	状态寄存器地址 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5x06_DEVICE_MODE_REG	0X00 		<span class="comment">/* 模式寄存器 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5426_IDG_MODE_REG		0XA4		<span class="comment">/* 中断模式				*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FT5X06_READLEN			29			<span class="comment">/* 要读取的寄存器个数 	*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> 				<span class="comment">/* 设备节点 		*/</span></span><br><span class="line">	<span class="type">int</span> irq_pin,reset_pin;					<span class="comment">/* 中断和复位IO		*/</span></span><br><span class="line">	<span class="type">int</span> irqnum;								<span class="comment">/* 中断号    		*/</span></span><br><span class="line">	<span class="type">void</span> *private_data;						<span class="comment">/* 私有数据 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input</span>;</span>				<span class="comment">/* input结构体 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span>;</span>				<span class="comment">/* I2C客户端 		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> <span class="title">ft5x06</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_reset</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;reset_pin)) &#123;</span><br><span class="line">		<span class="comment">/* 申请复位IO，并且默认输出低电平 */</span></span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev,	</span><br><span class="line">					dev-&gt;reset_pin, GPIOF_OUT_INIT_LOW,</span><br><span class="line">					<span class="string">&quot;edt-ft5x06 reset&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">		msleep(<span class="number">5</span>);</span><br><span class="line">		gpio_set_value(dev-&gt;reset_pin, <span class="number">1</span>);<span class="comment">/* 输出高电平，停止复位 */</span></span><br><span class="line">		msleep(<span class="number">300</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_read_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;					<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;					<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;						<span class="comment">/* reg长度*/</span></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;			<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;			<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;					<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;					<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ft5x06_write_regs</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;client;</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ft5x06地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ft5x06_write_reg</span><span class="params">(<span class="keyword">struct</span> ft5x06_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ft5x06_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">ft5x06_handler</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ft5x06_dev</span> *<span class="title">multidata</span> =</span> dev_id;</span><br><span class="line"></span><br><span class="line">	u8 rdbuf[<span class="number">29</span>];</span><br><span class="line">	<span class="type">int</span> i, type, x, y, id;</span><br><span class="line">	<span class="type">int</span> offset, tplen;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">bool</span> down;</span><br><span class="line"></span><br><span class="line">	offset = <span class="number">1</span>; 	<span class="comment">/* 偏移1，也就是0X02+1=0x03,从0X03开始是触摸值 */</span></span><br><span class="line">	tplen = <span class="number">6</span>;		<span class="comment">/* 一个触摸点有6个寄存器来保存触摸值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(rdbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(rdbuf));		<span class="comment">/* 清除 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 读取FT5X06触摸点坐标从0X02寄存器开始，连续读取29个寄存器 */</span></span><br><span class="line">	ret = ft5x06_read_regs(multidata, FT5X06_TD_STATUS_REG, rdbuf, FT5X06_READLEN);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 上报每一个触摸点坐标 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_SUPPORT_POINTS; i++) &#123;</span><br><span class="line">		u8 *buf = &amp;rdbuf[i * tplen + offset];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_XH(地址0X03),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:6  Event flag  0:按下 1:释放 2：接触 3：没有事件</span></span><br><span class="line"><span class="comment">		 * bit5:4  保留</span></span><br><span class="line"><span class="comment">		 * bit3:0  X轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		type = buf[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>;     <span class="comment">/* 获取触摸类型 */</span></span><br><span class="line">		<span class="keyword">if</span> (type == TOUCH_EVENT_RESERVED)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* 我们所使用的触摸屏和FT5X06是反过来的 */</span></span><br><span class="line">		x = ((buf[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">3</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		y = ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]) &amp; <span class="number">0x0fff</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 以第一个触摸点为例，寄存器TOUCH1_YH(地址0X05),各位描述如下：</span></span><br><span class="line"><span class="comment">		 * bit7:4  Touch ID  触摸ID，表示是哪个触摸点</span></span><br><span class="line"><span class="comment">		 * bit3:0  Y轴触摸点的11~8位。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		id = (buf[<span class="number">2</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>;</span><br><span class="line">		down = type != TOUCH_EVENT_UP;</span><br><span class="line"></span><br><span class="line">		input_mt_slot(multidata-&gt;input, id);</span><br><span class="line">		input_mt_report_slot_state(multidata-&gt;input, MT_TOOL_FINGER, down);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!down)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">		input_report_abs(multidata-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input_mt_report_pointer_emulation(multidata-&gt;input, <span class="literal">true</span>);</span><br><span class="line">	input_sync(multidata-&gt;input);</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_irq</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="keyword">struct</span> ft5x06_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (gpio_is_valid(dev-&gt;irq_pin)) &#123;</span><br><span class="line">		ret = devm_gpio_request_one(&amp;client-&gt;dev, dev-&gt;irq_pin,</span><br><span class="line">					GPIOF_IN, <span class="string">&quot;edt-ft5x06 irq&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			dev_err(&amp;client-&gt;dev,</span><br><span class="line">				<span class="string">&quot;Failed to request GPIO %d, error %d\n&quot;</span>,</span><br><span class="line">				dev-&gt;irq_pin, ret);</span><br><span class="line">			<span class="keyword">return</span> ret;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, <span class="literal">NULL</span>,</span><br><span class="line">					ft5x06_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,</span><br><span class="line">					client-&gt;name, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;client-&gt;dev, <span class="string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ft5x06.client = client;</span><br><span class="line"></span><br><span class="line">	ft5x06.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;interrupt-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	ft5x06.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_reset(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = ft5x06_ts_irq(client, &amp;ft5x06);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4，初始化FT5X06 */</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5x06_DEVICE_MODE_REG, <span class="number">0</span>); 	<span class="comment">/* 进入正常模式 	*/</span></span><br><span class="line">	ft5x06_write_reg(&amp;ft5x06, FT5426_IDG_MODE_REG, <span class="number">1</span>); 		<span class="comment">/* FT5426中断模式	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5，input设备注册 */</span></span><br><span class="line">	ft5x06.input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (!ft5x06.input) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ft5x06.input-&gt;name = client-&gt;name;</span><br><span class="line">	ft5x06.input-&gt;id.bustype = BUS_I2C;</span><br><span class="line">	ft5x06.input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line">	__set_bit(EV_KEY, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(EV_ABS, ft5x06.input-&gt;evbit);</span><br><span class="line">	__set_bit(BTN_TOUCH, ft5x06.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_X, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_Y, <span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_X,<span class="number">0</span>, <span class="number">1024</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	input_set_abs_params(ft5x06.input, ABS_MT_POSITION_Y,<span class="number">0</span>, <span class="number">600</span>, <span class="number">0</span>, <span class="number">0</span>);	     </span><br><span class="line">	ret = input_mt_init_slots(ft5x06.input, MAX_SUPPORT_POINTS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = input_register_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ft5x06_ts_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span>&#123;</span><br><span class="line">	input_unregister_device(ft5x06.input);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ft5x06_ts_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5206&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="string">&quot;edt-ft5426&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ft5x06_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5206&quot;</span>, &#125;,</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;edt,edt-ft5426&quot;</span>, &#125;,</span><br><span class="line">	&#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ft5x06_ts_driver</span> =</span> &#123;</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.owner = THIS_MODULE,</span><br><span class="line">		.name = <span class="string">&quot;edt_ft5x06&quot;</span>,</span><br><span class="line">		.of_match_table = of_match_ptr(ft5x06_of_match),</span><br><span class="line">	&#125;,</span><br><span class="line">	.id_table = ft5x06_ts_id,</span><br><span class="line">	.probe    = ft5x06_ts_probe,</span><br><span class="line">	.remove   = ft5x06_ts_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ft5x06_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ft5x06_ts_driver);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ft5x06_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	i2c_del_driver(&amp;ft5x06_ts_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ft5x06_init);</span><br><span class="line">module_exit(ft5x06_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

</details>

<h4><span id="5-4-2-1-probe-guo-cheng">5.4.2.1 probe过程</span><a href="#5-4-2-1-probe-guo-cheng" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"></p>
<p>dts中的<code>compatible</code>和驱动匹配，<code>of_match_table</code>匹配，因此触发probe函数。可以看到FT5426使用的标准I2C从设备驱动框架<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a>。因为使用的I2c2。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<p>由于<code>i2c_client</code>描述i2c从设备的i2c相关硬件信息。 一个<code>i2c_driver</code>可以支持多个同类型的<code>i2c_client</code>。<code>i2c_client</code>一般描述在设备树中, 这里<code>对应i2c2的ft5426子节点</code>。</p>
<ol>
<li><p>当驱动和设备匹配，<code>ft5x06_ts_probe</code>执行。首先获取dts中的属性<code>reset-gpios</code>,<code>interrupt-gpios</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/31.1.png" alt="image"></p>
</li>
<li><p>对复位引脚进行复位。（参考<a href="#power_on_sequence">5.1.3上电复位时序</a>）</p>
</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<ol start="3">
<li>注册中断服务</li>
</ol>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/33.png" alt="image"></p>
<ol start="4">
<li><p>初始化ft5426内部寄存器</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/34.png" alt="image"></p>
</li>
<li><p>利用input子系统设置MT协议参数，并且注册input设备。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/35.png" alt="image"></p>
</li>
</ol>
<p>需要上报的事件为 <code>EV_KEY 和 EV_ABS</code>，需要上报的按键码为<code> BTN_TOUCH</code>(<code>BTN_TOUCH见include\uapi\linux\input-event-codes.h</code>)。<code>EV_KEY </code>是按键事件，用于上报触摸屏是否被按下，相当于把触摸屏当做一个按键。<code>EV_ABS </code>是触摸点坐标数据，<code>BTN_TOUCH </code>表示将触摸屏的按下和抬起用作 <code>BTN_TOUCH </code>按键。</p>
<p><code>input_set_abs_params </code>函数设置 EV_ABS 事件需要上报 <code>ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y</code>。单点触摸需要上报<code>ABS_X</code> 和<code> ABS_Y</code>，对于多点触摸需要上报 <code>ABS_MT_POSITION_X </code>和<code> ABS_MT_POSITION_Y</code>。</p>
<p><code>input_mt_init_slots</code> 函数初始 化 slots，也就是最大触摸点数量，FT5426 是个 5 点电容触摸芯片，因此一共 5 个 slot。</p>
<h4><span id="5-4-2-2-i2c-shu-ju-chuan-shu">5.4.2.2 I2C数据传输</span><a href="#5-4-2-2-i2c-shu-ju-chuan-shu" class="header-anchor">#</a></h4><p>其实就是i2c数据传输的应用。参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18183047">Linux I2C子系统驱动</a>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/36.png" alt="image"></p>
<p>读过程：</p>
<p>构造<code>i2c_msg[0]</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要读哪个寄存器地址。</p>
<p>构造<code>i2c_msg[1]</code>，flag&#x3D;1表示读，先发送i2c从设备器件地址0x38。然后传入要读的buf。</p>
<p>写过程：</p>
<p>构造<code>i2c_msg</code>，flag&#x3D;0表示写，先发送i2c从设备器件地址0x38。然后发送要写哪个寄存器地址和写入的内容。</p>
<h4><span id="5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao">5.4.2.3 中断触摸数据上报</span><a href="#5-4-2-3-zhong-duan-hong-mo-shu-ju-shang-bao" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/37.png" alt="image"></p>
<ol>
<li>通过<code>I2c_read</code>获取寄存器值。一共29个寄存器，读出29 byte。从0X02寄存器开始读。</li>
<li>for循环内部用来拆解坐标信息，上报每一个点的坐标。</li>
<li>最后调用<code>input_sync</code>上传上报<code>SYN_REPORT</code>事件。</li>
</ol>
<h3><span id="5-4-3-yong-hu-tai-ying-yong-ce-shi">5.4.3 用户态应用测试</span><a href="#5-4-3-yong-hu-tai-ying-yong-ce-shi" class="header-anchor">#</a></h3><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/38.png" alt="image"></p>
<p>驱动加载成功以后就会生成<code>/dev/input/eventX</code>(X&#x3D;1,2,3…)</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/39.png" alt="image"></p>
<h4><span id="5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi">5.4.3.1 触摸屏原始数据解析</span><a href="#5-4-3-1-hong-mo-ping-yuan-shi-shu-ju-jie-xi" class="header-anchor">#</a></h4><p><code>hexdump /dev/input/event2</code>可以查看原始数据。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/40.png" alt="image"></p>
<p>第1行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x2f</code>，为<code>ABS_MT_SLOT</code>，因此这一行就是<code>input_mt_slot</code>函数上报的<code>ABS_MT_SLOT</code>事件。value&#x3D;0，说明接下来上报的是第一个触摸点坐标。</p>
<p>第2行，type为0x3，说明是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，这一行就是<code>input_mt_report_slot_state</code>函数上报<code>ABS_MT_TRACKING_ID</code>事件。<code>value=5</code>说明给<code>SLOT0</code>分配的ID为5。</p>
<p>​		第3行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x35</code>，为<code>ABS_MT_POSITION_X</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_X</code>事件，也就是触摸点的X轴坐标。<code>value=0x03ec=1004</code>，说明触摸点X轴坐标为1004，属于屏幕右上角区域。</p>
<p>​		第4行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x36</code>，为<code>ABS_MT_POSITION_Y</code>，这一行就是<code>input_report_abs</code>函数上报的<code>ABS_MT_POSITION_Y</code>事件，也就是触摸点的Y轴坐标。<code>value=0x17=23</code>，说明Y轴坐标为23，由此可以看出本次触摸的坐标为(1004,23)，处于屏幕右上角区域。</p>
<p>​		第5行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x1</code>表示触摸屏被按下。</p>
<p>​		第6行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x0</code>，为<code>ABS_X</code>，用于单点触摸的时候上报X轴坐标。在这里和<code>ABS_MT_POSITION_X</code>相同，<code>value也为0x3f0=1008</code>。ABS_X是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>​		第7行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x1</code>，为<code>ABS_Y</code>，用于单点触摸的时候上报Y轴坐标。在这里和<code>ABS_MT_POSITION_Y</code>相同，<code>value也为0x17=23</code>。ABS_Y是由<code>input_mt_report_pointer_emulation</code>函数上报的。</p>
<p>第8行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>第9行，type为0x3，是一个<code>EV_ABS</code>事件，<code>code为0x39</code>，也就是<code>ABS_MT_TRACKING_ID</code>，<code>value=0xffffffff=-1</code>，说明触摸点离开了屏幕。</p>
<p>第10行，type为0x1，是一个<code>EV_KEY</code>事件，<code>code=0x14a</code>，为<code>BTN_TOUCH</code>，<code>value=0x0</code>表示手指离开触摸屏，也就是触摸屏没有被按下了。</p>
<p>第11行，type为0x0，是一个<code>EV_SYN</code>事件，由<code>input_sync</code>函数上报。</p>
<p>以上就是一个触摸点的坐标上报过程。</p>
<h2><span id="5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong">5.5 Linux内核自带的触摸驱动</span><a href="#5-5-linux-nei-he-zi-dai-de-hong-mo-qu-dong" class="header-anchor">#</a></h2><p>打开<code>driver/input/touchscreen/Makefile</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/41.png" alt="image"></p>
<p>linux内核默认已经帮我们实现了这款<code>edt-ft5x06.c</code>触摸屏驱动。此驱动文件不仅仅 能够驱动 <code>FT5426，FT5206、FT5406 </code>这些都可以驱动。</p>
<p><code>make menuconfig</code>,选中这款触摸屏即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Location:</span><br><span class="line"> -&gt; Device Drivers</span><br><span class="line"> 	-&gt; Input device support</span><br><span class="line"> 		-&gt; Generic input layer (needed <span class="keyword">for</span> keyboard, mouse, ...) (INPUT [=y])</span><br><span class="line">			-&gt; Touchscreens (INPUT_TOUCHSCREEN [=y])</span><br><span class="line">				-&gt; &lt;*&gt; EDT FocalTech FT5x06 I2C Touchscreen support</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/42.png" alt="image"></p>
<p>编译后开机如下打印：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/43.png" alt="image"></p>
<p>直接运行 ts_test_mt 来测试触摸屏是否可以使用。</p>
<h1><span id="6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi">6 IS_ENABLED-在驱动中判断某CONFIG是否定义</span><a href="#6-is-enabled-zai-qu-dong-zhong-pan-duan-mou-config-shi-fou-ding-yi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux/kconfig.h:<span class="number">73</span>:<span class="meta">#<span class="keyword">define</span> IS_ENABLED(option) __or(IS_BUILTIN(option), IS_MODULE(option))</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm09fgqbn0000bwuff4721vm5" data-title="字符设备驱动-input子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-I2C子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T08:23:34.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</a></li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</a><ul>
<li><a href="#2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</a></li>
<li><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</a></li>
</ul>
</li>
<li><a href="#2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</a><ul>
<li><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</a></li>
<li><a href="#2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</a><ul>
<li><a href="#2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</a></li>
</ul>
</li>
<li><a href="#3-i2c-zi-xi-tong-api">3 I2C子系统API</a><ul>
<li><a href="#3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</a><ul>
<li><a href="#3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</a></li>
<li><a href="#3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</a></li>
</ul>
</li>
<li><a href="#3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</a><ul>
<li><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</a></li>
<li><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</a></li>
<li><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</a></li>
<li><a href="#3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</a><ul>
<li><a href="#3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</a></li>
<li><a href="#3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</a></li>
<li><a href="#3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</a><ul>
<li><a href="#4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</a><ul>
<li><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</a></li>
</ul>
</li>
<li><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</a><ul>
<li><a href="#4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</a><ul>
<li><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</a></li>
<li><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</a></li>
</ul>
</li>
<li><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</a><ul>
<li><a href="#4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</a></li>
<li><a href="#4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</a><ul>
<li><a href="#4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</a><ul>
<li><a href="#4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</a><ul>
<li><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</a></li>
<li><a href="#4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</a></li>
</ul>
</li>
<li><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</a><ul>
<li><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</a></li>
<li><a href="#4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</a></li>
<li><a href="#4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</a></li>
<li><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</span><a href="#1-linux-i2c-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>由上到下分为3层结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i2c设备驱动层: 作为client使用者使用i2c子系统。提供操作接口给应用层，与应用层交互数据。</span><br><span class="line"></span><br><span class="line">I2C核心层：提供transfer send recv函数。把client设备挂载到I2C总线上；</span><br><span class="line">    维护i2c driver和i2c client 链表 ，实现i2c_client和i2c_driver匹配。</span><br><span class="line"></span><br><span class="line">I2C适配器层：底层SOC I2C控制器驱动，实现i2c时序，实现i2c总线发送和接收数据的方法。</span><br></pre></td></tr></table></figure>

<p>目录结构位于drivers&#x2F;i2c：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/robin.lee/zip/A2/linux_5.10/drivers/i2c$ <span class="built_in">ls</span></span><br><span class="line">algos            i2c-core-acpi.c  i2c-core-of.c     i2c-dev.c           i2c-slave-testunit.c  Kconfig</span><br><span class="line">busses           i2c-core-base.c  i2c-core-slave.c  i2c-mux.c           i2c-smbus.c           Makefile</span><br><span class="line">i2c-boardinfo.c  i2c-core.h       i2c-core-smbus.c  i2c-slave-eeprom.c  i2c-stub.c            muxes</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</span><a href="#2-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</span><a href="#2-1-1-i2c-adapter-kong-zhi-qi" class="header-anchor">#</a></h3><p> I2C 适配器，也就是 SOC 的 I2C 控制器。<code>i2c_adapter</code> 结构体定义在<code> include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="type">int</span> nr;   <span class="comment">//总线的编号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>适配器的类类型，在一些口I2C设备驱动中会检查该成员，以判断设备能否被该适配器操作</td>
</tr>
<tr>
<td>algo</td>
<td>指向该造配器通信方法描述结构的指针，就是该适配器具体操作I2C控制器的函数</td>
</tr>
<tr>
<td>algo_data</td>
<td>指向通信方法数据的指针，该成员不会被I2C核心层修改，仅供具体的 i2c_algorithm使用</td>
</tr>
<tr>
<td>timeout</td>
<td>传输超时时间</td>
</tr>
<tr>
<td>retries</td>
<td>传输超时的重试次数</td>
</tr>
<tr>
<td>name</td>
<td>适配器名称，该名称可以通过<code>sys/bus/i2c/devices/i2c-x/name</code> (x&#x3D;0,1,2 … ）来访问</td>
</tr>
<tr>
<td>nr</td>
<td>总线编号（也是适配器编号），同时对应设备节点<code>／dev/i2c-x</code> (x&#x3D;0,1,2 …）中的 x</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</span><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa" class="header-anchor">#</a></h3><p>对于一个 I2C 适配器，肯定要对外提供读 写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。<code>i2c_algorithm </code>就是 I2C 适 配器与 IIC 设备进行通信的方法。包括<code>transfer send recv</code>等函数<code>。i2c_algorithm </code>结构体定义在 <code>include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>master_xfer </code>就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之 间的通信。 用于产生I2C访问周期需要的信号， 以<code>i2c_msg</code>为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<p><code>smbus_xfer</code> 是 SMBUS 总线协议的传输函数。</p>
<p><code>functionality</code>：查看适配的能力。这些功能都是以宏定义的方式表示，定义在<code>include/linux/i2c.h</code>中，以<code>I2C_FUNC</code>开头：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To determine what functionality is present */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_10BIT_ADDR		0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_IGNORE_NAK etc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_NOSTART		0x00000010 /* I2C_M_NOSTART */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SLAVE			0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_HOST_NOTIFY	0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br></pre></td></tr></table></figure>



<h2><span id="2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</span><a href="#2-2-ke-hu-duan-xiang-guan" class="header-anchor">#</a></h2><p>i2c 设备(client使用者)驱动要使用<code>i2c_driver</code> 和<code>i2c_client</code>数据结构并填充i2c_driver中的成员函数。</p>
<h3><span id="2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</span><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong" class="header-anchor">#</a></h3><p>代表一个i2c使用者设备驱动。结构体定义在 include&#x2F;linux&#x2F;i2c.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);<span class="comment">//类似于ioctl 的命令控制函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> </span><br><span class="line">	<span class="type">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attach_adapter</td>
<td>依附i2c_adapter的函数指针</td>
</tr>
<tr>
<td>detach_adapter</td>
<td>脱离i2c_adapter的函数指针</td>
</tr>
<tr>
<td>probe</td>
<td>设备和驱动匹配时调用</td>
</tr>
<tr>
<td>driver</td>
<td>在注册i2c_driver对象时，i2c_driver-&gt;driver的总线类型被指定为<code>i2c_bus_type</code></td>
</tr>
<tr>
<td>id_table</td>
<td>匹配列表，驱动和设备匹配时会用到</td>
</tr>
<tr>
<td>detect</td>
<td>基于设备探测机制实现的 12C 设备驱动：设备探测的回调函数</td>
</tr>
<tr>
<td>address_list</td>
<td>设备探测的地址范围</td>
</tr>
<tr>
<td>clients</td>
<td>探测到的设备列表</td>
</tr>
</tbody></table>
<p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;rtc-ds1307&quot;</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</span><a href="#2-2-2-i2c-client-cong-she-bei" class="header-anchor">#</a></h3><p>代表一个连接到<code>i2c_bus</code>总线上的从设备，结构体定义在 <code>include/linux/i2c.h</code>。描述i2c从设备的i2c相关硬件信息。 一个i2c_driver可以支持多个同类型的i2c_client。i2c_client一般描述再设备树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>&#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> flags;   <span class="comment">//描述从设备的一些特性，如I2C_CLIENT_TEN---使用的10位地址</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> addr;   <span class="comment">//设备的i2c地址，7位地址用低7位，10位地址用低10位。</span></span><br><span class="line"> 	<span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line"></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>   <span class="comment">//所属的适配器i2c_adapter,挂载在哪条i2c物理总线上</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>  *<span class="title">driver</span>;</span>    <span class="comment">//匹配成功的i2c_driver</span></span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</span><a href="#2-2-2-1-i2c-board-info" class="header-anchor">#</a></h4><p>也是描述从设备i2c硬件属性。通常情况下先填充i2c_board_info对象的成员，然后去初始化i2c_client对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> type[I2C_NAME_SIZE];<span class="comment">//名字，驱动层和设备层匹配参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//设备地址位数，一般不填或填0表示7位地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">//IIC设备地址</span></span><br><span class="line">    <span class="type">void</span> *platform_data;<span class="comment">//私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> irq;<span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</span><a href="#2-3-i2c-msg-xiao-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* 从机在I2C总线上的地址*/</span></span><br><span class="line">	__u16 flags;	<span class="comment">/* 消息特征的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的宏定义就是消息特征的标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* 消息数据长度，单位是字节 */</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* 指向存放消息数据的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息。</p>
<h1><span id="3-i2c-zi-xi-tong-api">3 I2C子系统API</span><a href="#3-i2c-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</span><a href="#3-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</span><a href="#3-1-1-zhu-ce-kong-zhi-qi" class="header-anchor">#</a></h3><p>通过<code>i2c_add_numbered_adapter</code>或 <code>i2c_add_adapter</code> 这两个函数向系统注册设置好的 i2c_adapter。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter 使用静态总线号。</p>
<h3><span id="3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</span><a href="#3-1-2-xie-zai-kong-zhi-qi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</span><a href="#3-2-ke-hu-duan-she-bei-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</span><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">i2c_register_driver</span>(<span class="params"><span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver</span>)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver);</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</span><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</span><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong" class="header-anchor">#</a></h3><p>在编写从设备驱动时为了方便也可以直接调用<code>module_i2c_driver</code>完成i2c驱动的<code>module_init</code>。或者使用<code>builtin_i2c_driver</code>完成i2c驱动的<code>device_initcall</code>。两者区别一个是编译成内核模块，一个是编译进内核镜像。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_init(__driver<span class="meta">##_init); \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit __driver<span class="meta">##_exit(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	__unregister(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_exit(__driver<span class="meta">##_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * builtin_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in init and have no exit. This eliminates some boilerplate.</span></span><br><span class="line"><span class="comment"> * Each driver may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * device_initcall (or in some cases, the legacy __initcall).  This is</span></span><br><span class="line"><span class="comment"> * meant to be a direct parallel of module_driver() above but without</span></span><br><span class="line"><span class="comment"> * the __exit stuff that is not used for builtin cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> builtin_driver(__driver, __register, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">device_initcall(__driver<span class="meta">##_init);</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</span><a href="#3-2-4-shu-ju-chuan-shu" class="header-anchor">#</a></h3><h4><span id="3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</span><a href="#3-2-4-1-i2c-transfer" class="header-anchor">#</a></h4><p>发送或接收指定字节数的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</span><a href="#3-2-4-2-i2c-master-recv" class="header-anchor">#</a></h4><p>接收指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</span><a href="#3-2-4-3-i2c-master-send" class="header-anchor">#</a></h4><p>发送指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</span><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</span><a href="#4-1-he-xin-core-ceng-zhu-ce" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i2c-core.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,	<span class="comment">//总线上驱动和设备的匹配函数</span></span><br><span class="line">	.probe		= i2c_device_probe,	<span class="comment">//总线上设备和驱动匹配时调用</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">	.pm		= &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">dummy_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;dummy&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">dummy_driver</span> =</span> &#123;</span><br><span class="line">	.driver.name	= <span class="string">&quot;dummy&quot;</span>,</span><br><span class="line">	.probe		= dummy_probe,</span><br><span class="line">	.remove		= dummy_remove,</span><br><span class="line">	.id_table	= dummy_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="comment">//注册I2C总线</span></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;	</span><br><span class="line">	<span class="comment">//向I2C总线注册一个名字为dummy的驱动，这个驱动没什么实际的功能，空实现的驱动</span></span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">class_err:</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">i2c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//删除dummy驱动</span></span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="comment">//卸载I2C总线</span></span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must initialize early, because some subsystems register i2c drivers</span></span><br><span class="line"><span class="comment"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到内核启动阶段就调用i2c_init 注册了I2C总线和注册了I2C设备驱动<code>dummy_driver</code>；</p>
<h3><span id="4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</span><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="title function_">i2c_match_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	driver = to_i2c_driver(drv);</span><br><span class="line">	<span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向I2C总线注册I2C驱动或者I2C设备时，会逐一将I2C驱动的名字和I2C设备的名字进行匹配，如果匹配上则调用I2C总线的probe方法；</p>
<p>I2C总线的probe方法就是进一步调用i2c_driver的probe方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C设备结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C驱动结构体</span></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 把I2C设备驱动和I2C设备绑定，将来可以互相查找到对方</span></span><br><span class="line">	client-&gt;driver = driver;</span><br><span class="line">	<span class="keyword">if</span> (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">					client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用I2C驱动的probe函数</span></span><br><span class="line">	status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		client-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		i2c_set_clientdata(client, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</span><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</span><a href="#4-2-1-gua-pei-qi-zhu-ce" class="header-anchor">#</a></h3><h4><span id="4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</span><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu" class="header-anchor">#</a></h4><p>以nxp的imx6ull芯片为例，在<code>imx6ull.dtsi</code>文件中找到 I2C1 控制器节点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1节点的compatible属性值有两个：<code>fsl,imx6ul-i2c</code>和<code>fsl,imx21-i2c</code>，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件为<code>drivers/i2c/busses/i2c-imx.c</code>。</p>
<h4><span id="4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</span><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>I2C 适配器驱动也是使用标准的 platform 驱动框架。<code>compatible</code> 属性匹配成功后就会调用probe函数如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.1.png" alt="image"></p>
<details>
<summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_hwdata</span> *<span class="title">match</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	match = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (match)</span><br><span class="line">		i2c_imx-&gt;hwdata = match;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line">	ACPI_COMPANION_SET(&amp;i2c_imx-&gt;adapter.dev, ACPI_COMPANION(&amp;pdev-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get I2C clock */</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(&amp;pdev-&gt;dev, PTR_ERR(i2c_imx-&gt;clk),</span><br><span class="line">				     <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init queue */</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up adapter data */</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up platform driver data */</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, I2C_PM_TIMEOUT);</span><br><span class="line">	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Request IRQ */</span></span><br><span class="line">	ret = request_threaded_irq(irq, i2c_imx_isr, <span class="literal">NULL</span>, IRQF_SHARED,</span><br><span class="line">				   pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up clock divider */</span></span><br><span class="line">	i2c_imx-&gt;bitrate = I2C_MAX_STANDARD_MODE_FREQ;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line">	i2c_imx-&gt;clk_change_nb.notifier_call = i2c_imx_clk_notifier_call;</span><br><span class="line">	clk_notifier_register(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	i2c_imx_set_clk(i2c_imx, clk_get_rate(i2c_imx-&gt;clk));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init optional bus recovery function */</span></span><br><span class="line">	ret = i2c_imx_init_recovery_info(i2c_imx, pdev);</span><br><span class="line">	<span class="comment">/* Give it another chance if pinctrl used is not ready yet */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add I2C adapter */</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	pm_runtime_mark_last_busy(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init DMA config if supported */</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_notifier_unregister:</span><br><span class="line">	clk_notifier_unregister(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	free_irq(irq, i2c_imx);</span><br><span class="line">rpm_disable:</span><br><span class="line">	pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ol>
<li><p><code>platform_get_irq</code> 函数获取中断号。</p>
</li>
<li><p><code>platform_get_resource </code>函数从设备树中获取 I2C1 控制器寄存器物理基 地址，也就是 <code>0X021A0000</code>。使用 <code>devm_ioremap_resource </code>函数对其进 行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p>
</li>
<li><p>使用 <code>imx_i2c_struct </code>结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使 用 <code>devm_kzalloc</code> 函数来申请内存。</p>
</li>
<li><p>初始化<code>i2c_adapter</code>。设置i2c_adapter 的algo成员变量为<code>i2c_imx_algo</code>， 也就是设置<code> i2c_algorithm</code>。</p>
</li>
<li><p>开启i2c时钟。</p>
</li>
<li><p>注册 I2C 控制器中断，中断服务函数为<code> i2c_imx_isr</code>。</p>
</li>
<li><p>设置 I2C 频率默认为 <code>IMX_I2C_BIT_RATE=100KHz</code>，如果设备树节点设 置了<code>“clock-frequency”</code>属性的话 I2C 频率就使用 <code>clock-frequency</code> 属性值。</p>
</li>
<li><p>设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image-20240825172735043"></p>
</li>
<li><p>调用 <strong>i2c_add_numbered_adapter</strong> 函数向 Linux 内核注册 i2c_adapter。</p>
</li>
</ol>
<h3><span id="4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</span><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">    .master_xfer = i2c_imx_xfer,</span><br><span class="line">    .functionality = i2c_imx_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</span><a href="#4-2-2-1-i2c-imx-func" class="header-anchor">#</a></h4><p><code>functionality</code>用于返回此I2C适配器支持什么样的通信协议， 在这里<code> functionality</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">i2c_imx_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</span><a href="#4-2-2-2-i2c-imx-xfer" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = pm_runtime_get_sync(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">false</span>);</span><br><span class="line">	pm_runtime_mark_last_busy(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	pm_runtime_put_autosuspend(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_atomic</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = clk_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">true</span>);</span><br><span class="line">	clk_disable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</span><a href="#4-2-2-2-1-i2c-imx-xfer-common" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_msg *msgs,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> num, <span class="type">bool</span> atomic)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start I2C transfer */</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">	<span class="keyword">if</span> (result) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Bus recovery uses gpiod_get_value_cansleep() which is not</span></span><br><span class="line"><span class="comment">		 * allowed within atomic context.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!atomic &amp;&amp; i2c_imx-&gt;adapter.bus_recovery_info) &#123;</span><br><span class="line">			i2c_recover_bus(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">			result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line">	<span class="comment">/* read/write data */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);</span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>, atomic);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);</span><br><span class="line">		<span class="comment">/* write/read data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_DEBUG_BUS</span></span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2CR_IEN ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_IIEN ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_MSTA ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_MTX ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_TXAK ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_RSTA ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2SR_ICF ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAAS ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_IBB ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAL ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_SRW ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IIF ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_RXAK ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg, atomic);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!atomic &amp;&amp;</span><br><span class="line">			    i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i], atomic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">/* Stop I2C transfer */</span></span><br><span class="line">	i2c_imx_stop(i2c_imx, atomic);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,</span><br><span class="line">		(result &lt; <span class="number">0</span>) ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;success msg&quot;</span>,</span><br><span class="line">			(result &lt; <span class="number">0</span>) ? result : num);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用<code>i2c_imx_start</code>函数开启 I2C 通信。</li>
<li>读数据的话就调用 <code>i2c_imx_read</code> 函数。</li>
<li>向 I2C 设备写数据，如果要用 DMA 的话就使用<code> i2c_imx_dma_write</code> 函数来 完成写数据。如果不使用 DMA 的话就使用 <code>i2c_imx_write</code> 函数完成写数据。</li>
<li>I2C 通信完成以后调用<code>i2c_imx_stop</code>函数停止 I2C 通信。</li>
</ol>
<p><code>i2c_imx_start</code>、<code>i2c_imx_read</code>、<code>i2c_imx_write</code> 和 <code>i2c_imx_stop</code> 这些函数就是 I2C 寄存器的具体操作函数，按照<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15384523.html">i2c协议</a>。</p>
<h2><span id="4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</span><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</span><a href="#4-3-1-i2c-cong-she-bei-miao-shu" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</span><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu" class="header-anchor">#</a></h4><p>在未使用设备树的时候需要在 BSP 里面使用<code>i2c_board_info</code>结构体来描 述一个具体的 I2C 设备。</p>
<p>举个例子，<code>arch/arm/mach-imx/mach-mx27_3ds.c</code>， <code>OV2640 摄像头</code>使用的 I2C 设备信息描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">mx27_3ds_i2c_camera</span> =</span> &#123;</span><br><span class="line">	I2C_BOARD_INFO(<span class="string">&quot;ov2640&quot;</span>, <span class="number">0x30</span>),</span><br><span class="line">&#125;;<span class="comment">//从设备OV2640 的名字和i2c地址</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</span><a href="#4-3-1-2-shi-yong-dts-miao-shu" class="header-anchor">#</a></h4><p>比如NXP 官方的 EVK 开发 板在<code> I2C1</code> 上接了 <code>mag3110 </code>这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然 后在这个子节点内描述 mag3110 这个i2c外设的相关信息。打开 <code>imx6ull-14x14-evk.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点 是 <code>compatible </code>属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</p>
<h3><span id="4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</span><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</span><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi" class="header-anchor">#</a></h4><p>AP3216C是一个三合一环境传感器，包含<code>环境光强度(ALS)、接近距离(PS)和红外线强度(IR)</code>这 三个环境参数检测。接开发板子的<code>i2c1</code>。因此用这个外设作为i2c从设备来举例。</p>
<p>AP3216C 的特点 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. I2C 接口，快速模式下波特率可以到 400Kbit/S</span><br><span class="line">2. 多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等。</span><br><span class="line">3. 内建温度补偿电路。</span><br><span class="line">4. 宽工作温度范围(-30°C ~ +80°C)。</span><br><span class="line">5. 超小封装，4.1mm x 2.4mm x 1.35mm</span><br><span class="line">6. 环境光传感器具有 16 位分辨率。</span><br><span class="line">7. 接近传感器和红外传感器具有 10 位分辨率</span><br></pre></td></tr></table></figure>

<p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</span><a href="#4-3-2-2-dts-she-zhi" class="header-anchor">#</a></h4><p>打开 <code>imx6ull-alientek-emmc.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1使用<code>pinctrl子系统</code>配置了iomux属性。<code>pinctrl_i2c1</code> 就是 I2C1 的 IO 节点，这里将<code> UART4_TXD</code> 和 <code>UART4_RXD </code>这两个 IO 分别 复用为<code> I2C1_SCL</code> 和<code> I2C1_SDA</code>，电气属性都设置为 <code>0x4001b8b0</code>。</p>
<p>默认i2c1 节点下并不是对应 <code>ap3216c</code> 从设备，而是<code>mag3110</code>。修改dts如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ap3216c </code>子节点，@后面的<code>“1e”</code>是 ap3216c 的<code>器件地址</code>。</p>
<p>reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 <code>0x1e</code>。</p>
<p>修改编译启动linux，可以看到<code>/sys/bus/i2c/devices </code>目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在 <code>/sys/bus/i2c/devices </code>目录下看到一个名为<code>“0-001e”</code>的子目录：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p><code>“0-001e”</code>就是 ap3216c 的设备目录，<code>“1e”</code>就是 ap3216c 器件地址。进入<code> 0-001e</code> 目录，可以看到<code>“name”</code>文件，name 问价就保存着此设备名字，在这里就是<code>“ap3216c”</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</span><a href="#4-3-2-3-ap3216c-qu-dong-shi-li" class="header-anchor">#</a></h4><p><code>ap3216creg.h</code>定义<code>AP3216C 的寄存器</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AP3216C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ADDR    	0X1E	<span class="comment">/* AP3216C器件地址  */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_SYSTEMCONG	0x00	<span class="comment">/* 配置寄存器       */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTSTATUS	0X01	<span class="comment">/* 中断状态寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTCLEAR	0X02	<span class="comment">/* 中断清除寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATALOW	0x0A	<span class="comment">/* IR数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATAHIGH	0x0B	<span class="comment">/* IR数据高字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATALOW	0x0C	<span class="comment">/* ALS数据低字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATAHIGH	0X0D	<span class="comment">/* ALS数据高字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATALOW	0X0E	<span class="comment">/* PS数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATAHIGH	0X0F	<span class="comment">/* PS数据高字节     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ap3216c.c:</p>
<details>     <summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME	<span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;			<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;	<span class="comment">/* 私有数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;		<span class="comment">/* 三个光传感器数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;			<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;			<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;				<span class="comment">/* reg长度*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;		<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;		<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;				<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;			<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">		</span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_read_byte_data(client, reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ap3216c_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)	</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) 	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ir = <span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取IR传感器的数据*/</span></span><br><span class="line">		dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>); 			</span><br><span class="line">	</span><br><span class="line">	dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* 读取ALS传感器的数据*/</span>  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>)	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ps = <span class="number">0</span>;    													</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取PS传感器的数据    */</span></span><br><span class="line">		dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">	<span class="comment">/* 初始化AP3216C */</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);<span class="comment">/* 复位AP3216C */</span></span><br><span class="line">	mdelay(<span class="number">50</span>);	<span class="comment">/* AP3216C复位最少10ms 	*/</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0X03</span>);<span class="comment">/* 开启ALS、PS+IR */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">	<span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">	ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = ap3216c_open,</span><br><span class="line">	.read = ap3216c_read,</span><br><span class="line">	.release = ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">		ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">		ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">	cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line">	ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid,</span><br><span class="line">                                      <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">	unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line">	device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">	class_destroy(ap3216cdev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">	.probe = ap3216c_probe,</span><br><span class="line">	.remove = ap3216c_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">		   	.of_match_table = ap3216c_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">module_i2c_driver(ap3216c_driver);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</details>

<ol>
<li>典型的i2c驱动框架编写的从设备驱动示例，<code>i2c_add_driver/i2c_del_driver</code>添加和删除从设备驱动。</li>
<li><code>ap3216c_of_match</code>中<code>compatible</code>匹配上，执行<code>ap3216c_probe</code>，把从设备ap3216c按照字符设备框架构造驱动。</li>
<li><code>ap3216cdev.private_data = client</code>， <code>private_data </code>成员变量用于存放 <code>ap3216c </code>对 应的 <code>i2c_client</code>。</li>
<li><code>ap3216c_open</code>初始化<code>ap3216c</code>。</li>
<li>传感器数据获取</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ap3216c_read</span><br><span class="line">   	ap3216c_readdata<span class="comment">//读取数据6字节</span></span><br><span class="line">   		ap3216c_read_reg<span class="comment">//读取一个字节</span></span><br><span class="line">   			ap3216c_read_regs<span class="comment">//构造i2c_msg[2]调用i2c_transfer获取1个字节传感器数据</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>ap3216c_write_reg</code>调用<code>ap3216c_write_regs</code>再调用<code>i2c_transfer</code>写入数据到指定地址寄存器。</li>
</ol>
<h4><span id="4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</span><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> databuf[<span class="number">3</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			ir =  databuf[<span class="number">0</span>]; 	<span class="comment">/* ir传感器数据 */</span></span><br><span class="line">			als = databuf[<span class="number">1</span>]; 	<span class="comment">/* als传感器数据 */</span></span><br><span class="line">			ps =  databuf[<span class="number">2</span>]; 	<span class="comment">/* ps传感器数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">200000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行程序如下：</span><br><span class="line">./a.out /dev/ap3216c</span><br></pre></td></tr></table></figure>

<p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm09fgqbo0001bwuf9bjwhd5r" data-title="字符设备驱动-I2C子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-内核led子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T09:01:56.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</a><ul>
<li><a href="#1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</a></li>
<li><a href="#1-2-jie-gou-ti-miao-shu">1.2 结构体描述</a><ul>
<li><a href="#1-2-1-led-classdev">1.2.1 led_classdev</a></li>
<li><a href="#1-2-2-gpio-led">1.2.2 gpio_led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-led-qu-dong-shi-neng">2 LED 驱动使能</a></li>
<li><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</a><ul>
<li><a href="#3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</a><ul>
<li><a href="#3-1-1-create-gpio-led">3.1.1 create_gpio_led</a></li>
<li><a href="#3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</a><ul>
<li><a href="#4-1-dts-bian-xie">4.1 dts编写</a></li>
<li><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</a></li>
</ul>
</li>
<li><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</a><ul>
<li><a href="#5-1-dian-liang-led">5.1 点亮 LED</a></li>
<li><a href="#5-2-shan-shuo">5.2 闪烁</a></li>
<li><a href="#5-3-guan-bi-led">5.3 关闭 LED</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-led-zi-xi-tong-jie-shao">1 LED子系统介绍</span><a href="#1-led-zi-xi-tong-jie-shao" class="header-anchor">#</a></h1><p>用来管理控制板子的led灯，比如系统心跳灯，普通的硬盘指示灯光，颜色灯，休眠唤醒灯等等。</p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"><br>led 子系统相关描述可在内核源码 <code>Documentation/leds/leds-class.txt </code>了解。</p>
<p>led 子系统是一个简单的 Linux 子系统 ，在目录 <code>/sys/class/leds</code> 下展示该子系统设备，每个设备都有自己的属性：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brightness：设置 LED 亮度，范围 <span class="number">0</span> ~ max_brightness</span><br><span class="line">max_brightness：最大亮度（<span class="number">255</span> 或其他数字）</span><br><span class="line">trigger：触发方式，如 heartbeat、mmc0、backlight、gpio</span><br><span class="line">delay_off、delay_on：trigger为timer时，LED亮灭的时间，单位ms</span><br></pre></td></tr></table></figure>

<p><code>kernel/include/linux/leds.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span> &#123;</span></span><br><span class="line">	LED_OFF  = <span class="number">0</span>,    <span class="comment">//全暗</span></span><br><span class="line">	LED_HALF = <span class="number">127</span>,  <span class="comment">//一半亮度</span></span><br><span class="line">	LED_FULL = <span class="number">255</span>,  <span class="comment">//最大亮度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="1-1-dai-ma-kuang-jia-fen-xi">1.1 代码框架分析</span><a href="#1-1-dai-ma-kuang-jia-fen-xi" class="header-anchor">#</a></h2><p><code>led-class.c</code> (led 子系统框架的入口)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有 LED 设备，为 LED 设备提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_classdev_register()</span><br><span class="line">devm_led_classdev_register()</span><br><span class="line"></span><br><span class="line">注销操作函数:</span><br><span class="line">led_classdev_unregister()</span><br><span class="line">devm_led_classdev_unregister();</span><br><span class="line"></span><br><span class="line">电源管理的休眠和恢复操作函数: </span><br><span class="line">led_classdev_suspend()</span><br><span class="line">led_classdev_resume();</span><br><span class="line"></span><br><span class="line">用户态操作接口:brightness 、max_brightness</span><br></pre></td></tr></table></figure>
<p><code>led-core.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">抽象出 LED 操作逻辑，封装成函数导出，供其它文件使用:</span><br><span class="line"></span><br><span class="line">led_init_core(): 核心初始化;</span><br><span class="line">led_blink_set(): 设置led闪烁时间:</span><br><span class="line">led_blink_set_oneshot() : 闪烁一次</span><br><span class="line">led_stop_software_blink() : led停止闪烁</span><br><span class="line">led_set_brightness() : 设置led的亮度</span><br><span class="line">led_update_brightness : 更新亮度</span><br><span class="line">led_sysfs_disable : 用户态关闭</span><br><span class="line">led_sysfs enable : 用户态打开</span><br><span class="line">leds_list : leds链表;</span><br><span class="line">leds_list_lock : leds链表锁</span><br></pre></td></tr></table></figure>
<p><code>led-triggers.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">维护 LED 子系统的所有触发器，为触发器提供注册操作函数: </span><br><span class="line"></span><br><span class="line">led_trigger_register()</span><br><span class="line">devm_led_trigger_register()</span><br><span class="line">led_trigger_register_simple()</span><br><span class="line"></span><br><span class="line">注销操作函数: </span><br><span class="line">led_trigger_unregister()</span><br><span class="line">led_trigger_unregister_simple()</span><br><span class="line"></span><br><span class="line">以及其它触发器相关的操作函数</span><br></pre></td></tr></table></figure>
<p><code>ledtrig-timer.c、ledtrig-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以 ledtrig-timer.c 为例</span><br><span class="line"></span><br><span class="line">入口函数调用 led_trigger_register() 注册触发器，</span><br><span class="line">注册时候传入 led_trigger 结构体，里面有 activate 和 deactivate 成员函数指针，</span><br><span class="line">作用是生成 delay_on 、 delay_off 文件</span><br><span class="line"></span><br><span class="line">同时还提供 delay_on 和 delay_off 的用户态操作接口</span><br><span class="line">卸载时，使用 led_trigger_unregister() 注销触发器</span><br></pre></td></tr></table></figure>

<p><code>leds-gpio.c、leds-xxx.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以 leds-gpio.c 为例</span><br><span class="line"></span><br><span class="line">在通过设备树或者其它途径匹配到设备信息后，将调用 probe() 函数，</span><br><span class="line">然后再根据设备信息设置 led_classdev，</span><br><span class="line">最后调用 devm_led_classdev_register() 注册 LED 设备。</span><br></pre></td></tr></table></figure>

<p>对于驱动开发人员，LED框架已经有了，并不需要我们去熟悉，只要知道如何使用，它是如何与我们的硬件相关联的，只要熟悉<code>leds-gpio.c</code>。</p>
<h2><span id="1-2-jie-gou-ti-miao-shu">1.2 结构体描述</span><a href="#1-2-jie-gou-ti-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-2-1-led-classdev">1.2.1 led_classdev</span><a href="#1-2-1-led-classdev" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_classdev</span> &#123;</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *name;<span class="comment">//名字</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">brightness</span>;</span><span class="comment">//亮度</span></span><br><span class="line">	 <span class="class"><span class="keyword">enum</span> <span class="title">led_brightness</span>  <span class="title">max_brightness</span>;</span><span class="comment">//最大亮度</span></span><br><span class="line">	 <span class="type">int</span>    flags;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/* Lower 16 bits reflect status */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SUSPENDED  (1 &lt;&lt; 0)</span></span><br><span class="line">	 <span class="comment">/* Upper 16 bits reflect control information */</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_CORE_SUSPENDRESUME (1 &lt;&lt; 16)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT (1 &lt;&lt; 17)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_ONESHOT_STOP (1 &lt;&lt; 18)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_BLINK_INVERT (1 &lt;&lt; 19)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_SYSFS_DISABLE (1 &lt;&lt; 20)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_ASYNC (1 &lt;&lt; 21)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> SET_BRIGHTNESS_SYNC (1 &lt;&lt; 22)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> LED_DEV_CAP_FLASH (1 &lt;&lt; 23)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置亮度API</span></span><br><span class="line">	 <span class="type">void</span>  (*brightness_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line">	 <span class="type">int</span>  (*brightness_set_sync)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="keyword">enum</span> led_brightness brightness);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取亮度API</span></span><br><span class="line">	 <span class="keyword">enum</span> <span class="title function_">led_brightness</span> <span class="params">(*brightness_get)</span><span class="params">(<span class="keyword">struct</span> led_classdev *led_cdev)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//闪烁时点亮和熄灭的时间设置</span></span><br><span class="line">	 <span class="type">int</span>  (*blink_set)(<span class="keyword">struct</span> led_classdev *led_cdev,<span class="type">unsigned</span> <span class="type">long</span> *delay_on,<span class="type">unsigned</span> <span class="type">long</span> *delay_off);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">device</span>  *<span class="title">dev</span>;</span></span><br><span class="line">	 <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">attribute_group</span> **<span class="title">groups</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//leds-list的node</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">node</span>;</span></span><br><span class="line">	<span class="comment">//默认trigger的名字</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span>  *default_trigger;</span><br><span class="line">	<span class="comment">//闪烁的开关时间</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>   blink_delay_on, blink_delay_off;</span><br><span class="line">	<span class="comment">//闪烁的定时器链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>  <span class="title">blink_timer</span>;</span></span><br><span class="line">	<span class="comment">//闪烁的亮度</span></span><br><span class="line">	 <span class="type">int</span>    blink_brightness;</span><br><span class="line">	 <span class="type">void</span>   (*flash_resume)(<span class="keyword">struct</span> led_classdev *led_cdev);</span><br><span class="line"></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">set_brightness_work</span>;</span></span><br><span class="line">	 <span class="type">int</span>   delayed_set_value;</span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_LEDS_TRIGGERS</span></span><br><span class="line">	<span class="comment">//trigger的锁</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>  <span class="title">trigger_lock</span>;</span></span><br><span class="line">	<span class="comment">//led的trigger</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">led_trigger</span> *<span class="title">trigger</span>;</span></span><br><span class="line">	<span class="comment">//trigger的链表</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">trig_list</span>;</span></span><br><span class="line">	<span class="comment">//trigger的数据</span></span><br><span class="line">	 <span class="type">void</span>   *trigger_data;</span><br><span class="line">	 <span class="type">bool</span>   activated;</span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>  <span class="title">led_access</span>;</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-2-gpio-led">1.2.2 gpio_led</span><a href="#1-2-2-gpio-led" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_led</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *default_trigger;</span><br><span class="line">	<span class="type">unsigned</span> 	gpio;</span><br><span class="line">	<span class="type">unsigned</span>	active_low : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	retain_state_suspended : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	panic_indicator : <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span>	default_state : <span class="number">2</span>;</span><br><span class="line">	<span class="comment">/* default_state should be one of LEDS_GPIO_DEFSTATE_(ON|OFF|KEEP) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>name</code>: led名字<br><code>default_trigger</code>:  LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br><code>default_state</code>: 默认状态，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define LEDS_GPIO_DEFSTATE_OFF		0</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_ON		1</span><br><span class="line">#define LEDS_GPIO_DEFSTATE_KEEP		2</span><br></pre></td></tr></table></figure>
<p><code>gpiod</code>：是gpio描述，详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<h1><span id="2-led-qu-dong-shi-neng">2 LED 驱动使能</span><a href="#2-led-qu-dong-shi-neng" class="header-anchor">#</a></h1><p>输入<code>make menuconfig</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line">	-&gt; LED Support (NEW_LEDS [=y])</span><br><span class="line">		-&gt;LED Support <span class="keyword">for</span> GPIO connected LEDs</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"><br>可 以 看 出 ， 把 Linux 内 部 自 带 的 LED 灯 驱 动 编 译 进 内 核 以 后，<code>CONFIG_LEDS_GPIO</code> 就会等于‘y’：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<h1><span id="3-linux-nei-he-zi-dai-led-qu-dong-fen-xi">3 Linux 内核自带 LED 驱动分析</span><a href="#3-linux-nei-he-zi-dai-led-qu-dong-fen-xi" class="header-anchor">#</a></h1><p>LED 灯驱动文件为<code>/drivers/leds/leds-gpio.c</code>，大家可以打开<code>/drivers/leds/Makefile</code> 这个文件：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br>来看一下<code>leds-gpio.c</code>这个驱动文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">of_gpio_leds_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;gpio-leds&quot;</span>, &#125;,</span><br><span class="line">	&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_led_driver</span> =</span> &#123;</span><br><span class="line">	.probe = gpio_led_probe,</span><br><span class="line">	.remove = gpio_led_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">	.name = <span class="string">&quot;leds-gpio&quot;</span>,</span><br><span class="line">	.of_match_table = of_gpio_leds_match,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(gpio_led_driver);</span><br></pre></td></tr></table></figure>

<p>LED 驱动的匹配表，此表只有一个匹配项，<code>compatible</code> 内容为<code>“gpio-leds”</code>，<br>因此设备树中的 LED 灯设备节点的 <code>compatible </code>属性值也要为<code>“gpio-leds”</code>，否则设备和驱动匹<br>配不成功，驱动就没法工作。</p>
<p>利用内核自带LED子系统驱动，可以帮我们很好的控制板子产品的指示灯，不需要单独编写驱动程序。</p>
<h2><span id="3-1-gpio-led-probe-han-shu-jian-xi">3.1 gpio_led_probe 函数简析</span><a href="#3-1-gpio-led-probe-han-shu-jian-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"><br>进入probe函数，pdata此时为空，<strong>进入gpio_leds_create</strong>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<ol>
<li>调用 <code>device_get_child_node_count</code> 函数统计子节点数量，一般在在设备树中创建<br>一个节点表示 LED 灯，然后在这个节点下面为每个 LED 灯创建一个子节点。因此子节点数量也是 LED 灯的数量。</li>
<li>遍历每个子节点，获取每个子节点的信息：<br> 2.1 <code>devm_get_gpiod_from_child</code>获取每个gpio灯的<code>gpio_desc</code>信息。<br> 2.2 获取<code>label</code>属性，<code>label</code>作为led的名字<br> 2.3 获取<code>“linux,default-trigger”</code>属性，可以通过此属性设置某个 LED 灯在Linux 系统中的默认功能，比如作为系统心跳指示灯等等。<br> 2.4 获取<code>“default-state”</code>属性值，也就是 LED 灯的默认状态属性<br> 2.5 <code>create_gpio_led </code>函数创建 LED 相关的 io，常用gpio操作，下面详细介绍</li>
</ol>
<h3><span id="3-1-1-create-gpio-led">3.1.1 create_gpio_led</span><a href="#3-1-1-create-gpio-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<ol>
<li>先获取<code>gpiod</code>信息</li>
<li>配置<code>led_dat</code>属性，包括<code>default_state, brightness</code>等信息</li>
<li>配置<code>gpio</code>方向</li>
<li>将led注册给LED子系统</li>
</ol>
<h3><span id="3-1-2-kai-qi-guan-bi-led">3.1.2 开启关闭led</span><a href="#3-1-2-kai-qi-guan-bi-led" class="header-anchor">#</a></h3><p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<h1><span id="4-led-zi-xi-tong-ying-yong-ju-li">4 led子系统应用举例</span><a href="#4-led-zi-xi-tong-ying-yong-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-dts-bian-xie">4.1 dts编写</span><a href="#4-1-dts-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建一个节点表示 LED 灯设备，比如<code> dtsleds</code>，如果板子上有多个 LED 灯的话每个 LED灯都作为 <code>dtsleds</code> 的子节点。</p>
<ol>
<li><code>dtsleds </code>节点的<code>compatible</code>属性值一定要为<code>“gpio-leds”</code>。</li>
<li>设置<code>label</code>属性，此属性为可选，每个子节点都有一个 label 属性，label 属性一般表示LED 灯的名字，比如以颜色区分的话就是 red、green 等等。</li>
<li>每个子节点必须要设置<code>gpios</code>属性值，表示此 LED 所使用的 GPIO 引脚！</li>
<li>可以设置<code>“linux,default-trigger”</code>属性值，也就是设置 LED 灯的默认功能，可以查阅<code>Documentation/devicetree/bindings/leds/common.txt </code>这个文档来查看可选功能，比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backlight：LED 灯作为背光。</span><br><span class="line"><span class="keyword">default</span>-on：LED 灯打开</span><br><span class="line">heartbeat：LED 灯作为心跳指示灯，可以作为系统运行提示灯。</span><br><span class="line">ide-disk：LED 灯作为硬盘活动指示灯。</span><br><span class="line">timer：LED 灯周期性闪烁，由定时器驱动，闪烁频率可以修改</span><br></pre></td></tr></table></figure></li>
<li>可以设置<code>“default-state”</code>属性值，可以设置为 on、off 或 keep，为 on 的时候 LED 灯默认打开，为 off 的话 LED 灯默认关闭，为 keep 的话 LED 灯保持当前模式</li>
</ol>
<p>启动开发板：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br>进入到 leds 目录中：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"><br>测试：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //打开 <span class="title">LED0</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">red</span>/<span class="title">brightness</span> //关闭 <span class="title">LED0</span></span></span><br></pre></td></tr></table></figure>
<p>如果能正常的打开和关闭 LED 灯话就说明使用led子系统ok。</p>
<h2><span id="4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng">4.2 修改该led成系统心跳灯</span><a href="#4-2-xiu-gai-gai-led-cheng-xi-tong-xin-tiao-deng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dtsleds &#123;</span><br><span class="line">	compatible = <span class="string">&quot;gpio-leds&quot;</span>;</span><br><span class="line">	led0 &#123;</span><br><span class="line">		label = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">		gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">		linux,<span class="keyword">default</span>-trigger = <span class="string">&quot;heartbeat&quot;</span>;</span><br><span class="line">		<span class="keyword">default</span>-state = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>设置 LED0 为<code> heartbeat</code>。<br>第 8 行，默认打开 LED0。</p>
<h1><span id="5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong">5 基于sysfs操作led子系统</span><a href="#5-ji-yu-sysfs-cao-zuo-led-zi-xi-tong" class="header-anchor">#</a></h1><h2><span id="5-1-dian-liang-led">5.1 点亮 LED</span><a href="#5-1-dian-liang-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">255</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br><span class="line"><span class="class"><span class="title">cat</span> /<span class="title">sys</span>/<span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">max_brightness</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-shan-shuo">5.2 闪烁</span><a href="#5-2-shan-shuo" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">会看到 <span class="title">trigger_list</span></span></span><br><span class="line"><span class="class">[<span class="title">none</span>] <span class="title">mmc0</span> <span class="title">mmc1</span> <span class="title">mmc2</span> <span class="title">timer</span></span></span><br><span class="line"><span class="class">其中的 <span class="title">timer</span> 这个 <span class="title">trigger</span> 是 <span class="title">ledtrig</span>-<span class="title">timer</span>.<span class="title">c</span> 中模块初始化的时候注册进去的</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> <span class="title">timer</span> &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">trigger</span></span></span><br><span class="line"><span class="class">这一句会调用</span></span><br><span class="line"><span class="class"><span class="title">led_trigger_store</span>()-&gt;</span></span><br><span class="line">   led_trigger_set()-&gt;</span><br><span class="line">     trigger-&gt;activate(led_cdev);</span><br><span class="line">从而调用 ledtrig-timer.c 文件里 的timer_trig_activate()，</span><br><span class="line">在 /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/ 下创建 <span class="title">delay_on</span>、<span class="title">delay_off</span> 两个文件</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 100 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class"><span class="title">echo</span> 200 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_off</span></span></span><br><span class="line"><span class="class">这样会闪烁，亮 100<span class="title">ms</span> 灭 200<span class="title">ms</span></span></span><br></pre></td></tr></table></figure>
<h2><span id="5-3-guan-bi-led">5.3 关闭 LED</span><a href="#5-3-guan-bi-led" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">delay_on</span></span></span><br><span class="line"><span class="class">或</span></span><br><span class="line"><span class="class"><span class="title">echo</span> 0 &gt;</span> /sys/<span class="class"><span class="keyword">class</span>/<span class="title">leds</span>/<span class="title">led1</span>/<span class="title">brightness</span></span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="clzzen66g00002sufhned0k45" data-title="字符设备驱动-内核led子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-pinctrl子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-18T07:38:09.000Z" itemprop="datePublished">2024-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</a></li>
<li><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</a><ul>
<li><a href="#2-1-pinctrl-zi-xi-tong">2.1 pinctrl子系统</a><ul>
<li><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</a></li>
<li><a href="#2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</a></li>
<li><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</a><ul>
<li><a href="#3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</a></li>
<li><a href="#3-1-pinctrl-dev">3.1 pinctrl_dev</a></li>
<li><a href="#3-2-pinctrl-desc">3.2 pinctrl_desc</a><ul>
<li><a href="#3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</a></li>
<li><a href="#3-2-2-pin-desc">3.2.2 pin_desc</a></li>
<li><a href="#3-2-3-san-ge-ops">3.2.3 三个ops</a><ul>
<li><a href="#3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</a></li>
<li><a href="#3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</a></li>
<li><a href="#3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</a><ul>
<li><a href="#4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</a></li>
<li><a href="#4-1-pinctrl-map">4.1 pinctrl_map</a></li>
<li><a href="#4-2-dev-pin-info">4.2 dev_pin_info</a><ul>
<li><a href="#4-2-1-pinctrl">4.2.1 pinctrl</a><ul>
<li><a href="#4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</a><ul>
<li><a href="#5-1-pin-controller-shi-li">5.1 pin controller示例</a></li>
<li><a href="#5-2-client-shi-li">5.2 client示例</a><ul>
<li><a href="#5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</a><ul>
<li><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pinctrl-he-gpio-subsystem-yin-ru">1 pinctrl和gpio subsystem引入</span><a href="#1-pinctrl-he-gpio-subsystem-yin-ru" class="header-anchor">#</a></h1><p>上一节引入gpio了子系统：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18085417">linux内核驱动-gpio子系统 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统 | Hexo (fuzidage.github.io)</a></p>
<p>Linux 驱动讲究驱动分离与分层，pinctrl 和 gpio 子系统就是驱动分离与分层思想下的产物。<br>pinctrl顾名思义就是引脚控制，用来配置比如引脚mux复用信息，引脚电器属性（比如上&#x2F;下拉、速度、驱动能力等）信息。<br>gpio顾名思义就是控制gpio的输入输出，以及高低电平。不过，大多数的芯片并没有单独的IOMUX模块，引脚的复用、配置等，而是在GPIO模块内部实现的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<h1><span id="2-pinctrl-zi-xi-tong-yuan-li-jie-shao">2 pinctrl子系统原理介绍</span><a href="#2-pinctrl-zi-xi-tong-yuan-li-jie-shao" class="header-anchor">#</a></h1><h2><span id="2-1-pinctrl-zi-xi-tong">2.1  pinctrl子系统</span><a href="#2-1-pinctrl-zi-xi-tong" class="header-anchor">#</a></h2><h3><span id="2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou">2.1.1 pinctrl子系统软件架构</span><a href="#2-1-1-pinctrl-zi-xi-tong-ruan-jian-jia-gou" class="header-anchor">#</a></h3><p>pinctrl子系统源码路径是linux&#x2F;drivers&#x2F;pinctrl：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">其他驱动层（client）：具体到使用系统pin资源的设备驱动程序</span><br><span class="line">pinctrl核心层(core)：内核抽象出来，向下为SoC pin controler drvier提供底层通信接口的能力， </span><br><span class="line">    向上为其他驱动提供了控制pin的能力，比如pin复用、配置引脚的电气特性，同时也为GPIO子系统提供pin操作。</span><br><span class="line">pin控制器驱动层(pinctrl-driver)： 提供了操作pin的具体方法。</span><br></pre></td></tr></table></figure>

<p><code>pinctrl-driver</code>主要为<code>pinctrl-core</code>提供pin的操作能力。把系统所有的pin以及对于pin的控制接口实例化成<code>pinctrl_desc</code>，并将<code>pinctrl_desc</code>注册到<code>pinctrl-core</code>中去。</p>
<h3><span id="2-1-2-pinctrl-chong-yao-gai-nian">2.1.2 Pinctrl重要概念</span><a href="#2-1-2-pinctrl-chong-yao-gai-nian" class="header-anchor">#</a></h3><p><code>Documentation\devicetree\bindings\pinctrl\pinctrl-bindings.txt</code>有介绍重要相关概念：</p>
<p><strong>1. pin controller：</strong><br>    芯片手册里你找不到 <code>pin controller</code>，它是一个软件上的概念。对应 IOMUX──用来复用引脚，还可以配置引脚(比如上下拉电阻等)。<br><strong>2. client device：</strong><br>    “客户设备”，客户是指<code>Pinctrl</code>系统的客户，即使用Pinctrl系统的设备，使用引脚的设备<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"></p>
<ul>
<li><ol>
<li><strong>pin state</strong><br>  对于一个<code>&quot;client device&quot;</code>，如UART设备，它有多个<code>“状态”</code>：<code>default、sleep</code>等，那么对应的引脚也有这些状态。</li>
</ol>
<p>  比如，默认状态下，UART设备正常工作，那么所用的引脚就要复用为UART功能；<br>  休眠状态下，为了省电，可以把这些引脚复用为GPIO功能；或者直接把它们配置输出高电平。</p>
<p>  上图<code>pinctrl-names</code>定义2种状态：<code>default，sleep</code>。<br>  第0种状态用到的引脚在<code>pinctrl-0</code>中定义，它是<code>state_0_node_a</code>，位于<code>pincontroller</code>节点中。<br>  第1种状态用到的引脚在<code>Pinctrl-1</code>中定义，它是<code>state_1_node_a</code>，位于<code>pincontroller</code>节点中。</p>
<p>  当UART设备处于<code>default</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚复用为uart0功能。<br>  当UART设备处于<code>sleep</code>状态时，pinctrl子系统会自动根据上述信息将所用引脚配置为高电平。</p>
</li>
<li><ol start="2">
<li><strong>groups和function</strong><br>  一个设备会用到一个或多个引脚，这些引脚可以归纳为一组<code>（group）</code>；<br>  这些引脚可以复用为某个功能：<code>function</code>，如I2C功能，SPI功能，GPIO功能等。当然：一个设备可以用到多组引脚，比如A1、A2两组引脚，A1组复用为F1功能，A2组复用为F2功能：<br>  <img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></li>
</ol>
</li>
<li><ol start="3">
<li><strong>Generic pin multiplexing node和Generic pin configuration node</strong><br>  下图左边<code>pin controller</code>节点中，有子节点或孙节点，它们是给<code>client device</code>使用的。<br>  可用来描述复用信息：哪组<code>（group）</code>引脚复用为哪个功能<code>（function）</code>；<br>  配置信息：<code>哪组（group）</code>引脚配置为哪个设置功能（<code>setting</code>），如上拉、下拉等；</li>
</ol>
</li>
</ul>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h3><span id="2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng">2.1.3 pinctrl 子系统注册流程</span><a href="#2-1-3-pinctrl-zi-xi-tong-zhu-ce-liu-cheng" class="header-anchor">#</a></h3><p>以imx6ull为例，<code>drivers/pinctrl/freescale/pinctrl-imx6ul.c</code><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p>驱动的入口是 <code>arch_initcall</code> 中声明的函数，类似于我们经常写的 <code>module_init</code>是动态ko加载，<code>arch_initcall</code>是编译进入内核镜像。可以看到是利用platform_device框架来写的。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"><br>根据 <code>compatible</code> 和<code>设备树的compatible </code>字段进行匹配，匹配成功执行 probe 函数，调用<code>imx_pinctrl_probe_dt</code>解析dts中的<code>pinctrl</code>描述信息。调用<code>pinctrl_register</code>或者<code>devm_pinctrl_register</code>注册pinctl子系统。</p>
<h1><span id="3-soc-pinctrl-zhu-yao-jie-gou-ti-controller">3 soc pinctrl主要结构体（controller）</span><a href="#3-soc-pinctrl-zhu-yao-jie-gou-ti-controller" class="header-anchor">#</a></h1><h2><span id="3-0-shu-ju-jie-gou-guan-xi-tu">3.0 数据结构关系图</span><a href="#3-0-shu-ju-jie-gou-guan-xi-tu" class="header-anchor">#</a></h2><p>总框图记录数据结构之间的关联。<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="1876680-20240315174913445-1187095793"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pincontroller数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\pinctrl.h</span><br><span class="line">include\linux\pinctrl\pinmux.h</span><br><span class="line">include\linux\pinctrl\pinconf.h</span><br><span class="line"><span class="comment">//client数据结构</span></span><br><span class="line">drivers\pinctrl\core.h</span><br><span class="line">include\linux\pinctrl\devinfo.h</span><br><span class="line">include\linux\device.h</span><br><span class="line">include\linux\pinctrl\machine.h</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pinctrl-dev">3.1 pinctrl_dev</span><a href="#3-1-pinctrl-dev" class="header-anchor">#</a></h2><p><code>pinctrl_dev</code> 是 pinctrl 子系统的根源结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> *<span class="title">desc</span>;</span> <span class="comment">//提供具体操作方法和抽象包括pincrtl_ops函数，pinmux操作函数和pin的描述等</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_desc_tree</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCTRL_GROUPS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_group_tree</span>;</span><span class="comment">//存储group的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_groups;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINMUX_FUNCTIONS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">pin_function_tree</span>;</span><span class="comment">//存储function的描述信息</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> num_functions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">gpio_ranges</span>;</span><span class="comment">//链接gpio range 2 pin range相关的信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">void</span> *driver_data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//每个pinctrl都描述着一组gpio的复用和状态配置，</span></span><br><span class="line">    	<span class="comment">//如果这个pinctrl_dev是一个通过iic连接的，那么使用这个pinctrl_dev</span></span><br><span class="line">    	<span class="comment">//就需要配置其占用的gpio为iic功能，那么就要用这个来描述</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_default</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">hog_sleep</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">device_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>/driver/pinctrl/core.c</code>中注册pinctrl时将soc中所有的<code>pinctrl_dev</code>挂载到<code>pinctrl_dev_list</code>链表中方便查询使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pinctrl_dev *<span class="title function_">pinctrl_register</span><span class="params">(<span class="keyword">struct</span> pinctrl_desc *pctldesc,</span></span><br><span class="line"><span class="params">								 <span class="keyword">struct</span> device *dev, <span class="type">void</span> *driver_data)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="3-2-pinctrl-desc">3.2 pinctrl_desc</span><a href="#3-2-pinctrl-desc" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_desc</span> &#123;</span></span><br><span class="line">   <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> *<span class="title">pins</span>;</span>   <span class="comment">//描述一个pin控制器的引脚,</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> npins;                    <span class="comment">//描述该控制器有多少个引脚</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> *<span class="title">pctlops</span>;</span>     <span class="comment">//引脚操作函数，有描述引脚，获取引脚等</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinmux_ops</span> *<span class="title">pmxops</span>;</span>       <span class="comment">//引脚复用相关的操作函数</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> *<span class="title">confops</span>;</span>     <span class="comment">//引脚配置相关的操作函数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> num_custom_params;</span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinconf_generic_params</span> *<span class="title">custom_params</span>;</span></span><br><span class="line">   <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pin_config_item</span> *<span class="title">custom_conf_items</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"><br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<p>三个ops:</p>
<ol>
<li><p><code>group</code>操作接口对应数据结构<code>struct pinctrl_ops</code>，包含<code>get_groups_count</code>、<code>get_group_name</code>、<code>get_group_pins</code>等接口；</p>
</li>
<li><p><code>mux</code>操作接口对应的数据结构为<code>struct pinmux_ops</code>，包含<code>pin request</code>、<code>free</code>、<code>set_mux</code>、<code>get_functions_count</code>、<code>get_function_groups</code>等；</p>
</li>
<li><p><code>function</code>操作接口对应的数据结构为<code>struct pinconf_ops</code>，包含<code>pin_config_set</code>、<code>pin_config_get</code>、<code>pin_config_group_get</code>、<code>pin_config_group_set</code>等接口；</p>
</li>
</ol>
<h3><span id="3-2-1-pinctrl-pin-desc">3.2.1 pinctrl_pin_desc</span><a href="#3-2-1-pinctrl-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_pin_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> number;<span class="comment">//引脚序号</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//引脚名</span></span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pinctrl_pin_desc</code>来描述一个引脚.</p>
<h3><span id="3-2-2-pin-desc">3.2.2 pin_desc</span><a href="#3-2-2-pin-desc" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pin_desc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_dev</span> *<span class="title">pctldev</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="type">bool</span> dynamic_name;</span><br><span class="line">	<span class="type">void</span> *drv_data;</span><br><span class="line">	<span class="comment">/* These fields only added when supporting pinmux drivers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PINMUX</span></span><br><span class="line">	<span class="type">unsigned</span> mux_usecount;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *mux_owner;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_setting_mux</span> *<span class="title">mux_setting</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *gpio_owner;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>记录引脚的使用计数、引脚当前所属的<code>function、group</code>信息（该数据结构主要是pinctrl子系统用于判断一个引脚是否被多次配置不同的复用情况使用（<code>pin_request、pin_free</code>）</p>
<h3><span id="3-2-3-san-ge-ops">3.2.3 三个ops</span><a href="#3-2-3-san-ge-ops" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-pinctrl-ops">3.2.3.1 pinctrl_ops</span><a href="#3-2-3-1-pinctrl-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">//获取组数</span></span><br><span class="line">	<span class="type">int</span> (*get_groups_count) ();</span><br><span class="line">	<span class="comment">//获取组名</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *(*get_group_name) ();</span><br><span class="line">	<span class="comment">//获取某组的引脚</span></span><br><span class="line">	<span class="type">int</span> (*get_group_pins) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供每个引脚的信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_dbg_show) ();</span><br><span class="line">	<span class="comment">//解析设备树节点，转换成pinctrl_map，重点</span></span><br><span class="line">	<span class="type">int</span> (*dt_node_to_map) ();</span><br><span class="line">	<span class="comment">//释放map</span></span><br><span class="line">	<span class="type">void</span> (*dt_free_map) ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>来取出某组的引脚：<code>get_groups_count、get_group_pins</code></li>
<li>处理设备树中<code>pin controller</code>中的某个节点创建映射：<code>dt_node_to_map</code>，把device_node转换为一系列的<code>pinctrl_map</code></li>
</ul>
<h4><span id="3-2-3-2-pinmux-ops">3.2.3.2 pinmux_ops</span><a href="#3-2-3-2-pinmux-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-3-pinconf-ops">3.2.3.3 pinconf_ops</span><a href="#3-2-3-3-pinconf-ops" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinconf_ops</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GENERIC_PINCONF</span></span><br><span class="line">	<span class="type">bool</span> is_generic;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//获取单个引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_get) ();</span><br><span class="line">	<span class="comment">//配置单个引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_set) ();</span><br><span class="line">	<span class="comment">//获取某组引脚配置</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_get) ();</span><br><span class="line">	<span class="comment">//配置某组引脚</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_group_set) ();</span><br><span class="line">	<span class="comment">//用以debugfs修改pin配置信息</span></span><br><span class="line">	<span class="type">int</span> (*pin_config_dbg_parse_modify) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供pin配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs提供group配置信息</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_group_dbg_show) ();</span><br><span class="line">	<span class="comment">//用以debugfs解析并显示pin的配置</span></span><br><span class="line">	<span class="type">void</span> (*pin_config_config_dbg_show) (s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1><span id="4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client">4 board pinctrl相关结构体(使用者client)</span><a href="#4-board-pinctrl-xiang-guan-jie-gou-ti-shi-yong-zhe-client" class="header-anchor">#</a></h1><h2><span id="4-0-shu-ju-jie-gou-guan-xi">4.0 数据结构关系</span><a href="#4-0-shu-ju-jie-gou-guan-xi" class="header-anchor">#</a></h2><p>前面Soc pin描述相关的数据结构，已经搭建了该soc所支持的<code>pin</code>、<code>function</code>、<code>group</code>以及相关操作接口等信息；而<code>board pin</code>描述相关的数据结构则描述一块board所使用到的<code>function</code>及相关的<code>group</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="1876680-20240316150501629-222504717"></p>
<h2><span id="4-1-pinctrl-map">4.1 pinctrl_map</span><a href="#4-1-pinctrl-map" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *dev_name;<span class="comment">//设备名称</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;<span class="comment">//该pinctrl_map对应的状态（default、idle、sleep等</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">pinctrl_map_type</span> <span class="title">type</span>;</span><span class="comment">//pinctrl_map的类型，包括mux group、config group、config pins等</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ctrl_dev_name;<span class="comment">//pinctrl device的名称，根据该名称可获取到soc pin controller对应的pinctrl device</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_mux</span> <span class="title">mux</span>;</span><span class="comment">//引脚复用的内容，该数据结构中包含function名称、group名称，</span></span><br><span class="line">        <span class="comment">//通过function、group就可以确定进行引脚复用的引脚id与引脚复用值等信息；</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_map_configs</span> <span class="title">configs</span>;</span><span class="comment">//引脚配置相关的内容，包括group或者pin的名称，</span></span><br><span class="line">        <span class="comment">//以及该group、pin的配置信息，实现引脚配置操作。</span></span><br><span class="line">	&#125; data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该数据结构可以理解为一个function类型：</p>
<h2><span id="4-2-dev-pin-info">4.2 dev_pin_info</span><a href="#4-2-dev-pin-info" class="header-anchor">#</a></h2><p>device结构体中有一个<code>dev_pin_info</code>，用来保存设备的pinctrl信息：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pin_info</span> &#123;</span>    <span class="comment">//该device对应引脚的配置与复用信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> *<span class="title">p</span>;</span><span class="comment">//该设备支持引脚配置类型（包括支持的pinctrl状态，</span></span><br><span class="line">    	<span class="comment">//每一种pinctrl状态下的引脚复用以及引脚配置信息）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">default_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">init_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PM</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">sleep_state</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">idle_state</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="4-2-1-pinctrl">4.2.1 pinctrl</span><a href="#4-2-1-pinctrl" class="header-anchor">#</a></h3><p>一个设备的所有引脚配置相关的信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">states</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> *<span class="title">state</span>;</span><span class="comment">//states下链接了该设备支持的所有引脚配置状态</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">dt_maps</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">users</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5><span id="4-2-1-1-pinctrl-state">4.2.1.1 pinctrl_state</span><a href="#4-2-1-1-pinctrl-state" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pinctrl_state</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">settings</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image"></p>
<h1><span id="5-pinctrl-shi-li-hua-shi-li">5 pinctrl实例化示例</span><a href="#5-pinctrl-shi-li-hua-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-pin-controller-shi-li">5.1 pin controller示例</span><a href="#5-1-pin-controller-shi-li" class="header-anchor">#</a></h2><p>打开imx6ull的dtsi找到<code>pin controller</code>控制器节点，对比IMX6ULL参考手册可知：<code>imx6ull一共3个IOMUX控制器</code>：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<h2><span id="5-2-client-shi-li">5.2 client示例</span><a href="#5-2-client-shi-li" class="header-anchor">#</a></h2><p>以<code>evk</code>公板为例：<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/16.png" alt="image"><br><strong>imx6ull pinmux dts配置描述：</strong><br>我们看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19       <span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br></pre></td></tr></table></figure>
<p>它是表示什么意思呢？配置了哪些信息呢？<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image"></p>
<p><code>UART1_RTS_B</code>复用成<code>GPIO1_IO19</code>:<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image"></p>
<p>此宏定义在imx_6ull_pinfunc.h, 后面跟着 5 个数字，也就是这个宏定义的具体值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0090</span> <span class="number">0x031C</span> <span class="number">0x0000</span> <span class="number">0x5</span> <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>这 5 个值的含义如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mux_reg conf_reg input_reg mux_mode input_val&gt;</span><br></pre></td></tr></table></figure>
<p>0x0090表示<code>UART1_RTS_B</code>的iomux寄存器<br>0x031C表示<code>UART1_RTS_B</code>的电器属性寄存器<br>0x0000表示<code>input寄存器</code><br>0x5表示复用成模式5<br>0x0表示input寄存器设置值为0x0</p>
<p>注意还少了一项电器属性的值啊？别急定义在dts中，<code>0x17059</code>就刚好是电器属性的值。</p>
<h3><span id="5-2-1-client-ru-he-shi-yong-pinctrl">5.2.1 client如何使用pinctrl</span><a href="#5-2-1-client-ru-he-shi-yong-pinctrl" class="header-anchor">#</a></h3><p>前面讲过client包含device结构体，每个device结构体里都有一个<code>dev_pin_info</code>结构体，用来保存设备的pinctrl信息。<code>platform_device</code>匹配driver会执行probe，probe前会进行pinctrl处理，处理函数为<code>pinctrl_bind_pins</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform_device_register</span><br><span class="line">	platform_device_add</span><br><span class="line">		device_add</span><br><span class="line">			bus_probe_device;</span><br><span class="line">				device_initial_probe</span><br><span class="line">					__device_attach</span><br><span class="line">						<span class="title function_">bus_for_each_drv</span><span class="params">(dev-&gt;bus, <span class="literal">NULL</span>, &amp;data, __device_attach_driver)</span>;</span><br><span class="line">						<span class="comment">// 对于plarform_bus_type下的每一个driver, 调用__device_attach_driver</span></span><br><span class="line"></span><br><span class="line">__device_attach_driver</span><br><span class="line">	<span class="title function_">driver_match_device</span><span class="params">(drv, dev)</span>;</span><br><span class="line">		drv-&gt;bus-&gt;match(dev, drv)<span class="comment">// 调用platform_bus_type.match</span></span><br><span class="line">			driver_probe_device</span><br><span class="line">				really_probe</span><br><span class="line">				<span class="comment">/* If using pinctrl, bind pins now before probing */</span></span><br><span class="line">					pinctrl_bind_pins</span><br><span class="line">					drv-&gt;probe <span class="comment">//执行driver中的probe函数			</span></span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-pinctrl-bind-pins-guo-cheng">5.2.1.1 pinctrl_bind_pins过程</span><a href="#5-2-1-1-pinctrl-bind-pins-guo-cheng" class="header-anchor">#</a></h4><ul>
<li>构造<code>pinctrl</code><ul>
<li>通过<code>pinctrl_ops.dt_node_to_map</code>将设备树节点转换成一系列<code>pinctrl_map</code></li>
<li><code>pinctrl_map</code>转换成<code>pinctrl_setting</code>，放入settings链表，记录在<code>pinctrl_state</code>中</li>
</ul>
</li>
<li>选择<code>state</code>，遍历settings链表，进行pinctrl的mux和config<br><img src="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/19.png" alt="image"></li>
</ul>
<p>函数调用过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 分配dev_pin_info结构体 */</span></span><br><span class="line">	devm_kzalloc(dev, <span class="keyword">sizeof</span>(*(dev-&gt;pins)), GFP_KERNEL);</span><br><span class="line">	<span class="comment">/* 获取pinctrl */</span></span><br><span class="line">	devm_pinctrl_get(dev);</span><br><span class="line">		pinctrl_get</span><br><span class="line">			<span class="comment">/* 构建pinctrl */</span></span><br><span class="line">			create_pinctrl(dev);</span><br><span class="line">				<span class="comment">/* 分配pinctrl */</span></span><br><span class="line">				p = kzalloc(<span class="keyword">sizeof</span>(*p), GFP_KERNEL);</span><br><span class="line">				<span class="comment">/* 设备树节点转换为pinctrl_map */</span></span><br><span class="line">				pinctrl_dt_to_map(p);</span><br><span class="line">				<span class="comment">/* 每个pinctrl_map，又被转换为一个pinctrl_setting，添加到setting链表 */</span></span><br><span class="line">				for_each_maps(maps_node, i, <span class="built_in">map</span>) &#123;</span><br><span class="line">					ret = add_setting(p, <span class="built_in">map</span>);</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节点转换为pinctrl_map过程</strong>：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_dt_to_map(p);</span><br><span class="line">	<span class="keyword">for</span> (state = <span class="number">0</span>; ; state++) &#123;</span><br><span class="line">		propname = kasprintf(GFP_KERNEL, <span class="string">&quot;pinctrl-%d&quot;</span>, state);</span><br><span class="line">	    <span class="comment">/* 取出pinctrl-%d节点属性 */</span></span><br><span class="line">	   	prop = of_find_property(np, propname, &amp;size);</span><br><span class="line">	    <span class="built_in">list</span> = prop-&gt;value;</span><br><span class="line">		size /= <span class="keyword">sizeof</span>(*<span class="built_in">list</span>);</span><br><span class="line">	   	<span class="comment">/* 对pinctrl-%d中的每一个phandle进行pinctrl_map转换 */</span></span><br><span class="line">	    <span class="comment">/* 例如pinctrl-0 = &lt;&amp;state_0_node_a &amp;state_0_node_b&gt;有两个phandle */</span></span><br><span class="line">	    <span class="keyword">for</span> (config = <span class="number">0</span>; config &lt; size; config++) &#123;</span><br><span class="line">	    	<span class="comment">/* 根据phandle找到对应节点 */</span></span><br><span class="line">	       	np_config = of_find_node_by_phandle(phandle);</span><br><span class="line">	        <span class="comment">/* Parse the node */</span></span><br><span class="line">			dt_to_map_one_config(p, statename, np_config);</span><br><span class="line">	           	<span class="comment">/* 调用Pincontroller中dt_node_to_map函数,构造pinctrl_map */</span></span><br><span class="line">	       		ops-&gt;dt_node_to_map()</span><br><span class="line">	            <span class="comment">/* 将pinctrl_map添加到maps链表 */</span></span><br><span class="line">	            dt_remember_or_free_map</span><br><span class="line">	            	pinctrl_register_map</span><br><span class="line">	                	list_add_tail</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* fy00的dt_node_to_map函数 */</span></span><br><span class="line">mc_pctrl_dt_node_to_map()</span><br><span class="line">	<span class="comment">/* 取出每一个子节点 */</span></span><br><span class="line">    for_each_child_of_node(np_config, np) &#123;</span><br><span class="line">   		mc_pctrl_dt_subnode_to_map</span><br><span class="line">   			<span class="comment">/* 获取设备树pinmux属性 */</span></span><br><span class="line">        	pins = of_find_property(node, <span class="string">&quot;pinmux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    		num_pins = pins-&gt;length / <span class="keyword">sizeof</span>(u32);</span><br><span class="line">    		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_pins; i++) &#123;</span><br><span class="line">            	of_property_read_u32_index(node, <span class="string">&quot;pinmux&quot;</span>,i, &amp;pinfunc); </span><br><span class="line">                <span class="comment">/* 解析设备树，将pinmux属性中每一个成员记录在pin和func中 */</span></span><br><span class="line">                pin = MC_GET_PIN_NO(pinfunc);</span><br><span class="line">				func = MC_GET_PIN_FUNC(pinfunc);</span><br><span class="line">                <span class="comment">/* 设置复用的pinctrl_map */</span></span><br><span class="line">                mc_pctrl_dt_node_to_map_func();</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].type = PIN_MAP_TYPE_MUX_GROUP;</span><br><span class="line">					(*<span class="built_in">map</span>)[*num_maps].data.mux.group = grp-&gt;name;</span><br><span class="line">                	(*<span class="built_in">map</span>)[*num_maps].data.mux.function = mc_gpio_functions[fnum];</span><br><span class="line">					(*num_maps)++;</span><br><span class="line">              	<span class="keyword">if</span> (has_config) &#123;</span><br><span class="line">                    <span class="comment">/* 设置配置pinctrl_map，fy00没有配置pinctrl_map */</span></span><br><span class="line">                    pinctrl_utils_add_map_configs</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].type = type;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.group_or_pin = group;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.configs = dup_configs;</span><br><span class="line">                        (*<span class="built_in">map</span>)[*num_maps].data.configs.num_configs = num_configs;</span><br><span class="line">                        (*num_maps)++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><strong>pinctrl_map转换为pinctrl_setting过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">for_each_maps() &#123;</span><br><span class="line">	add_setting();</span><br><span class="line">		find_state();</span><br><span class="line">		<span class="keyword">if</span> (!state)</span><br><span class="line">			<span class="comment">/* 第一次添加state到states链表 */</span></span><br><span class="line">			create_state(p, <span class="built_in">map</span>-&gt;name);</span><br><span class="line">				list_add_tail(&amp;state-&gt;node, &amp;p-&gt;states);</span><br><span class="line">		<span class="comment">/* 将map的name和tpye赋值给setting */</span></span><br><span class="line">		setting-&gt;type = <span class="built_in">map</span>-&gt;type;</span><br><span class="line">		setting-&gt;dev_name = <span class="built_in">map</span>-&gt;dev_name;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="built_in">map</span>-&gt;type) &#123;</span><br><span class="line">			<span class="comment">/* MUX类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">				pinmux_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的function字符串转换为序号，赋值给setting*/</span></span><br><span class="line">					pinmux_func_name_to_selector(pctldev, <span class="built_in">map</span>-&gt;data.mux.function);</span><br><span class="line">					setting-&gt;data.mux.func = ret;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map中的group字符串转换为序号，赋值给setting */</span></span><br><span class="line">					ret = pinctrl_get_group_selector(pctldev, group);</span><br><span class="line">					setting-&gt;data.mux.group = ret;</span><br><span class="line">			<span class="comment">/* CONFIGS类型 */</span></span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">			<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">				pinconf_map_to_setting(<span class="built_in">map</span>, setting);</span><br><span class="line">					<span class="comment">/* 从pinctrl_map取出pin或group赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.group_or_pin = pin;</span><br><span class="line">					<span class="comment">/* 将pinctrl_map的configs赋值给setting */</span></span><br><span class="line">					setting-&gt;data.configs.num_configs = <span class="built_in">map</span>-&gt;data.configs.num_configs;</span><br><span class="line">					setting-&gt;data.configs.configs = <span class="built_in">map</span>-&gt;data.configs.configs;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 添加到settings链表 */</span></span><br><span class="line">			list_add_tail(&amp;setting-&gt;node, &amp;state-&gt;settings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pin脚的复用和配置过程</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_bind_pins</span><br><span class="line">	<span class="comment">/* 寻找state */</span></span><br><span class="line">	pinctrl_lookup_state</span><br><span class="line">	<span class="comment">/* 选择state */</span></span><br><span class="line">	pinctrl_select_state</span><br><span class="line">		pinctrl_commit_state</span><br><span class="line">			<span class="comment">/* 遍历settings链表 */</span></span><br><span class="line">        	list_for_each_entry(setting, &amp;state-&gt;settings, node) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (setting-&gt;type) &#123;</span><br><span class="line">                	<span class="keyword">case</span> PIN_MAP_TYPE_MUX_GROUP:</span><br><span class="line">                		<span class="comment">/* 设置复用 */</span></span><br><span class="line">                   		pinmux_enable_setting(setting);</span><br><span class="line">                        	ops-&gt;set_mux(...);</span><br><span class="line">                    <span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_PIN:</span><br><span class="line">					<span class="keyword">case</span> PIN_MAP_TYPE_CONFIGS_GROUP:</span><br><span class="line">						<span class="comment">/* 设置配置 */</span></span><br><span class="line">						pinconf_apply_setting(setting);</span><br><span class="line">							ops-&gt;pin_config_group_set(...);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="clzz9dfoh00007guf1uun7mm5" data-title="字符设备驱动-pinctrl子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-gpio子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T12:14:37.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</a></li>
<li><a href="#2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</a><ul>
<li><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</a><ul>
<li><a href="#2-0-1-probe-fen-xi">2.0.1 probe分析</a><ul>
<li><a href="#2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</a></li>
<li><a href="#2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</a></li>
<li><a href="#2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</a></li>
<li><a href="#2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</a><ul>
<li><a href="#2-1-1-gpio-device">2.1.1 gpio_device</a></li>
<li><a href="#2-1-2-gpio-chip">2.1.2 gpio_chip</a></li>
<li><a href="#2-1-3-gpio-desc">2.1.3 gpio_desc</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-gpio-zi-xi-tong-api">3 gpio子系统api</a><ul>
<li><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</a><ul>
<li><a href="#3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</a></li>
<li><a href="#3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</a></li>
<li><a href="#3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</a></li>
</ul>
</li>
<li><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</a></li>
<li><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</a></li>
</ul>
</li>
<li><a href="#4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</a></li>
<li><a href="#5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</a><ul>
<li><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</a></li>
<li><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</a><ul>
<li><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</a><ul>
<li><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</a></li>
<li><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gpio-zi-xi-tong-yin-ru">1 gpio 子系统引入</span><a href="#1-gpio-zi-xi-tong-yin-ru" class="header-anchor">#</a></h1><p>如果 <code>pinctrl </code>子系统将一个 PIN 复用为 GPIO 的话，那么接下来要用到 gpio 子系统了。gpio 子系统顾名思义，就是用于初始化 GPIO 并且提供相应的 API 函数，比如设置 GPIO为输入输出，设置读取 GPIO 的值等。</p>
<p>gpio 子系统的主要目的就是方便驱动开发者使用 gpio，驱动开发者在设备树中添加 gpio 相关信息，然后就可以在驱动程序中使用 gpio 子系统提供的 API函数来操作 GPIO，Linux 内核向驱动开发者屏蔽掉了 GPIO 的设置过程，极大的方便了驱动开发者使用 GPIO。</p>
<h1><span id="2-gpio-zi-xi-tong-jia-gou">2 gpio子系统架构</span><a href="#2-gpio-zi-xi-tong-jia-gou" class="header-anchor">#</a></h1><p>Linux的GPIO子系统驱动框架由三个主要部分组成：① GPIO控制器驱动程序、②gpio lib驱动程序 ③GPIO字符设备驱动程序：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image-20240817202346143"><br>使用<code>gpiochip_add/gpiochip_add_data</code>向系统<code>注册gpio_chip</code>, 这些都是半导体原厂要做的，设备商只需要使用即可。</p>
<h2><span id="2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi">2.0 gpio控制器源码分析</span><a href="#2-0-gpio-kong-zhi-qi-yuan-ma-fen-xi" class="header-anchor">#</a></h2><p><code>drivers/gpio/gpio-mxc.c</code> 就是 I.MX6ULL的 GPIO 控制器驱动文件，在此文件中有如下所示<code>of_device_id</code> 匹配表:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"><br>对照<code>imx6ull.dtsi</code>的gpio控制器可以看到能匹配：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>打开<code>drivers/gpio/gpio-mxc.c</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image"><br>probe函数内容如下：</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">mxc_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mxc_gpio_port</span> *<span class="title">port</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">iores</span>;</span></span><br><span class="line">	<span class="type">int</span> irq_base = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	mxc_gpio_get_hw(pdev);</span><br><span class="line"></span><br><span class="line">	port = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*port), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!port)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	iores = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	port-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, iores);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(port-&gt;base);</span><br><span class="line"></span><br><span class="line">	port-&gt;irq_high = platform_get_irq(pdev, <span class="number">1</span>);</span><br><span class="line">	port-&gt;irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (port-&gt;irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> port-&gt;irq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the controller clock is optional */</span></span><br><span class="line">	port-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(port-&gt;clk))</span><br><span class="line">		port-&gt;clk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	err = clk_prepare_enable(port-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (err) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;Unable to enable clock.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line">	err = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_pm_dis;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* disable the interrupt and clear the status */</span></span><br><span class="line">	writel(<span class="number">0</span>, port-&gt;base + GPIO_IMR);</span><br><span class="line">	writel(~<span class="number">0</span>, port-&gt;base + GPIO_ISR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mxc_gpio_hwtype == IMX21_GPIO) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Setup one handler for all GPIO interrupts. Actually setting</span></span><br><span class="line"><span class="comment">		 * the handler is needed only once, but doing it for every port</span></span><br><span class="line"><span class="comment">		 * is more robust and easier.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		irq_set_chained_handler(port-&gt;irq, mx2_gpio_irq_handler);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* setup one handler for each entry */</span></span><br><span class="line">		irq_set_chained_handler_and_data(port-&gt;irq,</span><br><span class="line">						 mx3_gpio_irq_handler, port);</span><br><span class="line">		<span class="keyword">if</span> (port-&gt;irq_high &gt; <span class="number">0</span>)</span><br><span class="line">			<span class="comment">/* setup handler for GPIO 16 to 31 */</span></span><br><span class="line">			irq_set_chained_handler_and_data(port-&gt;irq_high,</span><br><span class="line">							 mx3_gpio_irq_handler,</span><br><span class="line">							 port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = bgpio_init(&amp;port-&gt;gc, &amp;pdev-&gt;dev, <span class="number">4</span>,</span><br><span class="line">			 port-&gt;base + GPIO_PSR,</span><br><span class="line">			 port-&gt;base + GPIO_DR, <span class="literal">NULL</span>,</span><br><span class="line">			 port-&gt;base + GPIO_GDIR, <span class="literal">NULL</span>,</span><br><span class="line">			 BGPIOF_READ_OUTPUT_REG_SET);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (of_property_read_bool(np, <span class="string">&quot;gpio_ranges&quot;</span>))</span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		port-&gt;gpio_ranges = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	port-&gt;gc.request = mxc_gpio_request;</span><br><span class="line">	port-&gt;gc.<span class="built_in">free</span> = mxc_gpio_free;</span><br><span class="line">	port-&gt;gc.parent = &amp;pdev-&gt;dev;</span><br><span class="line">	port-&gt;gc.to_irq = mxc_gpio_to_irq;</span><br><span class="line">	port-&gt;gc.base = (pdev-&gt;id &lt; <span class="number">0</span>) ? of_alias_get_id(np, <span class="string">&quot;gpio&quot;</span>) * <span class="number">32</span> :</span><br><span class="line">					     pdev-&gt;id * <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	err = devm_gpiochip_add_data(&amp;pdev-&gt;dev, &amp;port-&gt;gc, port);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line"></span><br><span class="line">	irq_base = irq_alloc_descs(<span class="number">-1</span>, <span class="number">0</span>, <span class="number">32</span>, numa_node_id());</span><br><span class="line">	<span class="keyword">if</span> (irq_base &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		err = irq_base;</span><br><span class="line">		<span class="keyword">goto</span> out_bgio;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	port-&gt;domain = irq_domain_add_legacy(np, <span class="number">32</span>, irq_base, <span class="number">0</span>,</span><br><span class="line">					     &amp;irq_domain_simple_ops, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (!port-&gt;domain) &#123;</span><br><span class="line">		err = -ENODEV;</span><br><span class="line">		<span class="keyword">goto</span> out_irqdesc_free;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gpio-mxc can be a generic irq chip */</span></span><br><span class="line">	err = mxc_gpio_init_gc(port, irq_base, &amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_irqdomain_remove;</span><br><span class="line"></span><br><span class="line">	list_add_tail(&amp;port-&gt;node, &amp;mxc_gpio_ports);</span><br><span class="line"></span><br><span class="line">	platform_set_drvdata(pdev, port);</span><br><span class="line">	pm_runtime_put(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_pm_dis:</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(port-&gt;clk);</span><br><span class="line">out_irqdomain_remove:</span><br><span class="line">	irq_domain_remove(port-&gt;domain);</span><br><span class="line">out_irqdesc_free:</span><br><span class="line">	irq_free_descs(irq_base, <span class="number">32</span>);</span><br><span class="line">out_bgio:</span><br><span class="line">	dev_info(&amp;pdev-&gt;dev, <span class="string">&quot;%s failed with errno %d\n&quot;</span>, __func__, err);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-0-1-probe-fen-xi">2.0.1 probe分析</span><a href="#2-0-1-probe-fen-xi" class="header-anchor">#</a></h3><p>里面定义了一个很重要的结构体<code>mxc_gpio_port</code> 就是对<code> I.MX6ULL GPIO</code> 的抽象。<code>mxc_gpio_port </code>结构体定义如下：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"><br><code>mxc_gpio_probe</code>又会继续调用<code>mxc_gpio_get_hw</code>获取gpio的硬件相关数据，也就是gpio组，gpio1.gpio2等。</p>
<h4><span id="2-0-1-0-mxc-gpio-get-hw">2.0.1.0 mxc_gpio_get_hw</span><a href="#2-0-1-0-mxc-gpio-get-hw" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<p>我们imx6ull gpio<code>控制器类型</code>就是<code>imx35系列</code>。因此选用<code>imx35_gpio_hwdata</code>，如下：可以看出这些成员不就是对应寄存器的偏移量吗？</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="2-0-1-1-get-resource-and-ioremap">2.0.1.1 get resource and ioremap</span><a href="#2-0-1-1-get-resource-and-ioremap" class="header-anchor">#</a></h4><p>比如我们probe中通过<code>platform_get_resource</code> 获取<code>gpio1</code>的<code>基地址为0X0209,C000</code>，那么就可以通过配置<code>mxc_gpio_hwdata</code>结构体成员来配置寄存器。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>
<p>然后调用 <code>devm_ioremap_resource</code> 函数进行内存映射，得到 <code>0x0209C000</code> 在 Linux 内核中的虚拟地址。<br>然后<code>platform_get_irq</code> 函数获取中断号，分为获取高 16 位 GPIO 的中断号，和获取低 16 位 GPIO 中断号。</p>
<p>操作 GPIO1 的 <code>IMR</code> 和 <code>ISR</code> 这两个寄存器，关闭 GPIO1 所有 IO 中断，并且清除状态寄存器:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/10.png" alt="image"></p>
<p>设置对应 GPIO 的中断服务函数，不管是高 16 位还是低 16 位，中断服务函数都是 <code>mx3_gpio_irq_handler</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/11.png" alt="image"></p>
<h4><span id="2-0-1-2-bgpio-init">2.0.1.2 bgpio_init</span><a href="#2-0-1-2-bgpio-init" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/12.png" alt="image"></p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/13.png" alt="image-20240817211118974"></p>
<p>调用<code>bgpio_init</code> 函数主 要 任 务 就 是 初 始 化<code> port-&gt;gc, (gc就是gpio_chip)</code>。顾名思义<code>bgpio_init</code>就是<code>basic gpio init</code>，里 面 有 三 个 <code>setup</code> 函 数 :</p>
<ol>
<li><code>bgpio_setup_io</code> </li>
<li><code>bgpio_setup_accessors</code> </li>
<li><code>bgpio_setup_direction</code>。这三个函数就是初始化 <code>port-&gt;gc</code> 中的各种有关GPIO 的操作，比如输出，输入等等。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/14.png" alt="image-20240817213544044"></p>
<h4><span id="2-0-1-3-devm-gpiochip-add-data">2.0.1.3 devm_gpiochip_add_data</span><a href="#2-0-1-3-devm-gpiochip-add-data" class="header-anchor">#</a></h4><p>调用<code>devm_gpiochip_add_data</code>注册这个port。gpio控制器就成功注册给了gpio子系统。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/15.png" alt="image"></p>
<p>至此，<code>port-&gt;gc</code>既有了对 GPIO 的操作函数，又有了 I.MX6ULL 有关 GPIO的寄存器，那么只要得到 port 就可以对 I.MX6ULL 的 GPIO 进行操作。</p>
<h2><span id="2-1-gpio-zi-xi-tong-shu-ju-jie-gou">2.1 gpio子系统数据结构</span><a href="#2-1-gpio-zi-xi-tong-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-1-1-gpio-device">2.1.1 gpio_device</span><a href="#2-1-1-gpio-device" class="header-anchor">#</a></h3><p>每个<code>GPIO Controller</code>用一个<code>gpio_device</code>来表示:</p>
<ol>
<li>每组gpio引脚对应一个<code>gpio_desc</code>和一个<code>gpio_chip</code></li>
<li>gpio引脚的操作函数，都放在<code>gpio_chip</code>成员函数中。</li>
</ol>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/17.png" alt="image-20240818143429583"></p>
<h3><span id="2-1-2-gpio-chip">2.1.2 gpio_chip</span><a href="#2-1-2-gpio-chip" class="header-anchor">#</a></h3><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/18.png" alt="image-20240818140515596"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_chip</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*label;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_device</span>	*<span class="title">gpiodev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span>		*<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>		*<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">int</span>			(*request)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//请求一个 GPIO 引脚</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">free</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//释放一个之前请求的 GPIO 引脚</span></span><br><span class="line">	<span class="type">int</span>			(*get_direction)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//获取方向</span></span><br><span class="line">	<span class="type">int</span>			(*direction_input)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//输入模式</span></span><br><span class="line">	<span class="type">int</span>			(*direction_output)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//输出模式，并且set gpio val</span></span><br><span class="line">	<span class="type">int</span>			(*get)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);<span class="comment">//读取 GPIO 引脚的值</span></span><br><span class="line">	<span class="type">void</span>			(*<span class="built_in">set</span>)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset, <span class="type">int</span> value);<span class="comment">//设置gpio 引脚值</span></span><br><span class="line">	<span class="type">void</span>			(*set_multiple)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *mask,</span><br><span class="line">						<span class="type">unsigned</span> <span class="type">long</span> *bits);</span><br><span class="line">	<span class="type">int</span>			(*set_debounce)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="type">unsigned</span> debounce);<span class="comment">//设置 GPIO 引脚的去抖动时间</span></span><br><span class="line">	<span class="type">int</span>			(*set_single_ended)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset,</span><br><span class="line">						<span class="keyword">enum</span> single_ended_mode mode);</span><br><span class="line">	<span class="type">int</span>			(*to_irq)(<span class="keyword">struct</span> gpio_chip *chip,</span><br><span class="line">						<span class="type">unsigned</span> offset);</span><br><span class="line">	<span class="type">void</span>			(*dbg_show)(<span class="keyword">struct</span> seq_file *s,</span><br><span class="line">						<span class="keyword">struct</span> gpio_chip *chip);<span class="comment">//调试目的，显示 GPIO 引脚的状态</span></span><br><span class="line">	<span class="type">int</span>			base;<span class="comment">//chip的基地址</span></span><br><span class="line">	u16			ngpio;<span class="comment">//GPIO 引脚数量</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*<span class="type">const</span> *names;</span><br><span class="line">	<span class="type">bool</span>			can_sleep;</span><br><span class="line">	<span class="type">bool</span>			irq_not_threaded;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_GPIO_GENERIC)<span class="comment">// bgpio使能</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*read_reg)</span><span class="params">(<span class="type">void</span> __iomem *reg)</span>;</span><br><span class="line">	<span class="type">void</span> (*write_reg)(<span class="type">void</span> __iomem *reg, <span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*pin2mask)</span><span class="params">(<span class="keyword">struct</span> gpio_chip *gc, <span class="type">unsigned</span> <span class="type">int</span> pin)</span>;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dat;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_set;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_clr;</span><br><span class="line">	<span class="type">void</span> __iomem *reg_dir;</span><br><span class="line">	<span class="type">int</span> bgpio_bits;</span><br><span class="line">	<span class="type">spinlock_t</span> bgpio_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> bgpio_dir;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_GPIOLIB_IRQCHIP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">irqchip</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_domain</span>	*<span class="title">irqdomain</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_base;</span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	irq_handler;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		irq_default_type;</span><br><span class="line">	<span class="type">int</span>			irq_parent;</span><br><span class="line">	<span class="type">bool</span>			irq_need_valid_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*irq_valid_mask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span>	*<span class="title">lock_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_OF_GPIO)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">	<span class="type">int</span> of_gpio_n_cells;<span class="comment">//dts描述几个cells构成</span></span><br><span class="line">	<span class="type">int</span> (*of_xlate)(<span class="keyword">struct</span> gpio_chip *gc,</span><br><span class="line">			<span class="type">const</span> <span class="keyword">struct</span> of_phandle_args *gpiospec, u32 *flags);<span class="comment">//设备树中 GPIO 引脚的转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3><span id="2-1-3-gpio-desc">2.1.3 gpio_desc</span><a href="#2-1-3-gpio-desc" class="header-anchor">#</a></h3><p>在<code>gpio_device</code>中有一个<code>gpio_desc</code>数组，每一引脚有一项<code>gpio_desc</code>。</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/20.png" alt="image-20240818145531275"></p>
<h1><span id="3-gpio-zi-xi-tong-api">3 gpio子系统api</span><a href="#3-gpio-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi">3.1使用整数的GPIO传统方式</span><a href="#3-1-shi-yong-zheng-shu-de-gpio-chuan-tong-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-1-1-qing-qiu-he-pei-zhi">3.1.1 请求和配置</span><a href="#3-1-1-qing-qiu-he-pei-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求和释放GPIO</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span>* label)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_free</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断gpio释放可用</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">gpio_is_valid</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio为输入还是输出</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_input</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置gpio的去抖动时间，其中debounce以ms为单位</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_set_debounce</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">unsigned</span> debounce)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-du-qu-he-she-zhi-zhi">3.1.2 读取和设置值</span><a href="#3-1-2-du-qu-he-she-zhi-zhi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; <span class="comment">// value为bool值，0表示低电平，非0高电平</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用gpio_can_sleep()判断gpio线是否可能睡眠</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">gpio_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio没有连接到I2C或SPI等慢速总线上，不会导致睡眠，可以在原子上下文中使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_get_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_set_value_cansleep</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当gpio映射到irq时，使用方式如下gpio_to_irq，返回irq号，接下来可以使用request_irq申请irq</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_to_irq</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">irq_to_gpio</span><span class="params">(<span class="type">int</span> irq)</span></span><br></pre></td></tr></table></figure>
<h3><span id="3-1-3-gpiochip-cao-zuo">3.1.3 gpiochip操作</span><a href="#3-1-3-gpiochip-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpiochip_add</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//注册一个gpio_chip结构体，它描述了一组GPIO引脚及其操作函数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiochip_remove</span><span class="params">(<span class="keyword">struct</span> gpio_chip *chip)</span><span class="comment">//移除之前注册的gpio_chip。</span></span><br><span class="line"></span><br><span class="line">gpiochip_line_config<span class="comment">//配置gpio_chip中的特定引脚。</span></span><br><span class="line">gpiochip_request_own<span class="comment">//请求对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_request_unown<span class="comment">//释放对gpio_chip中的引脚的所有权。</span></span><br><span class="line">gpiochip_set<span class="comment">//为gpio_chip中的多个引脚设置值。</span></span><br><span class="line">gpiochip_clear<span class="comment">//清除gpio_chip中的多个引脚的值。</span></span><br><span class="line"></span><br><span class="line">gpiochip_set_direction<span class="comment">//为gpio_chip中的多个引脚设置方向。</span></span><br><span class="line">gpiochip_get_direction<span class="comment">//获取gpio_chip中引脚的方向。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi">3.2 基于描述符的GPIO方式</span><a href="#3-2-ji-yu-miao-shu-fu-de-gpio-fang-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo_device &#123;</span><br><span class="line">	compatible = <span class="string">&quot;acme,foo&quot;</span>;</span><br><span class="line">	[...];</span><br><span class="line">	led-gpios = &lt;&amp;gpio <span class="number">15</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//红色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">16</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//绿色</span></span><br><span class="line">				&lt;&amp;gpio <span class="number">17</span> GPIO_ACTIVE_HIGH&gt; <span class="comment">//蓝色</span></span><br><span class="line">				;</span><br><span class="line">	power-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">	reset-gpios = &lt;&amp;gpio <span class="number">1</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在代码中获取GPIO的方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取gpio的代码</span></span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get_index</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line">sruct gpio_desc * <span class="title function_">gpiod_get</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">char</span> *con_id,</span></span><br><span class="line"><span class="params">								<span class="keyword">enum</span> gpiod_flags flags)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_put</span><span class="params">(sruct gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用示例：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">red</span>, *<span class="title">green</span>, *<span class="title">blue</span>, *<span class="title">power</span>, *<span class="title">reset</span>;</span></span><br><span class="line">red = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">0</span>, GPIO_OUT_HIGH);</span><br><span class="line">green = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">1</span>, GPIO_OUT_HIGH);</span><br><span class="line">blue = gpiod_get_index(dev, <span class="string">&quot;led&quot;</span>, <span class="number">2</span>, GPIO_OUT_HIGH);</span><br><span class="line"></span><br><span class="line">power = gpiod_get(dev, <span class="string">&quot;power&quot;</span>, GPIO_OUT_HIGH);</span><br><span class="line">reset = gpiod_get(dev, <span class="string">&quot;reset&quot;</span>, GPIO_OUT_HIGH);</span><br></pre></td></tr></table></figure>

<p>其他类似的功能函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_input</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_direction_output</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_set_debounce</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">unsigned</span> debounce)</span>;</span><br><span class="line"><span class="comment">// 输出逻辑1</span></span><br><span class="line"><span class="comment">// 在Active-High的情况下它会输出高电平</span></span><br><span class="line"><span class="comment">// 在Active-Low的情况下它会输出低电平</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpiod_set_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc, <span class="type">int</span> val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpiod_get_value_cansleep</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者之间相互转换</span></span><br><span class="line"><span class="keyword">struct</span> gpio_desc *<span class="title function_">gpio_to_desc</span><span class="params">(<span class="type">unsigned</span> gpio)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">desc_to_gpio</span><span class="params">(<span class="keyword">struct</span> gpio_desc *desc)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/21.png" alt="image-20240818143109206"></p>
<p>无论是传统GPIO控制还是基于描述符的gpio方式，都是调用底层控制器gpio_chip的操作函数。</p>
<h2><span id="3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou">3.3 和设备树相关GPIO接口</span><a href="#3-3-he-she-bei-shu-xiang-guan-gpio-jie-kou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">gpio1: gpio1 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio2 : gpio2 &#123;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">foo-device &#123;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">2</span>&gt;</span><br><span class="line">				&lt;&amp;gpio1 <span class="number">17</span> <span class="number">0</span>&gt;;</span><br><span class="line">	reset-gpio = &lt;&amp;gpio1 <span class="number">30</span> <span class="number">0</span>&gt;;</span><br><span class="line">	cs-gpios = &lt;&amp;gpio2 <span class="number">10</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在传统使用gpio的方式中，需要获取gpio编号，获取方式如下：</span></span><br><span class="line"><span class="type">int</span> n_gpios = of_get_named_gpio_count(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br><span class="line"><span class="type">int</span> first_gpio = of_get_named_gpio(dev.of_node, <span class="string">&quot;cs-gpios&quot;</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ji-yu-sysfs-cao-zuo-gpio">4 基于sysfs操作gpio</span><a href="#4-ji-yu-sysfs-cao-zuo-gpio" class="header-anchor">#</a></h1><p><strong>声明GPIO口:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/export  <span class="comment">#/sys/class/gpio会生成gpio256目录</span></span><br><span class="line"><span class="built_in">echo</span> 256 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/22.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/23.png" alt="image"></p>
<p><strong>方向：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;in&quot;</span> &gt; direction    <span class="comment">#输入方向</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;out&quot;</span> &gt; direction   <span class="comment">#输出方向</span></span><br><span class="line"><span class="built_in">cat</span> direction</span><br></pre></td></tr></table></figure>
<p><strong>val:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; value</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; value</span><br><span class="line"><span class="built_in">cat</span> value</span><br></pre></td></tr></table></figure>

<p><strong>edge:</strong><br>表示中断的触发方式，edge文件有如下四个值：<code>&quot;none&quot;, &quot;rising&quot;,&quot;falling&quot;，&quot;both&quot;</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">none：<span class="comment">#表示引脚为输入，不是中断引脚</span></span><br><span class="line">rising：<span class="comment">#表示引脚为中断输入，上升沿触发</span></span><br><span class="line">falling：<span class="comment">#表示引脚为中断输入，下降沿触发</span></span><br><span class="line">both：<span class="comment">#表示引脚为中断输入，边沿触发</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;both&quot;</span> &gt; /sys/class/gpio/gpioN/edge</span><br></pre></td></tr></table></figure>
<h1><span id="5-gpio-zi-xi-tong-shi-li">5 gpio子系统示例</span><a href="#5-gpio-zi-xi-tong-shi-li" class="header-anchor">#</a></h1><p>以<code>nxp</code>官方<code>evk</code>公板<code>imx6ull-14x14-evk.dts</code>为例：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/24.png" alt="image"><br>重新定义了<code>iomuxc</code>引脚控制器，<code>evk</code>设备默认default状态对应的pins为<code>pinctrl_hog_1</code>, 配置3个引脚（<code>UART1_RTS_B, GPIO1_IO05, GPIO1_IO09</code>)信息。看起来是要做成sd卡的热插拔功能。<br>我们再找到描述sd的设备树节点：<code>usdhc1</code>和<code>usdhc2</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;usdhc1 &#123;</span><br><span class="line">         pinctrl-names = <span class="string">&quot;default&quot;</span>, <span class="string">&quot;state_100mhz&quot;</span>, <span class="string">&quot;state_200mhz&quot;</span>;</span><br><span class="line">         pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc1&gt;;</span><br><span class="line">         pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc1_100mhz&gt;;</span><br><span class="line">         pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc1_200mhz&gt;;</span><br><span class="line">         cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">         keep-power-in-suspend;</span><br><span class="line">         enable-sdio-wakeup;</span><br><span class="line">         vmmc-supply = &lt;&amp;reg_sd1_vmmc&gt;;</span><br><span class="line">         status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>iomuxc</code>控制器节点下有<code>usdhc1</code>要用的<code>pins</code>信息，包括<code>pinctrl_hog_1</code>，<code>pinctrl_usdhc1</code>，<code>pinctrl_usdhc1_100mhz</code>节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">     pinctrl_usdhc1: usdhc1grp &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x10071</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x17059</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x17059</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_100mhz: usdhc1grp100mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170b9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170b9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     pinctrl_usdhc1_200mhz: usdhc1grp200mhz &#123;</span><br><span class="line">             fsl,pins = &lt;</span><br><span class="line">                     MX6UL_PAD_SD1_CMD__USDHC1_CMD     <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_CLK__USDHC1_CLK     <span class="number">0x100f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA0__USDHC1_DATA0 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA1__USDHC1_DATA1 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA2__USDHC1_DATA2 <span class="number">0x170f9</span></span><br><span class="line">                     MX6UL_PAD_SD1_DATA3__USDHC1_DATA3 <span class="number">0x170f9</span></span><br><span class="line">             &gt;;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-1-gpio-kong-zhi-qi-dts-miao-shu">5.1 gpio控制器dts描述</span><a href="#5-1-gpio-kong-zhi-qi-dts-miao-shu" class="header-anchor">#</a></h2><p>前面讲的其实都还是<code>pinctrl</code>的内容，<code>usdhc1</code>有一个属性<code>cd-gpios</code>。这时就需要用到gpio控制器了，以<code>imx6ull</code>为例，gpio控制器描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Linux<span class="number">-4.9</span><span class="number">.88</span>/Documentation/devicetree/bindings/gpio$ ls -l fsl-imx-gpio.txt</span><br><span class="line"></span><br><span class="line">   * Freescale i.MX/MXC GPIO controller</span><br><span class="line">  </span><br><span class="line">   Required properties:</span><br><span class="line">   - compatible : Should be <span class="string">&quot;fsl,&lt;soc&gt;-gpio&quot;</span></span><br><span class="line">   - reg : Address and length of the <span class="keyword">register</span> <span class="built_in">set</span> <span class="keyword">for</span> the device</span><br><span class="line">   - interrupts : Should be the port interrupt shared by all <span class="number">32</span> pins, <span class="keyword">if</span></span><br><span class="line">     one number.  If two numbers, the first one is the interrupt shared</span><br><span class="line">     by low <span class="number">16</span> pins and the second one is <span class="keyword">for</span> high <span class="number">16</span> pins.</span><br><span class="line">   - gpio-controller : Marks the device node as a gpio controller.</span><br><span class="line">  - <span class="meta">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">    the second cell is used to specify the gpio polarity:</span><br><span class="line">        <span class="number">0</span> = active high</span><br><span class="line">        <span class="number">1</span> = active low</span><br><span class="line">  - interrupt-controller: Marks the device node as an interrupt controller.</span><br><span class="line">  - <span class="meta">#interrupt-cells : Should be 2.  The first cell is the GPIO number.</span></span><br><span class="line">    The second cell bits[<span class="number">3</span>:<span class="number">0</span>] is used to specify trigger type and level flags:</span><br><span class="line">        <span class="number">1</span> = low-to-high edge triggered.</span><br><span class="line">        <span class="number">2</span> = high-to-low edge triggered.</span><br><span class="line">        <span class="number">4</span> = active high level-sensitive.</span><br><span class="line">        <span class="number">8</span> = active low level-sensitive.</span><br><span class="line"> </span><br><span class="line">  Example:</span><br><span class="line"> </span><br><span class="line">gpio0: gpio@<span class="number">73f</span>84000 &#123;</span><br><span class="line">        compatible = <span class="string">&quot;fsl,imx51-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x73f84000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">        interrupts = &lt;<span class="number">50</span> <span class="number">51</span>&gt;;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">        interrupt-controller;</span><br><span class="line">        <span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打开具体的<code>imx6ull.dtsi</code>:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/25.png" alt="image"><br>打开芯片参考书册，刚好对应gpio1控制器：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/26.png" alt="image"></p>
<h2><span id="5-2-gpio-kong-zhi-qi-shi-yong-zhe">5.2 gpio控制器使用者</span><a href="#5-2-gpio-kong-zhi-qi-shi-yong-zhe" class="header-anchor">#</a></h2><p>回到<code>usdhc1</code>的属性<code>cd-gpios</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd-gpios = &lt;&amp;gpio1 <span class="number">19</span> GPIO_ACTIVE_LOW&gt;;</span><br></pre></td></tr></table></figure>

<p>表述使用gpio1控制器，由于该控制器的gpio-cells为2， 根据描述：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gpio-cells : Should be two.  The first cell is the pin number and</span></span><br><span class="line">the second cell is used to specify the gpio polarity:</span><br><span class="line">    0 = active high</span><br><span class="line">    1 = active low</span><br></pre></td></tr></table></figure>
<p>19表示<code>pin number</code>， <code>GPIO_ACTIVE_LOW</code>是一个宏定义：可以看到为1，也就是低电平有效<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/27.png" alt="image"></p>
<h3><span id="5-2-1-shi-yong-zhe-cao-zuo-liu-cheng">5.2.1 使用者操作流程</span><a href="#5-2-1-shi-yong-zhe-cao-zuo-liu-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path获取使用该gpio的节点</span><br><span class="line"><span class="number">2.</span> of_get_named_gpio，获取gpio编号</span><br><span class="line"><span class="number">3.</span> gpio_request,申请gpio</span><br><span class="line"><span class="number">4.</span> gpio_direction_set/gpio_direction_get</span><br><span class="line"><span class="number">5.</span> gpio_val_set</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led">5.2.1.1 dts自定义gpio控制器使用者（demo1,gpio_led）</span><a href="#5-2-1-1-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo1-gpio-led" class="header-anchor">#</a></h4><p>编写一个gpioled节点：</p>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/28.png" alt="image"><br>同时修改<code>iomuxc</code>节点，因为用到了<code>GPIO1_IO03</code>，要设置该pin脚为<code>gpio</code>：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/29.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_CNT			1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIOLED_NAME		<span class="string">&quot;gpioled&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 				0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 				1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line">	<span class="type">int</span> major;</span><br><span class="line">	<span class="type">int</span> minor;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span></span><br><span class="line">	<span class="type">int</span> led_gpio;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpioled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	gpioled.nd = of_find_node_by_path(<span class="string">&quot;/gpioled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;gpioled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">&quot;led-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(gpioled.led_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get led-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, gpioled.led_gpio);</span><br><span class="line"></span><br><span class="line">	ret = gpio_direction_output(gpioled.led_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (gpioled.major) &#123;</span><br><span class="line">		gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">		gpioled.major = MAJOR(gpioled.devid);</span><br><span class="line">		gpioled.minor = MINOR(gpioled.devid);</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;gpioled major=%d,minor=%d\r\n&quot;</span>,gpioled.major, gpioled.minor);	</span><br><span class="line">	</span><br><span class="line">	gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;gpioled.cdev, &amp;gpioled_fops);</span><br><span class="line">	</span><br><span class="line">	cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	gpioled.class = class_create(THIS_MODULE, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>, gpioled.devid, <span class="literal">NULL</span>, GPIOLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpioled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpioled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;gpioled.cdev);</span><br><span class="line">	unregister_chrdev_region(gpioled.devid, GPIOLED_CNT);</span><br><span class="line"></span><br><span class="line">	device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">	class_destroy(gpioled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>


<h4><span id="5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep">5.2.1.2 dts自定义gpio控制器使用者（demo2,beep）</span><a href="#5-2-1-2-dts-zi-ding-yi-gpio-kong-zhi-qi-shi-yong-zhe-demo2-beep" class="header-anchor">#</a></h4><p>evk公板的蜂鸣器。<code>BEEP</code>使用了<code>SNVS_TAMPER1</code>这个PIN，打开<code>imx6ull-alientek-emmc.dts</code>，<code>SNVS_TAMPER1</code>属于<code>iomuxc_snvs</code>这个<code>pin controller</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/30.png" alt="image"><br>在<code>iomuxc</code>节点的<code>imx6ul-evk</code>子节点下创建一个名为<code>“pinctrl_beep”</code>的子节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_beep: beepgrp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01 <span class="number">0x10B0</span> <span class="comment">/* beep */</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根节点<code>“/”</code>下创建<code>BEEP</code>节点：可以看到用到了引脚控制器的<code>pinctrl_beep</code>节点。同时使用gpio子系统，<code>beep-gpio</code>属性用到<code>gpio5</code>控制器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">beep &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;evk-beep&quot;</span>;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_beep&gt;;</span><br><span class="line">	beep-gpio = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>蜂鸣器使用的 PIN 为<code> SNVS_TAMPER1</code>，因此先检查 PIN 为<code>SNVS_TAMPER1 </code>这个 PIN 有没有被其他的 pinctrl 节点使用，如果有使用的话就要屏蔽掉，然后再检查 <code>GPIO5_IO01</code> 这个 GPIO 有没有被其他外设使用，如果有的话也要屏蔽掉。</p>
<p>输入<code>“make dtbs”</code>命令重新编译设备树，然后使用新编译出来的 <code>imx6ull-alientek-emmc.dtb</code> 文件启动 Linux 系统，进入<code>“/proc/device-tree”</code>目录中 查看<code>“beep”</code>节点是否存在：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/31.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_CNT			1		<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEP_NAME			<span class="string">&quot;beep&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPOFF 			0		<span class="comment">/* 关蜂鸣器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BEEPON 				1		<span class="comment">/* 开蜂鸣器 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> beep_gpio;			<span class="comment">/* beep所使用的GPIO编号		*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> <span class="title">beep</span>;</span>		<span class="comment">/* beep设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;beep; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">beep_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> beepstat;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">beep_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beepstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(beepstat == BEEPON) &#123;	</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);	<span class="comment">/* 打开蜂鸣器 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(beepstat == BEEPOFF) &#123;</span><br><span class="line">		gpio_set_value(dev-&gt;beep_gpio, <span class="number">1</span>);	<span class="comment">/* 关闭蜂鸣器 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">beep_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">beep_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = beep_open,</span><br><span class="line">	.write = beep_write,</span><br><span class="line">	.release = 	beep_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">beep_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：beep */</span></span><br><span class="line">	beep.nd = of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node not find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;beep node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、 获取设备树中的gpio属性，得到BEEP所使用的BEEP编号 */</span></span><br><span class="line">	beep.beep_gpio = of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(beep.beep_gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t get beep-gpio&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;led-gpio num = %d\r\n&quot;</span>, beep.beep_gpio);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO5_IO01为输出，并且输出高电平，默认关闭BEEP */</span></span><br><span class="line">	ret = gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;can&#x27;t set gpio!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (beep.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		beep.devid = MKDEV(beep.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(beep.devid, BEEP_CNT, BEEP_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;beep.devid, <span class="number">0</span>, BEEP_CNT, BEEP_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		beep.major = MAJOR(beep.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		beep.minor = MINOR(beep.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;beep major=%d,minor=%d\r\n&quot;</span>,beep.major, beep.minor);	</span><br><span class="line">	</span><br><span class="line">	beep.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;beep.cdev, &amp;beep_fops);</span><br><span class="line">	cdev_add(&amp;beep.cdev, beep.devid, BEEP_CNT);</span><br><span class="line"></span><br><span class="line">	beep.class = class_create(THIS_MODULE, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	beep.device = device_create(beep.class, <span class="literal">NULL</span>, beep.devid, <span class="literal">NULL</span>, BEEP_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(beep.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(beep.device);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">beep_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;beep.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(beep.devid, BEEP_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(beep.class, beep.devid);</span><br><span class="line">	class_destroy(beep.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(beep_init);</span><br><span class="line">module_exit(beep_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>核心代码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> of_find_node_by_path(<span class="string">&quot;/beep&quot;</span>);<span class="comment">//找到设备节点</span></span><br><span class="line"><span class="number">2.</span> of_get_named_gpio(beep.nd, <span class="string">&quot;beep-gpio&quot;</span>, <span class="number">0</span>);<span class="comment">//获取beep-gpio这个引脚编号</span></span><br><span class="line"><span class="number">3.</span> gpio_direction_output(beep.beep_gpio, <span class="number">1</span>);<span class="comment">//请求gpio并且配成输出</span></span><br><span class="line"><span class="number">4.</span> gpio_set_value(dev-&gt;beep_gpio, <span class="number">0</span>);<span class="comment">//设置高低电平</span></span><br></pre></td></tr></table></figure>

<p>注意这里并没有使用<code>pinctrl</code>, <code>pinctrl子系统</code>是内核启动时就对<code>pinctrl(也叫iomuxc)控制器</code>进行了配置，进行了IOMUX配置。因此<code>SNVS_TAMPER1</code>会复用成gpio模式。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/32.png" alt="image"></p>
<p>按键作为输入时：</p>
<pre><code>static int keyio_init(void)
&#123;
    keydev.nd = of_find_node_by_path(&quot;/key&quot;);
    if (keydev.nd== NULL) &#123;
        return -EINVAL;
    &#125;

    keydev.key_gpio = of_get_named_gpio(keydev.nd ,&quot;key-gpio&quot;, 0);
    if (keydev.key_gpio &lt; 0) &#123;
        printk(&quot;can&#39;t get key0\r\n&quot;);
        return -EINVAL;
    &#125;
    printk(&quot;key_gpio=%d\r\n&quot;, keydev.key_gpio);

    /* 初始化key所使用的IO */
    gpio_request(keydev.key_gpio, &quot;key0&quot;);	/* 请求IO */
    gpio_direction_input(keydev.key_gpio);	/* 设置为输入 */
    return 0;
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="clzz8q3fx00008wufghr9acq6" data-title="字符设备驱动-gpio子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:46:12.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/">字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</a></li>
<li><a href="#2-qu-dong-dai-ma">2 驱动代码</a></li>
<li><a href="#3-yong-hu-tai-dai-ma">3 用户态代码</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</span><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou" class="header-anchor">#</a></h1><p>以键盘<code>keyscan</code>为例，定义一个IP寄存器描述头文件，<code>IOCRREG</code>, <code>IOCWREG</code>定义了两个ioctl命令，用来读写寄存器。<code>struct msg</code>用来存放寄存器地址和值。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/1.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyscan register: addr + offset + mask */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config1			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config2			0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config3			0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config4			0xc</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_MASK				0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_OFFSET			4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_MASK			0x10</span></span><br><span class="line"><span class="keyword">struct</span> msg &#123;</span><br><span class="line">	<span class="built_in">long</span> unsigned <span class="built_in">int</span> addr;</span><br><span class="line">	unsigned <span class="built_in">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC &#x27;k&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, struct msg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, struct msg)</span></span><br></pre></td></tr></table></figure>

<h1><span id="2-qu-dong-dai-ma">2 驱动代码</span><a href="#2-qu-dong-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">keyscan_ioctl</span>(<span class="params"><span class="keyword">struct</span> file *file, unsigned <span class="built_in">int</span> cmd, unsigned <span class="built_in">long</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> msg m;</span><br><span class="line">	memset(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="keyword">void</span> __iomem* <span class="keyword">base</span> = dev-&gt;<span class="keyword">base</span>;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		m.data = readl(<span class="keyword">base</span> + m.addr);</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, read data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;m, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, write data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		writel(m.data, <span class="keyword">base</span> + m.addr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="literal">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>驱动先定义<code>IP base addr</code>，然后透过<code>ioctl</code>进行<code>arg</code>参数接收，确定<code>msg</code>中的<code>addr</code>和<code>data</code>, 接收<code>cmd</code>调用<code>writel, readl</code>进行读写。</p>
<h1><span id="3-yong-hu-tai-dai-ma">3 用户态代码</span><a href="#3-yong-hu-tai-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">clrsetbits_32</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> clear, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m.data = (m.data &amp; (~clear)) | <span class="built_in">set</span>;</span><br><span class="line">	ret = ioctl(fd, IOCWREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: write error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">read_reg</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">    m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read reg error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先实现基础读写函数进行寄存器读写，<code>reg_read</code>函数传入<code>addr</code>即可得到<code>val</code>, <code>clrsetbits_32</code>需要先读，在写入<code>val.</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_MASK(REG_NAME) keyscan_top_##REG_NAME##_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_OFFSET(REG_NAME) keyscan_top_##REG_NAME##_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_SET(REG_NAME, VAL)                                             \</span></span><br><span class="line">	clrsetbits_32(keyscan_top_<span class="meta">##REG_NAME, KEYSCAN_MASK(REG_NAME),          \</span></span><br><span class="line">			  (VAL) &lt;&lt; KEYSCAN_OFFSET(REG_NAME))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_GET(REG_NAME)                                                  \</span></span><br><span class="line">	((read_reg(keyscan_top_<span class="meta">##REG_NAME) &amp; KEYSCAN_MASK(REG_NAME)) &gt;&gt;        \</span></span><br><span class="line">	 KEYSCAN_OFFSET(REG_NAME))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/5.png" alt="image"></p>
<p>例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_GET(reg_fifo_count); </span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">read_reg(keycan_top_reg_fifo_count) &amp;</span><br><span class="line">    keycan_top_reg_fifo_count_MASK &gt;&gt; keycan_top_reg_fifo_count_OFFSET);</span><br></pre></td></tr></table></figure>

<p><code>reg_fifo</code>表示IP的某一个寄存器:</p>
<p>①<code>count</code>表示位域，因此对<code>OFFSET</code>定义成位域在该寄存器的偏移量（<code>count位域是bit[3:0]</code>）定义为0，因此<code>MASK</code>定义为<code>0xf</code>.<br>②同理<code>not_empty</code>也是一个位域，<code>bit[4]</code>，<code>OFFSET</code>定义成4，<code>MASK</code>定义成<code>0x10</code>，来屏蔽除<code>bit[4]</code>的其他bit.</p>
<p><code>KEYSCAN_GET(reg_fifo_count);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>count</code>位域的内容。<br><code>KEYSCAN_GET(reg_fifo_not_empty);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>not_empty</code>位域的内容</p>
<p>又例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_SET(reg_enable, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">clrsetbits_32(keycan_top_reg_enable, </span><br><span class="line">              keycan_top_reg_enable_MASK, </span><br><span class="line">              <span class="number">1</span> &lt;&lt; keycan_top_reg_enable_OFFSET);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/6.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_MASK			0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_OFFSET			8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_MASK			0xff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable				0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_OFFSET			16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_MASK			0x10000</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>offset</code>定义为<code>16</code>，mask定义为<code>0x10000</code>，用来屏蔽除<code>bit[16]</code>的其他位。<code>clrsetbits_32</code>会先读出该寄存器，然后对该位set1, mask掉其他位，再次写入该寄存器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" data-id="clzxsfb1q0000n4uf7a0jennv" data-title="字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-ioctl命令详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:11:24.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">字符设备驱动-ioctl命令详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ioctl">1 引入ioctl</a></li>
<li><a href="#2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</a></li>
<li><a href="#3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</a></li>
<li><a href="#4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</a></li>
<li><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</a><ul>
<li><a href="#5-1-app-shi-li">5.1 app示例</a></li>
<li><a href="#5-2-qu-dong-shi-li">5.2 驱动示例</a></li>
<li><a href="#5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</a><ul>
<li><a href="#5-3-1-sys-ioctl">5.3.1 sys_ioctl</a><ul>
<li><a href="#5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</a><ul>
<li><a href="#5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-yin-ru-ioctl">1 引入ioctl</span><a href="#1-yin-ru-ioctl" class="header-anchor">#</a></h1><p>一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能增添命令，通常以增设 <code>ioctl() </code>命令的方式实现。<br>对于ioctl这个系统调用接口，Linux的创始人在2.0版本之前并没有进行添加，仅有write和read两个接口，但是后来发现当需要去控制文件的某些操作的时候，很显然这两个接口根本不够用。所以才有了这个万能控制接口ioctl，但是作为Linux的创始人Linus本人一直排斥该接口，因为这个ioctl接口的在内核中的使用相当于对应用层开设了一个能够直接交互的窗口，很影响内核整体的权限控制，不过由于目前还暂时没有更好可以替代的方法，所以还是继续保留了这个接口的使用。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.png" alt="image"></p>
<h1><span id="2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</span><a href="#2-yong-hu-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, …)</span>;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数功能：<br>1.向硬件设备发送控制命令<br>2.还可以和硬件设备进行读或者写操作<br>参数：<br><code>fd：</code>文件描述符<br><code>request：</code>给硬件设备发送的控制命令<br><code>arg：</code>保存的就是用户缓冲区的首地址<br>返回值：执行成功返回0，执行失败返回-1, ioctl 最常见的<code> errorno</code> 值为<code> ENOTTY</code>（<code>error not a typewriter</code>)表示命令找不到。</p>
<h1><span id="3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</span><a href="#3-nei-he-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</span><a href="#4-ioctl-de-ming-ling-gou-cheng" class="header-anchor">#</a></h1><p> ioctl命令就是用户和驱动约定的一种协议， 理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段，如下图所示：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/4.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="built_in">dir</span>（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，</span><br><span class="line">	可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，</span><br><span class="line">	分别指示了四种访问模式：无数据、读数据、写数据、读写数据；</span><br><span class="line">2. size，涉及到 ioctl 函数第三个参数 arg ，占据14bit，指定了 arg 的数据类型及长度；</span><br><span class="line">3. <span class="built_in">type</span>（device <span class="built_in">type</span>），设备类型，占据 8 bit，可以为任意 char 型字符，</span><br><span class="line">	例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识；</span><br><span class="line">4. nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，</span><br><span class="line">	取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增</span><br></pre></td></tr></table></figure>

<p>通常而言，为了方便会使用<code>宏 _IOC() 衍生的接口</code>来直接定义 ioctl 命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ioctl.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS	8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let any architecture override either of the following before</span></span><br><span class="line"><span class="comment"> * including this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_SIZEBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_SIZEBITS	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_DIRBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_DIRBITS	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRMASK	((1 &lt;&lt; _IOC_NRBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEMASK	((1 &lt;&lt; _IOC_TYPEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEMASK	((1 &lt;&lt; _IOC_SIZEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRMASK	((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRSHIFT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direction bits, which any architecture can choose to override</span></span><br><span class="line"><span class="comment"> * before including this file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOC_WRITE means userland is writing and kernel is</span></span><br><span class="line"><span class="comment"> * reading. _IOC_READ means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_NONE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_NONE	0U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_WRITE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_WRITE	1U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_READ</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_READ	2U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPECHECK(t) (sizeof(t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to create numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOW means userland is writing and kernel is reading. _IOR</span></span><br><span class="line"><span class="comment"> * means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to decode ioctl numbers.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)		(((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)		(((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)		(((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)		(((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ...and for the drivers/sound files... */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN		(_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT		(_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT	((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK	(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT	(_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/6.png" alt="image"><br>除了<code>_IO/_IOR/_IOW/_IOW</code>等命令外，还支持反向解析 ioctl 命令的宏接口：主要就是利用Mask看是否4个位段是否越界,如果越界说明cmd构造的不合法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr) (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr) (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr) (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr) (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure>

<p>举个例子比如<img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/7.png" alt="image">，展开命令成一个<code>unsigned int</code>的 cmd整数为：(<code>字符D的ascii码为68</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&lt;&lt;<span class="number">30</span> | <span class="number">0</span>&lt;&lt;<span class="number">16</span> | <span class="number">68</span>&lt;&lt;<span class="number">8</span> | <span class="number">0x7</span>&lt;&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</span><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie" class="header-anchor">#</a></h1><h2><span id="5-1-app-shi-li">5.1 app示例</span><a href="#5-1-app-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/ioctl-test&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd, IOCINIT);</span><br><span class="line"><span class="comment">/* 往寄存器0x01写入数据0xef */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">my_msg.data = <span class="number">0xef</span>;</span><br><span class="line">ioctl(fd, IOCWREG, &amp;my_msg);</span><br><span class="line"><span class="comment">/* 读寄存器0x01 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">ret = ioctl(fd, IOCRREG, &amp;my_msg);</span><br></pre></td></tr></table></figure>
<p>构造了<code>IOCINIT</code> <code>IOCRREG</code> <code>IOCWREG</code>3个命令。</p>
<h2><span id="5-2-qu-dong-shi-li">5.2 驱动示例</span><a href="#5-2-qu-dong-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">my_msg</span>;</span></span><br><span class="line">	<span class="comment">/* 检查设备类型 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != IOC_MAGIC) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command type [%c] error!\n&quot;</span>, __func__, _IOC_TYPE(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查序数 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_NR(cmd) &gt; IOC_MAXNR) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command numer [%d] exceeded!\n&quot;</span>, __func__, _IOC_NR(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查访问模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_READ)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_WRITE, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_WRITE)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_READ, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">switch</span>(cmd) &#123; </span><br><span class="line">	<span class="comment">/* 初始化设备 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCINIT:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 读寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		msg-&gt;data = read_reg(msg-&gt;addr);</span><br><span class="line">		ret = copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;msg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 写寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		write_reg(msg-&gt;addr, msg-&gt;data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/8.png" alt="image"><br>首先定好3个命令，通过<code>arg</code>传入要写入的地址和数据or 要读的地址。然后检查<code>type</code>是否为<code>‘c’</code>, 检查命令号是否超过最大值3，检查方向是读还是写，利用<code>access_ok</code>判断用户地址是否可以访问。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/9.png" alt="image"><br>最后将用户地址arg的数据透过<code>copy_from_user</code>和<code>copy_to_user</code>进行拷贝。然后进行寄存器读写。</p>
<h2><span id="5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</span><a href="#5-3-ioctl-guo-cheng-xiang-jie" class="header-anchor">#</a></h2><p>在系统调用中，是通过<code>SWI(Software Interrupt)</code>的方式陷入内核态的, 首先通过软中断方式切换到内核态，ioctl的系统调用位于<code>arch/arm/include/asm/unistd.h</code>：</p>
<h3><span id="5-3-1-sys-ioctl">5.3.1 sys_ioctl</span><a href="#5-3-1-sys-ioctl" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl	(__NR_SYSCALL_BASE+ 54)</span></span><br></pre></td></tr></table></figure>

<p><code>arch/arm/kernel/calls.S</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 55 */</span>	CALL(sys_ioctl);</span><br></pre></td></tr></table></figure>
<p>调用<code>sys_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/include/linux.h</span><br><span class="line">	asmlinkage <span class="type">long</span> <span class="title function_">sys_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>


<p>然后调用<code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/include/linux/syscalls.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...)  SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINE3</code><br><code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code>就是<code>sys_ioctl</code>的定义:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/10.png" alt="image"><br><code>fget_light() </code>以及 <code>security_file_ioctl() </code>就是检验可操作安全性，所以<code>sys_ioctl</code>更多是调用更深一层接口 <code>do_vfs_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="type">int</span> error = -EBADF;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	filp = fget_light(fd, &amp;fput_needed);<span class="comment">//由fd得带filp指针</span></span><br><span class="line">	<span class="keyword">if</span> (!filp)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = security_file_ioctl(filp, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line">	error = do_vfs_ioctl(filp, fd, cmd, arg);</span><br><span class="line"> out_fput:</span><br><span class="line">	fput_light(filp, fput_needed);</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</span><a href="#5-3-1-1-do-vfs-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FIOCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONBIO:</span><br><span class="line">		error = ioctl_fionbio(filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOASYNC:</span><br><span class="line">		error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOQSIZE:</span><br><span class="line">		<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||</span><br><span class="line">			S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">			<span class="type">loff_t</span> res = inode_get_bytes(inode);</span><br><span class="line">			error = copy_to_user(argp, &amp;res, <span class="keyword">sizeof</span>(res)) ?</span><br><span class="line">					-EFAULT : <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOTTY;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIFREEZE:</span><br><span class="line">		error = ioctl_fsfreeze(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FITHAW:</span><br><span class="line">		error = ioctl_fsthaw(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FS_IOC_FIEMAP:</span><br><span class="line">		<span class="keyword">return</span> ioctl_fiemap(filp, arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIGETBSZ:</span><br><span class="line">		<span class="keyword">return</span> put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))<span class="comment">//是否为常规文件若是常规文件</span></span><br><span class="line">			error = file_ioctl(filp, cmd, arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = vfs_ioctl(filp, cmd, arg);<span class="comment">//调用vfs_ioctl</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</span><a href="#5-3-1-1-1-vfs-ioctl" class="header-anchor">#</a></h5><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">unlocked_ioctl</span><br><span class="line">	error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<span class="comment">//调用unlocked_ioctl()</span></span><br><span class="line">	<span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">		error = -EINVAL;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>最终调用对应驱动人员自己fops的unlocked_ioctl函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" data-id="clzxrltbn000180uf0uhodbue" data-title="字符设备驱动-ioctl命令详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-misc杂项设备" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T05:32:57.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/">字符设备驱动-misc杂项设备</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-misc-device">1 引入misc device</a><ul>
<li><a href="#1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</a></li>
<li><a href="#1-2-misc-device-fang-shi">1.2 misc device方式</a></li>
</ul>
</li>
<li><a href="#2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</a><ul>
<li><a href="#2-1-misc-init-guo-cheng">2.1 misc_init过程</a></li>
<li><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</a></li>
<li><a href="#2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</a></li>
<li><a href="#2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</a></li>
</ul>
</li>
<li><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</a><ul>
<li><a href="#3-1-yin-ru">3.1 引入</a><ul>
<li><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</a></li>
<li><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</a></li>
<li><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-misc-device">1 引入misc device</span><a href="#1-yin-ru-misc-device" class="header-anchor">#</a></h1><h2><span id="1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</span><a href="#1-1-chuan-tong-cdev-fang-shi" class="header-anchor">#</a></h2><details>
<summary>char_drv.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> led_major;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> * ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,</span><br><span class="line">    .open   =   led_drv_open,</span><br><span class="line">    .write	=	led_drv_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_setup_cdev</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err, devno = MKDEV(led_major, <span class="number">0</span>);<span class="comment">//index 为从设备号</span></span><br><span class="line">  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">  cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev.ops = &amp;led_drv_fops;</span><br><span class="line">  err = cdev_add(&amp;cdev, devno, <span class="number">1</span>);<span class="comment">//devno 为第一个设备号，1为数量</span></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot;Error %d adding&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">dev_t</span> devno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    devno=MKDEV(led_major,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(led_major)<span class="comment">//静态申请设备号</span></span><br><span class="line">        result=register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result = alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">        led_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        printk (KERN_WARNING <span class="string">&quot;hello: can&#x27;t get major number %d\n&quot;</span>, led_major);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    led_setup_cdev();</span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;led_class&quot;</span>);</span><br><span class="line">	dev = device_create(led_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;led_dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device create failed error code(%ld)\n&quot;</span>, PTR_ERR(dev));</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(led_class, dev);     <span class="comment">/* remove the device */</span></span><br><span class="line">    class_destroy(led_class);           <span class="comment">/* remove the device class */</span></span><br><span class="line">    cdev_del(&amp;cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_drv_init);</span><br><span class="line">module_exit(led_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
总结流程：

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A：创建设备号。MKDEV(major_no,<span class="number">0</span>)，其值为一个整数。因为linux中使用设备号来关联相应的设备和设备对于的驱动程序。</span><br><span class="line">B：注册设备号。register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>)</span><br><span class="line">    或者alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">C：初始化并关联file_operations结构体。  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">D：添加字符设备到内核。<span class="function"><span class="built_in">int</span> <span class="title">cdev_add</span>(<span class="params"><span class="keyword">struct</span> cdev *p, dev_t dev, unsigned count</span>)，</span></span><br><span class="line"><span class="function">E：移除字符设备及设备号。<span class="title">cdev_del</span>(<span class="params">&amp;cdev</span>)</span>; unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>kdev_t.h</code><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/1.png" alt="image"></p>
<p>上面涉及到的API可以在函数<code>linux/fs/char_dev.c</code>中找到定义。</p>
<h2><span id="1-2-misc-device-fang-shi">1.2 misc device方式</span><a href="#1-2-misc-device-fang-shi" class="header-anchor">#</a></h2><p>使用<code>misc_register</code>，在加载模块时会自动创建设备节点，为<code>主设备号为10</code>的字符设备。使用<code>misc_deregister</code>，在卸载模块时会自动删除设备节点。因此<code>无需调用cdev这一套框架</code>流程，无需调用<code>class_create</code>和<code>device_create</code>操作。<code>misc_register</code>时会自行调用了<code> class_create()</code>, <code>device_create() </code>因此<code>/sys/class/misc</code>类会被创建， <code>/dev/</code>下的设备节点也会自动创建。<br><code>/proc/misc</code>记录了系统中所有加载的misc设备：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/2.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> <span class="title">my_led</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="comment">//filp-&gt;private_data = &amp;my_led;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">leds_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">leds_fops</span> =</span>&#123;</span><br><span class="line">	.owner   = THIS_MODULE,</span><br><span class="line">	.read    = leds_read,</span><br><span class="line">	.ioctl   = leds_ioctl,</span><br><span class="line">	.open    = leds_open,</span><br><span class="line">	.release = leds_release</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> *<span class="title">miscdev</span> =</span> &amp;my_led.miscdev;</span><br><span class="line">	miscdev-&gt;minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	miscdev-&gt;name = <span class="string">&quot;misc_leds&quot;</span>,</span><br><span class="line">	miscdev-&gt;fops = &amp;leds_fops,</span><br><span class="line">	miscdev-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = misc_register(miscdev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	misc_deregister(&amp;my_led.miscdev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(dev_init);</span><br><span class="line">module_exit(dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</span><a href="#2-misc-za-xiang-she-bei-jie-xi" class="header-anchor">#</a></h1><p>源代码位置<code>driver/char/misc.c</code>，主设备号固定为10，所有的<code>miscdevice</code>设备形成了一个链表，对设备访问时内核根据次设备号查找对应的miscdevice设备，然后调用其<code>file_operations</code>结构中注册的文件操作接口进行操作。</p>
<h2><span id="2-1-misc-init-guo-cheng">2.1 misc_init过程</span><a href="#2-1-misc-init-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/3.png" alt="image"><br>misc子系统的初始化是利用<code>subsys_initcall</code>进行子系统初始化，首先创建<code>/proc/misc</code>条目，对应<code>cat /proc/misc</code>可以看到所有misc设备信息，<code>cat /proc/misc</code>于是就会调用<code>misc_seq_ops</code>中的<code>misc_seq_show</code>函数，可以看到刚好为misc设备的次设备号和名字信息。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/4.png" alt="image"><br>主设备号固定为10，调用<code>class_create</code>创建<code>/sys/class/misc</code>, 调用<code>register_chrdev</code>注册字符设备，添加<code>file_operations</code>。(<code>register_chrdev</code>如果传入主设备号，则静态注册，否则动态注册返回主设备号)<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/6.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/7.png" alt="image"></p>
<h2><span id="2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</span><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/8.png" alt="image"></p>
<p><code>MISC_DYNAMIC_MINOR = 255</code>，使用者调用<code>misc_register</code>时一般会次设备号传入<code>MISC_DYNAMIC_MINOR</code>，那么会自动分配次设备号；否则遍历<code>misc_list</code>链表，看这个次设备号以前有没有被用过，如果次设备号已被占有则退出返回-EBUSY。<br>得到这个次设备号后<code>set_bit(i, misc_minors);</code>设置位图中相应位为1。<code>device_create_with_groups</code>等同于<code>device_create</code>创建设备节点。<br>最后将list节点添加到<code>misc_list</code>链表中。<br><code>cat /sys/class</code>可以看到所有驱动中调用<code>class_creat()</code>函数的模块，<code>cat /sys/class/misc</code>则可以看到所有misc杂项驱动模块。<code>ls /dev/*</code>可以看到对应的设备节点<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/9.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/10.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/11.png" alt="image"></p>
<h2><span id="2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</span><a href="#2-3-misc-she-bei-xie-zai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/12.png" alt="image"><br>从<code>misc_list链表</code>中删除节点list,  然后删除设备节点。释放位图相应位清0，以便次设备号留给下一个模块使用。</p>
<h2><span id="2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</span><a href="#2-4-misc-she-bei-da-kai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/13.png" alt="image"></p>
<ol>
<li>当用户调用<code>open(&quot;/dev/xxx&quot;)</code>时，由于misc设备主设备号都为10，那么会统一进入到<code>misc_open</code>，那么会根据次设备号来区分不同的misc设备，首先<code>iminor(inode)</code>取出次设备号，<code>i_rdev</code>是对应具体misc设备的<code>设备号dev_t</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/14.png" alt="image"></li>
<li>然后遍历<code>misc_list</code>链表，找到与<code>minor次设备号</code>相匹配的<code>misc device</code>，找到后将<code>file_operations(简称fops)</code>暂存到<code>new_fops</code>。如果匹配不到，则请求加载这个次设备号对应的模块。<code>request_module</code>表示让linux系统的用户空间调用<code>/sbin/modprobe</code>函数加载名为<code>char-major-%d-%d</code>的模块。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/15.png" alt="image"><br>匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>(后面会介绍作用)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Place the miscdevice in the file&#x27;s</span></span><br><span class="line"><span class="comment">* private_data so it can be used by the</span></span><br><span class="line"><span class="comment">* file operations, including f_op-&gt;open below</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">file-&gt;private_data = c;</span><br></pre></td></tr></table></figure>
<p>最后将暂存的<code>new_fops</code>赋值给<code>file-&gt;f_op</code>，调用具体的misc模块的fops：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;f_op-&gt;open(inode, file)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/16.png" alt="image"></p>
<h1><span id="3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</span><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi" class="header-anchor">#</a></h1><h2><span id="3-1-yin-ru">3.1 引入</span><a href="#3-1-yin-ru" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">dwa_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</span><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei" class="header-anchor">#</a></h3><p>可以看到如果我们想要重file_oprations获取设备入口，可以通过如下方式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> xxx_dev *m = container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br></pre></td></tr></table></figure>
<p>前面2.4讲过了匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>.</p>
<h3><span id="3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</span><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	m = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> xxx_dev, cdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inode</code>的<code>i_cdev</code>指向的即为<code>cdev</code>结构体。调用<code>container_of</code>即可获取设备信息。</p>
<h3><span id="3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</span><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>* <span class="title">res</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">keyscan_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">uint32_t</span> res_size = (<span class="type">uint32_t</span>)resource_size(m-&gt;res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	file-&gt;private_data = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file-&gt;private_data = m</code>保存设备信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/" data-id="clzxrltbm000080ufh39mfp2u" data-title="字符设备驱动-misc杂项设备" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-mmap驱动应用实例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T15:21:52.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">字符设备驱动-mmap驱动应用实例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</a></li>
<li><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</a></li>
<li><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</a><ul>
<li><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</a><ul>
<li><a href="#3-1-1-copy-on-write">3.1.1 copy on write</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</span><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing" class="header-anchor">#</a></h1><ol>
<li>确定物理地址</li>
<li>确定属性：是否使用 <code>cache、 buffer</code></li>
<li>建立映射关系</li>
</ol>
<p>参考 Linux 驱动源文件代码：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/2.png" alt="image"><br>我们要验证mmap功能，在驱动程序中申请一个 8K 的 buffer，让 APP 通过 mmap 能直接访问。</p>
<h1><span id="2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</span><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi" class="header-anchor">#</a></h1><p>linux内核中常用的内存申请方式：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>分配到的内存物理地址是连续的</td>
</tr>
<tr>
<td>kzalloc</td>
<td>分配到的内存物理地址是连续的，内容清 0</td>
</tr>
<tr>
<td>vmalloc</td>
<td>分配到的内存物理地址不保证是连续的</td>
</tr>
<tr>
<td>vzalloc</td>
<td>vzalloc 分配到的内存物理地址不保证是连续的，内容清 0</td>
</tr>
</tbody></table>
<p>我们在 mmap 时应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，mmap后 APP 才可以使用同一个基地址去访问这块内存。 (如果物理地址不连续，就要执行多次 mmap 了)</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/pgtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *kernel_buf;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsiz = <span class="number">1024</span>*<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_to_user(buf, kernel_buf, MIN(bufsiz, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(bufsiz, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获得物理地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line">	<span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">	vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">/* map */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;mmap remap_pfn_range failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = hello_drv_open,</span><br><span class="line">	.read    = hello_drv_read,</span><br><span class="line">	.write   = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line">	.mmap    = hello_drv_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	kernel_buf = kmalloc(bufsiz, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">strcpy</span>(kernel_buf, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">	hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">	err = PTR_ERR(hello_class);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(hello_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	kfree(kernel_buf);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>分析：init时，驱动使用kmalloc分配8K空间(物理地址连续), 初始化为<code>”old“</code>字符串。实现read，write函数。mmap函数中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得物理地址 */</span></span><br><span class="line">unsigned <span class="built_in">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line"><span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">/*映射*/</span></span><br><span class="line">remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT, vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/3.png" alt="image"></p>
<p><code>pgprot_writecombine</code>设置属性为<code>Non-cached buffered (NCB)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;asm/pgtable.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_noncached(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRnE) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_writecombine(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_NORMAL_NC) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_device(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRE) | PTE_PXN | PTE_UXN)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/4.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/5.png" alt="image"></p>
<p>注意：<code>remap_pfn_range</code> 中，<code>pfn </code>的意思是<code>“ Page Frame Number”</code>。在 Linux 中，整个物理地址空间可以分为第 0 页、第 1 页、第 2 页，诸如此类，这就是 pfn。假设每页大小是 4K，那么给定物理地址<code> phy</code>，它的<code> pfn = phy / 4096 = phy &gt;&gt; 12</code>。内核的 page 一般是 4K，但是也可以配置内核修改 page的大小。所以为了通用， <code>pfn = phy &gt;&gt; PAGE_SHIFT</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们的buf不是用<code>kmalloc</code>, 而是<code>vmalloc</code>，那么需要映射多次，每次映射一个<code>page 4k</code>.(MMU过程中内存以page为单位作为连续内存单元)<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/6.png" alt="image"></p>
<h1><span id="3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</span><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi" class="header-anchor">#</a></h1><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/* 1. 打开文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. mmap </span></span><br><span class="line"><span class="comment">	 * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment">	 *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment">	 * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment">	 *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment">	 *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment">	 *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buf =  mmap(<span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (buf == MAP_FAILED)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not mmap file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mmap address = 0x%x\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;buf origin data = %s\n&quot;</span>, buf); <span class="comment">/* old */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. write */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. read &amp; compare */</span></span><br><span class="line">	<span class="comment">/* 对于MAP_SHARED映射:  str = &quot;new&quot; </span></span><br><span class="line"><span class="comment">	 * 对于MAP_PRIVATE映射: str = &quot;old&quot; </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	read(fd, str, <span class="number">1024</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, str) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_SHARED映射，APP写的数据驱动可见</span></span><br><span class="line"><span class="comment">		 * APP和驱动访问的是同一个内存块</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare ok!\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_PRIVATE映射，APP写数据时, 是写入原来内存块的&quot;拷贝&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str = %s!\n&quot;</span>, str);  <span class="comment">/* old */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf = %s!\n&quot;</span>, buf);  <span class="comment">/* new */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);  <span class="comment">/* cat /proc/pid/maps */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	munmap(buf, <span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</span><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment"> *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment"> *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment"> *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment"> *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-copy-on-write">3.1.1 copy on write</span><a href="#3-1-1-copy-on-write" class="header-anchor">#</a></h3><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/7.png" alt="image"></p>
<pre><code>① mmap时使用MAP_PRIVATE
②③ 当写入mmap内存时，会copy这块内存
④写入新数据，会将数据写入新copy的内存
⑤读数据还是从旧的那块映射内存去读，因此这时会与buf中的数据不一样
</code></pre>
<p>根据上面的mmap应用示例来分析和验证<code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>的差异：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/8.png" alt="image"><br>先用<code>MAP_PRIVATE</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/9.png" alt="image"><br>再用<code>MAP_SHARED</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/10.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" data-id="clzww9otk0001nguf8pethpld" data-title="字符设备驱动-mmap驱动应用实例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-mmap机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T13:58:58.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/">字符设备驱动-mmap机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-mmap">1 引入mmap</a><ul>
<li><a href="#1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</a><ul>
<li><a href="#1-1-1-yin-ru-mmu">1.1.1 引入MMU</a></li>
<li><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</a><ul>
<li><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</a><ul>
<li><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ye-biao-ying-she">3 页表映射</a><ul>
<li><a href="#3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</a></li>
<li><a href="#3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</a></li>
</ul>
</li>
<li><a href="#4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</a><ul>
<li><a href="#4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</a></li>
<li><a href="#4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</a><ul>
<li><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</a><ul>
<li><a href="#4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-mmap">1  引入mmap</span><a href="#1-yin-ru-mmap" class="header-anchor">#</a></h1><p>应用程序和驱动程序之间传递数据时，可以通过 read、write 函数进行, 用户态和内核态的数据交互一般用<code>copy_from_user</code>,<code>copy_to_user</code>。这种方式在数据量比较小时没什么问题；但是数据量比较大时效率就太低了。比如更新 LCD 显示时，如果每次都让 APP 传递一帧数据给内核，假设 LCD 采用<code>1024x600x32 bpp </code>的格式，一帧数据就有<code>1024x600x32/8=2.3MB</code> 左右,而且一般为了显示动态画面，LDC输出fps要求是<code>60fps or 30 fps</code>，那么一秒数据量为<code>30x2.3 = 70M</code>左右，显然<code>copy_from_user</code>，<code>copy_to_user</code>的方式不再适合。<br>改进的方法就是让程序可以直接读写驱动程序中的 buffer，这可以通过mmap 实现(memory map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h2><span id="1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</span><a href="#1-1-nei-cun-ying-she-xian-xiang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, &amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PC 上如下编译(必须静态编译)：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -staitc</span><br></pre></td></tr></table></figure>
<p>分别后台执行 test 程序 2 次。最后执行 ps，可以看到这 2 个程序同时存在，这 2 个程序里 a 变量的地址相同，但是值不同。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 个程序同时运行，它们的变量a的地址都是一样的：0x6bc3a0；</span><br><span class="line">2 个程序同时运行，它们的变量a的值是不一样的，一个是 111，另一个是 123。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-yin-ru-mmu">1.1.1 引入MMU</span><a href="#1-1-1-yin-ru-mmu" class="header-anchor">#</a></h3><p>来分析一下：<br>2个程序同时在内存中运行，它们的值不一样，所以变量 a 的物理内存地址肯定不同（2个变量存放不是同一个地方）；<br>但是打印出来的变量 a 的地址却是一样的。怎么回事？<br>这里要引入<strong>虚拟地址</strong>的概念：CPU 发出的地址是虚拟地址，它经过<code>MMU(Memory Manage Unit，内存管理单元)</code>映射到物理地址上，对于不同进程的同一个虚拟地址，MMU 会把它们映射到不同的物理地址。<br>总结:虽然虚拟地址一样，但物理地址不一样，这个是mmu的功劳，将同一虚拟地址映射到不同物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前运行的是 app1 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr1，用 paddr1 去访问内存。</span><br><span class="line">当前运行的是 app2 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr2，用 paddr2 去访问内存。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</span><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian" class="header-anchor">#</a></h3><p>MMU 负责把虚拟地址映射为物理地址，虚拟地址映射到哪个物理地址去？可以执行<code>ps</code>命令查看进程 ID，然后执行<code>“cat /proc/[PID]/maps”</code>得到虚拟地址空间映射关系。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00400000</span><span class="number">-004b</span>6000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>6000<span class="number">-006b</span>c000 rw-p <span class="number">000b</span>6000 <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>c000<span class="number">-006b</span>d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">021</span>c8000<span class="number">-021</span>eb000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</span><br><span class="line"><span class="number">7f</span>fe18738000<span class="number">-7f</span>fe18759000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fe187f9000<span class="number">-7f</span>fe187fc000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</span><br><span class="line"><span class="number">7f</span>fe187fc000<span class="number">-7f</span>fe187fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>第一行地址范围显示权限为可读可执行，表示该程序<code>代码段（.text）</code><br>第二行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code><br>第三行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code>刚才变量a地址就在这段地址范围内<br>第四行地址范围是<code>堆空间（.heap段）</code>,malloc的内存就会处于这段<br>第5行地址范围是<code>栈空间（.stack段）</code>,局部变量处于这段<br>p表示<code>private</code>, s表示<code>share</code>, 再来看一个使用动态库的进程，比如bash进程：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</span><a href="#2-mmap-nei-he-tai-de-miao-shu" class="header-anchor">#</a></h1><h2><span id="2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</span><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct" class="header-anchor">#</a></h2><p>每一个 APP对应了很多虚拟地址空间，比如栈空间，堆空间，数据段，代码段等,也叫做进程地址空间<code>（mm_strcut）</code>。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<p>因此在内核里都有一个 tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每个 APP 在内核中都有一个 task_struct 结构体，它用来描述一个进程；</span><br><span class="line"><span class="number">2.</span> 每个 APP 都要占据内存，在 task_struct 中用 mm_struct 来管理进程占用的内存；</span><br><span class="line"><span class="number">3.</span> 内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，</span><br><span class="line">用 pgd 来描述对应的物理地址。(注意：pgd，Page Global Directory，页目录)</span><br><span class="line"><span class="number">4.</span> 每个 APP 都有一系列的 VMA：virtual memory，即mmap会指向vm_area_struct, </span><br><span class="line">比如 APP 含有代码段、数据段、BSS 段、栈等等，还有共享库。这些单元会保存在内存里，</span><br><span class="line">它们的地址空间不同，权限不同(代码段是只读的可运行的、数据段可读可写)，内核用一系列的 vm_area_struct 来描述它们。</span><br><span class="line"><span class="number">6.</span> vm_area_struct 中的 vm_start、vm_end 是虚拟地址。</span><br><span class="line"><span class="number">7.</span> vm_area_struct 中虚拟地址如何映射到物理地址去？ 每一个 APP 的虚拟地址可能相同，</span><br><span class="line">物理地址不相同，这些对应关系保存在 pgd 中。</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</span><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu" class="header-anchor">#</a></h3><p>每个进程有一个<code>task_struct</code>和一个<code>mm_struct</code>, 其中<code>mm_struct</code>中的mmap对应<code>vm_area_struct</code>虚拟内存区域：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png" alt="image-20240816222839173"></p>
<p>可以看到<code>mm_struct</code>每一段都对应一块<code>vm_area_struct</code>。</p>
<h1><span id="3-ye-biao-ying-she">3 页表映射</span><a href="#3-ye-biao-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<p>页表是存在<code>ddr</code>中的一段连续地址空间，页表里面存放了要映射的物理地址集合，页表分为很多个页表项。<br>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址可以找到第 1 个页表，从第 1 个页表里就可以知道这个虚拟地址对应的物理地址。一级页表里地址映射的最小单位是 1M。<br>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2 级页表在哪里；再取出第 2 级页表，从第 2 个页表里才能确定这个虚拟地址对应的物理地址。二级页表地址映射的最小单位有 4K、1K，Linux 使用 4K。<br><strong>一级页表项里的内容，决定了它是指向一块物理内存，还是指问二级页表</strong>，一个页表项格式如下图：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png" alt="image"></p>
<h2><span id="3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</span><a href="#3-1-yi-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>arm32系统中，一个页表项占4个byte, 32bit,它分为一级页表项和二级页表项，通过<code>bit[1:0]</code>区分，一级页表项保存有物理地址，用<code>bit[31:20]</code> 共12位表示段基地址，有1M物理内存。比如cpu发出虚拟地址<code>0x12345678</code>, MMU通过<code>bit[31:20]</code>发现为0x123,也就是从第0x123个页表项中找到<code>Section Base Address</code>, 比如第0个页表项中物理及地址为<code>0x8000,0000</code>， 那么第0x123个页表项目物理基地址就是<code>0x123 * 1M + 0x8000,0000</code>,也就是<code>0x9230,0000</code>, 因为每一个一级页表项物理内存大小为1M.<br>段内偏移是 <code>0x45678</code>，那么最终通过一级页表映射最终映射到物理地址就为<code>0x0x9230,0000 + 0x45678</code>,也就是<code>0x9234,5678</code>。<br><code>Section Base Address</code>的数量为多少呢？一共12bit，也就是4096个，每一个1级页表项大小为1M, 因此总共可表示4G。对于 32 位的系统，虚拟地址空间有 4G，<code>4G/1M=4096</code>。所以一级页表要映射整个 4G 空间的话，刚好需要 4096 个页表项。<br>所以 CPU 要访问虚拟地址 0x12345678 时，实际上访问的是 0x81045678 的物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png" alt="image"></p>
<h2><span id="3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</span><a href="#3-2-er-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>一级页表项每项有1M空间, 一级页表映射时是吧虚拟地址的1M映射到物理地址的1M连续空间，但有时我们的程序没有那么大，显然用1M太浪费空间。 那么引入二级页表映射来映射更小的块，对于二级页表，每一个页可以是1K, 4K，64K， Linux系统一般使用4K, 对应<code>Small Page</code>, 64K对应的是大页（<code>Large Page</code>）, 1K对应的是Tine Page(一般很少用)。<br><strong>二级页表映射过程：</strong><br>首先设置好一级页表、二级页表，并且把一级页表的首地址告诉 MMU,比如<code>0x8000,0000</code>。<br>二级页表首先也是要经过一级页表映射，用<code>bit[31:20] </code>共12位表示段基地址，找到对应的一级页表项比如<code>0x123</code>项，通过这一项里面的<code>bit[1:0]</code>发现它是一个二级页表项（注意不再是取出1M的物理地址），然后根据二级页表项的<code>bit[19：12]</code>这8位得到二级页表是得到索引0x45,表示为第0x45个二级页表项。从这个二级页表项中取出里面的物理地址，比如为addr。<br>二级页表格式如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png" alt="image"></p>
<p>可以看到里面含有<code>64k(Large Page) 4k(Small Page）</code>或 <code>1K(Tine) </code>物理空间的基地址<code> page base addr</code>，假设从第0x45个二级页表项取出的物理地址为<code>0x8188,9000</code>。然后<code>offset=0x678</code>, 那么它跟 <code>vaddr[11:0] </code>组 合 得 到 物 理 地 址 ：<code> 0x8188,9000 + 0x678 = 0x8188,9678</code>，所以 CPU 要访问虚拟地址 <code>0x1234,5678 </code>时，实际上访问的是<code>0x8188,9678</code>的物理地址, 根据<code>bit[1:0]</code>得到映射的大小为<code>4K(linux Small Page)</code>。假如这里不使用二级页表映射，理论去计算对应物理地址则会是<code>0x8180,0000</code>往后1M内存，显然浪费了。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png" alt="image"></p>
<h1><span id="4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</span><a href="#4-mmap-han-shu-diao-yong-guo-cheng" class="header-anchor">#</a></h1><p>从上面内存映射的过程可以知道，要给 APP 新开劈一块虚拟内存，并且让它指向某块内核buffer，我们要做这些事：</p>
<ol>
<li>得到一个 <code>vm_area_struct</code>，它表示 APP 的一块虚拟内存空间：<br> 很 幸 运 ， APP 调 用 mmap 系 统 函 数 时 ， 内 核 就 帮 我 们 构 造 了 一 个<code>vm_area_stuct </code>结构体。里面含有虚拟地址的地址范围、权限，属性。</li>
<li>确定物理地址：<br> 你想映射某个内核 buffer，你需要得到它的物理地址，这得由你提供。</li>
<li>给<code>vm_area_struct</code>和物理地址建立映射关系</li>
</ol>
<p>比如APP 里调用 mmap 时，导致的内核相关函数调用过程如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>可以传入一个addr虚拟地址，需要用户自己malloc。也可以将addr设置为NULL, 让linux内核帮你产生一段内存映射，返回虚拟地址给你。<br>内核得到可用的虚拟地址后会分配一个<code>vm_area_struct</code>, 用来描述一块虚拟地址空间，里面有这块虚拟地址空间的起始地址、结束地址、权限信息。最后会调用驱动里面的mmap函数，参数为刚刚分配的<code>vm_area_sruct</code>。<br>那么需要再驱动程序实现mmap函数，主要包括：</p>
<ol>
<li>提供物理地址</li>
<li>设置属性，<code>cache，buffer</code></li>
<li>给<code>vm_area_stuct</code>和物理地址建立映射</li>
</ol>
<h2><span id="4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</span><a href="#4-1-vm-area-struct-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct describes a virtual memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task. A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">	 * See vmf_insert_mixed_prot() for discussion.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br></pre></td></tr></table></figure>

<p>它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是<code>0~3G</code>，对应的物理页面都可以是不连续的.<br>主要成员有起始地址、结束地址、权限信息，属性信息。<br><code>vm_flags:</code>可读，可写，可执行权限，私有，共享等权限</p>
<p>常用<strong>vm_flags</strong>访问权限的取值说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VM_READ：可读</span><br><span class="line">VM_WRITE：可写</span><br><span class="line">VM_EXEC：可执行</span><br><span class="line">VM_SHARD：可多进程之间共享</span><br><span class="line">VM_IO：可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED：内存区域不可被换出</span><br><span class="line">VM_SEQ_READ：内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ：内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<p><code>vm_pgoff:</code>是否使用cache? 是否使用buffer？</p>
<h2><span id="4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</span><a href="#4-2-yin-ru-cache-he-buffer" class="header-anchor">#</a></h2><p>使用<code> mmap</code> 时，需要有<code>cache、 buffer</code>的知识。下图是 CPU 和内存之间的关系，有<code> cache、 buffer</code>(写缓冲器)。 Cache 是一块高速内存；写缓冲器相当于一个 FIFO，可以把多个写操作集合起来一次写入内存。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png" alt="image"></p>
<h3><span id="4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</span><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing" class="header-anchor">#</a></h3><p>当程序运行时有<code>“局部性原理”</code>，这又分为<strong>时间局部性、空间局部性</strong>。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间局部性：</strong><br>a++在很短的时间内被重复写了100次，与此同时i也被访问了100次，像这种在某个时间点访问了存储器的特定位置，反复地访问这个位置被称为<code>“时间局部性”</code>。<br><strong>空间局部性：</strong><br>访问变量a的同时也访问了它周围临近变量i, 像这种访问了存储器的特定位置，很可能在不久的将来访问它附近的位置被称作<code>”空间局部性“</code>， 那么为什么不用<code>buffer or cache</code>把它一次性访问完呢？<br>根据<code>“局部性原理”</code>，引入 <code>cache</code>和<code>buffer</code>。</p>
<h4><span id="4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</span><a href="#4-2-1-1-cache-miss-he-cache-hit" class="header-anchor">#</a></h4><p>读数据：</p>
<ol>
<li>要读取内存指定addr处的数据时，先看看cache中有没有addr的数据，如果有则直接从cache返回数据，这一过程叫做<code>cache命中(cache hit)</code>。</li>
<li>假如cache中没有该addr的数据，触发<code>cache缺失 (cache miss)</code>, 那么会从addr读一段连续数据进去，注意：它不是仅仅读入一个数据，而是读入一行数据(cache line)。</li>
<li>那么CPU 短时间内很可能会再次用到甚至多次用到这个 addr 的数据或者周围临近的数据，那么就可以直接从cache快速的获取数据。这样<strong>弥补了时间和空间上的”局部性“</strong>。</li>
</ol>
<p>写数据：</p>
<ol>
<li>CPU 写数据时，可以<strong>直接写内存</strong>，这很慢；也可以先把数据<strong>写入 cache</strong>，这很快。</li>
<li>cache 中的数据终究是要写入内存的啊，这有 2 种写策略:<br> <strong>2.1 写通(write through)：</strong><br> ◆ 数据要同时写入 cache 和内存，所以 cache 和内存中的数据保持一致，但是它的效率很低。能改进吗？可以！使用“<strong>写缓冲器</strong>”：cache 大哥，你把数据给我就可以了，我来慢慢写，保证帮你写完。<br> ◆ 有些写缓冲器有“<strong>写合并</strong>”的功能，比如 CPU 执行了 4 条写指令：写第 0、 1、 2、 3 个字节，每次写 1 字节；写缓冲器会把这 4 个写操作合并成一个写操作：写 word。对于内存来说，这没什么差别，但是对于硬件寄存器，这就有可能导致问题。<br> ◆ 所以对于寄存器操作，不会启动 buffer 功能；对于内存操作，比如 LCD 的显存，可以启用 buffer 功能(cpu直接用<code>write buffer</code>进行操作<code>frame buffer内存</code>)<br> <strong>2.2 写回(write back)：</strong><br> ◆ 新数据只是写入<code> cache</code>，不会立刻写入内存， <code>cache </code>和内存中的数据并不一致。<br> ◆ 新数据写入 cache 时，这一行 cache 被标为<code>“脏” (dirty)</code>；当cache 不够用时，才需要把脏的数据写入内存。</li>
</ol>
<p>对内存或者变量进行写操作可以使用写回功能，可以大幅提高效率。但是要注意 cache 和内存中的数据很可能不一致。这在很多时间要小心处理：比如 CPU 产生了新数据， DMA 把数据从内存搬到网卡，这时候就要 CPU 执行命令先把新数据从 cache 刷到内存。反过来也是一样的， DMA 从网卡得过了新数据存在内存里， CPU 读数据之前先把 cache中的数据丢弃。下图举例说明哪些硬件可以用或者不能用cache：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png" alt="image"></p>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合(位于<code>arch\arm\include\asm\pgtable-2level.h</code>：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png" alt="image"></p>
<p>以s3c2440芯片为例，上面 4 种组合对应下表中的各项：</p>
<table>
<thead>
<tr>
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件；写操作通过 buffer 实现， CPU 不等待操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><code>Cached, write-through mode (WT)</code>，写通    ①读：<code>cache hit</code>时从 cahce 读数据； <code>cache miss </code>时已入一行数据到 cache；②写：通过 buffer 实现， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><code>Cached, write-back mode (WB)</code>，写回    ①读：<code> cache hit</code> 时从 cahce 读数据；<code>cache miss</code>时已入一行数据到 cache；②写：通过 buffer 实现， <code>cache hit</code> 时新数据不会到达硬件，而是在 cahce 中被标为 “脏”； <code>cache miss</code> 时，通过 buffer写入硬件， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
</tbody></table>
<p>◼ 第 1 种是不使用 cache 也不使用 buffer，读写时都直达硬件，这适合寄存器的读写。<br>◼ 第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer 进行优化，可能会有<code>“写合并”</code>，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。<br>◼ 第 3 种是使用 cache 不使用 buffer，就是<code>“ write through”</code>，适用于只读设备：在读数据时用 cache 加速，基本不需要写。<br>◼ 第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" data-id="clzww9otj0000ngufh5fqcv44" data-title="字符设备驱动-mmap机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 11px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>