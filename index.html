<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:46:12.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/">字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</a></li>
<li><a href="#2-qu-dong-dai-ma">2 驱动代码</a></li>
<li><a href="#3-yong-hu-tai-dai-ma">3 用户态代码</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou">1 用户态定义寄存器结构</span><a href="#1-yong-hu-tai-ding-yi-ji-cun-qi-jie-gou" class="header-anchor">#</a></h1><p>以键盘<code>keyscan</code>为例，定义一个IP寄存器描述头文件，<code>IOCRREG</code>, <code>IOCWREG</code>定义了两个ioctl命令，用来读写寄存器。<code>struct msg</code>用来存放寄存器地址和值。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/1.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyscan register: addr + offset + mask */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config1			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config2			0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config3			0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_keyscan_config4			0xc</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_count_MASK				0xf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty				0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_OFFSET			4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_fifo_not_empty_MASK			0x10</span></span><br><span class="line"><span class="keyword">struct</span> msg &#123;</span><br><span class="line">	<span class="built_in">long</span> unsigned <span class="built_in">int</span> addr;</span><br><span class="line">	unsigned <span class="built_in">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC &#x27;k&#x27;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, struct msg)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, struct msg)</span></span><br></pre></td></tr></table></figure>

<h1><span id="2-qu-dong-dai-ma">2 驱动代码</span><a href="#2-qu-dong-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/3.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">keyscan_ioctl</span>(<span class="params"><span class="keyword">struct</span> file *file, unsigned <span class="built_in">int</span> cmd, unsigned <span class="built_in">long</span> arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> msg m;</span><br><span class="line">	memset(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	<span class="keyword">void</span> __iomem* <span class="keyword">base</span> = dev-&gt;<span class="keyword">base</span>;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		m.data = readl(<span class="keyword">base</span> + m.addr);</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, read data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		<span class="keyword">if</span> (copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;m, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(&amp;m, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(m)))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;base_addr:0x%lx, offset:0x%lx, write data: 0x%x \n&quot;</span>, <span class="keyword">base</span>, m.addr, m.data);</span><br><span class="line">		writel(m.data, <span class="keyword">base</span> + m.addr);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="literal">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>驱动先定义<code>IP base addr</code>，然后透过<code>ioctl</code>进行<code>arg</code>参数接收，确定<code>msg</code>中的<code>addr</code>和<code>data</code>, 接收<code>cmd</code>调用<code>writel, readl</code>进行读写。</p>
<h1><span id="3-yong-hu-tai-dai-ma">3 用户态代码</span><a href="#3-yong-hu-tai-dai-ma" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">clrsetbits_32</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> clear, <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">	m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m.data = (m.data &amp; (~clear)) | <span class="built_in">set</span>;</span><br><span class="line">	ret = ioctl(fd, IOCWREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: write error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">read_reg</span><span class="params">(<span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">m</span>;</span></span><br><span class="line">	<span class="built_in">memset</span>(&amp;m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">    m.addr = addr;</span><br><span class="line">	ret = ioctl(fd, IOCRREG, &amp;m);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ioctl: read reg error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先实现基础读写函数进行寄存器读写，<code>reg_read</code>函数传入<code>addr</code>即可得到<code>val</code>, <code>clrsetbits_32</code>需要先读，在写入<code>val.</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_MASK(REG_NAME) keyscan_top_##REG_NAME##_MASK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_OFFSET(REG_NAME) keyscan_top_##REG_NAME##_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_SET(REG_NAME, VAL)                                             \</span></span><br><span class="line">	clrsetbits_32(keyscan_top_<span class="meta">##REG_NAME, KEYSCAN_MASK(REG_NAME),          \</span></span><br><span class="line">			  (VAL) &lt;&lt; KEYSCAN_OFFSET(REG_NAME))</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSCAN_GET(REG_NAME)                                                  \</span></span><br><span class="line">	((read_reg(keyscan_top_<span class="meta">##REG_NAME) &amp; KEYSCAN_MASK(REG_NAME)) &gt;&gt;        \</span></span><br><span class="line">	 KEYSCAN_OFFSET(REG_NAME))</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/5.png" alt="image"></p>
<p>例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_GET(reg_fifo_count); </span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">read_reg(keycan_top_reg_fifo_count) &amp;</span><br><span class="line">    keycan_top_reg_fifo_count_MASK &gt;&gt; keycan_top_reg_fifo_count_OFFSET);</span><br></pre></td></tr></table></figure>

<p><code>reg_fifo</code>表示IP的某一个寄存器:</p>
<p>①<code>count</code>表示位域，因此对<code>OFFSET</code>定义成位域在该寄存器的偏移量（<code>count位域是bit[3:0]</code>）定义为0，因此<code>MASK</code>定义为<code>0xf</code>.<br>②同理<code>not_empty</code>也是一个位域，<code>bit[4]</code>，<code>OFFSET</code>定义成4，<code>MASK</code>定义成<code>0x10</code>，来屏蔽除<code>bit[4]</code>的其他bit.</p>
<p><code>KEYSCAN_GET(reg_fifo_count);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>count</code>位域的内容。<br><code>KEYSCAN_GET(reg_fifo_not_empty);</code>最终就获取到了<code>reg_fifo</code>寄存器的<code>not_empty</code>位域的内容</p>
<p>又例如，当调用</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">KEYSCAN_SET(reg_enable, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//表示</span></span><br><span class="line">clrsetbits_32(keycan_top_reg_enable, </span><br><span class="line">              keycan_top_reg_enable_MASK, </span><br><span class="line">              <span class="number">1</span> &lt;&lt; keycan_top_reg_enable_OFFSET);</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/6.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_OFFSET			0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_row_mask_MASK			0xff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask			0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_OFFSET			8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_col_mask_MASK			0xff00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable				0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_OFFSET			16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> keyscan_top_reg_enable_MASK			0x10000</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>offset</code>定义为<code>16</code>，mask定义为<code>0x10000</code>，用来屏蔽除<code>bit[16]</code>的其他位。<code>clrsetbits_32</code>会先读出该寄存器，然后对该位set1, mask掉其他位，再次写入该寄存器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/" data-id="clzxsfb1q0000n4uf7a0jennv" data-title="字符设备驱动-用户态构造IP寄存器结构体和读写寄存器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-ioctl命令详解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T06:11:24.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">字符设备驱动-ioctl命令详解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-ioctl">1 引入ioctl</a></li>
<li><a href="#2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</a></li>
<li><a href="#3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</a></li>
<li><a href="#4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</a></li>
<li><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</a><ul>
<li><a href="#5-1-app-shi-li">5.1 app示例</a></li>
<li><a href="#5-2-qu-dong-shi-li">5.2 驱动示例</a></li>
<li><a href="#5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</a><ul>
<li><a href="#5-3-1-sys-ioctl">5.3.1 sys_ioctl</a><ul>
<li><a href="#5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</a><ul>
<li><a href="#5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-yin-ru-ioctl">1 引入ioctl</span><a href="#1-yin-ru-ioctl" class="header-anchor">#</a></h1><p>一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能增添命令，通常以增设 <code>ioctl() </code>命令的方式实现。<br>对于ioctl这个系统调用接口，Linux的创始人在2.0版本之前并没有进行添加，仅有write和read两个接口，但是后来发现当需要去控制文件的某些操作的时候，很显然这两个接口根本不够用。所以才有了这个万能控制接口ioctl，但是作为Linux的创始人Linus本人一直排斥该接口，因为这个ioctl接口的在内核中的使用相当于对应用层开设了一个能够直接交互的窗口，很影响内核整体的权限控制，不过由于目前还暂时没有更好可以替代的方法，所以还是继续保留了这个接口的使用。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/1.png" alt="image"></p>
<h1><span id="2-yong-hu-kong-jian-ioctl">2 用户空间 ioctl</span><a href="#2-yong-hu-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> request, …)</span>;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数功能：<br>1.向硬件设备发送控制命令<br>2.还可以和硬件设备进行读或者写操作<br>参数：<br><code>fd：</code>文件描述符<br><code>request：</code>给硬件设备发送的控制命令<br><code>arg：</code>保存的就是用户缓冲区的首地址<br>返回值：执行成功返回0，执行失败返回-1, ioctl 最常见的<code> errorno</code> 值为<code> ENOTTY</code>（<code>error not a typewriter</code>)表示命令找不到。</p>
<h1><span id="3-nei-he-kong-jian-ioctl">3 内核空间 ioctl</span><a href="#3-nei-he-kong-jian-ioctl" class="header-anchor">#</a></h1><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br></pre></td></tr></table></figure>
<h1><span id="4-ioctl-de-ming-ling-gou-cheng">4 IOCTL的命令构成</span><a href="#4-ioctl-de-ming-ling-gou-cheng" class="header-anchor">#</a></h1><p> ioctl命令就是用户和驱动约定的一种协议， 理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段，如下图所示：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/4.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="built_in">dir</span>（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，</span><br><span class="line">	可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，</span><br><span class="line">	分别指示了四种访问模式：无数据、读数据、写数据、读写数据；</span><br><span class="line">2. size，涉及到 ioctl 函数第三个参数 arg ，占据14bit，指定了 arg 的数据类型及长度；</span><br><span class="line">3. <span class="built_in">type</span>（device <span class="built_in">type</span>），设备类型，占据 8 bit，可以为任意 char 型字符，</span><br><span class="line">	例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识；</span><br><span class="line">4. nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，</span><br><span class="line">	取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增</span><br></pre></td></tr></table></figure>

<p>通常而言，为了方便会使用<code>宏 _IOC() 衍生的接口</code>来直接定义 ioctl 命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ioctl.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRBITS	8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEBITS	8</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Let any architecture override either of the following before</span></span><br><span class="line"><span class="comment"> * including this file.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_SIZEBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_SIZEBITS	14</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_DIRBITS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_DIRBITS	2</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRMASK	((1 &lt;&lt; _IOC_NRBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPEMASK	((1 &lt;&lt; _IOC_TYPEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZEMASK	((1 &lt;&lt; _IOC_SIZEBITS)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRMASK	((1 &lt;&lt; _IOC_DIRBITS)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NRSHIFT	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Direction bits, which any architecture can choose to override</span></span><br><span class="line"><span class="comment"> * before including this file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOC_WRITE means userland is writing and kernel is</span></span><br><span class="line"><span class="comment"> * reading. _IOC_READ means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_NONE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_NONE	0U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_WRITE</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_WRITE	1U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _IOC_READ</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IOC_READ	2U</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC(dir,type,nr,size) \</span></span><br><span class="line"><span class="meta">	(((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span></span><br><span class="line"><span class="meta">	 ((size) &lt;&lt; _IOC_SIZESHIFT))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPECHECK(t) (sizeof(t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Used to create numbers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> _IOW means userland is writing and kernel is reading. _IOR</span></span><br><span class="line"><span class="comment"> * means userland is reading and kernel is writing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR_BAD(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW_BAD(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* used to decode ioctl numbers.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr)		(((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr)		(((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr)		(((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr)		(((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ...and for the drivers/sound files... */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_IN		(_IOC_WRITE &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_OUT		(_IOC_READ &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_INOUT	((_IOC_WRITE|_IOC_READ) &lt;&lt; _IOC_DIRSHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_MASK	(_IOC_SIZEMASK &lt;&lt; _IOC_SIZESHIFT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCSIZE_SHIFT	(_IOC_SIZESHIFT)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/6.png" alt="image"><br>除了<code>_IO/_IOR/_IOW/_IOW</code>等命令外，还支持反向解析 ioctl 命令的宏接口：主要就是利用Mask看是否4个位段是否越界,如果越界说明cmd构造的不合法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_DIR(nr) (((nr) &gt;&gt; _IOC_DIRSHIFT) &amp; _IOC_DIRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_TYPE(nr) (((nr) &gt;&gt; _IOC_TYPESHIFT) &amp; _IOC_TYPEMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_NR(nr) (((nr) &gt;&gt; _IOC_NRSHIFT) &amp; _IOC_NRMASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOC_SIZE(nr) (((nr) &gt;&gt; _IOC_SIZESHIFT) &amp; _IOC_SIZEMASK)</span></span><br></pre></td></tr></table></figure>

<p>举个例子比如<img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/7.png" alt="image">，展开命令成一个<code>unsigned int</code>的 cmd整数为：(<code>字符D的ascii码为68</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&lt;&lt;<span class="number">30</span> | <span class="number">0</span>&lt;&lt;<span class="number">16</span> | <span class="number">68</span>&lt;&lt;<span class="number">8</span> | <span class="number">0x7</span>&lt;&lt;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1><span id="5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie">5 ioctl系统调用过程详解</span><a href="#5-ioctl-xi-tong-diao-yong-guo-cheng-xiang-jie" class="header-anchor">#</a></h1><h2><span id="5-1-app-shi-li">5.1 app示例</span><a href="#5-1-app-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/ioctl-test&quot;</span>, O_RDWR);</span><br><span class="line">ioctl(fd, IOCINIT);</span><br><span class="line"><span class="comment">/* 往寄存器0x01写入数据0xef */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">my_msg.data = <span class="number">0xef</span>;</span><br><span class="line">ioctl(fd, IOCWREG, &amp;my_msg);</span><br><span class="line"><span class="comment">/* 读寄存器0x01 */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;my_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">my_msg.addr = <span class="number">0x01</span>;</span><br><span class="line">ret = ioctl(fd, IOCRREG, &amp;my_msg);</span><br></pre></td></tr></table></figure>
<p>构造了<code>IOCINIT</code> <code>IOCRREG</code> <code>IOCWREG</code>3个命令。</p>
<h2><span id="5-2-qu-dong-shi-li">5.2 驱动示例</span><a href="#5-2-qu-dong-shi-li" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAGIC <span class="string">&#x27;c&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCINIT _IO(IOC_MAGIC, 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCRREG _IOR(IOC_MAGIC, 1, int)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCWREG _IOW(IOC_MAGIC, 2, int)<span class="comment">//定义3个cmd</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOC_MAXNR 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">test_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> <span class="title">my_msg</span>;</span></span><br><span class="line">	<span class="comment">/* 检查设备类型 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != IOC_MAGIC) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command type [%c] error!\n&quot;</span>, __func__, _IOC_TYPE(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查序数 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_NR(cmd) &gt; IOC_MAXNR) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;[%s] command numer [%d] exceeded!\n&quot;</span>, __func__, _IOC_NR(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 检查访问模式 */</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_READ)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_WRITE, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (_IOC_DIR(cmd) &amp; _IOC_WRITE)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5, 10, 0))</span></span><br><span class="line">		ret= !access_ok(VERIFY_READ, (<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		ret= !access_ok((<span class="type">void</span> __user *)arg, _IOC_SIZE(cmd));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	<span class="keyword">switch</span>(cmd) &#123; </span><br><span class="line">	<span class="comment">/* 初始化设备 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCINIT:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 读寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCRREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		msg-&gt;data = read_reg(msg-&gt;addr);</span><br><span class="line">		ret = copy_to_user((<span class="keyword">struct</span> msg __user *)arg, &amp;msg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">/* 写寄存器 */</span></span><br><span class="line">	<span class="keyword">case</span> IOCWREG:</span><br><span class="line">		ret = copy_from_user(&amp;msg, (<span class="keyword">struct</span> msg __user *)arg, <span class="keyword">sizeof</span>(my_msg));</span><br><span class="line">		<span class="keyword">if</span> (ret) </span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		write_reg(msg-&gt;addr, msg-&gt;data);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/8.png" alt="image"><br>首先定好3个命令，通过<code>arg</code>传入要写入的地址和数据or 要读的地址。然后检查<code>type</code>是否为<code>‘c’</code>, 检查命令号是否超过最大值3，检查方向是读还是写，利用<code>access_ok</code>判断用户地址是否可以访问。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/9.png" alt="image"><br>最后将用户地址arg的数据透过<code>copy_from_user</code>和<code>copy_to_user</code>进行拷贝。然后进行寄存器读写。</p>
<h2><span id="5-3-ioctl-guo-cheng-xiang-jie">5.3 ioctl过程详解</span><a href="#5-3-ioctl-guo-cheng-xiang-jie" class="header-anchor">#</a></h2><p>在系统调用中，是通过<code>SWI(Software Interrupt)</code>的方式陷入内核态的, 首先通过软中断方式切换到内核态，ioctl的系统调用位于<code>arch/arm/include/asm/unistd.h</code>：</p>
<h3><span id="5-3-1-sys-ioctl">5.3.1 sys_ioctl</span><a href="#5-3-1-sys-ioctl" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl	(__NR_SYSCALL_BASE+ 54)</span></span><br></pre></td></tr></table></figure>

<p><code>arch/arm/kernel/calls.S</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 55 */</span>	CALL(sys_ioctl);</span><br></pre></td></tr></table></figure>
<p>调用<code>sys_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/include/linux.h</span><br><span class="line">	asmlinkage <span class="type">long</span> <span class="title function_">sys_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>;</span><br></pre></td></tr></table></figure>


<p>然后调用<code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/include/linux/syscalls.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...)  SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)	asmlinkage long sys##name(__SC_DECL##x(__VA_ARGS__))</span></span><br></pre></td></tr></table></figure>

<p><code>SYSCALL_DEFINE3</code><br><code>SYSCALL_DEFINE3(ioctl, unsigned int, fd, unsigned int, cmd, unsigned long, arg)</code>就是<code>sys_ioctl</code>的定义:<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/10.png" alt="image"><br><code>fget_light() </code>以及 <code>security_file_ioctl() </code>就是检验可操作安全性，所以<code>sys_ioctl</code>更多是调用更深一层接口 <code>do_vfs_ioctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">	<span class="type">int</span> error = -EBADF;</span><br><span class="line">	<span class="type">int</span> fput_needed;</span><br><span class="line"></span><br><span class="line">	filp = fget_light(fd, &amp;fput_needed);<span class="comment">//由fd得带filp指针</span></span><br><span class="line">	<span class="keyword">if</span> (!filp)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = security_file_ioctl(filp, cmd, arg);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out_fput;</span><br><span class="line">	error = do_vfs_ioctl(filp, fd, cmd, arg);</span><br><span class="line"> out_fput:</span><br><span class="line">	fput_light(filp, fput_needed);</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-3-1-1-do-vfs-ioctl">5.3.1.1 do_vfs_ioctl</span><a href="#5-3-1-1-do-vfs-ioctl" class="header-anchor">#</a></h4><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> arg)</span> &#123;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> FIOCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONCLEX:</span><br><span class="line">		set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIONBIO:</span><br><span class="line">		error = ioctl_fionbio(filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOASYNC:</span><br><span class="line">		error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIOQSIZE:</span><br><span class="line">		<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||</span><br><span class="line">			S_ISLNK(inode-&gt;i_mode)) &#123;</span><br><span class="line">			<span class="type">loff_t</span> res = inode_get_bytes(inode);</span><br><span class="line">			error = copy_to_user(argp, &amp;res, <span class="keyword">sizeof</span>(res)) ?</span><br><span class="line">					-EFAULT : <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			error = -ENOTTY;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIFREEZE:</span><br><span class="line">		error = ioctl_fsfreeze(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FITHAW:</span><br><span class="line">		error = ioctl_fsthaw(filp);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FS_IOC_FIEMAP:</span><br><span class="line">		<span class="keyword">return</span> ioctl_fiemap(filp, arg);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> FIGETBSZ:</span><br><span class="line">		<span class="keyword">return</span> put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))<span class="comment">//是否为常规文件若是常规文件</span></span><br><span class="line">			error = file_ioctl(filp, cmd, arg);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			error = vfs_ioctl(filp, cmd, arg);<span class="comment">//调用vfs_ioctl</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-3-1-1-1-vfs-ioctl">5.3.1.1.1 vfs_ioctl</span><a href="#5-3-1-1-1-vfs-ioctl" class="header-anchor">#</a></h5><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error = -ENOTTY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!filp-&gt;f_op || !filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">unlocked_ioctl</span><br><span class="line">	error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);<span class="comment">//调用unlocked_ioctl()</span></span><br><span class="line">	<span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">		error = -EINVAL;</span><br><span class="line"> out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>最终调用对应驱动人员自己fops的unlocked_ioctl函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" data-id="clzxrltbn000180uf0uhodbue" data-title="字符设备驱动-ioctl命令详解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-misc杂项设备" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/" class="article-date">
  <time class="dt-published" datetime="2024-08-17T05:32:57.000Z" itemprop="datePublished">2024-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/">字符设备驱动-misc杂项设备</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-misc-device">1 引入misc device</a><ul>
<li><a href="#1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</a></li>
<li><a href="#1-2-misc-device-fang-shi">1.2 misc device方式</a></li>
</ul>
</li>
<li><a href="#2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</a><ul>
<li><a href="#2-1-misc-init-guo-cheng">2.1 misc_init过程</a></li>
<li><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</a></li>
<li><a href="#2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</a></li>
<li><a href="#2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</a></li>
</ul>
</li>
<li><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</a><ul>
<li><a href="#3-1-yin-ru">3.1 引入</a><ul>
<li><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</a></li>
<li><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</a></li>
<li><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-misc-device">1 引入misc device</span><a href="#1-yin-ru-misc-device" class="header-anchor">#</a></h1><h2><span id="1-1-chuan-tong-cdev-fang-shi">1.1 传统cdev方式</span><a href="#1-1-chuan-tong-cdev-fang-shi" class="header-anchor">#</a></h2><details>
<summary>char_drv.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> led_major;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> * ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv_fops</span> =</span> &#123;</span><br><span class="line">    .owner  =   THIS_MODULE,</span><br><span class="line">    .open   =   led_drv_open,</span><br><span class="line">    .write	=	led_drv_write,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_setup_cdev</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> err, devno = MKDEV(led_major, <span class="number">0</span>);<span class="comment">//index 为从设备号</span></span><br><span class="line">  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">  cdev.owner = THIS_MODULE;</span><br><span class="line">  cdev.ops = &amp;led_drv_fops;</span><br><span class="line">  err = cdev_add(&amp;cdev, devno, <span class="number">1</span>);<span class="comment">//devno 为第一个设备号，1为数量</span></span><br><span class="line">  <span class="keyword">if</span> (err)</span><br><span class="line">    printk(KERN_NOTICE <span class="string">&quot;Error %d adding&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">dev_t</span> devno;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    devno=MKDEV(led_major,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(led_major)<span class="comment">//静态申请设备号</span></span><br><span class="line">        result=register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        result = alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">        led_major = MAJOR(devno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        printk (KERN_WARNING <span class="string">&quot;hello: can&#x27;t get major number %d\n&quot;</span>, led_major);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    led_setup_cdev();</span><br><span class="line">    led_class = class_create(THIS_MODULE, <span class="string">&quot;led_class&quot;</span>);</span><br><span class="line">	dev = device_create(led_class, <span class="literal">NULL</span>, devno, <span class="literal">NULL</span>, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;led_dev&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dev)) &#123;</span><br><span class="line">		dev_err(dev, <span class="string">&quot;device create failed error code(%ld)\n&quot;</span>, PTR_ERR(dev));</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dev);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_drv_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    device_destroy(led_class, dev);     <span class="comment">/* remove the device */</span></span><br><span class="line">    class_destroy(led_class);           <span class="comment">/* remove the device class */</span></span><br><span class="line">    cdev_del(&amp;cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_drv_init);</span><br><span class="line">module_exit(led_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
总结流程：

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A：创建设备号。MKDEV(major_no,<span class="number">0</span>)，其值为一个整数。因为linux中使用设备号来关联相应的设备和设备对于的驱动程序。</span><br><span class="line">B：注册设备号。register_chrdev_region(devno,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>)</span><br><span class="line">    或者alloc_chrdev_region(&amp;devno,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;led1_dev&quot;</span>);<span class="comment">//动态申请设备号</span></span><br><span class="line">C：初始化并关联file_operations结构体。  cdev_init(&amp;cdev, &amp;led_drv_fops);</span><br><span class="line">D：添加字符设备到内核。<span class="function"><span class="built_in">int</span> <span class="title">cdev_add</span>(<span class="params"><span class="keyword">struct</span> cdev *p, dev_t dev, unsigned count</span>)，</span></span><br><span class="line"><span class="function">E：移除字符设备及设备号。<span class="title">cdev_del</span>(<span class="params">&amp;cdev</span>)</span>; unregister_chrdev_region(MKDEV(led_major,<span class="number">0</span>),<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><code>kdev_t.h</code><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/1.png" alt="image"></p>
<p>上面涉及到的API可以在函数<code>linux/fs/char_dev.c</code>中找到定义。</p>
<h2><span id="1-2-misc-device-fang-shi">1.2 misc device方式</span><a href="#1-2-misc-device-fang-shi" class="header-anchor">#</a></h2><p>使用<code>misc_register</code>，在加载模块时会自动创建设备节点，为<code>主设备号为10</code>的字符设备。使用<code>misc_deregister</code>，在卸载模块时会自动删除设备节点。因此<code>无需调用cdev这一套框架</code>流程，无需调用<code>class_create</code>和<code>device_create</code>操作。<code>misc_register</code>时会自行调用了<code> class_create()</code>, <code>device_create() </code>因此<code>/sys/class/misc</code>类会被创建， <code>/dev/</code>下的设备节点也会自动创建。<br><code>/proc/misc</code>记录了系统中所有加载的misc设备：<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/2.png" alt="image"></p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pci.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_dev</span> <span class="title">my_led</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_ioctl</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="comment">//filp-&gt;private_data = &amp;my_led;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">leds_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">leds_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count, <span class="type">loff_t</span> *f_pos)</span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">leds_fops</span> =</span>&#123;</span><br><span class="line">	.owner   = THIS_MODULE,</span><br><span class="line">	.read    = leds_read,</span><br><span class="line">	.ioctl   = leds_ioctl,</span><br><span class="line">	.open    = leds_open,</span><br><span class="line">	.release = leds_release</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> *<span class="title">miscdev</span> =</span> &amp;my_led.miscdev;</span><br><span class="line">	miscdev-&gt;minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">	miscdev-&gt;name = <span class="string">&quot;misc_leds&quot;</span>,</span><br><span class="line">	miscdev-&gt;fops = &amp;leds_fops,</span><br><span class="line">	miscdev-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> ret = misc_register(miscdev);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	misc_deregister(&amp;my_led.miscdev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(dev_init);</span><br><span class="line">module_exit(dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="2-misc-za-xiang-she-bei-jie-xi">2 misc杂项设备解析</span><a href="#2-misc-za-xiang-she-bei-jie-xi" class="header-anchor">#</a></h1><p>源代码位置<code>driver/char/misc.c</code>，主设备号固定为10，所有的<code>miscdevice</code>设备形成了一个链表，对设备访问时内核根据次设备号查找对应的miscdevice设备，然后调用其<code>file_operations</code>结构中注册的文件操作接口进行操作。</p>
<h2><span id="2-1-misc-init-guo-cheng">2.1 misc_init过程</span><a href="#2-1-misc-init-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/3.png" alt="image"><br>misc子系统的初始化是利用<code>subsys_initcall</code>进行子系统初始化，首先创建<code>/proc/misc</code>条目，对应<code>cat /proc/misc</code>可以看到所有misc设备信息，<code>cat /proc/misc</code>于是就会调用<code>misc_seq_ops</code>中的<code>misc_seq_show</code>函数，可以看到刚好为misc设备的次设备号和名字信息。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/4.png" alt="image"><br>主设备号固定为10，调用<code>class_create</code>创建<code>/sys/class/misc</code>, 调用<code>register_chrdev</code>注册字符设备，添加<code>file_operations</code>。(<code>register_chrdev</code>如果传入主设备号，则静态注册，否则动态注册返回主设备号)<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/5.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/6.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/7.png" alt="image"></p>
<h2><span id="2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng">2.2 misc设备注册misc_register过程</span><a href="#2-2-misc-she-bei-zhu-ce-misc-register-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/8.png" alt="image"></p>
<p><code>MISC_DYNAMIC_MINOR = 255</code>，使用者调用<code>misc_register</code>时一般会次设备号传入<code>MISC_DYNAMIC_MINOR</code>，那么会自动分配次设备号；否则遍历<code>misc_list</code>链表，看这个次设备号以前有没有被用过，如果次设备号已被占有则退出返回-EBUSY。<br>得到这个次设备号后<code>set_bit(i, misc_minors);</code>设置位图中相应位为1。<code>device_create_with_groups</code>等同于<code>device_create</code>创建设备节点。<br>最后将list节点添加到<code>misc_list</code>链表中。<br><code>cat /sys/class</code>可以看到所有驱动中调用<code>class_creat()</code>函数的模块，<code>cat /sys/class/misc</code>则可以看到所有misc杂项驱动模块。<code>ls /dev/*</code>可以看到对应的设备节点<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/9.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/10.png" alt="image"><br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/11.png" alt="image"></p>
<h2><span id="2-3-misc-she-bei-xie-zai-guo-cheng">2.3 misc设备卸载过程</span><a href="#2-3-misc-she-bei-xie-zai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/12.png" alt="image"><br>从<code>misc_list链表</code>中删除节点list,  然后删除设备节点。释放位图相应位清0，以便次设备号留给下一个模块使用。</p>
<h2><span id="2-4-misc-she-bei-da-kai-guo-cheng">2.4 misc设备打开过程</span><a href="#2-4-misc-she-bei-da-kai-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/13.png" alt="image"></p>
<ol>
<li>当用户调用<code>open(&quot;/dev/xxx&quot;)</code>时，由于misc设备主设备号都为10，那么会统一进入到<code>misc_open</code>，那么会根据次设备号来区分不同的misc设备，首先<code>iminor(inode)</code>取出次设备号，<code>i_rdev</code>是对应具体misc设备的<code>设备号dev_t</code>。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/14.png" alt="image"></li>
<li>然后遍历<code>misc_list</code>链表，找到与<code>minor次设备号</code>相匹配的<code>misc device</code>，找到后将<code>file_operations(简称fops)</code>暂存到<code>new_fops</code>。如果匹配不到，则请求加载这个次设备号对应的模块。<code>request_module</code>表示让linux系统的用户空间调用<code>/sbin/modprobe</code>函数加载名为<code>char-major-%d-%d</code>的模块。<br><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/15.png" alt="image"><br>匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>(后面会介绍作用)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Place the miscdevice in the file&#x27;s</span></span><br><span class="line"><span class="comment">* private_data so it can be used by the</span></span><br><span class="line"><span class="comment">* file operations, including f_op-&gt;open below</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">file-&gt;private_data = c;</span><br></pre></td></tr></table></figure>
<p>最后将暂存的<code>new_fops</code>赋值给<code>file-&gt;f_op</code>，调用具体的misc模块的fops：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file-&gt;f_op-&gt;open(inode, file)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/16.png" alt="image"></p>
<h1><span id="3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi">3 如何从fops中获取模块设备信息</span><a href="#3-ru-he-cong-fops-zhong-huo-qu-mo-kuai-she-bei-xin-xi" class="header-anchor">#</a></h1><h2><span id="3-1-yin-ru">3.1 引入</span><a href="#3-1-yin-ru" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">miscdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">dwa_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">xxx_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-fang-fa-1-dui-yu-misc-she-bei">3.1.1 方法1：（对于misc设备）</span><a href="#3-1-1-fang-fa-1-dui-yu-misc-she-bei" class="header-anchor">#</a></h3><p>可以看到如果我们想要重file_oprations获取设备入口，可以通过如下方式：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> xxx_dev *m = container_of(filp-&gt;private_data, <span class="keyword">struct</span> xxx_dev, miscdev);</span><br></pre></td></tr></table></figure>
<p>前面2.4讲过了匹配成功后<code>file-&gt;private_data = c;</code>表示将链表中匹配出的<code>miscdevice</code>作为<code>file-&gt;private_data</code>.</p>
<h3><span id="3-1-2-fang-fa-2-dui-yu-cdev-she-bei">3.1.2 方法2：（对于cdev设备）</span><a href="#3-1-2-fang-fa-2-dui-yu-cdev-she-bei" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line">	m = container_of(inode-&gt;i_cdev, <span class="keyword">struct</span> xxx_dev, cdev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>inode</code>的<code>i_cdev</code>指向的即为<code>cdev</code>结构体。调用<code>container_of</code>即可获取设备信息。</p>
<h3><span id="3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi">3.1.3方法3：xxx_open中保存设备信息</span><a href="#3-1-3-fang-fa-3-xxx-open-zhong-bao-cun-she-bei-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span>* <span class="title">res</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">keyscan_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xxx_dev</span> *<span class="title">m</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="type">uint32_t</span> res_size = (<span class="type">uint32_t</span>)resource_size(m-&gt;res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">xxx_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">	file-&gt;private_data = m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>file-&gt;private_data = m</code>保存设备信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/" data-id="clzxrltbm000080ufh39mfp2u" data-title="字符设备驱动-misc杂项设备" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-mmap驱动应用实例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T15:21:52.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">字符设备驱动-mmap驱动应用实例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</a></li>
<li><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</a></li>
<li><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</a><ul>
<li><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</a><ul>
<li><a href="#3-1-1-copy-on-write">3.1.1 copy on write</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mmap-qu-dong-yao-zuo-de-shi-qing">1 mmap驱动要做的事情</span><a href="#1-mmap-qu-dong-yao-zuo-de-shi-qing" class="header-anchor">#</a></h1><ol>
<li>确定物理地址</li>
<li>确定属性：是否使用 <code>cache、 buffer</code></li>
<li>建立映射关系</li>
</ol>
<p>参考 Linux 驱动源文件代码：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/2.png" alt="image"><br>我们要验证mmap功能，在驱动程序中申请一个 8K 的 buffer，让 APP 通过 mmap 能直接访问。</p>
<h1><span id="2-mmap-qu-dong-dai-ma-shi-li-fen-xi">2 mmap驱动代码示例分析</span><a href="#2-mmap-qu-dong-dai-ma-shi-li-fen-xi" class="header-anchor">#</a></h1><p>linux内核中常用的内存申请方式：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>分配到的内存物理地址是连续的</td>
</tr>
<tr>
<td>kzalloc</td>
<td>分配到的内存物理地址是连续的，内容清 0</td>
</tr>
<tr>
<td>vmalloc</td>
<td>分配到的内存物理地址不保证是连续的</td>
</tr>
<tr>
<td>vzalloc</td>
<td>vzalloc 分配到的内存物理地址不保证是连续的，内容清 0</td>
</tr>
</tbody></table>
<p>我们在 mmap 时应该使用 kmalloc 或 kzalloc，这样得到的内存物理地址是连续的，mmap后 APP 才可以使用同一个基地址去访问这块内存。 (如果物理地址不连续，就要执行多次 mmap 了)</p>
<details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/pgtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *kernel_buf;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> bufsiz = <span class="number">1024</span>*<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_to_user(buf, kernel_buf, MIN(bufsiz, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(bufsiz, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	err = copy_from_user(kernel_buf, buf, MIN(<span class="number">1024</span>, size));</span><br><span class="line">	<span class="keyword">return</span> MIN(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 获得物理地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line">	<span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">	vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line">	<span class="comment">/* map */</span></span><br><span class="line">	<span class="keyword">if</span> (remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT,</span><br><span class="line">			    vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;mmap remap_pfn_range failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -ENOBUFS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.open    = hello_drv_open,</span><br><span class="line">	.read    = hello_drv_read,</span><br><span class="line">	.write   = hello_drv_write,</span><br><span class="line">	.release = hello_drv_close,</span><br><span class="line">	.mmap    = hello_drv_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	kernel_buf = kmalloc(bufsiz, GFP_KERNEL);</span><br><span class="line">	<span class="built_in">strcpy</span>(kernel_buf, <span class="string">&quot;old&quot;</span>);</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;hello&quot;</span>, &amp;hello_drv);</span><br><span class="line">	hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">	err = PTR_ERR(hello_class);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(hello_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	kfree(kernel_buf);</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>分析：init时，驱动使用kmalloc分配8K空间(物理地址连续), 初始化为<code>”old“</code>字符串。实现read，write函数。mmap函数中：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获得物理地址 */</span></span><br><span class="line">unsigned <span class="built_in">long</span> phy = virt_to_phys(kernel_buf);</span><br><span class="line"><span class="comment">/* 设置属性: cache, buffer */</span></span><br><span class="line">vma-&gt;vm_page_prot = pgprot_writecombine(vma-&gt;vm_page_prot);</span><br><span class="line"><span class="comment">/*映射*/</span></span><br><span class="line">remap_pfn_range(vma, vma-&gt;vm_start, phy &gt;&gt; PAGE_SHIFT, vma-&gt;vm_end - vma-&gt;vm_start, vma-&gt;vm_page_prot)；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/3.png" alt="image"></p>
<p><code>pgprot_writecombine</code>设置属性为<code>Non-cached buffered (NCB)</code></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;asm/pgtable.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_noncached(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRnE) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_writecombine(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_NORMAL_NC) | PTE_PXN | PTE_UXN)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pgprot_device(prot) \</span></span><br><span class="line">		__pgprot_modify(prot, PTE_ATTRINDX_MASK, PTE_ATTRINDX(MT_DEVICE_nGnRE) | PTE_PXN | PTE_UXN)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/4.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/5.png" alt="image"></p>
<p>注意：<code>remap_pfn_range</code> 中，<code>pfn </code>的意思是<code>“ Page Frame Number”</code>。在 Linux 中，整个物理地址空间可以分为第 0 页、第 1 页、第 2 页，诸如此类，这就是 pfn。假设每页大小是 4K，那么给定物理地址<code> phy</code>，它的<code> pfn = phy / 4096 = phy &gt;&gt; 12</code>。内核的 page 一般是 4K，但是也可以配置内核修改 page的大小。所以为了通用， <code>pfn = phy &gt;&gt; PAGE_SHIFT</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们的buf不是用<code>kmalloc</code>, 而是<code>vmalloc</code>，那么需要映射多次，每次映射一个<code>page 4k</code>.(MMU过程中内存以page为单位作为连续内存单元)<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/6.png" alt="image"></p>
<h1><span id="3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi">3 mmap应用代码示例与分析</span><a href="#3-mmap-ying-yong-dai-ma-shi-li-yu-fen-xi" class="header-anchor">#</a></h1><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./hello_drv_test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *buf;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">/* 1. 打开文件 */</span></span><br><span class="line">	fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. mmap </span></span><br><span class="line"><span class="comment">	 * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment">	 *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment">	 * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment">	 *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment">	 *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment">	 *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	buf =  mmap(<span class="literal">NULL</span>, <span class="number">1024</span>*<span class="number">8</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (buf == MAP_FAILED)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not mmap file /dev/hello\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;mmap address = 0x%x\n&quot;</span>, buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;buf origin data = %s\n&quot;</span>, buf); <span class="comment">/* old */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3. write */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(buf, <span class="string">&quot;new&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4. read &amp; compare */</span></span><br><span class="line">	<span class="comment">/* 对于MAP_SHARED映射:  str = &quot;new&quot; </span></span><br><span class="line"><span class="comment">	 * 对于MAP_PRIVATE映射: str = &quot;old&quot; </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	read(fd, str, <span class="number">1024</span>);  </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf, str) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_SHARED映射，APP写的数据驱动可见</span></span><br><span class="line"><span class="comment">		 * APP和驱动访问的是同一个内存块</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare ok!\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 对于MAP_PRIVATE映射，APP写数据时, 是写入原来内存块的&quot;拷贝&quot;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;compare err!\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;str = %s!\n&quot;</span>, str);  <span class="comment">/* old */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf = %s!\n&quot;</span>, buf);  <span class="comment">/* new */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);  <span class="comment">/* cat /proc/pid/maps */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	munmap(buf, <span class="number">1024</span>*<span class="number">8</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-1-gong-xiang-ying-she-yu-si-you-ying-she">3.1 共享映射与私有映射</span><a href="#3-1-gong-xiang-ying-she-yu-si-you-ying-she" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MAP_SHARED  : 多个APP都调用mmap映射同一块内存时, 对内存的修改大家都可以看到。</span></span><br><span class="line"><span class="comment"> *               就是说多个APP、驱动程序实际上访问的都是同一块内存</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE : 创建一个copy on write的私有映射。</span></span><br><span class="line"><span class="comment"> *               当APP对该内存进行修改时，其他程序是看不到这些修改的。</span></span><br><span class="line"><span class="comment"> *               就是当APP写内存时, 内核会先创建一个拷贝给这个APP, </span></span><br><span class="line"><span class="comment"> *               这个拷贝是这个APP私有的, 其他APP、驱动无法访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">   <span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">			  <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line">   <span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-copy-on-write">3.1.1 copy on write</span><a href="#3-1-1-copy-on-write" class="header-anchor">#</a></h3><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/7.png" alt="image"></p>
<pre><code>① mmap时使用MAP_PRIVATE
②③ 当写入mmap内存时，会copy这块内存
④写入新数据，会将数据写入新copy的内存
⑤读数据还是从旧的那块映射内存去读，因此这时会与buf中的数据不一样
</code></pre>
<p>根据上面的mmap应用示例来分析和验证<code>MAP_SHARED</code>和<code>MAP_PRIVATE</code>的差异：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/8.png" alt="image"><br>先用<code>MAP_PRIVATE</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/9.png" alt="image"><br>再用<code>MAP_SHARED</code>，执行测试程序：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/10.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" data-id="clzww9otk0001nguf8pethpld" data-title="字符设备驱动-mmap驱动应用实例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-mmap机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T13:58:58.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/">字符设备驱动-mmap机制</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-mmap">1 引入mmap</a><ul>
<li><a href="#1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</a><ul>
<li><a href="#1-1-1-yin-ru-mmu">1.1.1 引入MMU</a></li>
<li><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</a><ul>
<li><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</a><ul>
<li><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ye-biao-ying-she">3 页表映射</a><ul>
<li><a href="#3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</a></li>
<li><a href="#3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</a></li>
</ul>
</li>
<li><a href="#4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</a><ul>
<li><a href="#4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</a></li>
<li><a href="#4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</a><ul>
<li><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</a><ul>
<li><a href="#4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-mmap">1  引入mmap</span><a href="#1-yin-ru-mmap" class="header-anchor">#</a></h1><p>应用程序和驱动程序之间传递数据时，可以通过 read、write 函数进行, 用户态和内核态的数据交互一般用<code>copy_from_user</code>,<code>copy_to_user</code>。这种方式在数据量比较小时没什么问题；但是数据量比较大时效率就太低了。比如更新 LCD 显示时，如果每次都让 APP 传递一帧数据给内核，假设 LCD 采用<code>1024x600x32 bpp </code>的格式，一帧数据就有<code>1024x600x32/8=2.3MB</code> 左右,而且一般为了显示动态画面，LDC输出fps要求是<code>60fps or 30 fps</code>，那么一秒数据量为<code>30x2.3 = 70M</code>左右，显然<code>copy_from_user</code>，<code>copy_to_user</code>的方式不再适合。<br>改进的方法就是让程序可以直接读写驱动程序中的 buffer，这可以通过mmap 实现(memory map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h2><span id="1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</span><a href="#1-1-nei-cun-ying-she-xian-xiang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, &amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PC 上如下编译(必须静态编译)：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -staitc</span><br></pre></td></tr></table></figure>
<p>分别后台执行 test 程序 2 次。最后执行 ps，可以看到这 2 个程序同时存在，这 2 个程序里 a 变量的地址相同，但是值不同。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 个程序同时运行，它们的变量a的地址都是一样的：0x6bc3a0；</span><br><span class="line">2 个程序同时运行，它们的变量a的值是不一样的，一个是 111，另一个是 123。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-yin-ru-mmu">1.1.1 引入MMU</span><a href="#1-1-1-yin-ru-mmu" class="header-anchor">#</a></h3><p>来分析一下：<br>2个程序同时在内存中运行，它们的值不一样，所以变量 a 的物理内存地址肯定不同（2个变量存放不是同一个地方）；<br>但是打印出来的变量 a 的地址却是一样的。怎么回事？<br>这里要引入<strong>虚拟地址</strong>的概念：CPU 发出的地址是虚拟地址，它经过<code>MMU(Memory Manage Unit，内存管理单元)</code>映射到物理地址上，对于不同进程的同一个虚拟地址，MMU 会把它们映射到不同的物理地址。<br>总结:虽然虚拟地址一样，但物理地址不一样，这个是mmu的功劳，将同一虚拟地址映射到不同物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前运行的是 app1 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr1，用 paddr1 去访问内存。</span><br><span class="line">当前运行的是 app2 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr2，用 paddr2 去访问内存。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</span><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian" class="header-anchor">#</a></h3><p>MMU 负责把虚拟地址映射为物理地址，虚拟地址映射到哪个物理地址去？可以执行<code>ps</code>命令查看进程 ID，然后执行<code>“cat /proc/[PID]/maps”</code>得到虚拟地址空间映射关系。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00400000</span><span class="number">-004b</span>6000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>6000<span class="number">-006b</span>c000 rw-p <span class="number">000b</span>6000 <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>c000<span class="number">-006b</span>d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">021</span>c8000<span class="number">-021</span>eb000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</span><br><span class="line"><span class="number">7f</span>fe18738000<span class="number">-7f</span>fe18759000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fe187f9000<span class="number">-7f</span>fe187fc000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</span><br><span class="line"><span class="number">7f</span>fe187fc000<span class="number">-7f</span>fe187fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>第一行地址范围显示权限为可读可执行，表示该程序<code>代码段（.text）</code><br>第二行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code><br>第三行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code>刚才变量a地址就在这段地址范围内<br>第四行地址范围是<code>堆空间（.heap段）</code>,malloc的内存就会处于这段<br>第5行地址范围是<code>栈空间（.stack段）</code>,局部变量处于这段<br>p表示<code>private</code>, s表示<code>share</code>, 再来看一个使用动态库的进程，比如bash进程：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</span><a href="#2-mmap-nei-he-tai-de-miao-shu" class="header-anchor">#</a></h1><h2><span id="2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</span><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct" class="header-anchor">#</a></h2><p>每一个 APP对应了很多虚拟地址空间，比如栈空间，堆空间，数据段，代码段等,也叫做进程地址空间<code>（mm_strcut）</code>。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<p>因此在内核里都有一个 tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每个 APP 在内核中都有一个 task_struct 结构体，它用来描述一个进程；</span><br><span class="line"><span class="number">2.</span> 每个 APP 都要占据内存，在 task_struct 中用 mm_struct 来管理进程占用的内存；</span><br><span class="line"><span class="number">3.</span> 内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，</span><br><span class="line">用 pgd 来描述对应的物理地址。(注意：pgd，Page Global Directory，页目录)</span><br><span class="line"><span class="number">4.</span> 每个 APP 都有一系列的 VMA：virtual memory，即mmap会指向vm_area_struct, </span><br><span class="line">比如 APP 含有代码段、数据段、BSS 段、栈等等，还有共享库。这些单元会保存在内存里，</span><br><span class="line">它们的地址空间不同，权限不同(代码段是只读的可运行的、数据段可读可写)，内核用一系列的 vm_area_struct 来描述它们。</span><br><span class="line"><span class="number">6.</span> vm_area_struct 中的 vm_start、vm_end 是虚拟地址。</span><br><span class="line"><span class="number">7.</span> vm_area_struct 中虚拟地址如何映射到物理地址去？ 每一个 APP 的虚拟地址可能相同，</span><br><span class="line">物理地址不相同，这些对应关系保存在 pgd 中。</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</span><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu" class="header-anchor">#</a></h3><p>每个进程有一个<code>task_struct</code>和一个<code>mm_struct</code>, 其中<code>mm_struct</code>中的mmap对应<code>vm_area_struct</code>虚拟内存区域：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png" alt="image-20240816222839173"></p>
<p>可以看到<code>mm_struct</code>每一段都对应一块<code>vm_area_struct</code>。</p>
<h1><span id="3-ye-biao-ying-she">3 页表映射</span><a href="#3-ye-biao-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<p>页表是存在<code>ddr</code>中的一段连续地址空间，页表里面存放了要映射的物理地址集合，页表分为很多个页表项。<br>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址可以找到第 1 个页表，从第 1 个页表里就可以知道这个虚拟地址对应的物理地址。一级页表里地址映射的最小单位是 1M。<br>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2 级页表在哪里；再取出第 2 级页表，从第 2 个页表里才能确定这个虚拟地址对应的物理地址。二级页表地址映射的最小单位有 4K、1K，Linux 使用 4K。<br><strong>一级页表项里的内容，决定了它是指向一块物理内存，还是指问二级页表</strong>，一个页表项格式如下图：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png" alt="image"></p>
<h2><span id="3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</span><a href="#3-1-yi-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>arm32系统中，一个页表项占4个byte, 32bit,它分为一级页表项和二级页表项，通过<code>bit[1:0]</code>区分，一级页表项保存有物理地址，用<code>bit[31:20]</code> 共12位表示段基地址，有1M物理内存。比如cpu发出虚拟地址<code>0x12345678</code>, MMU通过<code>bit[31:20]</code>发现为0x123,也就是从第0x123个页表项中找到<code>Section Base Address</code>, 比如第0个页表项中物理及地址为<code>0x8000,0000</code>， 那么第0x123个页表项目物理基地址就是<code>0x123 * 1M + 0x8000,0000</code>,也就是<code>0x9230,0000</code>, 因为每一个一级页表项物理内存大小为1M.<br>段内偏移是 <code>0x45678</code>，那么最终通过一级页表映射最终映射到物理地址就为<code>0x0x9230,0000 + 0x45678</code>,也就是<code>0x9234,5678</code>。<br><code>Section Base Address</code>的数量为多少呢？一共12bit，也就是4096个，每一个1级页表项大小为1M, 因此总共可表示4G。对于 32 位的系统，虚拟地址空间有 4G，<code>4G/1M=4096</code>。所以一级页表要映射整个 4G 空间的话，刚好需要 4096 个页表项。<br>所以 CPU 要访问虚拟地址 0x12345678 时，实际上访问的是 0x81045678 的物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png" alt="image"></p>
<h2><span id="3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</span><a href="#3-2-er-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>一级页表项每项有1M空间, 一级页表映射时是吧虚拟地址的1M映射到物理地址的1M连续空间，但有时我们的程序没有那么大，显然用1M太浪费空间。 那么引入二级页表映射来映射更小的块，对于二级页表，每一个页可以是1K, 4K，64K， Linux系统一般使用4K, 对应<code>Small Page</code>, 64K对应的是大页（<code>Large Page</code>）, 1K对应的是Tine Page(一般很少用)。<br><strong>二级页表映射过程：</strong><br>首先设置好一级页表、二级页表，并且把一级页表的首地址告诉 MMU,比如<code>0x8000,0000</code>。<br>二级页表首先也是要经过一级页表映射，用<code>bit[31:20] </code>共12位表示段基地址，找到对应的一级页表项比如<code>0x123</code>项，通过这一项里面的<code>bit[1:0]</code>发现它是一个二级页表项（注意不再是取出1M的物理地址），然后根据二级页表项的<code>bit[19：12]</code>这8位得到二级页表是得到索引0x45,表示为第0x45个二级页表项。从这个二级页表项中取出里面的物理地址，比如为addr。<br>二级页表格式如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png" alt="image"></p>
<p>可以看到里面含有<code>64k(Large Page) 4k(Small Page）</code>或 <code>1K(Tine) </code>物理空间的基地址<code> page base addr</code>，假设从第0x45个二级页表项取出的物理地址为<code>0x8188,9000</code>。然后<code>offset=0x678</code>, 那么它跟 <code>vaddr[11:0] </code>组 合 得 到 物 理 地 址 ：<code> 0x8188,9000 + 0x678 = 0x8188,9678</code>，所以 CPU 要访问虚拟地址 <code>0x1234,5678 </code>时，实际上访问的是<code>0x8188,9678</code>的物理地址, 根据<code>bit[1:0]</code>得到映射的大小为<code>4K(linux Small Page)</code>。假如这里不使用二级页表映射，理论去计算对应物理地址则会是<code>0x8180,0000</code>往后1M内存，显然浪费了。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png" alt="image"></p>
<h1><span id="4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</span><a href="#4-mmap-han-shu-diao-yong-guo-cheng" class="header-anchor">#</a></h1><p>从上面内存映射的过程可以知道，要给 APP 新开劈一块虚拟内存，并且让它指向某块内核buffer，我们要做这些事：</p>
<ol>
<li>得到一个 <code>vm_area_struct</code>，它表示 APP 的一块虚拟内存空间：<br> 很 幸 运 ， APP 调 用 mmap 系 统 函 数 时 ， 内 核 就 帮 我 们 构 造 了 一 个<code>vm_area_stuct </code>结构体。里面含有虚拟地址的地址范围、权限，属性。</li>
<li>确定物理地址：<br> 你想映射某个内核 buffer，你需要得到它的物理地址，这得由你提供。</li>
<li>给<code>vm_area_struct</code>和物理地址建立映射关系</li>
</ol>
<p>比如APP 里调用 mmap 时，导致的内核相关函数调用过程如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>可以传入一个addr虚拟地址，需要用户自己malloc。也可以将addr设置为NULL, 让linux内核帮你产生一段内存映射，返回虚拟地址给你。<br>内核得到可用的虚拟地址后会分配一个<code>vm_area_struct</code>, 用来描述一块虚拟地址空间，里面有这块虚拟地址空间的起始地址、结束地址、权限信息。最后会调用驱动里面的mmap函数，参数为刚刚分配的<code>vm_area_sruct</code>。<br>那么需要再驱动程序实现mmap函数，主要包括：</p>
<ol>
<li>提供物理地址</li>
<li>设置属性，<code>cache，buffer</code></li>
<li>给<code>vm_area_stuct</code>和物理地址建立映射</li>
</ol>
<h2><span id="4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</span><a href="#4-1-vm-area-struct-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct describes a virtual memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task. A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">	 * See vmf_insert_mixed_prot() for discussion.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br></pre></td></tr></table></figure>

<p>它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是<code>0~3G</code>，对应的物理页面都可以是不连续的.<br>主要成员有起始地址、结束地址、权限信息，属性信息。<br><code>vm_flags:</code>可读，可写，可执行权限，私有，共享等权限</p>
<p>常用<strong>vm_flags</strong>访问权限的取值说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VM_READ：可读</span><br><span class="line">VM_WRITE：可写</span><br><span class="line">VM_EXEC：可执行</span><br><span class="line">VM_SHARD：可多进程之间共享</span><br><span class="line">VM_IO：可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED：内存区域不可被换出</span><br><span class="line">VM_SEQ_READ：内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ：内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<p><code>vm_pgoff:</code>是否使用cache? 是否使用buffer？</p>
<h2><span id="4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</span><a href="#4-2-yin-ru-cache-he-buffer" class="header-anchor">#</a></h2><p>使用<code> mmap</code> 时，需要有<code>cache、 buffer</code>的知识。下图是 CPU 和内存之间的关系，有<code> cache、 buffer</code>(写缓冲器)。 Cache 是一块高速内存；写缓冲器相当于一个 FIFO，可以把多个写操作集合起来一次写入内存。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png" alt="image"></p>
<h3><span id="4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</span><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing" class="header-anchor">#</a></h3><p>当程序运行时有<code>“局部性原理”</code>，这又分为<strong>时间局部性、空间局部性</strong>。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间局部性：</strong><br>a++在很短的时间内被重复写了100次，与此同时i也被访问了100次，像这种在某个时间点访问了存储器的特定位置，反复地访问这个位置被称为<code>“时间局部性”</code>。<br><strong>空间局部性：</strong><br>访问变量a的同时也访问了它周围临近变量i, 像这种访问了存储器的特定位置，很可能在不久的将来访问它附近的位置被称作<code>”空间局部性“</code>， 那么为什么不用<code>buffer or cache</code>把它一次性访问完呢？<br>根据<code>“局部性原理”</code>，引入 <code>cache</code>和<code>buffer</code>。</p>
<h4><span id="4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</span><a href="#4-2-1-1-cache-miss-he-cache-hit" class="header-anchor">#</a></h4><p>读数据：</p>
<ol>
<li>要读取内存指定addr处的数据时，先看看cache中有没有addr的数据，如果有则直接从cache返回数据，这一过程叫做<code>cache命中(cache hit)</code>。</li>
<li>假如cache中没有该addr的数据，触发<code>cache缺失 (cache miss)</code>, 那么会从addr读一段连续数据进去，注意：它不是仅仅读入一个数据，而是读入一行数据(cache line)。</li>
<li>那么CPU 短时间内很可能会再次用到甚至多次用到这个 addr 的数据或者周围临近的数据，那么就可以直接从cache快速的获取数据。这样<strong>弥补了时间和空间上的”局部性“</strong>。</li>
</ol>
<p>写数据：</p>
<ol>
<li>CPU 写数据时，可以<strong>直接写内存</strong>，这很慢；也可以先把数据<strong>写入 cache</strong>，这很快。</li>
<li>cache 中的数据终究是要写入内存的啊，这有 2 种写策略:<br> <strong>2.1 写通(write through)：</strong><br> ◆ 数据要同时写入 cache 和内存，所以 cache 和内存中的数据保持一致，但是它的效率很低。能改进吗？可以！使用“<strong>写缓冲器</strong>”：cache 大哥，你把数据给我就可以了，我来慢慢写，保证帮你写完。<br> ◆ 有些写缓冲器有“<strong>写合并</strong>”的功能，比如 CPU 执行了 4 条写指令：写第 0、 1、 2、 3 个字节，每次写 1 字节；写缓冲器会把这 4 个写操作合并成一个写操作：写 word。对于内存来说，这没什么差别，但是对于硬件寄存器，这就有可能导致问题。<br> ◆ 所以对于寄存器操作，不会启动 buffer 功能；对于内存操作，比如 LCD 的显存，可以启用 buffer 功能(cpu直接用<code>write buffer</code>进行操作<code>frame buffer内存</code>)<br> <strong>2.2 写回(write back)：</strong><br> ◆ 新数据只是写入<code> cache</code>，不会立刻写入内存， <code>cache </code>和内存中的数据并不一致。<br> ◆ 新数据写入 cache 时，这一行 cache 被标为<code>“脏” (dirty)</code>；当cache 不够用时，才需要把脏的数据写入内存。</li>
</ol>
<p>对内存或者变量进行写操作可以使用写回功能，可以大幅提高效率。但是要注意 cache 和内存中的数据很可能不一致。这在很多时间要小心处理：比如 CPU 产生了新数据， DMA 把数据从内存搬到网卡，这时候就要 CPU 执行命令先把新数据从 cache 刷到内存。反过来也是一样的， DMA 从网卡得过了新数据存在内存里， CPU 读数据之前先把 cache中的数据丢弃。下图举例说明哪些硬件可以用或者不能用cache：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png" alt="image"></p>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合(位于<code>arch\arm\include\asm\pgtable-2level.h</code>：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png" alt="image"></p>
<p>以s3c2440芯片为例，上面 4 种组合对应下表中的各项：</p>
<table>
<thead>
<tr>
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件；写操作通过 buffer 实现， CPU 不等待操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><code>Cached, write-through mode (WT)</code>，写通    ①读：<code>cache hit</code>时从 cahce 读数据； <code>cache miss </code>时已入一行数据到 cache；②写：通过 buffer 实现， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><code>Cached, write-back mode (WB)</code>，写回    ①读：<code> cache hit</code> 时从 cahce 读数据；<code>cache miss</code>时已入一行数据到 cache；②写：通过 buffer 实现， <code>cache hit</code> 时新数据不会到达硬件，而是在 cahce 中被标为 “脏”； <code>cache miss</code> 时，通过 buffer写入硬件， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
</tbody></table>
<p>◼ 第 1 种是不使用 cache 也不使用 buffer，读写时都直达硬件，这适合寄存器的读写。<br>◼ 第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer 进行优化，可能会有<code>“写合并”</code>，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。<br>◼ 第 3 种是使用 cache 不使用 buffer，就是<code>“ write through”</code>，适用于只读设备：在读数据时用 cache 加速，基本不需要写。<br>◼ 第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" data-id="clzww9otj0000ngufh5fqcv44" data-title="字符设备驱动-mmap机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断线程化-threaded_irq" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/" class="article-date">
  <time class="dt-published" datetime="2024-08-11T07:24:53.000Z" itemprop="datePublished">2024-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/">字符设备驱动-9-中断子系统-中断线程化-threaded_irq</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-threaded-irq-yin-ru">1 threaded_irq引入</a></li>
<li><a href="#2-threaded-irq-shi-yong">2 threaded_irq使用</a></li>
<li><a href="#3-threaded-irq-shi-li">3 threaded_irq实例</a><ul>
<li><a href="#3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</a></li>
<li><a href="#3-2-app-dai-ma-bian-xie">3.2 app代码编写</a></li>
<li><a href="#3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</a></li>
</ul>
</li>
<li><a href="#4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</a><ul>
<li><a href="#4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</a><ul>
<li><a href="#4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></a><ul>
<li><a href="#4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</a><ul>
<li><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</a></li>
<li><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</a><ul>
<li><a href="#4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</a></li>
<li><a href="#4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-threaded-irq-yin-ru">1 threaded_irq引入</span><a href="#1-threaded-irq-yin-ru" class="header-anchor">#</a></h1><p>工作队列用起来挺简单，但是它有一个缺点：工作队列中有多个 work，前一个 work 没处理完会影响后面的 work执行，导致后面的work没法快速响应。那么可以再内核自己创建一个线程来单独处理，不跟别的 work 凑在一块了。比如在 Linux 系统中，对于存储设备比如 SD&#x2F;TF 卡，它的驱动程序就是这样做的，它有自己的内核线程。用<code>kthread_creat</code>创建内核线程。<br>对于中断处理，还有另一种方法：<code>threaded irq</code>，线程化的中断处理。中断的处理仍然可以认为分为上半部、下半部。上半部用来处理紧急的事情，下半部用一个内核线程来处理，这个内核线程专用于这个中断。</p>
<h1><span id="2-threaded-irq-shi-yong">2 threaded_irq使用</span><a href="#2-threaded-irq-shi-yong" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html" title="1异常中断引入">1异常中断引入</a> </p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a>前面已经提到了<code>threaded_irq</code>。</p>
<ol>
<li>你可以只提供 <code>thread_fn</code>，内核会提供默认的上半部处理函数<code>irq_default_primary_handler</code>,该函数只是返回一个<strong>IRQ_WAKE_THREAD</strong>。发生中断时，系统会立刻调用 handler 函数，然后唤醒某个内核线程，内核线程再来执行<code>thread_fn</code> 函数。</li>
<li>你也可以既提供<code>handler</code>函数，也提供<code>thread_fn</code>函数。等硬件中断到来，先执行<code>handler</code>函数，handler函数中返回<strong>IRQ_WAKE_THREAD</strong>去唤醒中断线程函数<code>thread_fn</code>。</li>
</ol>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/1.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_threaded_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">			  <span class="type">irq_handler_t</span> handler, <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">			  <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname,</span></span><br><span class="line"><span class="params">			  <span class="type">void</span> *dev_id)</span>;</span><br><span class="line"><span class="comment">//include\linux\interrupt.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">devm_request_irq</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		 <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> devm_request_threaded_irq(dev, irq, handler, <span class="literal">NULL</span>, irqflags,</span><br><span class="line">					 devname, dev_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">		     <span class="type">irq_handler_t</span> thread_fn,</span></span><br><span class="line"><span class="params">		     <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">	    <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-threaded-irq-shi-li">3 threaded_irq实例</span><a href="#3-threaded-irq-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-qu-dong-yuan-ma-bian-xie">3.1 驱动源码编写</span><a href="#3-1-qu-dong-yuan-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line">		</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>,</span><br><span class="line">               __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>,</span><br><span class="line">                   __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">//err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span></span><br><span class="line">        <span class="comment">//, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span></span><br><span class="line">        <span class="comment">//, &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">        						   , gpio_key_thread_func,</span><br><span class="line">                                   IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                                   , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-2-app-dai-ma-bian-xie">3.2 app代码编写</span><a href="#3-2-app-dai-ma-bian-xie" class="header-anchor">#</a></h2><details>
<summary>app代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="3-3-qu-dong-dai-ma-jie-xi">3.3 驱动代码解析</span><a href="#3-3-qu-dong-dai-ma-jie-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/2.png" alt="image"><br>为每个按键注册中断服务</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/3.png" alt="image"><br>硬件中断上半部irq中做完重要事情如：清中断，然后返回<strong>IRQ_WAKE_THREAD</strong></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/4.png" alt="image"><br>返回后，内核线程开始调度<code>gpio_key_thread_func</code>，中断线程化的处理函数<code>gpio_key_thread_func</code>做完后返回<code>IRQ_HANDLED</code>;</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/5.png" alt="image"><br>最后卸载驱动时取消irq注册.</p>
<h1><span id="4-threaded-irq-nei-he-ji-zhi">4 threaded_irq内核机制</span><a href="#4-threaded-irq-nei-he-ji-zhi" class="header-anchor">#</a></h1><p>前面<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17532830.html" title="中断相关结构体">中断相关结构体</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/">字符设备驱动-9-中断子系统-中断结构体 | Hexo (fuzidage.github.io)</a>讲过<code>struct irq_desc</code>结构：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当发生中断时，handler函数被调用，如果返回IRQ_HANDLED,表示中断处理完毕，如果返回IRQ_WAKE_THREAD表示要唤醒thread_fn.</span><br><span class="line"><span class="number">2.</span> 内核线程唤醒后，执行thread_fn</span><br></pre></td></tr></table></figure>

<h2><span id="4-1-request-threaded-irq-guo-cheng">4.1 request_threaded_irq过程</span><a href="#4-1-request-threaded-irq-guo-cheng" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_threaded_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">			 <span class="type">irq_handler_t</span> thread_fn, <span class="type">unsigned</span> <span class="type">long</span> irqflags,</span></span><br><span class="line"><span class="params">			 <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="keyword">if</span> (irq == IRQ_NOTCONNECTED)</span><br><span class="line">		<span class="keyword">return</span> -ENOTCONN;</span><br><span class="line">	<span class="keyword">if</span> (((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id) ||</span><br><span class="line">	    (!(irqflags &amp; IRQF_SHARED) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)) ||</span><br><span class="line">	    ((irqflags &amp; IRQF_NO_SUSPEND) &amp;&amp; (irqflags &amp; IRQF_COND_SUSPEND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	desc = irq_to_desc(irq);  <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">if</span> (!desc)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!irq_settings_can_request(desc) ||</span><br><span class="line">	    WARN_ON(irq_settings_is_per_cpu_devid(desc)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!thread_fn)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		handler = irq_default_primary_handler;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	action = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!action)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	action-&gt;handler = handler;   <span class="comment">//2</span></span><br><span class="line">	action-&gt;thread_fn = thread_fn;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line"></span><br><span class="line">	retval = irq_chip_pm_get(&amp;desc-&gt;irq_data);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		kfree(action);</span><br><span class="line">		<span class="keyword">return</span> retval;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chip_bus_lock(desc);</span><br><span class="line">	retval = __setup_irq(irq, desc, action); <span class="comment">//3</span></span><br><span class="line">	chip_bus_sync_unlock(desc);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (retval) &#123;</span><br><span class="line">		irq_chip_pm_put(&amp;desc-&gt;irq_data);</span><br><span class="line">		kfree(action-&gt;secondary);</span><br><span class="line">		kfree(action);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SHIRQ_FIXME</span></span><br><span class="line">	<span class="keyword">if</span> (!retval &amp;&amp; (irqflags &amp; IRQF_SHARED)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * It&#x27;s a shared IRQ -- the driver ought to be prepared for it</span></span><br><span class="line"><span class="comment">		 * to happen immediately, so let&#x27;s make sure....</span></span><br><span class="line"><span class="comment">		 * We disable the irq to make sure that a &#x27;real&#x27; IRQ doesn&#x27;t</span></span><br><span class="line"><span class="comment">		 * run in parallel with our fake.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">		disable_irq(irq);</span><br><span class="line">		local_irq_save(flags);</span><br><span class="line">		handler(irq, dev_id);</span><br><span class="line">		local_irq_restore(flags);</span><br><span class="line">		enable_irq(irq);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/7.png" alt="image"></p>
<ol>
<li><p>首先根据<code>irq num</code>获取到<code>struct irq_desc</code>信息。</p>
</li>
<li><p>然后分配、设置一个<code> irqaction</code> 结构体。设置中断相关参数</p>
</li>
<li><p>然后进入<code>__setup_irq</code>，<code>__setup_irq </code>函数核心代码如下：</p>
</li>
</ol>
<h3><span id="4-1-1-setup-irq">4.1.1 <code>__setup_irq</code></span><a href="#4-1-1-setup-irq" class="header-anchor">#</a></h3><h4><span id="4-1-1-1-setup-irq-thread">4.1.1.1 setup_irq_thread</span><a href="#4-1-1-1-setup-irq-thread" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (new-&gt;thread_fn &amp;&amp; !nested) &#123;</span><br><span class="line">	ret = setup_irq_thread(new, irq, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">//setup_irq_thread函数核心代码如下：</span></span><br><span class="line"><span class="keyword">if</span> (!secondary) &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	t = kthread_create(irq_thread, new, <span class="string">&quot;irq/%d-s-%s&quot;</span>, irq,</span><br><span class="line">	 new-&gt;name);</span><br><span class="line">	param.sched_priority -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">new-&gt;thread = t;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/9.png" alt="image"><br>①可以看到创建了<code>irq_thread</code>这个内核线程。线程名字为<code>“irq/pid-中断名字”</code>。</p>
<p><code>kthread_create()</code>只是创建一个内核线程，但并没有启动，需要调用<code>wake_up_process()</code>来启动线程，所以内核又帮我们定义了一个宏<code>kthread_run</code>来帮我们搞定. 来看kthread相关API:</p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/10.png" alt="image-20240811233308139"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_create(threadfn, data, namefmt, arg...) \</span></span><br><span class="line"><span class="meta">	kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</span></span><br><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create_on_cpu</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">					  <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">					  <span class="type">unsigned</span> <span class="type">int</span> cpu,</span></span><br><span class="line"><span class="params">					  <span class="type">const</span> <span class="type">char</span> *namefmt)</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kthread_run - create and wake a thread.</span></span><br><span class="line"><span class="comment"> * @threadfn: the function to run until signal_pending(current).</span></span><br><span class="line"><span class="comment"> * @data: data ptr for @threadfn.</span></span><br><span class="line"><span class="comment"> * @namefmt: printf-style name for the thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description: Convenient wrapper for kthread_create() followed by</span></span><br><span class="line"><span class="comment"> * wake_up_process().  Returns the kthread or ERR_PTR(-ENOMEM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)			   \</span></span><br><span class="line"><span class="meta">(&#123;									   \</span></span><br><span class="line"><span class="meta">	struct task_struct *__k						   \</span></span><br><span class="line"><span class="meta">		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span> (!IS_ERR(__k))						   \</span></span><br><span class="line"><span class="meta">		wake_up_process(__k);					   \</span></span><br><span class="line"><span class="meta">	__k;								   \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>;</span><br></pre></td></tr></table></figure>

<p>②然后将创建内核线程返回的<code>task_strcut</code>给到<code>irqaction</code>.(<code>new-&gt;trhead = t;这句</code>)<br>我们知道<code>irqaction</code>就包含了<code>thread_fn</code>和<code>handler</code>。</p>
<h2><span id="4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de">4.2 中断后处理<code>thread_fn</code>是怎么被执行的</span><a href="#4-2-zhong-duan-hou-chu-li-thread-fn-shi-zen-me-bei-zhi-xing-de" class="header-anchor">#</a></h2><h3><span id="4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng">4.2.1 上半部硬件中断的调用过程</span><a href="#4-2-1-shang-ban-bu-ying-jian-zhong-duan-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>无论是中断的上半部的<code>handler</code>, 还是后处理的<code>thread_fn</code>前面的<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/#3-4-gic-zhong-duan-chu-guo-cheng">字符设备驱动-9-中断子系统-GICv2架构解析 | Hexo (fuzidage.github.io)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a>有引入介绍。</p>
<p>当中断产生时，用gdb看看gic驱动框架调用关系：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">1</span>, gpio_keys_gpio_isr (irq=<span class="number">200</span>, dev_id=<span class="number">0x863e6930</span>) at drivers/input/keybo</span><br><span class="line">ard/gpio_keys.c:<span class="number">393</span></span><br><span class="line"><span class="number">393</span> &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#0 gpio_keys_gpio_isr (irq=200, dev_id=0x863e6930) at drivers/input/keyboard/gpio_k</span></span><br><span class="line">eys.c:<span class="number">393</span></span><br><span class="line"><span class="meta">#1 0x80270528 in __handle_irq_event_percpu (desc=0x8616e300, flags=0x86517edc) at ke</span></span><br><span class="line">rnel/irq/handle.c:<span class="number">145</span></span><br><span class="line"><span class="meta">#2 0x802705cc in handle_irq_event_percpu (desc=0x8616e300) at kernel/irq/handle.c:18</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">#3 0x80270640 in handle_irq_event (desc=0x8616e300) at kernel/irq/handle.c:202</span></span><br><span class="line"><span class="meta">#4 0x802738e8 in handle_level_irq (desc=0x8616e300) at kernel/irq/chip.c:518</span></span><br><span class="line"><span class="meta">#5 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#6 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#7 0x805005e0 in mxc_gpio_irq_handler (port=0xc8, irq_stat=2252237104) at drivers/gp</span></span><br><span class="line">io/gpio-mxc.c:<span class="number">274</span></span><br><span class="line"><span class="meta">#8 0x805006fc in mx3_gpio_irq_handler (desc=&lt;optimized out&gt;) at drivers/gpio/gpio-mx</span></span><br><span class="line">c.c:<span class="number">291</span></span><br><span class="line"><span class="meta">#9 0x8026f7f8 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/i</span></span><br><span class="line">rqdesc.h:<span class="number">150</span></span><br><span class="line"><span class="meta">#10 generic_handle_irq (irq=&lt;optimized out&gt;) at kernel/irq/irqdesc.c:590</span></span><br><span class="line"><span class="meta">#11 0x8026fd0c in __handle_domain_irq (domain=0x86006000, hwirq=32, lookup=true, regs</span></span><br><span class="line">=<span class="number">0x86517fb0</span>) at kernel/irq/irqdesc.c:<span class="number">627</span></span><br><span class="line"><span class="meta">#12 0x80201484 in handle_domain_irq (regs=&lt;optimized out&gt;, hwirq=&lt;optimized out&gt;, dom</span></span><br><span class="line">ain=&lt;optimized <span class="keyword">out</span>&gt;) at ./include/linux/irqdesc.h:<span class="number">168</span></span><br><span class="line"><span class="meta">#13 gic_handle_irq (regs=0xc8) at drivers/irqchip/irq-gic.c:364</span></span><br><span class="line"><span class="meta">#14 0x8020b704 in __irq_usr () at arch/arm/kernel/entry-armv.S:464</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/11.png" alt="image"></p>
<p>从打印可以看出注册的上半部硬件中断<code>handler</code>的调用流程。</p>
<h3><span id="4-2-2-thread-fn-de-diao-yong-guo-cheng">4.2.2 <code>thread_fn</code>的调用过程</span><a href="#4-2-2-thread-fn-de-diao-yong-guo-cheng" class="header-anchor">#</a></h3><p>来看<code>gpio_keys_gpio_isr</code>是如何一层层调用上来的。从<code>__handle_irq_event_percpu</code>开始分析：（它在<code>kernel\irq\handle.c</code>中）<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/12.png" alt="image"><br>执行上半部提供的的<code>handler</code>函数。判断上半部返回值如果是<code>IRQ_WAKE_THREAD</code>，就调用<code>__irq_wake_thread</code>唤醒中断线程处理函数。</p>
<p>如果上半部返回值是<code>IRQ_HANDLED</code>,表示该中断无需线程化处理，直接退出。</p>
<h4><span id="4-2-2-1-irq-wake-thread-fen-xi">4.2.2.1 <code>__irq_wake_thread</code>分析</span><a href="#4-2-2-1-irq-wake-thread-fen-xi" class="header-anchor">#</a></h4><p>它在<code>kernel\irq\handle.c</code>中:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __irq_wake_thread(<span class="keyword">struct</span> irq_desc *desc, <span class="keyword">struct</span> irqaction *action)&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_active);</span><br><span class="line">	wake_up_process(action-&gt;thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唤醒的是谁，就是<code>action-&gt;thread</code>，也就是对应前面<code>kthread_create</code>出来的<code>irq_thread</code>，再次贴图如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/13.png" alt="image"></p>
<h4><span id="4-2-2-2-irq-thread-han-shu-fen-xi">4.2.2.2 irq_thread函数分析</span><a href="#4-2-2-2-irq-thread-han-shu-fen-xi" class="header-anchor">#</a></h4><p>在<code>kernel\irq\manage.c</code>，平时<code>irq_thread</code>是处于休眠idle状态，不占用cpu资源。</p>
<p>当被唤醒后，<code>irq_thread</code>进入唤醒状态调用<code>handler_fn</code>，也就是最终使用者预先设定的<code>action-&gt;thread_fn</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupt handler thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">irq_thread</span><span class="params">(<span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> <span class="title">on_exit_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">action</span> =</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_to_desc(action-&gt;irq);</span><br><span class="line">	<span class="type">irqreturn_t</span> (*handler_fn)(<span class="keyword">struct</span> irq_desc *desc,</span><br><span class="line">			<span class="keyword">struct</span> irqaction *action);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (force_irqthreads &amp;&amp; test_bit(IRQTF_FORCED_THREAD,</span><br><span class="line">					&amp;action-&gt;thread_flags))</span><br><span class="line">		handler_fn = irq_forced_thread_fn;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		handler_fn = irq_thread_fn;</span><br><span class="line"></span><br><span class="line">	init_task_work(&amp;on_exit_work, irq_thread_dtor);</span><br><span class="line">	task_work_add(current, &amp;on_exit_work, <span class="literal">false</span>);</span><br><span class="line">	irq_thread_check_affinity(desc, action);</span><br><span class="line">	<span class="keyword">while</span> (!irq_wait_for_interrupt(action)) &#123;</span><br><span class="line">		<span class="type">irqreturn_t</span> action_ret;</span><br><span class="line">		irq_thread_check_affinity(desc, action);</span><br><span class="line">		action_ret = handler_fn(desc, action);<span class="comment">//调用irq_thread_fn</span></span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_HANDLED)</span><br><span class="line">			<span class="type">atomic_inc</span>(&amp;desc-&gt;threads_handled);</span><br><span class="line">		<span class="keyword">if</span> (action_ret == IRQ_WAKE_THREAD)</span><br><span class="line">			irq_wake_secondary(desc, action);</span><br><span class="line">		wake_threads_waitq(desc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts explicitly requested as threaded interrupts want to be</span></span><br><span class="line"><span class="comment"> * preemtible - many of them need to sleep and wait for slow busses to</span></span><br><span class="line"><span class="comment"> * complete.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">irq_thread_fn</span><span class="params">(<span class="keyword">struct</span> irq_desc *desc,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> irqaction *action)</span>&#123;</span><br><span class="line">	<span class="type">irqreturn_t</span> ret;</span><br><span class="line">	ret = action-&gt;thread_fn(action-&gt;irq, action-&gt;dev_id);<span class="comment">//调用使用者预先设定的action-&gt;thread_fn</span></span><br><span class="line">	irq_finalize_oneshot(desc, action);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/15.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/" data-id="clzp8uttf003y9oufh6ujezxm" data-title="字符设备驱动-9-中断子系统-中断线程化-threaded_irq" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断线程化-workqueue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/" class="article-date">
  <time class="dt-published" datetime="2024-08-11T06:43:08.000Z" itemprop="datePublished">2024-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/">字符设备驱动-9-中断子系统-中断线程化-workqueue</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</a><ul>
<li><a href="#1-1-work-struct-miao-shu">1.1 work_struct描述</a><ul>
<li><a href="#1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</a></li>
<li><a href="#1-1-2-shi-yong-work">1.1.2 使用work</a></li>
<li><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</a><ul>
<li><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</a></li>
<li><a href="#2-2-fen-xi">2.2 分析</a></li>
</ul>
</li>
<li><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</a><ul>
<li><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</a></li>
<li><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</a></li>
<li><a href="#3-3-schedule-work">3.3 schedule_work</a><ul>
<li><a href="#3-3-1-queue-work">3.3.1 <code>__queue_work</code></a><ul>
<li><a href="#3-3-1-1-insert-work">3.3.1.1 insert_work</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-worker-thread-diao-du">3.4 worker_thread调度</a></li>
<li><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gong-zuo-dui-lie-workqueue-yin-ru">1工作队列workqueue引入</span><a href="#1-gong-zuo-dui-lie-workqueue-yin-ru" class="header-anchor">#</a></h1><p>定时器、<code> tasklet</code>，它们都是在中断上下文中执行（<code>softirq</code>中完成的），它们无法休眠。那么如果一旦中断要处理耗时复杂的操作，就会显得很卡。那么使用内核线程来处理这些耗时的工作，那就可以解决系统卡顿的问题。<br>Linux内核中<code>工作队列workqueue</code>就是线程化处理的一种方式，<code>“工作队列”(workqueue)</code>, 它是内核自带的<code>内核线程</code>。要使用<code>“工作队列”</code>，只需要把<code>“工作”</code>放入<code>“工作队列&quot;</code>中，对应的内核线程就会取出 <code>“工作”</code>，执行里面的函数。</p>
<p>工作队列的应用场合：<br>要做的事情比较耗时，甚至可能需要休眠，那么可以使用工作队列。<br>缺点：多个工作(函数)是在某个内核线程中依序执行的，前面函数执行很慢，就会影响到后面的函数。<br>在多 CPU 的系统下，一个工作队列可以有多个内核线程，可以在一定程度上缓解这个问题。</p>
<p>工队队列的源码机制在<code>Linux-4.9.88\kernel\workqueue.c</code>，头文件在<code>Linux-4.9.88\include\linux\workqueue.h</code></p>
<h2><span id="1-1-work-struct-miao-shu">1.1 work_struct描述</span><a href="#1-1-work-struct-miao-shu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="type">atomic_long_t</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">	<span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/2.png" alt="image"><br>表示一个work结构，一个任务或者叫做一个工作，里面的<code>.func</code>表示是要执行的任务函数，类型定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">work_func_t</span>)</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-ding-yi-yi-ge-work">1.1.1 定义一个work</span><a href="#1-1-1-ding-yi-yi-ge-work" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct work_struct n = __WORK_INITIALIZER(n, f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_DELAYED_WORK(n, f) \</span></span><br><span class="line"><span class="meta">struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第 1 个宏是用来定义一个 work_struct 结构体，要指定它的函数。</span></span><br><span class="line"><span class="comment">//第 2 个宏用来定义一个 delayed_work 结构体，也要指定它的函数。所以“delayed”</span></span><br><span class="line">   <span class="comment">// ，意思就是说要让它运行时，可以指定：某段时间之后你再执行</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/3.png" alt="image"><br>定义一个work为<code>n</code>, 并且初始化函数<code>f</code>.</p>
<p>如果代码中定义好了一个work_struct结构体，那么可以用<code>INIT_WORK</code>函数来初始化：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/4.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line"><span class="meta">	__INIT_WORK((_work), (_func), 0)</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-shi-yong-work">1.1.2 使用work</span><a href="#1-1-2-shi-yong-work" class="header-anchor">#</a></h3><p>初始化完work后，调用<strong>schedule_work</strong>即可调度工作队列进行处理当前任务。<br>调用 <code>schedule_work </code>时，就会把<code>work_struct</code> 结构体放入队列<code>system_wq</code>中，并唤醒对应的内核线程。内核线程就会从队列里把 work_struct 结构体取出来，执行里面的函数。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/6.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * schedule_work - put work task in global workqueue</span></span><br><span class="line"><span class="comment"> * @work: job to be done</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns %false if @work was already on the kernel-global workqueue and</span></span><br><span class="line"><span class="comment"> * %true otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This puts a job in the kernel-global workqueue if it was not already</span></span><br><span class="line"><span class="comment"> * queued and leaves it in the same position on the kernel-global</span></span><br><span class="line"><span class="comment"> * workqueue otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>system_wq</code>是内核自带的队列，结构属性为<code>struct workqueue_struct</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/7.png" alt="image"><br>如果不想用内核自带的<strong>system_wq</strong>来调度我们的work, 那么可以调用<strong>create_workqueue</strong>函数自行创建工队队列。然后用<strong>queue_work</strong>函数使能.</p>
<h3><span id="1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu">1.1.3 工作队列相关函数</span><a href="#1-1-3-gong-zuo-dui-lie-xiang-guan-han-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>create_workqueue</td>
<td>在 Linux 系统中已经有了现成的 system_wq 等工作队列，你当然也可以自己调用 create_workqueue 创建工作队列，对于 SMP 系统，这个工作队列会有多个内核线程与它对应，创建工作队列时，内核会帮这个工作队列创建多个内核线程</td>
</tr>
<tr>
<td>create_singlethread_workqueue</td>
<td>如果想只有一个内核线程与工作队列对应，可以用本函数创建工作队列，创建工作队列时，内核会帮这个工作队列创建一个内核线程</td>
</tr>
<tr>
<td>destroy_workqueue</td>
<td>销毁工作队列</td>
</tr>
<tr>
<td>schedule_work</td>
<td>调度执行一个具体的 work，执行的 work 将会被挂入 Linux 系统提供的工作队列</td>
</tr>
<tr>
<td>schedule_delayed_work</td>
<td>延迟一定时间去执行一个具体的任务，功能与 schedule_work 类似，多了一个延迟时间</td>
</tr>
<tr>
<td>queue_work</td>
<td>跟 schedule_work 类似，schedule_work 是在系统默认的工作队列上执行一个work，queue_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>queue_delayed_work</td>
<td>跟 schedule_delayed_work 类似，schedule_delayed_work 是在系统默认的工作队列上执行一个 work，queue_delayed_work 需要自己指定工作队列</td>
</tr>
<tr>
<td>flush_work</td>
<td>等待一个 work 执行完毕，如果这个 work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
<tr>
<td>flush_delayed_work</td>
<td>等待一个 delayed_work 执行完毕，如果这个 delayed_work 已经被放入队列，那么本函数等它执行完毕，并且返回 true；如果这个 delayed_work 已经执行完华才调用本函数，那么直接返回 false</td>
</tr>
</tbody></table>
<h1><span id="2-bian-xie-dai-ma-ji-jie-xi">2 编写代码及解析</span><a href="#2-bian-xie-dai-ma-ji-jie-xi" class="header-anchor">#</a></h1><h2><span id="2-1-workqueue-yong-li-qu-dong-yuan-ma">2.1 workqueue用例驱动源码</span><a href="#2-1-workqueue-yong-li-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/workqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_work_func</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> container_of(work, <span class="keyword">struct</span> gpio_key, work);</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_work_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;key_work_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="comment">//printk(&quot;gpio_key_isr key %d irq happened\n&quot;, gpio_key-&gt;gpio);</span></span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	schedule_work(&amp;gpio_key-&gt;work);</span><br><span class="line">	<span class="keyword">return</span> IRQ_WAKE_THREAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_thread_func</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func: the process is %s pid %d\n&quot;</span>,current-&gt;comm, current-&gt;pid);	</span><br><span class="line">	printk(<span class="string">&quot;gpio_key_thread_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		<span class="comment">/*err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, </span></span><br><span class="line"><span class="comment">        IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,</span></span><br><span class="line"><span class="comment">        &quot;100ask_gpio_key&quot;, &amp;gpio_keys_100ask[i]);*/</span></span><br><span class="line">		err = request_threaded_irq(gpio_keys_100ask[i].irq</span><br><span class="line">              , gpio_key_isr, gpio_key_thread_func</span><br><span class="line">              , IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">              , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);</span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h2><span id="2-2-fen-xi">2.2 分析</span><a href="#2-2-fen-xi" class="header-anchor">#</a></h2><p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/8.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/9.png" alt="image"><br>为每一个按键都建立一个work_struct，并且初始化work。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INIT_WORK(&amp;gpio_keys_100ask[i].work, key_work_func);</span><br></pre></td></tr></table></figure>
<p><code>key_work_func</code>是work里面函数，参数为该work自身。该函数只是简单打印该work的自身属性（work名字，work进程id），然后输出按键值。通过<code>container_of</code>找到父亲结构体<code>gpio_key</code>。<br>注意：current是Linux内核自带的一个变量，外部驱动要引用它只需要包含头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/10.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/11.png" alt="image"></p>
<p>中断到来后，这时候上半部完成清中断等一些列重要操作，使能workqueue工作队列，调用函数<strong>schedule_work</strong>。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12.png" alt="image"><br>内核从系统工作队列<code>system_wq</code>从取出该work，执行里面的函数<code>（key_work_func)</code>。</p>
<p>可以看到<code>current</code>信息：<code>pid为428</code>，内核线程名字为<code>[kworker/0:1]</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/12-1.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/13.png" alt="image"></p>
<h1><span id="3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li">3 工作队列内部机制原理</span><a href="#3-gong-zuo-dui-lie-nei-bu-ji-zhi-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.1 Linux 2.x 的工作队列创建过程</span><a href="#3-1-linux-2-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>代码在<code>kernel\workqueue.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init_workqueues<span class="comment">//函数主体如下</span></span><br><span class="line">keventd_wq = create_workqueue(<span class="string">&quot;events&quot;</span>);</span><br><span class="line"> __create_workqueue((name), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"> for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> err = create_workqueue_thread(cwq, cpu);</span><br><span class="line"> p = kthread_create(worker_thread, cwq, fmt, wq-&gt;name, cpu); </span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/14.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/15.png" alt="image"></p>
<p>会先分配一个workqueue结构创建一个<code>system_wq</code>工作队列，为每一个 CPU，都创建一个名为<code>“events/X”</code>的内核线程，X 从 0 开始。在创建 workqueue 的同时创建内核线程。</p>
<h2><span id="3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng">3.2 Linux 4.x 的工作队列创建过程</span><a href="#3-2-linux-4-x-de-gong-zuo-dui-lie-chuang-jian-guo-cheng" class="header-anchor">#</a></h2><p>Linux4.x 中，内核线程和工作队列是分开创建的。先创建内核线程，在 <code>kernel\workqueue.c </code>中<br>对每一个cpu，都会创建2个<code>work_pool</code>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">init_workqueues <span class="comment">//函数主体如下：</span></span><br><span class="line"><span class="comment">/* initialize CPU pools */</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 都创建 2 个 worker_pool 结构体，它是含有 ID 的 */</span></span><br><span class="line"> <span class="comment">/* 一个 worker_pool 对应普通优先级的 work，第 2 个对应高优先级的 work */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* create the initial worker */</span></span><br><span class="line">for_each_online_cpu(cpu) &#123;</span><br><span class="line"> for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line"> <span class="comment">/* 对每一个 CPU 的每一个 worker_pool，创建一个 worker */</span></span><br><span class="line"><span class="comment">/* 每一个 worker 对应一个内核线程 */</span></span><br><span class="line"> BUG_ON(!create_worker(pool));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/16.png" alt="image"><br><code>create_worker </code>函数代码如下：<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/17.png" alt="image"></p>
<p>创建好内核线程后，再创建<code> workqueue</code>：这里<code>workqueue</code>会和普通优先级的<code>work_pool</code>建立联系，以后给<code>workqueue</code>添加work的时候会放入<code>work_pool</code>中，执行对应<code>work</code>的时候唤醒相对应的<code>work</code>线程，比如<code>kwork/0:1</code><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/18.png" alt="image"></p>
<p><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/19.png" alt="image"></p>
<h2><span id="3-3-schedule-work">3.3 schedule_work</span><a href="#3-3-schedule-work" class="header-anchor">#</a></h2><p><code>schedule_work</code> 会将 work 添加到默认的工作队列也就是 <code>system_wq </code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">schedule_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work(system_wq, work);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;<span class="comment">//queue_work_on ，增加一个参数 WORK_CPU_UNBOUND，这个参数并不是指将当前</span></span><br><span class="line"><span class="comment">//work 绑定到 unbound 类型的 worker_pool 中，只是说明调用者并不指定将当前</span></span><br><span class="line"><span class="comment">//work 绑定到哪个 cpu 上，由系统来分配 cpu.当然，调用者也可以直接使用</span></span><br><span class="line"><span class="comment">//queue_work_on 接口，通过第一个参数来指定当前 work 绑定的 cpu。</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">queue_work_on</span><span class="params">(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">        __queue_work(cpu, wq, work);</span><br><span class="line">        ret = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-1-queue-work">3.3.1 <code>__queue_work</code></span><a href="#3-3-1-queue-work" class="header-anchor">#</a></h3><p>继续调用<code>__queue_work</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __queue_work(<span class="type">int</span> cpu, <span class="keyword">struct</span> workqueue_struct *wq,</span><br><span class="line">             <span class="keyword">struct</span> work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取 cpu 相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)</span><br><span class="line">        cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查当前的 work 是不是在这之前被添加到其他 worker_pool 中，</span></span><br><span class="line">    <span class="comment">//如果是，就让它继续在原本的 worker_pool 上运行</span></span><br><span class="line">    last_pool = get_work_pool(work);</span><br><span class="line">    <span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">        worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">            pwq = worker-&gt;current_pwq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">            spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">            spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果超过 pwq 支持的最大的 work 数量，将work添加到 pwq-&gt;delayed_works 中</span></span><br><span class="line">    <span class="comment">//，否则就添加到 pwq-&gt;pool-&gt;worklist 中。  </span></span><br><span class="line">    <span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">        trace_workqueue_activate_work(work);</span><br><span class="line">        pwq-&gt;nr_active++;</span><br><span class="line">        worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">        <span class="keyword">if</span> (list_empty(worklist))</span><br><span class="line">            pwq-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">        worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加 work 到队列中。</span></span><br><span class="line">    insert_work(pwq, work, worklist, work_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要由3个部分组成：</p>
<ol>
<li>获取 cpu 参数</li>
<li>检查冲突</li>
<li>添加 work 到队列<code>insert_work</code></li>
</ol>
<h4><span id="3-3-1-1-insert-work">3.3.1.1 insert_work</span><a href="#3-3-1-1-insert-work" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">insert_work</span><span class="params">(<span class="keyword">struct</span> pool_workqueue *pwq, <span class="keyword">struct</span> work_struct *work,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> list_head *head, <span class="type">unsigned</span> <span class="type">int</span> extra_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> pwq-&gt;pool;</span><br><span class="line">    <span class="comment">//设置 work 的 pwq 和 flag。</span></span><br><span class="line">    set_work_pwq(work, pwq, extra_flags);</span><br><span class="line">    <span class="comment">//将 work 添加到 worklist 链表中</span></span><br><span class="line">    list_add_tail(&amp;work-&gt;entry, head);</span><br><span class="line">    <span class="comment">//为 pwq 添加引用计数</span></span><br><span class="line">    get_pwq(pwq);</span><br><span class="line">    <span class="comment">//添加内存屏障，防止 cpu 将指令乱序排列</span></span><br><span class="line">    smp_mb();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒 worker 对应的内核线程</span></span><br><span class="line">    <span class="keyword">if</span> (__need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单地说，就是将<code> work</code> 插入到<code>worker_pool-&gt;worklist</code>中。<br>添加完之后，就会唤醒<code> worker_pool</code> 中第一个处于<code>idle</code>状态<code>worker-&gt;task</code>内核线程，work 就会进入到待处理状态。</p>
<h2><span id="3-4-worker-thread-diao-du">3.4 worker_thread调度</span><a href="#3-4-worker-thread-diao-du" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">worker_thread</span><span class="params">(<span class="type">void</span> *__worker)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> =</span> __worker;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> =</span> worker-&gt;pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">    spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    <span class="comment">//在必要的时候删除 worker，退出当前线程。</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">        spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">        WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">        worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">        set_task_comm(worker-&gt;task, <span class="string">&quot;kworker/dying&quot;</span>);</span><br><span class="line">        ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">        worker_detach_from_pool(worker, pool);</span><br><span class="line">        kfree(worker);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">    <span class="comment">//管理 worker 线程</span></span><br><span class="line">    <span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">        <span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">        <span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行 work</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line">            list_first_entry(&amp;pool-&gt;worklist,</span><br><span class="line">                     <span class="keyword">struct</span> work_struct, entry);</span><br><span class="line"></span><br><span class="line">        pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">            process_one_work(worker, work);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">                process_scheduled_works(worker);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">            process_scheduled_works(worker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (keep_working(pool));</span><br><span class="line"></span><br><span class="line">    worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">    <span class="comment">//处理完成，陷入睡眠</span></span><br><span class="line">    worker_enter_idle(worker);</span><br><span class="line">    __set_current_state(TASK_IDLE);</span><br><span class="line">    spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">    schedule();</span><br><span class="line">    <span class="keyword">goto</span> woke_up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>worker_thread</code>函数主要包括以下的几个主要部分：</p>
<ol>
<li>管理 worker</li>
<li>执行 work<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.1</span> 从当前worker_pool-&gt;worklist 中的链表元素取出work</span><br><span class="line"><span class="number">2.2</span> move_linked_works 将会在执行前将 work 添加到 worker-&gt;scheduled 链表中</span><br><span class="line">    ，该接口和 list_add_tail 不同的是，这个接口会先删除链表中存在的节点并重新添加，</span><br><span class="line">	保证不会重复添加，且始终添加到最后一个节点。</span><br><span class="line"><span class="number">2.3</span> process_scheduled_works 函数正式执行 work，该函数会遍历 worker-&gt;scheduled 链表，</span><br><span class="line">    执行每一个 work，执行之前会做一些必要的检查，比如在同一个 cpu 上，</span><br><span class="line">	一个 worker 不能在多个 worker 线程中被并发执行(这里的并发执行指的是同时加入到 schedule 链表)，</span><br><span class="line">    是否需要唤醒其它的 worker 来协助执行(碰到 cpu 消耗型的work 需要这么做)，</span><br><span class="line">    执行 work 的方式就是调用 work-&gt;func</span><br></pre></td></tr></table></figure>
当执行完<code>worker_pool-&gt;worklist</code> 中所有的<code>work</code>之后，当前线程就会陷入睡眠.</li>
</ol>
<h2><span id="3-5-linux5-1-x-ban-ben-de-workqueue-bug">3.5 linux5.1.x版本的workqueue bug</span><a href="#3-5-linux5-1-x-ban-ben-de-workqueue-bug" class="header-anchor">#</a></h2><p>在多核<code>cpu</code>调度时，使用<code>workqueue</code>会小概率出现<code>WARNING: CPU: x PID: xx at linux_5.10/kernel/workqueue.c:1796 worker_enter_idle</code><br>的<code>call trace</code>提示，然后cpu进入idel休眠状态。<br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/20.png" alt="image"></p>
<p>由于如果在 <code>WORKER_NOT_RUNNING </code>检查时和下面的 <code>nr_running </code>增量之间被<code>unbind_workers()</code>抢占，我们可能会破坏 <code>nr_running </code>重置并在新的未绑定池上留下意外的<code> pool-&gt;nr_running == 1</code> 。</p>
<p>为了 防止这样的竞态产生，linux内核patch参考:<br><a target="_blank" rel="noopener" href="https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/">https://lore.kernel.org/lkml/20220114081544.899493450@linuxfoundation.org/</a><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/21.png" alt="image"><br><img src="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/22.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-workqueue/" data-id="clzp8uttg00409oufffvc9qgc" data-title="字符设备驱动-9-中断子系统-中断线程化-workqueue" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断下半部-tasklet" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T12:44:36.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/">字符设备驱动-9-中断子系统-中断下半部-tasklet</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tasklet-yin-ru">1 tasklet引入</a></li>
<li><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</a></li>
<li><a href="#3-tasklet-shi-yong">3 tasklet使用</a><ul>
<li><a href="#3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</a><ul>
<li><a href="#3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</a></li>
<li><a href="#3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</a></li>
<li><a href="#3-1-2-tasklet-init">3.1.2 tasklet_init</a></li>
<li><a href="#3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</a></li>
</ul>
</li>
<li><a href="#3-2-shi-neng-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</a></li>
<li><a href="#3-3-diao-du-tasklet">3.3 调度tasklet</a></li>
<li><a href="#3-4-zhi-xing-tasklet">3.4 执行tasklet</a></li>
<li><a href="#3-5-tasklet-kill">3.5 tasklet_kill</a></li>
</ul>
</li>
<li><a href="#4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</a><ul>
<li><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</a></li>
<li><a href="#4-2-fen-xi">4.2 分析</a></li>
</ul>
</li>
<li><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</a><ul>
<li><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tasklet-yin-ru">1 tasklet引入</span><a href="#1-tasklet-yin-ru" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/">字符设备驱动-9-中断子系统-中断引入 | Hexo (fuzidage.github.io)</a></p>
<p>介绍了硬件中断和软件中断，硬件中断有gpio中断，网卡，外部电路IP引起的中断，而软件中断则有定时器，tasklet这些为软件中断。cpu会先处理硬件中断，然后处理软件中断。</p>
<p>简单说可以认为内核中有一个数组softirq[], 里面有很多项，某一项对应timer，某一项表示tasklet, 每一项中都有一个<code>.action</code>函数，当内核处理完某一个硬件中断之后，处理软件中断时会找到对应的项，找到<code>.action</code>函数执行。</p>
<p>对于<code>tasklet</code>软件中断，它的<code>.action</code>函数对应<code>tasklet_action</code>,这个函数会从链表里取出每一个<code>tasklet</code>结构，执行里面的<code>.func</code>函数。</p>
<p>内核处理硬件中断的过程叫做中断上半部，处理软件中断的过程叫做中断下半部。上半部执行过程中，中断是禁止的，这里防止中断嵌套，也就是说来了更紧急的硬件中断，也要等这个上半部分处理完，上半部一般处理重要紧急事情。下半部执行过程中，中断是使能的，因此在下半部的处理过程它是可以响应其他中断。因此如果有不紧急但是耗时的事情放在下半部来处理，比如用tasklet。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/1.png" alt="image"></p>
<h1><span id="2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen">2 tasklet是如何从从上半部调度到下半部分</span><a href="#2-tasklet-shi-ru-he-cong-cong-shang-ban-bu-diao-du-dao-xia-ban-bu-fen" class="header-anchor">#</a></h1><p>如何使能或者说调度tasklet呢？它其实就是把一个tasklet放入到内核tasklet链表中，假如硬件中断服务函数func_A(), 软件中断中也就是下半部放入tasklet中断的服务函数为func_B(), 那么可以想象看A和B被调度的次数因该是多对1的关系，应为软件中断由于是使能中断的，因此func_A()对应的硬件又可能会产生硬件中断。</p>
<h1><span id="3-tasklet-shi-yong">3 tasklet使用</span><a href="#3-tasklet-shi-yong" class="header-anchor">#</a></h1><h2><span id="3-1-chu-shi-hua-tasklet">3.1 初始化tasklet</span><a href="#3-1-chu-shi-hua-tasklet" class="header-anchor">#</a></h2><h3><span id="3-1-0-tasklet-jie-gou-ti">3.1.0 tasklet结构体</span><a href="#3-1-0-tasklet-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span><span class="comment">//tasklet链表</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> state;<span class="comment">//RUN表示正在运行，SCHED表示已被调度</span></span><br><span class="line">	<span class="type">atomic_t</span> count;<span class="comment">//0表示处于激活状态，不为0表示该tasklet禁止，不允许执行</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);<span class="comment">//处理函数，等效softirq的action函数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>\include\linux\interrupt.h</code><br>state 有 2 位：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">◼ bit0 表示 TASKLET_STATE_SCHED</span><br><span class="line">等于 <span class="number">1</span> 时表示已经执行了 tasklet_schedule 把该 tasklet 放入队列了；(等于<span class="number">1</span>表示放入队列就绪了)</span><br><span class="line">tasklet_schedule 会判断该位，如果已经等于 <span class="number">1</span> 那么它就不会再次把tasklet 放入队列。</span><br><span class="line">◼ bit1 表示 TASKLET_STATE_RUN</span><br><span class="line">等于 <span class="number">1</span> 时，表示正在运行 tasklet 中的 func 函数；函数执行完后内核会把该位清 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<p>count 表示该 tasklet 是否使能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等于 <span class="number">0</span> 表示使能了，非 <span class="number">0</span> 表示被禁止了。对于 count 非 <span class="number">0</span> 的 tasklet，里面的 func 函数不会被执行</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-1-tasklet-lian-biao">3.1.1 tasklet链表</span><a href="#3-1-1-tasklet-lian-biao" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> &#123;</span>                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> **<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>; <span class="comment">//kernel/softirq.c</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br><span class="line"><span class="comment">//对应softirq的TASKLET_SOFTIRQ和HI_SOFTIRQ， 优先级分别为6和0</span></span><br></pre></td></tr></table></figure>

<p>tasklet执行过程<code> TASKLET_SOFTIRQ</code>对应执行函数为<code>tasklet_action</code>，<code>HI_SOFTIRQ</code>为<code>tasklet_hi_action</code>。</p>
<h3><span id="3-1-2-tasklet-init">3.1.2 tasklet_init</span><a href="#3-1-2-tasklet-init" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">tasklet_init</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t, <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>), <span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-declare-tasklet">3.1.3 DECLARE_TASKLET</span><a href="#3-1-3-declare-tasklet" class="header-anchor">#</a></h3><p><code>DECLARE_TASKLET</code>和<code>DECLARE_TASKLET_DISABLED</code>可以定义一个tasklet结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 DECLARE_TASKLET 定义的 tasklet 结构体，它是使能的；</span></span><br><span class="line"><span class="comment">//使用 DECLARE_TASKLET_DISABLED 定义的 tasklet 结构体，它是禁止的；使用之前要先调用 tasklet_enable 使能它。</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shi-neng-x2f-jin-zhi-tasklet">3.2 使能&#x2F;禁止 tasklet</span><a href="#3-2-shi-neng-x2f-jin-zhi-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_enable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_disable</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/5.png" alt="image"></p>
<h2><span id="3-3-diao-du-tasklet">3.3 调度tasklet</span><a href="#3-3-diao-du-tasklet" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/6.png" alt="image"><br>把 <code>tasklet</code> 放入链表，并且设置它的 <code>TASKLET_STATE_SCHED </code>状态为1。<code>tasklet_schedule</code> 只是把 tasklet 放入内核队列，它的 <code>func</code> 函数会在软件中断的执行过程中被调用。</p>
<h2><span id="3-4-zhi-xing-tasklet">3.4 执行tasklet</span><a href="#3-4-zhi-xing-tasklet" class="header-anchor">#</a></h2><p>对于 <code>TASKLET_SOFTIRQ</code> 类型的 <code>softirq</code>，其handler是 <code>tasklet_action</code>，可以看到软中断执行，硬件中断是使能的。执行对应的<code>func</code>函数。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/7.png" alt="image-20240810224518977"></p>
<h2><span id="3-5-tasklet-kill">3.5 tasklet_kill</span><a href="#3-5-tasklet-kill" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_kill</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span>；</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果一个 tasklet 未被调度， tasklet_kill 会把它的TASKLET_STATE_SCHED 状态清 0；</span></span><br><span class="line"><span class="comment">//如果一个 tasklet 已被调度，tasklet_kill 会等待它执行完华，再把它的TASKLET_STATE_SCHED 状态清 0。</span></span><br></pre></td></tr></table></figure>

<p>通常在卸载驱动程序时调用 <code>tasklet_kill</code>。</p>
<h1><span id="4-tasklet-dai-ma-shi-li-jie-xi">4 tasklet代码示例解析</span><a href="#4-tasklet-dai-ma-shi-li-jie-xi" class="header-anchor">#</a></h1><h2><span id="4-1-tasklet-shi-yong-qu-dong-yuan-ma">4.1 tasklet使用驱动源码</span><a href="#4-1-tasklet-shi-yong-qu-dong-yuan-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">key_timer</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125; ;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_LEN 128</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_keys[BUF_LEN];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> r, w;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">button_fasync</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_POS(x) ((x+1) % BUF_LEN)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_empty</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">is_key_buf_full</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (r == NEXT_POS(w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put_key</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_full())&#123;</span><br><span class="line">		g_keys[w] = key;</span><br><span class="line">		w = NEXT_POS(w);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_key</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">int</span> key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (!is_key_buf_empty())&#123;</span><br><span class="line">		key = g_keys[r];</span><br><span class="line">		r = NEXT_POS(r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_timer_expire</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;key_timer_expire key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	put_key(key);</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	kill_fasync(&amp;button_fasync, SIGIO, POLL_IN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">key_tasklet_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>&#123;</span><br><span class="line">	<span class="comment">/* data ==&gt; gpio */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> data;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key_tasklet_func key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	<span class="keyword">if</span> (is_key_buf_empty() &amp;&amp; (file-&gt;f_flags &amp; O_NONBLOCK))</span><br><span class="line">		<span class="keyword">return</span> -EAGAIN;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, !is_key_buf_empty());</span><br><span class="line">	key = get_key();</span><br><span class="line">	err = copy_to_user(buf, &amp;key, <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_poll</span><span class="params">(<span class="keyword">struct</span> file *fp, poll_table * wait)</span>&#123;</span><br><span class="line">	poll_wait(fp, &amp;gpio_key_wait, wait);</span><br><span class="line">	<span class="keyword">return</span> is_key_buf_empty() ? <span class="number">0</span> : POLLIN | POLLRDNORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_drv_fasync</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> file *file, <span class="type">int</span> on)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fasync_helper(fd, file, on, &amp;button_fasync) &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">	.poll    = gpio_key_drv_poll,</span><br><span class="line">	.fasync  = gpio_key_drv_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	tasklet_schedule(&amp;gpio_key-&gt;tasklet);</span><br><span class="line">	mod_timer(&amp;gpio_key-&gt;key_timer, jiffies + HZ/<span class="number">50</span>);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count)&#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;		</span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line"></span><br><span class="line">		setup_timer(&amp;gpio_keys_100ask[i].key_timer, key_timer_expire, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		gpio_keys_100ask[i].key_timer.expires = ~<span class="number">0</span>;</span><br><span class="line">		add_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line"></span><br><span class="line">		tasklet_init(&amp;gpio_keys_100ask[i].tasklet, key_tasklet_func, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr</span><br><span class="line">		, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv); </span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">		del_timer(&amp;gpio_keys_100ask[i].key_timer);</span><br><span class="line">		tasklet_kill(&amp;gpio_keys_100ask[i].tasklet);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>用户态测试代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fd;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1];</span></span><br><span class="line">	<span class="type">int</span> timeout_ms = <span class="number">5000</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="type">int</span>	flags;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR | O_NONBLOCK);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	flags = fcntl(fd, F_GETFL);</span><br><span class="line">	fcntl(fd, F_SETFL, flags &amp; ~O_NONBLOCK);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (read(fd, &amp;val, <span class="number">4</span>) == <span class="number">4</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get button: 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;while get button: -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h2><span id="4-2-fen-xi">4.2 分析</span><a href="#4-2-fen-xi" class="header-anchor">#</a></h2><p>probe函数中为每一个gpio按键都创建一个<code>tasklet</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/10.png" alt="image"><br>当按键按下，中断服务执行，那么此时需要调度tasklet去完成中断下半部的事情，每当一个按键按下，就会执行一次tasklet里面的函数，也就是<code>key_tasklet_func</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/11.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/12.png" alt="image"><br>根据不同的gpio带来不同的data，这里<code>key_tasklet_func</code>下半部分只是简单打印出对应哪一个gpio，输出什么电平。<br>最终驱动卸载时调用<code>tasklet_kill</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/13.png" alt="image"></p>
<h1><span id="5-tasklet-nei-bu-ji-zhi-pou-xi">5 tasklet内部机制剖析</span><a href="#5-tasklet-nei-bu-ji-zhi-pou-xi" class="header-anchor">#</a></h1><h2><span id="5-1-tasklet-action-de-zhi-xing-guo-cheng">5.1 tasklet_action的执行过程</span><a href="#5-1-tasklet-action-de-zhi-xing-guo-cheng" class="header-anchor">#</a></h2><p><code>tasklet</code>属于<code>TASKLET_SOFTIRQ</code>软件中断，入口函数为<code>tasklet_action</code>，这在内核<code> kernel\softirq.c</code> 中设置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/14.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/15.png" alt="image"></p>
<p>当驱动程序调用<code> tasklet_schedule</code> 时，会设置 tasklet 的<code>state</code>为<code>TASKLET_STATE_SCHED</code>，并把它放入内核<code>tasklet链表</code>:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/16.png" alt="image"><br>触发<code>TASKLET_SOFTIRQ </code>软件中断，会调用 <code>tasklet_action </code>函数，遍历<code>tasklet </code>链表，进行状态判断后执行<code> .func</code><br>函数，从队列中删除 <code>tasklet</code>。<br>可以看出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>tasklet_schedule 调度 tasklet 时，其中的函数并不会立刻执行，而只是把tasklet 放入队列</span><br><span class="line"><span class="number">2.</span>调用一次 tasklet_schedule，只会导致 tasklet 的函数被执行一次；如果 tasklet 的函数尚未执行</span><br><span class="line">    ，多次调用 tasklet_schedule 也是无效的，只会放入队列一次，TASKLET_STATE_SCHED状态会自行判断。</span><br></pre></td></tr></table></figure>
<p>最终tasklet中的<code>func</code>执行要看<code>tasklet_action</code>的过程分析：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/17.png" alt="image"><br>首先从链表中取出每一项<code>tasklet</code>, 读取<code>count</code>, 如果等于0表示有使能该<code>tasklet</code>, 清除<code>TASKLET_STATE_SCHED</code>位，并且执行<code>t-&gt;func</code>，执行完该task中的<code>func</code>后从链表取出并且删除掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8-tasklet/" data-id="clzp8uttf003r9oufcsos6iiv" data-title="字符设备驱动-9-中断子系统-中断下半部-tasklet" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断设备树表述与解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T11:30:34.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/">字符设备驱动-9-中断子系统-中断设备树表述与解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</a><ul>
<li><a href="#1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</a></li>
<li><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</a><ul>
<li><a href="#1-2-1-interrupt-controller">1.2.1 interrupt-controller</a></li>
<li><a href="#1-2-2-interrupt-cells">1.2.2 interrupt-cells</a></li>
<li><a href="#1-2-3-interrupt-parent">1.2.3 interrupt-parent</a></li>
<li><a href="#1-2-4-interrupts">1.2.4 interrupts</a></li>
</ul>
</li>
<li><a href="#1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</a><ul>
<li><a href="#1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</a><ul>
<li><a href="#1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</a></li>
</ul>
</li>
<li><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</a><ul>
<li><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</a></li>
</ul>
</li>
<li><a href="#1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</a><ul>
<li><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</a><ul>
<li><a href="#2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</a><ul>
<li><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</a></li>
<li><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</a></li>
</ul>
</li>
<li><a href="#2-2-qu-dong-dai-ma">2.2 驱动代码</a><ul>
<li><a href="#2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu">1 中断在设备树中的表述</span><a href="#1-zhong-duan-zai-she-bei-shu-zhong-de-biao-shu" class="header-anchor">#</a></h1><h2><span id="1-1-zhong-duan-kong-zhi-qi">1.1 中断控制器</span><a href="#1-1-zhong-duan-kong-zhi-qi" class="header-anchor">#</a></h2><p>如图：GPIO1 连接到 GIC，GPIO2 连接到 GIC，所以 GPIO1 的父亲是 GIC，GPIO2的父亲是 GIC。假设 GPIO1 有 32 个中断源，但是它把其中的 16 个汇聚起来向 GIC 发出一个中断，把另外 16 个汇聚起来向 GIC 发出另一个中断。这就意味着 GPIO1 会用到 GIC 的两个中断，会涉及 GIC 里的 2 个 <code>hwirq</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/1.png" alt="image"></p>
<h2><span id="1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing">1.2 设备树中断相关属性</span><a href="#1-2-she-bei-shu-zhong-duan-xiang-guan-shu-xing" class="header-anchor">#</a></h2><p>设备树中，中断控制器节点中必须有一个属性：</p>
<h3><span id="1-2-1-interrupt-controller">1.2.1 interrupt-controller</span><a href="#1-2-1-interrupt-controller" class="header-anchor">#</a></h3><p>表明它是 <code>“中断控制器”</code>。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/2.png" alt="image"></p>
<h3><span id="1-2-2-interrupt-cells">1.2.2 interrupt-cells</span><a href="#1-2-2-interrupt-cells" class="header-anchor">#</a></h3><p>⚫ <code>#interrupt-cells=&lt;1&gt;</code><br>    别的节点要使用这个中断控制器时，只需要一个 cell 来表明使用 “哪一个中断”</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vic: intc@<span class="number">10140000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;arm,versatile-vic&quot;</span>;</span><br><span class="line">interrupt-controller;</span><br><span class="line"><span class="meta">#interrupt-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x10140000</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>⚫ <code>#interrupt-cells=&lt;2&gt;</code><br>别的节点要使用这个中断控制器时，需要一个 cell 来表明使用 “哪一个中断”；还需要另一个 cell 来描述中断，一般是表明触发类型：<br>    第 2 个 cell 的 bits[3:0] 用来表示中断触发类型(<code>trigger type and level flags</code>)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> = low-to-high edge triggered，上升沿触发</span><br><span class="line"><span class="number">2</span> = high-to-low edge triggered，下降沿触发</span><br><span class="line"><span class="number">4</span> = active high level-sensitive，高电平触发</span><br><span class="line"><span class="number">8</span> = active low level-sensitive，低电平触发</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gpio2: gpio@<span class="number">020</span>a0000 &#123;</span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6q-gpio&quot;</span>, <span class="string">&quot;fsl,imx35-gpio&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x020a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;<span class="number">0</span> <span class="number">68</span> <span class="number">4</span>&gt;,</span><br><span class="line">		  &lt;<span class="number">0</span> <span class="number">69</span> <span class="number">4</span>&gt;;</span><br><span class="line">	gpio-controller;</span><br><span class="line">	<span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">	interrupt-controller;</span><br><span class="line">	<span class="meta">#interrupt-cells = <span class="string">&lt;2&gt;</span>;</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-3-interrupt-parent">1.2.3 interrupt-parent</span><a href="#1-2-3-interrupt-parent" class="header-anchor">#</a></h3><p>你要用哪一个中断控制器里的中断？<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/3.png" alt="image"></p>
<h3><span id="1-2-4-interrupts">1.2.4 interrupts</span><a href="#1-2-4-interrupts" class="header-anchor">#</a></h3><p>你要用哪一个中断？<br><code>Interrupts</code> 里要用几个 cell，由<code>interrupt-parent</code>对应的中断控制器决定。在中断控制器里有<code>“#interrupt-cells”</code>属性，它指明了要用几个 cell来描述中断。比如下图表示用到gpio中断控制器的160号中断，上升沿触发。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/4.png" alt="image"></p>
<h2><span id="1-3-dts-zhong-huo-qu-zhong-duan">1.3 dts中获取中断</span><a href="#1-3-dts-zhong-huo-qu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="1-3-1-dui-yu-platform-device">1.3.1 对于 platform_device</span><a href="#1-3-1-dui-yu-platform-device" class="header-anchor">#</a></h3><h4><span id="1-3-1-1-platform-get-resource">1.3.1.1 platform_get_resource</span><a href="#1-3-1-1-platform-get-resource" class="header-anchor">#</a></h4><p>当平台设备和平台驱动match上后，一个节点能被转换为 <code>platform_device</code>，调用<code>platform_get_resource</code>可获取节点资源信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *,<span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/5.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/6.png" alt="image"><br>如果需要获取中断信息，传入<code>IORESOURCE_IRQ</code>。</p>
<h3><span id="1-3-2-dui-yu-i2c-she-bei-spi-she-bei">1.3.2 对于 I2C 设备、SPI 设备</span><a href="#1-3-2-dui-yu-i2c-she-bei-spi-she-bei" class="header-anchor">#</a></h3><p>I2C 总线驱动在处理设备树里的 I2C 子节点时，Linux总线会自动处理其中的中断信息。一个 I2C 设备会被转换为一个 <code>i2c_client</code>结构体，中断号会保存在 i2c_client 的 irq 成员里，代码如下(<code>drivers/i2c/i2c-core.c</code>)，probe函数里面<strong>of_irq_get</strong>函数会根据dts中的i2c节点获取中断资源。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/7.png" alt="image"></p>
<p><strong>GIC_SPI</strong>表示中断类型为共享中断。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/9.png" alt="image"><br>SPI总线同理，一个 SPI 设备会被转换为一个<code>spi_device</code>结构体，中断号会保存在 <code>spi_device</code> 的 irq 成员里，代码如下(<code>drivers/spi/spi.c</code>)：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/10.png" alt="image"></p>
<h4><span id="1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao">1.3.2.1 调用 of_irq_get 获得中断号</span><a href="#1-3-2-1-diao-yong-of-irq-get-huo-de-zhong-duan-hao" class="header-anchor">#</a></h4><p>如果我们没用<code>platform device</code>架构写字符设备驱动，也可以直接调用<code>of_irq_get</code>获取。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/11.png" alt="image"></p>
<h3><span id="1-3-3-dui-yu-gpio">1.3.3 对于 GPIO</span><a href="#1-3-3-dui-yu-gpio" class="header-anchor">#</a></h3><h4><span id="1-3-3-1-gpio-to-irq-huo-gpiod-to-irq">1.3.3.1 gpio_to_irq或 gpiod_to_irq</span><a href="#1-3-3-1-gpio-to-irq-huo-gpiod-to-irq" class="header-anchor">#</a></h4><p>参考：<code>drivers/input/keyboard/gpio_keys.c</code>， api路径<code>linux_5.10\include\linux\of_gpio.h</code><br>可以使用 <code>gpio_to_irq</code> 或 <code>gpiod_to_irq </code>获得中断号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button-&gt;gpio = of_get_gpio_flags(pp, <span class="number">0</span>, &amp;flags);</span><br><span class="line">bdata-&gt;gpiod = gpio_to_desc(button-&gt;gpio);</span><br><span class="line"><span class="comment">//再去使用 gpiod_to_irq 获得中断号：</span></span><br><span class="line">irq = gpiod_to_irq(bdata-&gt;gpiod)；</span><br></pre></td></tr></table></figure>

<h1><span id="2-bian-xie-yi-ge-an-jian-zhong-duan">2 编写一个按键中断</span><a href="#2-bian-xie-yi-ge-an-jian-zhong-duan" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-dts-pei-zhi">2.1 按键dts配置</span><a href="#2-1-an-jian-dts-pei-zhi" class="header-anchor">#</a></h2><p>linux内核自带的<code>input sub system</code>本身就包含了gpio按键驱动，驱动程序 <code>drivers/input/keyboard/gpio_keys.c</code> 就可以，然后你需要做<br>的只是修改设备树指定引脚及键值。<br>为了简化我们直接写一个例子：强化熟悉对gpio中断的使用。</p>
<p>我们确定好用<code>gpio5_1</code>,  <code>gpio4_14</code>这2个按键来展开实验：定义好dts节点,这里定义<code>gpio_keys_100ask</code>，内核有函数自动把gpio num转成irq。在其他地方dts中(<code>imx6ull.dts</code>中)会描述好gpio5,gpio4节点信息，里面会有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#gpio-cells = <span class="string">&lt;2&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>因此，这里表示引用gpio5的第0个引脚，gpio4的第14个引脚，节点如下，需要把原来的节点<code>gpio-keys</code> disable掉，添加下面的<code>gpio_keys_100ask</code>。进入内核目录 <code>make dtbs</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gpio_keys_100ask &#123;</span><br><span class="line">	compatible = <span class="string">&quot;100ask,gpio_key&quot;</span>;</span><br><span class="line">	gpios = &lt;&amp;gpio5 <span class="number">1</span> GPIO_ACTIVE_HIGH</span><br><span class="line">	&amp;gpio4 <span class="number">14</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;key1_pinctrl &amp;key2_pinctrl&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/12.png" alt="image"></p>
<p>设备树中并没有对这2个引脚进行<code>pinctrl</code>配置，也就是<code>iomux</code>配置，那为什么这2个引脚还能工作，是因为这个个引脚默认就是gpio状态，不用进行<code>iomux</code>切换。<br>为了保险起见，按照标准流程还需要对其添加<code>pinctrl</code>信息。</p>
<h3><span id="2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi">2.1.1 添加2个按键的iomux配置</span><a href="#2-1-1-tian-jia-2-ge-an-jian-de-iomux-pei-zhi" class="header-anchor">#</a></h3><p>imx6ull工具有制作好<code>pinctrl</code>如何配置:<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/13.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/14.png" alt="image"></p>
<p>填入到对应的子节点下面：gpio5的iomux配置放在<code>iomuxc_snvs</code>节点下，gpio4的配置放在<code>iomuxc</code>下。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/15.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/16.png" alt="image"></p>
<h3><span id="2-1-2-ding-yi-an-jian-dts-miao-shu">2.1.2 定义按键dts描述</span><a href="#2-1-2-ding-yi-an-jian-dts-miao-shu" class="header-anchor">#</a></h3><p>再到定义的<code>gpio_keys_100ask</code>引用这2个<code>pinctrl</code>信息 <code>key1_100ask</code>和 <code>key2_100ask</code>。这里pinctrl只有一个default状态，<code>pinctrl-0</code>表示该默认状态，因此最终<code>gpio5_1</code>,  <code>gpio4_14</code>就被<code>iomux</code>成了gpio状态。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/17.png" alt="image"></p>
<h2><span id="2-2-qu-dong-dai-ma">2.2 驱动代码</span><a href="#2-2-qu-dong-dai-ma" class="header-anchor">#</a></h2><details>
<summary>驱动代码如下</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio/consumer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> gpio;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_desc</span> *<span class="title">gpiod</span>;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_keys_100ask</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">gpio_key_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_key = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(gpio_key_wait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">gpio_key_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	wait_event_interruptible(gpio_key_wait, g_key);</span><br><span class="line">	err = copy_to_user(buf, &amp;g_key, <span class="number">4</span>);</span><br><span class="line">	g_key = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">gpio_key_drv</span> =</span> &#123;</span><br><span class="line">	.owner	 = THIS_MODULE,</span><br><span class="line">	.read    = gpio_key_drv_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	g_key = (gpio_key-&gt;gpio &lt;&lt; <span class="number">8</span>) | val;</span><br><span class="line">	wake_up_interruptible(&amp;gpio_key_wait);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 从platform_device获得GPIO</span></span><br><span class="line"><span class="comment"> * 2. gpio=&gt;irq</span></span><br><span class="line"><span class="comment"> * 3. request_irq</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">of_gpio_flags</span> <span class="title">flag</span>;</span></span><br><span class="line"></span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">if</span> (!count) </span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d, there isn&#x27;t any gpio available\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	gpio_keys_100ask = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> gpio_key) * count, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">		gpio_keys_100ask[i].gpio = of_get_gpio_flags(node, i, &amp;flag);</span><br><span class="line">		<span class="keyword">if</span> (gpio_keys_100ask[i].gpio &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			printk(<span class="string">&quot;%s %s line %d, of_get_gpio_flags fail\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		gpio_keys_100ask[i].gpiod = gpio_to_desc(gpio_keys_100ask[i].gpio);</span><br><span class="line">		gpio_keys_100ask[i].flag = flag &amp; OF_GPIO_ACTIVE_LOW;</span><br><span class="line">		gpio_keys_100ask[i].irq  = gpio_to_irq(gpio_keys_100ask[i].gpio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		err = request_irq(gpio_keys_100ask[i].irq, gpio_key_isr, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING</span><br><span class="line">                          , <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>, &amp;gpio_key_drv);  <span class="comment">/* /dev/100ask_gpio_key */</span></span><br><span class="line">	gpio_key_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_gpio_key_class&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(gpio_key_class)) &#123;</span><br><span class="line">		printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">		unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(gpio_key_class);</span><br><span class="line">	&#125;</span><br><span class="line">	device_create(gpio_key_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;100ask_gpio_key&quot;</span>); <span class="comment">/* /dev/100ask_gpio_key */</span>        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gpio_key_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">node</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line">	<span class="type">int</span> count;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	device_destroy(gpio_key_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">	class_destroy(gpio_key_class);</span><br><span class="line">	unregister_chrdev(major, <span class="string">&quot;100ask_gpio_key&quot;</span>);</span><br><span class="line">	count = of_gpio_count(node);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">		free_irq(gpio_keys_100ask[i].irq, &amp;gpio_keys_100ask[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	kfree(gpio_keys_100ask);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ask100_keys</span>[] =</span> &#123;</span><br><span class="line">    &#123; .compatible = <span class="string">&quot;100ask,gpio_key&quot;</span> &#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">gpio_keys_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = gpio_key_probe,</span><br><span class="line">    .remove     = gpio_key_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_gpio_key&quot;</span>,</span><br><span class="line">        .of_match_table = ask100_keys,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gpio_key_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;gpio_keys_driver); </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gpio_key_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;gpio_keys_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(gpio_key_init);</span><br><span class="line">module_exit(gpio_key_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<h3><span id="2-2-1-qu-dong-dai-ma-fen-xi">2.2.1 驱动代码分析</span><a href="#2-2-1-qu-dong-dai-ma-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/18.png" alt="image"></p>
<p>定义<code>gpio_key</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/19.png" alt="image"><br>通过<code>.compatible = &quot;100ask,gpio_key&quot;</code>匹配<code>plateform_device</code>和<code>platform_driver</code>, 当<code>insmod ko</code>时probe函数被调用。<br><code>struct device_node *node = pdev-&gt;dev.of_node;//可以从platform_device获取到device_node</code>。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/20.png" alt="image"><br><code>of_gpio_count</code>可以根据设备树节点获取到gpio的数量。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/21.png" alt="image"><br><code>of_get_gpio_flags</code>可以根据设备树节点获取到<code>gpio</code>编号和<code>gpio flags</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/22.png" alt="image"><br>获取gpio描述子和gpio中断号:</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/23.png" alt="image"><br>注册中断服务程序<code>gpio_key_isr</code>，当按键按下会触发gpio中断，执行<code>gpio_key_isr</code><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/24.png" alt="image"><br>中断服务程序就简单的打印按键的电平状态:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">gpio_key_isr</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpio_key</span> *<span class="title">gpio_key</span> =</span> dev_id;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	val = gpiod_get_value(gpio_key-&gt;gpiod);</span><br><span class="line">	printk(<span class="string">&quot;key %d %d\n&quot;</span>, gpio_key-&gt;gpio, val);</span><br><span class="line">	<span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A1%A8%E8%BF%B0%E4%B8%8E%E8%A7%A3%E6%9E%90/" data-id="clzp8uttm007o9ouf3pmw1l5l" data-title="字符设备驱动-9-中断子系统-中断设备树表述与解析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-9-中断子系统-中断结构体" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/" class="article-date">
  <time class="dt-published" datetime="2024-08-10T10:33:55.000Z" itemprop="datePublished">2024-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/">字符设备驱动-9-中断子系统-中断结构体</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</a></li>
<li><a href="#1-irq-desc-shu-zu">1 irq_desc 数组</a><ul>
<li><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</a><ul>
<li><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</a></li>
<li><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</a></li>
</ul>
</li>
<li><a href="#1-2-irqaction">1.2 irqaction</a><ul>
<li><a href="#1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</a></li>
<li><a href="#1-2-2-request-irq">1.2.2 request_irq</a></li>
<li><a href="#1-2-3-devm-request-irq">1.2.3 devm_request_irq</a></li>
</ul>
</li>
<li><a href="#1-3-irq-data">1.3 irq_data</a></li>
<li><a href="#1-4-irq-domain">1.4 irq_domain</a><ul>
<li><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</a></li>
<li><a href="#1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</a><ul>
<li><a href="#1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</a></li>
<li><a href="#1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-5-irq-chip">1.5 irq_chip</a></li>
</ul>
</li>
<li><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="0-yin-ru-sparse-irq">0 引入SPARSE_IRQ</span><a href="#0-yin-ru-sparse-irq" class="header-anchor">#</a></h1><p>如果内核配置了 <strong>CONFIG_SPARSE_IRQ</strong>，那么它就会用 <strong>基数树(radix tree)</strong> 来代替 irq_desc 数组。<br>SPARSE 的意思是“稀疏”，假设大小为 1000 的数组中只用到 2 个数组项，那不是浪费嘛？当中断比较“稀疏”时可以用基数树来代替数组。<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/1.png" alt="image"></p>
<h1><span id="1-irq-desc-shu-zu">1 irq_desc 数组</span><a href="#1-irq-desc-shu-zu" class="header-anchor">#</a></h1><p>位于<code>include/linux/irqdesc.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/2.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/3.png" alt="在这里插入图片描述"></p>
<p>内核中记录一个<code>irq_desc</code>的数组，数组的每一项对应一个中断或者一组中断（使用同一中断号）。<code>irq_desc</code>几乎记录所有中断相关的东西，这个结构是中断的核心。每一个<code>irq_desc</code>数组项中都有一个函数：<code>handle_irq</code>，还有一个<code>action链表</code>。</p>
<p><code>irq_desc </code>数组结构链路如下图：</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/4.png" alt="image"></p>
<h2><span id="1-1-zhong-duan-chu-li-han-shu-handle-irq">1.1 中断处理函数handle_irq</span><a href="#1-1-zhong-duan-chu-li-han-shu-handle-irq" class="header-anchor">#</a></h2><h3><span id="1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru">1.1.1 共享中断概念引入</span><a href="#1-1-1-gong-xiang-zhong-duan-gai-nian-yin-ru" class="header-anchor">#</a></h3><p>：<br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/5.png" alt="image"></p>
<ol>
<li>上图一个gpio按键连接gpio模块第一个引脚1，可以设置该引脚，当电平发生变化时，让该引脚产生中断，那么gpio模块会上报中断到gic模块, gic模块继续中断cpu。</li>
<li>同理当一个外部设备网卡和该gpio按键可以共享一个中断，也接到gpio模块第一个引脚1，gpio模块会上报中断到gic模块, gic模块继续中断cpu。这里就用到了共享中断的概念。</li>
</ol>
<p>可以看到中断的触发时从左到右的过程，那么cpu进行响应中断请求时就是从右到左的过程。</p>
<ol>
<li><p>cpu读取GIC控制器，判段中断号，如果是A号中断说明是来源于<code>gpio模块</code>，如果是<code>A&#39;</code>中断，说明来源于<code>其他模块</code>。</p>
</li>
<li><p>A号中断的来源有很多种，有<code>gpio0,gpio1....</code>， 又会从gpio控制寄存器来辨别倒是是哪一个gpio产生的中断，比如是B号中断</p>
</li>
<li><p>B号中断的来源有很多种，有<code>按键，网卡...</code></p>
</li>
</ol>
<h3><span id="1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan">1.1.2 中断的处理函数来源</span><a href="#1-1-2-zhong-duan-de-chu-li-han-shu-lai-yuan" class="header-anchor">#</a></h3><p>中断处理函数来源有三：</p>
<ol>
<li>GIC 的处理函数：<br> GIC 中断 CPU 时，CPU 读取 GIC 状态得到中断 A。假设<code> irq_desc[A].handle_irq 是 XXX_gpio_irq_handler</code>(XXX 指厂家)，这个函数需要读取芯片的 GPIO 控制器，细分发生的是哪一个 GPIO 中断(假设是B)，再去调用<code> irq_desc[B]. handle_irq</code>。</li>
</ol>
<p>  CPU从异常向量表中调用<code>handle_arch_irq</code>，这个函数指针是有GIC驱动设置的.调用<code>irq_desc[virq].handle_irq</code>函数：这也应该由GIC驱动提供。</p>
<ol start="2">
<li><p>模块的中断处理函数：<br>对于 GPIO 模块向 GIC 发出的中断 B ， 它 的 处 理 函 数 是<code>irq_desc[B].handle_irq</code>。<br>导致 GPIO 中断 B 发生的原因很多，可能是外部设备 1，可能是外部设备n，可能只是某一个设备，也可能是多个设备。所以<code> irq_desc[B].handle_irq</code>会调用链表里的函数，这些函数由外部设备提供。这些函数自行判断该中断是否自己产生，若是则处理。</p>
</li>
<li><p>外部设备提供的处理函数：（也就是<code>action</code>里面的函数）<br> 这里说的“外部设备”可能是芯片，也可能是简单的按键。它们的处理函数由自己驱动程序提供。对于共享中断，比如 GPIO 中断 B，它的中断来源可能有多个，每个中断源对应一个中断处理函数。所以<code> irq_desc[B]</code>中应该有一个链表, 这个链表就是<code> action</code> 链表。一旦程序确定发生了 GPIO 中断 B，那么就会从链表里把那些函数取出来，一一执行。</p>
</li>
</ol>
<h2><span id="1-2-irqaction">1.2 irqaction</span><a href="#1-2-irqaction" class="header-anchor">#</a></h2><p>irqaction 结构体在<code>include/linux/interrupt.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/6.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/7.png" alt="image"></p>
<p><code>irq_desc[A]</code>这里对应的<code>action一般为NULL</code>, 而<code>irq_desc[B]</code>的<code>handle_irq</code>会调用链表里的函数，这些函数就是对应不同的<code>irqaction</code>。</p>
<p>当调用<code>request_irq、request_threaded_irq </code>注册中断处理函数时，内核就会构造一个 <code>irqaction</code> 结构体。在里面保存<code>name、dev_id</code>等，最重要的是 <code>handler、thread_fn、thread</code>。<br>函数原型为：</p>
<h3><span id="1-2-1-request-threaded-irq">1.2.1 request_threaded_irq</span><a href="#1-2-1-request-threaded-irq" class="header-anchor">#</a></h3><h3><span id="1-2-2-request-irq">1.2.2 request_irq</span><a href="#1-2-2-request-irq" class="header-anchor">#</a></h3><h3><span id="1-2-3-devm-request-irq">1.2.3 devm_request_irq</span><a href="#1-2-3-devm-request-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/8.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/9.png" alt="image"><br><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/10.png" alt="image"><br>这里irq编号使用的虚拟中断号，虚拟中断号怎么来？详见后面<code>1.4 irq_domain</code>。</p>
<pre><code>handler ：是中断处理的上半部函数，用来处理紧急的事情。
thread_fn ：对应一个内核线程 thread，当 handler 执行完毕，Linux 内核会唤醒对应的内核线程。在内核线程里，会调用 thread_fn 函数。
</code></pre>
<ol>
<li>可以提供 handler 而不提供 thread_fn，就退化为一般的 <code>request_irq</code> 函数。</li>
<li>可以不提供 handler 只提供 thread_fn，完全由内核线程来处理中断。</li>
<li>也可以既提供 handler 也提供 thread_fn，这就是中断上半部、下半部。</li>
</ol>
<p>在 reqeust_irq 时可以传入 dev_id，为何需要 dev_id？作用有 2：</p>
<ol>
<li>中断处理函数执行时，可以使用 <code>dev_id</code></li>
<li>卸载中断时要传入 <code>dev_id</code>，这样才能在<code>action</code>链表中根据 dev_id 找到对应项（所以在共享中断中必须提供<code> dev_id</code>，非共享中断可以不提供）</li>
</ol>
<h2><span id="1-3-irq-data">1.3 irq_data</span><a href="#1-3-irq-data" class="header-anchor">#</a></h2><p>定义再<code>include/linux/irq.h</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/11.png" alt="image"><br><code>irq_data</code>就是个中转站，里面有<code> irq_chip</code> 指针 <code>irq_domain </code>指针，<code>irq </code>是软件中断号，<code>hwirq </code>是硬件中断号。<br>比如GPIO 中断 B 就是软件中断号，可以找到<code> irq_desc[B]</code>这个数组项；GPIO 里的第 x 号中断，这就是 <code>hwirq</code>。</p>
<p><code>irq、hwirq </code>之间的联系呢？由 <code>irq_domain </code>来建立。下面介绍<code>irq_domain</code></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/12.png" alt="image"></p>
<h2><span id="1-4-irq-domain">1.4 irq_domain</span><a href="#1-4-irq-domain" class="header-anchor">#</a></h2><p><code>include/linux/irqdomain.h</code> 中定义该结构。</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/13.png" alt="image"></p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/14.png" alt="img"></p>
<p>设备树中你会看到这样的属性:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line">interrupts = &lt;<span class="number">5</span> IRQ_TYPE_EDGE_RISING&gt;;</span><br></pre></td></tr></table></figure>
<p>表示使用<code>gpio1_5</code>作为中断，<code>hwirq </code>就是 5。当我们在驱动中会使用<code> request_irq(irq, handler)</code>这样的函数来注册中断，<code>irq编号</code>就是虚拟中断，那么虚拟中断号（软件中断号）要怎么得到？<br>就是<code>gpio1</code>对应的<code>irq_domain </code>结构体。<code>irq_domain </code>结构体中有一个 <code>irq_domain_ops </code>结构体，里面有各种操作函数。</p>
<h3><span id="1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain">1.4.0 中断控制器注册 irq_domain</span><a href="#1-4-0-zhong-duan-kong-zhi-qi-zhu-ce-irq-domain" class="header-anchor">#</a></h3><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/15.png" alt="img"></p>
<p>通过 <code>__irq_domain_add</code> 初始化<code>irq_domain</code>数据结构，然后把 irq_domain 添加到全局的链表<code>irq_domain_list</code>中。</p>
<h3><span id="1-4-1-irq-domain-ops">1.4.1 irq_domain_ops</span><a href="#1-4-1-irq-domain-ops" class="header-anchor">#</a></h3><h4><span id="1-4-1-1-xlate-han-shu">1.4.1.1 xlate函数</span><a href="#1-4-1-1-xlate-han-shu" class="header-anchor">#</a></h4><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/16.png" alt="image"></p>
<p><code>xlate</code>函数<br>用来解析设备树的中断属性，提取出 <code>hwirq、type</code> 等信息。</p>
<h4><span id="1-4-1-2-map-han-shu">1.4.1.2 <code>map</code>函数</span><a href="#1-4-1-2-map-han-shu" class="header-anchor">#</a></h4><p>把 <code>hwirq 转换为 irq</code>。</p>
<h2><span id="1-5-irq-chip">1.5 irq_chip</span><a href="#1-5-irq-chip" class="header-anchor">#</a></h2><p><code>irq_chip </code>结构体在<code>include/linux/irq.h</code>中定义</p>
<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/17.png" alt="image"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* @<span class="attr">irq_startup</span>:  start up the interrupt (defaults to -&gt;enable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_shutdown</span>:  shut down the interrupt (defaults to -&gt;disable <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_enable</span>:    enable the interrupt (defaults to chip-&gt;unmask <span class="keyword">if</span> <span class="variable constant_">NULL</span>)</span><br><span class="line">* @<span class="attr">irq_disable</span>:  disable the interrupt</span><br><span class="line">* @<span class="attr">irq_ack</span>:    start <span class="keyword">of</span> a <span class="keyword">new</span> interrupt</span><br><span class="line">* @<span class="attr">irq_mask</span>:    mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_mask_ack</span>:  ack and mask an interrupt source</span><br><span class="line">* @<span class="attr">irq_unmask</span>:    unmask an interrupt source</span><br><span class="line">* @<span class="attr">irq_eoi</span>:    end <span class="keyword">of</span> interrupt</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/18.png" alt="在这里插入图片描述"></p>
<p>我们在<code>request_irq</code>后，并不需要手工去使能中断，原因就是系统调用对应的 <code>irq_chip </code>里的<code>irq_enable</code>函数帮我们使能了中断。<br>我们提供的中断处理函数中，也不需要执行主芯片相关的清中断操作，也是系统帮我们调用<code>irq_chip</code>中的相关函数。<br>但是对于外部设备相关的清中断操作，还是需要我们自己做的。就像上面图里的<code>“外部设备 1“、“外部设备 n”</code>，外设备千变万化，内核里没有对应的清除中断操作。</p>
<h1><span id="2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu">2 中断不同结构体之间的关系框图</span><a href="#2-zhong-duan-bu-tong-jie-gou-ti-zhi-jian-de-guan-xi-kuang-tu" class="header-anchor">#</a></h1><p><img src="/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/19.png" alt="image-20240810191140464"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/10/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BB%93%E6%9E%84%E4%BD%93/" data-id="clzp8uttn007r9ouf29qk11s0" data-title="字符设备驱动-9-中断子系统-中断结构体" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/">字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">字符设备驱动-ioctl命令详解</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-misc%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87/">字符设备驱动-misc杂项设备</a>
          </li>
        
          <li>
            <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/">字符设备驱动-mmap驱动应用实例</a>
          </li>
        
          <li>
            <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/">字符设备驱动-mmap机制</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>