<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-字符设备驱动-4-设备树" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T11:23:03.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/">字符设备驱动-4-设备树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-yong-she-bei-shu">1 引用设备树</a><ul>
<li><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</a></li>
</ul>
</li>
<li><a href="#2-she-bei-shu-de-yu-fa">2 设备树的语法</a><ul>
<li><a href="#2-1-dts-wen-jian">2.1 DTS 文件</a><ul>
<li><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</a></li>
<li><a href="#2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</a></li>
<li><a href="#2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</a><ul>
<li><a href="#2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</a></li>
<li><a href="#2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</a></li>
</ul>
</li>
<li><a href="#2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</a><ul>
<li><a href="#2-1-4-1-address-cells">2.1.4.1 #address-cells</a></li>
<li><a href="#2-1-4-2-size-cells">2.1.4.2 #size-cells</a></li>
<li><a href="#2-1-4-3-compatible">2.1.4.3 compatible</a></li>
<li><a href="#2-1-4-4-model">2.1.4.4 model</a></li>
<li><a href="#2-1-4-5-phandle">2.1.4.5 phandle</a></li>
<li><a href="#2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</a></li>
<li><a href="#2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</a></li>
<li><a href="#2-1-4-8-reg">2.1.4.8 reg</a></li>
<li><a href="#2-1-4-8-status">2.1.4.8 status</a></li>
<li><a href="#2-1-4-9-ranges">2.1.4.9 ranges</a></li>
<li><a href="#2-1-4-10-device-type">2.1.4.10 device_type</a></li>
</ul>
</li>
<li><a href="#2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</a><ul>
<li><a href="#2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</a></li>
<li><a href="#2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</a></li>
</ul>
</li>
<li><a href="#2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</a><ul>
<li><a href="#2-1-6-1-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</a></li>
<li><a href="#2-1-6-2-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</a></li>
<li><a href="#2-1-6-3-gen-jie-dian">2.1.6.3 &#x2F;根节点</a></li>
</ul>
</li>
<li><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</a></li>
<li><a href="#2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</a></li>
<li><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</a><ul>
<li><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</a></li>
<li><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</a><ul>
<li><a href="#2-1-9-2-1-documentation-devicetree-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-dtb-wen-jian">2.2 DTB文件</a><ul>
<li><a href="#2-2-1-struct-ftd-header">2.2.1 struct ftd_header</a></li>
<li><a href="#2-2-2-memory-reservation-block">2.2.2 memory reservation block</a></li>
<li><a href="#2-2-3-structure-block">2.2.3 structure block</a></li>
<li><a href="#2-2-4-strings-block">2.2.4 strings block</a></li>
</ul>
</li>
<li><a href="#2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</a><ul>
<li><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</a></li>
<li><a href="#2-3-2-shou-gong-bian-yi">2.3.2 手工编译</a></li>
<li><a href="#2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</a></li>
</ul>
</li>
<li><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</a><ul>
<li><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</a></li>
<li><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</a></li>
<li><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wan-zheng-dts-shi-li">3 完整dts示例</a><ul>
<li><a href="#3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</a></li>
<li><a href="#3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</a><ul>
<li><a href="#3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</a></li>
<li><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</a><ul>
<li><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yin-yong-she-bei-shu">1 引用设备树</span><a href="#1-yin-yong-she-bei-shu" class="header-anchor">#</a></h1><p>在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如 A 板用 GPIO A，B 板用 GPIO B， 如果用<code>plateform_device</code>定义资源信息，那么每次单板硬件资源变动后，都要改驱动程序源码，重新编译驱动，重新加载驱动，非常麻烦。<br>随着 ARM 芯片的流行，内核中针对这些 ARM 板保存有大量的、没有技术含量的文件。 Linus 大发雷霆：<code>&quot;this whole ARM thing is a f*cking pain in the ass&quot;</code>。于是，Linux 内核开始引入设备树。 设备树并不是重新发明出来的，在 Linux 内核中其他平台如 <code>PowerPC</code>，早就使用设备树来描述硬件了。<br>设备树只是用来给内核里的驱动程序，指定硬件的信息。</p>
<h2><span id="1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu">1.1 根文件系统中查看设备树</span><a href="#1-1-gen-wen-jian-xi-tong-zhong-cha-kan-she-bei-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/1.png" alt="image"></p>
<p>烧录的dtb文件,显然两者是完全相同的。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/2.png" alt="image"></p>
<p>除了原始的dtb文件，根文件系统还以目录结构的方式呈现dtb文件,在<code>devicetree</code>目录下，则有一个<code>base</code>目录，这个base目录，就对应着根节点。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/3.png" alt="image"></p>
<p>base目录下，每一个节点对应一个目录, 每一个属性对应一个文件. 这些属性的值如果是字符串，可以使用 cat 命令把它打印出来。对于数值，可以用 <code>hexdump</code> 把它打印出来。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/4.png" alt="image-20240728192831389"></p>
<p>进入<code>led</code>目录，里面一共有三个文件，除<code>name</code>外，分别对应着led节点的两个属性，cat属性如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/5.png" alt="image"></p>
<p><code>pin</code>属性的值为<code>0x00 05 00 05</code>，也就是<code>GPF5</code>.<br>如果节点没有设置<code>name</code>属性，那么转换为<code>device_node</code>时，会将节点自己的名称作为<code>name</code>属性值。 所以这里<code>name</code>是<code>led</code>.<br>根文件系统下也可以查看<code>platform_device</code>。系统中所有的<code>platform_device</code>，都可以在<code>/sys/devices/platform/</code>路径下查看。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/6.png" alt="image"></p>
<p>另外，系统中所有的<code>platform_device</code>，有来自设备树的，也有来自<code>.c</code>文件中注册的。那么，我们怎么知道哪些<code>platform_device</code>是来自设备树，哪些是来自.c文件中注册的？</p>
<pre><code>答：可以查看该platform_device的相关目录下，是否有of_node，如果有of_node，那么这个platform_device就来自于设备树；否则，来自.c文件。
</code></pre>
<p>以<code>led</code>为例，进入led目录，可以看到有<code>of_node</code>，说明这个<code>platform_device</code>来自设备树。同时，可以看到这个<code>of_node</code>是一个链接文件，指向的是<code>/sys/firmware/devicetree/base/led</code>。也就是说，可以进入 <code>/sys/devices/platform/&lt;设备名&gt;/of_node</code> 查看它的设备树属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/7.png" alt="image"></p>
<p>在&#x2F;proc下有一个链接文件<code>device-tree</code>，它指向的是<code>/sys/firmware/devicetree/base</code><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/8.png" alt="image"></p>
<h1><span id="2-she-bei-shu-de-yu-fa">2 设备树的语法</span><a href="#2-she-bei-shu-de-yu-fa" class="header-anchor">#</a></h1><p>设备树文件(<code>dts: device tree source</code>)，它需要编译为<code> dtb(device tree blob)</code>文件，内核使用的是 dtb 文件。</p>
<h2><span id="2-1-dts-wen-jian">2.1 DTS 文件</span><a href="#2-1-dts-wen-jian" class="header-anchor">#</a></h2><h3><span id="2-1-1-dts-wen-jian-de-zong-ti-bu-ju">2.1.1 DTS文件的总体布局</span><a href="#2-1-1-dts-wen-jian-de-zong-ti-bu-ju" class="header-anchor">#</a></h3><p>设备树源文件通常以dts为后缀，其总体布局如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">[memory reservations]</span><br><span class="line">/&#123;</span><br><span class="line">	[property definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上各项的含义分别为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;dts-v1&#x2F;</td>
<td>设备树文件的版本</td>
</tr>
<tr>
<td>memory reservations</td>
<td>指定保留内存，内核不会使用保留内存</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>根节点（使用花括号括出属于根节点的内容）</td>
</tr>
<tr>
<td>property definitions</td>
<td>根节点的属性，用来描述硬件</td>
</tr>
<tr>
<td>child nodes</td>
<td>孩子节点（使用花括号括出属于孩子节点的内容）</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-memory-reservations-de-ge-shi">2.1.2 memory reservations的格式</span><a href="#2-1-2-memory-reservations-de-ge-shi" class="header-anchor">#</a></h3><p>该项是可选项，如果想要保留一段内存不让内核使用，可用如下格式指定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	address    指定要保留的内存的起始地址</span></span><br><span class="line"><span class="comment">	length     指定要保留的内存的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">/memreserve/&lt;address&gt;&lt;length&gt;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>address</code>和&#96;length都是64位。</p>
<h3><span id="2-1-3-shu-xing-de-ge-shi">2.1.3 属性的格式</span><a href="#2-1-3-shu-xing-de-ge-shi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 属性有值 [label:] property-name = value;</span><br><span class="line">• 属性没有值 [label:] property-name;</span><br></pre></td></tr></table></figure>
<p>其中各项的含义：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>label</td>
<td>标签</td>
</tr>
<tr>
<td>property-name</td>
<td>属性名</td>
</tr>
<tr>
<td>value</td>
<td>属性值</td>
</tr>
</tbody></table>
<h4><span id="2-1-3-1-you-guan-shu-xing-ming">2.1.3.1 有关属性名</span><a href="#2-1-3-1-you-guan-shu-xing-ming" class="header-anchor">#</a></h4><p>属性名的长度为<code>1~31</code>个字符，可以自己取，只要能够提供可以解读该属性名的驱动即可。也有一些属性名有着特定的含义，比如<code>compatible</code>用于表示哪个或哪些驱动支持该设备。对于自己命名的属性，并非所有字符均可组成属性名，它需要由以下字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/9.png" alt="image"></p>
<h4><span id="2-1-3-2-you-guan-shu-xing-zhi">2.1.3.2 有关属性值</span><a href="#2-1-3-2-you-guan-shu-xing-zhi" class="header-anchor">#</a></h4><p>属性值有以下四种：</p>
<ol>
<li><p><code>array of cells</code> 一个cell就是一个u32类型的数据，一个或多个cell用尖括号括起来，并以空格隔开就可以作为一种合法的属性值，如</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = &lt;<span class="number">0x1</span> <span class="number">0x2</span> <span class="number">0x3</span>&gt;;。</span><br></pre></td></tr></table></figure></li>
<li><p>含有结束符的<strong>字符串</strong> 如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = <span class="string">&quot;example value&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>字节序列</strong> 用方括号括起一个或多个字节，字节之间可用也可不用空格隔开，且字节以两位16进制数表示，如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example = [<span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>];</span><br></pre></td></tr></table></figure></li>
<li><p><strong>以上三种值的混合</strong>（以逗号隔开） 如:</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;fsl,mpc8641&quot;</span>, <span class="string">&quot;ns16550&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ 文本字符串（包含’\0’结束符）用双引号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>-property=<span class="string">&quot;a string&quot;</span>;</span><br></pre></td></tr></table></figure>
<p> ◆ Cells（32位无符号整数）用尖括号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell-property = &lt;<span class="number">0xbeef</span> <span class="number">123</span> <span class="number">0xabcd1234</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 64bit 数据使用 2 个 cell 来表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;; </span><br></pre></td></tr></table></figure>
<p> ◆ 二进制数据用方括号表示：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binary-property=[<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>];</span><br></pre></td></tr></table></figure>
<p> ◆ 类型不同的数据的组合也是可以的，但需要用逗号隔开：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixed-property=<span class="string">&quot;a string&quot;</span>, [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x45</span> <span class="number">0x67</span>], &lt;<span class="number">0x12345678</span>&gt;;</span><br></pre></td></tr></table></figure>
<p> ◆ 逗号同样用于创建字符串列表：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>-<span class="built_in">list</span> = <span class="string">&quot;red fish&quot;</span>, <span class="string">&quot;blue fish&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">	node1 &#123;</span><br><span class="line">		a-<span class="built_in">string</span>-property = <span class="string">&quot;A string&quot;</span>;</span><br><span class="line">		a-<span class="built_in">string</span>-<span class="built_in">list</span>-property = <span class="string">&quot;first string&quot;</span>, <span class="string">&quot;second string&quot;</span>;</span><br><span class="line">		a-byte-data-property = [<span class="number">0x01</span> <span class="number">0x23</span> <span class="number">0x34</span> <span class="number">0x56</span>];</span><br><span class="line">		child-node1 &#123;</span><br><span class="line">			first-child-property;</span><br><span class="line">			second-child-property = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">			a-<span class="built_in">string</span>-property = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		child-node2 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">	node2 &#123;</span><br><span class="line">		an-empty-property;</span><br><span class="line">		a-cell-property = &lt;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>&gt;; <span class="comment">/* each number (cell) is a uint32 */</span></span><br><span class="line">		child-node1 &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-4-yi-xie-te-ding-de-shu-xing">2.1.4 一些特定的属性</span><a href="#2-1-4-yi-xie-te-ding-de-shu-xing" class="header-anchor">#</a></h3><p>设备树文件中有一些特定的属性，他们拥有约定俗成的名称和含义，在<code>devicetree-specification</code>中，这些属性被称为<code>Standard Properties</code>，我们在使用这些属性时，应当遵守相应的约定。这些属性有很多，我将在下文中介绍它们中的一部分。</p>
<h4><span id="2-1-4-1-address-cells">2.1.4.1 #address-cells</span><a href="#2-1-4-1-address-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用使用多少个cell，也即使用多少个u32整数来表示地址（对于32位系统，一个u32整数就够了；而对于64位系统，需要两个u32整数）。</p>
<h4><span id="2-1-4-2-size-cells">2.1.4.2 #size-cells</span><a href="#2-1-4-2-size-cells" class="header-anchor">#</a></h4><p>该属性的值表示在该节点的子节点的reg属性中，使用多少个cell，也即使用多少个u32整数来表示大小（一段地址空间的长度）。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/10.png" alt="image"></p>
<h4><span id="2-1-4-3-compatible">2.1.4.3 compatible</span><a href="#2-1-4-3-compatible" class="header-anchor">#</a></h4><p>其值为一个或多个字符串，用来描述支持该设备的驱动程序。比如，该属性位于根节点时，用于指定内核中哪个<code>machine_desc</code>可以支持本设备，即当前设备与哪些平台兼容。其值的格式一般是<code>&quot;manufacturer, model&quot;</code>，其中<code>manufacturer</code>表示厂家，<code>model</code>表示型号（厂家的哪型产品）。<br>当该属性的值有多个字符串时，从左往右，从最特殊到最一般。举例来说</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;samsung,smdk2416&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>&quot;samsung, s3c2416&quot;</code> 作为根节点的属性时，第一个字符串指示了一个具体的开发板型号，而第二个字符串要更一般，只指示了SoC的型号。在linux初始化时，会优先找支持<code>&quot;samsung,smdk2416&quot;</code>的<code>machine_desc</code>用以初始化硬件，找不到时才退而求其次找到<code>&quot;samsung, s3c2416&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">led &#123; </span><br><span class="line">	compatible = “A”, “B”, “C”; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p><code>“compatible”</code>表示“兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱 动都支持它。</p>
<h4><span id="2-1-4-4-model">2.1.4.4 model</span><a href="#2-1-4-4-model" class="header-anchor">#</a></h4><p>其值为一个字符串，用来描述当前设备的型号（单板的名字）。当多个设备的<code>compatible</code>相同时，可以通过model来进一步区分多个设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>, <span class="string">&quot;samsung,mini2440&quot;</span>; </span><br><span class="line">	model = <span class="string">&quot;jz2440_v3&quot;</span>; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>它表示<code>jz2440_v3</code>这个单板，可以兼容内核中的<code>“smdk2440”</code>，也兼容<code>“mini2440”</code>.</p>
<h4><span id="2-1-4-5-phandle">2.1.4.5 phandle</span><a href="#2-1-4-5-phandle" class="header-anchor">#</a></h4><p>该属性可以为节点指定一个全局唯一的数字标识符。这个标识符可以被需要引用该节点的另一个节点使用。举例来说，现有一个中断控制器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一个可以产生中断的设备，且这个设备的中断信号线连接到了上述中断控制器，为了描述清楚这种关系，该设备的设备节点就需要引用中断控制器的节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-6-interrupt-controller">2.1.4.6 interrupt-controller</span><a href="#2-1-4-6-interrupt-controller" class="header-anchor">#</a></h4><p>这是一个没有值的属性，用在中断控制器的设备节点中，以表明这个节点描述的是一个中断控制器。</p>
<h4><span id="2-1-4-7-interrupt-parent">2.1.4.7 interrupt-parent</span><a href="#2-1-4-7-interrupt-parent" class="header-anchor">#</a></h4><p>该属性用于可以产生中断，且中断信号连接到某中断控制器的设备的设备节点，用于表示该设备的中断信号连接到了哪个中断控制器。该属性的值通常是中断控制器设备节点的数字标识（<code>phandle</code>），具体示例在上文已经出现过了。</p>
<h4><span id="2-1-4-8-reg">2.1.4.8 reg</span><a href="#2-1-4-8-reg" class="header-anchor">#</a></h4><p>reg属性描述了设备资源在其父总线定义的地址空间内的地址。通俗的说，该属性使用一对或多对（地址，长度）来描述设备所占的地址空间。至于地址和长度使用多少个cell来表示呢？这取决于上文介绍的<code>#address-cells、#size-cells</code>属性的值。<br>举个例子，当：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line"><span class="meta">#size-cells =<span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">reg = &lt;<span class="number">0x3000</span> <span class="number">0x20</span> <span class="number">0xFE00</span> <span class="number">0x100</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>那么<code>reg = &lt;0x3000 0x20 0xFE00 0x100&gt;</code>，表示该属性所属的设备占据了两块内存空间，第一块是以0x3000为起始的32字节内存块；第二块是以0xFE00为起始的256字节内存块。</p>
<h4><span id="2-1-4-8-status">2.1.4.8 status</span><a href="#2-1-4-8-status" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/11.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;uart1 &#123;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4><span id="2-1-4-9-ranges">2.1.4.9 ranges</span><a href="#2-1-4-9-ranges" class="header-anchor">#</a></h4><p><code>ranges</code>属性值可以为空或者按照 (<code>child-bus-address,parent-bus-address,length</code>)格式编写的数字组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">child-bus-address<span class="comment">//子总线地址空间的物理地址，由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">parent-bus-address<span class="comment">//父总线地址空间的物理地址，同样由父节点的 #address-cells确定此物理地址所占用的字长。</span></span><br><span class="line">length<span class="comment">//子地址空间的长度，由父节点的 #size-cells确定此地址长度所占用的字长。</span></span><br><span class="line"></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	interrupt-parent = &lt;&amp;gpc&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ranges</code>属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">soc &#123; </span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	ranges = &lt;<span class="number">0x0</span> <span class="number">0xe0000000</span> <span class="number">0x00100000</span>&gt;; </span><br><span class="line">	serial &#123; </span><br><span class="line">		device_type = <span class="string">&quot;serial&quot;</span>; </span><br><span class="line">		compatible = <span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x4600</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>soc定义的 ranges属性，值为<code> &lt;0x0 0xe0000000 0x00100000&gt;</code>，此属性值指定了一个 <code>1024KB(0x00100000)</code>的地址范围，子地址空间的物理起始地址为 <code>0x0</code>，父地址空间的物理起始地址为<code> 0xe0000000</code>。</p>
<p>serial是串口设备节点， reg属性定义了 serial设备寄存器的起始地址为 <code>0x4600</code>寄存器长度为<code> 0x100</code>。经过地址转换， serial设备可以从 <code>0xe0004600</code>开始进行读写操作，<code>0xe0004600=0x4600+0xe0000000</code>。</p>
<h4><span id="2-1-4-10-device-type">2.1.4.10 device_type</span><a href="#2-1-4-10-device-type" class="header-anchor">#</a></h4><p>此属性也被抛弃了。此属性只能用于 cpu节点或者 memory节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">    <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">    A53_0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span>&gt;;</span><br><span class="line">        enable-method = <span class="string">&quot;psci&quot;</span>;</span><br><span class="line">        compatible = <span class="string">&quot;arm,cortex-a53&quot;</span>;</span><br><span class="line">        device_type = <span class="string">&quot;cpu&quot;</span>;</span><br><span class="line">        next-level-cache = &lt;&amp;CA53_L2&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-5-jie-dian-de-ge-shi">2.1.5 节点的格式</span><a href="#2-1-5-jie-dian-de-ge-shi" class="header-anchor">#</a></h3><p>节点的格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[label:]node-name[@unit-address]&#123;</span><br><span class="line">	[properties definitions]</span><br><span class="line">	[child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以uart节点为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	uart0: uart@fe001000 &#123; </span><br><span class="line">		compatible=<span class="string">&quot;ns16550&quot;</span>; </span><br><span class="line">		reg=&lt;<span class="number">0xfe001000</span> <span class="number">0x100</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>节点名(<code>node-name</code>)长为1~31个字符，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/12.png" alt="image"></p>
<p>每个设备节点代表一个设备，因此节点名的命名通常要和设备相应，比如以太网控制器，我们可以给其取名<code>ethernet</code>。考虑到一个SoC中可能有多个以太网控制器，为了做区分，我们通常在其<strong>节点名后面加上设备的地址</strong>，也就是上文中出现的可选部分<code>@unit-address</code>。仍以以太网控制器为例，假如两个以太网控制器的寄存器组的首地址分别为<code>0xfe002000</code>和<code>0xfe003000</code>，那么相应的节点名可以取为<code>ethernet@fe002000</code>和<code>ethernet@fe003000</code>。<br>不难看出，设备节点允许嵌套，假设节点b嵌套于节点a中，那么节点a是节点b的父节点。根节点的名字比较特殊，就是一个斜杠&#x2F;，其他的设备节点都是根节点的孩子，或者孩子的孩子…因此，所有的设备节点呈现出一个树状的层次结构（设备树因此得名），下图就是一个例子：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/13.png" alt="image"></p>
<h4><span id="2-1-5-1-tui-jian-de-jie-dian-ming">2.1.5.1 推荐的节点名</span><a href="#2-1-5-1-tui-jian-de-jie-dian-ming" class="header-anchor">#</a></h4><p>关于节点的命名，官方有一些推荐的命名，具体可见<code>devicetree-specification-v0.3</code>的2.2.2节。</p>
<h4><span id="2-1-5-2-jie-dian-de-lu-jing-ming">2.1.5.2 节点的路径名</span><a href="#2-1-5-2-jie-dian-de-lu-jing-ming" class="header-anchor">#</a></h4><p>在文件系统中有个术语叫文件的路径名（<code>pathname</code>），在按照树状结构组织的众多文件中，用以唯一标识某个文件。类似的，节点也有路径名的概念。将根节点类比为根目录，以上图为例，其中cpu0节点的路径名为<code>/cpus/cpu@0</code>。我们在给节点命名时，必须<strong>保证每个节点拥有唯一的路径名</strong>（注意区别于每个节点拥有唯一的节点名）。</p>
<h3><span id="2-1-6-yi-xie-te-shu-de-jie-dian">2.1.6 一些特殊的节点</span><a href="#2-1-6-yi-xie-te-shu-de-jie-dian" class="header-anchor">#</a></h3><p>有一些特殊的节点不代表任何设备，而是有着特定的用途，本节就将介绍一些这样的节点。</p>
<h4><span id="2-1-6-1-x2f-aliases-jie-dian">2.1.6.1 &#x2F;aliases节点</span><a href="#2-1-6-1-x2f-aliases-jie-dian" class="header-anchor">#</a></h4><p><code>/aliases</code>节点应当作为根节点的孩子节点，用于定义一个或多个别名属性，每条别名属性会为一个设备节点的路径名设置一个别名，如下面这个例子所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">	serial0 =<span class="string">&quot;/simple-bus@fe000000/serial@llc500&quot;</span>;</span><br><span class="line">	ethernet0 =<span class="string">&quot;/simple-bus@fe000000/ethernet@31c000&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>别名只能由<code>1~31</code>个下面的字符组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/14.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/15.png" alt="image"></p>
<p><strong>别名通常以数字结尾</strong>，比如别名为<code>i2c1</code>，设备树的初始化程序在解析别名属性时，会将数字1记录在<code>struct alias_prop</code>结构的<code>id</code>成员中，使用<code>of_alias_get_id</code>可以获得这个数字。因为本文主要介绍设备树文件的格式，因此这里不再深究这部分内容。</p>
<h4><span id="2-1-6-2-x2f-chosen-jie-dian">2.1.6.2 &#x2F;chosen节点</span><a href="#2-1-6-2-x2f-chosen-jie-dian" class="header-anchor">#</a></h4><p><code>/chosen</code>节点应当用作根节点的孩子节点，有以下可选属性：<br>    • <code>bootargs</code><br>    • <code>stdout-path</code><br>    • <code>stdin-path</code><br>顾名思义，该节点可以指定启动参数、标准输出和标准输入，一个例子如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	......</span><br><span class="line">	chosen &#123;</span><br><span class="line">		bootargs =<span class="string">&quot;root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200&quot;</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上图中<code>chosen</code>节点仅仅设置了属性<code>“ stdout-path”</code>，表示标准输出使用 uart0。但是当我们进入到 <code>/proc/device-tree/chosen</code>目录里面，会发现多了<code> bootargs</code>属性，原因如下:<br><code>do_bootm_linux </code>函数会通过一系列复杂的调用，最终通过<code>fdt_chosen </code>函数在<code>chosen </code>节点中加入<br>了<code>bootargs </code>属性。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/17.png" alt="image"></p>
<p><code>do_bootm_linux</code>细节见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17960265">uboot-5_bootm&#x2F;bootz启动内核过程 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/">uboot-bootm和bootz启动内核 | Hexo (fuzidage.github.io)</a></p>
<h4><span id="2-1-6-3-x2f-gen-jie-dian">2.1.6.3 &#x2F;根节点</span><a href="#2-1-6-3-x2f-gen-jie-dian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	model = <span class="string">&quot;SMDK24440&quot;</span>; </span><br><span class="line">	compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>根节点中必须有这些属性： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#address-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述地址(address) </span></span></span><br><span class="line"><span class="meta">#size-cells <span class="comment">// 在它的子节点的 reg 属性中, 使用多少个 u32 整数来描述大小(size) </span></span></span><br><span class="line">compatible <span class="comment">// 定义一系列的字符串, 用来指定内核中哪个 machine_desc 可以支持本设备 (即这个板子兼容哪些平台) </span></span><br><span class="line">model <span class="comment">// 咱这个板子是什么</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/18.png" alt="image"><br>Linux内核通过根节点<code> compatible</code>属性找到对应的设备的函数调用过程如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/19.png" alt="image"></p>
<h3><span id="2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing">2.1.7 必要的节点和必要的属性</span><a href="#2-1-7-bi-yao-de-jie-dian-he-bi-yao-de-shu-xing" class="header-anchor">#</a></h3><p>一个完整的设备树文件（DTS文件），有一些节点是必须要有的，这些必要的节点有：</p>
<table>
<thead>
<tr>
<th>节点名</th>
<th>节点的必要属性</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>#address-cells、#size-cells、model、compatible</td>
</tr>
<tr>
<td>&#x2F;memory</td>
<td>device_type、reg</td>
</tr>
<tr>
<td>&#x2F;cpus</td>
<td>#address-cells、#size-cells</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*</td>
<td>device_type、reg、clock-frequency、timebase-frequency</td>
</tr>
<tr>
<td>&#x2F;cpus&#x2F;cpu*&#x2F;l?-cache</td>
<td>compatible、cache-level</td>
</tr>
</tbody></table>
<h3><span id="2-1-8-label-biao-qian-de-shi-yong">2.1.8 label（标签）的使用</span><a href="#2-1-8-label-biao-qian-de-shi-yong" class="header-anchor">#</a></h3><p>在上文就提到过标签，只是没有细说，这里就介绍一下标签的使用。首先，标签名可由<code>1~31</code>个字符组成，这些字符可以是：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/20.png" alt="image"></p>
<p>接下来仍以中断控制器的例子来说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	phandle =&lt;<span class="number">1</span>&gt;;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">	&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;<span class="number">1</span>&gt;;<span class="comment">/* 数字1就唯一标识了节点pic@10000000 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>如果我们使用phandle来标识设备，当设备多了，数字标识符是比较难记忆的，可读性也差，此时可以使用标签：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PIC:pic@<span class="number">10000000</span>&#123;</span><br><span class="line">	interrupt-controller;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">another-device-node &#123;</span><br><span class="line">	interrupt-parent =&lt;&amp;PIC&gt;;<span class="comment">/* 用标签来引用设备节点 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种常见的标签的用法，当我们需要修改某设备节点的属性，但又不想直接在原地修改（保持原来的内容不被破坏），此时可以在设备树文件的末尾重写该设备节点的相应属性，从而覆盖之前的内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">/&#123;</span><br><span class="line">	device-node &#123;<span class="comment">/* 因此这样写比较麻烦（特别是在路径比较深的时候） */</span></span><br><span class="line">		p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么使用标签的写法就简单很多：标签名DN.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/&#123;</span><br><span class="line">	DN:device-node &#123;</span><br><span class="line">		p =<span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重写device-node的属性p */</span></span><br><span class="line">&amp;DN&#123;</span><br><span class="line">	p =<span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>修改节点</strong>，节点追加内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i2c0: i2c@<span class="number">29000000</span> &#123;</span><br><span class="line">	 compatible = <span class="string">&quot;snps,designware-i2c&quot;</span>;</span><br><span class="line">	 clocks = &lt;&amp;clk ATHENA2_CLK_I2C0&gt;;</span><br><span class="line">	 reg = &lt;<span class="number">0x0</span> <span class="number">0x29000000</span> <span class="number">0x0</span> <span class="number">0x1000</span>&gt;;</span><br><span class="line">	 clock-frequency = &lt;<span class="number">400000</span>&gt;;</span><br><span class="line">	 <span class="meta">#size-cells = <span class="string">&lt;0x0&gt;</span>;</span></span><br><span class="line">	 <span class="meta">#address-cells = <span class="string">&lt;0x1&gt;</span>;</span></span><br><span class="line">	 resets = &lt;&amp;rst RST_I2C0&gt;;</span><br><span class="line">	 reset-names = <span class="string">&quot;i2c0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再另一个dts中使用i2c0:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">		clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123; </span><br><span class="line">			compatible = <span class="string">&quot;fsl,mag3110&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0x0e</span>&gt;; </span><br><span class="line">			position = &lt;<span class="number">2</span>&gt;; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-9-bian-xie-she-bei-shu-wen-jian">2.1.9 编写设备树文件</span><a href="#2-1-9-bian-xie-she-bei-shu-wen-jian" class="header-anchor">#</a></h3><h4><span id="2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian">2.1.9.1 在DTS文件中包含其他文件</span><a href="#2-1-9-1-zai-dts-wen-jian-zhong-bao-han-qi-ta-wen-jian" class="header-anchor">#</a></h4><p>编写设备树文件时，我们通常会把多型设备的共性抽出来，写在<code>DTSI</code>文件（后缀为<code>.dtsi</code>）中，其语法与DTS文件一样。比如，多款使用了<code>am335x</code>的板子，因为使用了同一款SoC，描述设备时肯定会有一些相同的部分，可以把这部分抽出来，写到<code>am335x.dts</code>i中，然后在具体的某型板子的设备树中包含相应的DTSI文件，包含的方式有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/include/ “xxx.dtsi”</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “xxx.dtsi”</span></span><br></pre></td></tr></table></figure>

<p>设备树编译器还支持c语言的头文件，因此，如果有需要可以定义一些宏并在设备树文件中使用。</p>
<h4><span id="2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei">2.1.9.2 如何在设备树文件中描述设备</span><a href="#2-1-9-2-ru-he-zai-she-bei-shu-wen-jian-zhong-miao-shu-she-bei" class="header-anchor">#</a></h4><h5><span id="2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings">2.1.9.2.1 Documentation&#x2F;devicetree&#x2F;bindings</span><a href="#2-1-9-2-1-documentation-x2f-devicetree-x2f-bindings" class="header-anchor">#</a></h5><p>设备树写出来是给驱动程序看的，也就是说驱动程序怎么写的，相应的设备树就该怎么写；或者反过来，先约定好设备树怎么写，在相应的设计驱动。驱动和设备树有着对应的关系，这种对应关系也被称为<code>bindings</code>。具体的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于上游芯片厂商，应当按照devicetree-specification推荐的设备树写法，遵守各种约定，确定好如何规范的描述设备，并提供相应的驱动程序。devicetree-specification-v0<span class="number">.3</span>的第四章给出了一些推荐的做法。</span><br><span class="line">对于下游产品厂商，当使用芯片厂商的芯片做产品时，芯片厂商通常会提供驱动程序和设备树文件编写的参考文档，这些文档位于linux内核源码树的Documentation/devicetree/bindings目录下。如果芯片厂商没提供相应文档的话，就要读驱动的源码，知道驱动怎么写的，自然也就知道如何写设备树了。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-dtb-wen-jian">2.2 DTB文件</span><a href="#2-2-dtb-wen-jian" class="header-anchor">#</a></h2><p>DTS文件只是文本文件，需要使用<strong>设备树编译器（DTC）将其编译为DTB文件（二进制文件）</strong>，然后才能传递给内核，内核解析的是DTB文件。dtb文件由四个部分组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/21.png" alt="image"></p>
<h3><span id="2-2-1-struct-ftd-header">2.2.1 struct ftd_header</span><a href="#2-2-1-struct-ftd-header" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/22.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fdt_header</span> &#123;</span></span><br><span class="line">    <span class="type">fdt32_t</span> magic;           <span class="comment">/* magic word FDT_MAGIC */</span></span><br><span class="line">    <span class="type">fdt32_t</span> totalsize;       <span class="comment">/* total size of DT block */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_struct;       <span class="comment">/* offset to structure */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_dt_strings;      <span class="comment">/* offset to strings */</span></span><br><span class="line">    <span class="type">fdt32_t</span> off_mem_rsvmap;      <span class="comment">/* offset to memory reserve map */</span></span><br><span class="line">    <span class="type">fdt32_t</span> version;         <span class="comment">/* format version */</span></span><br><span class="line">    <span class="type">fdt32_t</span> last_comp_version;   <span class="comment">/* last compatible version */</span></span><br><span class="line">    <span class="comment">/* version 2 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> boot_cpuid_phys;     <span class="comment">/* Which physical CPU id we&#x27;re</span></span><br><span class="line"><span class="comment">    booting on */</span></span><br><span class="line">    <span class="comment">/* version 3 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_strings;     <span class="comment">/* size of the strings block */</span></span><br><span class="line">    <span class="comment">/* version 17 fields below */</span></span><br><span class="line">    <span class="type">fdt32_t</span> size_dt_struct;      <span class="comment">/* size of the structure block */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>totalsize</strong>:<br>这个设备树的size，也可以理解为所占用的实际内存空间。<br><strong>off_dt_struct</strong>:<br><code>offset to dt_struct</code>，表示整个dtb中<code>structure</code>部分所在内存相对头部的偏移地址<br><strong>off_dt_strings</strong>:<br><code>offset to dt_string</code>，表示整个dtb中<code>string</code>部分所在内存相对头部的偏移地址<br><strong>off_mem_rsvmap</strong>:<br><code>offset to memory reserve map</code>，dtb中<code>memory reserve map</code>所在内存相对头部的偏移地址</p>
<h3><span id="2-2-2-memory-reservation-block">2.2.2 memory reservation block</span><a href="#2-2-2-memory-reservation-block" class="header-anchor">#</a></h3><p>该部分由<code>memory reservations</code>编译得来，由一个或多个表项组成，每一项都描述了一块要保留的内存区域，每项由两个64位数值（起始地址、长度）组成：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/23.png" alt="image"></p>
<p>reserved memory作用：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17664807.html">设备驱动-15.内核kmalloc&#x2F;vmalloc及CMA内存介绍 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/">Linux内核-kmalloc与vmalloc及CMA内存 | Hexo (fuzidage.github.io)</a></p>
<h3><span id="2-2-3-structure-block">2.2.3 structure block</span><a href="#2-2-3-structure-block" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/24.png" alt="image"></p>
<h3><span id="2-2-4-strings-block">2.2.4 strings block</span><a href="#2-2-4-strings-block" class="header-anchor">#</a></h3><p>该部分类似于ELF文件中的字符串表，存储了所有属性名（字符串），考虑到很多节点拥有一些同名的属性，集中存放属性名可以有效的节约DTB文件的空间，存放有属性的<code>structure block</code>部分只需要保存一个32位的偏移值——属性名的起始位置在<code>strings block</code>中的偏移。</p>
<h2><span id="2-3-dtb-wen-jian-de-bian-yi">2.3 DTB文件的编译</span><a href="#2-3-dtb-wen-jian-de-bian-yi" class="header-anchor">#</a></h2><h3><span id="2-3-1-zai-nei-he-zhong-zhi-jie-make">2.3.1 在内核中直接 make</span><a href="#2-3-1-zai-nei-he-zhong-zhi-jie-make" class="header-anchor">#</a></h3><p>进入内核源码的目录，执行如下命令即可编译 dtb 文件。<code>make all</code>命令是编译 Linux源码中的所有东西，包括 <code>zImage，dtb，.ko</code>驱动模块以及设备树，如果只是编译设备树的话建议使用<code>“ make dtbs”</code>命令。</p>
<pre><code>make dtbs V=1
</code></pre>
<h3><span id="2-3-2-shou-gong-bian-yi">2.3.2 手工编译</span><a href="#2-3-2-shou-gong-bian-yi" class="header-anchor">#</a></h3><p>内核目录下 <code>scripts/dtc/dtc</code> 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用<code>“#include”</code>，而必须使用<code>“/incldue”</code>。</p>
<p><strong>编译</strong>、反编译的示例命令如下，<code>“-I”</code>指定输入格式，<code>“-O”</code>指定输出格式，<code>“-o”</code>指定输出文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts <span class="comment">// 编译 dts 为 dtb </span></span><br><span class="line">./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb <span class="comment">// 反编译 dtb 为 dts </span></span><br></pre></td></tr></table></figure>

<p>DTC工具源码在 Linux内核的 <code>scripts/dtc</code>目录下，<code>scripts/dtc/Makefile</code>文件内容如下：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/25.png" alt="image"></p>
<h3><span id="2-3-3-fan-bian-yi-dtb">2.3.3 反编译dtb</span><a href="#2-3-3-fan-bian-yi-dtb" class="header-anchor">#</a></h3><p>cd 板子所用的内核源码目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng">2.4 内核对设备树的处理过程</span><a href="#2-4-nei-he-dui-she-bei-shu-de-chu-li-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/26.png" alt="image"></p>
<p>① dts 在 PC 机上被编译为 dtb 文件；<br>② u-boot 把 dtb 文件传给内核；<br>③ 内核解析 dtb 文件，把每一个节点都转换为 <code>device_node</code> 结构体；<br>④ 对于某些 <code>device_node</code> 结构体，会被<code>platform_device</code> 结构体获取资源信息<br><strong>dts解析过程:</strong><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/27.png" alt="image"><br>最终实际dts解析的函数为<code>unflatten_dt_node</code>。</p>
<h3><span id="2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti">2.4.1 dtb 中每一个节点都被转换为 device_node 结构体</span><a href="#2-4-1-dtb-zhong-mei-yi-ge-jie-dian-du-bei-zhuan-huan-wei-device-node-jie-gou-ti" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/28.png" alt="image"></p>
<p>根节点被保存在全局变量 <code>of_root</code> 中，从 <code>of_root </code>开始可以访问到任意节点。</p>
<h3><span id="2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device">2.4.2 哪些设备树节点会被转换为 platform_device</span><a href="#2-4-2-na-xie-she-bei-shu-jie-dian-hui-bei-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/&#123; </span><br><span class="line">	mytest &#123;</span><br><span class="line">		compatile = <span class="string">&quot;mytest&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		mytest@<span class="number">0</span> &#123; </span><br><span class="line">			compatile = <span class="string">&quot;mytest_0&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line"></span><br><span class="line">	i2c &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,i2c&quot;</span>; </span><br><span class="line">		at24c02 &#123; </span><br><span class="line">			compatile = <span class="string">&quot;at24c02&quot;</span>; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">	spi &#123; </span><br><span class="line">		compatile = <span class="string">&quot;samsung,spi&quot;</span>; </span><br><span class="line">		flash@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;winbond,w25q32dw&quot;</span>; </span><br><span class="line">			spi-max-frequency = &lt;<span class="number">25000000</span>&gt;; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>①根节点下含有 <code>compatile</code> 属性的子节点<br>②含有特定 <code>compatile</code> 属性的节点的子节点 :</p>
<pre><code>如果一个节点的 compatile 属性，它的值是这 4 者之一：&quot;simple-bus&quot;,&quot;simple-mfd&quot;,&quot;isa&quot;,&quot;arm,amba-bus&quot;, 那 么 它 的 子结点 ( 需 含compatile 属性)也可以转换为 platform_device。 
</code></pre>
<p>③总线 I2C、SPI 节点下的子节点：不转换为<code>platform_device</code><br>    某个总线下到子节点，应该交给对应的总线驱动程序来处理, 它们不应该被转换为<code> platform_device</code>。<br>    比如以下的节点中： </p>
<pre><code>⚫ /mytest 会被转换为 platform_device, 因为它兼容&quot;simple-bus&quot;; 它的子节点/mytest/mytest@0 也会被转换为 platform_device 
⚫ /i2c 节点一般表示 i2c 控制器, 它会被转换为 platform_device, 在内核 中有对应的 platform_driver; 
⚫ /i2c/at24c02 节点不会被转换为 platform_device, 它被如何处理完全由父节点的 platform_driver 决定, 一般是被创建为一个 i2c_client。 
⚫ 类似的也有/spi 节点, 它一般也是用来表示 SPI 控制器, 它会被转换为 platform_device, 在内核中有对应的 platform_driver; 
⚫ /spi/flash@0 节点不会被转换为 platform_device, 它被如何处理完全由 父节点的 platform_driver 决定, 一般是被创建为一个 spi_device。 
</code></pre>
<h3><span id="2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device">2.4.3 节点怎么转换为 platform_device</span><a href="#2-4-3-jie-dian-zen-me-zhuan-huan-wei-platform-device" class="header-anchor">#</a></h3><pre><code>⚫ platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性; 
⚫ platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性
</code></pre>
<h1><span id="3-wan-zheng-dts-shi-li">3 完整dts示例</span><a href="#3-wan-zheng-dts-shi-li" class="header-anchor">#</a></h1><p>编写设备树之前要先定义一个设备，我们就以<code> I.MX6ULL</code>这个 SOC为例，我们需要在设备树里面描述的内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①、 I.MX6ULL这个 Cortex-A7架构的 <span class="number">32</span>位 CPU。</span><br><span class="line">②、 I.MX6ULL内部 ocram，起始地址 <span class="number">0x00900000</span>，大小为 <span class="number">128</span>KB(<span class="number">0x20000</span>)。</span><br><span class="line">③、 I.MX6ULL内部 aips1域下的 ecspi1外设控制器，寄存器起始地址为 <span class="number">0x02008000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">④、 I.MX6ULL内部 aips2域下的 usbotg1外设控制器，寄存器起始地址为 <span class="number">0x02184000</span>，大小为 <span class="number">0x4000</span>。</span><br><span class="line">⑤、 I.MX6ULL内部 aips3域下的 rngb外设控制器，寄存器起始地址为 <span class="number">0x02284000</span>，大小为 <span class="number">0x4000</span></span><br></pre></td></tr></table></figure>

<h2><span id="3-1-tian-jia-cpus-jie-dian">3.1 添加 cpus节点</span><a href="#3-1-tian-jia-cpus-jie-dian" class="header-anchor">#</a></h2><p>cpu节点，<code> I.MX6ULL</code>采用<code> Cortex-A7</code>架构，而且只有一个 CPU，因此只有一个cpu0节点，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ull-alientek-evk&quot;</span>, <span class="string">&quot;fsl,imx6ull&quot;</span>;</span><br><span class="line">	cpus &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">		<span class="comment">//CPU0节点 </span></span><br><span class="line">		cpu0: cpu@<span class="number">0</span> &#123; </span><br><span class="line">			compatible = <span class="string">&quot;arm,cortex-a7&quot;</span>; </span><br><span class="line">			device_type = <span class="string">&quot;cpu&quot;</span>; </span><br><span class="line">			reg = &lt;<span class="number">0</span>&gt;; </span><br><span class="line">		&#125;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-tian-jia-soc-jie-dian">3.2 添加 soc节点</span><a href="#3-2-tian-jia-soc-jie-dian" class="header-anchor">#</a></h2><p>像<code> uart iic</code>控制器等等这些都属于 SOC内部外设，因此一般会创建一个叫做 <code>soc</code>的父节点来管理这些 SOC内部外设的子节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; </span><br><span class="line">	<span class="comment">//soc节点 </span></span><br><span class="line">	soc &#123; </span><br><span class="line">		<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">		compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">		ranges; </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>soc节点设置 <code>#address-cells = &lt;1&gt;</code>，<code>#size-cells = &lt;1&gt;</code>，这样 soc子节点的 reg属性中起始地占用一个字长，地址空间长度也占用一个字长。<code>ranges</code>属性为空，说明子空间和父空间地址范围相同。</p>
<h3><span id="3-2-1-tian-jia-ocram-jie-dian">3.2.1 添加 ocram节点</span><a href="#3-2-1-tian-jia-ocram-jie-dian" class="header-anchor">#</a></h3><p>根据第②点的要求，添加<code> ocram</code>节点，<code> ocram</code>是<code> I.MX6ULL</code>内部 RAM，因此 <code>ocram</code>节点应该是 soc节点的子节点。 <code>ocram</code>起始地址为 <code>0x00900000</code>，大小为<code>128KB(0x20000)</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//soc节点 </span></span><br><span class="line">soc &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	ranges; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//ocram节点 </span></span><br><span class="line">	ocram: sram@<span class="number">00900000</span> &#123; </span><br><span class="line">		compatible = <span class="string">&quot;fsl,lpm-sram&quot;</span>; </span><br><span class="line">		reg = &lt;<span class="number">0x00900000</span> <span class="number">0x20000</span>&gt;; </span><br><span class="line">	&#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian">3.2.2 添加 aips1、 aips2和 aips3节点</span><a href="#3-2-2-tian-jia-aips1-aips2-he-aips3-jie-dian" class="header-anchor">#</a></h3><p><code>IMX6ULL</code>外设控制分为三个域： <code>aips1~3</code>，这三个域分管不同的外设控制器，<code>aips1~3</code>这三个域都属于 soc节点的子节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//aips1节点</span></span><br><span class="line">aips1: aips-bus@<span class="number">02000000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02000000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips2: aips-bus@<span class="number">02100000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02100000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br><span class="line">aips3: aips-bus@<span class="number">02200000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,aips-bus&quot;</span>, <span class="string">&quot;simple-bus&quot;</span>; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	reg = &lt;<span class="number">0x02200000</span> <span class="number">0x100000</span>&gt;; </span><br><span class="line">	ranges; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian">3.2.2.1 添加 ecspi1、 usbotg1和 rngb节点</span><a href="#3-2-2-1-tian-jia-ecspi1-usbotg1-he-rngb-jie-dian" class="header-anchor">#</a></h4><p>每个域节点下都添加一个外设节点。<code>ecspi1</code>属于 <code>aips1</code>的子节点，<code> usbotg1</code>属于 <code>aips2</code>的子节点， <code>rngb</code>属于 <code>aips3</code>的子节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ecspi1节点 </span></span><br><span class="line">ecspi1: ecspi@<span class="number">02008000</span> &#123; </span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>; </span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>; </span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="string">&quot;fsl,imx51-ecspi&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02008000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usbotg1节点 </span></span><br><span class="line">usbotg1: usb@<span class="number">02184000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-usb&quot;</span>, <span class="string">&quot;fsl,imx27-usb&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02184000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rngb节点 </span></span><br><span class="line">rngb: rngb@<span class="number">02284000</span> &#123; </span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6sl-rng&quot;</span>, <span class="string">&quot;fsl,imx-rng&quot;</span>, <span class="string">&quot;imx-rng&quot;</span>; </span><br><span class="line">	reg = &lt;<span class="number">0x02284000</span> <span class="number">0x4000</span>&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/" data-id="clzp8uttd003f9ouf3hcaby7s" data-title="字符设备驱动-4-设备树" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-3-GPIO驱动KEY示例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T09:51:13.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/">字符设备驱动-3-GPIO驱动KEY示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</a><ul>
<li><a href="#1-1-cha-xun-fang-shi">1.1 查询方式</a></li>
<li><a href="#1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</a></li>
<li><a href="#1-3-poll-fang-shi">1.3 poll 方式</a></li>
<li><a href="#1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</a></li>
<li><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</a></li>
</ul>
</li>
<li><a href="#2-gpio-an-jian-qu-dong">2 GPIO按键驱动</a><ul>
<li><a href="#2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</a><ul>
<li><a href="#2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</a></li>
<li><a href="#2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</a></li>
</ul>
</li>
<li><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</a><ul>
<li><a href="#2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</a></li>
<li><a href="#2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</a></li>
<li><a href="#2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</a></li>
<li><a href="#2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ce-shi">3 测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-app-du-qu-an-jian-fang-shi">1 APP 读取按键方式</span><a href="#1-app-du-qu-an-jian-fang-shi" class="header-anchor">#</a></h1><ol>
<li>查询方式</li>
<li>休眠-唤醒方式</li>
<li>poll 方式</li>
<li>异步通知方式</li>
</ol>
<p>第2、3、4种方法，都涉及中断服务程序。</p>
<h2><span id="1-1-cha-xun-fang-shi">1.1 查询方式</span><a href="#1-1-cha-xun-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/1.png" alt="image"></p>
<p>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO 为输入引脚。 APP 调用 read 时，导致驱动中对应的 read 函数被调用，它读取寄存器，把引脚状态直接返回给 APP,APP需要反复read查询引脚电平状态。</p>
<p>很明显，查询方式用的非阻塞IO（<code>O_NONBLOCK</code>）。</p>
<h2><span id="1-2-xiu-mian-huan-xing-fang-shi">1.2 休眠-唤醒方式</span><a href="#1-2-xiu-mian-huan-xing-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/2.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 read 时，导致驱动中对应的 read 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态read函数中休眠。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，read函数被唤醒，执行驱动代码，把按键数据返回给APP(用户空间)。</li>
</ol>
<h2><span id="1-3-poll-fang-shi">1.3 poll 方式</span><a href="#1-3-poll-fang-shi" class="header-anchor">#</a></h2><p>上面的休眠-唤醒方式有个缺点：如果一直没操作按键，那么 APP 就会永远休眠。<br>我们可以给 APP 定个闹钟，这就是 poll 方式。当超时后就直接返回不再休眠。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/3.png" alt="image"></p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 调用 poll 或 select 函数，意图是“查询”是否有数据，这 2 个函数都可以指定一个超时时间，即在这段时间内没有数据的话就返回错误。这会导致驱动中对应的 <code>drv_poll</code> 函数被调用，如果有按键数据则直接返回给 APP；否则 APP 在内核态休眠一段时间。</li>
<li>当按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，并唤醒休眠中的 APP。如果用户没按下按键，但是超时时间到了，内核也会唤醒 APP。</li>
</ol>
<p>所以 APP 被唤醒有 2 种原因：用户操作了按键或者超时。被唤醒的 APP 在内核态继续运行，即继续执行驱动代码，把 “状态” 返回给 APP(用户空间)。APP 得到 <code>poll/select </code>函数的返回结果后，如果确认是有数据的，则再调用 read 函数，这会导致驱动中的 read 函数被调用，这时驱动程序中含有数据，会直接返回数据。</p>
<h2><span id="1-4-yi-bu-tong-zhi-fang-shi">1.4 异步通知方式</span><a href="#1-4-yi-bu-tong-zhi-fang-shi" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/4.png" alt="image"><br>异步通知的实现原理是：内核给 APP 发信号。信号有很多种，这里发的是SIGIO。<br>驱动程序中构造、注册一个<code> file_operations</code> 结构体，里面提供有对应的<code>open,read,fasync</code> 函数。</p>
<ol>
<li>APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置GPIO 为输入引脚；并且注册 GPIO 的中断处理函数。</li>
<li>APP 给信号 <code>SIGIO</code> 注册自己的处理函数： <code>my_signal_fun</code>。</li>
<li>APP 调用<code>fcntl</code>函数，把驱动程序的 flag 改为 <code>FASYNC</code>，这会导致驱动程序的<code>fasync</code>函数被调用，它只是简单记录进程 PID。</li>
<li>当用户按下按键时， GPIO 中断被触发，导致驱动程序之前注册的中断服务程序被执行。它会记录按键数据，然后给进程 PID 发送 <code>SIGIO</code> 信号。</li>
<li>APP 收到信号后会被打断，先执行信号处理函数：在信号处理函数中可以去调用 read 函数读取按键值。</li>
<li>信号处理函数返回后， APP 会继续执行原先被打断的代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig_func</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;get a signal : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    signal(SIGIO, my_sig_func);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, world %d!\n&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/5.png" alt="image-20240728184640793"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/6.png" alt="image"><br>发送一个SIGIO讯号给进程<code>3581339</code> <code>my_sig_func</code>函数，可以看到打印<code>”get a signal 29“</code>，即为<code>SIGIO</code>信号。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/7.png" alt="image"></p>
<h2><span id="1-5-zong-jie-4-chong-du-an-jian-fang-shi">1.5 总结4种读按键方式</span><a href="#1-5-zong-jie-4-chong-du-an-jian-fang-shi" class="header-anchor">#</a></h2><p>关于这几种方式的具体原理和示例后面会进行深度剖析：</p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-6.POLL底层驱动机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17438371.html">字符设备驱动-7.异步通知 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17469849.html">字符设备驱动-8.休眠唤醒机制 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h1><span id="2-gpio-an-jian-qu-dong">2 GPIO按键驱动</span><a href="#2-gpio-an-jian-qu-dong" class="header-anchor">#</a></h1><h2><span id="2-1-an-jian-qu-dong-kuang-jia">2.1 按键驱动框架</span><a href="#2-1-an-jian-qu-dong-kuang-jia" class="header-anchor">#</a></h2><p>按键驱动程序最简单的方法：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/8.png" alt="image"></p>
<p>我们的目的写出一个容易扩展到各种芯片、各种板子的按键驱动程序，所以驱动程序分为<strong>上下两层</strong>：</p>
<ol>
<li><code>button_drv.c</code> 分配&#x2F;设置&#x2F;注册<code> file_operations</code> 结构体起承上启下的作用，向上提供 <code>button_open</code>,<code>button_read </code>供 APP 调用。而这 2 个函数又会调用底层硬件提供的 <code>p_button_opr </code>中的 init、 read 函数操作硬件。</li>
<li><code>board_xxx.c</code> 实现 <code>p_button_opr</code>结构体，这个结构体是我们自己抽象出来的，里面定义<code>单板 xxx</code> 的按键操作函数。这样的结构易于扩展，对于不同的单板，只需要替换<code>board_xxx.c</code>提供自己的 <code>button_operations</code> 结构体即可。<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/9.png" alt="image"></li>
</ol>
<h3><span id="2-1-1-button-operations-jie-gou-ti">2.1.1 button_operations 结构体</span><a href="#2-1-1-button-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.h</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BUTTON_DRV_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">void</span> (*init) (<span class="type">int</span> which);</span><br><span class="line">    <span class="type">int</span> (*read) (<span class="type">int</span> which);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>board_xxx.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_xxx_button_init_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, init gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_xxx_button_read_gpio</span> <span class="params">(<span class="type">int</span> which)</span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;%s %s %d, read gpio for button %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__, which);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span>&#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init  = board_xxx_button_init_gpio,</span><br><span class="line">    .read  = board_xxx_button_read_gpio,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_xxx_button_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_xxx_button_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_xxx_button_init);</span><br><span class="line">module_exit(board_xxx_button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
board_xxx.c里面实现了具体单板的button_operations，当insmod这个驱动时，调用 register_button_operations 函数，把my_buttons_ops这个结构体注册到上层驱动中，这里.init .read函数先不去实现。

<h3><span id="2-1-2-file-operations-jie-gou-ti">2.1.2 file_operations 结构体</span><a href="#2-1-2-file-operations-jie-gou-ti" class="header-anchor">#</a></h3><details>
<summary>button_drv.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/skbuff.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/capi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernelcapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> *<span class="title">p_button_opr</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">button_class</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">button_open</span> <span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">    p_button_opr-&gt;init(minor);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">button_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *off)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = iminor(file_inode(file));</span><br><span class="line">    <span class="type">char</span> level;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    level = p_button_opr-&gt;read(minor);</span><br><span class="line">    err = copy_to_user(buf, &amp;level, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">button_fops</span> =</span> &#123;</span><br><span class="line">    .open = button_open,</span><br><span class="line">    .read = button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_button_operations</span><span class="params">(<span class="keyword">struct</span> button_operations *opr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    p_button_opr = opr;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_create(button_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;100ask_button%d&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_button_operations</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_button_opr-&gt;count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        device_destroy(button_class, MKDEV(major, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(register_button_operations);</span><br><span class="line">EXPORT_SYMBOL(unregister_button_operations);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">button_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_button&quot;</span>, &amp;button_fops);</span><br><span class="line">    button_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(button_class))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">button_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    class_destroy(button_class);</span><br><span class="line">    unregister_chrdev(major, <span class="string">&quot;100ask_button&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(button_init);</span><br><span class="line">module_exit(button_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>
上层是 `button_drv.c`，按照字符设备驱动标准框架编写，`register_button_operations`实现了将底层具体的`button_operations`对象注册进来，调用`open/read`时便可操作具体的单板，`device_create`为单板的具体按键创建设备节点。注意`insmod`顺序要先安装`button_drv.ko`, 具体单板驱动要后安装，否则`register_button_operations`函数是未定义的。



<h2><span id="2-2-ju-ti-dan-ban-an-jian-qu-dong">2.2 具体单板按键驱动</span><a href="#2-2-ju-ti-dan-ban-an-jian-qu-dong" class="header-anchor">#</a></h2><p>以<code>imx6ull</code>单板为例，按键引脚为 <code>GPIO5_IO01</code>、 <code>GPIO4_IO14</code>，平时按键电平为高，按下按键后电平为低，如下图：<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/10.png" alt="image"></p>
<ol>
<li>使能电源&#x2F;时钟控制器</li>
<li>配置引脚模式成gpio</li>
<li>配置引脚方向为输入</li>
<li>读取电平<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/11.png" alt="image"></li>
</ol>
<h3><span id="2-2-1-ccm-shi-zhong-shi-neng">2.2.1 CCM时钟使能</span><a href="#2-2-1-ccm-shi-zhong-shi-neng" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/12.png" alt="image"><br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/13.png" alt="image"><br>设置<code> CCM_CCGR1[31:30]</code>、<code> CCM_CCGR3[13:12]</code>就可以使能<code> GPIO5</code>、<code>GPIO4</code>，设置为什么值呢？<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/14.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>：该 GPIO 模块全程被关闭</span><br><span class="line"><span class="number">01</span>：该 GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭</span><br><span class="line"><span class="number">10</span>：保留</span><br><span class="line"><span class="number">11</span>：该 GPIO 模块全程使能</span><br></pre></td></tr></table></figure>

<p>那么将<code>CCM_CCGR1[31:30]</code>、 <code>CCM_CCGR3[13:12]</code>设置成<code>0b11</code>即可。</p>
<h3><span id="2-2-2-pei-cheng-gpio-mo-shi">2.2.2 配成GPIO 模式</span><a href="#2-2-2-pei-cheng-gpio-mo-shi" class="header-anchor">#</a></h3><ol>
<li><code>GPIO5_IO01</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/15.png" alt="image"><ol start="2">
<li><code>GPIO4_IO14</code> pinmux 成 GPIO:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/16.png" alt="image"></li>
</ol>
</li>
</ol>
<h3><span id="2-2-3-gpio-pei-cheng-shu-ru">2.2.3 GPIO配成输入</span><a href="#2-2-3-gpio-pei-cheng-shu-ru" class="header-anchor">#</a></h3><p><code>GPIO4,GPIO5</code>寄存器地址:<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/17.png" alt="image"><br>方向设置寄存器:(<code>offset 04</code>)<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/18.png" alt="image"></p>
<h3><span id="2-2-4-du-qu-gpio-dian-ping">2.2.4 读取gpio电平</span><a href="#2-2-4-du-qu-gpio-dian-ping" class="header-anchor">#</a></h3><p>注意输入模式下，gpio电平状态得从<code>GPIOx_PSR</code>得到（<code>offset 08</code>）<br><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/19.png" alt="image"></p>
<details>
<summary>button_board_imx6ull.c</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;button_drv.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR3; </span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set GPIO5_IO03 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1;</span><br><span class="line"><span class="comment">/* set GPIO4_IO14 as GPIO */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio4</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio5</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">board_imx6ull_button_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化button, which-哪个button */</span>      </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CCM_CCGR1)&#123;</span><br><span class="line">        CCM_CCGR1 = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">        CCM_CCGR3 = ioremap(<span class="number">0x20C4074</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = ioremap(<span class="number">0x229000C</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B        = ioremap(<span class="number">0x20E01B0</span>, <span class="number">4</span>);</span><br><span class="line">        gpio4 = ioremap(<span class="number">0x020A8000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">        gpio5 = ioremap(<span class="number">0x20AC000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO5 </span></span><br><span class="line"><span class="comment">         * CG15, b[31:30] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO5_IO01 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER1 = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO5_IO01 as input </span></span><br><span class="line"><span class="comment">         * GPIO5 GDIR, b[1] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio5-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">/* 1. enable GPIO4 </span></span><br><span class="line"><span class="comment">         * CG6, b[13:12] = 0b11</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *CCM_CCGR3 |= (<span class="number">3</span>&lt;&lt;<span class="number">12</span>);</span><br><span class="line">        <span class="comment">/* 2. set GPIO4_IO14 as GPIO </span></span><br><span class="line"><span class="comment">         * MUX_MODE, b[3:0] = 0b101</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        *IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">/* 3. set GPIO4_IO14 as input </span></span><br><span class="line"><span class="comment">         * GPIO4 GDIR, b[14] = 0b0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        gpio4-&gt;gdir &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_imx6ull_button_read</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 读button, which-哪个 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> (gpio5-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> (gpio4-&gt;psr &amp; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_operations</span> <span class="title">my_buttons_ops</span> =</span> &#123;</span><br><span class="line">    .count = <span class="number">2</span>,</span><br><span class="line">    .init = board_imx6ull_button_init,</span><br><span class="line">    .read = board_imx6ull_button_read,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">board_imx6ull_button_drv_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    register_button_operations(&amp;my_buttons_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">board_imx6ull_button_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    unregister_button_operations();</span><br><span class="line">&#125;</span><br><span class="line">module_init(board_imx6ull_button_drv_init);</span><br><span class="line">module_exit(board_imx6ull_button_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<p>具体单板驱动insmod会调用<code> register_button_operations</code>把具体的<code>my_buttons_ops</code>注册进去。当用户open,就会进行<code>board_imx6ull_button_init</code>进行按键寄存器配置。当用户read的时候调用<code>board_imx6ull_button_read</code>读取按键值。</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/20.png" alt="image"></p>
<h1><span id="3-ce-shi">3 测试</span><a href="#3-ce-shi" class="header-anchor">#</a></h1><details>
<summary>Makefile</summary>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">	<span class="variable">$(CROSS_COMPILE)</span>gcc -o button_test button_test.c </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">	rm -rf modules.order</span><br><span class="line">	rm -f ledtest</span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line">obj-m	+= button_drv.o</span><br><span class="line">obj-m	+= board_xxx.o</span><br></pre></td></tr></table></figure>

</details>

<details>
<summary>测试代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./button_test /dev/100ask_button0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> val;</span><br><span class="line">	<span class="comment">/* 1. 判断参数 */</span></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 2. 打开文件 */</span></span><br><span class="line">	fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">	<span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 3. 写文件 */</span></span><br><span class="line">	read(fd, &amp;val, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;get button : %d\n&quot;</span>, val);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/21.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/" data-id="clzp8uttd003d9ouf1uba8ixp" data-title="字符设备驱动-3-GPIO驱动KEY示例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-2-总线模型和平台设备驱动" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" class="article-date">
  <time class="dt-published" datetime="2024-07-25T16:38:15.000Z" itemprop="datePublished">2024-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">字符设备驱动-2-总线模型和平台设备驱动</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</a><ul>
<li><a href="#1-1-zong-xian-ping-tai-she-bei-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</a><ul>
<li><a href="#1-1-1-struct-bus-type">1.1.1 struct bus_type</a></li>
<li><a href="#1-1-2-struct-platform-driver">1.1.2 struct platform_driver</a></li>
<li><a href="#1-1-3-struct-platform-device">1.1.3 struct platform_device</a></li>
<li><a href="#1-1-4-zong-xian-she-bei-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</a></li>
</ul>
</li>
<li><a href="#1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</a></li>
<li><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</a><ul>
<li><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</a><ul>
<li><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</a><ul>
<li><a href="#1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</a></li>
<li><a href="#1-3-1-1-2-id-table">1.3.1.1.2 ID table</a></li>
<li><a href="#1-3-1-1-3-name">1.3.1.1.3 name</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</a></li>
<li><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</a></li>
</ul>
</li>
<li><a href="#1-4-zong-jie-ping-tai-she-bei-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</a></li>
<li><a href="#1-6-ping-tai-she-bei-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</a><ul>
<li><a href="#1-6-1-zhu-ce-fan-zhu-ce">1.6.1 注册&#x2F;反注册</a></li>
<li><a href="#1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</a><ul>
<li><a href="#1-6-2-1-io-resource">1.6.2.1 IO resource</a></li>
<li><a href="#1-6-2-2-irq">1.6.2.2 IRQ</a></li>
<li><a href="#1-6-2-3-gpio">1.6.2.3 GPIO</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</a><ul>
<li><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</a></li>
<li><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</a></li>
<li><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</a></li>
<li><a href="#2-4-ce-shi">2.4 测试</a><ul>
<li><a href="#2-4-1-makefile">2.4.1 Makefile</a></li>
<li><a href="#2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</a></li>
</ul>
</li>
<li><a href="#2-5-is-err-err-ptr-ptr-err-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</a><ul>
<li><a href="#2-5-1-is-err">2.5.1 IS_ERR</a></li>
<li><a href="#2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</a></li>
<li><a href="#2-5-3-ptr-err">2.5.3 PTR_ERR</a></li>
<li><a href="#2-5-4-err-ptr">2.5.4 ERR_PTR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-yin-ru-sysfs">3 引入sysfs</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zong-xian-she-bei-qu-dong-mo-xing">1 总线设备驱动模型</span><a href="#1-zong-xian-she-bei-qu-dong-mo-xing" class="header-anchor">#</a></h1><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/1.png" alt="img"></p>
<p>设备定义资源，<code>platform_device</code>结构体</p>
<p>驱动定义<code>platform_driver</code>结构体，实现<code>probe, file_operations</code></p>
<p>总线驱动模型优点：</p>
<p>驱动只是一套控制驱动框架，基本不用修改，和单板硬件相关的都在设备代码里面，硬件修改只需要修改设备资源相关的代码，不用关心具体的函数实现和寄存器控制。</p>
<h2><span id="1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu">1.1 总线&#x2F;平台设备&#x2F;平台驱动描述</span><a href="#1-1-zong-xian-x2f-ping-tai-she-bei-x2f-ping-tai-qu-dong-miao-shu" class="header-anchor">#</a></h2><h3><span id="1-1-1-struct-bus-type">1.1.1 struct bus_type</span><a href="#1-1-1-struct-bus-type" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/2.png" alt="img"></p>
<p>有一个很关键的函数，<code>match</code>函数。当设备与设备枚举过程中match函数会按照规则进行匹配,规则见<code>1.3.1</code>。</p>
<h3><span id="1-1-2-struct-platform-driver">1.1.2 struct platform_driver</span><a href="#1-1-2-struct-platform-driver" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/3.png" alt="img"></p>
<h3><span id="1-1-3-struct-platform-device">1.1.3 struct platform_device</span><a href="#1-1-3-struct-platform-device" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4.png" alt="img"></p>
<h3><span id="1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi">1.1.4 总线&#x2F;设备&#x2F;驱动三者关系</span><a href="#1-1-4-zong-xian-x2f-she-bei-x2f-qu-dong-san-zhe-guan-xi" class="header-anchor">#</a></h3><ol>
<li><p>系统启动后，会调用<code>buses_init()</code>函数创建<code>/sys/bus</code>文件目录。</p>
</li>
<li><p>接下来就是通过总线注册函数<code>bus_register()</code>进行总线注册，注册完成后，在<code>/sys/bus</code>目录下生成device文件夹和driver文件夹。</p>
</li>
<li><p>最后分别通过<code>device_register()</code>和<code>driver_register()</code>函数注册对应的设备和驱动。<br><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/4_1.png" alt="image-20240727214421349"></p>
</li>
</ol>
<h2><span id="1-2-platform-device-de-zhu-ce-guo-cheng">1.2 platform_device的注册过程</span><a href="#1-2-platform-device-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/5.png" alt="image-20240727164939263"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/6.png" alt="image-20240726004737362"></p>
<ol>
<li>系统初始化时，调用<code>platform_add_devices</code>函数，把所有放置在板级<code>platform_device</code>数组中的<code>platform_device</code>注册到系统中去。</li>
</ol>
<ul>
<li><p>1.1 此函数循环调用<code>platform_device_register</code>函数，来注册每个<code>platform_device</code>。</p>
</li>
<li><p>1.2 而<code>platform_device_register</code>中会调用<code>platform_device_add</code>函数。</p>
</li>
</ul>
<ol start="2">
<li><code>platform_device</code>全部注册到系统之后，便可以通过<code>platform</code>的操作接口，来获取<code>platform_device</code>中的resource资源。</li>
</ol>
<ul>
<li><p>2.1 比如地址、中断号等，以进行<code>request_mem_region</code>、<code>ioremap</code>（将resource分配的物理地址映射到kernel的虚拟空间来）和<code>request_irq</code>操作。</p>
</li>
<li><p>2.2 <code>platform</code>的操作接口包括<code>platform_get_irq</code>、<code>platform_get_irq_byname</code>、<code>platform_get_resource</code>、<code>platform_get_resource_byname</code>等。这个后面设备树专题会专门介绍<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17369817.html">字符设备驱动-5.设备树函数 - fuzidage - 博客园 (cnblogs.com)</a>。</p>
</li>
</ul>
<h2><span id="1-3-platform-driver-de-zhu-ce-guo-cheng">1.3 platform_driver的注册过程</span><a href="#1-3-platform-driver-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p>当<code>insmod</code>设备驱动的时候会透过<code>module_init</code>调用, 过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">platform_driver_register()</span><br><span class="line">	driver_register()</span><br><span class="line">		bus_add_driver<span class="comment">//加入driver链表</span></span><br><span class="line">			driver_attach()</span><br><span class="line">				bus_for_each_dev()</span><br><span class="line">					__driver_attach()</span><br><span class="line">						driver_match_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">							platform_match</span><br><span class="line">    					driver_probe_device<span class="comment">//drvier匹配device成功调用driver的probe</span></span><br><span class="line">    						drv-&gt;probe(dev);</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-1-device-he-driver-de-pi-pei-guo-cheng">1.3.1 device和driver的匹配过程</span><a href="#1-3-1-device-he-driver-de-pi-pei-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/7.png" alt="image-20240727170404969"></p>
<h4><span id="1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu">1.3.1.1 device和driver的匹配优先级顺序</span><a href="#1-3-1-1-device-he-driver-de-pi-pei-you-xian-ji-shun-xu" class="header-anchor">#</a></h4><p>一个驱动是可以匹配多个设备的，平台总线中的驱动要具有三种匹配信息的能力，基于这种需求，<code>platform_driver</code>中使用不同的成员来进行相应的匹配。系统为platform总线定义了一个<code>bus_type 的实例platform_bus_type</code>, 会不断循环呼叫<code>platform_match函数</code>去遍历所有设备和驱动:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/8.png" alt="img"></p>
<p>匹配优先级顺序实现位于<code>drivers/base/platform.c</code>的platform_match函数，下面按照优先级由高到底的匹配顺序介绍：</p>
<h5><span id="1-3-1-1-1-of-match-table">1.3.1.1.1 of_match_table</span><a href="#1-3-1-1-1-of-match-table" class="header-anchor">#</a></h5><p><code>of_match_table</code>就是从dts中对应node的<code>compatible属性</code>去匹配设备和驱动。</p>
<p><code>compatible</code>属性也叫做<code>“兼容性”</code>属性，是一个字符串列表, 格式如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“manufacturer,model”</span><br></pre></td></tr></table></figure>

<p><code>manufacturrer</code>表示厂商，<code>model</code>表示驱动名字，该属性用于将设备和驱动绑定起来。</p>
<p><code>platform_device.dev.of_node </code>和 <code>platform_driver.driver.of_match_table</code>介绍：</p>
<p>由设备树节点转换得来的 <code>platform_device </code>中，含有一个结构体：<code>of_node</code>。 它的类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/9.png" alt="img"></p>
<p><code>platform_driver.driver.of_match_table </code>类型如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/10.png" alt="img"></p>
<p>一般驱动程序都会有一个<code>of_match_table</code>匹配表，此<code>of_match_table</code>匹配表保存着一些<code>compatible</code>值，如果dts中的<code>compatible</code>属性值和<code>of_match_table</code>匹配表中的有一个值相等，那么就表示设备可以使用这个驱动。</p>
<p>如下图dts定义了一个<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/11.png" alt="img"></p>
<p>驱动程序中的定义如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/12.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/13.png" alt="img"></p>
<p>那么这里驱动程序中的<code>.of_match_table</code>和dts能够匹配，那么就说明<code>match</code>成功，匹配成功后调用<code>platform driver</code>的<code>probe</code>函数。一般在驱动程序<code>module int</code>的时候，也就是<code>insmod</code>的时候，会用<code>platform_driver_register</code>来进行match过程。</p>
<h5><span id="1-3-1-1-2-id-table">1.3.1.1.2 ID table</span><a href="#1-3-1-1-2-id-table" class="header-anchor">#</a></h5><p>下面这个例子就是用一个驱动来匹配两个分别叫<code>&quot;demo0&quot;</code>和<code>&quot;demo1&quot;</code>的设备，注意，数组最后的{}是一定要的，这个是内核判断数组已经结束的标志。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device_id</span> <span class="title">tbl</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;demo0&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;demo1&quot;</span>&#125;,</span><br><span class="line">        &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(platform, tbl);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/14.png" alt="image-20240727174003803"></p>
<h5><span id="1-3-1-1-3-name">1.3.1.1.3 name</span><a href="#1-3-1-1-3-name" class="header-anchor">#</a></h5><p>假如前面两项匹配规则都不满足，那么最后可以是用name来匹配。例如：上面的<code>mipi_rx: cif</code>节点:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/15.png" alt="image-20240727174511089"></p>
<p>转换后就对应一个<code>platform_device</code>，<code>platform_device</code>中<code>.name= “cif”</code>,利用名字也能匹配上。</p>
<h3><span id="1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe">1.3.2 匹配成功后执行probe</span><a href="#1-3-2-pi-pei-cheng-gong-hou-zhi-xing-probe" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/16.png" alt="image-20240727171618120"></p>
<p>drvier匹配device成功调用driver的probe函数。一般平台设备都不需要驱动代码去定义，而是直接放入设备树作为设备树节点，内核启动后遍历设备树节点，将其转换成<code>platform_device</code>。</p>
<h3><span id="1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng">1.3.3 总结下<code>platform_driver</code>的注册执行过程</span><a href="#1-3-3-zong-jie-xia-platform-driver-de-zhu-ce-zhi-xing-guo-cheng" class="header-anchor">#</a></h3><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/17.png" alt="image-20240727170620921"></p>
<h2><span id="1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng">1.4 总结平台设备&#x2F;平台驱动的注册过程</span><a href="#1-4-zong-jie-ping-tai-she-bei-x2f-ping-tai-qu-dong-de-zhu-ce-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/18.png" alt="img"></p>
<h2><span id="1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api">1.6 平台设备&#x2F;平台驱动相关API</span><a href="#1-6-ping-tai-she-bei-x2f-ping-tai-qu-dong-xiang-guan-api" class="header-anchor">#</a></h2><h3><span id="1-6-1-zhu-ce-x2f-fan-zhu-ce">1.6.1 注册&#x2F;反注册</span><a href="#1-6-1-zhu-ce-x2f-fan-zhu-ce" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\include\linux\platform_device.h</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">　platform_device_register/ platform_device_unregister</span><br><span class="line">　platform_driver_register/ platform_driver_unregister</span><br><span class="line"></span><br><span class="line">　platform_add_devices <span class="comment">// 注册多个 device</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/19.png" alt="image-20240727175522278"></p>
<h3><span id="1-6-2-zi-yuan-huo-qu-shi-fang">1.6.2 资源获取释放</span><a href="#1-6-2-zi-yuan-huo-qu-shi-fang" class="header-anchor">#</a></h3><h4><span id="1-6-2-1-io-resource">1.6.2.1 IO resource</span><a href="#1-6-2-1-io-resource" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>kernel\include\linux\ioport.h</code>中有<code>resource结构</code>。用来描述hw设备的资源信息, <code>include\linux\ioport.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/20.png" alt="img"></p>
<p>flags一般有以下几种：比如中断资源， IO端口资源， IO内存资源， DMA资源</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/21.png" alt="img"></p>
<ul>
<li><code>IORESOURCE_IO</code>：表示IO资源，cpu需要用特殊指令才能访问或需要用特殊访问方式才能访问,不能直接用指针来寻址</li>
<li><code>IORESOURCE_MEM</code>：表示IO内存，可以直接用指针引用来直接寻址操作</li>
</ul>
<p>这里举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/22.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/23.png" alt="img"></p>
<p>打印如下：那这里的<code>pdev</code>对应dts中的<code>mipi_rx</code>节点。<code>platform_get_resource</code>可以从dts <code>node</code>中找到io内存资源。</p>
<p>那这里循环获取4次，如下所示地址范围和上面的dts节点一致：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/24.png" alt="img"></p>
<h4><span id="1-6-2-2-irq">1.6.2.2 IRQ</span><a href="#1-6-2-2-irq" class="header-anchor">#</a></h4><p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/25.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/26.png" alt="img"></p>
<ul>
<li>IORESOURCE_IRQ: 中断irq资源</li>
</ul>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/27.png" alt="img"></p>
<p>中断触发类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include\linux\platform_device.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_RISING 1     <span class="comment">//上升沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_FALLING 2    <span class="comment">//下降沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_EDGE_BOTH (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING) <span class="comment">// 双边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_TYPE_LEVEL_HIGH 4    <span class="comment">//电平触发-高电平</span></span></span><br></pre></td></tr></table></figure>

<p>这里又要引入新概念GIC: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17551724.html">设备驱动-10.中断子系统-3.中断设备树表述与解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p>Dts中描述到了GIC相关基础知识。(<code>Generic Interrupt Controller</code>)是ARM公司提供的一个通用的中断控制器。</p>
<p>GIC <strong>3要素</strong>：</p>
<ul>
<li><ul>
<li>中断类型</li>
<li>中断号</li>
<li>中断触发方式这三个要素</li>
</ul>
</li>
</ul>
<ol>
<li>GIC的外设中断（除去SGI）类型有两类：</li>
</ol>
<ul>
<li><ul>
<li>SPI，共享外设中断(由GIC内部的<code>distributor</code>来分发到相关CPU)，中断号：<code>32~1019</code></li>
<li>PPI，私有外设中断(指定CPU接收)，中断号：<code>16~31</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>外设中断号的分配规则如下：</li>
</ol>
<ul>
<li><ul>
<li><code>32~1019</code>给SPI</li>
<li><code>16~31</code>给PPI</li>
</ul>
</li>
</ul>
<ol start="3">
<li>所有外设中断都支持四种触发方式:</li>
</ol>
<ul>
<li><ul>
<li>上升沿触发</li>
<li>下降沿触发</li>
<li>高电平触发</li>
<li>低电平触发</li>
</ul>
</li>
</ul>
<p>所以DTS中接在GIC的<code>device node</code>的<code>interrupts</code>属性也是用这三个要素来描述一个具体的中断。</p>
<p>格式如：<code>interrupts = &lt;interruptType interruptNumber triggerType&gt; </code></p>
<table>
<thead>
<tr>
<th><strong>Interrrupt Types</strong></th>
<th><strong>Interrrupt Number</strong></th>
<th><strong>Trigger Type</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0 &#x3D; SPI,  1 &#x3D; PPI</td>
<td>32… …1019</td>
<td>1 &#x3D; low to high, 2 &#x3D; high to low, 4 &#x3D; high level, 8 &#x3D; low level</td>
</tr>
</tbody></table>
<p><code>sample code</code>如下:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/28.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/29.png" alt="img"></p>
<p>打印结果如下：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/30.png" alt="img"></p>
<p> 那么最后dts解析的结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">155</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br><span class="line"></span><br><span class="line">out_irq-&gt;np = interrupt-parent = gic node</span><br><span class="line">out_irq-&gt;args[<span class="number">0</span>] = GIC_SPI;</span><br><span class="line">out_irq-&gt;args[<span class="number">1</span>] = 硬件中断号 = <span class="number">156</span></span><br><span class="line">out_irq-&gt;args[<span class="number">2</span>] = 中断触发类型 = IRQ_TYPE_LEVEL_HIGH</span><br></pre></td></tr></table></figure>

<p><code>platform_get_irq</code>返回一个虚拟中断号，这里对应的是<code>27， 28</code>.</p>
<p><code>devm_request_irq</code>用来申请中断，分配<code>isr中断处理函数</code>。该函数可以在驱动卸载时不用主动调用<code>free_irq</code>显示释放中断请求。</p>
<p>可以看到两次call <code>devm_request_irq</code>却是用的同一个中断服务程序<code>cif_isr</code>，这也是允许的，我们看一下函数原型：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/31.png" alt="image-20240727182250194"></p>
<p><code>devm_request_irq</code>会建立中断号<code>irq_num</code>和中断服务程序<code>isr</code>的绑定，最后一个参数会传给中断服务程序<code>isr</code>.</p>
<p>中断服务程序<code>isr</code>能够根据中断号<code>irq_num</code>和传进的参数进行区分中断源。</p>
<h4><span id="1-6-2-3-gpio">1.6.2.3 GPIO</span><a href="#1-6-2-3-gpio" class="header-anchor">#</a></h4><p><code>of_get_named_gpio_flags</code>获取dts中<code>gpio</code> 编号，并且会找到<code>device_node</code>，找到<code>of_gpio_flags</code>。</p>
<p><code>gpio_request</code>申请<code>gpio</code></p>
<p><code>gpio_direction_output</code>设置成<code>output</code>且<code>set gpio val</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_get_named_gpio_flags</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *list_name,</span></span><br><span class="line"><span class="params">			    <span class="type">int</span> index, <span class="keyword">enum</span> of_gpio_flags *flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">gpio_request</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">const</span> <span class="type">char</span> *label)</span>;		    </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">gpio_direction_output</span><span class="params">(<span class="type">unsigned</span> gpio, <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="comment">//include\asm-generic\gpio.h</span></span><br><span class="line"><span class="comment">//include\linux\gpio.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/32.png" alt="image-20240727183103383"></p>
<p>举个例子：</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/33.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_HIGH 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPIO_ACTIVE_LOW 1</span></span><br><span class="line"><span class="comment">//include\linux\gpio\machine.h</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/34.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/35.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/36.png" alt="img"></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/37.png" alt="img"></p>
<p>这里的<code>gpio 编号=411 = GPIO_D + offset = 404 + 7 =411</code>(也就是dts中配置的<code>portd 7</code>)，这里由于是<code>of_gpio_flags </code>是<code>OF_GPIO_ACTIVE_LOW =0x01</code>，所以<code>snsr_rst_pol = 1</code>.</p>
<h1><span id="2-ping-tai-she-bei-qu-dong-shi-li">2 平台设备驱动示例</span><a href="#2-ping-tai-she-bei-qu-dong-shi-li" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">        <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>①分配&#x2F;设置&#x2F;注册<code>platform_device</code>结构体 在里面定义所用资源，指定设备名字。-<code>Board_A_led.c</code></p>
<p>②分配&#x2F;设置&#x2F;注册 <code>platform_driver </code>结构体 在其中的 probe 函数里，分配&#x2F;设置&#x2F;注册 <code>file_operations </code>结构体， 并从 <code>platform_device </code>中确实所用硬件资源。 指定 <code>platform_driver</code> 的名字。 -<code>Chip_demo_gpio.c</code></p>
<h2><span id="2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia">2.1 通用字符设备驱动框架</span><a href="#2-1-tong-yong-zi-fu-she-bei-qu-dong-kuang-jia" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">                                                               */</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, minor); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span> &#123;</span><br><span class="line">        device_destroy(led_class, MKDEV(major, minor));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span> &#123;</span><br><span class="line">        p_led_opr = opr;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(led_class_create_device);</span><br><span class="line">EXPORT_SYMBOL(led_class_destroy_device);</span><br><span class="line">EXPORT_SYMBOL(register_led_operations);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="type">int</span> minor = iminor(inode);</span><br><span class="line">        err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">        p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="type">int</span> minor = iminor(node);</span><br><span class="line">        <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">        p_led_opr-&gt;init(minor);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">        .owner         = THIS_MODULE,</span><br><span class="line">        .open    = led_drv_open,</span><br><span class="line">        .read    = led_drv_read,</span><br><span class="line">        .write   = led_drv_write,</span><br><span class="line">        .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);</span><br><span class="line">        led_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">        err = PTR_ERR(led_class);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">                printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">                unregister_chrdev(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        class_destroy(led_class);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里只实现一个框架, 具体的opr操作函数需要具体单板去实现。先注册字符设备驱动，确定好class和主设备号。</p>
<p>因为暂时还不知道具体led驱动是啥，因此需要外部去注册具体的led驱动，交给<code>platform_driver</code>去建立。</p>
<p>暂时先不建立设备节点，设备节点交给<code>platform_device</code>去建立，因为暂时不知道设备的led资源信息。</p>
<p><code>EXPORT_SYMBOL</code>导出<code>led_class_create_device</code>，<code>led_class_destroy_device</code>， <code>register_led_operations</code>函数。</p>
<h2><span id="2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts">2.2 具体单板资源描述驱动(platform_device暂不使用dts)</span><a href="#2-2-ju-ti-dan-ban-zi-yuan-miao-shu-qu-dong-platform-device-zan-bu-shi-yong-dts" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_RESOURCE_H</span></span><br><span class="line"><span class="comment">/* GPIO3_0 */</span></span><br><span class="line"><span class="comment">/* bit[31:16] = group */</span></span><br><span class="line"><span class="comment">/* bit[15:0]  = which pin */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP(x) (x&gt;&gt;16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIN(x)   (x&amp;0xFFFF)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GROUP_PIN(g,p) ((g&lt;&lt;16) | (p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>Board_A_led.c</code>这里实现了单板的资源定义，这里是<code>gpio3_1</code>,<code>gpio5_8</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">led_dev_release</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">resources</span>[] =</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">3</span>,<span class="number">1</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">                .start = GROUP_PIN(<span class="number">5</span>,<span class="number">8</span>),</span><br><span class="line">                .flags = IORESOURCE_IRQ,</span><br><span class="line">                .name = <span class="string">&quot;100ask_led_pin&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">board_A_led_dev</span> =</span> &#123;</span><br><span class="line">        .name = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">        .num_resources = ARRAY_SIZE(resources),</span><br><span class="line">        .resource = resources,</span><br><span class="line">        .dev = &#123;</span><br><span class="line">                .release = led_dev_release,</span><br><span class="line">         &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_dev_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_device_register(&amp;board_A_led_dev);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_dev_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_device_unregister(&amp;board_A_led_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(led_dev_init);</span><br><span class="line">module_exit(led_dev_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);　</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>如果<code>platform_device</code>中不提供 <code>release </code>函数，如下图所示不提供红框部分的函数:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/38.png" alt="img"></p>
<p>则在调用 <code>platform_device_unregister</code> 时会出现警告，如下图所示, 因此我们可以将<code>release</code>实现为空。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/39.png" alt="img"></p>
<h2><span id="2-3-ju-ti-xin-pian-qu-dong-platform-driver">2.3 具体芯片驱动(platform_driver)</span><a href="#2-3-ju-ti-xin-pian-qu-dong-platform-driver" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LEDDRV_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LEDDRV_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span> </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_create_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">led_class_destroy_device</span><span class="params">(<span class="type">int</span> minor)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_led_operations</span><span class="params">(<span class="keyword">struct</span> led_operations *opr)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _LEDDRV_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>Chip_demo_gpio.c</code>实现opr的gpio控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leddrv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_resource.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledpins[<span class="number">100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_ledcnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span> <span class="params">(<span class="type">int</span> which)</span> <span class="comment">/* 初始化LED, which-哪个LED */</span>      </span><br><span class="line">&#123;  </span><br><span class="line">    printk(<span class="string">&quot;init gpio: group %d, pin %d\n&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;init pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span> <span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;set led %s: group %d, pin %d\n&quot;</span>, status ? <span class="string">&quot;on&quot;</span> : <span class="string">&quot;off&quot;</span>, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));</span><br><span class="line">    <span class="keyword">switch</span>(GROUP(g_ledpins[which]))&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 0 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 1 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 2 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">            printk(<span class="string">&quot;set pin of group 3 ...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i++);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">        g_ledpins[g_ledcnt] = res-&gt;start;<span class="comment">//获取gpio num</span></span><br><span class="line">        led_class_create_device(g_ledcnt);<span class="comment">//利用EXPORT_SYMBOL导出的函数为每个led创建设备节点</span></span><br><span class="line">        g_ledcnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chip_demo_gpio_remove</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        res = platform_get_resource(pdev, IORESOURCE_IRQ, i);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            <span class="keyword">break</span>;        </span><br><span class="line">        led_class_destroy_device(i);</span><br><span class="line">        i++;</span><br><span class="line">        g_ledcnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">chip_demo_gpio_driver</span> =</span> &#123;</span><br><span class="line">    .probe      = chip_demo_gpio_probe,</span><br><span class="line">    .remove     = chip_demo_gpio_remove,</span><br><span class="line">    .driver     = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;100ask_led&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chip_demo_gpio_drv_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = platform_driver_register(&amp;chip_demo_gpio_driver);</span><br><span class="line">    register_led_operations(&amp;board_demo_led_opr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">lchip_demo_gpio_drv_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    platform_driver_unregister(&amp;chip_demo_gpio_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chip_demo_gpio_drv_init);</span><br><span class="line">module_exit(lchip_demo_gpio_drv_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当<code>platform_device</code>和<code>platform_driver</code>都<code>insmod</code>（注册）后，总线设备驱动模型会进行<code>match</code>匹配，匹配成功调用<code>probe</code>函数，这里使用name进行匹配的。</p>
<ol>
<li><code>chip_demo_gpio_probe</code>中, 获取单板定义的资源信息，依次创建设备节点。</li>
<li><code>register_led_operations</code>注册了具体chip的opr操作函数(寄存器操作不具体展开实现，opr暂定为空)。</li>
</ol>
<p>当用户调用open&#x2F;write时便可操作具体chip的led驱动方法。</p>
<h2><span id="2-4-ce-shi">2.4 测试</span><a href="#2-4-ce-shi" class="header-anchor">#</a></h2><h3><span id="2-4-1-makefile">2.4.1 Makefile</span><a href="#2-4-1-makefile" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span></span><br><span class="line"><span class="comment"># 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span></span><br><span class="line"><span class="comment"># 2.1 ARCH,          比如: export ARCH=arm64</span></span><br><span class="line"><span class="comment"># 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-</span></span><br><span class="line"><span class="comment"># 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin </span></span><br><span class="line"><span class="comment"># 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span></span><br><span class="line"><span class="comment">#       请参考各开发板的高级用户使用手册</span></span><br><span class="line"> </span><br><span class="line">KERN_DIR = /home/book/100ask_roc-rk3399-pc/linux-4.4</span><br><span class="line"> </span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules </span><br><span class="line">        <span class="variable">$(CROSS_COMPILE)</span>gcc -o ledtest ledtest.c </span><br><span class="line"> </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KERN_DIR)</span> M=`pwd` modules clean</span><br><span class="line">        rm -rf modules.order</span><br><span class="line">        rm -f ledtest</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 参考内核源码drivers/char/ipmi/Makefile</span></span><br><span class="line"><span class="comment"># 要想把a.c, b.c编译成ab.ko, 可以这样指定:</span></span><br><span class="line"><span class="comment"># ab-y := a.o b.o</span></span><br><span class="line"><span class="comment"># obj-m += ab.o</span></span><br><span class="line"></span><br><span class="line">obj-m += leddrv.o chip_demo_gpio.o board_A_led.o</span><br></pre></td></tr></table></figure>

<p>编译出3个ko，依次insmod <code>leddrv.ko</code> <code>chip_demo_gpio.ko</code> <code>board_A_led.ko</code></p>
<h3><span id="2-4-2-ledtest-ce-shi-cheng-xu">2.4.2 ledtest测试程序</span><a href="#2-4-2-ledtest-ce-shi-cheng-xu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 on</span></span><br><span class="line"><span class="comment"> * ./ledtest /dev/100ask_led0 off</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        <span class="type">int</span> fd;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;dev&gt; &lt;on | off&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(argv[<span class="number">2</span>], <span class="string">&quot;on&quot;</span>))&#123;</span><br><span class="line">                status = <span class="number">1</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                status = <span class="number">0</span>;</span><br><span class="line">                write(fd, &amp;status, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/40.png" alt="img"></p>
<h2><span id="2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu">2.5 IS_ERR&#x2F;ERR_PTR&#x2F;PTR_ERR&#x2F;NULL_PTR函数族</span><a href="#2-5-is-err-x2f-err-ptr-x2f-ptr-err-x2f-null-ptr-han-shu-zu" class="header-anchor">#</a></h2><p><code>include\linux\err.h</code>:</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/41.png" alt="image-20240727204217358"></p>
<p>内核中的函数常常返回指针，如果出错，也希望能够通过返回的指针体现出来。那么有三种情况：<code>合法指针，NULL指针和非法指针</code>。</p>
<p>1.<code>合法指针</code>：内核函数返回的指针一般是4K对齐，即 ptr &amp; 0xfff &#x3D;&#x3D; 0，也就是0x1000的倍数。其中Linux采用分页机制管理内存，而CPU访问的是线性地址需要通过页表转化成物理地址。所以内核就约定留出最后一页4k（<code>0xfffffffffffff000 ~ 0xffffffffffffffff</code>）用来记录内核空间的错误指针(32位的话就是（<code>0xfffff000 ~ 0xffffffff</code>）).</p>
<p>2.<code>非法指针</code>：一般内核函数地址不会落在<code>（0xfffff000，0xffffffff）</code>之间，而一般内核的出错代码也是一个小负数，在<code>-4095到0</code>之间，转变成<code>unsigned long</code>，正好在<code>（0xfffff000，0xffffffff)</code>之间。因此可以用 <code>(unsigned long)ptr &gt; (unsigned long)-1000L</code></p>
<p><code>-1000L</code>正好是<code>0xfffff000</code>。</p>
<p>3.linux内核中有一个宏<code>MAX_ERRNO = 4095</code>。errno见如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include/<span class="keyword">asm</span>-generic/errno-base.h  <span class="comment">//1-34</span></span><br><span class="line">include\uapi\<span class="keyword">asm</span>-generic\errno.h  <span class="comment">//35-133</span></span><br><span class="line">include\linux\errno.h <span class="comment">//512-530</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-1-is-err">2.5.1 IS_ERR</span><a href="#2-5-1-is-err" class="header-anchor">#</a></h3><p>作用：判断是否无效非法指针。</p>
<p>实现见上面图片，例如一个地址<code>0xfffff,ffaa</code>，那么代入后：很明显返回1,是一个错误非法指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xfffffffaa</span> &gt; <span class="number">0xfffff000</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-2-is-err-or-null">2.5.2 IS_ERR_OR_NULL</span><a href="#2-5-2-is-err-or-null" class="header-anchor">#</a></h3><p>和IS_ERR基本等同，会先提前判断一下是否空。</p>
<h3><span id="2-5-3-ptr-err">2.5.3 PTR_ERR</span><a href="#2-5-3-ptr-err" class="header-anchor">#</a></h3><p>作用：将非法指针转成错误码返回。</p>
<p>实现见上面图片. 将传入的<code>void *</code>类型指针强转为long类型，并返回</p>
<h3><span id="2-5-4-err-ptr">2.5.4 ERR_PTR</span><a href="#2-5-4-err-ptr" class="header-anchor">#</a></h3><p>将传入的long类型强转为<code>void *</code>类型指针，并返回</p>
<h1><span id="3-yin-ru-sysfs">3 引入sysfs</span><a href="#3-yin-ru-sysfs" class="header-anchor">#</a></h1><p>讲到总线设备驱动模型，那不能少了sysfs。<code>sysfs</code>是一种虚拟文件系统，旨在提供一种访问内核数据结构的方法，从而允许用户空间程序查看和控制系统的设备和资源。</p>
<p>例如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/18114131">设备驱动-16-Linux 内核LED子系统 - fuzidage - 博客园 (cnblogs.com)</a> 操作led：</p>
<p><code>echo 1 &gt; /sys/class/leds/red/brightness</code></p>
<p>又例如某个驱动修改设置module_param:</p>
<p><code>echo &quot;8&quot; &gt;/sys/module/my_drv/parameters/lg_lv</code></p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/42.png" alt="image-20240727220331721"></p>
<p> <code>kobject</code> 和 <code>kset</code> 是构成 <code>/sys</code> 目录下的目录节点和文件节点的核心，也是层次化组织总线、设备、驱动的核心数据结构，<code>kobject、kset </code>数据结构都能表示一个目录或者文件节点。在这个目录下面的每一个子目录，其实都是相同类型的kobject集合。然后不同的kset组织成树状层次的结构，就构成了sysfs子系统。</p>
<p><img src="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/43.png" alt="image-20240727220824743"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" data-id="clzp8uttd003a9ouf8z66e5t2" data-title="字符设备驱动-2-总线模型和平台设备驱动" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符设备驱动-1-GPIO驱动LED示例" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-23T16:21:50.000Z" itemprop="datePublished">2024-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/">字符设备驱动-1-GPIO驱动LED示例</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa">1 GPIO 寄存器的 2 种操作方法</a></li>
<li><a href="#2-gpio-ji-cun-qi-pei-zhi-liu-cheng">2 GPIO 寄存器配置流程</a><ul>
<li><a href="#2-1-ccm-shi-zhong-she-zhi">2.1 CCM时钟设置</a></li>
<li><a href="#2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi">2.2 引脚模式电器属性设置</a><ul>
<li><a href="#2-2-1-iomux-gong-neng">2.2.1 IOMUX功能</a></li>
<li><a href="#2-2-2-dian-qi-shu-xing-gong-neng">2.2.2 电器属性功能</a><ul>
<li><a href="#2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi">2.2.2.1 GPIO驱动LED的4种方式</a></li>
</ul>
</li>
<li><a href="#2-2-3-gpio-fang-xiang">2.2.3 GPIO方向</a></li>
<li><a href="#2-2-4-gpio-zhi">2.2.4 GPIO值</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia">3 字符设备驱动程序框架</a><ul>
<li><a href="#3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban">3.1 实现通用性驱动模板</a><ul>
<li><a href="#3-1-1-led-drv-c">3.1.1 <code>led_drv.c</code></a></li>
</ul>
</li>
<li><a href="#3-2-ju-ti-dan-ban-led-qu-dong">3.2 具体单板led驱动</a><ul>
<li><a href="#3-2-1-led-opr-h">3.2.1 <code>led_opr.h</code></a></li>
<li><a href="#3-2-2-board-100ask-imx6ull-qemu-c-fen-xi">3.2.2 <code>board_100ask_imx6ull-qemu.c分析</code></a><ul>
<li><a href="#3-2-2-1-ccm-shi-zhong-pei-zhi">3.2.2.1 CCM时钟配置</a></li>
<li><a href="#3-2-2-2-iomux-cheng-gpio">3.2.2.2 IOMUX成gpio</a><ul>
<li><a href="#3-2-2-2-1-gpio5-3-jin-xing-iomux">3.2.2.2.1 gpio5_3 进行iomux</a></li>
<li><a href="#3-2-2-2-2-gpio1-3-gpio1-5-gpio1-6-jin-xing-iomux">3.2.2.2.2 gpio1_3&#x2F;gpio1_5&#x2F;gpio1_6 进行iomux</a></li>
</ul>
</li>
<li><a href="#3-2-2-3-gpio-pei-cheng-shu-chu">3.2.2.3 gpio配成输出</a></li>
<li><a href="#3-2-2-4-gpio-zhi-she-zhi">3.2.2.4 gpio值设置</a></li>
<li><a href="#3-2-2-5-board-100ask-imx6ull-qemu-c">3.2.2.5 <code>board_100ask_imx6ull-qemu.c</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian">4 字符设备驱动基础概念</a><ul>
<li><a href="#4-1-export-symbol">4.1 EXPORT_SYMBOL</a></li>
<li><a href="#4-2-module-info">4.2 MODULE_INFO</a></li>
<li><a href="#4-2-module-param">4.2 module_param</a><ul>
<li><a href="#4-2-1-type">4.2.1 type</a></li>
<li><a href="#4-2-2-perm">4.2.2 perm</a></li>
</ul>
</li>
<li><a href="#4-3-she-bei-jie-dian">4.3 设备节点</a><ul>
<li><a href="#4-3-1-shou-dong-jian-li-she-bei-jie-dian">4.3.1 手动建立设备节点</a></li>
<li><a href="#4-3-2-zi-dong-chuang-jian-she-bei-jie-dian">4.3.2 自动创建设备节点</a><ul>
<li><a href="#4-3-2-1-mdev-ji-zhi">4.3.2.1 mdev机制</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-she-zhi-wen-jian-si-you-shu-ju">4.4 设置文件私有数据</a></li>
<li><a href="#4-5-she-bei-hao">4.5 设备号</a><ul>
<li><a href="#4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.1 静态分配和释放一个设备号</a></li>
<li><a href="#4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.2 动态分配和释放一个设备号</a></li>
</ul>
</li>
<li><a href="#4-6-tian-jia-she-bei-he-lei">4.6 添加设备和类</a></li>
</ul>
</li>
<li><a href="#5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong">5 内核源码树添加一个字符设备驱动</a><ul>
<li><a href="#5-1-zhun-bei-qu-dong-yuan-ma">5.1 准备驱动源码</a></li>
<li><a href="#5-2-makefile">5.2 MakeFile</a></li>
<li><a href="#5-3-kconfig">5.3 Kconfig</a></li>
<li><a href="#5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig">5.4 修改上一级Makefile和Kconfig</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<p>GPIO: <code>General-purpose input/output</code>，通用输入输出接口。下面以<code>IMX6ULL</code>芯片的GPIO寄存器来展开介绍。</p>
<h1><span id="1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa">1 GPIO 寄存器的 2 种操作方法</span><a href="#1-gpio-ji-cun-qi-de-2-chong-cao-zuo-fang-fa" class="header-anchor">#</a></h1><ol>
<li><strong>直接读写</strong>：读出、修改对应位、写入。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a) 要设置 bit n：</span><br><span class="line">　　val = data_reg;</span><br><span class="line">　　val = val | (<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">　　data_reg = val;</span><br><span class="line">b) 要清除 bit n：</span><br><span class="line">　　val = data_reg;</span><br><span class="line">　　val = val &amp; ~(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">　　data_reg = val;</span><br></pre></td></tr></table></figure></li>
<li><strong>set-and-clear protocol</strong>：(芯片不一定支持）</li>
</ol>
<p>　　<code>set_reg, clr_reg, data_reg </code>三个寄存器对应的是同一个物理寄存器:</p>
<p>　　a) 要设置 bit n：<code>set_reg = (1&lt;&lt;n);</code></p>
<p>　　b) 要清除 bit n：<code>clr_reg = (1&lt;&lt;n);</code></p>
<h1><span id="2-gpio-ji-cun-qi-pei-zhi-liu-cheng">2 GPIO 寄存器配置流程</span><a href="#2-gpio-ji-cun-qi-pei-zhi-liu-cheng" class="header-anchor">#</a></h1><h2><span id="2-1-ccm-shi-zhong-she-zhi">2.1 CCM时钟设置</span><a href="#2-1-ccm-shi-zhong-she-zhi" class="header-anchor">#</a></h2><p>CCM寄存器为GPIO 模块提供时钟：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/1.png" alt="img"></p>
<p>以IMX6ULL 芯片为列，<code>GPIOn </code>要用 <code>CCM_CCGRx</code> 寄存器中的 2 位来决定该组 GPIO 是否使能。将对应的<code>clk gating enable</code>。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/2.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>：该 GPIO 模块全程被关闭</span><br><span class="line"><span class="number">01</span>：该 GPIO 模块在 CPU run mode 情况下是使能的；在 WAIT 或 STOP 模式下，关闭</span><br><span class="line"><span class="number">10</span>：保留</span><br><span class="line"><span class="number">11</span>：该 GPIO 模块全程使能</span><br></pre></td></tr></table></figure>

<p>例如：用<code>CCM_CCGR0[bit31:30]</code>使能GPIO2 的时钟：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/3.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR1[bit31:30]</code>使能GPIO5 的时钟:</p>
<p>例如：用<code>CCM_CCGR1[bit27:26]</code>使能GPIO1 的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/4.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR2[bit27:26]</code>使能GPIO3的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/5.png" alt="img"></p>
<p>例如：用<code>CCM_CCGR3[bit13:12]</code>使能GPIO4的时钟:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/6.png" alt="img"></p>
<h2><span id="2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi">2.2 引脚模式电器属性设置</span><a href="#2-2-yin-jiao-mo-shi-dian-qi-shu-xing-she-zhi" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/7.png" alt="img"></p>
<p><code>MUX seting</code>用来配置pin的模式，比如GPIO。<code>Pad setting</code>用来设置GPIO的电器属性，比如电平，上下拉情况。</p>
<p>对于某个&#x2F;某组引脚，<code>IOMUXC </code>中有 2 个寄存器用来设置它：</p>
<h3><span id="2-2-1-iomux-gong-neng">2.2.1 IOMUX功能</span><a href="#2-2-1-iomux-gong-neng" class="header-anchor">#</a></h3><pre><code> a) `IOMUXC_SW_MUX_CTL_PAD_ &lt;PAD_NAME&gt;`：`Mux pad xxx`，选择某个引脚的功能
</code></pre>
<p> 　b) <code>IOMUXC_SW_MUX_CTL_GRP_&lt;GROUP_NAME&gt;</code>：<code>Mux grp xxx</code>，选择某组引脚的功能</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/8.png" alt="img"></p>
<p>某个引脚，或是某组预设的引脚，都有 8 个可选的模式(<code>alternate (ALT) MUX_MODE</code>)，设成<code>ALT5</code>表示选择GPIO。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/9.png" alt="img"></p>
<h3><span id="2-2-2-dian-qi-shu-xing-gong-neng">2.2.2 电器属性功能</span><a href="#2-2-2-dian-qi-shu-xing-gong-neng" class="header-anchor">#</a></h3><p>a) <code>IOMUXC_SW_PAD_CTL_PAD_&lt;PAD_NAME</code>&gt;：<code>pad pad xxx</code>，设置某个引脚的电器属性</p>
<p>b) <code>IOMUXC_SW_PAD_CTL_GRP_&lt;GROUP_NAME&gt;</code>：<code>pad grp xxx</code>，设 置某组引脚的电器属性</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/10.png" alt="img"></p>
<p>pad参数有很多不只是上下拉，还有很多属性如IO驱动能力。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/11.png" alt="img"></p>
<h4><span id="2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi">2.2.2.1 GPIO驱动LED的4种方式</span><a href="#2-2-2-1-gpio-qu-dong-led-de-4-chong-fang-shi" class="header-anchor">#</a></h4><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/12.png" alt="img"></p>
<p>① 使用引脚输出 3.3V 点亮 LED，输出 0V 熄灭 LED。</p>
<p>② 使用引脚拉低到 0V 点亮 LED，输出 3.3V 熄灭 LED。</p>
<p>③有的芯片为了省电等原因，其引脚驱动能力不足，这时可以使用三极管驱动。 使用引脚输出 1.2V 点亮 LED，输出 0V 熄灭 LED。</p>
<p>④使用引脚输出 0V 点亮 LED，输出 1.2V 熄灭 LED</p>
<h3><span id="2-2-3-gpio-fang-xiang">2.2.3 GPIO方向</span><a href="#2-2-3-gpio-fang-xiang" class="header-anchor">#</a></h3><p>当iomux成gpio模式后，就需要配置成gpio输出。</p>
<p><code>GPIOx_GDIR</code>：设置引脚方向，每位对应一个引脚，<code>1-output</code>，<code>0-input</code>.</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/13.png" alt="img"></p>
<p>确定每组gpio基地址如下：加4就对应方向寄存器。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/14.png" alt="img"></p>
<h3><span id="2-2-4-gpio-zhi">2.2.4 GPIO值</span><a href="#2-2-4-gpio-zhi" class="header-anchor">#</a></h3><p><code>GPIOx_DR</code>：(<code>GPIOx的data register</code>)。设置输出引脚的电平，每位对应一个引脚，1-高电平，0-低电平。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/15.png" alt="img"></p>
<p>如果是配成了输入引脚，<code>GPIOx_PSR</code>：读取引脚的电平，每位对应一个引脚，1-高电平，0-低电平:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/16.png" alt="img"></p>
<h1><span id="3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia">3 字符设备驱动程序框架</span><a href="#3-zi-fu-she-bei-qu-dong-cheng-xu-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/17.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/18.png" alt="img"></p>
<p>字符驱动编写流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 确定主设备号，也可以让内核动态分配.</span></span><br><span class="line"><span class="comment">2. 定义自己的 file_operations 结构体 实现对应的 drv_open/drv_read/drv_write 等函数</span></span><br><span class="line"><span class="comment">填入 file_operations 结构体，把 file_operations 结构体告诉内核。</span></span><br><span class="line"><span class="comment">3. register_chrdev/unregister_chrdev</span></span><br><span class="line"><span class="comment">4. 其他完善：提供设备信息，自动创建设备节点：class_create, device_create</span></span><br><span class="line"><span class="comment">5. 操作硬件：通过 ioremap 映射寄存器的物理地址得到虚拟地址，读写虚拟地址</span></span><br><span class="line"><span class="comment">6. 驱动怎么和 APP 传输数据：通过 copy_to_user、copy_from_user 等操作函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (newchrled.major) &#123; <span class="comment">/* 定义了设备号，静态分配 */</span> </span><br><span class="line">    newchrled.devid = MKDEV(newchrled.major, <span class="number">0</span>); </span><br><span class="line">    register_chrdev_region(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* 没有定义设备号，动态分配 */</span> </span><br><span class="line">    alloc_chrdev_region(&amp;newchrled.devid, <span class="number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME); <span class="comment">/* 申请设备号 */</span> </span><br><span class="line">    newchrled.major = MAJOR(newchrled.devid); <span class="comment">/* 获取主设备号 */</span> </span><br><span class="line">    newchrled.minor = MINOR(newchrled.devid); <span class="comment">/* 获取次设备号 */</span> </span><br><span class="line">&#125; </span><br><span class="line">printk(<span class="string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2、初始化cdev */</span> </span><br><span class="line">newchrled.cdev.owner = THIS_MODULE; </span><br><span class="line">cdev_init(&amp;newchrled.cdev, &amp;newchrled_fops); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3、添加一个cdev */</span> </span><br><span class="line">cdev_add(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4、创建类 */</span> </span><br><span class="line">newchrled.class = class_create(THIS_MODULE, NEWCHRLED_NAME); </span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.class)) </span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newchrled.class); </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5、创建设备 */</span></span><br><span class="line">newchrled.device = device_create(newchrled.class, <span class="literal">NULL</span>, newchrled.devid, <span class="literal">NULL</span>, NEWCHRLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newchrled.device))</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newchrled.device);</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban">3.1 实现通用性驱动模板</span><a href="#3-1-shi-xian-tong-yong-xing-qu-dong-mo-ban" class="header-anchor">#</a></h2><h3><span id="3-1-1-led-drv-c">3.1.1 <code>led_drv.c</code></span><a href="#3-1-1-led-drv-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 确定主设备号 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">led_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> *<span class="title">p_led_opr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a, b) (a &lt; b ? a : b)</span></span><br><span class="line"><span class="comment">/* 实现对应的open/read/write等函数，填入file_operations结构体 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* write(fd, &amp;val, 1); */</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_drv_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">char</span> status;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">        <span class="type">int</span> minor = iminor(inode);</span><br><span class="line"> </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        err = copy_from_user(&amp;status, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 根据次设备号和status控制LED */</span></span><br><span class="line">        p_led_opr-&gt;ctl(minor, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_open</span><span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> minor = iminor(node);</span><br><span class="line">         </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="comment">/* 根据次设备号初始化LED */</span></span><br><span class="line">        p_led_opr-&gt;init(minor);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 定义自己的file_operations结构体  */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_drv</span> =</span> &#123;</span><br><span class="line">        .owner         = THIS_MODULE,</span><br><span class="line">        .open    = led_drv_open,</span><br><span class="line">        .read    = led_drv_read,</span><br><span class="line">        .write   = led_drv_write,</span><br><span class="line">        .release = led_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 把file_operations结构体告诉内核：注册驱动程序  */</span></span><br><span class="line"><span class="comment">/* 入口函数：安装驱动程序时，就会去调用这个入口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">         </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        major = register_chrdev(<span class="number">0</span>, <span class="string">&quot;100ask_led&quot;</span>, &amp;led_drv);</span><br><span class="line">        led_class = class_create(THIS_MODULE, <span class="string">&quot;100ask_led_class&quot;</span>);</span><br><span class="line">        err = PTR_ERR(led_class);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(led_class)) &#123;</span><br><span class="line">                printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">                unregister_chrdev(major, <span class="string">&quot;led&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p_led_opr = get_board_led_opr();</span><br><span class="line">        <span class="comment">/* creat device node, eg: /dev/100ask_led0,1,... */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">                device_create(led_class, <span class="literal">NULL</span>, MKDEV(major, i), <span class="literal">NULL</span>, <span class="string">&quot;100ask_led%d&quot;</span>, i); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p_led_opr-&gt;num; i++)</span><br><span class="line">                device_destroy(led_class, MKDEV(major, i)); <span class="comment">/* /dev/100ask_led0,1,... */</span></span><br><span class="line">        class_destroy(led_class);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;100ask_led&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li><code>register_chrdev</code>， 如果传入主设备号，则静态注册，传入0则动态注册返回主设备号。</li>
<li><code>class_create</code>创建类<code>/sys/class/100ask_led_class</code>。</li>
<li><code>get_board_led_opr</code>获取具体单板的操作operation函数,后面具体单板实现。</li>
<li>获取到具体单板的led数量后，<code>device_create</code>为每一个led灯都建立设备节点。</li>
</ol>
<p>再来看<code>file_operations中</code>的操作：</p>
<ol>
<li><code>led_drv_open</code>根据次设备号，调用具体单板的<code>init</code>函数，比如gpio 引脚复用，电器属性设置等。</li>
<li><code>led_drv_write</code>就可以根据次设备号, 控制具体单板的led引脚，设置高低电平，从而控制亮灭。</li>
</ol>
<h2><span id="3-2-ju-ti-dan-ban-led-qu-dong">3.2 具体单板led驱动</span><a href="#3-2-ju-ti-dan-ban-led-qu-dong" class="header-anchor">#</a></h2><h3><span id="3-2-1-led-opr-h">3.2.1 <code>led_opr.h</code></span><a href="#3-2-1-led-opr-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _LED_OPR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _LED_OPR_H</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">int</span> (*init) (<span class="type">int</span> which); <span class="comment">/* 初始化LED, which-哪个LED */</span>       </span><br><span class="line">        <span class="type">int</span> (*ctl) (<span class="type">int</span> which, <span class="type">char</span> status); <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>定义一个<code>led_operations</code>，<code>num</code>表示有几个led, <code> init</code>表示初始化led(<code>drv_open</code>的时候调用，配置<code>pinmux</code>，<code>io mode</code>, <code>enable pin clk</code>等)。</p>
<h3><span id="3-2-2-board-100ask-imx6ull-qemu-c-fen-xi">3.2.2 <code>board_100ask_imx6ull-qemu.c分析</code></span><a href="#3-2-2-board-100ask-imx6ull-qemu-c-fen-xi" class="header-anchor">#</a></h3><p>现在有一块<code>board_100ask_imx6ull-qemu</code>板子有4个LED，占2组GPIO，分别是<code>GPIO5_3</code>和<code>GPIO1_3, GPIO1_5, GPIO1_6</code>。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/19.png" alt="img"></p>
<h4><span id="3-2-2-1-ccm-shi-zhong-pei-zhi">3.2.2.1 CCM时钟配置</span><a href="#3-2-2-1-ccm-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p>寄存器配置参考2.1。使能时钟gpio5和gpio1的时钟，<code>CCM_CCGR1[CG13]</code>和<code>CCM_CCGR1[CG15]</code>配置成0x11。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. enable GPIO1</span></span><br><span class="line"><span class="comment"> * CG13, b[27:26] = 0b11 */</span></span><br><span class="line"> </span><br><span class="line">*CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">       </span><br><span class="line"><span class="comment">/* 1. enable GPIO5</span></span><br><span class="line"><span class="comment"> * CG15, b[31:30] = 0b11 */</span></span><br><span class="line"> *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-2-iomux-cheng-gpio">3.2.2.2 IOMUX成gpio</span><a href="#3-2-2-2-iomux-cheng-gpio" class="header-anchor">#</a></h4><p>iomux配置4个引脚复用成gpio功能。</p>
<h5><span id="3-2-2-2-1-gpio5-3-jin-xing-iomux">3.2.2.2.1 gpio5_3 进行iomux</span><a href="#3-2-2-2-1-gpio5-3-jin-xing-iomux" class="header-anchor">#</a></h5><p>基地址为<code>0x2290014</code>。用ioremap进行映射到虚拟地址，就可以直接操作寄存器地址了。但是一般建议用<code>writel, writeb</code>等函数族。配成5表示gpio模式。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/20.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3=ioremap(<span class="number">0x2290014</span>, <span class="number">4</span>);        </span><br><span class="line"><span class="comment">/* 2. set GPIO5_IO03 as GPIO</span></span><br><span class="line"><span class="comment"> * MUX_MODE, b[3:0] = 0b101 */</span></span><br><span class="line"></span><br><span class="line">*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-2-2-2-2-gpio1-3-x2f-gpio1-5-x2f-gpio1-6-jin-xing-iomux">3.2.2.2.2 gpio1_3&#x2F;gpio1_5&#x2F;gpio1_6 进行iomux</span><a href="#3-2-2-2-2-gpio1-3-x2f-gpio1-5-x2f-gpio1-6-jin-xing-iomux" class="header-anchor">#</a></h5><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/21.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/22.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/23.png" alt="img"></p>
<p>每次映射4个字节太繁琐，干脆对整个gpio的iomux地址进行映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> unnames[<span class="number">23</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00;  <span class="comment">/* offset 0x5c*/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iomux = ioremap(<span class="number">0x20e0000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iomux));</span><br></pre></td></tr></table></figure>

<p>这里偷懒用了一个技巧，<code>unnames[23] </code>占<code>92(0x5c)</code>字节,刚好<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00</code>地址就是<code>0x20e0000+0x5c</code>，就不用把所有寄存器都搬进来到<code>struct iomux</code>。</p>
<p>同理<code>IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</code>地址就是<code>0x20e0000+0x68</code>, 因此：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* MUX_MODE, b[3:0] = 0b101 */</span></span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 = <span class="number">5</span>;</span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05 = <span class="number">5</span>;</span><br><span class="line">iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06 = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-3-gpio-pei-cheng-shu-chu">3.2.2.3 gpio配成输出</span><a href="#3-2-2-3-gpio-pei-cheng-shu-chu" class="header-anchor">#</a></h4><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/24.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* GPIO1 GDIR, b[5] = 0b1*/</span></span><br><span class="line"> gpio1 = ioremap(<span class="number">0x209C000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line"> gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>offset为0表示data register, offset为4表示方向寄存器。以<code>gpio1_3/gpio1_5/gpio1_6</code>举例，<code>gdir</code>的<code>bit_n</code>置1就表示哪个gpio配成输出。</p>
<h4><span id="3-2-2-4-gpio-zhi-she-zhi">3.2.2.4 gpio值设置</span><a href="#3-2-2-4-gpio-zhi-she-zhi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio5-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio5-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (status)  <span class="comment">/* on : output 0 */</span></span><br><span class="line">        gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span>         <span class="comment">/* on : output 1 */</span></span><br><span class="line">        gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理<code>dr</code>就表示数据寄存器。一共4个led：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">which等于0表示gpio5_3</span><br><span class="line">which等于1示gpio1_3</span><br><span class="line">which等于2示gpio1_5</span><br><span class="line">which等于3示gpio1_6</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-2-5-board-100ask-imx6ull-qemu-c">3.2.2.5 <code>board_100ask_imx6ull-qemu.c</code></span><a href="#3-2-2-5-board-100ask-imx6ull-qemu-c" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_opr.h&quot;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> unnames[<span class="number">23</span>];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00;  <span class="comment">/* offset 0x5c*/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> dr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> gdir;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> psr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> icr2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> imr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> isr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> edge_sel;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* enable GPIO1,GPIO5 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *CCM_CCGR1;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">iomux</span> *<span class="title">iomux</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio1</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx6ull_gpio</span> *<span class="title">gpio5</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">led_operations</span> <span class="title">board_demo_led_opr</span> =</span> &#123;</span><br><span class="line">    .num  = <span class="number">4</span>,</span><br><span class="line">    .init = board_demo_led_init,</span><br><span class="line">    .ctl  = board_demo_led_ctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_init</span><span class="params">(<span class="type">int</span> which)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!CCM_CCGR1) &#123;</span><br><span class="line">        CCM_CCGR1 = ioremap(<span class="number">0x20C406C</span>, <span class="number">4</span>);</span><br><span class="line">        IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(<span class="number">0x2290014</span>, <span class="number">4</span>);</span><br><span class="line">        iomux = ioremap(<span class="number">0x20e0000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iomux));</span><br><span class="line">        gpio1 = ioremap(<span class="number">0x209C000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">        gpio5 = ioremap(<span class="number">0x20AC000</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> imx6ull_gpio));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">        *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = <span class="number">5</span>;</span><br><span class="line">        gpio5-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">1</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">2</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(which == <span class="number">3</span>) &#123;</span><br><span class="line">        *CCM_CCGR1 |= (<span class="number">3</span>&lt;&lt;<span class="number">26</span>);</span><br><span class="line">        iomux-&gt;IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06 = <span class="number">5</span>;</span><br><span class="line">        gpio1-&gt;gdir |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">board_demo_led_ctl</span><span class="params">(<span class="type">int</span> which, <span class="type">char</span> status)</span> <span class="comment">/* 控制LED, which-哪个LED, status:1-亮,0-灭 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (which == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio5-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio5-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status)</span><br><span class="line">            gpio1-&gt;dr &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            gpio1-&gt;dr |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> led_operations *<span class="title function_">get_board_led_opr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;board_demo_led_opr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>open的时候调用<code>get_board_led_opr</code>得到具体单板的操作函数集。进一步调用<code>board_demo_led_init</code>初始化led。</p>
<p>write的时候调用具体单板的操作函数集，进一步调用<code>board_demo_led_ctl</code>操控led。</p>
<h1><span id="4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian">4 字符设备驱动基础概念</span><a href="#4-zi-fu-she-bei-qu-dong-ji-chu-gai-nian" class="header-anchor">#</a></h1><h2><span id="4-1-export-symbol">4.1 EXPORT_SYMBOL</span><a href="#4-1-export-symbol" class="header-anchor">#</a></h2><p><code>EXPORT_SYMBOL</code>:导出函数，让别的module也能使用。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/25.png" alt="image-20240725202519779"></p>
<p><code>EXPORT_SYMBOL_GPL</code>:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/26.png" alt="image-20240725211903017"></p>
<h2><span id="4-2-module-info">4.2 MODULE_INFO</span><a href="#4-2-module-info" class="header-anchor">#</a></h2><p><code>MODULE_INFO(intree, &quot;Y&quot;);</code>的作用是将可加载内核模块标记为<code> in-tree</code>。</p>
<p>加载树外 LKM 会导致内核打印警告:这是从<code>module.c</code>中的检查引起的:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/27.png" alt="img"></p>
<p><code>module: loading out-of-tree module taints kernel.</code></p>
<h2><span id="4-2-module-param">4.2 module_param</span><a href="#4-2-module-param" class="header-anchor">#</a></h2><p><code>module_param(name,type,perm);</code></p>
<p>功能：指定模块参数，用于在加载模块时或者模块加载以后传递参数给模块。</p>
<p><code>module_param_array( name, type, nump, perm);</code></p>
<p>可用sysfs进行查看修改：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/28.png" alt="img"></p>
<p>讲到<code>module_param</code>,把其他的也一笔带入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Freescale PM rpmsg driver&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Anson Huang &lt;Anson.Huang@nxp.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;v2.0&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-1-type">4.2.1 type</span><a href="#4-2-1-type" class="header-anchor">#</a></h3><p>type: 数据类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool : 布尔型</span><br><span class="line">   inbool : 布尔反值</span><br><span class="line">   charp: 字符指针（相当于char *,不超过1024字节的字符串）</span><br><span class="line">   short: 短整型</span><br><span class="line">   ushort : 无符号短整型</span><br><span class="line">   int : 整型</span><br><span class="line">   uint : 无符号整型</span><br><span class="line">   long : 长整型</span><br><span class="line">   ulong: 无符号长整型</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-2-perm">4.2.2 perm</span><a href="#4-2-2-perm" class="header-anchor">#</a></h3><p>perm表示此参数在sysfs文件系统中所对应的文件节点的属性，其权限在<code>include/linux/stat.h</code>中有定义:</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/29.png" alt="image-20240725205237500"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRUSR 00400 <span class="comment">//文件所有者可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWUSR 00200 <span class="comment">//文件所有者可写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXUSR 00100 <span class="comment">//文件所有者可执行</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IRGRP 00040 <span class="comment">//与文件所有者同组的用户可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWGRP 00020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXGRP 00010</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IROTH 00004 <span class="comment">//与文件所有者不同组的用户可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IWOTH 00002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S_IXOTH 00001</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/30.png" alt="image-20240725205907528"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *alg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> u32 type;</span><br><span class="line"><span class="type">static</span> u32 mask;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mode;</span><br><span class="line"></span><br><span class="line">module_param(alg, charp, <span class="number">0</span>);</span><br><span class="line">module_param(type, uint, <span class="number">0</span>);</span><br><span class="line">module_param(mask, uint, <span class="number">0</span>);</span><br><span class="line">module_param(mode, <span class="type">int</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> fish[<span class="number">10</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_fish;</span><br><span class="line">module_param_array(fish, <span class="type">int</span>, &amp;nr_fish, <span class="number">0664</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> media[<span class="number">8</span>];</span><br><span class="line">module_param_string(media, media, <span class="keyword">sizeof</span>(media), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>可以用sysfs设置<code>fish</code>数组，或者insmod时伴随设置。</p>
<h2><span id="4-3-she-bei-jie-dian">4.3 设备节点</span><a href="#4-3-she-bei-jie-dian" class="header-anchor">#</a></h2><p><code>cat /proc/devices</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/31.png" alt="img"></p>
<h3><span id="4-3-1-shou-dong-jian-li-she-bei-jie-dian">4.3.1 手动建立设备节点</span><a href="#4-3-1-shou-dong-jian-li-she-bei-jie-dian" class="header-anchor">#</a></h3><p>手动建立设备节点命令是<code>mknod</code>, 由于这里的字符设备都是用的misc杂项设备方式，因此主设备号都为10：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/mnt/Athena2_FPGA_SDK_Veriry/demo/workspace/ko <span class="comment"># ls -l /dev/mmcblk0p1</span></span><br><span class="line">brw-rw----    1 root     root      179,   1 Jan  1 00:05 /dev/mmcblk0p1</span><br><span class="line">/mnt/Athena2_FPGA_SDK_Veriry/demo/workspace/ko <span class="comment"># ls -l /dev/mmcblk0</span></span><br><span class="line">brw-rw----    1 root     root      179,   0 Jan  1 00:05 /dev/mmcblk0</span><br><span class="line"></span><br><span class="line">/dev <span class="comment"># ls -l cvi-*</span></span><br><span class="line">crw-rw----    1 root     root       10,   0 Jan  1 00:05 /dev/cvi-base</span><br><span class="line">crw-rw----    1 root     root       10,  61 Jan  1 00:05 /dev/cvi-dwa</span><br><span class="line">crw-rw----    1 root     root       10,  58 Jan  1 00:30 /dev/cvi-ldc</span><br><span class="line">crw-rw----    1 root     root       10,  60 Jan  1 00:04 /dev/cvi-stitch</span><br><span class="line">crw-rw----    1 root     root       10,  62 Jan  1 00:05 /dev/cvi-sys</span><br><span class="line">crw-rw----    1 root     root       10,  59 Jan  1 00:04 /dev/cvi-vpss</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/mmcblk0 b 179 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/mmcblk0p1 b 179 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-base c 10 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-sys c 10 62</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-dwa c 10 61</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-ldc c 10 58</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-stitch c 10 60</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-vpss c 10 59</span><br><span class="line">crw-rw---- 1 root root 10, 0 Jan 1 00:08 /dev/cvi-base</span><br><span class="line">crw-rw---- 1 root root 10, 61 Jan 1 00:08 /dev/cvi-dwa</span><br><span class="line">crw-rw---- 1 root root 10, 59 Jan 1 00:07 /dev/cvi-ldc</span><br><span class="line">crw-rw---- 1 root root 10, 60 Jan 1 00:07 /dev/cvi-stitch</span><br><span class="line">crw-rw---- 1 root root 10, 62 Jan 1 00:08 /dev/cvi-sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-base c 10 0</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-sys c 10 62</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-dwa c 10 61</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-ldc c 10 59</span><br><span class="line"><span class="built_in">mknod</span> /dev/cvi-stitch c 10 60</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-2-zi-dong-chuang-jian-she-bei-jie-dian">4.3.2 自动创建设备节点</span><a href="#4-3-2-zi-dong-chuang-jian-she-bei-jie-dian" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-mdev-ji-zhi">4.3.2.1 mdev机制</span><a href="#4-3-2-1-mdev-ji-zhi" class="header-anchor">#</a></h4><p><code>udev</code>是一个用户程序，在 Linux下通过 <code>udev</code>来实现设备文件的创建与删除， <code>udev</code>可以检测系统中硬件设备状态，可以根据系统中硬件设备状态来创建或者删除设备文件。比如使用<code>modprobe</code>命令成功加载驱动模块以后就自动在<code> /dev目录</code>下创建对应的设备节点文件 ,使用<code>rmmod</code>命令卸载驱动模块以后就 删除掉<code> /dev目录</code>下的设备节点文件。 使用<code> busybox</code>构建根文件系统的时候， busybox会创建一个 <code>udev</code>的简化版本<code> mdev</code>，所以在嵌入式 Linux中我们使用<code>mdev</code>来实现设备节点文件的自动创建与删除， Linux系统中的热插拔事件也由 <code>mdev</code>管理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br></pre></td></tr></table></figure>

<h2><span id="4-4-she-zhi-wen-jian-si-you-shu-ju">4.4 设置文件私有数据</span><a href="#4-4-she-zhi-wen-jian-si-you-shu-ju" class="header-anchor">#</a></h2><p>一般<code>open</code>函数里面设置好私有数据以后，在<code> write、 read、 close</code>等函数中直接读取<code> private_data</code>即可得到设备结构体。</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/32.png" alt="img"></p>
<h2><span id="4-5-she-bei-hao">4.5 设备号</span><a href="#4-5-she-bei-hao" class="header-anchor">#</a></h2><p><code>include\linux\kdev_t.h</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/33.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MINORBITS 表示次设备号位数，一共是 20 位;</span><br><span class="line">MINORMASK 表示次设备号掩码;</span><br><span class="line">MAJOR 用于从 dev_t 中获取主设备号，将 dev_t 右移 20 位即可</span><br><span class="line">MINOR 用于从 dev_t 中获取次设备号，取 dev_t 的低 20 位的值即可</span><br><span class="line">MKDEV 用于将给定的主设备号和次设备号的值组合成 dev_t 类型的设备号</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/34.png" alt="img"></p>
<p>定义了major主设备就用静态注册，否则动态分配设备号注册字符设备。</p>
<h3><span id="4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.1 静态分配和释放一个设备号</span><a href="#4-5-1-jing-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line">register_chrdev_region()</span><br><span class="line">unregister_chrdev_region()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_MAJOR_NUM 202 <span class="comment">//主设备号</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">my_dev_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = my_dev_open,</span><br><span class="line">    .release = my_dev_close,</span><br><span class="line">    .unlocked_ioctl = my_dev_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> dev = MKDEV(MY_MAJOR_NUM, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Allocate device numbers */</span></span><br><span class="line">    ret = register_chrdev_region(dev, <span class="number">1</span>, <span class="string">&quot;my_char_device&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to allocate mayor number %d\n&quot;</span>, MY_MAJOR_NUM);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Initialize the cdev structure and add it to the kernel space */</span></span><br><span class="line">    cdev_init(&amp;my_dev, &amp;my_dev_fops);</span><br><span class="line">    ret= cdev_add(&amp;my_dev, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    cdev_del(&amp;my_dev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(MY_MAJOR_NUM, <span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao">4.5.2 动态分配和释放一个设备号</span><a href="#4-5-2-dong-tai-fen-pei-he-shi-fang-yi-ge-she-bei-hao" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/fs.h&gt;</span><br><span class="line">alloc_chrdev_region()</span><br><span class="line">unregister_chrdev_region()</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span>*  <span class="title">helloClass</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">my_dev</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">dev_t</span> dev_no;</span><br><span class="line">    <span class="type">int</span> Major;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span>* <span class="title">helloDevice</span>;</span></span><br><span class="line">    ret = alloc_chrdev_region(&amp;dev_no, <span class="number">0</span>, <span class="number">1</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to allocate Mayor number \n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    Major = MAJOR(dev_no);</span><br><span class="line">    dev = MKDEV(Major,<span class="number">0</span>);</span><br><span class="line">    cdev_init(&amp;my_dev, &amp;my_dev_fops);</span><br><span class="line">    ret = cdev_add(&amp;my_dev, dev, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Unable to add cdev\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    helloClass = class_create(THIS_MODULE, CLASS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(helloClass))&#123;</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        cdev_del(&amp;my_dev);</span><br><span class="line">        pr_info(<span class="string">&quot;Failed to register device class\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(helloClass);</span><br><span class="line">    &#125;</span><br><span class="line">    helloDevice = device_create(helloClass, <span class="literal">NULL</span>, dev, <span class="literal">NULL</span>, DEVICE_NAME);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(helloDevice))&#123;</span><br><span class="line">        class_destroy(helloClass);</span><br><span class="line">        cdev_del(&amp;my_dev);</span><br><span class="line">        unregister_chrdev_region(dev, <span class="number">1</span>);</span><br><span class="line">        pr_info(<span class="string">&quot;Failed to create the device\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(helloDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    device_destroy(helloClass, dev);     <span class="comment">/* remove the device */</span></span><br><span class="line">    class_destroy(helloClass);           <span class="comment">/* remove the device class */</span></span><br><span class="line">    cdev_del(&amp;my_dev);</span><br><span class="line">    unregister_chrdev_region(dev, <span class="number">1</span>);    <span class="comment">/* unregister the device numbers */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-6-tian-jia-she-bei-he-lei">4.6 添加设备和类</span><a href="#4-6-tian-jia-she-bei-he-lei" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct class *class; /* 类 */ </span><br><span class="line">struct device *device; /* 设备 */ </span><br><span class="line">dev_t devid; /* 设备号 */</span><br><span class="line">static int __init led_init(void) &#123; </span><br><span class="line">    class = class_create(THIS_MODULE, &quot;xxx&quot;); </span><br><span class="line">    device = device_create(class, NULL, devid, NULL, &quot;xxx&quot;); </span><br><span class="line">    return 0; </span><br><span class="line">&#125; </span><br><span class="line">static void __exit led_exit(void) &#123; </span><br><span class="line">	device_destroy(newchrled.class, newchrled.devid); </span><br><span class="line">    class_destroy(newchrled.class); </span><br><span class="line">&#125; </span><br><span class="line">module_init(led_init); </span><br><span class="line">module_exit(led_exit);</span><br></pre></td></tr></table></figure>

<h1><span id="5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong">5 内核源码树添加一个字符设备驱动</span><a href="#5-nei-he-yuan-ma-shu-tian-jia-yi-ge-zi-fu-she-bei-qu-dong" class="header-anchor">#</a></h1><h2><span id="5-1-zhun-bei-qu-dong-yuan-ma">5.1 准备驱动源码</span><a href="#5-1-zhun-bei-qu-dong-yuan-ma" class="header-anchor">#</a></h2><p>这里以<code>misc device</code>为例， 进入<code>drivers/misc目录</code>，新建目录<code>hello_drv</code>。放入<code>驱动源码</code>和<code>Makefile</code>和<code>Kconfig</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/miscdevice.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/proc_fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seq_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/tty.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kmod.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gfp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> major = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">hello_cdev</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> kernel_buf[<span class="number">1024</span>];</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_read</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = copy_to_user(buf, kernel_buf, min(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> min(<span class="number">1024</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">hello_drv_write</span> <span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> size, <span class="type">loff_t</span> *offset)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    err = copy_from_user(kernel_buf, buf, min(<span class="number">1024</span>, size));</span><br><span class="line">    <span class="keyword">return</span> min(<span class="number">1024</span>, size);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_open</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_drv_close</span> <span class="params">(<span class="keyword">struct</span> inode *node, <span class="keyword">struct</span> file *file)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">    .owner     = THIS_MODULE,</span><br><span class="line">    .open    = hello_drv_open,</span><br><span class="line">    .read    = hello_drv_read,</span><br><span class="line">    .write   = hello_drv_write,</span><br><span class="line">    .release = hello_drv_close,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> rc;</span><br><span class="line">    <span class="type">dev_t</span> devid;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//major = register_chrdev(0, &quot;hello&quot;, &amp;hello_drv);  /* /dev/hello */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    rc = alloc_chrdev_region(&amp;devid, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    major = MAJOR(devid);</span><br><span class="line">    cdev_init(&amp;hello_cdev, &amp;hello_drv);</span><br><span class="line">    cdev_add(&amp;hello_cdev, devid, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    hello_class = class_create(THIS_MODULE, <span class="string">&quot;hello_class&quot;</span>);</span><br><span class="line">    err = PTR_ERR(hello_class);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(hello_class)) &#123;</span><br><span class="line">        printk(<span class="string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="line">        unregister_chrdev(major, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    device_create(hello_class, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">&quot;hello&quot;</span>); <span class="comment">/* /dev/hello */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    device_destroy(hello_class, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(hello_class);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">//unregister_chrdev(major, &quot;hello&quot;);</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    cdev_del(&amp;hello_cdev);</span><br><span class="line">    unregister_chrdev_region(MKDEV(major,<span class="number">0</span>), <span class="number">1</span>);   </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-makefile">5.2 MakeFile</span><a href="#5-2-makefile" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/35.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userprogs-always-y += hello_test</span><br><span class="line">userccflags += -I usr/include</span><br></pre></td></tr></table></figure>

<p>这里表示用userspace方式去编译应用程序，hello_test就是用户程序。</p>
<p>假如我们多个文件<code>hello1.c hello2.c</code>, 如何得到<code>hello.o</code>和<code>hello.ko</code>呢？如下参考：</p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/36.png" alt="image-20240725223651990"></p>
<h2><span id="5-3-kconfig">5.3 Kconfig</span><a href="#5-3-kconfig" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/37.png" alt="img"></p>
<h2><span id="5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig">5.4 修改上一级Makefile和Kconfig</span><a href="#5-4-xiu-gai-shang-yi-ji-makefile-he-kconfig" class="header-anchor">#</a></h2><p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/38.png" alt="img"></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/39.png" alt="img"></p>
<p>让<code>hello_drv</code>目录中的<code>Kconfig</code>也能被内核识别，输入<code>make menuconfig</code>，即可选择将其编译成内核模块还是直接编译进内核镜像，默认<code>default n</code>,也就是<code>CONFIG_HELLO</code>等于n, <code>hello_drv</code>目录是<code>obj-n</code>, 不编译；选择y则表示编译进内核镜像，选择m表示编译成内核模块。</p>
<p> 编译成内核模块，则会在<code>.config</code>中产生<code>CONFIG_HELLO=m</code>的一项配置，编译产生<code>hello.ko</code></p>
<p><img src="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/40.png" alt="img"></p>
<p>编译成内核镜像，则会在<code>.config</code>中产生<code>CONFIG_HELLO=y</code>的一项配置，编译产生<code>built-in.a</code>,最终该 <code>built-in.a</code>会合入vmlinux。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/" data-id="clzp8uttc00389oufba2n63kn" data-title="字符设备驱动-1-GPIO驱动LED示例" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-buildroot教程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-23T15:36:29.000Z" itemprop="datePublished">2024-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/">buildroot教程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-buildroot">1 引入buildroot</a><ul>
<li><a href="#1-1-xia-zai-buildroot">1.1 下载buildroot</a></li>
<li><a href="#1-2-buildroot-mu-lu-jie-gou">1.2 buildroot目录结构</a><ul>
<li><a href="#1-2-0-buildroot-yuan-mu-lu">1.2.0 buildroot源目录</a></li>
<li><a href="#1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao">1.2.1 编译出的output输出目录介绍</a></li>
</ul>
</li>
<li><a href="#1-3-pei-zhi-target-options">1.3 配置 Target options</a></li>
<li><a href="#1-4-pei-zhi-gong-ju-lian">1.4 配置工具链</a><ul>
<li><a href="#1-4-1-nei-bu-gong-ju-lian">1.4.1 内部工具链</a></li>
<li><a href="#1-4-2-wai-bu-gong-ju-lian">1.4.2 外部工具链</a></li>
</ul>
</li>
<li><a href="#1-5-pei-zhi-build-options">1.5 配置 build options</a></li>
<li><a href="#1-6-pei-zhi-system-configuration">1.6 配置 System configuration</a></li>
<li><a href="#1-7-pei-zhi-filesystem-images">1.7 配置 Filesystem images</a></li>
<li><a href="#1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot">1.8 禁止编译 Linux 内核和 uboot</a></li>
<li><a href="#1-9-pei-zhi-target-packages">1.9 配置 Target packages</a></li>
</ul>
</li>
<li><a href="#2-bian-yi-buildroot">2 编译buildroot</a><ul>
<li><a href="#2-1-make-help">2.1 make help</a></li>
<li><a href="#2-2-make-print-version">2.2 make print-version</a></li>
<li><a href="#2-3-make-menuconfig">2.3 make menuconfig</a></li>
<li><a href="#2-4-make-xxxx-defconfig">2.4 make xxxx_defconfig</a></li>
<li><a href="#2-5-make">2.5 make</a><ul>
<li><a href="#2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong">2.5.1 nfs 挂载根文件系统</a></li>
</ul>
</li>
<li><a href="#2-6-make-show-targets">2.6 make show-targets</a></li>
</ul>
</li>
<li><a href="#3-buildroot-kuang-jia-yuan-li">3 buildroot框架原理</a><ul>
<li><a href="#3-1-tian-jia-zi-ji-de-ruan-jian-bao">3.1 添加自己的软件包</a><ul>
<li><a href="#3-1-1-package-config-in-zong-ru-kou-tian-jia-cai-dan">3.1.1 package&#x2F;Config.in总入口添加菜单</a></li>
<li><a href="#3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian">3.1.2 配置APP对应的Config.in和mk文件</a><ul>
<li><a href="#3-1-2-1-config-in">3.1.2.1 Config.in</a></li>
<li><a href="#3-1-2-2-helloworld-mk">3.1.2.2 helloworld.mk</a></li>
</ul>
</li>
<li><a href="#3-1-3-bian-xie-app-yuan-ma-he-makefile">3.1.3 编写APP源码和Makefile</a></li>
<li><a href="#3-1-4-tong-guo-make-menuconfig-xuan-zhong-app">3.1.4 通过make menuconfig选中APP</a></li>
<li><a href="#3-1-5-bian-yi-shi-yong-app">3.1.5 编译使用APP</a></li>
</ul>
</li>
<li><a href="#3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao">3.2 如何重新编译软件包</a></li>
<li><a href="#3-3-shi-neng-di-san-fang-ruan-jian-he-ku">3.3 使能第三方软件和库</a><ul>
<li><a href="#3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian">3.3.1 使能音频的ALSA库套件</a></li>
<li><a href="#3-3-2-shi-neng-busybox-tao-jian">3.3.2 使能busybox套件</a><ul>
<li><a href="#3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian">3.3.2.1 修改配置busybox套件</a></li>
<li><a href="#3-3-2-2-rebuild-busybox-tao-jian">3.3.2.2 rebuild busybox套件</a></li>
</ul>
</li>
<li><a href="#3-3-3-ps1-huan-jing-bian-liang">3.3.3 PS1环境变量</a></li>
</ul>
</li>
<li><a href="#3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree">3.4 单独生成目标（build out of tree）</a></li>
</ul>
</li>
<li><a href="#4-buildroot-guan-fang-jiao-cheng-lian-jie">4 buildroot官方教程链接</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-buildroot">1 引入buildroot</span><a href="#1-yin-ru-buildroot" class="header-anchor">#</a></h1><p>Buildroot是Linux平台上一个开源的嵌入式Linux系统<strong>自动构建框架</strong>。用来制作根文件系统，我们还要自己去移植一些第三方软件和库，比如 <code>alsa</code>、<code>iperf</code>、<code>mplayer</code> 等等。</p>
<p>那么有没有一种傻瓜式的方法或软件，它不仅包含了 <code>busybox</code> 的功能，而且里面还集成了各种软件，需要什么软件就选择什么软件，不需要我们去移植。答案肯定是有的，<code>buildroot </code>就是这样一种工具。</p>
<h2><span id="1-1-xia-zai-buildroot">1.1 下载buildroot</span><a href="#1-1-xia-zai-buildroot" class="header-anchor">#</a></h2><p>Buildroot版本每2个月，2月，5月，8月和11月发布一次。版本号的格式为YYYY.MM，例如2013.02、2014.08。</p>
<p>可以从<a target="_blank" rel="noopener" href="http://buildroot.org/downloads/">http://buildroot.org/downloads/</a>获得发行包。</p>
<p>也可通过<code>github</code>仓库获取最新版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.busybox.net/buildroot</span><br></pre></td></tr></table></figure>

<p><code>buildroot</code> 和<code> uboot</code>、<code>Linux kernel </code>一样也支持图形化配置：<br><code>make menuconfig</code><br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/1.png" alt="image"></p>
<h2><span id="1-2-buildroot-mu-lu-jie-gou">1.2 buildroot目录结构</span><a href="#1-2-buildroot-mu-lu-jie-gou" class="header-anchor">#</a></h2><h3><span id="1-2-0-buildroot-yuan-mu-lu">1.2.0 buildroot源目录</span><a href="#1-2-0-buildroot-yuan-mu-lu" class="header-anchor">#</a></h3><ul>
<li><p><code>arch</code>: CPU架构相关的配置脚本</p>
</li>
<li><p><code>board</code>: 在构建系统时，board默认的boot和Linux kernel配置文件，以及一些板级相关脚本</p>
</li>
<li><p><code>boot</code>: uboot配置脚本目录</p>
</li>
<li><p><code>configs</code>: 板级配置文件，该目录下的配置文件记录着该机器平台或者方案使用的工具链，boot， kernel，各种应用软件包的配置</p>
</li>
<li><p><code>dl</code>: download的简写，下载一些开源包。第一次下载后，下次就不会再去从官网下载了，而是从dl&#x2F;目录下拿开源包，以节约时间</p>
</li>
<li><p><code>docs</code>:</p>
</li>
<li><p><code>fs</code>: 各种文件系统的自动构建脚本</p>
</li>
<li><p><code>linux</code>: 存放Linux kernel的自动构建脚本</p>
</li>
<li><p><code>package</code>: 第三方开源包的自动编译构建脚本，用来配置编译dl目录下载的开源包</p>
</li>
<li><p><code>support</code>:</p>
</li>
<li><p><code>system</code>: 存放文件系统目录的和设备节点的模板，这些模板会被拷贝到<code>output/</code>目录下，用于制作根文件系统<code>rootfs</code></p>
</li>
<li><p><code>toolchain/ </code>目录中存放着各种制作工具链的脚本</p>
</li>
</ul>
<h3><span id="1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao">1.2.1 编译出的output输出目录介绍</span><a href="#1-2-1-bian-yi-chu-de-output-shu-chu-mu-lu-jie-shao" class="header-anchor">#</a></h3><ul>
<li><p><code>images/</code>存储所有映像（内核映像，引导加载程序和根文件系统映像）的位置。这些是您需要放在目标系统上的文件。</p>
</li>
<li><p><code>build/</code>构建所有组件的位置（包括主机上Buildroot所需的工具和针对目标编译的软件包）。该目录为每个组件包含一个子目录。</p>
</li>
<li><p><code>host/</code>包含为主机构建的工具和目标工具链。</p>
</li>
<li><p><code>staging/</code>是到内部目标工具链host&#x2F;的符号链接 </p>
</li>
<li><p><code>target/</code>它几乎包含了目标的完整根文件系统。除了设备文件<code>/dev/</code>（Buildroot无法创建它们，因为Buildroot不能以root身份运行并且不想以root身份运行）之外，所需的一切都存在。</p>
</li>
</ul>
<h2><span id="1-3-pei-zhi-target-options">1.3 配置 Target options</span><a href="#1-3-pei-zhi-target-options" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Target options</span><br><span class="line">	-&gt; Target Architecture = ARM (little endian)</span><br><span class="line">	-&gt; Target Binary Format = ELF</span><br><span class="line">	-&gt; Target Architecture Variant = cortex-A7</span><br><span class="line">	-&gt; Target ABI = EABIhf</span><br><span class="line">	-&gt; Floating point strategy = NEON/VFPv4</span><br><span class="line">	-&gt; ARM instruction <span class="built_in">set</span> = ARM</span><br></pre></td></tr></table></figure>
<p>配置输出目标选项，架构，格式，浮点策略，指令集啊。配置好后如下：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/2.png" alt="image"></p>
<h2><span id="1-4-pei-zhi-gong-ju-lian">1.4 配置工具链</span><a href="#1-4-pei-zhi-gong-ju-lian" class="header-anchor">#</a></h2><p>Buildroot为交叉编译工具链提供了两种解决方案：</p>
<h3><span id="1-4-1-nei-bu-gong-ju-lian">1.4.1 内部工具链</span><a href="#1-4-1-nei-bu-gong-ju-lian" class="header-anchor">#</a></h3><ul>
<li>内部工具链，称为<code>Buildroot toolchain</code>。<code>buildroot </code>其实是可以自动下载交叉编译器的，但是都是从国外服务器下载的， 鉴于国内的网络环境，推荐大家设置成自己所使用的交叉编译器(也就是外部工具链)。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/3.png" alt="image"></li>
</ul>
<h3><span id="1-4-2-wai-bu-gong-ju-lian">1.4.2 外部工具链</span><a href="#1-4-2-wai-bu-gong-ju-lian" class="header-anchor">#</a></h3><ul>
<li>外部工具链<code>External toolchain</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Toolchain</span><br><span class="line">-&gt; Toolchain type = External toolchain</span><br><span class="line">-&gt; Toolchain = Custom toolchain <span class="comment">//选择用户自己的交叉编译器</span></span><br><span class="line">-&gt; Toolchain origin = Pre-installed toolchain <span class="comment">//选择预装的编译器,否则Toolchain to be downloaded and installed</span></span><br><span class="line">-&gt; Toolchain path =/usr/local/arm/gcc-linaro<span class="number">-4.9</span><span class="number">.4</span><span class="number">-2017.01</span>-x86_64_arm-linux-gnueabihf</span><br><span class="line">-&gt; Toolchain prefix = $(ARCH)-linux-gnueabihf <span class="comment">//前缀</span></span><br><span class="line">-&gt; External toolchain gcc version = <span class="number">4.9</span>.x</span><br><span class="line">-&gt; External toolchain kernel headers series = <span class="number">4.1</span>.x</span><br><span class="line">-&gt; External toolchain C library = glibc/eglibc</span><br><span class="line">-&gt; [*] Toolchain has SSP support? (NEW) <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Toolchain has RPC support? (NEW) <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Toolchain has C++ support? <span class="comment">//选中</span></span><br><span class="line">-&gt; [*] Enable MMU support (NEW) <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>

<p><code>Toolchain</code>：设置为 Custom toolchain，表示使用用户自己的交叉编译器。<br><code>Toolchain origin</code>：设置为 Pre-installed toolchain，表示使用预装的交叉编译器。<br><code>Toolchain path</code>：设置自己安装的交叉编译器绝对路径！buildroot 要用到。<br><code>Toolchain prefix</code>：设置交叉编译器前缀，要根据自己实际所使用的交叉编译器来设置，比如我们使用的是 <code>arm-linux-gnueabihf-gcc</code>，因此前缀就是<code>$(ARCH)-linux-gnueabihf</code>，其中 ARCH 我们前面已经设置为了 arm。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/4.png" alt="image"></p>
<h2><span id="1-5-pei-zhi-build-options">1.5 配置 build options</span><a href="#1-5-pei-zhi-build-options" class="header-anchor">#</a></h2><p>编译选项，编译第三方插件使用静态还是动态链接等。</p>
<h2><span id="1-6-pei-zhi-system-configuration">1.6 配置 System configuration</span><a href="#1-6-pei-zhi-system-configuration" class="header-anchor">#</a></h2><p>系统配置，比如开发板名字、欢迎语、用户名、密码等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System configuration</span><br><span class="line">-&gt; System hostname = alpha_imx6ull <span class="comment">//平台名字，自行设置</span></span><br><span class="line">-&gt; System banner = Welcome to alpha i.mx6ull <span class="comment">//欢迎语</span></span><br><span class="line">-&gt; Init system = BusyBox <span class="comment">//使用 busybox</span></span><br><span class="line">-&gt; /dev management = Dynamic using devtmpfs + mdev <span class="comment">//使用 mdev</span></span><br><span class="line">-&gt; [*] Enable root login with password (NEW) <span class="comment">//使能登录密码</span></span><br><span class="line">-&gt; Root password = <span class="number">123456</span> <span class="comment">//登录密码为 123456</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-7-pei-zhi-filesystem-images">1.7 配置 Filesystem images</span><a href="#1-7-pei-zhi-filesystem-images" class="header-anchor">#</a></h2><p>根文件系统格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Filesystem images</span><br><span class="line">-&gt; [*] ext2/<span class="number">3</span>/<span class="number">4</span> root filesystem <span class="comment">//如果是 EMMC 或 SD 卡的话就用 ext3/ext4</span></span><br><span class="line">-&gt; ext2/<span class="number">3</span>/<span class="number">4</span> variant = ext4 <span class="comment">//选择 ext4 格式</span></span><br><span class="line">-&gt; [*] ubi image containing an ubifs root filesystem <span class="comment">//如果使用 NAND 的话就用 ubifs</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/5.png" alt="image"></p>
<h2><span id="1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot">1.8 禁止编译 Linux 内核和 uboot</span><a href="#1-8-jin-zhi-bian-yi-linux-nei-he-he-uboot" class="header-anchor">#</a></h2><p>一版不建议uboot和kernel也用buildroot。buildroot 不仅仅能构建根文件系统，也可以编译 linux 内核和 uboot。</p>
<p>buildroot如果开启了uboot和Linux内核的编译，会自动下载最新的 linux 内核和 uboot，那么最新的内核和uboot会对编译器版本号有要求，可能导致编译失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Kernel</span><br><span class="line">-&gt; [ ] Linux Kernel <span class="comment">//不要选择编译 Linux Kernel 选项！</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/6.png" alt="image"></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/7.png" alt="image"></p>
<h2><span id="1-9-pei-zhi-target-packages">1.9 配置 Target packages</span><a href="#1-9-pei-zhi-target-packages" class="header-anchor">#</a></h2><p><a name="1.9配置Targetpackages"></a></p>
<p>配置要选择的第三方库或软件、比如 <code>alsa-utils、ffmpeg、iperf</code>等工具。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/8.png" alt="image"></p>
<h1><span id="2-bian-yi-buildroot">2 编译buildroot</span><a href="#2-bian-yi-buildroot" class="header-anchor">#</a></h1><h2><span id="2-1-make-help">2.1 make help</span><a href="#2-1-make-help" class="header-anchor">#</a></h2><p>可以看到<code>buildroot</code>下make的使用细节，包括对<code>package、uclibc、busybox、linux</code>以及文档生成等配置。</p>
<h2><span id="2-2-make-print-version">2.2 make print-version</span><a href="#2-2-make-print-version" class="header-anchor">#</a></h2><p>打印<code>buildroot</code>版本号</p>
<h2><span id="2-3-make-menuconfig">2.3 make menuconfig</span><a href="#2-3-make-menuconfig" class="header-anchor">#</a></h2><p>或者(<code>make linux-menuconfig</code>…):进行图形化配置</p>
<h2><span id="2-4-make-xxxx-defconfig">2.4 make xxxx_defconfig</span><a href="#2-4-make-xxxx-defconfig" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Buildroot_2020.02.x/configs$ <span class="built_in">ls</span></span><br><span class="line">100ask                                                nexbox_a95x_defconfig</span><br><span class="line">100ask_imx6ull_mini_ddr512m_systemV_core_defconfig    nitrogen6sx_defconfig</span><br><span class="line">100ask_imx6ull_mini_ddr512m_systemV_qt5_defconfig     nitrogen6x_defconfig</span><br><span class="line">100ask_imx6ull_pro_ddr512m_systemV_core_defconfig     nitrogen7_defconfig</span><br><span class="line">100ask_imx6ull_pro_ddr512m_systemV_qt5_defconfig      nitrogen8m_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_busybox_core_defconfig  odroidxu4_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemD_core_defconfig  olimex_a10_olinuxino_lime_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemD_qt5_defconfig   olimex_a13_olinuxino_defconfig</span><br><span class="line">100ask_stm32mp157_pro_ddr512m_systemV_core_defconfig  olimex_a20_olinuxino_lime2_defconfig</span><br></pre></td></tr></table></figure>

<p><code>make 100ask_imx6ull_pro_ddr512m_systemV_core_defconfig</code>即可产生<code>.config</code>和<code>output目录</code>：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/9.png" alt="image"></p>
<h2><span id="2-5-make">2.5 make</span><a href="#2-5-make" class="header-anchor">#</a></h2><p><code>sudo make //注意不能-jxxx，来指定多核编译</code></p>
<p>make命令通常将执行以下步骤：</p>
<ol>
<li>下载源文件（根据需要）；</li>
<li>配置、构建和安装交叉编译工具链，或仅导入外部工具链；</li>
<li>配置、构建和安装选定的目标软件包；</li>
<li>构建内核映像（如果选择）；</li>
<li>构建引导加载程序映像（如果选择）；</li>
<li>以选定的格式创建一个根文件系统</li>
</ol>
<ul>
<li><code>make clean</code>：delete all build products (including build directories, host, staging and target trees, the images and the toolchain)</li>
<li><code>make distclean</code>: 等于make clean+删除配置</li>
<li><code>make show-targets</code>:显示出本次配置所要编译所有的目标</li>
<li><code>make  pkg-target</code>:单独编译某个pkg模块</li>
<li><code>make pkg-rebuild</code>:重新编译pkg</li>
<li><code>make  pkg-extrac</code>t:只下载解压pkg,不编译，pkg解压后放在 <code>output/build/</code>对应的<code>pkg-dir</code>目录下</li>
<li><code>make pkg-source</code>:只下载某pkg，然后不做任何事情</li>
<li><code>make list-defconfigs</code>:例举所有可用的defconfigs。</li>
<li><code>make xxx_menuconfig</code>:比如<code>make linux-menuconfig</code></li>
</ul>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/10.png" alt="image"></p>
<p><code>rootfs.tar</code>就是编译出的根文件系统，解压缩后就能使用。</p>
<h3><span id="2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong">2.5.1 nfs 挂载根文件系统</span><a href="#2-5-1-nfs-gua-zai-gen-wen-jian-xi-tong" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=tty1 console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.253:</span></span><br><span class="line"><span class="string">/home/zuozhongkai/linux/nfs/buildrootfs rw ip=192.168.1.251:192.168.1.253:192.168.1.1:255.255.</span></span><br><span class="line"><span class="string">255.0::eth0:off&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/11.png" alt="image"></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/12.png" alt="image"></p>
<p>可以看到能进入rootfs，但是驱动ko和第三方软件和库没有。</p>
<h2><span id="2-6-make-show-targets">2.6 make show-targets</span><a href="#2-6-make-show-targets" class="header-anchor">#</a></h2><p><code>make show-targets</code>显示出本次配置所要编译所有的目标。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/13.png" alt="image"></p>
<h1><span id="3-buildroot-kuang-jia-yuan-li">3 buildroot框架原理</span><a href="#3-buildroot-kuang-jia-yuan-li" class="header-anchor">#</a></h1><p><code>Buildroot</code>提供了函数框架和变量命令框架，采用它的框架编写的<code>app_pkg.mk</code>这种<code>Makefile</code>格式的<code>自动构建脚本</code>，将被<code>package/pkg-generic.mk</code> 这个核心脚本展开填充到<code>buildroot</code>主目录下的<code>Makefile</code>中去。</p>
<p>最后<code>make all</code>执行<code>Buildroot</code>主目录下的<code>Makefile</code>，生成你想要的image。 <code>package/pkg-generic.mk</code>中通过调用同目录下的<code>pkg-download.mk</code>、<code>pkg-utils.mk</code>文件，已经帮你自动实现了下载、解压、依赖包下载编译等一系列机械化的流程。</p>
<p>你只要需要按照格式写<code>app_pkg.mk</code>，填充下载地址，链接依赖库的名字等一些特有的构建细节即可。 总而言之，<code>Buildroot</code>本身提供构建流程的框架，开发者按照格式写脚本，提供必要的构建细节，配置整个系统，最后自动构建出你的系统。</p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/14.png"></p>
<h2><span id="3-1-tian-jia-zi-ji-de-ruan-jian-bao">3.1 添加自己的软件包</span><a href="#3-1-tian-jia-zi-ji-de-ruan-jian-bao" class="header-anchor">#</a></h2><h3><span id="3-1-1-package-x2f-config-in-zong-ru-kou-tian-jia-cai-dan">3.1.1 package&#x2F;Config.in总入口添加菜单</span><a href="#3-1-1-package-x2f-config-in-zong-ru-kou-tian-jia-cai-dan" class="header-anchor">#</a></h3><p>添加如下语句：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu <span class="string">&quot;myown(fuzidage) package&quot;</span></span><br><span class="line">	source <span class="string">&quot;package/helloworld/Config.in&quot;</span></span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>

<p>为自己的软件包添加入口，这样在<code>make menuconfig</code>的时候就可以找到自己的软件包的<code>Config.in</code>，如果在<code>make menuconfig</code>的时候选中<code>helloworld</code>，那么<code>&quot;BR2_PACKAGE_HELLOWORLD=y&quot;</code>也会同步到<code>.config</code>中去。</p>
<h3><span id="3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian">3.1.2 配置APP对应的Config.in和mk文件</span><a href="#3-1-2-pei-zhi-app-dui-ying-de-config-in-he-mk-wen-jian" class="header-anchor">#</a></h3><p>在<code>package</code>中新增目录<code>helloworld</code>，并在里面添加<code>Config.in</code>和<code>helloworld.mk</code></p>
<h4><span id="3-1-2-1-config-in">3.1.2.1 Config.in</span><a href="#3-1-2-1-config-in" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config BR2_PACKAGE_HELLOWORLD</span><br><span class="line">bool <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">help</span><br><span class="line">  This is a demo to add myown(fuzidage) package.</span><br></pre></td></tr></table></figure>

<p><code>helloworld/Config.in</code>文件，可以通过<code>make menuconfig</code>可以对<code>helloworld</code>进行选择。只有在<code>BR2_PACKAGE_HELLOWORLD=y</code>条件下，才会调用<code>helloworld.mk</code>进行编译</p>
<h4><span id="3-1-2-2-helloworld-mk">3.1.2.2 helloworld.mk</span><a href="#3-1-2-2-helloworld-mk" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># helloworld</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">################################################################################</span></span><br><span class="line">HELLOWORLD_VERSION:= 1.0.0</span><br><span class="line">HELLOWORLD_SITE:= <span class="variable">$(CURDIR)</span>/work/helloworld</span><br><span class="line">HELLOWORLD_SITE_METHOD:=local</span><br><span class="line">HELLOWORLD_INSTALL_TARGET:=YES</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_BUILD_CMDS</span><br><span class="line">    <span class="variable">$(MAKE)</span> CC=<span class="string">&quot;<span class="variable">$(TARGET_CC)</span>&quot;</span> LD=<span class="string">&quot;<span class="variable">$(TARGET_LD)</span>&quot;</span> -C $(@D) all</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_INSTALL_TARGET_CMDS</span><br><span class="line">    <span class="variable">$(INSTALL)</span> -D -m 0755 $(@D)/helloworld <span class="variable">$(TARGET_DIR)</span>/bin</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> HELLOWORLD_PERMISSIONS</span><br><span class="line">    /bin/helloworld f 4755 0 0 - - - - -</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"><span class="variable">$(<span class="built_in">eval</span> $(generic-package)</span>)</span><br></pre></td></tr></table></figure>

<p><code>helloworld.mk</code>包括源码位置、安装目录、权限设置等。</p>
<h3><span id="3-1-3-bian-xie-app-yuan-ma-he-makefile">3.1.3 编写APP源码和Makefile</span><a href="#3-1-3-bian-xie-app-yuan-ma-he-makefile" class="header-anchor">#</a></h3><p>创建一个<code>work/helloworld</code>目录，建立<code>hello_world.c</code>和<code>makefile</code>。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">all: helloworld</span></span><br><span class="line"><span class="section">helloworld: helloworld.o</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o helloworld helloworld.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o</span><br><span class="line">	rm -rf helloworld</span><br><span class="line"><span class="section">install:</span></span><br><span class="line">	<span class="variable">$(INSTALL)</span> -D -m 0755 helloworld <span class="variable">$(TARGET_DIR)</span>/bin</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-4-tong-guo-make-menuconfig-xuan-zhong-app">3.1.4 通过make menuconfig选中APP</span><a href="#3-1-4-tong-guo-make-menuconfig-xuan-zhong-app" class="header-anchor">#</a></h3><p>通过上面对<code>package/Config.in</code>入口的配置, 我们可以通过<code>make menuconfig</code>，进入<code>Target packages</code>可以看见多了一个<code>&quot;myown(fuzidage) package&quot;</code>入口，选中，保存配置到<code>.config</code>。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/15.png" alt="image"></p>
<p>然后<code>make savedefconfig</code>，对helloworld的配置就会保存到对应的<code>xxx_defconfig</code>中。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/16.png" alt="image"></p>
<h3><span id="3-1-5-bian-yi-shi-yong-app">3.1.5 编译使用APP</span><a href="#3-1-5-bian-yi-shi-yong-app" class="header-anchor">#</a></h3><p>可以和整个平台一起编译APP；或者<code>make helloworld</code>单独编译。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/17.png" alt="image"></p>
<p>编译过程中，会被拷贝到<code>output/build/helloworld-1.0.0</code>文件夹中。然后生成的bin文件拷贝到<code>output/target/bin/helloworld</code>，这个文件会打包到文件系统中。<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/18.png" alt="image"></p>
<p>如果需要清空相应的源文件，通过<code>make helloworld-dirclean</code>。</p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/19.png" alt="image"></p>
<h2><span id="3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao">3.2 如何重新编译软件包</span><a href="#3-2-ru-he-chong-xin-bian-yi-ruan-jian-bao" class="header-anchor">#</a></h2><p>经过第一次完整编译后，如果我们需要对源码包重新配置，我们不能直接在<code>buildroot</code>上的根目录下直接make，<code>buildroot</code>是不知道你已经对源码进行重新配置，它只会将第一次编译出来的文件，再次打包成根文件系统镜像文件。</p>
<p>那么可以通过以下2种方式重新编译：</p>
<ol>
<li><p>直接删除源码包,然后<code>make all</code></p>
 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例如我们要重新编译helloworld，那么可以直接删除output/build/helloworld目录，</span><br><span class="line">那么当你make的时候，就会自动从dl文件夹下，解压缩源码包，并重新安装。这种效率偏低</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行<code>xxx-rebuild</code>,然后<code>make all</code></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">也是以helloworld为例子，我们直接输入make helloworld-rebuild，</span><br><span class="line">即可对build/helloworld/目录进行重新编译，然后还要进行make all(或者make world 或者 make target-post-image)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要重新配置编译安装：</p>
 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &lt;package&gt;-reconfigure; make all</span><br></pre></td></tr></table></figure></li>
</ol>
<h2><span id="3-3-shi-neng-di-san-fang-ruan-jian-he-ku">3.3 使能第三方软件和库</span><a href="#3-3-shi-neng-di-san-fang-ruan-jian-he-ku" class="header-anchor">#</a></h2><p>前面 <a href="#1.9%E9%85%8D%E7%BD%AETargetpackages">1.9配置Targetpackages</a> 有引入介绍。</p>
<h3><span id="3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian">3.3.1 使能音频的ALSA库套件</span><a href="#3-3-1-shi-neng-yin-pin-de-alsa-ku-tao-jian" class="header-anchor">#</a></h3><p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/20.png" alt="image"></p>
<h3><span id="3-3-2-shi-neng-busybox-tao-jian">3.3.2 使能busybox套件</span><a href="#3-3-2-shi-neng-busybox-tao-jian" class="header-anchor">#</a></h3><p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/21.png" alt="image"></p>
<p>使能后，<code>buildroot</code> 会自动下载 <code>busybox</code> 压缩包，<code>buildroot </code>下载的源码压缩包都存 放在<code>/dl </code>目录下，在<code> dl</code> 目录下就有一个叫做<code>“busybox”</code>的文件夹，此目录下保存着 busybox 压 缩包:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/22.png" alt="image"></p>
<p><code>make all</code>编译完后, <code>buildroot</code> 将所有解压缩后的软件保存在<code>/output/build </code>软件中，我们可以找到<code>/output/build/busybox-1.29.3</code> 这个文件夹，此文件夹就是解压后的 busybox 源码:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/23.png" alt="image"><br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/24.png" alt="image"></p>
<h4><span id="3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian">3.3.2.1 修改配置busybox套件</span><a href="#3-3-2-1-xiu-gai-pei-zhi-busybox-tao-jian" class="header-anchor">#</a></h4><p>修改busybox源码就直接在<code>/output/build/busybox-1.29.3</code>修改。</p>
<p><code>make busybox-menuconfig</code>可以配置busybox套件选择哪些功能：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/25.png" alt="image"></p>
<h4><span id="3-3-2-2-rebuild-busybox-tao-jian">3.3.2.2 rebuild busybox套件</span><a href="#3-3-2-2-rebuild-busybox-tao-jian" class="header-anchor">#</a></h4><p><code>make busybox</code>或者<code>make busybox-rebuild</code>即可重新编译。</p>
<p>编译完后还要<code>make</code>或者<code>make target-post-image</code>对其进行打包进根文件系统。</p>
<h3><span id="3-3-3-ps1-huan-jing-bian-liang">3.3.3 PS1环境变量</span><a href="#3-3-3-ps1-huan-jing-bian-liang" class="header-anchor">#</a></h3><p>我们构建的根文件系统启动以后会发现， 输入命令的时候命令行前面一直都是<code>“#”</code>，如果我们进入到某个目录的话前面并不会显示当前目录路径:<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/26.png" alt="image"></p>
<p>PS1 用于设置命令提示符格式，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PS1 = ‘命令列表’</span><br><span class="line">命令列表中可选的参数如下：</span><br><span class="line">\! 显示该命令的历史记录编号。</span><br><span class="line"> \<span class="comment"># 显示当前命令的命令编号。</span></span><br><span class="line"> \$ 显示$符作为提示符，如果用户是 root 的话，则显示<span class="comment">#号。</span></span><br><span class="line"> \\ 显示反斜杠。</span><br><span class="line"> \d 显示当前日期。</span><br><span class="line"> \h 显示主机名。</span><br><span class="line"> \n 打印新行。</span><br><span class="line"> \nnn 显示 nnn 的八进制值。</span><br><span class="line"> \s 显示当前运行的 shell 的名字。</span><br><span class="line"> \t 显示当前时间。</span><br><span class="line"> \u 显示当前用户的用户名。</span><br><span class="line"> \W 显示当前工作目录的名字。</span><br><span class="line"> \w 显示当前工作目录的路径</span><br></pre></td></tr></table></figure>

<p>我们打开&#x2F;etc&#x2F;profie，修改成如下：<br><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/27.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;[\u@\h]:\w$:&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PS1</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree">3.4 单独生成目标（build out of tree）</span><a href="#3-4-dan-du-sheng-cheng-mu-biao-build-out-of-tree" class="header-anchor">#</a></h2><p><code>make O=/home/XXX/output</code></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/28.png"></p>
<h1><span id="4-buildroot-guan-fang-jiao-cheng-lian-jie">4 buildroot官方教程链接</span><a href="#4-buildroot-guan-fang-jiao-cheng-lian-jie" class="header-anchor">#</a></h1><p><a target="_blank" rel="noopener" href="https://bootlin.com/doc/training/buildroot/">buildroot官方训练教程</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2147438">buildroot中文手册</a></p>
<p><img src="/2024/07/23/buildroot%E6%95%99%E7%A8%8B/29.png" alt="image-20240814004339288"></p>
<p>可以下载正点原子翻译的中文版buildroot手册。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/23/buildroot%E6%95%99%E7%A8%8B/" data-id="clzso22o20000psufbgf8aqtf" data-title="buildroot教程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux内核-异常输出函数调用栈calltrace分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2024-07-23T14:36:29.000Z" itemprop="datePublished">2024-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/">Linux内核-异常输出函数调用栈calltrace分析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dump-stack-han-shu">1 dump_stack函数</a></li>
<li><a href="#2-nei-he-tai-yi-chang-call-trace-deng-ji">2 内核态异常call trace等级</a><ul>
<li><a href="#2-1-warn-on-han-shu">2.1 WARN_ON函数</a></li>
<li><a href="#2-2-bug-on-han-shu">2.2 BUG_ON函数</a></li>
<li><a href="#2-3-panic-han-shu">2.3 panic函数</a></li>
</ul>
</li>
<li><a href="#3-ftrace-gong-ju-ji">3 Ftrace工具集</a><ul>
<li><a href="#3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de">3.1 Ftrace是如何记录信息的</a><ul>
<li><a href="#3-1-1-jing-tai-cha-zhuang">3.1.1 静态插桩</a></li>
<li><a href="#3-1-2-dong-tai-cha-zhuang">3.1.2 动态插桩</a></li>
</ul>
</li>
<li><a href="#3-2-shi-neng-ftrace">3.2 使能Ftrace</a><ul>
<li><a href="#3-2-1-gua-zai-debugfs">3.2.1 挂载debugfs</a></li>
</ul>
</li>
<li><a href="#3-3-ftrace-shi-yong">3.3 Ftrace 使用</a><ul>
<li><a href="#3-3-1-sys-kernel-tracing-jie-shao">3.3.1 &#x2F;sys&#x2F;kernel&#x2F;tracing介绍</a></li>
<li><a href="#3-3-2-trace-he-trace-pipe-shi-yong">3.3.2 trace和trace_pipe使用</a><ul>
<li><a href="#3-3-2-1-xuan-yong-han-shu-zhui-zong">3.3.2.1 选用函数追踪</a></li>
<li><a href="#3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong">3.3.2.2 选用图像化函数追踪</a></li>
<li><a href="#3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong">3.3.2.3 选用动态过滤追踪</a></li>
<li><a href="#3-3-2-4-zhui-zong-te-ding-jin-cheng">3.3.2.4 追踪特定进程</a></li>
<li><a href="#3-3-2-5-zhui-zong-te-ding-han-shu">3.3.2.5 追踪特定函数</a></li>
<li><a href="#3-3-2-6-zhui-zong-te-ding-ko-mo-kuai">3.3.2.6 追踪特定ko模块</a></li>
<li><a href="#3-3-2-7-chong-zhi-zhui-zong">3.3.2.7 重置追踪</a></li>
<li><a href="#3-3-2-8-shi-jian-zhui-zong">3.3.2.8 事件追踪</a></li>
<li><a href="#3-3-2-n-trace-printk-han-shu-shi-yong">3.3.2.n trace_printk函数使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-yin-ru-yong-hu-tai-ltrace-he-strace">3.4 引入用户态ltrace和strace</a><ul>
<li><a href="#3-4-1-ltrace">3.4.1 ltrace</a></li>
<li><a href="#3-4-2-strace">3.4.2 strace</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dump-stack-han-shu">1 dump_stack函数</span><a href="#1-dump-stack-han-shu" class="header-anchor">#</a></h1><p>打印内核调用堆栈。举个例子：</p>
<p>我们定义四个函数<code>aaa</code>、<code>bbb</code>、<code>ccc</code>、<code>ddd</code>，然后<code>bbb</code>中调用<code>aaa</code>，<code>ccc</code>中调用<code>bbb</code>，<code>ddd</code>函数谁都不调用。在入口函数中，我们调用<code>ccc</code>与<code>ddd</code>函数，看看堆栈打印效果如何：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aaa</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;aaa\n&quot;</span>);</span><br><span class="line">    dump_stack();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bbb</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;bbb\n&quot;</span>);</span><br><span class="line">    aaa();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ccc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;ccc\n&quot;</span>);</span><br><span class="line">    bbb();</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ddd</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;ddd\n&quot;</span>);</span><br><span class="line">    msleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">chrdevTest_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;INIT func\r\n&quot;</span>);</span><br><span class="line">    ccc();</span><br><span class="line">    ddd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">chrdevTest_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(KERN_EMERG <span class="string">&quot;EXIT func\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(chrdevTest_init);</span><br><span class="line">module_exit(chrdevTest_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到当打印完<code>aaa</code>后开始<code>dump_stack</code>, 打印出函数调用栈。</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/1.png" alt="image-20240727224310304"></p>
<h1><span id="2-nei-he-tai-yi-chang-call-trace-deng-ji">2 内核态异常call trace等级</span><a href="#2-nei-he-tai-yi-chang-call-trace-deng-ji" class="header-anchor">#</a></h1><p>内核态call trace 有三种出错情况，分别是<code>bug</code>, <code>oops</code>和<code>panic</code>。</p>
<p>1、 <code>bug</code>- <strong>bug只是提示警告</strong>。<br><code>BUG: sleeping function called from invalid context at …</code>, 比如在原子上下文中休眠，总断服务函数休眠，spin_lock中进行might_sleep等。</p>
<p>我在某个设备驱动的中断处理函数 <code>XXX_ISR()</code> 里加了 <code>msleep(10) </code>之后：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/2.png" alt="image-20240727230940026"></p>
<p>可以看到跑出了BUG打印，为什么是<code>BUG: scheduling while atomic</code>呢？而不是<code>BUG: sleeping function called from invalid context at …</code></p>
<p>那是因为在原子上文中发生了调度，我们调用might_sleep是会时间片到了啊，让出CPU自然就进行了schedule。</p>
<p><code>BUG: spinlock bad magic on CPU</code>错误表示自旋锁使用时没有初始化。</p>
<p>2、 <code>Oops</code>- <strong>oops会终止进程，但是不会系统崩溃</strong>。<br>程序在内核态进入一种异常情况，比如引用非法指针导致的数据异常，数组越界导致的取指异常，此时异常处理机制能够捕获此异常，并将系统关键信息打印到串口上，正常情况下Oops消息会被记录到系统日志中去。</p>
<p>3、<code> Panic</code> -<strong>panic系统崩溃</strong>。<br>当Oops发生在中断上下文中或者在进程0和1中，系统将彻底挂起，因为中断服务程序异常后，将无法恢复，这种情况即称为内核panic。</p>
<h2><span id="2-1-warn-on-han-shu">2.1  WARN_ON函数</span><a href="#2-1-warn-on-han-shu" class="header-anchor">#</a></h2><p>我们把上面的实验<code>aaa</code>函数中<code>dump_stack</code>改成<code>WARN_ON(1)</code>函数。可以看到<code>WARN_ON(1)</code>就是调用了<code>dump_stack</code>，多了绿色打印部分而已:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/3.png" alt="image-20240727232452233"></p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/4.png" alt="image-20240727232843642"></p>
<p>注意只有当<code>condition=1</code>时才会真正调用<code>__warn</code>:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/5.png" alt=":"></p>
<h2><span id="2-2-bug-on-han-shu">2.2 BUG_ON函数</span><a href="#2-2-bug-on-han-shu" class="header-anchor">#</a></h2><p><code>BUG_ON</code>这句，一旦执行就会抛出<code>oops</code>，导致栈的回溯和错误信息的打印，大部分体系结构把<code>BUG()</code>和<code>BUG_ON()</code>定义成某种非法操作，这样自然会产生需要的oops。类似一种断言，让进程终止。我们把上面的实验<code>aaa</code>函数中<code>dump_stack</code>改成<code>BUG_ON(1)</code>函数:</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/6.png" alt="image-20240727233540771"></p>
<h2><span id="2-3-panic-han-shu">2.3 panic函数</span><a href="#2-3-panic-han-shu" class="header-anchor">#</a></h2><p>当Oops发生在中断上下文中或者在进程0和1中，系统将彻底挂起，因为中断服务程序异常后，将无法恢复，这种情况即称为内核panic</p>
<h1><span id="3-ftrace-gong-ju-ji">3 Ftrace工具集</span><a href="#3-ftrace-gong-ju-ji" class="header-anchor">#</a></h1><p><code>Ftrace</code>是<code>Function Trace</code>的简写。它是一个内核函数追踪工具，旨在帮助内核设计和开发人员去追踪系统内部的函数调用流程。</p>
<p>还可以用来调试和分析系统的延迟和性能问题，并发展成为一个追踪类调试工具的框架：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/7.png" alt="image-20240728145336807"></p>
<p>可以看到还包括了用户态的<code>ltrace</code>和<code>ftrace</code>。</p>
<h2><span id="3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de">3.1 Ftrace是如何记录信息的</span><a href="#3-1-ftrace-shi-ru-he-ji-lu-xin-xi-de" class="header-anchor">#</a></h2><p><code>Ftrace</code>采用了静态插桩和动态插桩两种方式来实现。</p>
<h3><span id="3-1-1-jing-tai-cha-zhuang">3.1.1 静态插桩</span><a href="#3-1-1-jing-tai-cha-zhuang" class="header-anchor">#</a></h3><p><code>Kernel</code>中打开了<code>CONFIG_FUNCTION_TRACER</code>功能后，会增加一个<code>-pg</code>的一个编译选项，这样每个函数入口处，都会插入<code>bl mcount</code>跳转指令，使得每个函数运行时都会进入<code>mcount</code>函数。</p>
<p>既然每个函数都静态插桩，这带来的性能开销是惊人的，有可能导致人们弃用<code>Ftrace</code>功能。为了解决这个问题，开发者推出了<code>Dynamic ftrace</code>，以此来优化整体的性能。</p>
<h3><span id="3-1-2-dong-tai-cha-zhuang">3.1.2 动态插桩</span><a href="#3-1-2-dong-tai-cha-zhuang" class="header-anchor">#</a></h3><p>既然静态插桩记录这些可追踪的函数，为了减少性能消耗，将跳转函数替换为<code>nop</code>指令，动态将被调试函数的<code>nop</code>指令，替换为跳转指令，以实现追踪。</p>
<h2><span id="3-2-shi-neng-ftrace">3.2 使能Ftrace</span><a href="#3-2-shi-neng-ftrace" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_FTRACE=y                             <span class="comment"># 启用了 Ftrace</span></span><br><span class="line">CONFIG_FUNCTION_TRACER=y                    <span class="comment"># 启用函数级别的追踪器</span></span><br><span class="line">CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y         <span class="comment"># 表示内核支持图形显示</span></span><br><span class="line">CONFIG_FUNCTION_GRAPH_TRACER=y              <span class="comment"># 以图形的方式显示函数追踪过程</span></span><br><span class="line">CONFIG_STACK_TRACER=y                       <span class="comment"># 启用堆栈追踪器，用于跟踪内核函数调用的堆栈信息。</span></span><br><span class="line">CONFIG_DYNAMIC_FTRACE=y                     <span class="comment"># 启用动态 Ftrace，允许在运行时启用和禁用 Ftrace 功能。</span></span><br><span class="line">CONFIG_HAVE_FTRACE_NMI_ENTER=y              <span class="comment"># 表示内核支持非屏蔽中断（NMI）时进入 Ftrace 的功能</span></span><br><span class="line">CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y          <span class="comment"># 表示内核支持通过 mcount 记录函数调用关系。</span></span><br><span class="line">CONFIG_FTRACE_NMI_ENTER=y                   <span class="comment"># 表示内核支持通过 mcount 记录函数调用关系。   </span></span><br><span class="line">CONFIG_FTRACE_SYSCALLS=y                    <span class="comment"># 系统调用的追踪</span></span><br><span class="line">CONFIG_FTRACE_MCOUNT_RECORD=y               <span class="comment"># 启用 mcount 记录函数调用关系。</span></span><br><span class="line">CONFIG_SCHED_TRACER=y                       <span class="comment"># 支持调度追踪</span></span><br><span class="line">CONFIG_CONTEXT_SWITCH_TRACER                <span class="comment">#使能上下文切换追踪功能，可以用来跟踪进程之间的切换。</span></span><br><span class="line">CONFIG_NOP_TRACER                           <span class="comment">#使能空操作追踪功能，可以用来在不需要追踪的情况下占位。</span></span><br><span class="line">CONFIG_FUNCTION_PROFILER=y                  <span class="comment"># 启用函数分析器，主要用于记录函数的执行时间和调用次数</span></span><br><span class="line">CONFIG_DEBUG_FS=y                           <span class="comment"># 启用 Debug 文件系统支持</span></span><br></pre></td></tr></table></figure>

<p>上述配置不一定全部打开，勾选自己需要的即可，通常我们选择<code>CONFIG_FUNCTION_TRACER</code>和<code>CONFIG_HAVE_FUNCTION_GRAPH_TRACER</code>即可，然后编译烧录到开发板。</p>
<p>通过<code>make menuconfig</code>的方式写入：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">       Tracers ─&gt;</span><br><span class="line">           [*]   Kernel Function Tracer</span><br><span class="line">           [*]     Kernel Function Graph <span class="title function_">Tracer</span> <span class="params">(NEW)</span></span><br><span class="line">           <span class="comment">// (下面还有几个追踪器的选项，可以根据自己的需要选择)</span></span><br></pre></td></tr></table></figure>

<p><code>Ftrace </code>通过 <code>debugfs </code>向用户态提供了访问接口，所以还需要将<code> debugfs</code> 编译进内核:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">        -*- Debug Filesystem</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-gua-zai-debugfs">3.2.1 挂载debugfs</span><a href="#3-2-1-gua-zai-debugfs" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用户态需要挂载debugfs,or通过配置修改etc/fstab文件</span></span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">或者 mount -t tracefs nodev /sys/kernel/tracing</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/8.png" alt="img"></p>
<p>我们能够在<code>/sys/kernel/debug</code>下看到内核支持的所有的调试信息:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /sys/kernel/debug/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line"> asoc                gpio                regmap</span><br><span class="line"> bdi                 ieee80211           sched_debug</span><br><span class="line"> block               memblock            sched_features</span><br><span class="line"> clk                 mmc0                sleep_time</span><br><span class="line"> device_component    mmc1                suspend_stats</span><br><span class="line"> devices_deferred    mtd                 tracing</span><br><span class="line"> dma_buf             opp                 ubi</span><br><span class="line"> extfrag             pinctrl             ubifs</span><br><span class="line"> fault_around_bytes  pm_qos              wakeup_sources</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-ftrace-shi-yong">3.3 Ftrace 使用</span><a href="#3-3-ftrace-shi-yong" class="header-anchor">#</a></h2><h3><span id="3-3-1-x2f-sys-x2f-kernel-x2f-tracing-jie-shao">3.3.1 &#x2F;sys&#x2F;kernel&#x2F;tracing介绍</span><a href="#3-3-1-x2f-sys-x2f-kernel-x2f-tracing-jie-shao" class="header-anchor">#</a></h3><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/9.png" alt="image-20240728163630564"></p>
<h3><span id="3-3-2-trace-he-trace-pipe-shi-yong">3.3.2 trace和trace_pipe使用</span><a href="#3-3-2-trace-he-trace-pipe-shi-yong" class="header-anchor">#</a></h3><p><code>cat trace_pipe</code>是堵塞读取，有数据就读，没数据就等待。</p>
<p>打开关闭追踪：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; tracing_on             <span class="comment">// 打开跟踪</span></span><br><span class="line">do_someting</span><br><span class="line">echo <span class="number">0</span> &gt; tracing_on             <span class="comment">// 关闭跟踪</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat trace  &gt; /tmp/<span class="built_in">log</span> <span class="comment">//一次性导出log</span></span><br><span class="line">cat trace_pipe &gt; /tmp/<span class="built_in">log</span> &amp;<span class="comment">//后台导出log</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat current_tracer                    <span class="comment">// 查看当前追踪器</span></span><br><span class="line">cat available_tracers                 <span class="comment">// 查看当前内核中可用跟踪器</span></span><br><span class="line">cat available_events                  <span class="comment">// 查看当前内核中可用事件</span></span><br><span class="line">cat available_filter_functions        </span><br><span class="line"><span class="comment">// 查看当前内核中可用函数,可以被追踪的函数列表，</span></span><br><span class="line"><span class="comment">// 即可以写到 set_ftrace_filter，set_ftrace_notrace，set_graph_function，</span></span><br><span class="line"><span class="comment">// set_graph_notrace 文件的函数列表</span></span><br><span class="line"></span><br><span class="line">echo function &gt; current_tracer        <span class="comment">// 选用 function 追踪器，</span></span><br><span class="line">echo function_graph &gt; current_tracer  <span class="comment">// 选用 function_graph 追踪器，</span></span><br><span class="line">echo [func] &gt; set_ftrace_filter       <span class="comment">// 选择追踪指定 [func] 函数的调用栈</span></span><br><span class="line">echo [pid] &gt; set_ftrace_pid           <span class="comment">// 选择追踪指定 [pid] 进程的调用栈</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-1-xuan-yong-han-shu-zhui-zong">3.3.2.1 选用函数追踪</span><a href="#3-3-2-1-xuan-yong-han-shu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/10.png" alt="image-20240728153553129"></p>
<h4><span id="3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong">3.3.2.2 选用图像化函数追踪</span><a href="#3-3-2-2-xuan-yong-tu-xiang-hua-han-shu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/11.png" alt="image-20240728153651223"></p>
<h4><span id="3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong">3.3.2.3 选用动态过滤追踪</span><a href="#3-3-2-3-xuan-yong-dong-tai-guo-lu-zhui-zong" class="header-anchor">#</a></h4><p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/12.png" alt="image-20240728155333300"></p>
<h4><span id="3-3-2-4-zhui-zong-te-ding-jin-cheng">3.3.2.4 追踪特定进程</span><a href="#3-3-2-4-zhui-zong-te-ding-jin-cheng" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">echo</span> 0 &gt; tracing_on                                 <span class="comment"># 关闭追踪器</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer                      <span class="comment"># 设置当前追踪类别</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> &gt; trace; <span class="built_in">echo</span> $$ &gt; set_ftrace_pid; <span class="built_in">echo</span> 1 &gt; tracing_on; your_command; <span class="built_in">echo</span> 0 &gt; tracing_on</span><br></pre></td></tr></table></figure>

<p><code>$$</code>表示当前bash的pid,这样可以追踪任意命令。</p>
<p>如果我们要抓执行<code>a.out</code>的trace信息，那么先要获取到<code>a.out</code>程序的pid。</p>
<p>为什么要写成一条语句？</p>
<p>因为<code>ftrace</code>当打开时，在没有过滤的情况下，瞬间会抓取到内核所有的函数调用，为了更准确的抓取我们执行的命令，所以需要打开<code>trace</code>，执行完命令后，马上关闭。</p>
<h4><span id="3-3-2-5-zhui-zong-te-ding-han-shu">3.3.2.5 追踪特定函数</span><a href="#3-3-2-5-zhui-zong-te-ding-han-shu" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; options/func_stack_trace</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on									<span class="comment"># 关闭追踪器</span></span><br><span class="line"><span class="built_in">cat</span> available_filter_functions | grep <span class="string">&quot;xxxxxx&quot;</span>		<span class="comment"># 搜索函数是否存在</span></span><br><span class="line"><span class="built_in">echo</span> xxxxxx &gt; set_ftrace_filter						<span class="comment"># 设定追踪的函数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="keyword">function</span> &gt; current_tracer						<span class="comment"># 设置当前追踪类别</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; options/func_stack_trace					<span class="comment"># 记录堆栈信息</span></span><br><span class="line"><span class="built_in">echo</span> &gt; trace										<span class="comment"># 清空缓存</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; tracing_on</span><br></pre></td></tr></table></figure>

<p>查看结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat trace</span></span><br><span class="line"><span class="comment"># tracer: function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># entries-in-buffer/entries-written: 2/2   #P:3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#                              _-----=&gt; irqs-off</span></span><br><span class="line"><span class="comment">#                             / _----=&gt; need-resched</span></span><br><span class="line"><span class="comment">#                            | / _---=&gt; hardirq/softirq</span></span><br><span class="line"><span class="comment">#                            || / _--=&gt; preempt-depth</span></span><br><span class="line"><span class="comment">#                            ||| /     delay</span></span><br><span class="line"><span class="comment">#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span></span><br><span class="line"><span class="comment">#              | |       |   ||||       |         |</span></span><br><span class="line">     kworker/1:1-59    [001] ....   168.954199: mmc_rescan &lt;-process_one_work</span><br><span class="line">     kworker/1:1-59    [001] ....   168.954248: &lt;stack trace&gt;</span><br><span class="line"> =&gt; mmc_rescan</span><br><span class="line"> =&gt; process_one_work</span><br><span class="line"> =&gt; worker_thread</span><br><span class="line"> =&gt; kthread</span><br><span class="line"> =&gt; ret_from_fork</span><br><span class="line"> =&gt; 0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-6-zhui-zong-te-ding-ko-mo-kuai">3.3.2.6 追踪特定ko模块</span><a href="#3-3-2-6-zhui-zong-te-ding-ko-mo-kuai" class="header-anchor">#</a></h4><p>编译ko需要加上编译参数<code>-pg</code>。否则你在<code>available_filter_functions</code>列表中，查找不到你想要的函数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line">Format: :mod:&lt;module-name&gt;</span><br><span class="line">example: <span class="built_in">echo</span> :mod:ext3 &gt; set_ftrace_filter</span><br></pre></td></tr></table></figure>

<p>追踪<code>ext3</code>模块内的所有函数。</p>
<h4><span id="3-3-2-7-chong-zhi-zhui-zong">3.3.2.7 重置追踪</span><a href="#3-3-2-7-chong-zhi-zhui-zong" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; tracing_on         <span class="comment"># 关闭trace</span></span><br><span class="line"><span class="built_in">echo</span> &gt; trace                <span class="comment"># 清空当前trace记录</span></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-8-shi-jian-zhui-zong">3.3.2.8 事件追踪</span><a href="#3-3-2-8-shi-jian-zhui-zong" class="header-anchor">#</a></h4><p><strong>查看事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@100ask:/sys/kernel/debug/tracing/events<span class="comment"># ls</span></span><br><span class="line">alarmtimer    exceptions    i2c          migrate         power         signal </span><br><span class="line">block         ext4          initcall     mmc             printk        skb                    </span><br><span class="line"><span class="built_in">enable</span>        hyperv        mdio         percpu</span><br><span class="line">    </span><br><span class="line">root@100ask:/sys/kernel/debug/tracing/events/sched<span class="comment"># ls</span></span><br><span class="line"><span class="built_in">enable</span>                  sched_move_numa     sched_process_free  sched_stat_runtime  sched_switch          </span><br><span class="line">filter                  sched_pi_setprio    sched_process_hang  sched_stat_sleep</span><br><span class="line">sched_kthread_stop      sched_process_exec  sched_process_wait  sched_stat_wait</span><br></pre></td></tr></table></figure>

<p><strong>追踪一个&#x2F;若干事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># echo 1 &gt; events/sched/sched_wakeup/enable</span></span><br><span class="line"> ...（省略追踪过程）</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#TASK-PID  CPU#  TIMESTAMP    FUNCTION</span></span><br><span class="line"><span class="comment"># || | |</span></span><br><span class="line">bash-2613 [001] 425.078164: sched_wakeup: task bash:2613 [120] success=0 [001]</span><br><span class="line">bash-2613 [001] 425.078184: sched_wakeup: task bash:2613 [120] success=0 [001]</span><br></pre></td></tr></table></figure>

<p><strong>追踪所有事件</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 1 &gt; events/enable</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat trace | head -10</span></span><br><span class="line"><span class="comment"># tracer: nop</span></span><br><span class="line"><span class="comment">#TASK-PID     CPU#     TIMESTAMP    FUNCTION</span></span><br><span class="line"><span class="comment">#   |                    |                    |                   | </span></span><br><span class="line">cpid-1470       [001]   794.947181:         kfree: call_site=ffffffff810c996d ptr=(null)</span><br><span class="line">acpid-1470     [001] 794.947182:      sys_read -&gt; 0x1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-n-trace-printk-han-shu-shi-yong">3.3.2.n trace_printk函数使用</span><a href="#3-3-2-n-trace-printk-han-shu-shi-yong" class="header-anchor">#</a></h4><p>内核头文件<code> include/linux/kernel.h</code> 中描述了 <code>ftrace </code>提供的工具函数的原型，这些函数包括 <code>trace_printk</code>、<code>tracing_on</code>&#x2F;<code>tracing_off</code> 等。</p>
<h2><span id="3-4-yin-ru-yong-hu-tai-ltrace-he-strace">3.4 引入用户态ltrace和strace</span><a href="#3-4-yin-ru-yong-hu-tai-ltrace-he-strace" class="header-anchor">#</a></h2><h3><span id="3-4-1-ltrace">3.4.1 ltrace</span><a href="#3-4-1-ltrace" class="header-anchor">#</a></h3><p>跟踪进程调用<code>C库函数</code>的情况。</p>
<p>常用的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-a : 对齐具体某个列的返回值。</span><br><span class="line">-c : 计算时间和调用，并在程序退出时打印摘要。</span><br><span class="line">-d : 打印调试信息。</span><br><span class="line">-h : 打印帮助信息。</span><br><span class="line">-i : 打印指令指针，当库调用时。</span><br><span class="line">-l : 只打印某个库中的调用。</span><br><span class="line">-o, --output=file : 把输出定向到文件。</span><br><span class="line">-p : PID 附着在值为PID的进程号上进行ltrace。</span><br><span class="line">-r : 打印相对时间戳。</span><br><span class="line">-S : 显示系统调用。</span><br><span class="line">-t, -tt, -ttt : 打印绝对时间戳。</span><br><span class="line">-T : 输出每个调用过程的时间开销。</span><br><span class="line">-V, --version : 打印版本信息，然后退出。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(arr, <span class="number">2</span>, n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.查看c库调用：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/13.png" alt="image-20240728165618548"></p>
<p>2.查看c库调用次数：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/14.png" alt="image-20240728165742636"></p>
<p>3.查看c库执行时间：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/15.png" alt="image-20240728165842926"></p>
<p>4.查看系统调用情况：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/16.png" alt="image-20240728170027545"></p>
<h3><span id="3-4-2-strace">3.4.2 strace</span><a href="#3-4-2-strace" class="header-anchor">#</a></h3><p>跟踪进程系统调用<code>System Call</code>使用情况。</p>
<p>常用的参数如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等.</span><br><span class="line">-d 输出strace关于标准错误的调试信息.</span><br><span class="line">-f 跟踪由fork调用所产生的子进程.</span><br><span class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.</span><br><span class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.</span><br><span class="line">-h 输出简要的帮助信息.</span><br><span class="line">-i 输出系统调用的入口指针.</span><br><span class="line">-q 禁止输出关于脱离的消息.</span><br><span class="line">-r 打印出相对时间关于,,每一个系统调用.</span><br><span class="line">-t 在输出中的每一行前加上时间信息.</span><br><span class="line">-tt 在输出中的每一行前加上时间信息,微秒级.</span><br><span class="line">-ttt 微秒级输出,以秒了表示时间.</span><br><span class="line">-T 显示每一调用所耗的时间.</span><br><span class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.</span><br><span class="line">-V 输出strace的版本信息.</span><br><span class="line">-x 以十六进制形式输出非标准字符串</span><br><span class="line">-xx 所有字符串以十六进制形式输出.</span><br><span class="line">-a column 设置返回值的输出位置.默认 为40.</span><br><span class="line">-e expr 指定一个表达式,用来控制如何跟踪.格式：[qualifier=][!]value1[,value2]...</span><br><span class="line">qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open 表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\.</span><br><span class="line">-e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.</span><br><span class="line">-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.</span><br><span class="line">-e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5</span><br><span class="line">-e write=set 输出写入到指定文件中的数据.</span><br><span class="line">-o filename 将strace的输出写入文件filename</span><br><span class="line">-p pid 跟踪指定的进程pid.</span><br></pre></td></tr></table></figure>

<p>查看系统调用的时间：</p>
<p><img src="/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/17.png" alt="image-20240728170644866"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/23/Linux%E5%86%85%E6%A0%B8-%E5%BC%82%E5%B8%B8%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88calltrace%E5%88%86%E6%9E%90/" data-id="clzp8utsx000a9oufheasbs2k" data-title="Linux内核-异常输出函数调用栈calltrace分析" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux内核-kmalloc与vmalloc及CMA内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/" class="article-date">
  <time class="dt-published" datetime="2024-07-21T06:45:55.000Z" itemprop="datePublished">2024-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/">Linux内核-kmalloc与vmalloc及CMA内存</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-kmalloc-vmalloc-qu-bie">1 kmalloc&#x2F;vmalloc区别</a><ul>
<li><a href="#1-1-kmalloc-han-shu-yuan-xing">1.1 kmalloc函数原型：</a><ul>
<li><a href="#1-1-1-gpf-flags-han-yi">1.1.1 gpf flags含义</a></li>
</ul>
</li>
<li><a href="#1-2-vmalloc-han-shu-yuan-xing">1.2 vmalloc函数原型：</a></li>
<li><a href="#1-3-nei-cun-shi-fang">1.3 内存释放</a></li>
</ul>
</li>
<li><a href="#2-kmalloc-vmalloc-nei-cun-fen-pei-yuan-li">2 kmalloc&#x2F;vmalloc内存分配原理</a></li>
<li><a href="#3-cma-jie-shao">3 CMA介绍</a><ul>
<li><a href="#3-0-yin-ru-linux-nei-he-buddy-xi-tong">3.0 引入Linux内核Buddy系统</a></li>
<li><a href="#3-1-cma-gai-shu">3.1 CMA概述</a></li>
<li><a href="#3-2-cma-nei-he-shi-neng">3.2 CMA内核使能</a></li>
<li><a href="#3-3-cma-de-ding-yi">3.3 CMA的定义</a></li>
<li><a href="#3-5-cma-nei-cun-yuan-li-he-liu-cheng">3.5 CMA内存原理和流程</a><ul>
<li><a href="#3-5-1-cma-diao-yong-ceng-ci-kuang-jia">3.5.1 CMA调用层次框架</a></li>
<li><a href="#3-5-2-cma-jie-gou-ti">3.5.2 CMA结构体</a></li>
<li><a href="#3-5-3-cma-qu-yu-chu-shi-hua">3.5.3 CMA区域初始化</a><ul>
<li><a href="#3-5-3-0-zheng-ge-memory-chu-shi-hua">3.5.3.0 整个memory初始化</a></li>
<li><a href="#3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua">3.5.3.1 dts描述中cma内存的初始化</a><ul>
<li><a href="#3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup">3.5.3.1.1 全局cma内存初始化rmem_cma_setup</a><ul>
<li><a href="#3-5-3-1-1-1-cma-init-reserved-mem">3.5.3.1.1.1 cma_init_reserved_mem</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua">3.5.3.2 dts没有描述cma内存的初始化</a></li>
</ul>
</li>
<li><a href="#3-5-4-cma-qu-yu-nei-cun-ying-she">3.5.4 CMA 区域内存映射</a><ul>
<li><a href="#3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she">3.5.4.1 dma_contiguous_remap-建立cma area的页表映射</a></li>
</ul>
</li>
<li><a href="#3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun">3.5.5 cma_init_reserved_areas-激活cma area内存</a><ul>
<li><a href="#3-5-5-1-cma-activate-area">3.5.5.1 cma_activate_area</a><ul>
<li><a href="#3-5-5-1-1-init-cma-reserved-pageblock">3.5.5.1.1 init_cma_reserved_pageblock</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-cma-nei-cun-shi-yong">4 CMA内存使用</a><ul>
<li><a href="#4-1-dma-alloc-from-contiguous">4.1 dma_alloc_from_contiguous</a></li>
<li><a href="#4-2-dma-release-from-contiguous">4.2 dma_release_from_contiguous</a></li>
<li><a href="#4-3-cma-alloc">4.3 cma_alloc</a></li>
<li><a href="#4-4-cma-release">4.4 cma_release</a></li>
</ul>
</li>
<li><a href="#5-tong-guo-procfs-cha-kan-cma-area">5 通过procfs查看cma area</a><ul>
<li><a href="#5-1-huo-de-ram-di-zhi-fan-wei">5.1 获得ram地址范围</a></li>
<li><a href="#5-2-huo-de-reserved-memory-fan-wei">5.2 获得reserved-memory范围</a></li>
</ul>
</li>
<li><a href="#6-dts-de-reserved-memory-nei-rong-jie-xi">6 dts的reserved-memory内容解析</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-kmalloc-x2f-vmalloc-qu-bie">1 kmalloc&#x2F;vmalloc区别</span><a href="#1-kmalloc-x2f-vmalloc-qu-bie" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>函数</th>
<th>位置</th>
<th>特性</th>
<th>大小限制</th>
</tr>
</thead>
<tbody><tr>
<td>kmalloc</td>
<td>物理内存映射区域</td>
<td>物理地址虚拟地址均连续</td>
<td>不能超过128K</td>
</tr>
<tr>
<td>kzalloc</td>
<td>物理内存映射区域</td>
<td>物理地址虚拟地址均连续</td>
<td>不能超过128K</td>
</tr>
<tr>
<td>vmalloc</td>
<td>虚拟内存映射区域</td>
<td>虚拟地址连续，物理地址不一定连续</td>
<td>无限制</td>
</tr>
<tr>
<td>vzalloc</td>
<td>虚拟内存映射区域</td>
<td>虚拟地址连续，物理地址不一定连续</td>
<td>无限制</td>
</tr>
</tbody></table>
<p>kzalloc只是相当于附加了 <strong>__GFP_ZERO</strong> 标志。所以它除了申请内核内存外，还会对申请到的内存内容清零。<br>同理，vzalloc也是一样，会对申请内存内容清零。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/1.png" alt="image"></p>
<h2><span id="1-1-kmalloc-han-shu-yuan-xing">1.1 kmalloc函数原型：</span><a href="#1-1-kmalloc-han-shu-yuan-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span>；</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-gpf-flags-han-yi">1.1.1 gpf flags含义</span><a href="#1-1-1-gpf-flags-han-yi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|– 在进程上下文，可以睡眠　　　　　GFP_KERNEL</span><br><span class="line"> |– 在进程上下文，不可以睡眠，如： GFP_ATOMIC</span><br><span class="line"> |　　|– 中断处理程序　　　　　　　GFP_ATOMIC</span><br><span class="line"> |　　|– 软中断　　　　　　　　　　GFP_ATOMIC</span><br><span class="line"> |　　|– Tasklet　　　　　　　　　GFP_ATOMIC</span><br><span class="line"> |– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL</span><br><span class="line"> |– 用于DMA的内存，不可以睡眠　　GFP_DMA |GFP_ATOMIC</span><br></pre></td></tr></table></figure>
<p>如果进程上下文允许睡眠情况下尽量用<code>GFP_KERNEL</code>， 如果进程上下文禁止休眠的话（如中断，taskletd等）必须用<code>GFP_ATOMIC</code></p>
<h2><span id="1-2-vmalloc-han-shu-yuan-xing">1.2 vmalloc函数原型：</span><a href="#1-2-vmalloc-han-shu-yuan-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure>

<p>注意：vmalloc和vfree可以睡眠，因此中断上下文禁止使用。</p>
<h2><span id="1-3-nei-cun-shi-fang">1.3 内存释放</span><a href="#1-3-nei-cun-shi-fang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="2-kmalloc-x2f-vmalloc-nei-cun-fen-pei-yuan-li">2 kmalloc&#x2F;vmalloc内存分配原理</span><a href="#2-kmalloc-x2f-vmalloc-nei-cun-fen-pei-yuan-li" class="header-anchor">#</a></h1><p>slab机制，等后面学习完后介绍。</p>
<h1><span id="3-cma-jie-shao">3 CMA介绍</span><a href="#3-cma-jie-shao" class="header-anchor">#</a></h1><h2><span id="3-0-yin-ru-linux-nei-he-buddy-xi-tong">3.0 引入Linux内核Buddy系统</span><a href="#3-0-yin-ru-linux-nei-he-buddy-xi-tong" class="header-anchor">#</a></h2><p>Linux伙伴系统<code>(Buddy)</code>使用 Page 粒度来管理内存，每个页面大小为4K。伙伴系统按照空闲内存块的长度，把内存挂载到不同长度的 <code>free_list</code>链表中。<code>free_list </code>的单位是以 (<code>2^order个Page</code>) 来递增的，即 <code>1 page、2 page、… 2^n</code>，通常情况下最大 order 为10 对应的空闲内存大小为 4M bytes。我们使用伙伴系统来申请连续的物理页面最大的页面最大小4M bytes。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/4.png" alt="图片"></p>
<p>当系统内存碎片化严重的时候，也很难分配到高order的页面，这时就引入了CMA概念，接着往下看。</p>
<h2><span id="3-1-cma-gai-shu">3.1 CMA概述</span><a href="#3-1-cma-gai-shu" class="header-anchor">#</a></h2><p>连续内存分配器（<code>Contiguous Memory Allocator</code>），简称CMA。在系统长时间运行后，内存可能碎片化，很难找到连续的物理页，CMA很好的避免了这个问题。<br>举个例子：<br>手机上1300万像素的摄像头，一个像素占用3字节，拍摄一张照片需要大约37MB内存。在系统长时间运行后，内存可能碎片化，很难找到连续的物理页，页分配器（kmalloc）和块分配器(vmalloc)很可能无法分配这么大的连续内存块。</p>
<p>方案1：<br>最开始的一种解决方案是为设备保留一块大的内存区域，比如为摄像头驱动预留一块大内存，通过ioremap来映射后作为私有内存使用，缺点是：当设备驱动不使用的时候（大多数时间手机摄像头是空闲的），内核的其他模块不能使用这块内存。<br>方案2：<br>连续内存分配器CMA很好的解决了这个问题，保留一块大的内存区域，当设备驱动不使用的时候，内核的其他模块可以使用。一般我们把这块区域定义为<code>reserved-memory</code>。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/5.png" alt="image"></p>
<h2><span id="3-2-cma-nei-he-shi-neng">3.2 CMA内核使能</span><a href="#3-2-cma-nei-he-shi-neng" class="header-anchor">#</a></h2><p>编译内核时需要开启以下配置宏：<br>（1）配置宏CONFIG_CMA，启用连续内存分配器。<br>（2）配置宏CONFIG_CMA_AREAS，指定CMA区域的最大数量，默认值是7。<br>（3）配置宏CONFIG_DMA_CMA，启用允许设备驱动分配内存的连续内存分配器</p>
<h2><span id="3-3-cma-de-ding-yi">3.3 CMA的定义</span><a href="#3-3-cma-de-ding-yi" class="header-anchor">#</a></h2><p>CMA每个区域实际上就是一个<code>reserved memory</code>。CMA分两种:</p>
<ol>
<li>通用的CMA区域，该区域是给整个系统分配使用的;如下面的<code>&quot;linux,cma&quot;</code></li>
<li>专用的CMA区域，这种是专门为单个模块定义的。如下面的<code>&quot;ion”</code></li>
</ol>
<p>dts中CMA属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> reusable:表示当前的内存区域除了被dma使用之外，还可以被内存管理(buddy)子系统reuse。</span><br><span class="line"><span class="number">2.</span> no-<span class="built_in">map</span>:表示是否需要创建页表映射，对于通用的内存，必须要创建映射才可以使用，共享CMA是可以作为通用内存进行分配使用的，因此必须要创建页表映射。</span><br><span class="line"><span class="number">3.</span> 对于共享的CMA区域，需要配置上linux,cma-<span class="keyword">default</span>属性，标志着它是共享的CMA。</span><br><span class="line"><span class="number">4.</span> alignment：对齐参数，保留内存的起始地址需要向该参数对齐</span><br><span class="line"><span class="number">5.</span> alloc-ranges：指定可以用来申请动态保留内存的区间</span><br></pre></td></tr></table></figure>

<p>下面定义了3段区域CMA:<br>1.全局CMA区域，节点名称是<code>“linux,cma”</code>，大小是2GB，8K对齐。配置上<code>linux,cma-default</code>属性,reusable属性。<br>2.私有CMA区域，节点名字<code>“de_mem0” “de_mem1”</code>，128M给GPU 2D engine使用，私有无需建立页表映射。<br>3.私有CMA区域，节点名字<code>“ion”</code>，给video pipeline使用，私有无需建立页表映射。<br>​	2de模块中定义memory-region属性，并且把对应dts定义的cma节点de_reserved0，de_reserved1传递给该模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">reserved-memory &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line">        ranges;</span><br><span class="line">        cma_reserved: linux,cma &#123;</span><br><span class="line">                compatible = <span class="string">&quot;shared-dma-pool&quot;</span>;</span><br><span class="line">                reusable;<span class="comment">//表示 cma 内存可被 buddy 系统使用</span></span><br><span class="line">                size = &lt;<span class="number">0x0</span> <span class="number">0x80000000</span>&gt;; <span class="comment">// 2GB</span></span><br><span class="line">                alignment = &lt;<span class="number">0x0</span> <span class="number">0x2000</span>&gt;; <span class="comment">// 8KB</span></span><br><span class="line">                linux,cma-<span class="keyword">default</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        de_reserved0: de_mem0 &#123;</span><br><span class="line">                        reg = &lt;<span class="number">0x1</span> <span class="number">0x10000000</span> <span class="number">0x0</span> <span class="number">0x8000000</span>&gt;; <span class="comment">// 128M, for 2de</span></span><br><span class="line">                        no-<span class="built_in">map</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        de_reserved1: de_mem1 &#123;</span><br><span class="line">                        reg = &lt;<span class="number">0x1</span> <span class="number">0x18000000</span> <span class="number">0x0</span> <span class="number">0x8000000</span>&gt;; <span class="comment">// 128M, for 2de</span></span><br><span class="line">                        no-<span class="built_in">map</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        ion_reserved: ion &#123;</span><br><span class="line">                compatible = <span class="string">&quot;ion-region&quot;</span>;</span><br><span class="line">                size = &lt;<span class="number">0x0</span> <span class="number">0x04000000</span>&gt;; <span class="comment">// 64MB</span></span><br><span class="line">        &#125;;</span><br><span class="line">        vo_2de0 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;sophgo,vg-lite0&quot;</span>;</span><br><span class="line">                memory-region = &lt;&amp;de_reserved0&gt;;</span><br><span class="line">                interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">27</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                interrupt-names = <span class="string">&quot;vo_2de0&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        vo_2de1 &#123;</span><br><span class="line">                compatible = <span class="string">&quot;sophgo,vg-lite1&quot;</span>;</span><br><span class="line">                memory-region = &lt;&amp;de_reserved1&gt;;</span><br><span class="line">                interrupt-parent = &lt;&amp;gic&gt;;</span><br><span class="line">                interrupts = &lt;GIC_SPI <span class="number">28</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">                interrupt-names = <span class="string">&quot;vo_2de1&quot;</span>;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-5-cma-nei-cun-yuan-li-he-liu-cheng">3.5 CMA内存原理和流程</span><a href="#3-5-cma-nei-cun-yuan-li-he-liu-cheng" class="header-anchor">#</a></h2><p>设备驱动程序不能直接使用连续内存分配器，而是调用DMA映射框架来使用连续内存分配器CMA。</p>
<h3><span id="3-5-1-cma-diao-yong-ceng-ci-kuang-jia">3.5.1 CMA调用层次框架</span><a href="#3-5-1-cma-diao-yong-ceng-ci-kuang-jia" class="header-anchor">#</a></h3><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/6.png" alt="image"></p>
<ol>
<li>最底层为<code>页分配器（以后分析）</code>。</li>
<li>cma_alloc用来从CMA区域分配页，cma_release用来释放从CMA区域分配的页。</li>
<li>第3层为DMA映射框架专用的连续内存分配器，简称DMA专用连续内存分配器，提供的接口<code>dma_alloc_from_contiguous</code>用来从CMA区域分配页，接口<code>dma_release_from_contiguous</code>用来释放从CMA区域分配的页。</li>
<li>第4层就是DMA通用映射框架，供驱动程序调用<code>dma_alloc_coherent</code>和<code>dma_alloc_noncoherent</code>用来分配内存，接口<code>dma_free_coherent</code>和<code>dma_free_noncoherent</code>用来释放内存。</li>
</ol>
<h3><span id="3-5-2-cma-jie-gou-ti">3.5.2 CMA结构体</span><a href="#3-5-2-cma-jie-gou-ti" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mm/cma.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> &#123;</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    base_pfn; <span class="comment">//该CMA区域的起始页帧号</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    count; <span class="comment">//该cma区域的页数</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span>    *bitmap; <span class="comment">//位图，每个位描述对应的页的分配状态，0表示空闲，1表示已分配</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> order_per_bit;<span class="comment">//位图中的每个位描述的物理页的阶数，目前取值为0，表示每个位描述一页</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>     <span class="title">lock</span>;</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mm/cma.c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cma</span> <span class="title">cma_areas</span>[<span class="title">MAX_CMA_AREAS</span>];</span><span class="comment">//定义多个CMA区域。</span></span><br><span class="line"><span class="type">unsigned</span> cma_area_count;<span class="comment">//表示实际使用的cma区域数量</span></span><br></pre></td></tr></table></figure>

<p>cma模块使用bitmap来管理其内存的分配，0表示free，1表示已经分配。</p>
<p>重点解释<code>order_per_bit</code>:如果<code>order_per_bit</code>等于0，表示按照一个一个page来分配和释放，如果<code>order_per_bit</code>等于1，表示按照2个page组成的block来分配和释放，以此类推。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/7.png" alt="image-20240721215512066"></p>
<p>上图<code>cma_area[0]的.order_per_bit = 1</code>,对应2个page，起始页帧号为0x2000, 0x400个页数，对应size为<code>0x400 *2* 2K = 4M</code></p>
<p>刚好对应4M。</p>
<h3><span id="3-5-3-cma-qu-yu-chu-shi-hua">3.5.3 CMA区域初始化</span><a href="#3-5-3-cma-qu-yu-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="3-5-3-0-zheng-ge-memory-chu-shi-hua">3.5.3.0 整个memory初始化</span><a href="#3-5-3-0-zheng-ge-memory-chu-shi-hua" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;setup_machine_fdt</span><br><span class="line">            ------&gt;early_init_dt_scan_nodes</span><br><span class="line">                ------&gt;of_scan_flat_dt</span><br><span class="line">                    ------&gt;early_init_dt_scan_memory</span><br><span class="line">                        ------&gt;early_init_dt_add_memory_arch</span><br><span class="line">                            ------&gt;memblock_add</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/8.png" alt="image-20240721223712191"></p>
<h4><span id="3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua">3.5.3.1 dts描述中cma内存的初始化</span><a href="#3-5-3-1-dts-miao-shu-zhong-cma-nei-cun-de-chu-shi-hua" class="header-anchor">#</a></h4><p>linux内核首先需要解析dtb中节点<code>“memory”</code>，把内存块添加到<code>memblock</code>的memory类型，memory类型保存内存块的物理地址范围，reserved类型保存保留内存块的物理地址范围，CMA区域就属于保留内存块。<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/9.png" alt="image"><br>创建CMA区域的执行流程如下所示：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;arm_memblock_init</span><br><span class="line">            ------&gt;early_init_fdt_scan_reserved_mem</span><br><span class="line">                ------&gt;of_scan_flat_dt</span><br><span class="line">                     ------&gt; __fdt_scan_reserved_mem</span><br><span class="line">                        ------&gt; fdt_init_reserved_mem</span><br><span class="line">                            ------&gt; memblock_add</span><br></pre></td></tr></table></figure>

<p>linux内核启动时，当调用到<code>__reserved_mem_init_node</code>时会调用所有使用<code>RESERVEDMEM_OF_DECLARE</code>声明的CMA区域。</p>
<p><code>__reserved_mem_init_node</code>会遍历<code>__reservedmem_of_table section</code>中的内容，检查到dts中有compatible匹配（CMA这里为“shared-dma-pool”）就进一步执行对应的<code>initfn</code>。通过<code>RESERVEDMEM_OF_DECLARE</code>定义的都会被链接到<code>__reservedmem_of_table</code>这个section段中，最终会调到使用<code>RESERVEDMEM_OF_DECLAR</code>E定义的函数:</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/11.png" alt="image-20240721190202046"></p>
<p>其中全局CMA区域的初始化函数是<code>rmem_cma_setup</code>：</p>
<h5><span id="3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup">3.5.3.1.1 全局cma内存初始化rmem_cma_setup</span><a href="#3-5-3-1-1-quan-ju-cma-nei-cun-chu-shi-hua-rmem-cma-setup" class="header-anchor">#</a></h5><p><code>rmem_cma_setup</code>的作用就是将<code>reserved-memory</code>添加到cma子系统：</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/12.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rmem_cma_setup</span><br><span class="line">    |------&gt;cma_init_reserved_mem       <span class="comment">// 将reserved-memory 添加到cma_areas数组中</span></span><br><span class="line">    |------&gt;dma_contiguous_early_fixup<span class="comment">// dma remap</span></span><br><span class="line">    |------&gt;dma_contiguous_set_default<span class="comment">// set_default cma area</span></span><br></pre></td></tr></table></figure>

<h6><span id="3-5-3-1-1-1-cma-init-reserved-mem">3.5.3.1.1.1 cma_init_reserved_mem</span><a href="#3-5-3-1-1-1-cma-init-reserved-mem" class="header-anchor">#</a></h6><p>来看调用的cma_init_reserved_mem：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/13.png" alt="image"><br>从数组<code>cma_areas</code>分配一个数组项，保存CMA区域的起始页帧号和页数。dts指定了属性<code>“linux,cma-default”</code>，那么这个CMA区域是默认的CMA区域，最后设置全局变量<code>dma_contiguous_default_area</code>指向这个CMA区域(默认全局CMA区域)<br>红色圈出了该cma区域的dts描述和dts是不是完全吻合。</p>
<h4><span id="3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua">3.5.3.2 dts没有描述cma内存的初始化</span><a href="#3-5-3-2-dts-mei-you-miao-shu-cma-nei-cun-de-chu-shi-hua" class="header-anchor">#</a></h4><p>如果内核参数或配置宏配置全局CMA区域，cma初始化则流程如下所示：<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/14.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/15.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/16.png" alt="image"></p>
<h3><span id="3-5-4-cma-qu-yu-nei-cun-ying-she">3.5.4 CMA 区域内存映射</span><a href="#3-5-4-cma-qu-yu-nei-cun-ying-she" class="header-anchor">#</a></h3><p>CMA 区域创建初始化完后还不能直接使用，需要单独进行页表映射。前面：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17995165">linux内核-3.Linux 内核启动流程 - fuzidage - 博客园 (cnblogs.com)</a> <code>2.1.1.1.1 start_kernel</code></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/#2-1-1-1-1-start-kernel">Linux内核启动流程 | Hexo (fuzidage.github.io)</a></p>
<p>小结有介绍start_kernel启动流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">    ------&gt;setup_arch</span><br><span class="line">        ------&gt;paging_init<span class="comment">//建立页表映射，包括非保留内存和保留内存。</span></span><br><span class="line">            ------&gt;dma_contiguous_remap</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she">3.5.4.1 dma_contiguous_remap-建立cma area的页表映射</span><a href="#3-5-4-1-dma-contiguous-remap-jian-li-cma-area-de-ye-biao-ying-she" class="header-anchor">#</a></h4><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/17.png" alt="image-20240721230004292"></p>
<p><code>prepare_page_table</code>负责普通内存的页表映射。<code>dma_contiguous_remap</code>建立<code>cma area</code>的页表映射:</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/18.png" alt="image-20240721231037582"></p>
<h3><span id="3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun">3.5.5 cma_init_reserved_areas-激活cma area内存</span><a href="#3-5-5-cma-init-reserved-areas-ji-huo-cma-area-nei-cun" class="header-anchor">#</a></h3><p><code>cma_activate_area</code>函数用于将 CMA 区域内的预留页全部释放添加到 Buddy 管理器内，然后激活 CMA 区域供系统使用。</p>
<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/19.png" alt="image-20240721174230275"></p>
<h4><span id="3-5-5-1-cma-activate-area">3.5.5.1 cma_activate_area</span><a href="#3-5-5-1-cma-activate-area" class="header-anchor">#</a></h4><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/20.png" alt="image-20240721232741149"></p>
<h5><span id="3-5-5-1-1-init-cma-reserved-pageblock">3.5.5.1.1 init_cma_reserved_pageblock</span><a href="#3-5-5-1-1-init-cma-reserved-pageblock" class="header-anchor">#</a></h5><p>cma默认是从<code>reserved memory</code>中分配的，通常情况这块内存是直接分配并预留不做任何使用，无形之中造成了浪费。所以在不用的时候放入伙伴系统，作为普通内存使用。</p>
<h1><span id="4-cma-nei-cun-shi-yong">4 CMA内存使用</span><a href="#4-cma-nei-cun-shi-yong" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>   *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">page = cma_alloc(dev_get_cma_area(dev)，mem_size, <span class="number">0</span>, GFP_KERNEL);</span><br></pre></td></tr></table></figure>

<p><code>dev_get_cma_area</code>可以获取对应的cma handler，如果获取不到，比如对应模块中并未定义memory-region，那么就会返回共享的<code>cma handler</code>，还记的上面的<code> linux,cma-default</code>属性吗，共享cma区域会被作为缺省cma来使用。</p>
<h2><span id="4-1-dma-alloc-from-contiguous">4.1 dma_alloc_from_contiguous</span><a href="#4-1-dma-alloc-from-contiguous" class="header-anchor">#</a></h2><h2><span id="4-2-dma-release-from-contiguous">4.2 dma_release_from_contiguous</span><a href="#4-2-dma-release-from-contiguous" class="header-anchor">#</a></h2><p>不过一般内核模块要使用CMA内存时，使用的接口依然是dma的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flag)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr, <span class="type">dma_addr_t</span> dma_handle)</span>;</span><br></pre></td></tr></table></figure>

<p>最终也会进入<code>dma_alloc_from_contiguous</code>调用<code>cma_alloc</code>分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">dma_alloc_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">bool</span> no_warn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (align &gt; CONFIG_CMA_ALIGNMENT)</span><br><span class="line">		align = CONFIG_CMA_ALIGNMENT;</span><br><span class="line">	<span class="keyword">return</span> cma_alloc(dev_get_cma_area(dev), count, align, no_warn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">dma_release_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> page *pages,</span></span><br><span class="line"><span class="params">	 <span class="type">int</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> cma_release(dev_get_cma_area(dev), pages, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_alloc() - allocate pages from contiguous area</span></span><br><span class="line"><span class="comment"> * @cma:   Contiguous memory region for which the allocation is performed.</span></span><br><span class="line"><span class="comment"> * @count: Requested number of pages.</span></span><br><span class="line"><span class="comment"> * @align: Requested alignment of pages (in PAGE_SIZE order).</span></span><br><span class="line"><span class="comment"> * @no_warn: Avoid printing message about failed allocation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function allocates part of contiguous memory on specific</span></span><br><span class="line"><span class="comment"> * contiguous memory area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">cma_alloc</span><span class="params">(<span class="keyword">struct</span> cma *cma, <span class="type">size_t</span> count, <span class="type">unsigned</span> <span class="type">int</span> align,</span></span><br><span class="line"><span class="params">			   <span class="type">bool</span> no_warn)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">dma_addr_t</span> *dma_handle, <span class="type">gfp_t</span> flag)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">dma_free_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size, <span class="type">void</span> *cpu_addr, <span class="type">dma_addr_t</span> dma_handle)</span>;</span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">dma_alloc_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> count,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">int</span> align, <span class="type">bool</span> no_warn)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">dma_release_from_contiguous</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> page *pages,</span></span><br><span class="line"><span class="params">	 <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>
<h2><span id="4-3-cma-alloc">4.3 cma_alloc</span><a href="#4-3-cma-alloc" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/21.png" alt="图片"></p>
<p>从指定的CMA 区域上分配count个连续的页面，按照align对齐。</p>
<h2><span id="4-4-cma-release">4.4 cma_release</span><a href="#4-4-cma-release" class="header-anchor">#</a></h2><p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/22.png" alt="图片"></p>
<p>释放已经分配count个连续的页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cma_release() - release allocated pages</span></span><br><span class="line"><span class="comment"> * @cma:   Contiguous memory region for which the allocation is performed.</span></span><br><span class="line"><span class="comment"> * @pages: Allocated pages.</span></span><br><span class="line"><span class="comment"> * @count: Number of allocated pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function releases memory allocated by cma_alloc().</span></span><br><span class="line"><span class="comment"> * It returns false when provided pages do not belong to contiguous area and</span></span><br><span class="line"><span class="comment"> * true otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">cma_release</span><span class="params">(<span class="keyword">struct</span> cma *cma, <span class="type">const</span> <span class="keyword">struct</span> page *pages, <span class="type">unsigned</span> <span class="type">int</span> count)</span>；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/23.png" alt="image-20240721213654864"></p>
<h1><span id="5-tong-guo-procfs-cha-kan-cma-area">5 通过procfs查看cma area</span><a href="#5-tong-guo-procfs-cha-kan-cma-area" class="header-anchor">#</a></h1><h2><span id="5-1-huo-de-ram-di-zhi-fan-wei">5.1 获得ram地址范围</span><a href="#5-1-huo-de-ram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>第一个比较重要的是获得系统物理内存的范围：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/iomem </span><br><span class="line">10000000-17ffffff : System RAM</span><br><span class="line">  10008000-107fffff : Kernel code</span><br><span class="line">  10900000-10960677 : Kernel data</span><br><span class="line">40002000-4000201f : serial</span><br><span class="line">4000a000-4000a01f : codec@4000a000</span><br><span class="line">40010000-40011fff : i2c0@40010000</span><br><span class="line">40014000-4001401f : serial</span><br><span class="line">40016000-4001601f : serial</span><br><span class="line">40020000-40021fff : i2c2@40020000</span><br><span class="line">4003a000-4003a01f : wdt0@4003a000</span><br><span class="line">40056000-40056fff : video0@40056000</span><br><span class="line">4005a000-4005bfff : dma0@4005a000</span><br><span class="line">40064000-40064fff : video1@40064000</span><br><span class="line">40068000-40069fff : dma1@40068000</span><br><span class="line">4006a000-4006a1ff : lsacc2d@4006a000</span><br><span class="line">40080000-40081fff : clock@40080000</span><br><span class="line">40082000-40082027 : msgunit@40082000</span><br><span class="line">400a0000-400a00ff : mmc0@400a0000</span><br><span class="line">400aa000-400aa1ff : gauss@400aa000</span><br></pre></td></tr></table></figure>

<p>到 <strong>“System RAM”</strong>, 其代表系统物理内存的起始物理地址和终止物理地址。</p>
<h2><span id="5-2-huo-de-reserved-memory-fan-wei">5.2 获得reserved-memory范围</span><a href="#5-2-huo-de-reserved-memory-fan-wei" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/kernel/debug/memblock/reserved </span><br><span class="line">   0: 0x10004000..0x10007fff</span><br><span class="line">   1: 0x10100000..0x10960677</span><br><span class="line">   2: 0x12000000..0x127fffff</span><br><span class="line">   3: 0x1579b000..0x157a1fff</span><br><span class="line">   4: 0x17ea1cc0..0x17eb9fc3</span><br><span class="line">   5: 0x17eba000..0x17ee0fff</span><br><span class="line">   6: 0x17ee3180..0x17ee347f</span><br><span class="line">   7: 0x17ee34b0..0x17ffefff</span><br><span class="line">   8: 0x17fff100..0x17fff177</span><br><span class="line">   9: 0x17fff180..0x17fff1c4</span><br><span class="line">  10: 0x17fff200..0x17fff23b</span><br><span class="line">  11: 0x17fff240..0x17fff3c3</span><br><span class="line">  12: 0x17fff400..0x17fff5c4</span><br><span class="line">  13: 0x17fff600..0x17fff677</span><br><span class="line">  14: 0x17fff680..0x17fff68b</span><br><span class="line">  15: 0x17fff6c0..0x17fff6cb</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>通过这个命令可以知道系统已预留的内存信息，这些已预留的内存信息不可使用。</p>
<h1><span id="6-dts-de-reserved-memory-nei-rong-jie-xi">6 dts的reserved-memory内容解析</span><a href="#6-dts-de-reserved-memory-nei-rong-jie-xi" class="header-anchor">#</a></h1><p>通常使用memory-region将设备和reserved memory 关联起，cvifb 通过 memory-region 关联到 fb_reserved 这块 reserved memory 上面.<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/24.png" alt="image"><br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/25.png" alt="image"><br>通过<code>cvifb</code>节点的<code>memory-region</code>属性找到<code>reserved-memory</code>，<code>of_reserved_mem_lookup</code>根据关联的<code>reserved-momory</code>节点找到预留内存地址.<br><img src="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/26.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/" data-id="clzp8utst00019ouferc5aiph" data-title="Linux内核-kmalloc与vmalloc及CMA内存" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux内核-并发与同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2024-07-20T13:04:31.000Z" itemprop="datePublished">2024-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/">Linux内核-并发与同步</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-bing-fa-chang-jing">1 并发场景</a></li>
<li><a href="#2-bing-fa-jie-jue-fang-an">2 并发解决方案</a><ul>
<li><a href="#2-1-nei-cun-ping-zhang">2.1 内存屏障</a><ul>
<li><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</a></li>
<li><a href="#2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</a><ul>
<li><a href="#2-1-2-1-barrier">2.1.2.1 barrier</a></li>
<li><a href="#2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</a></li>
<li><a href="#2-1-2-3-read-once">2.1.2.3 READ_ONCE()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-yuan-zi-cao-zuo">2.2 原子操作</a><ul>
<li><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</a></li>
<li><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</a></li>
<li><a href="#2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</a></li>
</ul>
</li>
<li><a href="#2-3-zi-xuan-suo">2.3 自旋锁</a><ul>
<li><a href="#2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</a><ul>
<li><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</a></li>
</ul>
</li>
<li><a href="#2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</a></li>
<li><a href="#2-3-3-shun-xu-suo">2.3.3 顺序锁</a></li>
</ul>
</li>
<li><a href="#2-4-xin-hao-liang">2.4 信号量</a><ul>
<li><a href="#2-4-1-xin-hao-liang-api">2.4.1 信号量 API</a></li>
</ul>
</li>
<li><a href="#2-5-hu-chi-suo">2.5 互斥锁</a><ul>
<li><a href="#2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</a></li>
</ul>
</li>
<li><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</a><ul>
<li><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</a></li>
<li><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</a></li>
<li><a href="#2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</a></li>
<li><a href="#2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</a></li>
<li><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</a><ul>
<li><a href="#2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-bing-fa-chang-jing">1 并发场景</span><a href="#1-bing-fa-chang-jing" class="header-anchor">#</a></h1><p>Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原 因：</p>
<ol>
<li>多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。</li>
<li>抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以 在任意时刻抢占正在运行的线程，从而运行其他的线程。 </li>
<li>中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可 是很大的。</li>
<li>SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并 发访问。</li>
</ol>
<h1><span id="2-bing-fa-jie-jue-fang-an">2 并发解决方案</span><a href="#2-bing-fa-jie-jue-fang-an" class="header-anchor">#</a></h1><h2><span id="2-1-nei-cun-ping-zhang">2.1 内存屏障</span><a href="#2-1-nei-cun-ping-zhang" class="header-anchor">#</a></h2><h3><span id="2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</span><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w0, [x0]       <span class="comment">//load b to w0</span></span><br><span class="line">    add w1, w0, #<span class="number">0x1</span></span><br><span class="line">    ...</span><br><span class="line">    str w1, [x0]       <span class="comment">//a = b + 1</span></span><br><span class="line">    ...</span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure>

<p>我们把编译优化打开到-O2，再次反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    add w0, w2, #<span class="number">0x1</span></span><br><span class="line">    str w0, [x1]       <span class="comment">//a = b + 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到编译器 ”自作聪明“， b被提前赋值了。因此要使用内存屏障。</p>
<h3><span id="2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</span><a href="#2-1-2-nei-cun-ping-zhang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barrier();</span><br><span class="line">cpu_relax();</span><br><span class="line">READ_ONCE(val);</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-1-barrier">2.1.2.1 barrier</span><a href="#2-1-2-1-barrier" class="header-anchor">#</a></h4><p>前面用-O2选项顺序会被错误的排列。加入<code>barrier();//插入内存屏障</code>，再次反汇编可以看到OK符合我们的逻辑了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line"> 	barrier();<span class="comment">//插入内存屏障</span></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反汇编如下：</span></span><br><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    add w2, w2, #<span class="number">0x1</span></span><br><span class="line">    str w2, [x1]       <span class="comment">//a = a + 1</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</span><a href="#2-1-2-2-cpu-relax" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 是个全局变量，foo() 在一个进程中执行，一直循环。我们期望的结果是 foo() 一直等到其他进程修改 run 的值为 0 才退出循环。反汇编看看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000748</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">748</span>: <span class="number">90000080</span> adrp x0, <span class="number">10000</span></span><br><span class="line"><span class="number">74</span>c: f947e800 ldr x0, [x0, #<span class="number">4048</span>]</span><br><span class="line"><span class="number">750</span>: b9400000 ldr w0, [x0]            <span class="comment">//load run to w0</span></span><br><span class="line"><span class="number">754</span>: d503201f nop</span><br><span class="line"><span class="number">758</span>: <span class="number">35000000</span> cbnz w0, <span class="number">758</span> &lt;foo+<span class="number">0x10</span>&gt; <span class="comment">//if (w0) while (1);</span></span><br><span class="line"><span class="number">75</span>c: d65f03c0 ret</span><br></pre></td></tr></table></figure>

<p>但实际上编译器帮我们优化成了等效下面的样子：这样永远也不会退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg = run;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (reg)</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此加上内存屏障如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-3-read-once">2.1.2.3 READ_ONCE()</span><a href="#2-1-2-3-read-once" class="header-anchor">#</a></h4><p>也可用这种方式作为内存屏障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (READ_ONCE(run)) <span class="comment">/* similar to while (*(volatile int *)&amp;run) */</span></span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-yuan-zi-cao-zuo">2.2 原子操作</span><a href="#2-2-yuan-zi-cao-zuo" class="header-anchor">#</a></h2><h3><span id="2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</span><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru" class="header-anchor">#</a></h3><p>所谓的临界区就是共享数据段，如全局变量，对于临界区必须保证一次只有一个线程访问，也就是要保证临 界区是原子访问的。我们都知道，原子是化学反应不可再分的基本微粒，这里的原子访问就表示这一个访问是一个步骤，不能再进行拆分。</p>
<p>示例1：</p>
<p><code>a=3;</code></p>
<p>假设变量 a 的地址为 0X3000000，“a&#x3D;3”这一行 C 语言可能会被编译为如下所示的汇编代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr r0, =<span class="number">0X30000000</span> <span class="comment">/* 变量 a 地址 */</span></span><br><span class="line"><span class="number">2</span> ldr r1, = <span class="number">3</span> <span class="comment">/* 要写入的值 */</span></span><br><span class="line"><span class="number">3</span> str r1, [r0] <span class="comment">/* 将 3 写入到 a 变量中 */</span></span><br></pre></td></tr></table></figure>

<p>如果多线程同时执行这条语句。我们期望的执行顺序：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/1.png" alt="image"></p>
<p>实际执行顺序可能是：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/2.png" alt="image"></p>
<p>线程 A 最终将变量 a 设置为了 20，而并不是要求的 10线程 B 没有问题，是期望的a设置成了20，这就是并发竞态。我们希望三条汇编指令一次性执行完，不被打断和拆解，这就是原子操作。</p>
<h2><span id></span><a href="#" class="header-anchor">#</a></h2><h3><span id="2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</span><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"><span class="type">atomic_t</span> b = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//定义原子变量 b 并赋初值为 0</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;b, <span class="number">10</span>); <span class="comment">/* 设置 b=10 */</span></span><br><span class="line"><span class="type">atomic_read</span>(&amp;b); <span class="comment">/* 读取 b 的值，肯定是 10 */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;b); <span class="comment">/* b 的值加 1，v=11 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"><span class="type">atomic64_t</span> c = ATOMIC64_INIT(<span class="number">0</span>); <span class="comment">//定义64位系统原子变量 c 并赋初值为 0</span></span><br><span class="line"><span class="comment">//注意：如果使用的是64 位的 SOC，那么建议使用 64 位的原子操作函数。Cortex-A7 (armv7)是 32 位的架构，Cortex-A53（armv8）64位架构。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化。</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取 v 的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向 v 写入 i 值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>给 v 加上 i 值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>从 v 减去 i 值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>给 v 加 1，也就是自增。</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>从 v 减 1，也就是自减</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>从 v 减 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>给 v 加 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_add_return(int i, atomic_t *v)</td>
<td>给 v 加 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_sub_return(int i, atomic_t *v)</td>
<td>给 v 减 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>从 v 减 i，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>从 v 减 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>给 v 加 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>给 v 加 i，如果结果为负就返回真，否则返回假</td>
</tr>
<tr>
<td>atomic_cmpxchg(atomic_t *ptr, int old, int new)</td>
<td>比较old和原子变量ptr中的值，如果相等，那么就把new值赋给原子变量。返回旧的原子变量ptr中的值</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_dec_and_test(&amp;gpioled.lock)) &#123;</span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;gpioled.lock);<span class="comment">/* 小于 0 的话就加 1,使其原子变量等于 0 */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY; <span class="comment">/* LED 被使用，返回忙 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭驱动文件的时候释放原子变量 */</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;dev-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;gpioled.lock, <span class="number">1</span>); <span class="comment">/* 原子变量初始值为 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子用来实现一次只能允许一个应用访问 LED 灯，不能多个进程同时操作LED。第一个用户程序进行open,成功此时原子值counter&#x3D;0，第二个用户程序进行open就会fail, 直到第一个用户程序close, counter会进行加一，此时第二个程序才可以open成功。</p>
<h3><span id="2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</span><a href="#2-2-2-wei-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><p>原 子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<h2><span id="2-3-zi-xuan-suo">2.3 自旋锁</span><a href="#2-3-zi-xuan-suo" class="header-anchor">#</a></h2><p>原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形 变量或位这么简单的临界区。</p>
<p>自旋锁的定义：</p>
<p>对于自旋锁而言，如果自旋锁 正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线 程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁 可用。比如现在有个公用电话亭，一次肯定只能进去一个人打电话，现在电话亭里面有人正在 打电话，相当于获得了自旋锁。此时你到了电话亭门口，因为里面有人，所以你不能进去打电 话，相当于没有获取自旋锁，这个时候你肯定是站在原地等待，你可能因为无聊的等待而转圈 圈消遣时光，反正就是哪里也不能去，要一直等到里面的人打完电话出来。终于，里面的人打 完电话出来了，相当于释放了自旋锁，这个时候你就可以使用电话亭打电话了，相当于获取到 了自旋锁。</p>
<p> 自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以 用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a&#x3D;1 的时候表示共享资源可用，当 a&#x3D;0 的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a&#x3D;0(自旋锁被其他线程持有)， 那么线程 A 就会不断的查询 a 的值，直到 a&#x3D;1。可</p>
<p><code>缺点：获取自旋锁会原地等待，会浪费处理器时间，降低系统性能，所以自旋锁 的持有时间不能太长。如果临界区比较大，运行时间比较长的话要选择信号量和互斥体。</code></p>
<p><code>适用范围：适用于短时期的轻量级加锁。</code></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/3.png" alt="image"></p>
<h3><span id="2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</span><a href="#2-3-1-zi-xuan-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化一个自选变量。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0。</td>
</tr>
</tbody></table>
<p>被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的 API 函数，否则的话会可能会导致死锁现象（不能带锁休眠）。因为自旋锁会禁止抢占，也就说当线程 A 得到锁以后会暂时禁止内核抢占，那既然禁止内核抢占自己又休眠了，粗俗的形容就是“占着茅坑不拉屎”，自己休眠了又没有释放锁就导致死锁。</p>
<h4><span id="2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</span><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan" class="header-anchor">#</a></h4><p>中断里面访问临界资源，也是可以使用自旋锁的，但是在获取锁之前一定要先禁止本地中断。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t*lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁</td>
</tr>
</tbody></table>
<p>如下图就是没有禁止本地中断导致死锁的例子：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/4.png" alt="image"></p>
<p>线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 <code>functionA </code>函 数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁， 但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着， 死锁发生！</p>
<p>使用<code> spin_lock_irq/spin_unlock_irq</code> 的时候需要用户能够确定加锁之前的中断状态，但实际上我们是很难确定某个时刻的中断状态，因此不推荐使用<code> spin_lock_irq/spin_unlock_irq</code>。建议使用 <code>spin_lock_irqsave/spin_unlock_irqrestore</code>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用<code> spin_lock_irqsave/ spin_unlock_irqrestore</code>，在中断中使用<code> spin_lock/spin_unlock</code>，例如下面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line"><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 中断状态 */</span></span><br><span class="line">	spin_lock_irqsave(&amp;lock, flags); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock_irqrestore(&amp;lock, flags); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq</span><span class="params">()</span> &#123;</span><br><span class="line">	spin_lock(&amp;lock); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock(&amp;lock); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人说为什么中断服务程序不去使用<code>spin_lock_irqsave</code>呢？ 难道不需要去禁止中断吗？</p>
<p>因为GIC中断总入口已经帮我们做了禁止中断。调用了<code>local_irq_disable()</code>,详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/5.png" alt="image"></p>
<p>如果下半部(BH)也会竞争共享资源，要在下半部里面使用自旋锁:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，并获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，并释放自旋锁</td>
</tr>
</tbody></table>
<h3><span id="2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</span><a href="#2-3-2-du-xie-zi-xuan-suo" class="header-anchor">#</a></h3><p>读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁， 可以进行并发的读操作。Linux 内核使用 rwlock_t 结构体表示读写锁，结构体定义如下(删除了 条件编译)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">arch_rwlock_t</span> raw_lock;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>现在有个学生信息表，此表存放着学生的年龄、家庭住址、班级等信息，此表可以随时被 修改和读取，那么必须要对其进行保护，如果我们现在使用自旋锁对其进行 保护。每次只能一个读操作或者写操作，但是，实际上此表是可以并发读取的。只需要保证在 修改此表的时候没人读取，或者在其他人读取此表的时候没有人修改此表就行了。也就是此表 的读和写不能同时进行，但是可以多人并发的读取此表。像这样，当某个数据结构符合读&#x2F;写或 生产者&#x2F;消费者模型的时候就可以使用读写自旋锁。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_RWLOCK(rwlock_t lock)</td>
<td>定义并初始化读写锁</td>
</tr>
<tr>
<td>void rwlock_init(rwlock_t *lock)</td>
<td>初始化读写锁。</td>
</tr>
<tr>
<td>读操作</td>
<td></td>
</tr>
<tr>
<td>void read_lock(rwlock_t *lock)</td>
<td>获取读锁。</td>
</tr>
<tr>
<td>void read_unlock(rwlock_t *lock)</td>
<td>释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irqsave(rwlock_t *lock, unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void read_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
<tr>
<td>写操作</td>
<td></td>
</tr>
<tr>
<td>void write_lock(rwlock_t *lock)</td>
<td>获取写锁。</td>
</tr>
<tr>
<td>void write_unlock(rwlock_t *lock)</td>
<td>释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取写锁。</td>
</tr>
<tr>
<td>void write_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irqsave(rwlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写锁</td>
</tr>
<tr>
<td>void write_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void write_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void write_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
</tbody></table>
<h3><span id="2-3-3-shun-xu-suo">2.3.3 顺序锁</span><a href="#2-3-3-shun-xu-suo" class="header-anchor">#</a></h3><p>顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 		<span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> <span class="title">seqcount</span>;</span></span><br><span class="line"> 		<span class="type">spinlock_t</span> lock;</span><br><span class="line">&#125; <span class="type">seqlock_t</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEQLOCK(seqlock_t sl)</td>
<td>定义并初始化顺序锁</td>
</tr>
<tr>
<td>void seqlock_ini seqlock_t *sl)</td>
<td>初始化顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock(seqlock_t *sl)</td>
<td>获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock(seqlock_t *sl)</td>
<td>释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irq(seqlock_t *sl)</td>
<td>禁止本地中断，并且获取写顺序锁</td>
</tr>
<tr>
<td>void write_sequnlock_irq(seqlock_t *sl)</td>
<td>打开本地中断，并且释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irqsave(seqlock_t *sl,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock_irqrestore(seqlock_t *sl,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_bh(seqlock_t *sl)</td>
<td>关闭下半部，并获取写读锁。</td>
</tr>
<tr>
<td>void write_sequnlock_bh(seqlock_t *sl)</td>
<td>打开下半部，并释放写读锁。</td>
</tr>
<tr>
<td>unsigned read_seqbegin(const seqlock_t *sl)</td>
<td>读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号。</td>
</tr>
<tr>
<td>unsigned read_seqretry(const seqlock_t *sl,unsigned start)</td>
<td>读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读</td>
</tr>
</tbody></table>
<h2><span id="2-4-xin-hao-liang">2.4 信号量</span><a href="#2-4-xin-hao-liang" class="header-anchor">#</a></h2><p>相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个 房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕 所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着， 等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继 续回房间睡觉，这个时候相当于信号量。可以看出，使用信号量会提高处理器的使用效率，毕 竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使 线程进入休眠状态以后会切换线程，切换线程就会有开销。</p>
<p>信号量的特点： </p>
<p><code>适用于那些占用资源比较久的场合，如线程同步。</code></p>
<p><code>因此信号量等待不能用于中断中，因为中断不能休眠。</code></p>
<h3><span id="2-4-1-xin-hao-liang-api">2.4.1 信号量 API</span><a href="#2-4-1-xin-hao-liang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	 <span class="type">raw_spinlock_t</span> lock;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义一个信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，因为会导致休眠，因此不能在中断中使用。</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠。</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，和 down 类似，只是使用 down 进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* 定义信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>); <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">threadA()&#123;</span><br><span class="line">    down(&amp;sem); <span class="comment">/* 申请信号量 */</span></span><br><span class="line">&#125;</span><br><span class="line">theadB()&#123;</span><br><span class="line">    up(&amp;sem); <span class="comment">/* 释放信号量 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-5-hu-chi-suo">2.5 互斥锁</span><a href="#2-5-hu-chi-suo" class="header-anchor">#</a></h2><p>将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">	 <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line"> 	<span class="type">atomic_t</span> count;</span><br><span class="line">	 <span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 mutex 的时候要注意如下几点：</p>
<p><code>1. mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。</code> </p>
<p><code>2. 和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</code></p>
<p><code> 3. 因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。</code></p>
<h3><span id="2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</span><a href="#2-5-1-hu-chi-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_trylock(struct mutex *lock)</td>
<td>尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
<tr>
<td>int mutex_lock_interruptible(struct mutex *lock)</td>
<td>使用此函数获取信号量失败进入休眠以后可以被信号打断</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 定义一个互斥体 */</span></span><br><span class="line">mutex_init(&amp;lock); <span class="comment">/* 初始化互斥体 */</span></span><br><span class="line">mutex_lock(&amp;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;lock); <span class="comment">/* 解锁 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</span><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi" class="header-anchor">#</a></h2><p>随着 SMP(对称多处理器架构) 的发展，程序确实是在并发执行，也为数据同步带来了更大的挑战。</p>
<p>在 SMP 架构中，每个 CPU 都拥有自己的高速缓存，通常，L1 cache 是 CPU 独占的，每个 CPU 都有一份，它的速度自然是最快的，而 L2 cache 通常是所有 CPU 共享的高速缓存，当 CPU 载入一个全局数据时，会逐级地查看高速缓存，如果没有在缓存中命中，就从内存中载入，并加入到各级 cache 中，当下次需要读取这个值时，直接读取 cache 。</p>
<p>假如进程在 CPU0 上操作一个共享变量，在某个时刻进程被调度到 CPU1 上执行时，CPU0 和 CPU1 上的 共享变量值就不同。</p>
<p><strong>percpu机制</strong>：为了避免多个 CPU 对全局数据的竞争而导致的性能损失，<strong>percpu 直接为每个 CPU 生成一份独有的数据备份，每个数据备份占用独立的内存</strong>，CPU 不应该修改不属于自己的这部分数据，这样就避免了多 CPU 对全局数据的竞争问题。</p>
<h3><span id="2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</span><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>对于普通的变量而言，变量的加载地址就是程序中使用的该变量的地址，可以使用取址符获取变量地址。</p>
<p><strong>percpu 变量</strong>：percpu 变量的加载地址是不允许访问的，取而代之的是对于 n 核的 SMP 架构系统，内核将会为每一个 CPU 另行开辟一片内存，将该 percpu 变量复制 n 份分别放在每个 CPU 独有的内存区中。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/6.png" alt="image"></p>
<p>也就是说，为 percpu 分配内存的时候，原始的变量 var 与 percpu 变量内存偏移值 offset 被保存了下来，每个 CPU 对应的 percpu 变量地址为 <code>(&amp;var + offset)</code>，当然真实情况要比这个复杂，将在后文中讲解。</p>
<h3><span id="2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</span><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing" class="header-anchor">#</a></h3><ol>
<li>计数器和统计信息：如果你有计数器或者统计信息需要在每个CPU上独立维护，那么<code>percpu</code>变量将会非常有用。</li>
<li>异步任务处理：通过<code>percpu</code>变量来维护异步任务的上下文信息。</li>
</ol>
<h3><span id="2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</span><a href="#2-6-2-percpu-bian-liang-de-ding-yi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(type, name);<span class="comment">//静态定义一个 percpu变量，type 是变量类型，name 是变量名</span></span><br><span class="line"></span><br><span class="line">type __percpu *ptr <span class="title function_">alloc_percpu</span><span class="params">(type)</span>;<span class="comment">//动态分配一个percpu变量ptr,这只是一个原始数据，真正被使用的数据被 copy 成 n(n=CPU数量) 份分别保存在每个 CPU 独占的地址空间中，在访问 percpu 变量时就是对每个副本进行访问。</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</span><a href="#2-6-3-percpu-bian-liang-de-du-xie" class="header-anchor">#</a></h3><p><strong>静态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="type">int</span>, val)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前CPU的percpu变量的值</span></span><br><span class="line"><span class="type">int</span> value = per_cpu(val, smp_processor_id());</span><br><span class="line"><span class="comment">// 遍历所有CPU，并打印percpu变量的值</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    value = per_cpu(val, cpu);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_percpu_var on CPU%d is %d\n&quot;</span>, cpu, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*put_cpu_var 和 get_cpu_var 是成对出现的,因为这段期间内静止内核抢占，</span></span><br><span class="line"><span class="comment"> *它们之间的代码不宜执行太长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> *pint = &amp;get_cpu_var(val);<span class="comment">//获取当前 CPU 的 percpu 变量的地址进行操作</span></span><br><span class="line">*pint++;</span><br><span class="line">put_cpu_var(val);</span><br></pre></td></tr></table></figure>

<p>为什么在调用 <code>get_cpu_var </code>时，第一步是禁止内核抢占呢?</p>
<p>想想这样一个场景，进程 A 在 CPU0 上执行，读取了 percpu 变量到寄存器中，这时候进程被高优先级进程抢占，继续执行的时候可能被转移到 CPU1 上执行，这时候在 CPU1 执行的代码操作的仍旧是 CPU0 上的 percpu 变量，这显然是错误的。</p>
<p><strong>动态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pint = alloc_percpu(<span class="type">int</span>);</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *p = per_cpu_ptr(pint,raw_smp_processor_id());<span class="comment">//与静态变量的操作接口不一样，这个接口允许指定 CPU ，不再是只能获取当前 CPU 的值</span></span><br><span class="line">(*p)++;</span><br></pre></td></tr></table></figure>

<p><code>raw_smp_processor_id() </code>函数返回<code>当前 CPU num</code>，这个示例也就是操作当前 CPU 的 percpu 变量，这个接口<strong>并不需要禁止内核抢占</strong>，因为不管进程被切换到哪个 CPU 上执行，它所操作的都是第二个参数提供的 CPU。</p>
<h3><span id="2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</span><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    DEFINE_PER_CPU_SECTION(type, name, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU_SECTION(type, name, sec)             \</span></span><br><span class="line"><span class="meta">    __PCPU_ATTRS(sec) PER_CPU_DEF_ATTRIBUTES            \</span></span><br><span class="line"><span class="meta">    __typeof__(type) name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PCPU_ATTRS(sec)                       \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(PER_CPU_BASE_SECTION sec))) \</span></span><br><span class="line"><span class="meta">    PER_CPU_ATTRIBUTES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data..percpu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>展开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data..percpu&quot;</span>))) type name;  \ </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data&quot;</span>))) type name; \</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 SMP 架构下，被定义的 percpu 变量在编译后放在<code> .data..percpu</code> 这个 section 中;</li>
<li>在单核系统中， percpu 变量被放在<code>.data</code>也就是数据段中;</li>
</ol>
<h4><span id="2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</span><a href="#2-6-4-1-get-cpu-var-shi-xian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    this_cpu_ptr(&amp;var);                     \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> this_cpu_ptr(ptr) raw_cpu_ptr(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_cpu_ptr(ptr)                        \</span></span><br><span class="line"><span class="meta">(&#123;                                              \</span></span><br><span class="line"><span class="meta">    __verify_pcpu_ptr(ptr);                     \</span></span><br><span class="line"><span class="meta">    arch_raw_cpu_ptr(ptr);                      \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先，<code>preempt_disable </code>禁用内核抢占，然后使用 <code>this_cpu_ptr </code>接口获取当前 cpu 上对应的 var 变量地址。</p>
<p>对<code>get_cpu_var</code>展开：可以看到就能准确获取当前cpu的val地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    &amp;var + __per_cpu_offset[raw_smp_processor_id()]  \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br></pre></td></tr></table></figure>

<p>使用完变量之后记得调用 <code>put_cpu_var</code> 以使能内核抢占功能，恢复系统状态。</p>
<h1><span id="3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</span><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing" class="header-anchor">#</a></h1><ol>
<li>原子操作：主要用于进行原子性的读写操作，适用于计数器等场景。</li>
<li>自旋锁：用于短时间内锁定互斥资源，适用于锁持有时间短的场景。</li>
<li>读写锁：用于提供读模式和写模式下的锁操作，适用于读多写少的场景。</li>
<li>MUTEX：类似自旋锁，但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。(允许休眠)</li>
<li>信号量：用于实现互斥和同步，适用于保护临界区和控制访问频率。但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。（允许休眠）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/" data-id="clzp8utsw00079oufci3gfawk" data-title="Linux内核-并发与同步" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux内核-rootfs构建移植" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/" class="article-date">
  <time class="dt-published" datetime="2024-07-20T09:47:28.000Z" itemprop="datePublished">2024-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/">Linux内核-rootfs构建移植</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gen-wen-jian-xi-tong-de-yin-ru">1 根文件系统的引入</a></li>
<li><a href="#2-gen-wen-jian-xi-tong-de-zu-cheng">2 根文件系统的组成</a><ul>
<li><a href="#2-1-bin-mu-lu">2.1 &#x2F;bin 目录</a></li>
<li><a href="#2-2-dev-mu-lu">2.2 &#x2F;dev 目录</a></li>
<li><a href="#2-3-etc-mu-lu">2.3 &#x2F;etc 目录</a></li>
<li><a href="#2-4-lib-mu-lu">2.4 &#x2F;lib 目录</a></li>
<li><a href="#2-5-mnt-mu-lu">2.5 &#x2F;mnt 目录</a></li>
<li><a href="#2-6-proc-mu-lu">2.6 &#x2F;proc 目录</a></li>
<li><a href="#2-7-usr-mu-lu">2.7 &#x2F;usr 目录</a></li>
<li><a href="#2-8-var-mu-lu">2.8 &#x2F;var 目录</a></li>
<li><a href="#2-9-sys-mu-lu">2.9 &#x2F;sys 目录</a></li>
</ul>
</li>
<li><a href="#3-gou-jian-gen-wen-jian-xi-tong">3 构建根文件系统</a><ul>
<li><a href="#3-1-busybox">3.1 busybox</a><ul>
<li><a href="#3-1-1-pei-zhi-bian-yi-busybox">3.1.1 配置编译 BusyBox</a><ul>
<li><a href="#3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie">3.1.1.1 busybox支持中文识别</a></li>
<li><a href="#3-1-1-2-busybox-pei-zhi">3.1.1.2 busybox配置</a></li>
<li><a href="#3-1-1-3-bian-yi">3.1.1.3 编译</a></li>
</ul>
</li>
<li><a href="#3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku">3.1.2 根文件系统添加 lib 库</a><ul>
<li><a href="#3-1-2-1-lib-ku-tian-jia">3.1.2.1 &#x2F;lib库添加</a></li>
<li><a href="#3-1-2-2-usr-lib-ku-tian-jia">3.1.2.2 &#x2F;usr&#x2F;lib库添加</a></li>
</ul>
</li>
<li><a href="#3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu">3.1.3 根文件系统添加其他目录</a></li>
<li><a href="#3-1-4-gen-wen-jian-xi-tong-ce-shi">3.1.4 根文件系统测试</a></li>
<li><a href="#3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben">3.1.5 根文件系统添加 etc配置脚本</a><ul>
<li><a href="#3-1-5-1-chuang-jian-etc-init-d-rcs">3.1.5.1 创建&#x2F;etc&#x2F;init.d&#x2F;rcS</a></li>
<li><a href="#3-1-5-2-chuang-jian-etc-fstab">3.1.5.2 创建&#x2F;etc&#x2F;fstab</a></li>
<li><a href="#3-1-5-3-chuang-jian-etc-inittab-wen-jian">3.1.5.3 创建&#x2F;etc&#x2F;inittab文件</a></li>
<li><a href="#3-1-5-3-chuang-jian-etc-resolv-conf">3.1.5.3 创建&#x2F;etc&#x2F;resolv.conf</a></li>
<li><a href="#3-1-5-4-proc-cmdline">3.1.5.4 <code>/proc/cmdline</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gen-wen-jian-xi-tong-de-yin-ru">1 根文件系统的引入</span><a href="#1-gen-wen-jian-xi-tong-de-yin-ru" class="header-anchor">#</a></h1><p>我们知道文件系统类型有 <code>FATFS、FAT、EXT4、YAFFS 和 NTFS，squashfs</code>等。文件系统可以让我们利用文件IO的形式对文件目录进行访问，而不用去访问flash存储地址，在使用上更为方便轻松。<br>根文件系统rootfs, 首先是内核启动时所 mount(挂载)的第一个文件系统，系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加载到内存中去运行。<br>百度百科上说内核代码镜像文件保存在根文件系统中(对电脑端的Ubuntu来说确实是，放在<code>/boot/vmlinuz-5.4.0-152-generic</code>)。但是我们嵌入式 Linux 并没有将内核代码镜像保存在根文件系统中，而是保存到了其他地方，比如 NAND Flash 的指定存储地址、EMMC 专用分区中。<br>嵌入式根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须要搭配根文件系统。如果不提供根文件系统，Linux 内核在启动的时候就会提示内核崩溃(Kernel panic)：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/1.png" alt="image"></p>
<h1><span id="2-gen-wen-jian-xi-tong-de-zu-cheng">2 根文件系统的组成</span><a href="#2-gen-wen-jian-xi-tong-de-zu-cheng" class="header-anchor">#</a></h1><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/2.png" alt="image"></p>
<h2><span id="2-1-x2f-bin-mu-lu">2.1 &#x2F;bin 目录</span><a href="#2-1-x2f-bin-mu-lu" class="header-anchor">#</a></h2><p>存放着系统需要的可执行文件，一般都是一些命令，比如<code>ls、cp、mv</code>等命令。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/3.png" alt="image"></p>
<h2><span id="2-2-x2f-dev-mu-lu">2.2 &#x2F;dev 目录</span><a href="#2-2-x2f-dev-mu-lu" class="header-anchor">#</a></h2><p>此目录下的文件都是设备节点文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /dev/</span><br><span class="line">crw-rw----    1 root     root       89,   9 Jan  1 08:00 /dev/i2c-9</span><br><span class="line">crw-rw----    1 root     root       10,  62 Jan  1 08:00 /dev/ion</span><br><span class="line">crw-rw----    1 root     root        1,  11 Jan  1 08:00 /dev/kmsg</span><br><span class="line">srw-rw-rw-    1 root     root             0 Jan  1 08:00 /dev/log</span><br><span class="line">crw-rw----    1 root     root       10, 237 Jan  1 08:00 /dev/loop-control</span><br><span class="line">brw-rw----    1 root     root        7,   0 Jan  1 08:00 /dev/loop0</span><br><span class="line">brw-rw----    1 root     root        7,   1 Jan  1 08:00 /dev/loop1</span><br><span class="line">brw-rw----    1 root     root      179,   0 Jan  1 08:00 /dev/mmcblk0</span><br><span class="line">brw-rw----    1 root     root      179,   8 Jan  1 08:00 /dev/mmcblk0boot0</span><br><span class="line">brw-rw----    1 root     root      179,  16 Jan  1 08:00 /dev/mmcblk0boot1</span><br><span class="line">brw-rw----    1 root     root      179,   1 Jan  1 08:00 /dev/mmcblk0p1</span><br><span class="line">brw-rw----    1 root     root      179,   2 Jan  1 08:00 /dev/mmcblk0p2</span><br><span class="line">brw-rw----    1 root     root      179,   3 Jan  1 08:00 /dev/mmcblk0p3</span><br><span class="line">brw-rw----    1 root     root      179,   4 Jan  1 08:00 /dev/mmcblk0p4</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-x2f-etc-mu-lu">2.3 &#x2F;etc 目录</span><a href="#2-3-x2f-etc-mu-lu" class="header-anchor">#</a></h2><p>此目录下存放着各种配置文件。</p>
<h2><span id="2-4-x2f-lib-mu-lu">2.4 &#x2F;lib 目录</span><a href="#2-4-x2f-lib-mu-lu" class="header-anchor">#</a></h2><p>存放着 Linux 所必须的库文件。这些库文件是共享库，命令和用户编写的应用程序要使用这些库文件。</p>
<h2><span id="2-5-x2f-mnt-mu-lu">2.5 &#x2F;mnt 目录</span><a href="#2-5-x2f-mnt-mu-lu" class="header-anchor">#</a></h2><p>临时挂载目录，一般是空目录，可以在此目录下创建空的子目录，比如&#x2F;mnt&#x2F;sd、&#x2F;mnt&#x2F;usb，这样就可以将 SD 卡或者 U 盘挂载到&#x2F;mnt&#x2F;sd 或者&#x2F;mnt&#x2F;usb 目录中。</p>
<h2><span id="2-6-x2f-proc-mu-lu">2.6 &#x2F;proc 目录</span><a href="#2-6-x2f-proc-mu-lu" class="header-anchor">#</a></h2><p>proc虚拟文件系统，输出硬件驱动模块的相关信息，各种输出打印。（后续专门出一篇博文介绍）<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/4.png" alt="image"></p>
<h2><span id="2-7-x2f-usr-mu-lu">2.7 &#x2F;usr 目录</span><a href="#2-7-x2f-usr-mu-lu" class="header-anchor">#</a></h2><p>这里的usr 不是 user 的缩写，而是 <code>Unix Software Resource </code>的缩写，也就是 Unix 操作系统软件资源目录。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/5.png" alt="image"></p>
<h2><span id="2-8-x2f-var-mu-lu">2.8 &#x2F;var 目录</span><a href="#2-8-x2f-var-mu-lu" class="header-anchor">#</a></h2><p>存放一些可以改变的数据。如&#x2F;var&#x2F;log。</p>
<pre><code>[root@robin]/var/log# ls
messages    messages.0  messages.1  messages.2  messages.3
</code></pre>
<h2><span id="2-9-x2f-sys-mu-lu">2.9 &#x2F;sys 目录</span><a href="#2-9-x2f-sys-mu-lu" class="header-anchor">#</a></h2><p>此目录作为 sysfs 文件系统的挂载点，sysfs 是一个类似于 proc 文件系统的特殊文件系统，sysfs 也是基于 ram 的文件系统，也就是说它也没有实际的存储设备。此目录是系统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息。</p>
<p>查看硬件模块IP的<code>base addr</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@robin]/sys/devices<span class="comment"># cd platform/</span></span><br><span class="line">[root@robin]/sys/devices/platform<span class="comment"># ls</span></span><br><span class="line">1040000.mon                 29230000.spi3</span><br><span class="line">1900000.rtos_cmdqu          29240000.can</span><br><span class="line">203c0000.bmtpu              29300000.cv-emmc</span><br><span class="line">20400000.pcie               29310000.cv-sd</span><br><span class="line">20bc0000.sata               29320000.cv-sd</span><br><span class="line">20bc0000.sata:sata-port@0   29330000.wifi-sd</span><br><span class="line">20bc0000.sata:sata-port@1   29340000.dma</span><br><span class="line">21020000.vc_drv             29350000.dma</span><br><span class="line">27000000.cv-wd              39000100.usb</span><br><span class="line">27010000.gpio               39000200.usb</span><br><span class="line">27011000.gpio               41d0c00.pdm</span><br><span class="line">27012000.gpio               5021000.gpio</span><br></pre></td></tr></table></figure>


<p>查看debug相关：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@robin]/sys/kernel/debug<span class="comment"># ls</span></span><br><span class="line">27000000.cv-wd      dw_spi2             mtd</span><br><span class="line">asoc                dw_spi3             pinctrl</span><br><span class="line">bdi                 dynamic_debug       pwm</span><br><span class="line">block               extfrag             regmap</span><br><span class="line">bluetooth           fault_around_bytes  sched_debug</span><br><span class="line">clear_warn_once     gpio                sched_features</span><br><span class="line">clk                 hid                 sleep_time</span><br><span class="line">debug_enabled       ieee80211           split_huge_pages</span><br></pre></td></tr></table></figure>
<p>重要的有：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sys/kernel/debug/debug_enabled</span><br><span class="line">/sys/kernel/debug/dynamic_debug/control</span><br><span class="line">/sys/kernel/debug/clk/clk_summary</span><br></pre></td></tr></table></figure>

<p>查看和设置驱动模块module param变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /sys/module/soph_stitch/parameters</span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># cat stitch_log_lv</span></span><br><span class="line">2</span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># echo 2 &gt; stitch_log_lv</span></span><br><span class="line">[root@cvitek]/sys/module/soph_stitch/parameters<span class="comment"># cat stitch_log_lv</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1><span id="3-gou-jian-gen-wen-jian-xi-tong">3 构建根文件系统</span><a href="#3-gou-jian-gen-wen-jian-xi-tong" class="header-anchor">#</a></h1><h2><span id="3-1-busybox">3.1 busybox</span><a href="#3-1-busybox" class="header-anchor">#</a></h2><p>BusyBox 是一个集成了大量的 Linux 命令和工具的软件，像<code>ls、mv、ifconfig</code>等命令 BusyBox 都会提供。<br>一般下载 BusyBox 的源码，然后配置 BusyBox，选择自己想要的功能，最后编译即可。<br>BusyBox 可以在其官网下载到，官网地址为：<br><a target="_blank" rel="noopener" href="https://busybox.net/downloads/">https://busybox.net/downloads/</a></p>
<h3><span id="3-1-1-pei-zhi-bian-yi-busybox">3.1.1 配置编译 BusyBox</span><a href="#3-1-1-pei-zhi-bian-yi-busybox" class="header-anchor">#</a></h3><p>这里我下载的<code>busybox-1.29.0.tar.bz2</code>， 将其进行解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> rootfs；<span class="built_in">cd</span> rootfs; tar xfj busybox-1.29.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/6.png" alt="image"><br>修改Makefile添加<code>toolchain</code>:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">164 CROSS_COMPILE ?= /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/arm-linux-gnueabihf-</span><br><span class="line">......</span><br><span class="line">190 ARCH ?= arm</span><br></pre></td></tr></table></figure>

<h4><span id="3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie">3.1.1.1 busybox支持中文识别</span><a href="#3-1-1-1-busybox-zhi-chi-zhong-wen-shi-bie" class="header-anchor">#</a></h4><p>我们知道中文的编码如果采用<code>utf8</code>，那么<code>ascii</code>值肯定是大于<code>0x7f</code>的。因此需要修改busybox源码，让其能识别超过<code>ascii</code>的编码范围<code>0x7f</code>。</p>
<p><strong>utf8 中文编码</strong>：<br>UTF-8是一种广泛使用的<code>Unicode</code>编码方式，它可以用来表示各种语言和符号。对于中文字来说，UTF-8采用了一种特殊的编码方式，即中文字符主要使用三个字节（21比特）来表示。具体来说，当一个汉字的Unicode码位于0x80到0x7FF之间的时，UTF-8会用三个字节来编码这个汉字。例如，汉字“爸”在UTF-8中的编码过程是这样的：</p>
<p>首先，将汉字<code>“爸”</code>的<code>Unicode</code>码<code>（0x5BAD）</code>转换为二进制数<code>（0111 0010 0011 1000）</code>。<br>然后，按照UTF-8的三字节模式进行编码，即每个字节的最高位都设置为1，剩下的7位用于表示该字节所对应的Unicode值。在这个例子中，第一个字节的高位为1，表示这是一个16位的字节；接下来的三位为1011，对应于Unicode码中的第11位，即十进制的5；最后一位为0，代表这是一个字节的最低位。<br>最后，将这三个字节的二进制数转换为十六进制数<code>（0xE788B8）</code>，这就是汉字<code>“爸”</code>在UTF-8中的编码形式。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi libbb/unicode.c</span><br></pre></td></tr></table></figure>
<p>打开函数<code>unicode_conv_to_printable2</code>,修改如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/7.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi libbb/printable_string.c</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/8.png" alt="image"></p>
<h4><span id="3-1-1-2-busybox-pei-zhi">3.1.1.2 busybox配置</span><a href="#3-1-1-2-busybox-pei-zhi" class="header-anchor">#</a></h4><p>编译busybox前要先对 busybox 进行默认的配置，有以下几种配置选项：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①、defconfig，缺省配置，也就是默认配置选项。</span><br><span class="line">②、allyesconfig，全选配置，也就是选中 busybox 的所有功能</span><br><span class="line">③、allnoconfig，最小配置。</span><br><span class="line"></span><br><span class="line">make defconfig</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/9.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Settings </span><br><span class="line">	-&gt; Build <span class="type">static</span> <span class="title function_">binary</span> <span class="params">(no shared libs)</span></span><br></pre></td></tr></table></figure>
<p>这项请不要勾选，静态编译 busybox会DNS解析有问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Settings</span><br><span class="line">	-&gt; vi-style line editing commands</span><br></pre></td></tr></table></figure>
<p>建议勾选这项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Linux Module Utilities</span><br><span class="line">	-&gt; Simplified modutils</span><br></pre></td></tr></table></figure>
<p>默认会选中“Simplified modutils”，这里我们要取消勾选。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Linux System Utilities</span><br><span class="line">	-&gt; mdev (<span class="number">16</span> kb) <span class="comment">//确保下面的全部选中，默认都是选中的</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Settings</span><br><span class="line">	-&gt; Support Unicode <span class="comment">//选中</span></span><br><span class="line">		-&gt; Check $LC_ALL, $LC_CTYPE and $LANG environment variables <span class="comment">//选中</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/11.png" alt="image"></p>
<h4><span id="3-1-1-3-bian-yi">3.1.1.3 编译</span><a href="#3-1-1-3-bian-yi" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line">make install CONFIG_PREFIX=/media/cvitek/robin.lee/rootfs ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/12.png" alt="image"><br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/13.png" alt="image"></p>
<p>busybox 的所有工具和文件就会被安装到 rootfs 目录中，rootfs 目录内容如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/14.png" alt="image"><br>命令和工具都再对应&#x2F;bin &#x2F;usr&#x2F;bin对应的目录：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/15.png" alt="image"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17995165" title="3.linux内核启动流程">3.linux内核启动流程</a></p>
<p><a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Linux内核启动流程 | Hexo (fuzidage.github.io)</a></p>
<p>说过 Linux 内核 init 进程最后会查找用户空间的 init 程序，找到以后就会运行这个用户空间的 init 程序，从而切换到用户态。如果 <code>bootargs</code> 设置 <code>init=/linuxrc</code>，那么 linuxrc 就是可以作为用户空间的 init 程序，所以用户态空间的 init 程序是 busybox 来生成的。</p>
<p>我们的根文件系统此时就制作好了，但此时还不能使用，还需要一些其他的文件，我们继续来完善 rootfs。</p>
<h3><span id="3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku">3.1.2 根文件系统添加 lib 库</span><a href="#3-1-2-gen-wen-jian-xi-tong-tian-jia-lib-ku" class="header-anchor">#</a></h3><h4><span id="3-1-2-1-x2f-lib-ku-tian-jia">3.1.2.1 &#x2F;lib库添加</span><a href="#3-1-2-1-x2f-lib-ku-tian-jia" class="header-anchor">#</a></h4><p>Linux 中的应用程序一般都是需要动态库的，当然你也可以编译成静态的，但是静态的可执行文件会很大。如果编译为动态的话就需要动态库，所以我们需要向根文件系统中添加动态库。lib 库文件从交叉编译器中获取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> lib</span><br><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib</span><br></pre></td></tr></table></figure>
<p>libc库如下：将其拷贝进rootfs。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/16.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>

<p>进入工具链的lib库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib</span><br><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>
<p>最终根文件系统的&#x2F;lib内容如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/17.png" alt="image"></p>
<h4><span id="3-1-2-2-x2f-usr-x2f-lib-ku-tian-jia">3.1.2.2 &#x2F;usr&#x2F;lib库添加</span><a href="#3-1-2-2-x2f-usr-x2f-lib-ku-tian-jia" class="header-anchor">#</a></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/lib</span><br><span class="line"><span class="built_in">cd</span> gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib</span><br></pre></td></tr></table></figure>
<p>libc&#x2F;usr&#x2F;lib库如下：将其拷贝进rootfs。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/18.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> *so* *.a /media/cvitek/robin.lee/rootfs/usr/lib -d <span class="comment">#-d表示将软链接也一同拷贝</span></span><br></pre></td></tr></table></figure>
<p>至此，根文件系统的库文件就全部添加好了。来看下库占用存储空间多少：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/cvitek/robin.lee/rootfs$ <span class="built_in">du</span> ./lib ./usr/lib/ -sh</span><br><span class="line">57M     ./lib</span><br><span class="line">67M     ./usr/lib/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu">3.1.3 根文件系统添加其他目录</span><a href="#3-1-3-gen-wen-jian-xi-tong-tian-jia-qi-ta-mu-lu" class="header-anchor">#</a></h3><p>dev、proc、mnt、sys、tmp 和 root这些目录需要在rootfs进行创建。<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/19.png" alt="image"></p>
<h3><span id="3-1-4-gen-wen-jian-xi-tong-ce-shi">3.1.4 根文件系统测试</span><a href="#3-1-4-gen-wen-jian-xi-tong-ce-shi" class="header-anchor">#</a></h3><p>初步测试我们的rootfs功能，我们最好是利用nfs挂载根文件系统，方便修改。之前<code>bootargs</code>都是设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从emmc分区2启动，分区2存放了根文件系统。现在bootargs改成nfs挂载rootfs要如何设置呢？<br>文档为 <code>Documentation/filesystems/nfs/nfsroot.txt</code>，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root=/dev/nfs nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;] ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;:&lt;dns0-ip&gt;:&lt;dns1-ip&gt;</span><br><span class="line"></span><br><span class="line">&lt;server-ip&gt;：服务器 IP 地址，比如我的 Ubuntu 主机 IP 地址为 192.168.1.250。</span><br><span class="line">&lt;root-dir&gt;：根文件系统的存放路径，要保证放在nfs共享目录下。比如我的就是/media/cvitek/robin.lee/rootfs</span><br><span class="line">&lt;nfs-options&gt;：NFS 的其他可选选项，一般不设置。</span><br><span class="line">&lt;client-ip&gt;：客户端 IP 地址，也就是我们开发板的 IP 地址</span><br><span class="line">&lt;server-ip&gt;：服务器 IP 地址，前面已经说了。</span><br><span class="line">&lt;gw-ip&gt;：网关地址，我的就是 192.168.1.1。</span><br><span class="line">&lt;netmask&gt;：子网掩码，我的就是 255.255.255.0。</span><br><span class="line">&lt;hostname&gt;：客户机的名字，一般不设置，此值可以空着。</span><br><span class="line">&lt;device&gt;：设备名，也就是网卡名，一般是 eth0，eth1….，正点原子的 I.MX6U-ALPHA 开发板的 ENET2 为 eth0，ENET1 为 eth1。</span><br><span class="line">&lt;autoconf&gt;：自动配置，一般不使用，所以设置为 off。</span><br><span class="line">&lt;dns0-ip&gt;：DNS0 服务器 IP 地址，不使用。</span><br><span class="line">&lt;dns1-ip&gt;：DNS1 服务器 IP 地址，不使用。</span><br></pre></td></tr></table></figure>

<p>最终我们设置 bootargs 环境变量的 root 值如下：<br><code>root=/dev/nfs nfsroot=192.168.1.250:/media/cvitek/robin.lee/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off</code></p>
<p><code>“proto=tcp”</code>表示使用 TCP 协议，<code>“rw”</code>表示 nfs 挂载的根文件系统为可读可写。<br>修改保存环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200 root=/dev/nfs nfsroot=192.168.1.250:/media/cvitek/robin.lee/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off&#x27;</span> <span class="comment">#设置 bootargs</span></span><br><span class="line">saveenv <span class="comment">#保存环境变量</span></span><br></pre></td></tr></table></figure>

<p>设置好以后使用<code>“boot”</code>命令启动 Linux 内核，输出打印如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/20.png" alt="image"><br>可以看到成功挂载rootfs，并且进入Linux控制台。</p>
<h3><span id="3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben">3.1.5 根文件系统添加 etc配置脚本</span><a href="#3-1-5-gen-wen-jian-xi-tong-tian-jia-etc-pei-zhi-jiao-ben" class="header-anchor">#</a></h3><h4><span id="3-1-5-1-chuang-jian-x2f-etc-x2f-init-d-x2f-rcs">3.1.5.1 创建&#x2F;etc&#x2F;init.d&#x2F;rcS</span><a href="#3-1-5-1-chuang-jian-x2f-etc-x2f-init-d-x2f-rcs" class="header-anchor">#</a></h4><p>前面打印有一行报错，进入根文件系统的时候会有下面这一行错误提示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can<span class="string">&#x27;t run &#x27;</span>/etc/init.d/rcS<span class="string">&#x27;: No such file or directory</span></span><br></pre></td></tr></table></figure>
<p>rcS 是个 shell 脚本，Linux 内核启动以后需要启动一些服务，而 rcS 就是规定启动哪些文件的脚本文件。在 rootfs 中创建<code>/etc/init.d/rcS </code>文件，然后在 rcS 中输入如下所示内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="variable">$PATH</span></span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/lib:/usr/lib</span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>
<p><code>PATH</code> 环境变量保存着可执行文件可能存在的目录;<br><code>LD_LIBRARY_PATH</code> 环境变量保存着库文件所在的目录;<br>mount 命令来挂载所有的文件系统，这些文件系统由文件<code>/etc/fstab</code> 来指定;<br>创建目录<code>/dev/pts</code>，然后将 <code>devpts</code> 挂载到<code>/dev/pts </code>目录中。<br>使用 mdev 来管理热插拔设备，通过这两行，Linux 内核就可以在&#x2F;dev 目录下自动创建设备节点。</p>
<p>我们是简单构造了一个最简单的rcS, 大家如果去看 Ubuntu 或者其他大型 Linux操作系统中的 rcS 文件，就会发现其非常复杂。而且这么复杂的 rcS 文件也是借助其他工具创建的，比如 buildroot 等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 rcS</span><br></pre></td></tr></table></figure>
<p>重新启动 Linux 内核，启动以后如下图：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/21.png" alt="image"></p>
<h4><span id="3-1-5-2-chuang-jian-x2f-etc-x2f-fstab">3.1.5.2 创建&#x2F;etc&#x2F;fstab</span><a href="#3-1-5-2-chuang-jian-x2f-etc-x2f-fstab" class="header-anchor">#</a></h4><p>fstab 在 Linux 开机以后自动配置哪些需要自动挂载的分区，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;file system&gt; &lt;mount point&gt; &lt;<span class="built_in">type</span>&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;</span><br><span class="line"></span><br><span class="line">&lt;file system&gt;：要挂载的特殊的设备，也可以是块设备，比如/dev/sda 等等</span><br><span class="line">&lt;mount point&gt;：挂载点。</span><br><span class="line">&lt;<span class="built_in">type</span>&gt;：文件系统类型，比如 ext2、ext3、proc、romfs、tmpfs 等等。</span><br><span class="line">&lt;options&gt;：挂载选项，一般使用 defaults，defaults 包含了 rw、suid、 dev、 <span class="built_in">exec</span>、 auto、 nouser 和 async。</span><br><span class="line">&lt;dump&gt;：为 1 的话表示允许备份，为 0 不备份，一般不备份，因此设置为 0。</span><br><span class="line">&lt;pass&gt;：磁盘检查设置，为 0 表示不检查。根目录‘/’设置为 1，其他的都不能设置为 1，因此这里一般设置为 0</span><br></pre></td></tr></table></figure>
<p>fstab内容设置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#&lt;file system&gt;   &lt;mount point&gt;     &lt;type&gt;     &lt;options&gt;   &lt;dump&gt;    &lt;pass&gt;</span></span><br><span class="line">proc             /proc             proc       defaults    0         0</span><br><span class="line">tmpfs            /tmp              tmpfs      defaults    0         0</span><br><span class="line">sysfs            /sys              sysfs      defaults    0         0</span><br></pre></td></tr></table></figure>

<p><code>fstab </code>文件创建完成以后重新启动 Linux打印如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/22.png" alt="image"></p>
<h4><span id="3-1-5-3-chuang-jian-x2f-etc-x2f-inittab-wen-jian">3.1.5.3 创建&#x2F;etc&#x2F;inittab文件</span><a href="#3-1-5-3-chuang-jian-x2f-etc-x2f-inittab-wen-jian" class="header-anchor">#</a></h4><p>inittab 的详细内容可以参考 busybox 下的文件 <code>examples/inittab</code>。init 程序会读取<code>/etc/inittab</code>这个文件，inittab 由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的 4 个段组成，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">id</span>&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line">&lt;<span class="built_in">id</span>&gt;：每个指令的标识符，不能重复。但是对于 busybox 的 init 来说，&lt;<span class="built_in">id</span>&gt;有着特殊意义。对于 busybox 而言&lt;<span class="built_in">id</span>&gt;用来指定启动进程的控制 <span class="built_in">tty</span>，一般我们将串口或者 LCD 屏幕设置为控制 <span class="built_in">tty</span>。</span><br><span class="line">&lt;runlevels&gt;：对 busybox 来说此项完全没用，所以空着。</span><br><span class="line">&lt;action&gt;：动作，用于指定&lt;process&gt;可能用到的动作:</span><br><span class="line">	busybox 支持的动作如下：</span><br><span class="line">	sysinit: 在系统初始化的时候 process 才会执行一次。</span><br><span class="line">	respawn: 当 process 终止以后马上启动一个新的。</span><br><span class="line">	askfirst:和 respawn 类似，在运行 process 之前在控制台上显示“Please press Enter to activate this console.”。只要用户按下“Enter”键以后才会执行 process。</span><br><span class="line">	<span class="built_in">wait</span>: 告诉 init，要等待相应的进程执行完以后才能继续执行。</span><br><span class="line">	once: 仅执行一次，而且不会等待 process 执行完成。</span><br><span class="line">	restart: 当 init 重启的时候才会执行 procee。</span><br><span class="line">	ctrlaltdel: 当按下 ctrl+alt+del 组合键才会执行 process。</span><br><span class="line">	shutdown: 关机的时候执行 process。</span><br><span class="line">&lt;process&gt;：具体的动作，比如程序、脚本或命令等</span><br></pre></td></tr></table></figure>

<p>我们的&#x2F;etc&#x2F;inittab内容设置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#etc/inittab</span></span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">console::askfirst:-/bin/sh</span><br><span class="line">::restart:/sbin/init</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br></pre></td></tr></table></figure>

<p>第 2 行，系统启动以后运行<code>/etc/init.d/rcS </code>这个脚本文件。<br>第 3 行，将 console 作为控制台终端，也就是 ttymxc0。<br>第 4 行，重启的话运行&#x2F;sbin&#x2F;init。<br>第 5 行，按下 ctrl+alt+del 组合键的话就运行<code>/sbin/reboot</code>，看来 ctrl+alt+del 组合键用于重启系统。<br>第 6 行，关机的时候执行<code>/bin/umount</code>，也就是卸载各个文件系统。<br>第 7 行，关机的时候执行<code>/sbin/swapoff</code>，也就是关闭交换分区。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/23.png" alt="image"></p>
<h4><span id="3-1-5-3-chuang-jian-x2f-etc-x2f-resolv-conf">3.1.5.3 创建&#x2F;etc&#x2F;resolv.conf</span><a href="#3-1-5-3-chuang-jian-x2f-etc-x2f-resolv-conf" class="header-anchor">#</a></h4><p><code>/etc/resolv.conf</code>是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。该文件是由域名解析器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameserver： 配置DNS服务器地址（顺序来查询，且只有当第一个nameserver没有反应时才查询下面的nameserver）</span><br><span class="line">domain： 声明主机的域名，当查询不完全的域名时主机名将被使用(相当于search的默认值)</span><br><span class="line">search： 它的多个参数指明域名查询顺序。当查询不完全的域名时会使用到（domain和search不能共存）</span><br></pre></td></tr></table></figure>

<p>默认<code>/etc/resolv.conf</code>配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br></pre></td></tr></table></figure>

<p>一般将<strong>nameserver</strong>设置成网关地址，再加入<code>8.8.8.8</code>和<code>114.114.114.114</code></p>
<p><code>ping blog.csdn.com</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog.csdn.com</span></span><br><span class="line">PING blog.csdn.com.com (45.11.57.36) 56(84) bytes of data.</span><br><span class="line">64 bytes from comcomproxy1.com.com (45.11.57.36): icmp_seq=1 ttl=44 time=291 ms</span><br><span class="line">64 bytes from comcomproxy1.com.com (45.11.57.36): icmp_seq=2 ttl=44 time=270 ms</span><br></pre></td></tr></table></figure>

<p><code>ping blog</code>，发现不通，需要设置<code>domain域</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog</span></span><br><span class="line">ping: blog: 未知的名称或服务</span><br></pre></td></tr></table></figure>
<p>调整<code>/etc/resolv.conf</code>配置文件,添加<strong>domain</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># vi /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br><span class="line">domain csdn.net</span><br></pre></td></tr></table></figure>

<p>再次<code>ping blog</code>, ping不完整域名会自动补全</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># ping blog</span></span><br><span class="line">PING blog.csdn.net (182.92.187.217) 56(84) bytes of data.</span><br><span class="line">64 bytes from 182.92.187.217 (182.92.187.217): icmp_seq=1 ttl=89 time=20.4 ms</span><br></pre></td></tr></table></figure>

<p>调整<code>/etc/resolv.conf</code>配置文件,添加<strong>search</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@node2 ~]<span class="comment"># vi /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># Generated by NetworkManager</span></span><br><span class="line">nameserver 192.168.248.2</span><br><span class="line">search abc.com csdn.net</span><br></pre></td></tr></table></figure>

<h4><span id="3-1-5-4-proc-cmdline">3.1.5.4 <code>/proc/cmdline</code></span><a href="#3-1-5-4-proc-cmdline" class="header-anchor">#</a></h4><p><code>cat /proc/cmdline</code> 可以看到内核启动时U-boot传入参数:<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/24.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/" data-id="clzp8utsw00069ouf2g340fbd" data-title="Linux内核-rootfs构建移植" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux内核启动流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-20T06:13:25.000Z" itemprop="datePublished">2024-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Linux内核启动流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</a></li>
<li><a href="#2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</a><ul>
<li><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</a></li>
<li><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</a></li>
<li><a href="#2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</a><ul>
<li><a href="#2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></a></li>
<li><a href="#2-1-1-enable-mmu">2.1.1 <code>__enable_mmu</code></a><ul>
<li><a href="#2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></a><ul>
<li><a href="#2-1-1-1-1-start-kernel">2.1.1.1.1 start_kernel</a><ul>
<li><a href="#2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</a></li>
<li><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</a></li>
<li><a href="#2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</a><ul>
<li><a href="#2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</a><ul>
<li><a href="#2-2-1-1-driver-init">2.2.1.1 driver_init</a></li>
<li><a href="#2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</a></li>
<li><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</a><ul>
<li><a href="#2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</a><ul>
<li><a href="#2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</a><ul>
<li><a href="#3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</a></li>
<li><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</a><ul>
<li><a href="#3-2-1-do-initcalls">3.2.1 do_initcalls</a><ul>
<li><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</span><a href="#1-lian-jie-jiao-ben-vmlinux-lds" class="header-anchor">#</a></h1><p>先编译一下 Linux 源码，因为有很多文件是需要编译才会生成的。首先分析 Linux 内核的连接脚本文件 <code>arch/arm/kernel/vmlinux.lds</code>，通过链接脚本可以找到 Linux 内核的第一行程序是从哪里执行的。vmlinux.lds 中有如下代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">492</span> OUTPUT_ARCH(arm)</span><br><span class="line"><span class="number">493</span> ENTRY(stext)</span><br><span class="line"><span class="number">494</span> jiffies = jiffies_64;</span><br><span class="line"><span class="number">495</span> SECTIONS</span><br><span class="line"><span class="number">496</span> &#123;</span><br><span class="line"><span class="number">497</span> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">498 	* <span class="doctag">XXX:</span> The linker does not define how output sections are</span></span><br><span class="line"><span class="comment">499 	* assigned to input sections when there are multiple statements</span></span><br><span class="line"><span class="comment">500 	* matching the same input section name. There is no documented</span></span><br><span class="line"><span class="comment">501 	* order of matching.</span></span><br><span class="line"><span class="comment">502 	*</span></span><br><span class="line"><span class="comment">503 	* unwind exit sections must be discarded before the rest of the</span></span><br><span class="line"><span class="comment">504 	* unwind sections get included.</span></span><br><span class="line"><span class="comment">505 	*/</span></span><br><span class="line"><span class="number">506</span> 	/DISCARD/ : &#123;</span><br><span class="line"><span class="number">507</span> 	*(.ARM.exidx.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">508</span> 	*(.ARM.extab.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">509</span> 	</span><br><span class="line">......</span><br><span class="line"><span class="number">645</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ENTRY 指明了了 Linux 内核入口，入口为 stext，stext 定义在文件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 中 ， 因 此 要 分 析 Linux 内 核 的 启 动 流 程 ， 就 得 先 从 文 件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 的 stext 处开始分析。</p>
<h1><span id="2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</span><a href="#2-linux-nei-he-qi-dong-liu-cheng" class="header-anchor">#</a></h1><h2><span id="2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</span><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/0.png" alt="image-20240720160759323"></p>
<h2><span id="2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</span><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya" class="header-anchor">#</a></h2><p><code>kernel/lib/inflate.c</code>的<code>decompress_kernel</code>，<code> inflate.c</code>是从gzip 插件源代码移过来的。解压完后会看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UncompressingLinux...done, booting the kernel.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call_kernel: bl    cache_clean_flush</span><br><span class="line">  bl    cache_off</span><br><span class="line">  mov       r0, #<span class="number">0</span>          @ must be zero</span><br><span class="line">  mov       r1, r7          @ restore architecture number</span><br><span class="line">  mov       r2, r8          @ restore atags pointer</span><br><span class="line">  mov       pc, r4          @ call kernel</span><br></pre></td></tr></table></figure>

<p> r4 中已经在head.S处预置为内核镜像的地址,因此会跳转到r4去执行，就是Linux 内核入口 stext。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_ZRELADDR</span></span><br><span class="line">  @determine final kernel image address</span><br><span class="line">  mov       r4, pc</span><br><span class="line">  and r4, r4, #<span class="number">0xf8000000</span></span><br><span class="line">  add r4, r4, #TEXT_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  ldr   r4, =zreladdr</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</span><a href="#2-1-linux-nei-he-ru-kou-stext" class="header-anchor">#</a></h2><p>打开arch&#x2F;arm&#x2F;kernel&#x2F;head.S可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kernel startup entry point.</span></span><br><span class="line"><span class="comment">* ---------------------------</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This is normally called from the decompressor code. The requirements</span></span><br><span class="line"><span class="comment">* are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,</span></span><br><span class="line"><span class="comment">* r1 = machine nr, r2 = atags or dtb pointer.</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核的入口点 stext 其实相当于内核的入口函数，stext 函数内容如下：</p>
<p>依据上面的注释内容，Linux 内核启动之前要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①、关闭 MMU。</span><br><span class="line">②、关闭 D-cache。</span><br><span class="line">③、I-Cache 无所谓。</span><br><span class="line">④、r0=<span class="number">0</span>。</span><br><span class="line">⑤、r1=machine nr(也就是机器 ID)。</span><br><span class="line">⑥、r2=atags 或者设备树(dtb)首地址。</span><br></pre></td></tr></table></figure>

<p>stext代码如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image"></p>
<p>第 92 行，调用函数 <code>safe_svcmode_maskall</code> 确保 CPU 处于 SVC 模式，并且关闭了所有的中断。<code>safe_svcmode_maskall </code>定义在文件 <code>arch/arm/include/asm/assembler.h </code>中。<br>第 94 行，读处理器 ID，ID 值保存在 r9 寄存器中。<br>第 95 行，调用函数<code>__lookup_processor_type </code>检查当前系统是否支持此 CPU，如果支持就获取 procinfo 信 息 。 procinfo 是 <code>proc_info_list </code>类 型 的 结 构 体，<code>proc_info_list </code>在 文 件<code>arch/arm/include/asm/procinfo.h </code>中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_val;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_mask;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_mm_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_io_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_flush; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *arch_name;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *elf_name;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> elf_hwcap;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *cpu_name;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">processor</span> *<span class="title">proc</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span> *<span class="title">tlb</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span> *<span class="title">user</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span> *<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每种处理器都抽象为一个 proc_info_list 结构体，每种处理器都对应一个procinfo。因此可以通过处理器 ID 来找到对应的 procinfo 结构，<code>__lookup_processor_type </code>函数找到对应处理器的 procinfo 以后会将其保存到 r5 寄存器中。</p>
<p>第121行，函数<code>__vet_atags </code>验证 atags 或设备树(dtb)的合法性。函数<code>__vet_atags </code>定义在文件 <code>arch/arm/kernel/head-common.S </code>中。<br>第128行，调用函数<code>__create_page_tables </code>创建页表。<br>第 137 行，将函数<code>__mmap_switched</code> 的地址保存到 r13 寄存器中。<code>__mmap_switched </code>定义在文件 <code>arch/arm/kernel/head-common.S</code>，<code>__mmap_switched</code> 最终会调用 start_kernel 函数。<br>第 144 行 ， 调 用 <code>__enable_mmu </code>函 数 使 能 MMU ，<code>__enable_mmu</code>定 义 在 文 件<code>arch/arm/kernel/head.S </code>中。<code>__enable_mmu</code> 最终会通过调用<code>__turn_mmu_on </code>来打开 MMU，<code>__turn_mmu_on </code>最后会执行 r13 里面保存的<code>__mmap_switched </code>函数。</p>
<h3><span id="2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></span><a href="#2-1-0-create-page-tables" class="header-anchor">#</a></h3><ul>
<li>内核所在物理内存块的初始地址，保存在寄存器 r8 中。</li>
<li>内核代码相对于初始地址的偏移值，是在程序编译前就确定的一个宏：<code>TEXT_OFFSET</code>，arm32 中通常是 0x8000，也就是偏移地址为 32 K，前面保留的 32K 内存就是用来存放页表。</li>
</ul>
<p>在建立页表之前，目前所处的相关寄存器环境为：<code>r8 = phys_offset, r9 = cpuid, r10 = procinfo.</code></p>
<h3><span id="2-1-1-enable-mmu">2.1.1  <code>__enable_mmu</code></span><a href="#2-1-1-enable-mmu" class="header-anchor">#</a></h3><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image"></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image"></p>
<h4><span id="2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></span><a href="#2-1-1-1-mmap-switched" class="header-anchor">#</a></h4><p>前面讲到<code>__enable_mmu</code>会调用<code>__mmap_switched </code>函数（通过调用<code>__turn_mmu_on</code> 再调用r13）。现在具体分析它：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image"><br>可以看到<code>__mmap_switched</code>主要就是做clear bss,然后保存处理器ID, 序列号，最终跳转start_kernel函数。</p>
<h5><span id="2-1-1-1-1-start-kernel">2.1.1.1.1  start_kernel</span><a href="#2-1-1-1-1-start-kernel" class="header-anchor">#</a></h5><p>start_kernel会调用大量的子函数完成linux启动前的一些初始化工作，start_kernel 函数里面调用的子函数太多，而这些子函数又很复杂。我们简单的来看一下一些重要的子函数。精简并添加注释后的 start_kernel 函数内容如下：</p>
<details>
<summary>init/main/start_kenel函数</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *command_line;</span><br><span class="line">	<span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run as early as possible, to initialize the</span></span><br><span class="line"><span class="comment">	 * lockdep hash:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_init();</span><br><span class="line">	set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">	smp_setup_processor_id();</span><br><span class="line">	debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the the initial canary ASAP:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">	cgroup_init_early();</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	boot_cpu_init();</span><br><span class="line">	page_address_init();</span><br><span class="line">	pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">	setup_arch(&amp;command_line);</span><br><span class="line">	mm_init_cpumask(&amp;init_mm);</span><br><span class="line">	setup_command_line(command_line);</span><br><span class="line">	setup_nr_cpu_ids();</span><br><span class="line">	setup_per_cpu_areas();</span><br><span class="line">	smp_prepare_boot_cpu();	<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">	build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	page_alloc_init();</span><br><span class="line"></span><br><span class="line">	pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">	parse_early_param();</span><br><span class="line">	after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">				  static_command_line, __start___param,</span><br><span class="line">				  __stop___param - __start___param,</span><br><span class="line">				  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">		parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">			   set_init_arg);</span><br><span class="line"></span><br><span class="line">	jump_label_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">	 * kmem_cache_init()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	pidhash_init();</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment">	 * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment">	 * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment">	 * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line">		 <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">		local_irq_disable();</span><br><span class="line">	idr_init_cache();</span><br><span class="line">	rcu_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trace_printk() and trace points may be used after this */</span></span><br><span class="line">	trace_init();</span><br><span class="line"></span><br><span class="line">	context_tracking_init();</span><br><span class="line">	radix_tree_init();</span><br><span class="line">	<span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">	early_irq_init();</span><br><span class="line">	init_IRQ();</span><br><span class="line">	tick_init();</span><br><span class="line">	rcu_init_nohz();</span><br><span class="line">	init_timers();</span><br><span class="line">	hrtimers_init();</span><br><span class="line">	softirq_init();</span><br><span class="line">	timekeeping_init();</span><br><span class="line">	time_init();</span><br><span class="line">	sched_clock_postinit();</span><br><span class="line">	perf_event_init();</span><br><span class="line">	profile_init();</span><br><span class="line">	call_function_init();</span><br><span class="line">	WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment">	 * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment">	 * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (panic_later)</span><br><span class="line">		panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">		      panic_param);</span><br><span class="line"></span><br><span class="line">	lockdep_info();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment">	 * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment">	 * too:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">	<span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">	    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">		pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">		    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">		    min_low_pfn);</span><br><span class="line">		initrd_start = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	page_ext_init();</span><br><span class="line">	debug_objects_mem_init();</span><br><span class="line">	kmemleak_init();</span><br><span class="line">	setup_per_cpu_pageset();</span><br><span class="line">	numa_policy_init();</span><br><span class="line">	<span class="keyword">if</span> (late_time_init)</span><br><span class="line">		late_time_init();</span><br><span class="line">	sched_clock_init();</span><br><span class="line">	calibrate_delay();</span><br><span class="line">	pidmap_init();</span><br><span class="line">	anon_vma_init();</span><br><span class="line">	acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">		efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line">	<span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">	init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	thread_info_cache_init();</span><br><span class="line">	cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init(totalram_pages);</span><br><span class="line">	signals_init();</span><br><span class="line">	<span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">	page_writeback_init();</span><br><span class="line">	proc_root_init();</span><br><span class="line">	nsfs_init();</span><br><span class="line">	cpuset_init();</span><br><span class="line">	cgroup_init();</span><br><span class="line">	taskstats_init_early();</span><br><span class="line">	delayacct_init();</span><br><span class="line"></span><br><span class="line">	check_bugs();</span><br><span class="line"></span><br><span class="line">	acpi_subsystem_init();</span><br><span class="line">	sfi_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">		efi_late_init();</span><br><span class="line">		efi_free_boot_services();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftrace_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">	rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>如下，打上注释方便清楚每个子调用的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">lockdep_init() <span class="comment">//lockdep 是死锁检测模块，此函数会初始化两个 hash 表</span></span><br><span class="line">set_task_stack_end_magic() <span class="comment">//设置任务栈结束魔术数，用于栈溢出检测</span></span><br><span class="line">smp_setup_processor_id() <span class="comment">//跟 SMP 有关(多核处理器)，设置处理器 ID</span></span><br><span class="line">debug_objects_early_init() <span class="comment">//做一些和 debug 有关的初始化</span></span><br><span class="line">boot_init_stack_canary() <span class="comment">//栈溢出检测初始化</span></span><br><span class="line">cgroup_init_early() <span class="comment">//cgroup 初始化，cgroup 用于控制 Linux 系统资源</span></span><br><span class="line">local_irq_disable() <span class="comment">//关闭当前 CPU 中断, 中断关闭期间做一些重要的操作，然后打开中断</span></span><br><span class="line">boot_cpu_init() <span class="comment">//跟 CPU 有关的初始化</span></span><br><span class="line">page_address_init() <span class="comment">//页地址相关的初始化</span></span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);<span class="comment">/* 打印 Linux 版本号、编译时间等信息 */</span></span><br><span class="line">setup_arch(&amp;command_line); <span class="comment">//架构相关的初始化，此函数会解析传递进来的ATAGS 或者设备树(DTB)文件。会根据设备树里面的 model 和 compatible 这两个属性值来查找Linux 是否支持这个单板。此函数也会获取设备树中 chosen 节点下的 bootargs 属性值来得到命令行参数，也就是 uboot 中的 bootargs 环境变量的值，获取到的命令行参数会保存到command_line 中</span></span><br><span class="line">mm_init_cpumask(&amp;init_mm) <span class="comment">//内存有关的初始化</span></span><br><span class="line">setup_command_line(command_line) <span class="comment">//存储命令行参数</span></span><br><span class="line">setup_nr_cpu_ids() <span class="comment">//如果只是 SMP(多核 CPU)的话，此函数用于获取CPU 核心数量，CPU 数量保存在变量nr_cpu_ids 中</span></span><br><span class="line">setup_per_cpu_areas() <span class="comment">//在 SMP 系统中有用，设置每个 CPU 的 per-cpu 数据</span></span><br><span class="line">smp_prepare_boot_cpu()</span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">/* 建立系统内存页区(zone)链表 */</span></span><br><span class="line">page_alloc_init(); <span class="comment">/* 处理用于热插拔 CPU 的页 */</span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line); <span class="comment">//打印命令行信息</span></span><br><span class="line">parse_early_param(); <span class="comment">/* 解析命令行中的 console 参数 */</span></span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">		static_command_line, __start___param,</span><br><span class="line">		__stop___param - __start___param,</span><br><span class="line">		<span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">setup_log_buf(<span class="number">0</span>); <span class="comment">/* 设置 log 使用的缓冲区*/</span></span><br><span class="line">pidhash_init(); <span class="comment">// 构建 PID 哈希表，Linux 中每个进程都有一个 ID,这个 ID 叫做 PID。通过构建哈希表可以快速搜索进程信息结构体</span></span><br><span class="line">idr_init_cache(); <span class="comment">// IDR 初始化，IDR 是 Linux 内核的整数管理机制，也就是将一个整数 ID 与一个指针关联起来</span></span><br><span class="line">rcu_init(); <span class="comment">// 初始化 RCU，RCU 全称为 Read Copy Update(读-拷贝修改)</span></span><br><span class="line">trace_init(); <span class="comment">// 跟踪调试相关初始化 </span></span><br><span class="line">radix_tree_init(); <span class="comment">//基数树相关数据结构初始化</span></span><br><span class="line">early_irq_init(); <span class="comment">//初始中断相关初始化,主要是注册 irq_desc 结构体变量，因为 Linux 内核使用 irq_desc 来描述一个中断</span></span><br><span class="line">init_IRQ(); <span class="comment">/* 中断初始化 */</span></span><br><span class="line">tick_init(); <span class="comment">/* tick 初始化 */</span></span><br><span class="line">init_timers(); <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">hrtimers_init(); <span class="comment">/* 初始化高精度定时器 */</span></span><br><span class="line">softirq_init(); <span class="comment">/* 软中断初始化 */</span></span><br><span class="line">timekeeping_init(); </span><br><span class="line">time_init(); <span class="comment">/* 初始化系统时间 */</span></span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable(); <span class="comment">/* 使能中断 */</span></span><br><span class="line">kmem_cache_init_late(); <span class="comment">/* slab 初始化，slab 是 Linux 内存分配器 */</span></span><br><span class="line">console_init(); <span class="comment">//初始化控制台，之前 printk 打印的信息都存放缓冲区中，并没有打印出来。只有调用此函数初始化控制台以后才能在控制台上打印信息</span></span><br><span class="line">locking_selftest() <span class="comment">/* 锁自测 */</span></span><br><span class="line">kmemleak_init(); <span class="comment">/* kmemleak 初始化，kmemleak 用于检查内存泄漏 */</span></span><br><span class="line">calibrate_delay(); <span class="comment">/* 测定 BogoMIPS 值，可以通过 BogoMIPS 来判断 CPU 的性能BogoMIPS 设置越大，说明 CPU 性能越好*/</span></span><br><span class="line">pidmap_init(); <span class="comment">/* PID 位图初始化 */</span></span><br><span class="line">anon_vma_init(); <span class="comment">/* 生成 anon_vma slab 缓存 */</span></span><br><span class="line">cred_init(); <span class="comment">/* 为对象的每个用于赋予资格(凭证) */</span></span><br><span class="line">fork_init(); <span class="comment">/* 初始化一些结构体以使用 fork 函数 */</span></span><br><span class="line">proc_caches_init(); <span class="comment">/* 给各种资源管理结构分配缓存 */</span></span><br><span class="line">buffer_init(); <span class="comment">/* 初始化缓冲缓存 */</span></span><br><span class="line">key_init(); <span class="comment">/* 初始化密钥 */</span></span><br><span class="line">security_init(); <span class="comment">/* 安全相关初始化 */</span></span><br><span class="line">vfs_caches_init(totalram_pages); <span class="comment">/* 为 VFS 创建缓存 */</span></span><br><span class="line">signals_init(); <span class="comment">/* 初始化信号 */</span></span><br><span class="line">page_writeback_init(); <span class="comment">/* 页回写初始化 */</span></span><br><span class="line">proc_root_init(); <span class="comment">/* 注册并挂载 proc 文件系统 */</span></span><br><span class="line">cpuset_init(); <span class="comment">/* 初始化 cpuset，cpuset 是将 CPU 和内存资源以逻辑性和层次性集成的一种机制，是 cgroup 使用的子系统之一*/</span></span><br><span class="line">cgroup_init(); <span class="comment">/* 初始化 cgroup */</span></span><br><span class="line">taskstats_init_early(); <span class="comment">/* 进程状态初始化 */</span></span><br><span class="line">check_bugs(); <span class="comment">/* 检查写缓冲一致性 */</span></span><br><span class="line">rest_init(); <span class="comment">/* rest_init 函数 */</span></span><br></pre></td></tr></table></figure>

<p>start_kernel完成内核初始化工作。具体包括以下部分：</p>
<p>（1）内核架构 、通用配置相关初始化</p>
<p>（2） 内存管理相关初始化</p>
<p>（3）进程管理相关初始化</p>
<p>（4）进程调度相关初始化</p>
<p>（5）网络子系统管理</p>
<p>（6）虚拟文件系统</p>
<p>（7）文件系统</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.1.png" alt="image-20240720151715291"></p>
<h6><span id="2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</span><a href="#2-1-1-1-1-1-setup-arch" class="header-anchor">#</a></h6><p>内核架构相关的初始化函数, 包含了处理器相关参数的初始化、内核启动参数（tagged list）的获取和前期处理、内存子系统的早期初始化。</p>
<p><code>setup_arch(&amp;command_line);</code></p>
<p>若uboot中bootargs的值为空，<code>command_line = default_command_line</code>，即为内核中的默认命令行参数，其值在<code>.config</code>文件中配置，对应<code>CONFIG_CMDLINE</code>配置项。</p>
<h6><span id="2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</span><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args" class="header-anchor">#</a></h6><p>完成命令行参数的解析、保存。譬如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmdline = console=ttySAC2,115200 root=/dev/mmcblk0p2 rw</span><br><span class="line">init=/linuxrc rootfstype=ext3 <span class="comment">#解析为一下四个参数：</span></span><br><span class="line">console=ttySAC2,115200 <span class="comment">#指定控制台的串口设备号，及其波特率</span></span><br><span class="line">root=/dev/mmcblk0p2 rw <span class="comment">#指定根文件系统rootfs的路径</span></span><br><span class="line">init=/linuxrc <span class="comment">#指定第一个用户进程init的路径rootf stype=ext3</span></span><br></pre></td></tr></table></figure>

<h6><span id="2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</span><a href="#2-1-1-1-1-n-reset-init" class="header-anchor">#</a></h6><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.2.png" alt="image-20240720161109653"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd。</span><br><span class="line">    kernel_init线程中调用prepare_namespace函数挂载根文件系统rootfs；</span><br><span class="line">    然后调用init_post函数，执行根文件系统rootfs下的第一个用户进程init。</span><br><span class="line">    用户进程有4个备选方案，若command_line中init的路径错误，则会执行备用方案。</span><br><span class="line">    第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。</span><br><span class="line"></span><br><span class="line">2）调用schedule函数开启内核调度系统；</span><br><span class="line">3）调用cpu_idle函数，启动空闲进程idle，完成内核启动。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init_refok <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">	rcu_scheduler_starting();</span><br><span class="line">	smpboot_thread_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment">	 * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment">	 * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	numa_default_policy();</span><br><span class="line">	pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment">	 * at least once to get things moving:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_idle_bootup_task(current);</span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数 rcu_scheduler_starting，启动 RCU 锁调度器。<br>调用函数 kernel_thread 创建 kernel_init 进程，也就是大名鼎鼎的 init 内核进程。init 进程的 PID 为 1。init 进程一开始是内核进程(也就是运行在内核态)，后面 init 进程会在根文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程序，init 进程就会实现从内核态到用户态的转变。<br>调用函数 kernel_thread 创建 kthreadd 内核进程，此内核进程的 PID 为 2。kthreadd进程负责所有内核进程的调度和管理。<br>最后调用函数 cpu_startup_entry 来进入 idle 进程，cpu_startup_entry 会调用cpu_idle_loop，cpu_idle_loop 是个 while 循环，也就是 idle 进程代码。idle 进程的 PID 为 0，idle进程叫做空闲进程，如果学过 FreeRTOS 或者 UCOS 的话应该听说过空闲任务。idle 空闲进程就和空闲任务一样，当 CPU 没有事情做的时候就在 idle 空闲进程里面“瞎逛游”，反正就是给CPU 找点事做。当其他进程要工作的时候就会抢占 idle 进程，从而夺取 CPU 使用权。其实大家应该可以看到 idle 进程并没有使用 kernel_thread 或者 fork 函数来创建，因为它是有主进程演变而来的。<br>在 Linux 终端中输入<code>“ps -A”</code>就可以打印出当前系统中的所有进程，其中就能看到 init 进程和 kthreadd 进程：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png" alt="image"><br>init 进程的 PID 为 1，kthreadd 进程的 PID 为 2。没有显示 PID 为 0 的 idle 进程，那是因为 idle 进程是内核进程。kernel_init 就是 init 进程的进程函数。</p>
<h2><span id="2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</span><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie" class="header-anchor">#</a></h2><p>把reset_init中的<code>kernel_init</code> 拆出来，函数<code>kernel_init</code> 就是 init 进程具体做的工作，函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	kernel_init_freeable(); <span class="comment">/* init 进程的一些其他初始化工作 */</span></span><br><span class="line">	<span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">	async_synchronize_full(); <span class="comment">/* 等待所有的异步调用执行完成 */</span></span><br><span class="line">	free_initmem(); <span class="comment">/* 释放 init 段内存 */</span></span><br><span class="line">	mark_rodata_ro();</span><br><span class="line">	system_state = SYSTEM_RUNNING; <span class="comment">/* 标记系统正在运行 */</span></span><br><span class="line">	numa_default_policy();</span><br><span class="line"></span><br><span class="line">	flush_delayed_fput();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">		ramdisk_execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment">	* trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		ret = run_init_process(execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class="line">		execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No working init found. Try passing init= option to kernel. &quot;</span></span><br><span class="line">	<span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kernel_init_freeable </code>函数用于完成 init 进程的一些其他初始化工作，稍后再来具体看一下此函数。<br><code>ramdisk_execute_command </code>是一个全局的 char 指针变量，此变量值为<code>“/init”</code>，也就是根目录下的 init 程序。<code>ramdisk_execute_command </code>也可以通过 uboot 传递，在 bootargs 中使用<code>“rdinit=xxx”</code>即可，xxx 为具体的 init 程序名字。<br>如果存在<code>“/init”</code>程序的话就通过函数 <code>run_init_process </code>来运行此程序。<br>如果 <code>ramdisk_execute_command </code>为空的话就看 <code>execute_command </code>是否为空，反正不管如何一定要在根文件系统中找到一个可运行的 init 程序。<code>execute_command</code> 的值是通过uboot 传递，在 bootargs 中使用<code>“init=xxxx”</code>就可以了，比如<code>“init=/linuxrc”</code>表示根文件系统中的 linuxrc 就是要执行的用户空间 init 程序。<br>如果<code>ramdisk_execute_command</code>和 <code>execute_command </code>都为空，那么就依次查找<code>“/sbin/init”</code>、<code>“/etc/init”</code>、<code>“/bin/init”</code>和<code>“/bin/sh”</code>，这四个相当于备用 init 程序，如果这四个也不存在，那么 Linux 启动失败！<br>如果以上步骤都没有找到用户空间的 init 程序，那么就提示错误发生！</p>
<h3><span id="2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</span><a href="#2-2-1-kernel-init-freeable" class="header-anchor">#</a></h3><p><code>kernel_init_freeable </code>定义在文件 init&#x2F;main.c 中，缩减后的函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title function_">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Wait until kthreadd is all set-up.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	wait_for_completion(&amp;kthreadd_done);<span class="comment">/* 等待 kthreadd 进程准备就绪 */</span></span><br><span class="line">	smp_init(); <span class="comment">/* SMP 初始化 */</span></span><br><span class="line">	sched_init_smp(); <span class="comment">/* 多核(SMP)调度初始化 */</span></span><br><span class="line">	do_basic_setup(); <span class="comment">/* 设备初始化都在此函数中完成 */</span></span><br><span class="line">	<span class="comment">/* Open the /dev/console on the rootfs, this should never fail */</span></span><br><span class="line">	<span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)	</span><br><span class="line">		pr_err(<span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* check if there is an early userspace init. If yes, let it do </span></span><br><span class="line"><span class="comment">	* all the work</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">		ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (sys_access((<span class="type">const</span> <span class="type">char</span> __user *) ramdisk_execute_command, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ramdisk_execute_command = <span class="literal">NULL</span>;</span><br><span class="line">		prepare_namespace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Ok, we have completed the initial bootup, and</span></span><br><span class="line"><span class="comment">	* we&#x27;re essentially up and running. Get rid of the</span></span><br><span class="line"><span class="comment">	* initmem segments and start the user-mode stuff..</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* rootfs is available now, try loading the public keys</span></span><br><span class="line"><span class="comment">	* and default modules</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	integrity_load_keys();</span><br><span class="line">	load_default_modules();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-1-1-driver-init">2.2.1.1 driver_init</span><a href="#2-2-1-1-driver-init" class="header-anchor">#</a></h4><p><code>do_basic_setup</code> 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 <code>driver_init </code>函数完成 Linux 下驱动模型子系统的初始化。</p>
<h4><span id="2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</span><a href="#2-2-1-2-she-zhi-kong-zhi-tai" class="header-anchor">#</a></h4><p>打开设备<code>“/dev/console”</code>，在 Linux 中一切皆为文件！因此<code>“/dev/console”</code>也是一个文件，此文件为控制台设备。每个文件都有一个文件描述符，此处打开的<code>“/dev/console”</code>文件描述符为 0，作为标准输入(0)。<br><code>sys_dup </code>函数将标准输入(0)的文件描述符复制了 2 次，一个作为标准输出(1)，一个作为标准错误(2)。这样标准输入、输出、错误都是&#x2F;dev&#x2F;console 了。console 通过uboot 的 bootargs 环境变量设置，<code>“console=ttymxc0,115200”</code>表示将<code>/dev/ttymxc0 </code>设置为 console，也就是 I.MX6U 的串口 1。当然，也可以设置其他的设备为 console，比如虚拟控制台 tty1，设置 tty1 为 console 就可以在 LCD 屏幕上看到系统的提示信息。</p>
<h4><span id="2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</span><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong" class="header-anchor">#</a></h4><p>调用函数 <code>prepare_namespace</code> 来挂载根文件系统。根文件系统也是由命令行参数指定的，就是 uboot 的 bootargs 环境变量。比如<code>“root=/dev/mmcblk1p2 rootwait rw”</code>就表示根文件系统在&#x2F;dev&#x2F;mmcblk1p2 中，也就是 EMMC 的分区 2 中。</p>
<p>下面2张图都是emmc存储，分别挂载ext3格式和squashfs格式根文件系统：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image"><br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image"></p>
<p>如果根文件系统缺失错误，这里我们故意将:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200&#x27;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>这时候挂载根文件系统时，由于没有指定<code>root=/dev/mmcblk1p2 rootwait rw</code>，因此报错如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image"><br>还能看到call trace如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image"></p>
<h5><span id="2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</span><a href="#2-2-1-3-1-init-fu-wu" class="header-anchor">#</a></h5><p>启动init服务时，init服务会读取<code>/etc/inittab</code>文件，<code>/etc/inittab</code>中设置了初始化系统环境的工作。 <code>/etc/inittab</code>定义 init 服务在 linux启动过程中必须依序执行以下几个Script ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/rc.sysinit</span><br><span class="line">/etc/rc.d/rc</span><br><span class="line">/etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<h6><span id="2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</span><a href="#2-2-1-3-1-1-rc-sysinit" class="header-anchor">#</a></h6><p><code>/etc/rc.d/rc.sysinit</code>主要的功能是设置系统的基本环境:</p>
<p>(1)启动<code>udev</code></p>
<p>(2)设置内核参数：执行<code>sysctl –p</code> ,以便从 <code>/etc/sysctl.conf </code>设置内核参数</p>
<p>(3)设置系统时间：将硬件时间设置为系统时间</p>
<p>(4)启用交换内存空间：执行<code> swpaon –a –e</code>，以便根据<code>/etc/fstab</code>的设置启用所有的交换内存空间。</p>
<p>(5)检查并挂载所有文件系统：检查所有需要挂载的文件系统，以确保这些文件系统的完整性。检查完毕后以可读可写的方式挂载文件系统。</p>
<p>(6)初始化硬件设备：Linux除了在启动内核时以静态驱动程序驱动部分的硬件外，在执行<code>rc.sysinit </code>时，也会试着驱动剩余的硬件设备</p>
<h1><span id="3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</span><a href="#3-linux-nei-he-initcall-ji-zhi" class="header-anchor">#</a></h1><p>linux内核提供<code>xxx_init(init_func)</code>宏定义接口,驱动开发者只需要将驱动程序的<code>init_func</code>使用<code>xxx_init()</code>来修饰，这个函数就被自动添加到了上述的段中，开发者完全不需要关心实现细节。</p>
<h2><span id="3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</span><a href="#3-1-xxx-initcall-de-yuan-ma" class="header-anchor">#</a></h2><p>在平台对应的<code>init.h</code>文件中，可以找到<code>xxx_initcall</code>的定义：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image"></p>
<p>n是一个数字或者是数字+s，这个数字代表这个fn执行的优先级，数字越小，优先级越高，带s的fn优先级低于不带s的fn优先级。可以看到上面的从<code>pure_initcall</code>到<code>late_initcall</code>优先级依次变低。</p>
<p>这里<code>__attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;)))</code>表示编译时将目标符号放置在括号指定的段中。</p>
<p>举个例子，对<code>pure_initcall(test_init);</code>展开：</p>
<ul>
<li>首先宏展开成：<code>__define_initcall(test_init, 0)</code></li>
<li>然后接着展开：<code>static initcall_t __initcall_test_init0 = test_init;</code>这就是一个简单的变量定义。</li>
<li>同时声明<code>__initcall_test_init0这个变量</code>即使没被引用也保留符号，且将其放置在内核镜像的<code>.initcall0.init</code>段处。</li>
</ul>
<p>在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<h2><span id="3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</span><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong" class="header-anchor">#</a></h2><p>见<code>Linux-4.9.88\init\main.c</code></p>
<h3><span id="3-2-1-do-initcalls">3.2.1 do_initcalls</span><a href="#3-2-1-do-initcalls" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">-&gt; rest_init();</span><br><span class="line">    -&gt; kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">        -&gt; kernel_init()</span><br><span class="line">            -&gt; kernel_init_freeable();</span><br><span class="line">                -&gt; do_basic_setup();</span><br><span class="line">                    -&gt; do_initcalls();</span><br></pre></td></tr></table></figure>

<p>这个<code>do_initcalls()</code>就是我们需要寻找的函数了，在这个函数中执行所有使用<code>xxx_initcall()</code>声明的函数。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png" alt="image"></p>
<p><code>do_initcalls() </code>循环调用 <code>do_initcall_level(level)</code>，level就是 <code>initcall </code>的优先级数字，由 for 循环的终止条件<code>ARRAY_SIZE(initcall_levels) - 1</code>可知，总共会调用8次。</p>
<p>而 <code>do_initcall_level(level)</code> 中则会遍历 <code>initcall_levels[level] </code>中的每个函数指针，<code>initcall_levels[level] </code>实际上是对应的<code>__initcall##level##_start </code>指针变量，然后依次取出<code>__initcall##level##_start </code>指向地址存储的每个函数指针，并调用 <code>do_one_initcall(*fn)</code>，实际上就是执行当前函数。</p>
<p>这个<code>__initcall##level##_start </code>所存储的函数指针就是开发者用 <code>xxx_initcall() </code>宏添加的函数，对应<code>&quot;.initcall_##level##.init&quot;</code>段。</p>
<p>听起来很绕，举个例子：</p>
<p>比如有一个<code>core_initcall(beagle_init);</code>展开为<code>__define_initcall(beagle_init, 1)</code>，所以 <code>beagle_init() </code>这个函数被放置在<code> &quot;.initcall1.init&quot;</code>段处。</p>
<p>再比如有一个<code>core_initcall(beagle2_init);</code>, 在<code> &quot;.initcall1.init&quot;</code>段就会增加一组函数。</p>
<p>那么<code>do_one_initcall(*fn)</code> 的执行：判断<code>initcall_debug</code>的值，如果为真，则调用 <code>do_one_initcall_debug(fn); </code>如果为假，则直接调用<code>fn</code>。</p>
<p>事实上，调用<code>do_one_initcall_debug(fn)</code>只是在调用<code>fn</code>的基础上添加一些额外的打印信息，可以直接看成是调用<code>fn</code>。</p>
<p>可能有些C语言基础不太好的朋友不太理解 <code>do_initcall_level() </code>函数中依次取出地址并执行的函数执行逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">    do_one_initcall(*fn);</span><br></pre></td></tr></table></figure>

<p><code>fn</code>为函数指针，<code>fn++</code>相当于函数指针+1，相当于：<code>内存地址+sizeof(fn)</code>，<code>sizeof(fn)</code>根据平台不同而不同，一般来说，32位机上是4字节，64位机则是8字节.</p>
<p>也就是在同等level下，会从同一个<code>&quot;.initcall_##level##.init&quot;</code>段中依次取出对应的函数指针。<br>也就是从<code>&quot;.initcall##level##.init&quot;</code>段开始，每次取一个函数出来执行，并累加指针，直到取完（即到了下一个段的起始地址就表示取完了）。</p>
<h4><span id="3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</span><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian" class="header-anchor">#</a></h4><p>前面说了在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<p>在<code>do_initcall()</code>的时候，却是从<code>initcall_levels[level]</code>(即<code>__initcall##level##_start</code>指针)取出，那么</p>
<p><code>initcall_levels[level] </code>是怎么关联到<code>&quot;.initcall##level##.init&quot;</code>段的呢？</p>
<p>在vmlinux.lds.h中：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png" alt="image"></p>
<p>关联到<code>&quot;.initcallearly.init&quot;</code>段。</p>
<p>然后对每个 level 定义了<code>INIT_CALLS_LEVEL(level)</code>，将<code>INIT_CALLS_LEVEL(level)</code>展开之后的结果是定义<code> __initcall##level##_start</code>,并将<code>__initcall##level##_start</code>关联到 <code>&quot;.initcall##level##.init&quot; </code>段和<code>&quot;.initcall##level##s.init&quot;</code>段。</p>
<p>到这里，<code>__initcall##level##_start </code>和<code>&quot;.initcall##level##.init&quot;</code>段的对应就比较清晰了，所以，从 <code>initcall_levels[level] </code>部分一个个取出函数指针并执行函数就是执行<code>xxx_init_call()</code>定义的函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" data-id="clzp8utsy000e9oufe83h6ohz" data-title="Linux内核启动流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E7%94%A8%E6%88%B7%E6%80%81%E6%9E%84%E9%80%A0IP%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%AF%BB%E5%86%99%E5%AF%84%E5%AD%98%E5%99%A8/">字符设备驱动-用户态构造IP寄存器结构体和读写寄存器</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-ioctl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">字符设备驱动-ioctl命令详解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>