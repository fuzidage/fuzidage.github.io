<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-s3c2440裸机编程-电阻触摸屏" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T07:13:12.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/">s3c2440裸机编程-电阻触摸屏</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</a><ul>
<li><a href="#1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</a></li>
<li><a href="#1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</a></li>
</ul>
</li>
<li><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</a><ul>
<li><a href="#2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</a></li>
<li><a href="#2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</a></li>
<li><a href="#2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</a></li>
<li><a href="#2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</a><ul>
<li><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</a></li>
<li><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</a><ul>
<li><a href="#3-1-normal-conversion-mode">3.1 Normal Conversion Mode</a></li>
<li><a href="#3-2-separate-x-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</a></li>
<li><a href="#3-3-auto-sequential-x-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</a></li>
<li><a href="#3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</a></li>
</ul>
</li>
<li><a href="#4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</a><ul>
<li><a href="#4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</a></li>
<li><a href="#4-2-data-ji-cun-qi">4.2 DATA寄存器</a><ul>
<li><a href="#4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</a></li>
<li><a href="#4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</a></li>
</ul>
</li>
<li><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</a></li>
</ul>
</li>
<li><a href="#5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</a><ul>
<li><a href="#5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</a><ul>
<li><a href="#5-1-1-zhong-duan-yuan">5.1.1 中断源</a></li>
<li><a href="#5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</a></li>
<li><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</a></li>
<li><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</a><ul>
<li><a href="#5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</a></li>
<li><a href="#5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</a><ul>
<li><a href="#5-2-1-chu-shi-hua">5.2.1 初始化</a><ul>
<li><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</a></li>
<li><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</a></li>
<li><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</a></li>
</ul>
</li>
<li><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</a><ul>
<li><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</a><ul>
<li><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</a></li>
<li><a href="#5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</a></li>
</ul>
</li>
<li><a href="#5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</a></li>
<li><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</a><ul>
<li><a href="#5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</a></li>
<li><a href="#5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</a><ul>
<li><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</a><ul>
<li><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</span><a href="#1-dian-zu-hong-mo-ping-yuan-li" class="header-anchor">#</a></h1><p>触摸屏包含上下叠合的两个透明层，一般覆盖在lcd表面，两个透明层是由均匀的电阻介质组成，如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png"></p>
<p>当触摸屏表面受到的压力（如通过笔尖或手指进行按压）足够大时，顶层与底层之间的薄膜会产生接触，此时会形成x方向和y方向的坐标。那么x，y坐标的值是怎么得来的呢？本质上就是通过ADC转换得来的。</p>
<p>触摸屏的等效电路可以看成如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg"></p>
<p>计算触点的X，Y坐标分为如下两步： </p>
<h2><span id="1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</span><a href="#1-1-ji-suan-y-zuo-biao" class="header-anchor">#</a></h2><p>在Y+电极施加驱动电压Vdrive， Y-电极接地，由于上下两层膜形成触点，X+做为触点的引出端，测量得到接触点的电压，触点电压与Vdrive电压之比等于触点Y坐标与屏高度之比。如下图：</p>
<h2><span id="1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</span><a href="#1-2-ji-suan-x-zuo-biao" class="header-anchor">#</a></h2><p>在X+电极施加驱动电压Vdrive， X-电极接地，由于上下两层膜形成触点，Y+做为触点的引出端，测量得到接触点的电压，Y+做为引出端测量得到接触点的电压，触点电压与Vdrive电压之比等于触点X坐标与屏宽度之比。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg"></p>
<h1><span id="2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</span><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi" class="header-anchor">#</a></h1><h2><span id="2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</span><a href="#2-1-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h2><p>平时的时候上下两层膜并不粘在一起，我们把这种状态称为<strong>“等待中断模式”</strong>， 等效电路如下图的右边那幅图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png"></p>
<p>s5、s4闭合，s1、s2、s3断开，这个时候Y_ADC&#x2F;XP通过S5接上拉电阻，处于高电平状态,X_ADC&#x2F;YP接地。没法读取x,y坐标。</p>
<h2><span id="2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</span><a href="#2-2-du-qu-x-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给X方向通电，也就是让S1、S3开关闭合，s2、s4断开，那么当屏幕按下，触点YP的电平就对应x坐标。（XP到XM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png"></p>
<pre><code>x_adc电压/vcc = x坐标/width, 所以x坐标= width * x_adc电压/vcc
</code></pre>
<h2><span id="2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</span><a href="#2-3-du-qu-y-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给Y方向通电，也就是让S2、S4开关闭合，s1、s3断开，那么当屏幕按下，触点XP的电平就对应y坐标。（YP到YM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png"></p>
<pre><code>y_adc电压/vcc = Y坐标/height, 所以y坐标= height * y_adc电压/vcc
</code></pre>
<h2><span id="2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</span><a href="#2-4-ts-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>总结一下单次触发TS中断，使用触摸屏的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 按下触摸屏，产生TS中断</span><br><span class="line"><span class="number">2.</span> 启动ADC(目的是获取x,y方向上的坐标值)</span><br><span class="line"><span class="number">3.</span> ADC转换完成，产生adc中断（adc转换需要一定的时间）</span><br><span class="line"><span class="number">4.</span> ADC中断中来读取x y坐标</span><br><span class="line"><span class="number">5.</span> 松开，结束</span><br></pre></td></tr></table></figure>

<p>我们知道，现在的手机都是支持屏幕滑动翻页和长按的功能。那么这些功能是如何做到的呢？</p>
<h3><span id="2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</span><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi" class="header-anchor">#</a></h3><p>如何让触摸屏支持长按或者滑动操作（多次触发TS中断）？</p>
<p>答案:<strong>定时器</strong>，当长按屏幕，会产生多次TS中断，因此我们需要用定时器来判断，当定时一段时间后，还有TS中断产生，那么我们认为是长按操作，进行中断响应。滑动也是类似的道理，当定时时间到后，如果还有TS中断产生，且坐标发生了改变，就认为是滑动操作。</p>
<pre><code>&lt;5&gt; 启动定时器
&lt;6&gt; 一段时间后，定时器中断发生，判断触摸屏是否仍被按下(是否有定时器中断产生)，如果有就循环上述过程&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;
</code></pre>
<p>可以用如下流程图概括TSC的整个SW flow.</p>
<h3><span id="2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</span><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png" alt="image"></p>
<h1><span id="3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</span><a href="#3-hong-mo-ping-jie-kou-mo-shi" class="header-anchor">#</a></h1><h2><span id="3-1-normal-conversion-mode">3.1 Normal Conversion Mode</span><a href="#3-1-normal-conversion-mode" class="header-anchor">#</a></h2><p>正常转换模式，一般情况下可以配置ADCCON和ADCDAT0来读取数据。</p>
<h2><span id="3-2-separate-x-x2f-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</span><a href="#3-2-separate-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png"><br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png"></p>
<p>x,y坐标分离转换格式，x坐标会写入ADCDAT0, y坐标会写入ADCDAT1,所以会产生2次中断开分开完成x,y的坐标转换。</p>
<h2><span id="3-3-auto-sequential-x-x2f-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</span><a href="#3-3-auto-sequential-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p>自动转换模式，当触摸屏按下后，会一次性对x,y方向的坐标进行转换，x坐标会写入ADCDAT0, x坐标会写入ADCDAT1。会产生一次中断进行x,y坐标的自动转换。 </p>
<h2><span id="3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</span><a href="#3-4-waiting-for-interrupt-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg"></p>
<p> 等待中断模式 。可以设置rADCTSC&#x3D;0xd3;也就是对应下图寄存器 &#x2F;&#x2F; XP_PU, XP_Dis, XM_Dis, YP_Dis, YM_En.当产生中断信号(INT_TC)后，等待中断模式必须清除.(即XY_PST sets to the No operation Mode).</p>
<h1><span id="4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</span><a href="#4-hong-mo-ping-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</span><a href="#4-1-ts-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p>电阻触摸屏的原理本质上就是ADC，ADC相关寄存器介绍详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13396987.html">s3c2440裸机-ADC编程</a>或者<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC | Hexo (fuzidage.github.io)</a><br>TSC相比ADC多了一个ADCTSC寄存器，如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg" alt="image"><br>当bit[2]&#x3D;0，normal mode时，那么bit[1:0]需要配置成01或者10进行手工测量x,y.<br>当bit[2]&#x3D;1，auto mode时，那么bit[1:0]需要配置成0,进行自动测量。</p>
<h2><span id="4-2-data-ji-cun-qi">4.2 DATA寄存器</span><a href="#4-2-data-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</span><a href="#4-2-1-x-zuo-biao-adcdata0" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png" alt="image"></p>
<h3><span id="4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</span><a href="#4-2-2-y-zuo-biao-adcdata1" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png" alt="image"></p>
<h2><span id="4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</span><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi" class="header-anchor">#</a></h2><p>这个寄存器可以检测是否有触摸中断产生，是按下触摸屏了，还是松开触摸屏了。<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png" alt="image"></p>
<h1><span id="5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</span><a href="#5-hong-mo-ping-bian-cheng-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</span><a href="#5-1-adc-zhong-duan-chan-sheng" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png" alt="img"></p>
<h3><span id="5-1-1-zhong-duan-yuan">5.1.1 中断源</span><a href="#5-1-1-zhong-duan-yuan" class="header-anchor">#</a></h3><p>ADC和TSC共用一个中断源，如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png" alt="img"></p>
<p>SRCPND表示哪个中断源产生了中断请求。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png" alt="img"></p>
<h3><span id="5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</span><a href="#5-1-2-zhong-duan-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png" alt="img"></p>
<h3><span id="5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</span><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png" alt="img"></p>
<h3><span id="5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</span><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi" class="header-anchor">#</a></h3><p>用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png" alt="img"></p>
<p>从SRCPND寄存器可以读到ADC和TSC复用的同一个中断源，那么如何区分呢？</p>
<p>可以从SUBSRCPND寄存器配置，如下：</p>
<h4><span id="5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</span><a href="#5-1-4-1-subsrcpnd-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png" alt="img"></p>
<p> 当bit 9被置1时，表示TSC中断。那么我们需要打开subsrcmask寄存器：</p>
<h4><span id="5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</span><a href="#5-1-4-2-intsubmsk-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png" alt="img"></p>
<p>所以TSC中断的产生流程如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png" alt="img"></p>
<h2><span id="5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</span><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化TSC，ADCTSC寄存器</span><br><span class="line"><span class="number">2.</span> 设定TSC处于“等待中断模式”</span><br><span class="line"><span class="number">3.</span> 使能TSC中断</span><br><span class="line">　　　　　　INTSUBMSK</span><br><span class="line">　　　　　　MSK/MODE</span><br><span class="line"><span class="number">4.</span> 按下，进入TSC中断</span><br><span class="line">　　　　　　进入自动采集转换模式</span><br><span class="line">　　　　　　启动ADC</span><br><span class="line"><span class="number">5.</span> ADC中断</span><br><span class="line">　　　　　　读数据</span><br><span class="line">　　　　　　再次进入”等待中断模式“</span><br><span class="line">　　　　　　启动定时器（为了处理长按或者滑动操作）</span><br><span class="line"><span class="number">6.</span> 定时器中断</span><br><span class="line">　　　　　　若松开，结束</span><br><span class="line">　　　　　　如任然按下，进入步骤<span class="number">4</span>的启动ADC流程</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png" alt="img"></p>
<h3><span id="5-2-1-chu-shi-hua">5.2.1 初始化</span><a href="#5-2-1-chu-shi-hua" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置触摸屏接口:寄存器 */</span></span><br><span class="line">    adc_ts_reg_init();</span><br><span class="line">    <span class="comment">/* 设置中断 */</span></span><br><span class="line">    adc_ts_int_init();</span><br><span class="line">    <span class="comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</span><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>主要是设置预分频，产生ADC clk &#x3D; 1MHz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">     * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">     * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">     * [2]   : STDBM</span></span><br><span class="line"><span class="comment">     * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    ADCDLY = <span class="number">0xff</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</span><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua" class="header-anchor">#</a></h4><p>为了将中断源开启，这里设置SUBSRCPND 和INTSUBMSK让中断源开启。通过register_irq（）注册中断号和中断服务程AdcTsIntHandle，查表得出中断号为31，这样当硬件产生中断后可以从INTOFFSET区分是哪个中断号。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_int_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    register_irq(<span class="number">31</span>, AdcTsIntHandle);    <span class="comment">/*31号中断*/</span></span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    INTSUBMSK &amp;= ~((<span class="number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="number">1</span>&lt;&lt;TC_INT_BIT));<span class="comment">//防止屏蔽（SUBMSK）</span></span><br><span class="line">    <span class="comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);//reg_irq已经使能了31中断号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</span><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png" alt="img"></p>
<p>进入等待中断模式，YM闭合， YP， XP， XM断开，需要pull up，WAIT_PEN_DOWN表示要等待的是按下中断，当触摸屏按下时就会产生一个TSC irq,反之WAIT_PEN_UP表示要等待的是松开中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_INT_BIT (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_INT_BIT  (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_ADC_TC   (31)</span></span><br><span class="line"><span class="comment">/* ADCTSC&#x27;s bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8) <span class="comment">/*触摸笔按下*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8) <span class="comment">/*触摸笔松开*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)    <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)    <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_down_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待按下模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | 	WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_up_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待松开模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</span><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h3><p>SUBSRCPND的bit9, bit10可以区分是TC中断还是ADC中断。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*触摸屏中断服务程序*/</span> &#123;</span><br><span class="line">　　	<span class="built_in">printf</span>(<span class="string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br><span class="line">　　	<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">//dat寄存器的第15位判断按下还是松开</span></span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">　　　　	enter_wait_pen_down_mode();</span><br><span class="line">　　	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">　　　　	<span class="comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span></span><br><span class="line">　　　　	enter_wait_pen_up_mode();</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　	<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT)) <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　	Isr_Tc();</span><br><span class="line">　　	<span class="comment">// if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT)) /* ADC中断 */</span></span><br><span class="line">　　	<span class="comment">// Isr_Adc();</span></span><br><span class="line">　　	SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">　　	<span class="comment">//SRCPND = 1&lt;&lt;31;/*在interrupt.c已经清中断了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AdcTsIntHandle函数： 这里先注解掉ADC中断，只检测单独的按下松开触摸屏操作。那当isr处理完后为了能够正常响应下一次中断，需要清中断，否则会一直触发interrupt。</span><br><span class="line">Isr_Tc函数：ADCDAT0 寄存器的第15位判断按下还是松开。那么当按下后，要将控制器进入”等待松开模式“，当松开后，要将控制器配置进入”等待按下模式“。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png" alt="img"></p>
<h4><span id="5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</span><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao" class="header-anchor">#</a></h4><h5><span id="5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</span><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi" class="header-anchor">#</a></h5><p>Auto(Sequential) X&#x2F;Y Position Conversion Mode。打开TS控制寄存器，也就是ADCTSC寄存器：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png" alt="img"></p>
<p>让bit[2] &#x3D;1, bit[1:0]&#x3D;00，则会进入auto measurement。如果bit[2]&#x3D;0，则需配置bit[1::0]&#x3D;01 or 10是手动测量x,y坐标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)        <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)        <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_auto_measure_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　ADCTSC = AUTO_PST | NO_OPR_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</span><a href="#5-2-2-1-2-qi-dong-adc" class="header-anchor">#</a></h5><p>触摸屏坐标就是通过ADC获取的。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以TSC isr程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">/*触摸屏中断服务程序*/</span></span><br><span class="line">      <span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">            enter_wait_pen_down_mode();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">            <span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">            enter_auto_measure_mode();</span><br><span class="line">            <span class="comment">/* 启动ADC */</span></span><br><span class="line">            ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当检测到按下后，需要进入auto measure mode，启动adc，然后就会进行自动坐标转换，转换结束后又会触发ADC中断，再次进入<code>AdcTsIntHandle</code>函数，进而进入<code>Isr_Adc</code>，SUBSRCPND可以区分中断源 。如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT))  <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="comment">/* ADC中断 */</span></span><br><span class="line">　　　　Isr_Adc();</span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道ADC进行坐标转换结束后，那么会产生ADC中断，在<code>Isr_Adc</code>中即可获取我们的x,y坐标数据。由于我们按下后是进入了 “自动测量” 模式，因此那当数据获取完后我们得进入 “等待松开” 模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="type">int</span> x = ADCDAT0;</span><br><span class="line">      <span class="type">int</span> y = ADCDAT1;</span><br><span class="line">      <span class="keyword">if</span> (!(ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))) &#123; <span class="comment">/* 在isr_Tc按下后，如果仍然按下才打印 */</span></span><br><span class="line">            x &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            y &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      enter_wait_pen_up_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能触摸屏的测量过程非常长，那当ADC转换结束后，它已经松开了，这时不应该进行打印出坐标，所以这里在isr_Tc按下后，如果仍然按下才打印。</p>
<h4><span id="5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</span><a href="#5-2-2-2-adcdly-ji-cun-qi" class="header-anchor">#</a></h4><p>由于触摸屏采样的转换速率问题，按下后需要过一段电压才能稳定下来，那么数据才能稳定可能需要一定的延迟，所以需要配置ADC delay，让ADC慢一点产生中断，也就是等坐标稳定后在通知用户。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png" alt="img"></p>
<p>ADCDLY就是用来延时ADC启动的时间，让数据稳定后再进行转换。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png" alt="img"></p>
<p><code>可以看到，进行auto or manual measure 坐标转换的时序要满足：A = Dx,D表示ADCDLY的值。 现在晶振的频率是12Mhz, 那么根据触摸屏规格书我们取A= 5ms，那么D= 0.005s *12*1000000 = 60000，所以ADCDLY配置成60000.</code></p>
<p>修改前面的<code>adc_ts_reg_init</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">       * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">       * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">       * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">       * [2]   : STDBM</span></span><br><span class="line"><span class="comment">       * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">      <span class="comment">/*  按下触摸屏, 延时一会再发出TC中断</span></span><br><span class="line"><span class="comment">       *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCDLY = <span class="number">60000</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</span><a href="#5-3-ts-hong-mo-ping-ce-shi" class="header-anchor">#</a></h2><p>从左往右依次点击触摸屏，可以看到x坐标没有明显变化，y坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png" alt="img"></p>
<p>同理，从上往下依次按下触摸屏，可以看到y坐标没有明显变化，x坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png" alt="img"></p>
<p>这里是由于硬件上xp与yp接反了，ym与xm接反了，如下图：但这里并不影响我们的时候，这里我们软件上可以进行x,y坐标的转换：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png" alt="img"></p>
<p>我们软件上可以对x,y轴进行flip， mirror, rotaion旋转等一系列操作即可。比如：</p>
<p>Case1：ts与lcd吻合</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png" alt="img"></p>
<p>Case2：ts与lcd相反</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png" alt="img"></p>
<h2><span id="5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</span><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong" class="header-anchor">#</a></h2><h3><span id="5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</span><a href="#5-4-1-gai-jin-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有讲到在<code>handle_irq_c()</code>中去区分中断源，执行不同的<code>isr</code>。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png" alt="image-20240501173712329"></p>
<p>那现在通过<code>register_timer</code>注册对应的定时器中断服务程序，<code>timer_irq</code>进行执行不同的定时器中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_NUM  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL  ((void *)0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*timer_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_desc</span> &#123;</span></span><br><span class="line">　　<span class="type">char</span> *name;</span><br><span class="line">　　timer_func fp;</span><br><span class="line">&#125;timer_desc, *p_timer_desc;</span><br><span class="line"></span><br><span class="line">timer_desc timer_array[TIMER_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">register_timer</span><span class="params">(<span class="type">char</span> *name, timer_func fp)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = name;</span><br><span class="line">　　　　　　timer_array[i].fp   = fp;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_timer</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(timer_array[i].name, name)) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　timer_array[i].fp   = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].fp();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要用timer来进行进行流水灯实验，那么假如点灯函数为:<br><code>Isr_timer_led()&#123;&#125;</code></p>
<p>那么则只需要在<code>led init</code>的时候进行调用<code>register_timer(“led”, Isr_timer_led)</code>, 那么当时间到后触发定时器中断，便会执行<code>timer_irq</code>.进入<code>Isr_timer_led</code>。</p>
<h3><span id="5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</span><a href="#5-4-2-chu-shi-hua-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有具体讲解，这里采用PWM定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="comment">/* 设置TIMER0的时钟 */</span></span><br><span class="line">　　<span class="comment">/* Timer clk = PCLK / &#123;prescaler value+1&#125; / &#123;divider value&#125;</span></span><br><span class="line"><span class="comment">             = 50000000/(49+1)/16</span></span><br><span class="line"><span class="comment">             = 62500</span></span><br><span class="line"><span class="comment"> 　　*/</span></span><br><span class="line">　　TCFG0 = <span class="number">49</span>;  <span class="comment">/* Prescaler 0 = 49, 用于timer0,1 */</span></span><br><span class="line">　　TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">　　TCFG1 |= <span class="number">3</span>;  <span class="comment">/* MUX0 : 1/16 */</span></span><br><span class="line">　　<span class="comment">/* 设置TIMER0的初值 */</span></span><br><span class="line">　　TCNTB0 = <span class="number">625</span>;  <span class="comment">/* 10Ms中断一次 */</span></span><br><span class="line">　　<span class="comment">/* 加载初值, 启动timer0 */</span></span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);   <span class="comment">/* Update from TCNTB0 &amp; TCMPB0 */</span></span><br><span class="line">　　<span class="comment">/* 设置为自动加载并启动 */</span></span><br><span class="line">　　TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">/* bit0: start, bit3: auto reload */</span></span><br><span class="line">　　<span class="comment">/* 设置中断 */</span></span><br><span class="line">　　register_irq(<span class="number">10</span>, timer_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</span><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong" class="header-anchor">#</a></h4><p>我们之前是2s timer触发一次中断，那如果是要支持触摸屏，我们必须让定时器10ms就触发一次中断。因此需要修改timer_init中的寄存器参数。</p>
<p>当按下触摸屏会产生TSC中断，然后启动ADC进而产生<code>adc</code>中断的时候，在<code>Isr_Adc</code>函数中进行定时器的设置，检测长按和滑动操作。</p>
<h5><span id="5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</span><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_status_of_ts_timer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> g_ts_timer_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 每10ms该函数被调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (get_status_of_ts_timer() == <span class="number">0</span>)</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">/* 如果松开 */</span></span><br><span class="line">　　　　ts_timer_disable();</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;  <span class="comment">/* 按下状态 */</span></span><br><span class="line">　　　　<span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">　　　　enter_auto_measure_mode();</span><br><span class="line">　　　　<span class="comment">/* 启动ADC */</span></span><br><span class="line">　　　　ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png" alt="image-20240501174908562"></p>
<p>来分析一下这个程序的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在touchscreen_init的时候我们先注册了一个timer，然后修改了定时器的产生中断的时间间隔为<span class="number">10</span>ms中断一次，所以touchscreen_timer_irq会每间隔<span class="number">10</span>ms调用一次。没有按下，则touchscreen_timer_irq虽然也有走，但是就直接<span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 然后如果按下触摸屏，产生tsc中断，启动adc，产生adc中断。</span><br><span class="line"></span><br><span class="line">如果产生了adc中断，但是读取状态发现已经松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效。那么要是状态是被按下，则开启ts_timer_enable。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 当使能touchscreen_timer_irq这个定时器中断服务程序后，并且<span class="number">10</span>ms到了touchscreen_timer_irq函数执行生效。</span><br><span class="line"></span><br><span class="line">如果松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效，表示没有长按或者滑动。</span><br><span class="line"></span><br><span class="line">如果任然按下，输出长按或者滑动后的坐标结果。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/" data-id="clyylnk8r00217wuf4na8a3b3" data-title="s3c2440裸机编程-电阻触摸屏" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-LDC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/" class="article-date">
  <time class="dt-published" datetime="2024-04-19T09:57:39.000Z" itemprop="datePublished">2024-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/">s3c2440裸机编程-LDC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lcd-ying-jian-yuan-li">1 LCD硬件原理</a><ul>
<li><a href="#1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</a></li>
<li><a href="#1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</a><ul>
<li><a href="#1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</a></li>
<li><a href="#1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</a><ul>
<li><a href="#1-2-2-1-xing-shi-xu">1.2.2.1 行时序</a></li>
<li><a href="#1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</a></li>
<li><a href="#1-3-lcd-chong-lei">1.3 LCD种类</a></li>
<li><a href="#1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</a></li>
</ul>
</li>
<li><a href="#2-lcd-kong-zhi-qi">2 LCD控制器</a><ul>
<li><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</a></li>
<li><a href="#2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</a><ul>
<li><a href="#2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</a><ul>
<li><a href="#2-2-1-1-bswp-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</a><ul>
<li><a href="#2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</a></li>
<li><a href="#2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</a></li>
<li><a href="#2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</a><ul>
<li><a href="#2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</a></li>
</ul>
</li>
<li><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</a></li>
<li><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</a></li>
<li><a href="#2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</a></li>
<li><a href="#2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</a><ul>
<li><a href="#3-1-ruan-jian-kuang-jia">3.1 软件框架</a></li>
<li><a href="#3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</a><ul>
<li><a href="#3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</a></li>
</ul>
</li>
<li><a href="#3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</a><ul>
<li><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1 LCD操作方法-lcd_controller.c</a></li>
<li><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</a></li>
</ul>
</li>
<li><a href="#3-4-lcd-chu-shi-hua">3.4 LCD初始化</a><ul>
<li><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</a><ul>
<li><a href="#3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</a><ul>
<li><a href="#3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</a></li>
<li><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</a></li>
<li><a href="#3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</a></li>
</ul>
</li>
<li><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</a></li>
<li><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</a></li>
</ul>
</li>
<li><a href="#3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</a></li>
</ul>
</li>
<li><a href="#3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</a><ul>
<li><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</a><ul>
<li><a href="#3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</a></li>
<li><a href="#3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</a></li>
<li><a href="#3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</a></li>
<li><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</a><ul>
<li><a href="#3-6-1-hua-dian">3.6.1 画点</a></li>
<li><a href="#3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</a></li>
<li><a href="#3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</a></li>
<li><a href="#3-6-4-ce-shi">3.6.4 测试</a></li>
</ul>
</li>
<li><a href="#3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</a><ul>
<li><a href="#3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-lcd-ying-jian-yuan-li">1 LCD硬件原理</span><a href="#1-lcd-ying-jian-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</span><a href="#1-1-lcd-xiang-su-sao-miao" class="header-anchor">#</a></h2><p>里面的每个点就是一个像素点。</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/1.jpg"></p>
<p>它里面有一个电子枪，一边移动，一边发出各种颜色的光。用动态图表示如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/2.jpg"></p>
<ol>
<li><p>电子枪是如何移动的？</p>
<pre><code> 有一条CLK时钟线与LCD相连，每发出一次CLK(高低电平)，电子枪就移动一个像素。
</code></pre>
</li>
<li><p>颜色如何确定？</p>
<pre><code> 由连接LCD的三组线RGB三原色混合而成：R(Red)、G(Green)、B(Blue)确定。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到下一行？</p>
<pre><code> 有一条HSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到下一行，该信号叫做行同步信号。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到原点？</p>
<pre><code> 有一条VSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到原点，该信号叫做帧同步信号。
</code></pre>
</li>
<li><p>RGB线上的数据从何而来？</p>
<pre><code> 内存里面划分一块显存(FrameBuffer)，里面存放了要显示的数据，LCD控制器从里面将数据读出来，通过RGB三组线传给电子枪，电子枪再依次打到显示屏上。
</code></pre>
</li>
<li><p>前面的信号由谁发给LCD？</p>
<pre><code> 有S3C2440里面的LCD控制器来控制发出信号。
</code></pre>
</li>
</ol>
<h2><span id="1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</span><a href="#1-2-lcd-ying-jian-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/3.png"></p>
<p>①是时钟信号，每来一个CLK，电子枪就移动一个像素；</p>
<p>②是用来传输颜色数据；</p>
<p>③是垂直方向同步信号，FRAME(帧)；</p>
<p>④是水平方向同步信号，LINE(行)；</p>
<p>⑤LED+、LED-背光灯电源。</p>
<p>⑥TSYP、TSXP、TSYM、TSXM是触摸屏信号，暂时不用。</p>
<p>⑦VM接DE是数据使能</p>
<h3><span id="1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</span><a href="#1-2-1-rgb-lcd-mo-shi" class="header-anchor">#</a></h3><p>HV模式: HS与VS来控制刷新。比如对于分辨率为1024x600RGB的LCD，LCD控制器发出HS信号后，就会发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个HS信号后，就会发出一个VS信号<br>DE模式：DE信号来控制刷新，比如对于分辨率为1024x600RGB的LCD，LCD控制器发出DE信号后，就要发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个DE信号，刷新完一帧数据</p>
<h3><span id="1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</span><a href="#1-2-2-lcd-shi-xu-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/4.png" alt="image"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/5.png"></p>
<p>①从一行最开始的像素开始分析，如上图标号①，DE信号开始有效，电子枪每次在CLK下降沿时从数据线Dn0-Dn7上得到数据（Dn0-Dn7上的数据来源于FrameBuffer，后面会讲），然后发射到显示屏上，然后移动到下一个位置。从<em>1 st pixel</em>到<em>last pixel</em>，就这样从一行的最左边，一直移动到一行的最右边，完成了一行的显示，假设一行有x个pixel。可以看到每发送一个pixel，需要1个时钟周期（1&#x2F;tc）。</p>
<p>②当打完一行的最后一个数据后，会收到Hsync行同步信号，那么电子枪会跳到下一行，如上图标号②，根据时序图，一个Hsync周期，也就是一行数据刷新时间th, 可以大致分为五部分组成：thp、thb、1&#x2F;tc、thd、thf。<br>    thp:称为脉冲宽度，这个时间不能太短，太短电子枪可能识别不到。<br>    thb:电子枪正确识别到thp后，会从最右端移动最左端，这个移动的时间就是thb，称之为移动时间。<br>    thd：表示显示一行数据的时间<br>    thf：表示显示完最右像素，再过多久Hsync才来。</p>
<p>③同理，当电子枪移动到最后一行时，就会发送一个Vsync垂直同步信号，让电子枪移动回最上边。如上图标号③，根据时序图，一个Vsync周期，也就是一帧数据刷新时间tv, 可以大致分为：tvp、tvb、tvd、tvf。<br>    tvp:Vsync信号的脉冲宽度<br>    tvb：电子枪从最后一行移动到第一行的移动时间<br>    tvf：表示显示完最后一行像素，再过多久Vsync才来。</p>
<p> 假设一共有y行，那么LCD的分辨率就是x*y。</p>
<p>下面是LCD显示配置示意图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/6.png"></p>
<p>从左往右看，可以看到Total width &#x3D; HSYNC width + HBP + Active width + HFP。当发出一个HSYNC信号后，电子枪就会从最右边花费HBP时长移动到最左边，等到了最右边后，等待HFP时长后下一轮HSYNC信号才会发出。因此，HBP和HFP分别决定了左边和右边的黑框。</p>
<pre><code> HSYNC是行同步信号的脉冲宽度（低电平有效）
 HBP表示屏幕左边黑框的宽度（电子枪要花多久才能从最右边移动到最左边）行后肩
 Active width表示有效数据宽度
 HFP表示屏幕右边黑框的宽度（再过多久HSYNC才会发出）行前肩
</code></pre>
<p>同理从上往下看，Total height &#x3D; Vsync width + VBP + Active width + VFP。当发出一个VSYNC信号后，电子枪就会从最下边花费VBP时长移动到最上边，等到了最下边后，等待VFP时长后下一轮VSYNC信号才会发出。因此，VBP和VFP分别决定了上边和下边的黑框。 中间灰色区域才是有效显示区域。</p>
<pre><code>VSYNC是帧同步信号的脉冲宽度（低电平有效）
VBP表示屏幕上边黑框的宽度（电子枪要花多久才能从最后一行移动到最上面一行）帧后肩
Active height表示有效数据高度
VFP表示屏幕下边黑框的宽度(再过多久VSYNC才会发出) 帧前肩
</code></pre>
<p>总结：</p>
<h4><span id="1-2-2-1-xing-shi-xu">1.2.2.1 行时序</span><a href="#1-2-2-1-xing-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/7.png" alt="image"></p>
<pre><code>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。
HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。
</code></pre>
<h4><span id="1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</span><a href="#1-2-2-2-zheng-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/8.png" alt="image"></p>
<pre><code>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间
LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。
</code></pre>
<h2><span id="1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</span><a href="#1-2-framebuffer-he-bpp-gai-nian" class="header-anchor">#</a></h2><p>FrameBuffer是在内存中的一段区域，这段区域专门用来存放颜色数据的。如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/9.png"></p>
<p>BPP(Bits Per Pixels)表示每个像素占据多少位。 前面的LCD引脚功能图里，有R0-R7、G0-G7、B0-B7，那么每个像素是占据3<em>8&#x3D;24位的，*<em>所以硬件上LCD的BPP是确定的.</em></em></p>
<p>那么在FrameBuffer中，每个像素在FrameBuffer中，占据多少位BPP(Bits Per Pixels)？</p>
<p>虽然LCD上的引脚是固定的，但我们使用的时候，可以根据实际情况进行取舍，查看我们的硬件原理图，发现我们的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以每个像素就只占据16位数据。等效连接图如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/10.png"></p>
<h2><span id="1-3-lcd-chong-lei">1.3 LCD种类</span><a href="#1-3-lcd-chong-lei" class="header-anchor">#</a></h2><p>S3C2440芯片手册介绍了LCD控制器支持TFT和STN两种LCD，我们常用的都是TFT材质的，本开发板采用的就是一款TFT材质的LCD.</p>
<h2><span id="1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</span><a href="#1-4-lcd-fang-wen-kuang-jia" class="header-anchor">#</a></h2><p>如下图，LCD控制器从SDRAM中的FrameBuffer区域取出颜色数据，发送给电子枪，电子枪按照特定的时钟周期将颜色数据显示在LCD上。<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/11.png"></p>
<h1><span id="2-lcd-kong-zhi-qi">2 LCD控制器</span><a href="#2-lcd-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</span><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/12.png"></p>
<p>S3C2440 LCD控制器用于传输视频数据并且生成必要的控制信号，如VFRAME，VLINE，VCLK，VM等。除了控制信号，S3C2440还有视频数据端口，即VD [23：0]。通过设置REGBANK(寄存器组)，LCDCDMA会自动(无需CPU参与)把内存上FrameBuffer里的数据，通过VIDPRCS发送到引脚VD[23:0]数据总线上，再配合VIDEOMUX引脚的控制信号，正确的显示出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REGBANK：具有<span class="number">17</span>个可编程寄存器组和<span class="number">256</span>x16调色板存储器，用于配置LCD控制器。 </span><br><span class="line">TIMEGEN：产生控制信号，例如 VSYNC、HSYNC、VCLK等信号</span><br><span class="line">LCDCDMA：可以自动从FrameBuff中把数据copy出来。</span><br><span class="line">VIDPRCS：从LCDCDMA接收视频数据，将数据输出到VD[<span class="number">23</span>:<span class="number">0</span>]数据总线上。</span><br></pre></td></tr></table></figure>

<p>总结LCD控制器主要功能如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 取：从内存(FrameBuffer)取出某个像素的数据（之后需要把FrameBuffer地址、BPP、分辨率告诉LCD控制器）</span><br><span class="line"><span class="number">2.</span> 发：配合其它信号把FrameBuffer中的数据发给LCD；（那么需要设置LCD控制器时序、设置引脚极性）</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</span><a href="#2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><h3><span id="2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</span><a href="#2-2-1-shu-ju-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>可以配置寄存器的BSWP、HWSWP来设置Framebuff中的像素存储格式。</p>
<h4><span id="2-2-1-1-bswp-x2f-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</span><a href="#2-2-1-1-bswp-x2f-hwswp-ji-cun-qi" class="header-anchor">#</a></h4><h5><span id="2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</span><a href="#2-2-2-1-1-24bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/13.png"></p>
<p>从图中可以看到24bpp的像素，在lcd控制器的VD[7:0]表示BLUE， VD[15:8]表示GREEN，VD[23:16]表示RED。在内存中的FrameBuffer中每一个像素占据4个字节，当BPP24BL&#x3D;0时，低24位为颜色数据，当BPP24BL&#x3D;1时，高24位为颜色数据。</p>
<h5><span id="2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</span><a href="#2-2-2-1-2-16bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/14.png"></p>
<p>也可以看到16bpp的像素，在内存中的FrameBuffer中每一个像素占据2个字节，HWSWP用来设置像素数据的存放方式。</p>
<p>再看下LCD控制器的VD引脚输出情况，可以看到16bpp时分5:6:5和5：5：5：i两种数据格式。当5：6：5模式时，VD[7:3]表示BLUE， VD[15:10]表示Green数据，VD[23:19]表示RED。当5：5:5：i模式时，VD[7:3]表示BLUE， VD[15:11]表示Green，VD[23:19]表示RED。其中i表示透明度。</p>
<h5><span id="2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</span><a href="#2-2-2-1-3-8bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/15.png"></p>
<h3><span id="2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</span><a href="#2-2-2-diao-se-ban-ji-cun-qi" class="header-anchor">#</a></h3><p>我们外接的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以LCD上每个像素就只占据16位数据。那么当我们的Frame buffer中是8BPP颜色数据时，是如何把颜色数据填充到LCD上的呢？</p>
<p><code>用调色板</code></p>
<p>S3C2440A 中的 TFT LCD 控制器支持 1、2、4 或 8bpp调色显示（伪彩色）和16、24bpp无调色显示（真彩色）。S3C2440A 可以支持 256 色调色板给各种色彩映射的选择，以提供灵活操作给用户。</p>
<p>假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/16.png"></p>
<p>那么当8BPP的数据时，就需要用到调色板，调色板里存放了256个16bit的数据，FB(frame buffer)只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，比如从FB中的第0个元素拿到调色板中的第0个16bit数据，再通过电子枪显示出来，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/17.png"></p>
<p>调色板支持 5:6:5（R:G:B）格式和 5:5:5:I（R:G:B:I）格式。当用户使用5:5:5:I格式时，I表示强度，也就是透明度。I是用作每个RGB 数据的共用 LSB 位，因此 5:5:5:I与R(5+I):G(5+I):B(5+I)格式相同。</p>
<h4><span id="2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</span><a href="#2-2-2-1-diao-se-ban-ge-shi" class="header-anchor">#</a></h4><p>0x4D000400为调色板起始地址:</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/18.png"></p>
<h3><span id="2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</span><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/19.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">27</span>:<span class="number">18</span>]为只读数据位，不需要设置；</span><br><span class="line">[<span class="number">17</span>:<span class="number">8</span>]设置CLKVAL(像素时钟频率)，我们使用的是TFT屏，因此采用的公式是VCLK = HCLK / [(CLKVAL+<span class="number">1</span>) x <span class="number">2</span>]，其中HCLK为<span class="number">100</span>M。LCD手册里面Clock cycle的要求范围为<span class="number">5</span><span class="number">-12</span>MHz即可，那么取VCLK=<span class="number">9</span>，根据公式<span class="number">9</span>=<span class="number">100</span>/[(CLKVAL+<span class="number">1</span>)x2],算出CLKVAL≈<span class="number">4.5</span>=<span class="number">5</span>，设置CLKVAL=<span class="number">5</span>。</span><br><span class="line">[<span class="number">7</span>]不用管，默认即可；</span><br><span class="line">[<span class="number">6</span>:<span class="number">5</span>]TFT lcd配置为<span class="number">0b11</span>；</span><br><span class="line">[<span class="number">4</span>:<span class="number">1</span>]设置bpp模式，用户可选</span><br><span class="line">[<span class="number">0</span>]LCD输出使能，先暂时关闭不输出；</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</span><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/20.png"></p>
<p>s3c2440 LCD控制器时序图如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/21.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">31</span>:<span class="number">24</span>] : VBPD = tvb - <span class="number">1</span> （表示显示完最后一行像素，再过多久Vsync才来，表示上边黑框）</span><br><span class="line">[<span class="number">23</span>:<span class="number">14</span>] : LINEVAL = 每帧有多少行 - <span class="number">1</span> </span><br><span class="line">[<span class="number">13</span>:<span class="number">6</span>]  : VFPD = tvf - <span class="number">1</span>（下边黑框）</span><br><span class="line">[<span class="number">5</span>:<span class="number">0</span>]  : VSPW = tvp - <span class="number">1</span> （Vsync信号的脉冲宽度）</span><br></pre></td></tr></table></figure>



<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/22.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">25</span>:<span class="number">19</span>] : HBPD = thb - <span class="number">1</span>（左边黑框）</span><br><span class="line">[<span class="number">18</span>:<span class="number">8</span>]  : HOZVAL = 每行有多少列 - <span class="number">1</span></span><br><span class="line">[<span class="number">7</span>:<span class="number">0</span>]  : HFPD = thf - <span class="number">1</span> （右边黑框）</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/23.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">7</span>:<span class="number">0</span>]: HSPW = thp - <span class="number">1</span> (Hsync信号的脉冲宽度)</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/24.png"></p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>] : BPP24BL（表示<span class="number">24b</span>pp的数据是大端还是小端）</span><br><span class="line">[<span class="number">11</span>] : FRM565 （数据存放格式）</span><br><span class="line">[<span class="number">10</span>] : INVVCLK（时钟是否反转极性，当配置成<span class="number">0</span>时数据在时钟下降沿被锁存）</span><br><span class="line">[<span class="number">9</span>]  : HSYNC是否反转</span><br><span class="line">[<span class="number">8</span>]  : VSYNC是否反转</span><br><span class="line">[<span class="number">7</span>]  : INVVD, rgb是否反转</span><br><span class="line">[<span class="number">6</span>]  : INVVDEN</span><br><span class="line">[<span class="number">5</span>]  : INVPWREN</span><br><span class="line">[<span class="number">4</span>]  : INVLEND</span><br><span class="line">[<span class="number">3</span>]  : PWREN(LCD_PWREN output signal enable/disable)</span><br><span class="line">[<span class="number">2</span>]  : ENLEND</span><br><span class="line">[<span class="number">1</span>]  : BSWP</span><br><span class="line">[<span class="number">0</span>]  : HWSWP</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</span><a href="#2-2-6-lcdsaddr1-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的起始地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/26.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">29</span>:<span class="number">21</span>] : LCDBANK, A[<span class="number">30</span>:<span class="number">22</span>] of fb</span><br><span class="line">[<span class="number">20</span>:<span class="number">0</span>]  : LCDBASEU, A[<span class="number">21</span>:<span class="number">1</span>] of fb</span><br><span class="line">即[<span class="number">29</span>:<span class="number">0</span>]表示Frame buffer的起始地址的[<span class="number">30</span>:<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</span><a href="#2-2-7-lcdsaddr2-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的结束地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/27.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">0</span>] : LCDBASEL，A[<span class="number">21</span>:<span class="number">1</span>] of end addr,即framebuffer的结束地址。</span><br></pre></td></tr></table></figure>

<h1><span id="3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</span><a href="#3-lcd-luo-ji-bian-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-ruan-jian-kuang-jia">3.1 软件框架</span><a href="#3-1-ruan-jian-kuang-jia" class="header-anchor">#</a></h2><p>为了让程序更加好扩展，体现出<strong>高内聚、低耦合</strong>的特点，能够兼容各种不同型号的lcd，假如有两款尺寸大小的lcd，如何快速的在两个lcd上切换？</p>
<p>首先我们抽象出lcd_3.5.c和lcd_4.3.c的共同点，比如都有初始化函数init(),我们可以新建一个lcd.c，然后定义一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_opr</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户不接触lcd_3.5.c和lcd_4.3.c，只需要在lcd.c里通过指针访问对应的结构体的函数，也就调用了不同init():</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/28.jpg" alt="img"></p>
<p>我们的目的是在LCD显示屏上画线、画圆(geomentry.c)和写字(font.c)其核心是画点(farmebuffer.c)，这些都属于纯软件。此外还需要一个lcd_test.c测试程序提供操作菜单，调用画线、画圆和写字操作。</p>
<p>往下操作的是LCD相关的内容，不同的LCD，其配置的参数也会不一样，通过lcd_3.5.c或lcd_4.3.c来设置属性参数。</p>
<p>根据LCD的特性，来设置LCD控制器，首先编写lcd_controller.c，它向上要接收不同LCD的参数，向下要使用这些参数设置对应具体的某一款LCD控制器。</p>
<p>对于我们开发板，就是s3c2440_lcd_controller.c，假如希望在其它开发板上也实现LCD显示，只需添加相应的代码文件即可。文件自上而下的框架如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/29.jpg"></p>
<h2><span id="3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</span><a href="#3-2-shu-ju-jie-gou-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</span><a href="#3-2-1-lcd-she-bei-jie-gou-ti" class="header-anchor">#</a></h3><p>我们知道LCD的参数属性有：引脚的极性、时序、数据的格式bpp、分辨率等，使用面向对象的思维方式，将这些封装成结构体放在lcd.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	NORMAL = <span class="number">0</span>,</span><br><span class="line">	INVERT = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NORMAL : 正常极性</span></span><br><span class="line"><span class="comment"> * INVERT : 反转极性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pins_polarity</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> vclk;  <span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">	<span class="type">int</span> rgb;   <span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">	<span class="type">int</span> hsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	<span class="type">int</span> vsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">&#125; pins_polarity, *p_pins_polarity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">time_sequence</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 垂直方向 */</span></span><br><span class="line">	<span class="type">int</span> tvp; <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> tvb; <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">	<span class="type">int</span> tvf; <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line">	<span class="comment">/* 水平方向 */</span></span><br><span class="line">	<span class="type">int</span> thp; <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> thb; <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">	<span class="type">int</span> thf; <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line">	<span class="type">int</span> vclk;</span><br><span class="line">&#125; time_sequence, *p_time_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_params</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 引脚极性 */</span></span><br><span class="line">	pins_polarity pins_pol;</span><br><span class="line">	<span class="comment">/* 时序 */</span></span><br><span class="line">	time_sequence time_seq;</span><br><span class="line">	<span class="comment">/* 分辨率, bpp */</span></span><br><span class="line">	<span class="type">int</span> xres;</span><br><span class="line">	<span class="type">int</span> yres;</span><br><span class="line">	<span class="type">int</span> bpp;</span><br><span class="line">	<span class="comment">/* framebuffer的地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line">&#125; lcd_params, *p_lcd_params;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</span><a href="#3-3-cao-zuo-fang-fa-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1  LCD操作方法-lcd_controller.c</span><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c" class="header-anchor">#</a></h3><p>我们知道在c++中是面向对象编程的，那么一个对象就有它的属性和方法，LCD属性我们上面已经定义好了，那么方法我们可以定义一个lcd_controller.c用来控制管理LCD，定义个一个lcd_controller.h, struct lcd_controller结构体放置lcd对象的一些成员函数，即对象的方法，或者称之为对象的行为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*init)(p_lcd_params plcdparams);</span><br><span class="line">    <span class="type">void</span> (*enable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*disable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*init_palette)(<span class="type">void</span>);</span><br><span class="line">&#125; lcd_controller, *p_lcd_controller;</span><br></pre></td></tr></table></figure>
<p>那么lcd_controller.c相当于一个管理者，会去选择具体型号的LCD对象去执行具体的成员函数，比如管理s3c2440_lcd_controller.c，它向上接受传入的LCD参数，向下传给具体的LCD控制器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">    <span class="comment">/* 调用2440的LCD控制器的初始化函数，lcd_controller是一个被选中的对象，即s3c2440_lcd_controller*/</span></span><br><span class="line">    lcd_controller.init(plcdparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在s3c2440_lcd_controller.c再构造一个具体的lcd对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = xxx,</span><br><span class="line">	.init    = xxx,</span><br><span class="line">	.enalbe  = xxx,</span><br><span class="line">	.disable = xxx,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lcd_controller.c代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CONTROLLER_NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> p_lcd_controller p_array_lcd_controller[LCD_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_controller g_p_lcd_controller_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd_controller</span><span class="params">(p_lcd_controller plcdcon)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd_controller[i]) &#123;</span><br><span class="line">			p_array_lcd_controller[i] = plcdcon;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd_controller[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd_controller[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_controller_selected = p_array_lcd_controller[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向上: 接收不同LCD的参数</span></span><br><span class="line"><span class="comment"> * 向下: 使用这些参数设置对应的LCD控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* 调用所选择的LCD控制器的初始化函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected) &#123;</span><br><span class="line">		g_p_lcd_controller_selected-&gt;init(plcdparams);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细分析lcd_controller.c框架的含义以及作用：</p>
<ol>
<li>开始定义了一个p_array_lcd_controller数组和g_p_lcd_controller_selected，p_array_lcd_controller数组表示lcd控制器的集合，g_p_lcd_controller_selected表示被选中的那一个lcd_controller;</li>
<li>当我们初始化时要先调用register_lcd_controller，select_lcd_controller选中具体的lcd_controller；</li>
<li>然后才能调用lcd_controller_init初始化具体的lcd_controller，去控制具体型号的lcd。</li>
</ol>
<p>同理，也通过lcd.c去管理lcd_4.3.c,思路如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 有一个数组存放各类lcd的参数；</span><br><span class="line">b. 有一个register_lcd给下面的lcd程序来设置数组；</span><br><span class="line">c. 有一个select_lcd，供上层选择某款LCD；</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</span><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c" class="header-anchor">#</a></h3><p>参考前面的lcd_controller.c编辑lcd.c如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_NUM 10</span></span><br><span class="line"><span class="type">static</span> p_lcd_params p_array_lcd[LCD_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_params g_p_lcd_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd</span><span class="params">(p_lcd_params plcd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd[i]) &#123;</span><br><span class="line">			p_array_lcd[i] = plcd;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_selected = p_array_lcd[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-lcd-chu-shi-hua">3.4 LCD初始化</span><a href="#3-4-lcd-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</span><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</span><a href="#3-4-1-1-chu-shi-hua-yin-jiao" class="header-anchor">#</a></h4><h5><span id="3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</span><a href="#3-4-1-1-1-bei-guang-yin-jiao" class="header-anchor">#</a></h5><p>我们配置LCD的背光引脚成输出模式：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/30.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPBCON &amp;= ~<span class="number">0x3</span>;</span><br><span class="line">GPBCON |= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</span><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao" class="header-anchor">#</a></h5><p>然后再配置LCD的控制引脚和数据引脚，LCD控制引脚和数据引脚分别复用了GPC和GPD，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/31.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/32.png"></p>
<p>设置GPC, GPD均为0xaaaa,aaaa。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LCD专用引脚 */</span></span><br><span class="line">GPCCON = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">GPDCON = <span class="number">0xaaaaaaaa</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</span><a href="#3-4-1-1-3-pwren-yin-jiao" class="header-anchor">#</a></h5><p>设置GPG4成PWREN引脚</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/33.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/34.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPGCON |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</span><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>前面介绍了LCDCON1，LCDCON2，LCDCON3…LCDSADDR1等寄存器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* [17:8]: CLKVAL, vclk = HCLK / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment">	 *                   如：9   = 100M /[(CLKVAL+1) x 2], 所以CLKVAL = 4.5 = 5</span></span><br><span class="line"><span class="comment">	 *                 CLKVAL = 100/vclk/2-1</span></span><br><span class="line"><span class="comment">	 * [6:5]: 0b11, tft lcd</span></span><br><span class="line"><span class="comment">	 * [4:1]: bpp mode</span></span><br><span class="line"><span class="comment">	 * [0]  : LCD video output and the logic enable/disable</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> clkval = (<span class="type">double</span>)HCLK/plcdparams-&gt;time_seq.vclk/<span class="number">2</span><span class="number">-1</span>+<span class="number">0.5</span>;</span><br><span class="line">	<span class="type">int</span> bppmode = plcdparams-&gt;bpp == <span class="number">8</span>  ? <span class="number">0xb</span> :\</span><br><span class="line">				  plcdparams-&gt;bpp == <span class="number">16</span> ? <span class="number">0xc</span> :\</span><br><span class="line">				  <span class="number">0xd</span>;  <span class="comment">/* 0xd: 24bpp */</span></span><br><span class="line">	LCDCON1 = (clkval&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (bppmode&lt;&lt;<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [31:24] : VBPD    = tvb - 1</span></span><br><span class="line"><span class="comment">	 * [23:14] : LINEVAL = line - 1</span></span><br><span class="line"><span class="comment">	 * [13:6]  : VFPD    = tvf - 1</span></span><br><span class="line"><span class="comment">	 * [5:0]   : VSPW    = tvp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON2 = 	((plcdparams-&gt;time_seq.tvb - <span class="number">1</span>)&lt;&lt;<span class="number">24</span>) | \</span><br><span class="line">	            ((plcdparams-&gt;yres - <span class="number">1</span>)&lt;&lt;<span class="number">14</span>)         | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvf - <span class="number">1</span>)&lt;&lt;<span class="number">6</span>)  | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [25:19] : HBPD	 = thb - 1</span></span><br><span class="line"><span class="comment">	 * [18:8]  : HOZVAL  = 列 - 1</span></span><br><span class="line"><span class="comment">	 * [7:0]   : HFPD	 = thf - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON3 =	((plcdparams-&gt;time_seq.thb - <span class="number">1</span>)&lt;&lt;<span class="number">19</span>) | \</span><br><span class="line">				((plcdparams-&gt;xres - <span class="number">1</span>)&lt;&lt;<span class="number">8</span>)		      | \</span><br><span class="line">				((plcdparams-&gt;time_seq.thf - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [7:0]   : HSPW	 = thp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON4 =	((plcdparams-&gt;time_seq.thp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用来设置引脚极性, 设置16bpp, 设置内存中象素存放的格式</span></span><br><span class="line"><span class="comment">     * [12] : BPP24BL</span></span><br><span class="line"><span class="comment">	 * [11] : FRM565, 1-565</span></span><br><span class="line"><span class="comment">	 * [10] : INVVCLK, 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment">	 * [9]  : HSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [8]  : VSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [7]  : INVVD, rgb是否反转</span></span><br><span class="line"><span class="comment">	 * [6]  : INVVDEN</span></span><br><span class="line"><span class="comment">	 * [5]  : INVPWREN</span></span><br><span class="line"><span class="comment">	 * [4]  : INVLEND</span></span><br><span class="line"><span class="comment">	 * [3]  : PWREN, LCD_PWREN output signal enable/disable</span></span><br><span class="line"><span class="comment">	 * [2]  : ENLEND</span></span><br><span class="line"><span class="comment">	 * [1]  : BSWP</span></span><br><span class="line"><span class="comment">	 * [0]  : HWSWP</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	pixelplace = plcdparams-&gt;bpp == <span class="number">24</span> ? (<span class="number">0</span>) : |\</span><br><span class="line">	             plcdparams-&gt;bpp == <span class="number">16</span> ? (<span class="number">1</span>) : |\</span><br><span class="line">	             (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);  <span class="comment">/* 8bpp */</span></span><br><span class="line">	LCDCON5 = (plcdparams-&gt;pins_pol.vclk&lt;&lt;<span class="number">10</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.rgb&lt;&lt;<span class="number">7</span>)   |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.hsync&lt;&lt;<span class="number">9</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.vsync&lt;&lt;<span class="number">8</span>) |\</span><br><span class="line"> 			  (plcdparams-&gt;pins_pol.de&lt;&lt;<span class="number">6</span>)    |\</span><br><span class="line">			  (plcdparams-&gt;pins_pol.pwren&lt;&lt;<span class="number">5</span>) |\</span><br><span class="line">			  (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | pixelplace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* framebuffer地址 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * [29:21] : LCDBANK, A[30:22] of fb</span></span><br><span class="line"><span class="comment">	 * [20:0]  : LCDBASEU, A[21:1] of fb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base &amp; ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">	LCDSADDR1 = (addr &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [20:0] : LCDBASEL, A[21:1] of end addr</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base + plcdparams-&gt;xres*plcdparams-&gt;yres*plcdparams-&gt;bpp/<span class="number">8</span>;</span><br><span class="line">	addr &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	addr &amp;= <span class="number">0x1fffff</span>;</span><br><span class="line">	LCDSADDR2 = addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</span><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao" class="header-anchor">#</a></h4><p>根据背光电路背光引脚是GPB0，那么配置GPBDAT[0]置1，使能背光引脚，设置LCDCON5和<br>LCDCON1使能power enable和LCD输出，反之。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_enalbe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren    : 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren	: 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的s3c2440的lcd控制器初始化就编写完了，那么用户只要调用s3c2440_lcd_controller_init去设置LCD的属性即可。下面开始介绍如何设置LCD属性，让LCD控制器能够适应具体型号的LCD。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">	.init    = s3c2440_lcd_controller_init,</span><br><span class="line">	.enable  = s3c2440_lcd_controller_enalbe,</span><br><span class="line">	.disable = s3c2440_lcd_controller_disable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</span><a href="#3-4-2-chu-shi-hua-lcd-she-bei" class="header-anchor">#</a></h3><p>参考AT043TN24 LCD数据手册上的参数性能，见下表：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/35.png"></p>
<p>配置lcd_params属性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_FB_BASE 0x33c00000</span></span><br><span class="line">lcd_params lcd_4_3_params = &#123;</span><br><span class="line">	.name = <span class="string">&quot;lcd_4.3&quot;</span></span><br><span class="line">	.pins_polarity = &#123;</span><br><span class="line">		.de    = NORMAL,	<span class="comment">/* normal: 高电平时可以传输数据 */</span></span><br><span class="line">		.vclk  = NORMAL,	<span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">		.rgb   = NORMAL,	<span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">		.hsync = INVERT,    <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">		.vsync = INVERT, 	<span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.time_sequence = &#123;</span><br><span class="line">		<span class="comment">/* 垂直方向 */</span></span><br><span class="line">		.tvp=	<span class="number">10</span>, <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">		.tvb=	<span class="number">2</span>,  <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">		.tvf=	<span class="number">2</span>,  <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 水平方向 */</span></span><br><span class="line">		.thp=	<span class="number">41</span>, <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">		.thb=	<span class="number">2</span>,  <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">		.thf=	<span class="number">2</span>,  <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line"></span><br><span class="line">		.vclk=	<span class="number">9</span>,  <span class="comment">/* MHz */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.xres = <span class="number">480</span>,</span><br><span class="line">	.yres = <span class="number">272</span>,</span><br><span class="line">	.bpp  = <span class="number">16</span>,</span><br><span class="line">	.fb_base = LCD_FB_BASE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.de表示数据输出使能引脚，高电平有效，所以配置成NORMAL；</span><br><span class="line">.pwren表示LCD_PWREN引脚，高电平有效；</span><br><span class="line">.vclk表示LCD的时钟，从手册的LCD时序图中可以看到下降沿有效，所以配置NORMAL；</span><br><span class="line">.rgb表示颜色数据的引脚极性，高电平表示<span class="number">1</span>，配置成NORMAL；</span><br><span class="line">.hsync表示行同步信号，normal表示高脉冲，参考手册发现该信号低脉冲有效，所以配置成INVERT；</span><br></pre></td></tr></table></figure>

<p>什么是高低脉冲？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高脉冲：即从逻辑<span class="number">0</span>变化bai到逻辑du1再变化到逻辑<span class="number">0</span>，如此便是一个高脉zhi冲。在单片机中定义高脉冲就是让某个I/O先输出逻辑<span class="number">0</span>，接着保持一定的时间（延时），再输出逻辑<span class="number">1</span>，同样保持一定的时间（延时），最后再转变输出为逻辑<span class="number">0</span>+延时。</span><br><span class="line">低脉冲：反之</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.vsync表示帧同步信号，同.hsync；</span><br><span class="line">.time_sequence时序设置参考上表配置。我们看到thf + thp + thb = <span class="number">2</span> + <span class="number">41</span> +<span class="number">2</span> = <span class="number">45</span> clk &gt; <span class="number">44</span> clk，满足上面的注意事项；</span><br><span class="line">.xres .yres表示分辨率</span><br><span class="line">.bpp表示像素点颜色模式</span><br><span class="line">.fb_base指定frame buffer的基地址</span><br></pre></td></tr></table></figure>

<p>那么最终LCD初始化函数封装如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册LCD,把具体的LCD属性配置下去 */</span></span><br><span class="line">	register_lcd(&amp;lcd_4_3_params);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册LCD控制器 */</span></span><br><span class="line">	register_lcd_controller(&amp;s3c2440_lcd_controller);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 选择某款LCD */</span></span><br><span class="line">	select_lcd(<span class="string">&quot;lcd_4.3&quot;</span>);</span><br><span class="line">	<span class="comment">/* 选择某款LCD控制器 */</span></span><br><span class="line">	select_lcd_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用LCD的参数, 初始化LCD控制器 */</span></span><br><span class="line">	lcd_controller_init(g_p_lcd_selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：我们可以看到，调用的函数都是一些通用型框架型接口，具体的实现本质还得根据硬件本身的特性来配置寄存器来驱动硬件工作。</p>
<h2><span id="3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</span><a href="#3-5-shi-xian-xian-shi-gong-neng" class="header-anchor">#</a></h2><h3><span id="3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</span><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se" class="header-anchor">#</a></h3><p>想要在LCD上显示出数据，所需步骤如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. 初始化LCD</span><br><span class="line">b. 使能LCD</span><br><span class="line">c. 获取LCD参数: fb_base, xres, yres, bpp</span><br><span class="line">d. 往framebuffer中写数据</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</span><a href="#3-5-1-1-chu-shi-hua-lcd" class="header-anchor">#</a></h4><p>前面已详细实现。</p>
<h4><span id="3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</span><a href="#3-5-1-2-shi-neng-lcd" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_enable</span><span class="params">()</span> &#123;</span><br><span class="line">	lcd_controller_enalbe(); <span class="comment">//会间接调用s3c2440_lcd_controller_enalbe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</span><a href="#3-5-1-3-huo-qu-lcd-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</span><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju" class="header-anchor">#</a></h4><p>假设我们初始化配置了BPP&#x3D;16，那么如何让全屏显示红色？</p>
<p>就需要从framebuffer基地址开始的整个屏幕的像素点都填充红色值。 对于16BPP，RGB&#x3D;565，想显示红色，即[15:11]全为1表示红色，[10:5]全为0表示无绿色，[4:0]全为0表示无蓝色，0b1111100000000000&#x3D;0xF800。<br>以基地址为起点，分别以xres和yres为边界，依次填充颜色。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">short</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xf800</span>;</span><br></pre></td></tr></table></figure>
<p>假设我们初始化配置了BPP&#x3D;24 或者BPP &#x3D;32，那么如何让全屏显示红色？</p>
<p>其实无论是24bpp还是32bpp，在frame buffer中每个像素点都占4 bytes，对于24BPP or 32 bpp，即RGB:888，每个颜色占8位，一共占据24位。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">int</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xff0000</span>;</span><br></pre></td></tr></table></figure>
<p>当Frame buffer中填满颜色数据时，LCD控制器会参照我们之前的配置将数据填充到LCD显示器上。那前面的24BPP、32BPP是怎样在 只能接收16BPP(硬件上只有16根数据线)的LCD上显示的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是因为在使用<span class="number">24B</span>PP时，发出的<span class="number">8</span>条红色，<span class="number">8</span>条绿色，<span class="number">8</span>条蓝色数据，只用了高<span class="number">5</span>条红色，高<span class="number">6</span>条绿色，高<span class="number">5</span>条蓝色与LCD相连。（前面LCD硬件原理的FrameBuffer和BPP概念有讲）</span><br></pre></td></tr></table></figure>

<h2><span id="3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</span><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu" class="header-anchor">#</a></h2><h3><span id="3-6-1-hua-dian">3.6.1 画点</span><a href="#3-6-1-hua-dian" class="header-anchor">#</a></h3><p>无论是何种图形，都是基于点来构成的，因此我们需要先实现画点，其他的都是上层的一些数据处理了，像各种图形、甚至色彩鲜艳的图片无非都是一些由点构造出的数据而已。</p>
<p>我们在在farmebuffer.c实现画点，在geomentry.c实现画线、画圆等几何图形，font.c实现画字。</p>
<p>那么一个像素点要显示到lcd上，我们要知道它的位置坐标，然后还要知道它的颜色值，假设该像素点的坐标为（x,y）,那么该像素的地址为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（x,y）= fb_base + (xres*(bpp/<span class="number">8</span>))*y +x*bpp/<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>那么所以在画点前需要先获取lcd参数：fb_base、xres、yres、bpp;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_get_lcd_params</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后画点函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>  *pc;  <span class="comment">/* 8bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *pw;  <span class="comment">/* 16bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>   *pdw; <span class="comment">/* 32bpp */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pixel_base = fb_base + (xres * bpp / <span class="number">8</span>) * y + x * bpp / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (bpp) &#123; <span class="comment">//根据像素不同bpp格式，在Frame buffer中存放方式不一样，但对用户来说，不关心颜色格式，通通当做32位色颜色处理，所以这里需要做格式转换</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			pc = (<span class="type">unsigned</span> <span class="type">char</span> *) pixel_base;</span><br><span class="line">			*pc = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			pw = (<span class="type">unsigned</span> <span class="type">short</span> *) pixel_base;</span><br><span class="line">			*pw = convert32bppto16bpp(color);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			pdw = (<span class="type">unsigned</span> <span class="type">int</span> *) pixel_base;</span><br><span class="line">			*pdw = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户传入的颜色数据一般都是32bit的，即格式为：0x00RRGGBB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于<span class="number">8</span>PP，通过的是调色板索引实现的，这个后续再讲解，直接*pc = color即可（这样只取了高<span class="number">8</span>位，低精度的数据就丢了）。</span><br><span class="line">对于<span class="number">16</span>PP，那么需要进行颜色转换后再存放进frame buffer。</span><br><span class="line">对于<span class="number">32</span>PP，大小刚好对应，直接*pc = color即可。</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</span><a href="#3-6-2-32bppto16bpp-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先分别取出RGB，再相应的清除低位数据，实现将RGB888变为RGB565</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">convert32bppto16bpp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rgb)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r = (rgb &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> g = (rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> b = rgb &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">/* rgb565 */</span></span><br><span class="line">	r = r &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	g = g &gt;&gt; <span class="number">2</span>;<span class="comment">//取低6位</span></span><br><span class="line">	b = b &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	<span class="keyword">return</span> ((r&lt;&lt;<span class="number">11</span>) | (g&lt;&lt;<span class="number">5</span>) | (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</span><a href="#3-6-3-hua-xian-hua-yuan" class="header-anchor">#</a></h3><p>画圆画线的具体原理不是本主题的重点，这些属于研究算法的范畴了，比如这里就有现成的算法可以用，如这篇博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/p1126500468/article/details/50428613">https://blog.csdn.net/p1126500468/article/details/50428613</a>，里面有画圆画线的函数实现，直接使用就可以了，套用画点的”轮子”就可以了。</p>
<h3><span id="3-6-4-ce-shi">3.6.4 测试</span><a href="#3-6-4-ce-shi" class="header-anchor">#</a></h3><p>新建一个geometry.c，复制博客中代码，替换里面的描点显示函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 画线 */</span></span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xff0000</span>); <span class="comment">//(0,0) 到（xres - 1, 0）两点间的线</span></span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xffff00</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, yres - <span class="number">1</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff00aa</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff00ef</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff4500</span>);</span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff0780</span>);</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画圆 */</span></span><br><span class="line">draw_circle(xres/<span class="number">2</span>, yres/<span class="number">2</span>, yres/<span class="number">4</span>, <span class="number">0xff00</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/36.jpg"></p>
<h2><span id="3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</span><a href="#3-7-zi-fu-ku-yi-zhi" class="header-anchor">#</a></h2><p>字符也是由点构成的，一个个点组成的点阵，其实本质上要显示文字就是把字库移植到对应的自己型号相匹配的board上，字库中的每一个字符都是一些点按照对应格式组合成的集合。</p>
<p>从linux内核源码中随便挑选一个字库文件，比如linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应的很多字库文件。在这里我挑选font_8x16.c，如下图：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/37.png"></p>
<p>其中8x16表示每个字符所占的像素点的大小，表示每个字符占的大小为长*宽&#x3D;8*16个像素点。</p>
<p>我们来看下一个字符’A’是如何显示的？从font_8x16.c我们找到字符’A’的数据，如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/38.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/39.png"><br>那么我们如何让font_8x16.c这个字库的数据显示到lcd上呢？font_8x16.c见附件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a. 根据要显示的字符的ascii码作为索引，在fontdata_8x16中得到点阵数据</span></span><br><span class="line"><span class="comment">b. 根据点阵来设置对应象素的颜色</span></span><br><span class="line"><span class="comment">c. 根据点阵的某位决定是否描颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="comment">/* 根据c的ascii码作为索引在fontdata_8x16中得到点阵数据（fontdata_8x16是字库的数据集合）*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = &amp;fontdata_8x16[c * <span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> bit;</span><br><span class="line">	<span class="comment">/* 根据点阵来设置对应象素的颜色 */</span></span><br><span class="line">	<span class="keyword">for</span> (j = y; j &lt; y+<span class="number">16</span>; j++) &#123;</span><br><span class="line">		data = *dots++;</span><br><span class="line">		bit = <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = x; i &lt; x+<span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="comment">/* 根据点阵的某位决定是否描颜色 */</span></span><br><span class="line">			<span class="keyword">if</span> (data &amp; (<span class="number">1</span>&lt;&lt;bit))</span><br><span class="line">				fb_put_pixel(i, j, color);</span><br><span class="line">			bit--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在font_8x16.c里面，每个字符占据16字节，因此想要根据ascii码找到对应的点阵数据，需要对应的乘16，再取地址，得到该字符的首地址。</p>
<p>在显示之前，还需要获取LCD参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> fontdata_8x16[];</span><br><span class="line"><span class="comment">/* 获得LCD参数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">font_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</span><a href="#3-7-1-xian-shi-zi-fu-chuan" class="header-anchor">#</a></h3><p>如果想显示字符串，那就在每显示完一个字符后，x轴加8即可，同时考虑是否超出屏幕显示范围进行换行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* &quot;abc\n\r123&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_string</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>* str, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    	<span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            			y = y+<span class="number">16</span>;</span><br><span class="line">        		<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            			x = <span class="number">0</span>;</span><br><span class="line">        		<span class="keyword">else</span> &#123;</span><br><span class="line">            			fb_print_char(x, y, str[i], color);</span><br><span class="line">            			x = x+<span class="number">8</span>;</span><br><span class="line">            			<span class="keyword">if</span> (x &gt;= xres) &#123;</span><br><span class="line">                				x = <span class="number">0</span>;</span><br><span class="line">                				y = y+<span class="number">16</span>;</span><br><span class="line">            			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/" data-id="clyylnk8p001j7wuf8l0s9b2s" data-title="s3c2440裸机编程-LDC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-SPI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/" class="article-date">
  <time class="dt-published" datetime="2024-04-18T12:37:17.000Z" itemprop="datePublished">2024-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/">s3c2440裸机编程-SPI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-spi-yuan-li">1 SPI原理</a><ul>
<li><a href="#1-1-spi-gai-nian">1.1 spi概念</a></li>
<li><a href="#1-2-ying-ti-kuang-jia">1.2 硬体框架</a></li>
<li><a href="#1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</a></li>
<li><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</a></li>
<li><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</a></li>
</ul>
</li>
<li><a href="#2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</a><ul>
<li><a href="#2-1-sspsr">2.1 SSPSR</a></li>
<li><a href="#2-2-sspbuf">2.2 SSPBUF</a></li>
<li><a href="#2-3-controller">2.3 Controller</a></li>
</ul>
</li>
<li><a href="#3-spi-luo-ji-shi-li">3 SPI裸机示例</a><ul>
<li><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</a><ul>
<li><a href="#3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</a></li>
<li><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</a></li>
<li><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</a></li>
<li><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</a></li>
<li><a href="#3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</a></li>
</ul>
</li>
<li><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</a><ul>
<li><a href="#3-2-1-fa-song-di-zhi">3.2.1 发送地址</a><ul>
<li><a href="#3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</a><ul>
<li><a href="#3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</a></li>
<li><a href="#3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-2-fa-song-shu-ju">3.2.2 发送数据</a></li>
</ul>
</li>
<li><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</a><ul>
<li><a href="#3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</a></li>
<li><a href="#3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</a><ul>
<li><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</a></li>
<li><a href="#3-3-2-2-xie-ming-ling">3.3.2.2 写命令</a><ul>
<li><a href="#3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</a></li>
</ul>
</li>
<li><a href="#3-3-2-3-xie-shu-ju">3.3.2.3 写数据</a></li>
</ul>
</li>
<li><a href="#3-2-3-oled-c">3.2.3 oled.c</a><ul>
<li><a href="#3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</a></li>
<li><a href="#3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</a></li>
</ul>
</li>
<li><a href="#3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-spi-yuan-li">1 SPI原理</span><a href="#1-spi-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-spi-gai-nian">1.1 spi概念</span><a href="#1-1-spi-gai-nian" class="header-anchor">#</a></h2><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p>
<p>特点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">高速、同步、全双工、非差分、总线式</span><br><span class="line">主从机通信模式</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">支持全双工通信（SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出）</span><br><span class="line">数据传输速率快（I2c一般只能到100-400Khz, SPI高达上百Mhz）</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据可靠性上有一定的缺陷</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ying-ti-kuang-jia">1.2 硬体框架</span><a href="#1-2-ying-ti-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/1.png" alt="img"></p>
<p>SCK：提供时钟<br>DO:作为数据输出<br>DI:作为数据输入<br>CS0&#x2F;CS1:作为片选</p>
<p>同一时刻只能有一个SPI设备处于工作状态。因此cs选中谁，谁就和主控通信。</p>
<h2><span id="1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</span><a href="#1-2-shu-ju-chuan-shu-shi-xu" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/2.png" alt="img"></p>
<p>这里是一款SPI flash在SCLK上升延采样数据（D7~D0）的示意图。设现在s3c2440传输一个0x56数据给SPI Flash，时序如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/3.png" alt="img"></p>
<p>CS0低选中SPI Flash，配置成模式0， 0x56的二进制就是0b0101 0110，因此在每个SCK时钟周期，DO输出对应的电平。会在<strong>每个时钟周期的上升沿采样DO上的电平</strong>。</p>
<h2><span id="1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</span><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie" class="header-anchor">#</a></h2><p><strong>KPOL</strong>： (Clock Polarity)（时钟）极性</p>
<p><strong>CKPHA</strong>： (Clock Phase)（时钟）相位</p>
<p><strong>SCK</strong>&#x3D;<strong>SCLK</strong>：SPI的时钟</p>
<p><strong>Leading edge</strong>：前一个边沿</p>
<p><strong>Trailing edge</strong>：后一个边沿</p>
<h2><span id="1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</span><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi" class="header-anchor">#</a></h2><p>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平</p>
<p>CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p>
<p>两者组合成4种模式：</p>
<table>
<thead>
<tr>
<th>SPI模式</th>
<th>CPOL</th>
<th>CPHA</th>
<th>空闲状态时钟极性</th>
<th>采样&#x2F;移位时钟相位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>低电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>低电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>高电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>高电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
</tbody></table>
<p>4个模式波形对比：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/4.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/5.png" alt="img"></p>
<p>常用的是<strong>模式0和模式3</strong>，因为它们都是在<strong>上升沿采样数据</strong>.当配置成模式3时，<strong>对于主设备，数据采样在时钟上升沿，数据传送在时钟下降沿****。</strong></p>
<p><strong>主设备SPI时钟和极性的配置应该由外设来决定；二者的配置应该保持一致，即主设备的SDO同从设备的SDO配置一致，主设备的SDI同从设备的SDI配置一致。即因为主从设备是在SCLK的控制下，同时发送和接收数据，并通过2个双向移位寄存器来交换数据 。</strong></p>
<p>举个例子，以 CPOL&#x3D;0，CPHA&#x3D;0，模式0为例：空闲CLK为低电平，相位为0，也就是上升延采集数据。由于SPI的全双工可以同时读写，发送MOSI数据为0xD2,接收MISO数据为0x66。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/6.png" alt="img"></p>
<h1><span id="2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</span><a href="#2-spi-kong-zhi-qi-jie-gou" class="header-anchor">#</a></h1><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/7.png" alt="img"></p>
<h2><span id="2-1-sspsr">2.1 SSPSR</span><a href="#2-1-sspsr" class="header-anchor">#</a></h2><p>SSPSR：移位寄存器(Shift Register). 根据 SPI 时钟同步信号, 将SSPBUF中的数据一位一位移出去或者收进来。</p>
<h2><span id="2-2-sspbuf">2.2 SSPBUF</span><a href="#2-2-sspbuf" class="header-anchor">#</a></h2><p>Master 与 Slave 之间交换的数据其实都是移位寄存器从 SSPBUF 里面拷贝的。通过往 SSPBUF 对应的寄存器 (Tx-Data &#x2F; Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF。</p>
<h2><span id="2-3-controller">2.3 Controller</span><a href="#2-3-controller" class="header-anchor">#</a></h2><p>用来发送控制信号的，像CS，SCK等控制信号。</p>
<h1><span id="3-spi-luo-ji-shi-li">3 SPI裸机示例</span><a href="#3-spi-luo-ji-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</span><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/8.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款OLED为例，可见它支持Parallel&#x2F;i2c&#x2F;SPI这3种方式对它进行控制，这里仅对它进行SPI控制。它的product Specification见附件。</p>
<h3><span id="3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</span><a href="#3-1-1-bing-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/9.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/10.png" alt="img"></p>
<h3><span id="3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</span><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/11.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Tr/Tf: 表示spi clk上升/下降延不能超过<span class="number">40</span>ns</span><br><span class="line">Tclkl/Tclkh: 表示spi clk低/高电平持续至少<span class="number">20</span>ns</span><br><span class="line">Tcycle: 表示spi clk一个时钟周期至少<span class="number">100</span>ns</span><br><span class="line">Tdsw/Tdhw: 表示spi data的建立/持续时间至少<span class="number">15</span>ms</span><br><span class="line">Tcss:片选建立时间至少<span class="number">20</span>ns</span><br><span class="line">Tcsh:片选持续时间至少<span class="number">10</span>ns</span><br><span class="line">Tas/Tah:地址建立/持续时间至少<span class="number">15</span>ns</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</span><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/12.png" alt="img"></p>
<h3><span id="3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</span><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/13.png" alt="img"></p>
<h3><span id="3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</span><a href="#3-1-5-xiu-mian-huan-xing" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/14.png" alt="img"></p>
<h2><span id="3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</span><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/15.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款为例，OLED长有128个像素，宽有64个像素，共128*64&#x3D;8,192 像素。每个像素用1bit来表示，为1则亮，为0则灭。所以每一个字节数据Data表示8个像素，Data0~Data1023,如上图。 那要怎么在显存里面存放Data数据。</p>
<h3><span id="3-2-1-fa-song-di-zhi">3.2.1 发送地址</span><a href="#3-2-1-fa-song-di-zhi" class="header-anchor">#</a></h3><h4><span id="3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</span><a href="#3-2-1-1-ye-page-di-zhi-mo-shi" class="header-anchor">#</a></h4><p>QG-2864TMBEG01 OLED主控有三种地址模式，我们常用的是页地址模式，发送0x20命令，再发送0x02命令，进入页地址模式，如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/16.png" alt="img"></p>
<p>它把显存的64行分为8页，每页对应8行；选中某页后，再选择某列。因此共用页地址，也就是8行都共用同一个页地址，列地址独立，所以page0<del>page7，col0</del>col127。然后就可以往里面写数据了，每写一个数据，列地址就会加1，一直写到最右端的位置，页地址加1，会自动跳到最左端。通过命令来实现发送页地址和列地址，其中列地址分为两次发送，先发送低字节，再发送高字节。如下图，假设每个字符数据大小为8x16像素，假如第一个字符位置为(page,col)，相邻的右边就是(page,col+8)，写一个字符需要先发8字节，然后跳到下一页坐标就是(page+2,col)，发送8字节数据。一个字符需要2个page*8个col，由于一个像素占1个bit, 所以一个Data占1byte, 一个字符占16 byte。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/17.png" alt="img"></p>
<h5><span id="3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</span><a href="#3-2-1-1-1-she-zhi-page-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/18.png" alt="img"></p>
<p>一共就8页，因此X2<del>X0，有3bit足够了。比如选中page0，则x2</del>x0 &#x3D; 000。</p>
<h5><span id="3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</span><a href="#3-2-1-1-2-she-zhi-col-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/19.png" alt="img"></p>
<p>分两次发送， 先发送列地址低4位，再发送列地址高4位；</p>
<h3><span id="3-2-2-fa-song-shu-ju">3.2.2 发送数据</span><a href="#3-2-2-fa-song-shu-ju" class="header-anchor">#</a></h3><p>如何发送一个字符‘A’，显示到OLED。</p>
<ol>
<li>取得字模</li>
</ol>
<p>这里从网上找了一份8x16的字库。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLEDFONT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLEDFONT_H      </span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> oled_asc2_8x16[<span class="number">95</span>][<span class="number">16</span>]= &#123;</span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">// 0</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//!1</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&quot;2</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//#3</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0xFC</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//$4</span></span><br><span class="line">    &#123;<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x1C</span>,<span class="number">0x03</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//%5</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x27</span>,<span class="number">0x21</span>,<span class="number">0x10</span>&#125;,<span class="comment">//&amp;6</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x16</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#x27;7</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//(8</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x18</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//)9</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//*10</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x1F</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//+11</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xB0</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//,12</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>&#125;,<span class="comment">//-13</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//.14</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">///15</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//016</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//117</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//218</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x48</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//319</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x00</span>&#125;,<span class="comment">//420</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//521</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//622</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//723</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//824</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//925</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//:26</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//;27</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&lt;28</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//=29</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&gt;30</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x48</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x36</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//?31</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0xC8</span>,<span class="number">0x28</span>,<span class="number">0xE8</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x27</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x14</span>,<span class="number">0x0B</span>,<span class="number">0x00</span>&#125;,<span class="comment">//@32</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3C</span>,<span class="number">0x23</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x27</span>,<span class="number">0x38</span>,<span class="number">0x20</span>&#125;,<span class="comment">//A33</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//B34</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;,<span class="comment">//C35</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//D36</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x23</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//E37</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//F38</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x1E</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//G39</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//H40</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//I41</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//J42</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0xC0</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x01</span>,<span class="number">0x26</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//K43</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//L44</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//M45</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//N46</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//O47</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//P48</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x18</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x38</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Q49</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//R50</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//S51</span></span><br><span class="line">    &#123;<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//T52</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//U53</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x78</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x0E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//V54</span></span><br><span class="line">    &#123;<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x3C</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x3C</span>,<span class="number">0x03</span>,<span class="number">0x00</span>&#125;,<span class="comment">//W55</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x68</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x2C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//X56</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0xC8</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Y57</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x38</span>,<span class="number">0x26</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Z58</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//[59</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>&#125;,<span class="comment">//\60</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//]61</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//^62</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>&#125;,<span class="comment">//_63</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//`64</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//a65</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//b66</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x00</span>&#125;,<span class="comment">//c67</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x88</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//d68</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x00</span>&#125;,<span class="comment">//e69</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//f70</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x6B</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x93</span>,<span class="number">0x60</span>,<span class="number">0x00</span>&#125;,<span class="comment">//g71</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//h72</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//i73</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//j74</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x02</span>,<span class="number">0x2D</span>,<span class="number">0x30</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//k75</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//l76</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>&#125;,<span class="comment">//m77</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//n78</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//o79</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0xA1</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//p80</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xA0</span>,<span class="number">0xFF</span>,<span class="number">0x80</span>&#125;,<span class="comment">//q81</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//r82</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x00</span>&#125;,<span class="comment">//s83</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//t84</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//u85</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//v86</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x0F</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//w87</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x2E</span>,<span class="number">0x0E</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//x88</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x81</span>,<span class="number">0x8E</span>,<span class="number">0x70</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//y89</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//z90</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x7C</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>&#125;,<span class="comment">//&#123;91</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//|92</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x7C</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#125;93</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//~94</span></span><br><span class="line">&#125;;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>发送页&#x2F;列地址</p>
</li>
<li><p>发送数据</p>
</li>
</ol>
<h2><span id="3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</span><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</span><a href="#3-3-1-ruan-jian-ceng-ci" class="header-anchor">#</a></h3><p>操作OLED，通过三条线(SCK、DO、CS)与OLED相连，这里没有DI是因为s3c2440只会向OLED传数据而不用接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpio_spi.c来实现gpio模拟spi，负责spi通讯。对于OLED，有专门的指令和数据格式，要传输的数据内容。</span><br><span class="line">oled.c这一层来实现，负责组织数据。</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</span><a href="#3-3-2-gpio-spi-c" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/20.png" alt="img"></p>
<h4><span id="3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</span><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h4><p>上图J3为板子pin2pin到OLED的底座。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPF1作为OLED片选引脚，设置为输出；</span><br><span class="line">GPG4作为OLED的数据(Data)/命令(Command)选择引脚，设置为输出；</span><br><span class="line">GPG5作为SPI的MISO，设置为输入（实际用不到）；</span><br><span class="line">GPG6作为SPI的MOSI，设置为输出；</span><br><span class="line">GPG7作为SPI的时钟CLK，设置为输出；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/21.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/22.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* GPF1 as OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//取消OLED_CSn片选，pull up</span></span><br><span class="line">   <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//取消FLASH_CSn 片选，pull up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-2-xie-ming-ling">3.3.2.2 写命令</span><a href="#3-3-2-2-xie-ming-ling" class="header-anchor">#</a></h4><p>D&#x2F;C即数据(Data)&#x2F;命令(Command)选择引脚，它为高电平时，OLED即认为收到的是数据；它为低电平时，OLED即认为收到的是命令。先设置为命令模式，再片选OLED，再传输命令，再恢复成原来的模式和取消片选。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/23.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  gpio output default is pull up*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>拉低DC引脚表示要发送是命令；</p>
</li>
<li><p>片选</p>
</li>
<li><p>发送1byte数据</p>
</li>
</ol>
<h5><span id="3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</span><a href="#3-3-2-2-1-spisendbyte" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/24.png" alt="img"><br>SPISendByte是把一个byte数据从高位往低位依次发送到DO。spi配置模式0， 主控先设置CLK为低，由于是MSB, 先传送高位，然后CLK为高，在CLK这个上升沿,DO的数据被锁存，OLED就读取了一位数据。接着左移一位，传输下一位。通过SPI_Set_CLK()和SPI_Set_DO()配置SCK和DO的时序，用gpio模拟出了spi。至此，SPI初始化和OLED初始化就基本完成了，接下来就是OLED显示部分。</p>
<p>这里gpio模拟spi传送时主控没有加延时控制SCK的频率，那是由于s3c2440本身cpu运行就很慢，这里不延时也是能满足该款外设的spi传输时序，如果cpu很快，那么需要控制spi时序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔一个SPI时钟，发送1位数据，MSB-高位先出</span></span><br><span class="line"><span class="comment">//这里的SPI时钟并没有指定周期，这就取决于指令执行的速率，指令执行越快，gpio模拟的SPI时钟越快,如下：     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">              SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">              SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">              SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">              val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>取消片选</li>
<li>DC拉高</li>
</ol>
<h4><span id="3-3-2-3-xie-shu-ju">3.3.2.3 写数据</span><a href="#3-3-2-3-xie-shu-ju" class="header-anchor">#</a></h4><p>与写命令同理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span>&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data*/</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(data);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-oled-c">3.2.3 oled.c</span><a href="#3-2-3-oled-c" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</span><a href="#3-2-3-1-chu-shi-hua-oled" class="header-anchor">#</a></h4><p>找到<strong>QG-2864TMBEG01</strong> 的power on sequence-上电时序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</span><a href="#3-2-3-2-qu-dong-xian-shi-oled" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++) &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</span><a href="#3-3-4-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************** gpio_spi.c ****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 用GPIO模拟SPI */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* GPF1 OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);</span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************* oled.c****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio_spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(dat);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPageAddrMode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x20</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line"> </span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPageAddrMode();</span><br><span class="line"> </span><br><span class="line">    OLEDClear();</span><br><span class="line">     </span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAF</span>); <span class="comment">/*display ON*/</span>   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/" data-id="clyylnk8p001o7wuf30m64zvi" data-title="s3c2440裸机编程-SPI" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-I2C" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/" class="article-date">
  <time class="dt-published" datetime="2024-04-18T07:10:45.000Z" itemprop="datePublished">2024-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/">s3c2440裸机编程-I2C</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-i2c-yuan-li">1 I2C原理</a><ul>
<li><a href="#1-1-ying-jian-dian-lu">1.1 硬件电路</a></li>
<li><a href="#1-2-i2c-xie-yi">1.2 i2c协议</a><ul>
<li><a href="#1-2-1-s-p-xin-hao">1.2.1 S&#x2F;P信号</a></li>
<li><a href="#1-2-2-ack-xin-hao">1.2.2 ACK信号</a></li>
<li><a href="#1-2-3-data-ge-shi">1.2.3 DATA格式</a></li>
<li><a href="#1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</a></li>
</ul>
</li>
<li><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</a></li>
<li><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</a></li>
<li><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</a></li>
</ul>
</li>
<li><a href="#2-i2c-kong-zhi-qi">2 I2C控制器</a><ul>
<li><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</a></li>
<li><a href="#2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</a><ul>
<li><a href="#2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</a></li>
<li><a href="#2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</a><ul>
<li><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</a></li>
<li><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</a></li>
<li><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</a></li>
<li><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</a><ul>
<li><a href="#3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</a><ul>
<li><a href="#3-1-1-zhu-fa-master-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-2-zhu-shou-master-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</a></li>
<li><a href="#3-1-3-cong-fa-slave-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-4-cong-shou-slave-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-cheng-xu-shi-li">4 I2C程序示例</a><ul>
<li><a href="#4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</a><ul>
<li><a href="#4-1-1-at24cxx-eeprom">4.1.1 AT24CXX EEPROM</a></li>
</ul>
</li>
<li><a href="#4-2-cheng-xu-kuang-jia">4.2 程序框架</a><ul>
<li><a href="#4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</a></li>
<li><a href="#4-2-2-i2c-test-c">4.2.2 i2c_test.c</a></li>
<li><a href="#4-2-3-at24cxx-c">4.2.3 at24cxx.c</a></li>
<li><a href="#4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</a></li>
<li><a href="#4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</a></li>
<li><a href="#4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</a></li>
</ul>
</li>
<li><a href="#4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</a></li>
<li><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</a><ul>
<li><a href="#4-4-1-xie-cao-zuo">4.4.1 写操作</a></li>
<li><a href="#4-4-2-du-cao-zuo">4.4.2 读操作</a></li>
</ul>
</li>
<li><a href="#4-5-ce-shi">4.5 测试</a><ul>
<li><a href="#4-5-1-i2c-test-c">4.5.1 i2c_test.c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-i2c-yuan-li">1 I2C原理</span><a href="#1-i2c-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-ying-jian-dian-lu">1.1 硬件电路</span><a href="#1-1-ying-jian-dian-lu" class="header-anchor">#</a></h2><p>I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/1.png" alt="img"></p>
<p>SDA（串行数据线）和SCL（串行时钟线）都是双向I&#x2F;O线，需通过上拉电阻接电源VCC．当总线空闲时．两根线都是高电平。</p>
<p>I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。</p>
<h2><span id="1-2-i2c-xie-yi">1.2 i2c协议</span><a href="#1-2-i2c-xie-yi" class="header-anchor">#</a></h2><p>传输过程如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/2.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 主控发送start讯号(S)</span><br><span class="line"><span class="number">2.</span> 主控发送从设备地址(slave dev addr)</span><br><span class="line"><span class="number">3.</span> 主控发送方向（W/R）</span><br><span class="line"><span class="number">4.</span> 从设备应答（ack）</span><br><span class="line"><span class="number">5.</span> 主控（or从设备）发送数据(data)</span><br><span class="line"><span class="number">6.</span> 从设备（or主控）应答(ack)</span><br><span class="line">...</span><br><span class="line"><span class="number">7.</span> 主控发送停止信号(P)</span><br></pre></td></tr></table></figure>

<p>s3c2440 一次i2c读写过程:</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/3.png" alt="img"></p>
<h3><span id="1-2-1-s-x2f-p-xin-hao">1.2.1 S&#x2F;P信号</span><a href="#1-2-1-s-x2f-p-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/4.png" alt="img"></p>
<p>start信号：SCL是高电平，SDA被主控拉低。<br>stop信号：SCL是高电平，SDA被主控拉高。</p>
<p>示波器测量出start信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/5.png" alt="img"></p>
<p>示波器测量出stop信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/6.png" alt="img"></p>
<h3><span id="1-2-2-ack-xin-hao">1.2.2 ACK信号</span><a href="#1-2-2-ack-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/7.png" alt="img"></p>
<p>第9个时钟周期，SDA被拉低表示ack讯号。</p>
<h3><span id="1-2-3-data-ge-shi">1.2.3 DATA格式</span><a href="#1-2-3-data-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/8.png" alt="img"></p>
<p>用 9个clk传输8bit数据（7bit 从设备地址 + 1bit方向 ），MSB高位先出。第9个clk是ack讯号。</p>
<h3><span id="1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</span><a href="#1-2-4-shu-ju-you-xiao-xing" class="header-anchor">#</a></h3><p>SDA 线上的数据必须在<strong>SCL高电平周期保持稳定，在 SCL 低电平时才能允许改变</strong>。</p>
<h2><span id="1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</span><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/9.jpg" alt="img"></p>
<ol>
<li>主控发送了S信号；</li>
<li>发送地址0x34，包含读写位；</li>
<li>发送数据0x30, 0x00, 0x01共3个字节数据；</li>
<li>最后SDA被拉高发送P信号。</li>
</ol>
<p>这里我是用了带I2C解码的示波器，能将I2C协议解码出来方便调试者阅读分析。</p>
<h2><span id="1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</span><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li" class="header-anchor">#</a></h2><p>电路设计内部结构使用<strong>开极电路</strong>。如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/10.png" alt="img"></p>
<p><strong>条件</strong>：</p>
<ol>
<li><p>主设备发送时，从设备不发送（通过SCL控制即可，比如让前8个clk主控发送数据到SDA,让第9个clk从设备发送数据到SDA）</p>
</li>
<li><p>主设备发送数据时，从设备的“发送引脚”不能影响SDA数据。反之，从设备发送数据时，主设备的”发送引脚”不能影响到SDA数据。那么如何做到？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDA内部电路用三极管，开集电路,原理如下图：</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/11.png" alt="img"></p>
<p>从上图知道：</p>
<ol>
<li><p>当A,B都为低电平时，三极管不导通，SDA的电平取决于外部电路，这里SDA有上拉电阻，所以对应高电平；</p>
</li>
<li><p>当主控拉高A时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
<li><p>同理，当从设备拉高B时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
</ol>
</li>
</ol>
<p>那么电平真值表如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/12.png" alt="img"></p>
<p>所以，要实现双向传输：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果要master-&gt; slave进行数据传输，那么让主控驱动三极管，拉低SDA。</span><br><span class="line">如果要slave-&gt; master进行数据传输，那么让从设备驱动三极管，拉低SDA。</span><br><span class="line">否则，都不驱动三极管，SDA一直输出高电平，处于idle状态。</span><br></pre></td></tr></table></figure>

<p>从下面的例子可以看看数据是怎么传的（实现双向传输）。</p>
<p>举例：主设备发送（8bit）给从设备:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前 <span class="number">8</span> 个 clk</span><br><span class="line">	◼ 从设备不要影响 SDA，从设备不驱动三极管</span><br><span class="line">	◼ 主设备决定数据，主设备要发送 <span class="number">1</span> 时不驱动三极管，要发送 <span class="number">0</span> 时驱动三极管</span><br><span class="line">第 <span class="number">9</span> 个 clk，由从设备决定数据</span><br><span class="line">	◼ 主设备不驱动三极管</span><br><span class="line">	◼ 从设备决定数据，要发出回应信号的话，就驱动三极管让 SDA 变为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从这里也可以知道 ACK 信号是低电平从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是 SDA 上要使用上拉电阻的原因。</p>
<p>为何 SCL 也要使用上拉电阻？在第 9 个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把 SCL 拉低。</p>
<p>当 SCL 为低电平时候，大家都不应该使用 IIC 总线，只有当 SCL 从低电平变为高电平的时候，IIC 总线才能被使用。当它就绪后，就可以不再驱动三极管，这是上拉电阻把 SCL 变为高电平，其他设备就可以继续使用 I2C 总线了。</p>
<h2><span id="1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</span><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/13.png" alt="img"></p>
<p>在<strong>第9个clk 后i2c会产生中断，此时SCL被拉低，表示busy状态</strong>，表示谁都不允许再使用i2c, 然后等到中断处理结束了，也就是处于idle状态了，此时会释放出SCL，那么主控可以继续发送SCL讯号表示可以继续进行i2c通信了。</p>
<h1><span id="2-i2c-kong-zhi-qi">2 I2C控制器</span><a href="#2-i2c-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</span><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/14.png" alt="img"></p>
<p>对于写操作，主控作为transmitter,从设备作为receiver。<br>对于读操作，主控作为receiver， 从设备作为transmitter。</p>
<h2><span id="2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</span><a href="#2-2-s3c2440-i2c-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</span><a href="#2-2-1-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/15.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pclk = <span class="number">50</span>Mhz, 经过prescaler分频，可以得到SCL。</span><br><span class="line"></span><br><span class="line">IICSTAT: 发出S（start）信号或者P(stop)信号。</span><br><span class="line"></span><br><span class="line">Data Bus可以把数据写入IICDS寄存器，然后会自动产生SCL，并且会将<span class="number">8</span>位数据从SDA同步给slave dev，</span><br><span class="line"></span><br><span class="line">在数据发送出去后，在第<span class="number">9</span>个SCL时钟，会受到slave dev的ack应答，可以通过查询IICSTAT来判断是否有ACK回应。</span><br><span class="line"></span><br><span class="line">当slave dev回应ACK后，那么又可以继续发送数据，继续写入据到IICDS。</span><br><span class="line"></span><br><span class="line">当主控想结束，设置IICSTAT发出P信号。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</span><a href="#2-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</span><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/16.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bit[<span class="number">7</span>]: 对于发送模式，不需要配置ack信号，ack是接收者发送回来的应答。对于接受模式，设置成<span class="number">1</span>，让它在第<span class="number">9</span>个CLK发出ack讯号（拉低sda）。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">6</span>]:SCL时钟源，pclk分频即可</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:中断使能，使用i2c时要去enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>]:中断状态标识 表示中断有没有结束，当该bit读出来是<span class="number">1</span>时，SCL被拉低表示busy，也就是i2c中断还在处理中。当i2c中断处理结束后，可以将该bit 清<span class="number">0</span>，释放出SCL。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>:<span class="number">0</span>]:i2c时钟分频系数配置，SCL时钟 = IICCLK/(IICCON[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</span><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/17.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">7</span>:<span class="number">6</span>]:模式选择</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:当读的时候，<span class="number">0</span>表示not busy,<span class="number">1</span>表示busy, 当写的时候，<span class="number">0</span>表示写入STOP, <span class="number">1</span>表示写入START</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>] : 数据输出使能，<span class="number">0</span>：表示disable, <span class="number">1</span>表示enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>]:仲裁flag</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">0</span>]:表示i2c总线上的第<span class="number">9</span>个时钟周期有没有ack，<span class="number">1</span>表示有ack, <span class="number">0</span>表示无ack</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</span><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/18.png" alt="img"></p>
<h4><span id="2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</span><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/19.png" alt="img"></p>
<h1><span id="3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</span><a href="#3-i2c-du-xie-cao-zuo-liu-cheng" class="header-anchor">#</a></h1><p>The following steps must be executed before any IIC Tx&#x2F;Rx operations.</p>
<ol>
<li>Write own slave address on IICADD register, if needed.</li>
<li>Set IICCON register.<ol>
<li>Enable interrupt</li>
<li>Define SCL period</li>
</ol>
</li>
<li>Set IICSTAT to enable Serial Output</li>
</ol>
<p>在操作tx,rx前，要先执行以下几步骤：</p>
<ol>
<li>IICADD写入从设备地址</li>
<li>设置IICCON，设置时钟，使能中断</li>
<li>设置IICSTAT，使能传输</li>
</ol>
<h2><span id="3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</span><a href="#3-1-i2c-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p>The S3C2440A IIC-bus interface has four operation modes:<br><strong>— Master transmitter mode</strong><br><strong>— Master receive mode</strong><br><strong>— Slave transmitter mode</strong><br><strong>— Slave receive mode</strong></p>
<h3><span id="3-1-1-zhu-fa-master-x2f-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</span><a href="#3-1-1-zhu-fa-master-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/20.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master tx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">11</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xF0（使能传输,发S信号，使能tx/rx）</span><br><span class="line">3. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">			IICDS = buf</span><br><span class="line">			Clear pending bit</span><br><span class="line">			数据被发送出去，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">			IICSTAT = <span class="number">0xd0</span></span><br><span class="line">			Clear pending bit（IICCON[<span class="number">4</span>]）</span><br><span class="line">			Delay一会儿等待停止条件生效</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-zhu-shou-master-x2f-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</span><a href="#3-1-2-zhu-shou-master-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/21.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master rx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">10</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xB0（使能传输）</span><br><span class="line">4. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">		Buf = IICDS</span><br><span class="line">		Clear pending bit</span><br><span class="line">		数据被接受到，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">		IICSTAT = <span class="number">0x90</span></span><br><span class="line">		Clear pending bit</span><br><span class="line">		Delay一会儿</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-cong-fa-slave-x2f-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</span><a href="#3-1-3-cong-fa-slave-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/22.png" alt="img"></p>
<h3><span id="3-1-4-cong-shou-slave-x2f-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</span><a href="#3-1-4-cong-shou-slave-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/23.png" alt="img"></p>
<h1><span id="4-i2c-cheng-xu-shi-li">4 I2C程序示例</span><a href="#4-i2c-cheng-xu-shi-li" class="header-anchor">#</a></h1><h2><span id="4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</span><a href="#4-1-i2c-cong-she-bei-jie-shao" class="header-anchor">#</a></h2><p>IIC控制器只提供了传输数据的能力，至于数据有什么含义，IIC控制器并不知道，数据的含义有外部i2c从设备，我们需要阅读芯片手册，才知道IIC控制器应该发出怎样的数据。</p>
<h3><span id="4-1-1-at24cxx-eeprom">4.1.1  AT24CXX EEPROM</span><a href="#4-1-1-at24cxx-eeprom" class="header-anchor">#</a></h3><p>AT24Cxx系列EEPROM是由美国Mcrochip公司出品，1-512K位的支持I2C总线数据传送协议的串行CMOS E2PROM。I2c传输规则如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/24.png" alt="img"></p>
<h2><span id="4-2-cheng-xu-kuang-jia">4.2 程序框架</span><a href="#4-2-cheng-xu-kuang-jia" class="header-anchor">#</a></h2><p>我们的程序应该分为两层（IIC设备层，IIC控制器层），框架如下图所示：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/25.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最上层是i2c_test层，用来对i2c的功能进行测试和验证。</span><br><span class="line"></span><br><span class="line">第2层是i2c设备层，用来对具体某一型号的从设备进行i2c读写。</span><br><span class="line"></span><br><span class="line">第3层是通用i2c控制器层，用来提供对具体某一型号的i2c主控进行管理操作。</span><br><span class="line"></span><br><span class="line">最底层是i2c控制器具体的型号层。</span><br></pre></td></tr></table></figure>

<p>在通用i2c控制层，我们提供一个统一的接口i2c_transfer，不关使用哪个芯片，他最终都会调用i2c_transfer，来选择某一款I2C控制器，把数据发送出去，或者从I2c设备读到数据。这种层次分明的架构是作为软件开发人员必备的素养和技能。这里也是借鉴了linux内核I2C子系统的模型。</p>
<h3><span id="4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</span><a href="#4-2-1-i2c-msg-jie-gou-ti" class="header-anchor">#</a></h3><p>我们借鉴Linux I2C子系统的数据结构定义。对于每一次传输的数据都可以用一个i2c_msg结构体来表示。但是，读某个地址的数据时，就要用两个i2c_msg结构体来描述它，因为一个i2c_msg结构体只能描述一个传输方向(读&#x2F;写)，我们读取ac24ccxx某个地址上的数据时，要先写出要读取的地址，然后来读取设备地址上的数据。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/26.png" alt="img"></p>
<h3><span id="4-2-2-i2c-test-c">4.2.2 i2c_test.c</span><a href="#4-2-2-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 初始化: 选择I2C控制器 */</span></span><br><span class="line">        <span class="comment">/* 提供菜单供测试 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个菜单会调用到at24cxx.c里面的函数进行i2c外设读写。</p>
<h3><span id="4-2-3-at24cxx-c">4.2.3 at24cxx.c</span><a href="#4-2-3-at24cxx-c" class="header-anchor">#</a></h3><p>定义描述at24cxx外设，并且实现该外设的操作，里面会使用标准的接口i2c_transfer来启动I2C传输。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24CXX_ADDR 0x50</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buf[<span class="number">0</span>] = addr++;</span><br><span class="line">                buf[<span class="number">1</span>] = data[i];</span><br><span class="line">                <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">                msg.addr  = AT24CXX_ADDR;</span><br><span class="line">                msg.flags = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">                msg.len   = <span class="number">2</span>;</span><br><span class="line">                msg.buf   = buf;</span><br><span class="line">                msg.err   = <span class="number">0</span>;</span><br><span class="line">                msg.cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">                err = i2c_transfer(&amp;msg, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">        msg[<span class="number">0</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">0</span>].flags  = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">        msg[<span class="number">0</span>].len   = <span class="number">1</span>;</span><br><span class="line">        msg[<span class="number">0</span>].buf   = &amp;addr;</span><br><span class="line">        msg[<span class="number">0</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">0</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg[<span class="number">1</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">1</span>].lags  = <span class="number">1</span>; <span class="comment">/* read */</span></span><br><span class="line">        msg[<span class="number">1</span>].len   = len;</span><br><span class="line">        msg[<span class="number">1</span>].buf   = data;</span><br><span class="line">        msg[<span class="number">1</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">1</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">        err = i2c_transfer(&amp;msg, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</span><a href="#4-2-4-i2c-controller-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> addr;  <span class="comment">/* 7bits */</span></span><br><span class="line">        <span class="type">int</span> flags;  <span class="comment">/* 0 - write, 1 - read */</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> cnt_transferred;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">&#125;i2c_msg, *p_i2c_msg;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_controller</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*<span class="type">int</span>)(<span class="type">void</span>);</span><br><span class="line">        <span class="type">int</span> (*master_xfer)(i2c_msg msgs, <span class="type">int</span> num);</span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">&#125;i2c_controller, *p_i2c_controller;</span><br></pre></td></tr></table></figure>

<p>构造i2c_msg和i2c_controller结构。</p>
<h3><span id="4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</span><a href="#4-2-5-i2c-controller-c" class="header-anchor">#</a></h3><p>实现通用i2c控制器管理，用来注册具体i2c控制器，调用具体控制器去做i2c通信。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CONTROLLER_NUM 10</span></span><br><span class="line"><span class="comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span></span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_controllers[I2C_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_con_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_i2c_controller</span><span class="params">(p_i2c_controller *p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p_i2c_controllers[i]) &#123;</span><br><span class="line">                        p_i2c_controllers[i] = p;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据名字来选择某款I2C控制器 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_i2c_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (p_i2c_controllers[i] &amp;&amp; !<span class="built_in">strcmp</span>(name, p_i2c_controllers[i]-&gt;name))</span><br><span class="line">                &#123;</span><br><span class="line">                        p_i2c_con_selected = p_i2c_controllers[i];</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现 i2c_transfer 接口函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(i2c_msg msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p_i2c_con_selected-&gt;master_xfer(msgs, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册下面的I2C控制器 */</span></span><br><span class="line">	s3c2440_i2c_con_add();</span><br><span class="line">	<span class="comment">/* 选择某款I2C控制器 */</span></span><br><span class="line">	select_i2c_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line">	<span class="comment">/* 调用它的init函数 */</span></span><br><span class="line">	p_i2c_con_selected-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</span><a href="#4-2-6-s3c2440-i2c-controller-c" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_interrupt_func</span>(<span class="params"><span class="built_in">int</span> irq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 配置引脚用于I2C*/</span></span><br><span class="line">        GPECON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">        GPECON |= ((<span class="number">2</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置时钟 */</span></span><br><span class="line">        <span class="comment">/* [7] : IIC-bus acknowledge enable bit, 1-enable in rx mode</span></span><br><span class="line"><span class="comment">         * [6] : 时钟源, 0: IICCLK = fPCLK /16; 1: IICCLK = fPCLK /512</span></span><br><span class="line"><span class="comment">         * [5] : 1-enable interrupt</span></span><br><span class="line"><span class="comment">         * [4] : 读出为1时表示中断发生了, 写入0来清除并恢复I2C操作</span></span><br><span class="line"><span class="comment">         * [3:0] : Tx clock = IICCLK/(IICCON[3:0]+1).</span></span><br><span class="line"><span class="comment">         * Tx Clock = 100khz = 50Mhz/16/(IICCON[3:0]+1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IICCON = (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">        register_irq(<span class="number">27</span>, i2c_interrupt_func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_tx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 master tx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* TX mode, 在ACK周期释放SDA */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/*IIC-bus data output enable/disable(1: Enable Rx/Tx)*/</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>;<span class="comment">//[slave addr [7:1], addr[0] is trans dir]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xf0 (启动传输), slave addr数据即被发送出去,当到达第9个clk,无论是否有ack, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_rx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 Master Rx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* RX mode, 在ACK周期回应ACK */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);  <span class="comment">/*IIC-bus data output enable/disable*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xb0 , 从设备地址即被发送出去, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xb0</span>;</span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">s3c2440_master_xfer</span>(<span class="params">p_i2c_msg msgs, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="built_in">int</span> err;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)        </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgs[i].flags == <span class="number">0</span>)<span class="comment">/* write */</span></span><br><span class="line">                        err = do_master_tx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        err = do_master_rx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_add</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_i2c_controller(&amp;s3c2440_i2c_con);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> i2c_controller s3c2440_i2c_con = &#123;</span><br><span class="line">        .name = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">        .<span class="keyword">init</span> = s3c2440_i2c_con_init,</span><br><span class="line">        .master_xfer = s3c2440_master_xfer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>s3c2440_i2c_con_add函数：注册 s3c2440的i2c控制器， 当调用i2c_init就会对选中的这款控制器初始化，也就是调用s3c2440_i2c_con_init。</p>
<p>s3c2440_i2c_con_init函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>).IICCON = (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>); 设置IICCON控制寄存器。选择发送时钟，使能中断。设置ACK应答使能，bit[<span class="number">7</span>]。</span><br><span class="line"><span class="number">2</span>).register_irq(<span class="number">27</span>, i2c_interrupt_func)：注册中断处理函数，当发生I2C中断的时候就会调用i2c_interrupt_func中断处理函数。</span><br></pre></td></tr></table></figure>

<p>s3c2440_master_xfer函数：</p>
<p>当发起i2c传输时，调用i2c_transfer，进而调用s3c2440_master_xfer进行数据传输。写的话do_master_tx，读的话do_master_rx。</p>
<p>do_master_rx函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)：把从设备地址写入IICDS，前<span class="number">7</span>位是从机地址，第<span class="number">8</span>位表示传输方向(<span class="number">0</span>表示写操作，<span class="number">1</span>表示读操作)。</span><br></pre></td></tr></table></figure>

<p>do_master_tx函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>: 把从机地址（高<span class="number">7</span>位，所以需要向右移一位）写入到IICDS寄存器中。</span><br><span class="line"><span class="number">2.</span> IICSTAT = <span class="number">0xf0</span>:设置IICSTAT寄存器，将s3c2440设为主机发送器，并发出S信号后，紧接着就发出从机地址。后续的传输工作将在中断服务程序中完成。</span><br></pre></td></tr></table></figure>

<h2><span id="4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</span><a href="#4-3-cheng-xu-kuang-jia-zong-jie" class="header-anchor">#</a></h2><p>对应程序框架的4层架构。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/27.png" alt="img"></p>
<h2><span id="4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</span><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h2><p>Start信号之后，发出设备地址，在第9个时钟就会产生第一个中断，我们根据i2c的流程图来编写中断程序。每传输完一个数据将又产生一个中断，I2C操作的主体在<strong>中断服务程序</strong>，它可以分为两部分：写操作，读操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> p_i2c_msg p_cur_msg;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">isLastData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == p_cur_msg-&gt;len - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* 正要开始传输最后一个数据 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_with_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* 回应ACK */</span></span><br><span class="line">        iiccon &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/* 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_without_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)); <span class="comment">/* 不回应ACK, 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_interrupt_func</span><span class="params">(<span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iicstat = IICSTAT;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//printf(&quot;i2c_interrupt_func! flags = %d\n\r&quot;, p_cur_msg-&gt;flags);</span></span><br><span class="line"> </span><br><span class="line">        p_cur_msg-&gt;cnt_transferred++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;flags == <span class="number">0</span>) &#123;<span class="comment">//write</span></span><br><span class="line">				<span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;  <span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/*iicstat [0] == 1表示no ack*/</span></span><br><span class="line">								<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;tx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						<span class="comment">/* 对于其他中断, 要继续发送下一个数据</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred];</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//clear pending bit</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 停止传输 */</span></span><br><span class="line">						IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//read</span></span><br><span class="line">                <span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在, 恢复I2C传输, 这样在下一个中断才可以得到第1个数据</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;<span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;rx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ack */</span></span><br><span class="line">                                <span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">                                <span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">                                <span class="keyword">if</span> (isLastData())</span><br><span class="line">                                        resume_iic_without_ack();</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        resume_iic_with_ack();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">				<span class="comment">/* 非第1个中断, 表示得到了一个新数据</span></span><br><span class="line"><span class="comment">				 * 从IICDS读出、保存</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						index = p_cur_msg-&gt;cnt_transferred - <span class="number">1</span>;</span><br><span class="line">						p_cur_msg-&gt;buf[index] = IICDS;</span><br><span class="line">		 </span><br><span class="line">						<span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">						<span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">						<span class="keyword">if</span> (isLastData())</span><br><span class="line">								resume_iic_without_ack();</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">								resume_iic_with_ack();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 发出停止信号 */</span></span><br><span class="line">						IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-1-xie-cao-zuo">4.4.1 写操作</span><a href="#4-4-1-xie-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. p_cur_msg-&gt;cnt_transferred初始值为-1(do_master_tx启动时设置)。</span><br><span class="line">2. p_cur_msg-&gt;cnt_transferred == 0表示是第一次传输数据完后产生的中断，即发送从设备地址产生的中断。</span><br><span class="line">3. iicstat &amp; (1&lt;&lt;0)表示主机没有接受到ACK信号(即发出的设备地址不存在)，需要停止传输。</span><br><span class="line">4. IICSTAT = 0xd0置IICSTAT寄存器的[5]写为0，产生P信号。但是由于这时IICCON[4]仍为1，P信号没有实际发出，当执行IICCON &amp;= ~(1&lt;&lt;4);清除IICCON[4]后，P信号才真正发出。</span><br><span class="line">5. 等待一段时间，确保P信号已经发送完毕。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">1).假如if (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)条件成立，表示数据还没有发送完毕，需要继续发送数据。</span><br><span class="line">2).执行IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred]把要发送的数据写入到IICDS寄存器中，经过执行IICCON &amp;= ~(1&lt;&lt;4);清除中断标志后后，紧接着就自动把数据发送出去了，这将触发下一个中断。</span><br><span class="line">3).如果条件不成立表示数据传输完毕，发出P信号，停止数据的传输。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-du-cao-zuo">4.4.2 读操作</span><a href="#4-4-2-du-cao-zuo" class="header-anchor">#</a></h3><p>见注释。</p>
<h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><h3><span id="4-5-1-i2c-test-c">4.5.1 i2c_test.c</span><a href="#4-5-1-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">    err = at24cxx_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_write ret = %d\n\r&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得长度 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the length to read: &quot;</span>);</span><br><span class="line">    len = get_int();</span><br><span class="line"></span><br><span class="line">    err = at24cxx_read(addr, data, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_read ret = %d\n\r&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 长度固定为64 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="comment">/* 先打印数值 */</span></span><br><span class="line">            c = data[cnt++];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/* 打印菜单, 供我们选择测试内容 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[w] Write at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[r] Read at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[q] quit\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Enter selection: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n\r&quot;</span>, c);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* 测试内容:</span></span><br><span class="line"><span class="comment">             * 3. 编写某个地址</span></span><br><span class="line"><span class="comment">             * 4. 读某个地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    do_write_at24cxx();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">					do_read_at24cxx();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/" data-id="clyylnk8o001f7wuf1nccdz39" data-title="s3c2440裸机编程-I2C" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-nandflash" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/" class="article-date">
  <time class="dt-published" datetime="2024-04-17T12:10:39.000Z" itemprop="datePublished">2024-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/">s3c2440裸机编程-nandflash</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nandflash-yuan-li">1 nandflash原理</a><ul>
<li><a href="#1-1-yuan-li-tu">1.1 原理图</a></li>
<li><a href="#1-2-yin-jiao-miao-shu">1.2 引脚描述</a></li>
<li><a href="#1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</a><ul>
<li><a href="#1-3-1-block-kuai">1.3.1 Block块</a></li>
<li><a href="#1-3-2-page-ye">1.3.2 Page页</a></li>
<li><a href="#1-3-3-oob-qu-yu">1.3.3 oob区域</a></li>
<li><a href="#1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</a></li>
</ul>
</li>
<li><a href="#1-4-feature-te-xing">1.4 Feature特性</a></li>
<li><a href="#1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</a></li>
</ul>
</li>
<li><a href="#2-nand-kong-zhi-qi">2 Nand控制器</a><ul>
<li><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</a></li>
<li><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</a></li>
</ul>
</li>
<li><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</a><ul>
<li><a href="#3-1-ming-ling-di-zhi-suo-cun-shi-xu-xie-ming-ling-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</a><ul>
<li><a href="#3-1-1-k9f2g08u0c-ming-ling-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</a></li>
</ul>
</li>
<li><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</a></li>
<li><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</a></li>
</ul>
</li>
<li><a href="#4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</a><ul>
<li><a href="#4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</a></li>
<li><a href="#4-2-du-id-shi-xu">4.2 读ID时序</a></li>
<li><a href="#4-3-chu-shi-hua">4.3 初始化</a><ul>
<li><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</a><ul>
<li><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</a></li>
<li><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-shi-bie-nandflash">4.4 识别nandflash</a><ul>
<li><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</a></li>
<li><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</a><ul>
<li><a href="#5-1-du-shu-ju">5.1 读数据</a><ul>
<li><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</a></li>
<li><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</a></li>
</ul>
</li>
<li><a href="#5-2-ca-shu-ju">5.2 擦数据</a></li>
<li><a href="#5-3-xie-shu-ju">5.3 写数据</a></li>
<li><a href="#5-4-ce-shi">5.4 测试</a></li>
<li><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nandflash-yuan-li">1 nandflash原理</span><a href="#1-nandflash-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-yuan-li-tu">1.1 原理图</span><a href="#1-1-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/1.png"></p>
<h2><span id="1-2-yin-jiao-miao-shu">1.2 引脚描述</span><a href="#1-2-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/2.png"></p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>IO0~IO7</td>
<td>数据输入输出（命令、地址、数据共用数据总线）</td>
</tr>
<tr>
<td>CLE</td>
<td>命令使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址使能</td>
</tr>
<tr>
<td>&#x2F;CE</td>
<td>芯片使能（片选）</td>
</tr>
<tr>
<td>&#x2F;RE</td>
<td>读使能</td>
</tr>
<tr>
<td>&#x2F;WE</td>
<td>写使能</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号（低电平表示操作还在进行中，高电平表示操作完成）</td>
</tr>
</tbody></table>
<h2><span id="1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</span><a href="#1-3-nand-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/3.png"></p>
<p>我们常见的Nand Flash，内部只有一个chip，每个chip只有一个plane。但也有些复杂的，容量更大的Nand Flash，内部有多个chip，每个chip有多个plane，这类的Nand Flash，其实就是多了一个主控将多块flash叠加在一起，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/4.png"></p>
<h3><span id="1-3-1-block-kuai">1.3.1 Block块</span><a href="#1-3-1-block-kuai" class="header-anchor">#</a></h3><p>一个Nand Flash由很多个块（Block）组成，块的大小一般有64K，128KB，256KB，512KB，<strong>Block是Nand Flash的擦除操作的基本&#x2F;最小单位</strong>。Nand Flash中，一个块中含有1个或多个位是坏的，就称为其为<strong>坏块Bad Block</strong>。</p>
<h3><span id="1-3-2-page-ye">1.3.2 Page页</span><a href="#1-3-2-page-ye" class="header-anchor">#</a></h3><p>每个块里面又包含了很多页（page）。每个页的大小，对于现在常见的Nand Flash多数是2KB，当然也有的nand flash的页大小为4KB、8KB等。<strong>页Page，是读写操作的基本单位</strong>。</p>
<h3><span id="1-3-3-oob-qu-yu">1.3.3 oob区域</span><a href="#1-3-3-oob-qu-yu" class="header-anchor">#</a></h3><p>每一个page页，对应还附加了一块区域，一般为64byte，叫做空闲区域（spare area）&#x2F;oob区域（Out Of Band），由于nandflash在操作过程中容易产生位反转，这是nandflash的物理特性决定的，所以必须要有对应的检测和纠错机制，这种机制被叫做Error Checking and Correcting，所以设计了多余的oob区域，<strong>用于放置数据的校验值</strong>。oob的读写操作，一般是随着页的操作一起完成的，即读写页的时候，对应地就读写了oob。</p>
<p>关于oob具体用途，总结起来有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标记是否是坏快</span><br><span class="line">存储ECC数据</span><br><span class="line">存储一些和文件系统相关的数据。如jffs2就会用到这些空间存储一些特定信息</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</span><a href="#1-3-4-cun-chu-dan-wei-guan-xi" class="header-anchor">#</a></h3><p>一般情况下：1block &#x3D; 64page &#x3D; 64 * (2K+64B) &#x3D; 128K + 4K， 一个page包含2K数据和64B的oob。</p>
<h2><span id="1-4-feature-te-xing">1.4 Feature特性</span><a href="#1-4-feature-te-xing" class="header-anchor">#</a></h2><p>以<strong>K9F2G08U0C</strong>这款nandflash为例：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/5.png"></p>
<p>可以看出此款nandflash特性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 容量为<span class="number">256</span>M，外加<span class="number">8</span>M的冗余oob存储区。</span><br><span class="line"><span class="number">2.</span> page大小为<span class="number">2</span>K，block大小为<span class="number">128</span>K</span><br><span class="line"><span class="number">3.</span> 读一个page时顺序读取至少<span class="number">25</span>*<span class="number">2048</span>ns(数据可以每字节<span class="number">25</span>ns的循环时间读出)，随机读取不超过<span class="number">40u</span>s</span><br><span class="line"><span class="number">4.</span> 写一个page一般为<span class="number">250u</span>s</span><br><span class="line"><span class="number">5.</span> 擦除一个block一般为<span class="number">2</span>ms</span><br><span class="line"><span class="number">6.</span> 封装上分为TSOP分装和FBGA封装（TSOP是指引脚在侧面，FBGA是引脚封在芯片底部，更能保障数据安全，有些客户为了保障数据安全性，防止被飞线进行数据破解，会要求用FBGA封装的flash）</span><br></pre></td></tr></table></figure>

<h2><span id="1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</span><a href="#1-5-chang-jian-de-flash-han-shang" class="header-anchor">#</a></h2><p>常见的flash厂商有：Micron（镁光）、Toshiba（东芝）、Samsung（三星）、MXIC(旺宏)、dosilicon(东芯)，（Winbond）华邦、ESMT等。</p>
<h1><span id="2-nand-kong-zhi-qi">2 Nand控制器</span><a href="#2-nand-kong-zhi-qi" class="header-anchor">#</a></h1><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>介绍讲到，我们知道nand没有独立地址线，cpu无法直接访问nand上的指令，所以nand不能片上执行。那么为何程序还能支持nand启动的呢？</p>
<p>为了支持NAND启动，S3C2440A配备了一个称为“ Steppingstone”的内部SRAM缓冲区,容量为4K。 开机时，Nandflash中的前4K数据将被加载到Steppingstone中，而引导代码将被加载到SRAM中将被执行，如下图所示：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/6.png"></p>
<h2><span id="2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</span><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze" class="header-anchor">#</a></h2><p>我们知道s3c2440支持2种boot方式，nand或者nor，那么需要配置OM引脚来设置引导方式，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/7.png"></p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/8.png"></p>
<p>内存控制器的地址映射表如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/9.png"></p>
<p>当SW2闭合,OM0&#x3D;1, OM[1:0]&#x3D;01, 0地址对应nor，那么从nor启动。<br>当SW2断开,OM0&#x3D;0, OM[1:0]&#x3D;00, 0地址对应bootSRAM(4K)，那么0地址对应该SRAM, 那么从nand启动。</p>
<h2><span id="2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</span><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi" class="header-anchor">#</a></h2><p>当上电启动时，NAND Flash 控制器将通过下面的引脚配置来获取连接的 NAND Flash 的信息。</p>
<p><strong>NCON</strong>：NAND Flash 存储器选择（普通&#x2F;先进）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：普通 NAND Flash（<span class="number">256</span> 字或 <span class="number">512</span> 字节页大小，<span class="number">3</span> 或 <span class="number">4</span> 个地址周期）</span><br><span class="line"><span class="number">1</span>：先进 NAND Flash（<span class="number">1</span>K 字或 <span class="number">2</span>K 字节页大小，<span class="number">4</span> 或 <span class="number">5</span> 个地址周期）</span><br></pre></td></tr></table></figure>

<p><strong>GPG13</strong>：NAND Flash 存储器page size选择</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：页=<span class="number">256</span> 字（NCON=<span class="number">0</span>）或页=<span class="number">1</span>K 字（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：页=<span class="number">512</span> 字节（NCON=<span class="number">0</span>）或页=<span class="number">2</span>K 字节（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<p><strong>GPG14</strong>：NAND Flash 存储器地址周期选择</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">3</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">4</span> 个地址周期（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：<span class="number">4</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">5</span> 个地址周期（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>
<p><strong>GPG15</strong>：NAND Flash 存储器总线宽度选择</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">8</span> 位宽度</span><br><span class="line"><span class="number">1</span>：<span class="number">16</span> 位宽度</span><br></pre></td></tr></table></figure>
<p>如下表所示更直观:<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/10.png"></p>
<h1><span id="3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</span><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu" class="header-anchor">#</a></h1><p>nandflash访问时需要遵循一定的时序才能完成命令、地址、数据的发送。nandflash有8bit位宽数据总线，那么没有地址线它是怎么和cpu通信的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>nandflash是DATA0～DATA7上既传输数据，又传输地址，又传输命令；</span><br><span class="line">	①当ALE为高电平时传输的是地址；</span><br><span class="line">	②当CLE为高电平时传输的是命令；</span><br><span class="line">	③当ALE，CLE都为低电平表示传输的是数据</span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 先发送片选CS和WE/RE信号</span><br><span class="line"> <span class="number">3.</span> 再发送CLE</span><br><span class="line"> <span class="number">4.</span> 再发送ALE</span><br><span class="line"> <span class="number">5.</span> 最后发送数据</span><br></pre></td></tr></table></figure>

<p>下面分别介绍命令、地址、数据的发送过程。</p>
<h2><span id="3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</span><a href="#3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/11.png"></p>
<ol>
<li>首先看时钟，nand控制器的时钟源采用的是HCLK, 也就是AHB高速总线模式，可以参考<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>那么HCLK&#x3D;100Mhz, T&#x3D;1&#x2F;HCLK&#x3D;10ns。</li>
<li>从上图可知命令、地址锁存的时序是一样的，复用一个时序图，当到达①的位置时，CLE&#x2F;ALE&#x3D;0; </li>
<li>当到达位置②时，CLE&#x2F;ALE&#x3D;1,表示命令&#x2F;地址信号拉高，命令&#x2F;地址开始使能，然后往数据总线DATA上放入命令或地址;</li>
<li>经过TACLS时间，到达位置③时，拉低nWE引脚，这时数据总线DATA上的命令&#x2F;地址开始被锁存，锁存需要一定的时间，所以经过TWRPH0时间后，数据总线DATA上的命令&#x2F;地址锁存完成；</li>
<li>到达位置④，此时释放nWE信号，nWE&#x3D;1，这时还需要经过TWRPH1时间后，释放CLE&#x2F;ALE，此时一个完整的命令&#x2F;地址锁存过程完成。</li>
</ol>
<p>上面分析了命令&#x2F;地址的锁存时序过程，下面详细解释下上面几个时间参数的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TACLS：CLE/ALE使能信号发送多久后才可以发送nWE信号</span><br><span class="line">TWRPH0:nWE信号发送多久后数据（commamd/addr）才会被锁存成功</span><br><span class="line">TWRPH1：nWE信号释放多久后才能释放CLE/ALE</span><br></pre></td></tr></table></figure>

<p>这些时间参数要根据我们实际使用的具体nandflash型号和性能来配置我们的nand控制器。</p>
<h3><span id="3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</span><a href="#3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu" class="header-anchor">#</a></h3><p>以K9F2G08U0C这款nandflash为例进行讲解，规格书上命令和地址锁存周期如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/12.png"></p>
<p>和nand控制器的命令&#x2F;地址锁存时序图对比发现:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TACLS = max(tCLS,tALS) - tWP;</span><br><span class="line">TWRPH0 = tWP;</span><br><span class="line">TWRPH0 = max(tCLH,tALH);</span><br></pre></td></tr></table></figure>

<p>nand控制器把命令、地址锁存时序复用成了一个时序图，其实命令和地址锁存时序参数基本一致，只不过发命令只需要一个周期就OK了，发地址需要5个时钟周期，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你想，命令多简单，无非就是读写擦，像我们这款nand数据位宽8bit，一个周期绰绰有余。但地址就不一样了，比如此款nandflash容量256M = 2^28，那么需要28根数据线来传输才能一个周期传输完，但这款nandflash的数据总线位宽只有8bit, 只有8根数据线，所以需要把地址拆分成多次发送，先发送col地址，再发送row地址，此款nandflash是用了5个周期发送地址。</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</span><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju" class="header-anchor">#</a></h2><p>从前面的命令地址锁存时序图中我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLE信号拉高，ALE信号拉低时，表示发送的命令；</span><br><span class="line">CLE信号拉低，ALE信号拉高时，表示发送的地址；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/13.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLE信号拉低, ALE信号拉低时，表示发送的数据;</span><br></pre></td></tr></table></figure>

<ol>
<li>当到达①时，nWE还是高电平，写使能没有开启；</li>
<li>当到达②,③时，那么经过了tWP时间（TDS时间），数据开始被锁存；</li>
<li>到达④，经过tDH时间，数据锁存完成;</li>
<li>到达⑤，也就是数据开始锁存后再过了tWH时间后释放nWE信号；</li>
<li>重复②③④⑤过程,得到DIN0, DIN1, DIN final。</li>
</ol>
<p>根据上面这三个图（手册上的命令、地址、数据锁存时序图），下面详细解释各个时间参数的含义：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/14.png"></p>
<h2><span id="3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</span><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/15.png"></p>
<ol>
<li>①处，表示要过tRR后才能发送读使能信号nRE进行访问（上一次的访问结束后，需要等待ready状态稳定后才可以进行下一次访问）；</li>
<li>当到达②，需要经过rREA时间后nRE信号才有效（待nRE稳定）；</li>
<li>当到达③，DATA总线上的读取被读取；</li>
<li>当到达④，nRE释放tREH时间后才允许下一次读使能；</li>
</ol>
<p>我们看到连续顺序访问时，单次访问的时间为tRC，那么这些时间参数的值也可以从K9F2G08U0C datasheet中找到：为25ns</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/16.png"></p>
<h1><span id="4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</span><a href="#4-nandflash-chu-shi-hua-he-shi-bie" class="header-anchor">#</a></h1><h2><span id="4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</span><a href="#4-1-nandflash-ming-ling-biao" class="header-anchor">#</a></h2><p>找到K9F2G08U0C datasheet，对NAND FLASH的操作需要发出命令，下面有个NAND FLASH的命令表格，用此表格上的命令来访问我们的nandflash：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/17.png"></p>
<h2><span id="4-2-du-id-shi-xu">4.2 读ID时序</span><a href="#4-2-du-id-shi-xu" class="header-anchor">#</a></h2><p>命令表中的读id还不太直观，下图是从nand芯片手册中截取出的读id时序图：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/18.png"></p>
<ol>
<li>第一条竖线位置，发送了nCE,CLE,nWE信号，所以90命令被锁存（readID命令）；</li>
<li>第二条竖线位置，发送了nCE,ALE,nWE信号，所以地址00被锁存；继续往后，命令、地址都发完了，要read数据了，所以释放nWE，ALE，这里tAR表示ALE释放多久后才可以发送nRE信号，tREA表示nRE信号的建立时间；</li>
<li>第三条竖线位置，发送了nCE,nRE信号，所以数据被锁存，第一个访问周期锁存的数据为marker code，值为0xEC，第二个访问周期的数据为device code，值为0xDA。读id时读5个周期含义对应如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/19.png"></li>
</ol>
<p>该款nandflash的5个周期读出来的值对应如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/20.png"></p>
<p>第四个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/21.png"></p>
<p>第五个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/22.png"></p>
<p>根据第4、5个访问周期的结果0x15、0x44我们得知该flash的block_size&#x3D;128K，page_size&#x3D;2k, 有2个plane，plane_size&#x3D;1Gb &#x3D; 128M, 共256M。</p>
<h2><span id="4-3-chu-shi-hua">4.3 初始化</span><a href="#4-3-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</span><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</span><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>nand控制器要按照我们nandflash的实际型号和性能来设置初始值。NFCONF寄存器，也叫nand配置寄存器：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/23.png"></p>
<p>以K9F2G08U0C这款nandflash为例：</p>
<p>前面<strong>第3.1.1小节</strong>分析了TACLS &#x3D; max(tCLS,tALS) - tWP，我们得知tCLS、tALS、tWP最小都可以取到12ns, 所以我们可以取TACLS&#x3D;0；</p>
<p>TWRPH0 &#x3D; tWP，我们的nand手册上要求tWP最少12ns, 那么取TWRPH0 &#x3D;1， Duration &#x3D; HCLK*(TWRPH0+1)&#x3D;20ns&gt;12ns，满足要求；</p>
<p>TWRPH0 &#x3D; max(tCLH,tALH), 我们的nand手册上要求tCLH、tALH最少5ns， 那么取TWRPH1 &#x3D;0， Duration &#x3D; HCLK*(TWRPH1+1)&#x3D;10ns&gt;5ns，满足要求。</p>
<p>再配置BusWidth总线位宽为8bit；<br>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line"><span class="comment">/*设置NAND FLASH的时序*/</span></span><br><span class="line">NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</span><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/24.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MODE [<span class="number">0</span>]: 设置为<span class="number">1</span>，使能NAND控制器。</span><br><span class="line">Reg_nCE [<span class="number">1</span>]: 设置为<span class="number">1</span>，禁止片选（等要使用的时候再使能片选信号）</span><br></pre></td></tr></table></figure>

<p>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使能NAND FLASH控制器，禁止片选*/</span></span><br><span class="line">NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="4-4-shi-bie-nandflash">4.4 识别nandflash</span><a href="#4-4-shi-bie-nandflash" class="header-anchor">#</a></h2><h3><span id="4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</span><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/26.png"></p>
<p>我们可以使用2440上的NAND FLASH控制器简化操作，只需要往NFCMMD寄存器写入要传输的命令就可以了，NAND FLASH控制器默认把上面复杂的时序发出来。</p>
<p>NFADDR-地址寄存器<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/27.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/28.png"></p>
<p>发命令后，后面就需要发送地址了，当nWE和ALE有效的时候，表示锁存的是地址，往NFADDR寄存器中写值就可以了，比如：NFADDR&#x3D;0x00。<br>我们得知地址需要用5个周期来发送，前2个周期为col地址，后三个周期为row(page)地址。前面<strong>第3小节</strong>已详细分析过了命令、地址、数据锁存时序过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> column: 列地址A0~A10，就是页内地址，地址范围是从<span class="number">0</span>到<span class="number">2047</span>。（A11用来确定oob的地址，即<span class="number">2048</span><span class="number">-2111</span>这<span class="number">64</span>个字节的范围）</span><br><span class="line"><span class="number">2.</span> page：A12～A30，称作页号，page(row)编号。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</span><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/29.png"></p>
<p>当命令、地址都发送完后就可以从数据总线上DATA[7:0]获取数据或者写入数据。同样往NFDATA寄存器中写值或者读值就可以了，如unsigned char buf&#x3D;NFDATA,由于是数据位宽是8位的，所以访问时数据组织形式如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/30.png"></p>
<p>从上图可以看出，当byte access时，只需一个时钟周期；当wold access的时候，需要4个时钟周期，小端模式下第一个时钟周期对应低字节，第四个时钟周期对应高字节。</p>
<p>识别nandflash代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化nand控制器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line">	NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_select</span><span class="params">(<span class="type">void</span>)</span> &#123;		</span><br><span class="line">	NFCONT &amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*禁止片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_deselect</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	NFCONT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发命令*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFCCMD = cmd;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发地址*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_addr_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFADDR = addr;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*读数据*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">nand_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>	NFDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*识别nandflash*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_chip_probe</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	nand_select(); </span><br><span class="line">	nand_cmd(<span class="number">0x90</span>);</span><br><span class="line">	nand_addr_byte(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">1</span>] = nand_data();	</span><br><span class="line">	buf[<span class="number">2</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">3</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">4</span>] = nand_data();	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maker   id  = 0x%x\n\r&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;device  id  = 0x%x\n\r&quot;</span>,buf[<span class="number">1</span>]);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">2</span>]);		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">3</span>]);			</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;page  size  = %d kb\n\r&quot;</span>,<span class="number">1</span>  &lt;&lt;  (buf[<span class="number">3</span>] &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;block size  = %d kb\n\r&quot;</span>,<span class="number">64</span> &lt;&lt; ((buf[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</span><a href="#5-nandflash-shu-ju-cao-zuo" class="header-anchor">#</a></h1><h2><span id="5-1-du-shu-ju">5.1 读数据</span><a href="#5-1-du-shu-ju" class="header-anchor">#</a></h2><p>读数据以page为单位的。下图的表格，来说明NAND FLASH内部结构，前面2K(0<del>2047)表示页数据，后边64字节(2048</del>2111)表示oob。</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/31.png"></p>
<p>CPU想读取，第2048个数据，它是哪以一个？</p>
<pre><code>是Page1的第0个字节。CPU使用某个地址访问数据的时候，是在页数据空间来寻址的。
</code></pre>
<p>下图为读NAND FLASH的read时序操作：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/32.png"></p>
<ol>
<li>首先需要锁存00命令，nCE、CLE、nWE有效，0x00命令被锁存；</li>
<li>此时CLE无效，ALE开始有效,地址被锁存（从NAND FLASH的地址周期中可以看出来，先发出2个周期的col列地址，再发出3个周期的Row行地址）；</li>
<li>锁存0x30命令；</li>
<li>然后会有一个busy时间段，R&#x2F;nB为低电平。tRR表示busy状态的持续时间（手册上最小为20ns）。</li>
<li>开始锁存数据，nRE使能，nand上的数据被同步到数据nand控制器上。我们的nand是8bit数据位宽，所以每隔一个read时钟周期（tRC），传输1byte数据。每传输1byte数据，地址会自动往后偏移1byte，一般我们会连续读取1page数据。</li>
</ol>
<p>下面开始写代码：</p>
<h3><span id="5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</span><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>当发完命令、地址后再进行读数据前我们知道有一段时间tRR处于busy状态，我们可以通过查询NFSTAT寄存器来确定busy状态有没有结束，是不是已经ready了。<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/33.png"></p>
<p>wait_ready函数等待NAND FLASH空闲，从上图可以看出当NFSTAT寄存器[0]的值为1时NAND FLASH是空闲的，我们可以通过该位来判断NAND FLASH是否繁忙。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	 <span class="keyword">while</span> (!(NFSTAT &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nand_read函数为NAND FLASH的读函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">		<span class="comment">/* 发出00h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">00</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出30h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">0x30</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 等待就绪 */</span></span><br><span class="line">		wait_ready();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 读数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)</span><br><span class="line">			buf[i++] = nand_data();			</span><br><span class="line">		</span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到每read一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h3><span id="5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</span><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong" class="header-anchor">#</a></h3><p>在init.c文件中，加上如下代码，用来判断所使用的FLASH是NOR FLASH还是NAND FLASH。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们知道nand启动0地址对应片内SRAM，可以像内存一样的写0地址；nor启动，0地址对应nor,nor不能像内存一样的写地址，</span></span><br><span class="line"><span class="comment">**所以往0地址写入数据成功表示nand启动，写不成功表示nor启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isBootFromNorFlash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = *p;</span><br><span class="line"></span><br><span class="line">	*p = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">		<span class="comment">/* 写成功, 对应nand启动 */</span></span><br><span class="line">		*p = val;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是代码重定位时可以自动区分nand和nor启动，无论是nand启动还是nor启动，都能将程序重定位到sdram中去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">            <span class="comment">/* 要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line"><span class="comment">            * 然后从0地址把数据复制到__code_start</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> len = (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__bss_start) - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__code_start);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (isBootFromNorFlash()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (dest &lt; end)</span><br><span class="line">                    *dest++ = *src++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    nand_init();</span><br><span class="line">    	    nand_read((<span class="type">unsigned</span> <span class="type">int</span>)src, dest, len);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-2-ca-shu-ju">5.2 擦数据</span><a href="#5-2-ca-shu-ju" class="header-anchor">#</a></h2><p>擦除数据以block为单位的。block erase时序图的过程大致如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/34.png"></p>
<pre><code>1.首先发送0x60命令
2.发送row地址（由于擦除是以block为单位的，所以无需知道页内地址，只需要知道要擦除哪个page、哪个block即可）
3.发送0xd0,执行擦除动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否擦除成功
</code></pre>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_erase</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">		<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (addr &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, addr is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (len &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, len is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_select(); </span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			page = addr / <span class="number">2048</span>;</span><br><span class="line">			</span><br><span class="line">			nand_cmd(<span class="number">0x60</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/* page addr */</span></span><br><span class="line">			nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0xD0</span>);</span><br><span class="line">	</span><br><span class="line">			wait_ready();</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">			<span class="keyword">if</span> (nand_data()&amp;<span class="number">0x1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, at addr:0x%x\n\r&quot;</span>, addr);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			len -= (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			addr += (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_deselect(); 	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-xie-shu-ju">5.3 写数据</span><a href="#5-3-xie-shu-ju" class="header-anchor">#</a></h2><p>写数据以page为单位。往NAND FLASH写数据时，只需要把要写的数据复制给NFDATA寄存器即可。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_w_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">	NFDATA = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>page write的写时序图如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/35.png"></p>
<pre><code>1.首先发送0x80命令
2.发送地址（5个周期）
3.发送数据
4.发送0x10命令，执行烧写动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否烧写成功
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		nand_cmd(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)  <span class="comment">//还需确认</span></span><br><span class="line">			nand_w_data(buf[i++]);</span><br><span class="line">		</span><br><span class="line">		nand_cmd(<span class="number">0x10</span>);</span><br><span class="line">		wait_ready();</span><br><span class="line">        </span><br><span class="line">		nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">		<span class="keyword">if</span> (nand_data() &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_write err, at page:0x%x, addr:0x%x\n\r&quot;</span>, page, page&lt;&lt;<span class="number">11</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 开始下一个循环page */</span></span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到每写一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h2><span id="5-4-ce-shi">5.4 测试</span><a href="#5-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nand_erase(addr, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	nand_read(addr, buf, <span class="number">64</span>);</span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 长度固定为64 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 先打印数值 */</span></span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">	nand_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：本节的读、写、擦都只涉及到页数据区，不涉及到oob区的操作。</strong></p>
<h2><span id="5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</span><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu" class="header-anchor">#</a></h2><p>Nand Flash怎么标记某一个BLOCK是坏的? 如何识别一个flash中的坏快？ </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它使用该BLOCK中第<span class="number">1</span>个扇区的OOB数据中某一个字节来标记: 其值为<span class="number">0xff</span>表示该BLOCK是好的， 其值为非<span class="number">0xff</span>表示该BLOCK是坏的。</span><br><span class="line">在uboot中直接输入“nand bad ”命令即可识别某一个块是否为坏快，在linux用户态的情况下，需要用ioctl(MEMGETBADBLOCK)来获取该block是否为坏快。</span><br><span class="line">有时候我们会误写这个OOB区的值导致有些BLOCK被误认为是<span class="string">&quot;坏块&quot;</span>,可以在u-boot中执行<span class="string">&quot;nand scrub&quot;</span>后, 根据提示信息输入小写字母<span class="string">&#x27;y&#x27;</span>并回车, 它会强制擦除整个Nand <span class="title function_">Flash</span><span class="params">(包括把OOB擦除为<span class="number">0xff</span>)</span>, 这样就可以恢复被误标为坏块的区域了。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/" data-id="clyylnk8p001q7wuffgot9egt" data-title="s3c2440裸机编程-nandflash" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-ADC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/" class="article-date">
  <time class="dt-published" datetime="2024-04-16T11:57:19.000Z" itemprop="datePublished">2024-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-adc-ying-jian-yuan-li">1 ADC硬件原理</a><ul>
<li><a href="#1-1-adc-shu-xing">1.1 ADC属性</a></li>
<li><a href="#1-2-adc-kuang-tu">1.2 ADC框图</a></li>
</ul>
</li>
<li><a href="#2-adc-ji-cun-qi">2 ADC寄存器</a><ul>
<li><a href="#2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</a></li>
<li><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</a></li>
<li><a href="#2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</a></li>
</ul>
</li>
<li><a href="#3-bian-cheng-ce-shi">3 编程测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-adc-ying-jian-yuan-li">1 ADC硬件原理</span><a href="#1-adc-ying-jian-yuan-li" class="header-anchor">#</a></h1><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p>
<p>如图，把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。以s3c2440为例：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/1.jpg"></p>
<h2><span id="1-1-adc-shu-xing">1.1  ADC属性</span><a href="#1-1-adc-shu-xing" class="header-anchor">#</a></h2><p>对于数字信号我们需要得到它的2个属性：</p>
<ol>
<li><p>转换精度：<br>用多少位来存储这个数据（假如是10 bit）。那么最大值0b111111111对应3.3v， 0b0对应0v。</p>
</li>
<li><p>采样&#x2F;转换速度：</p>
</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/2.png"><br>可以看出s3c2440的转换精度可达10 bit, 转换速率可达 500ksps.</p>
<h2><span id="1-2-adc-kuang-tu">1.2 ADC框图</span><a href="#1-2-adc-kuang-tu" class="header-anchor">#</a></h2><p>下图是s3c2440芯片的ADC转换框图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/3.png"></p>
<p>可以看出AD converter前有一个MUX选择器，用来选择模拟输入源，这里选择A[3:0]作为输入源。</p>
<p>下面是编写程序要做的步骤：</p>
<pre><code>1.确定是哪一路信号：设置8：1MUX
2.设置工作时钟
3.启动ADC
4.读状态，判断ADC转换是否成功。
5.读数据
</code></pre>
<h1><span id="2-adc-ji-cun-qi">2 ADC寄存器</span><a href="#2-adc-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</span><a href="#2-1-kong-zhi-ji-cun-qi-adccon" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/4.png"></p>
<pre><code>bit[15]：只读，用来表示转换是否完成
bit[14:6]:用来设置adc频率（如果是auto TSC则不用设置该位）
bit[5：3]:用来选择模拟输入源
bit[2]:用来设置是否待机
bit[0]:用来启动adc
</code></pre>
<h2><span id="2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</span><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/5.png"></p>
<h2><span id="2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</span><a href="#2-3-shu-ju-ji-cun-qi-adcdat0" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/6.png"></p>
<pre><code>bit[9:0]表示转换后的数据
</code></pre>
<h1><span id="3-bian-cheng-ce-shi">3 编程测试</span><a href="#3-bian-cheng-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/7.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//设置输入源AIN0, ADC时钟为1Mhz,并且使能预分频</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_read_ain0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		<span class="comment">/* 启动ADC */</span></span><br><span class="line">	ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!(ADCCON &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)));  <span class="comment">/* 等待ADC结束 */</span></span><br><span class="line">	<span class="keyword">return</span> ADCDAT0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/" data-id="clyylnk8o001b7wuf3f4555d3" data-title="s3c2440裸机编程-ADC" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机-异常中断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/" class="article-date">
  <time class="dt-published" datetime="2024-04-16T06:55:01.000Z" itemprop="datePublished">2024-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</a><ul>
<li><a href="#1-1-cpu-mo-shi">1.1 CPU模式</a></li>
<li><a href="#1-2-gong-zuo-state">1.2 工作State</a></li>
<li><a href="#1-3-arm-ji-cun-qi">1.3 ARM寄存器</a><ul>
<li><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</a></li>
<li><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</a></li>
</ul>
</li>
<li><a href="#1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</a></li>
</ul>
</li>
<li><a href="#2-yi-chang-chu-li-liu-cheng">2 异常处理流程</a><ul>
<li><a href="#2-1-zhong-duan-qian">2.1 中断前</a><ul>
<li><a href="#2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</a></li>
</ul>
</li>
<li><a href="#2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</a><ul>
<li><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</a></li>
</ul>
</li>
<li><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</a></li>
</ul>
</li>
<li><a href="#3-zhong-duan-shi-li">3 中断实例</a><ul>
<li><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</a><ul>
<li><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</a></li>
<li><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</a></li>
<li><a href="#3-1-3-shi-li-gai-jin">3.1.3 示例改进</a><ul>
<li><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</a></li>
<li><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</a></li>
<li><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-swi-ruan-zhong-duan">3.2 swi-软中断</a><ul>
<li><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</a><ul>
<li><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</a><ul>
<li><a href="#3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</a></li>
<li><a href="#3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</a><ul>
<li><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</a></li>
<li><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</a></li>
<li><a href="#3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</a></li>
<li><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</a><ul>
<li><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</a><ul>
<li><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</a><ul>
<li><a href="#3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</a></li>
<li><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</a><ul>
<li><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</a></li>
<li><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</a></li>
</ul>
</li>
<li><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</a><ul>
<li><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</a></li>
<li><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</a><ul>
<li><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</a></li>
<li><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</span><a href="#1-yi-chang-zhong-duan-yin-ru" class="header-anchor">#</a></h1><p>在arm架构的处理器中，cpu有7中工作模式，2中工作状态。</p>
<h2><span id="1-1-cpu-mo-shi">1.1 CPU模式</span><a href="#1-1-cpu-mo-shi" class="header-anchor">#</a></h2><pre><code>7种Mode: 除了usr/sys，其他5种都是异常模式。我们知道中断属于异常的2中，中断有irq,fiq。
</code></pre>
<table>
<thead>
<tr>
<th>usr</th>
<th>sys</th>
<th>undefined(und)</th>
<th>Supervisor(svc)</th>
<th>Abort(abt)</th>
<th>irq</th>
<th>fiq</th>
</tr>
</thead>
<tbody><tr>
<td>用户模式</td>
<td>系统模式</td>
<td>未定义指令异常模</td>
<td>svc管理模式</td>
<td>终止模式（1.指令预取终止(读写某条错误的指令导致终止运行)；2.数据访问终止(读写某个非法地址程序终止)）</td>
<td>irq中断</td>
<td>快中断</td>
</tr>
</tbody></table>
<p>除了usr模式，其他6中为特权模式。 CPU无法从usr模式直接进入特权模式。不能直接进入特权模式，那么<strong>怎么进入特权模式</strong>呢？</p>
<p>可以通过<strong>设置CPSR</strong>进入其他模式。</p>
<h2><span id="1-2-gong-zuo-state">1.2 工作State</span><a href="#1-2-gong-zuo-state" class="header-anchor">#</a></h2><pre><code>ARM state
Thumb state(几乎用不上)
</code></pre>
<h2><span id="1-3-arm-ji-cun-qi">1.3 ARM寄存器</span><a href="#1-3-arm-ji-cun-qi" class="header-anchor">#</a></h2><pre><code>(1)通用寄存器:
(2)备份寄存器(banked register):
    CPSR:当前程序状态寄存器(Current Program Status Register) 反映程序处在那种状态
    SPSR:CPSR的备份寄存器 (Saved Program Status Register)  用来保存&quot;被中断前的CPSR&quot;
</code></pre>
<p>下图是我们arm状态下的通用寄存器和程序状态寄存器<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/1.png"></p>
<p><strong>R13是SP（栈指针）</strong><br><strong>R14是LR</strong>（link register），程序跳转或者发成异常时的返回地址<br><strong>R15是PC</strong>（程序计数器）</p>
<p>假设cpu执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov R0, R8</span><br><span class="line">mov R0,R8_fiq</span><br></pre></td></tr></table></figure>

<p>在usr&#x2F;System 模式下访问的R8, 但是在FIQ模式下，访问R8是访问FIQ模式专属的R8寄存器，不是同一个物理上的寄存器。<br>在5种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈)， R14(LR)是用来保存发生异常时的指令地址。</p>
<p>为什么快中断(FIQ)有那么多专属寄存器?<br>这些寄存器称为备份寄存器，我们先看下<strong>中断处理流程</strong>：</p>
<pre><code>1 保存现场(保存被中断模式的寄存器)---(比如程序正在sys/usr模式下运行，当发生中断时，需要把R0-R14这些寄存器全部保存下来)
2 异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
3 恢复现场(恢复被中断时保存下来的寄存器R0-R14)
</code></pre>
<p>但如果是快中断，那么我就不需要保存系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，因为在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度，所以它才称得上快中断。</p>
<h3><span id="1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</span><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>在异常中断中PSR寄存器会使用的很频繁，PSR寄存器的格式如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/2.png"></p>
<p>我们再来看看下表，反映的是PSR的 M[4:0]与arm工作模式的关系：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/3.png"></p>
<p>我们可以按照上图的对应关系设置CPSR，让其进入与之对应的模式。</p>
<h3><span id="1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</span><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h2><span id="1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</span><a href="#1-4-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p><strong>异常向量</strong>：不同的异常有不同的入口函数，那么这个异常入口函数的地址就是存放在该异常向量的位置。从该异常向量读取到的数据就是异常入口函数的地址。<br><strong>异常向量表</strong>：就是由异常向量组成的集合。</p>
<p>下图是从uboot源代码中截取的smdk2410 的异常向量表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:	b       reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>异常向量表对应的地址如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/4.png"></p>
<h1><span id="2-yi-chang-chu-li-liu-cheng">2 异常处理流程</span><a href="#2-yi-chang-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>CPU是如何进入到中断模式，执行中断服务程序的？</p>
<h2><span id="2-1-zhong-duan-qian">2.1 中断前</span><a href="#2-1-zhong-duan-qian" class="header-anchor">#</a></h2><p>下图是中断未触发前的程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/5.png"></p>
<h3><span id="2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</span><a href="#2-1-1-chu-shi-hua-zhong-duan" class="header-anchor">#</a></h3><pre><code>1，设置中断源（使中断能够产生，让CPU知道是哪个中断）
2，设置中断控制器（设置中断屏蔽，中断优先级）
3，设置中断总开关CPSR (使能中断)
</code></pre>
<h2><span id="2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</span><a href="#2-2-zhong-duan-chan-sheng-hou" class="header-anchor">#</a></h2><p>举个栗子：按键按下，产生按键irq。</p>
<h3><span id="2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</span><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h3><p>cpu强制跳转到异常向量表上对应的_irq异常向量（0x18）去读取指令（这个是CPU强制执行的，不需要我们去控制）。</p>
<p>具体的进入中断向量和中断返回流程见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/6.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进入：</span><br><span class="line">	 (<span class="number">1</span>) LR_异常=PC + offset（具体多少看下图）</span><br><span class="line">	（<span class="number">2</span>）SPSR_异常=被中断前的程序模式CPSR</span><br><span class="line">	 (<span class="number">3</span>) CPSR被设置成对应的异常模式</span><br><span class="line">	（<span class="number">4</span>）跳转到对应的异常向量去执行</span><br><span class="line">退出（返回）：进入和退出就是一个逆过程</span><br><span class="line">	（<span class="number">1</span>）PC= LR_异常 -offset</span><br><span class="line">	（<span class="number">2</span>）被中断前的程序模式CPSR = SPSR_异常</span><br><span class="line">	（<span class="number">3</span>）中断结束，清中断</span><br></pre></td></tr></table></figure>

<p>进入异常和返回异常时pc和lr的关系如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/7.png"></p>
<p>从图中我们发现进入不同异常，offset的值也是有差异的。</p>
<h2><span id="2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</span><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h2><pre><code>1.当跳转到irq异常向量(0x18)后，发现该处是一条跳转指令“ldr pc, _irq”,
那么会通过ldr绝对跳转指令跳到到真正的中断处理函数_irq去执行。
2.那么在_irq的函数中我们需要按照之前说的**中断处理流程**去执行：
    （1）保存现场
    （2）异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
    （3）恢复现场
</code></pre>
<p>流程图总结下中断产生后的详细处理过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/8.png"></p>
<h1><span id="3-zhong-duan-shi-li">3 中断实例</span><a href="#3-zhong-duan-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</span><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang" class="header-anchor">#</a></h2><p>先来看下当cpu解析到什么样的指令才会触发未定义指令异常呢？</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/9.png"></p>
<p>从上面的arm指令格式中可知，只要指令码属于划线的格式，就属于未定义指令异常。</p>
<h3><span id="3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</span><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can" class="header-anchor">#</a></h3><p>我们知道汇编给C语言函数传参是通过r0，r1，…通过堆栈的方式去传递的参数，比如r0&#x3D;1, r1&#x3D;2;那么在被调用的c函数中argv0就是r0, argv1就是r1…,那么我们如果通过汇编给C函数传递字符串呢？</p>
<p>声明und_string为一个字符串:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>ldr r1, =und_string</code>，这样r1中就保存了und_string的地址。<br>这样调用我们的c函数就可以把und_string传入进去。</p>
<h3><span id="3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</span><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	sdram</span></span><br><span class="line"><span class="comment">	设置SP</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">	...</span><br><span class="line">	bl print1</span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>; <span class="comment">/*定义一条未定义指令*/</span></span><br><span class="line">	<span class="comment">/*故意以一个数据的方式引入一条未定义指令，当cpu执行到这里，读取0xdeadc0de指令码的时候，</span></span><br><span class="line"><span class="comment">	发现无法识别这条指令，就发生未定义指令异常，就跳转到0x4的中断向量去执行*/</span></span><br><span class="line">	</span><br><span class="line">	bl print2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>


<p>在未定义指令异常前后加上打印print1, print2，<strong>如果出现未定义指令异常后，就会跳到0x4的地方去读取指令，print2也就没法执行</strong>。</p>
<p>当跳转到0x4的中断向量后，发现此处是一条跳转指令<code>bl do_und</code>, 我们再到未定义指令异常的服务程序do_und中打印出und_string这个字符串的内容。<br>现在开始写指令异常的服务程序do_und，实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>

<p>下面来分析一下这个未定义指令异常服务程序:</p>
<ol>
<li><p>进入未定义指令异常服务do_und之前硬件自动完成的事情如下：</p>
<ol>
<li>lr_und保存有被中断模式中的下一条即将执行的指令的地址</li>
<li>SPSR_und保存有被中断模式的CPSR</li>
<li>CPSR中的M4-M0被设置为11011, 进入到und模式</li>
<li>跳到0x4的地方执行程序 （bl do_und）</li>
</ol>
</li>
<li><p>进入指令异常服务程序do_und后，我们需要保存现场，处理und异常,恢复现场，<strong>注意：由于发生了cpu模式切换，如果要用到栈，那么先要设置对应模式的栈。</strong>由于栈的地址是向下生长的，这里我就用sdram的末位地址作为栈指针，把sp_und&#x3D;0x34000000。</p>
</li>
<li><p>在und异常服务程序中有可能会用到栈, 所以先保存现场，通过<code>stmdb sp!, &#123;r0-r12, lr&#125;</code>语句把栈中的值备份到r0-r12和lr，然后恢复现场的时候通过<code>ldmia sp!, &#123;r0-r12, pc&#125;^</code>，详见上面的注释。</p>
</li>
<li><p>我们看到保存现场后，我们把cpsr的值放到r0, 把und_string放到r1, 然后用bl printException调用c函数，这样我们的c函数printException就能收到汇编传过来的参数，一个是cpsr模式（r0），一个是und_string汇编传过来的字符串(r1)。我们用C函数实现printException：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printException</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpsr, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Exception! cpsr = &quot;</span>);</span><br><span class="line">	printHex(cpsr);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line"></span><br><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_und保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为11011, 进入到und模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x4的地方执行程序 （bl do_und）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">	<span class="comment">/* sdram */</span>	</span><br><span class="line">	bl copy2sdram</span><br><span class="line">	bl clean_bss</span><br><span class="line"></span><br><span class="line">	bl uart0_init</span><br><span class="line"></span><br><span class="line">	bl print1</span><br><span class="line">	<span class="comment">/* 故意加入一条未定义指令 */</span></span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>  <span class="comment">/* 未定义指令 */</span></span><br><span class="line">	bl print2</span><br><span class="line"></span><br><span class="line">	<span class="comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong>如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/10.png"></p>
<p>打印出print1中的字符串‘abc’后，紧接着打印printException函数中的结果，cpsr&#x3D;0x600000db,那么对应的M[4:0]&#x3D;11011， 对应下图为und模式。然后从und异常返回，恢复原来的模式继续执行。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/11.png"></p>
<h3><span id="3-1-3-shi-li-gai-jin">3.1.3 示例改进</span><a href="#3-1-3-shi-li-gai-jin" class="header-anchor">#</a></h3><h4><span id="3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</span><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi" class="header-anchor">#</a></h4><p>我们将上面的代码的und_string字符串修改一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编译烧录再次运行，发现没有任何打印输出，这是为什么呢？我明明只是把und_string字符串改了一下呀。</p>
<p>查看反汇编：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/12.png"></p>
<p>我们发现reset的地址是0x30000032，竟然不是4字节对齐的，我们知道arm指令集是以4字节为基本单位的，那么这里没有对齐，肯定无法解析指令。那么我们手工改进代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br></pre></td></tr></table></figure>

<font color="red" size="2.5">
.align 4
</font>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/13.png"></p>
<p>我们再来看看反汇编，发现reset的地址是30000040，是以4字节对齐的，再次烧录运行，发现能够正常输出print1, 能够进入未定义指令异常。</p>
<h4><span id="3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</span><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang" class="header-anchor">#</a></h4><p>如果我们程序非常大，中断向量入口代码的地址可能会大于sram的容量4k，比如do_und和do_swi，那么这个时候就需要用绝对跳转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">    b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br></pre></td></tr></table></figure>

<p>将上面的相对跳转换成如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">	ldr pc, und_addr </span><br><span class="line">    ldr pc, swi_addr</span><br><span class="line">    ...</span><br><span class="line">    ... </span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">    .word do_swi</span><br></pre></td></tr></table></figure>

<p>这样我们的do_und， do_swi就可放在4k之外的地方, 放到sdram。</p>
<h4><span id="3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</span><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing" class="header-anchor">#</a></h4><p>我们现在不断增加的程序代码量，那么有可能在 <code>ldr pc, =main</code> 这条指令执行之前程序就已经超过4k。那么我们当从nand启动的时候，还没执行到ldr pc, &#x3D;main这句来，就无法取指令执行了。nor同理超过2M也就无法取指令执行了。 所以我们干脆重定位完代码后就直接跳转到sdram上去执行,代码简要概述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">ldr pc, =sdram</span><br><span class="line">sdram：</span><br><span class="line">   ...</span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<p>我们再来分析下整个程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/14.jpg"></p>
<pre><code>1.一上电，cpu从0地址执行，执行b reset（进行初始化硬件）
2.重定位程序
3.跳转到sdram去继续执行
4.执行到 deadc0de,发生未定义指令异常
5.跳转到异常向量表的0x4地址去执行
6.跳转到sdram上执行异常处理函数（do_und）
7.异常返回，继续执行
</code></pre>
<h2><span id="3-2-swi-ruan-zhong-duan">3.2 swi-软中断</span><a href="#3-2-swi-ruan-zhong-duan" class="header-anchor">#</a></h2><p>arm有7中工作模式，除了usr模式，其他6种都是特权模式。</p>
<p>我们知道usr模式无法修改CPSR直接进入其他特权模式，但linux应用程序一般运行在usr模式，既然usr模式权限非常低，是无法直接访问硬件寄存器的，那么它是如何访问硬件的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linux应用程序是通过系统调用，从而进入内核态，运行驱动程序来访问的硬件，那么系统调用又是如何实现的呢，就是通过软中断swi指令来进入svc模式，进入到svc模式后当然就能访问硬件啦。</span><br></pre></td></tr></table></figure>

<p>所以我们的应用程序在usr模式想访问硬件，必须切换模式:</p>
<p>有以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 发生异常或中断(被动的)</span><br><span class="line"><span class="number">2.</span> swi + 某个值(主动的)</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</span><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi" class="header-anchor">#</a></h3><p>s3c2440 一上电会跳到0地址（reset复位）执行代码，此时CPU处于svc模式，2440异常向量表如下图所示:<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/15.png"></p>
<p>为了验证usr模式能够主动的通过swi软中断指令来进入svc模式, 我们先将模式切换到usr模式，那么这个时候就不能访问硬件了，也不能直接修改cpsr直接进入其他模式。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/16.png"></p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/17.png"></p>
<p>从上图我们设置CPSR让M4-M0处在10000，这样就进入了usr模式。修改start.s如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>那么当执行到swi 0x123，就会触发SWI异常, 进入0x8的向量去执行，调用do_swi，我们参考do_und实现我们的软中断服务程序do_swi。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理swi异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">		b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>do_swi中调用printException，打印出了软中断异常的字符串和CPSR对应的svc模式。</p>
<h4><span id="3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</span><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao" class="header-anchor">#</a></h4><p>我们要读出swi 0x123指令，我们知道当执行完swi 0x123指令以后，会发生swi异常，那么lr_svc &#x3D; PC + offset。从下图看出offset是4：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/18.png"></p>
<p>修改中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;</span><br></pre></td></tr></table></figure>

<p>我们要把lr拿出来保存,因为bl printException会破坏lr，那么把lr保存在哪个个寄存器比较好呢？</p>
<p>我们知道当调用<code>bl printException</code>可能会修改某些寄存器，但是又会恢复这些寄存器，那么得知道它会保护哪些些寄存器。<br>来看下ATPCS规则：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/19.png" alt="img"></p>
<p>在子程序中,使用R4~R11来保存局部变量,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值。所以对于 r4 ~ r11在C函数里会保存这几个寄存器，执行完C函数再把它释放掉并且恢复原来的值。我们把lr 保存在r4寄存器里，r4寄存器不会被C语言破坏。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov r4, lr</span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string</span><br><span class="line">bl printException</span><br></pre></td></tr></table></figure>

<p>当执行完<code>swi 0x123</code>指令后，会发生swi异常，swi异常模式里的lr寄存器会保存下一条指令的地址（即’ldr pc, &#x3D;main’），我们把lr寄存器的地址减去4就是<code>swi 0x123</code>这条指令的地址。</p>
<p>把r4的寄存器赋给r0让后打印我们得写出打印函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    mov r0, r4</span><br><span class="line"></span><br><span class="line">    sub r0, r4, #<span class="number">4</span>	<span class="comment">//得到swi指令的地址</span></span><br><span class="line">    bl printSWIVal</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>在uart.c添加printSWIVal打印函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printSWIVal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSWI)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SWI val = &quot;</span>);</span><br><span class="line">	printHEx(*pSWI &amp; ~<span class="number">0xff000000</span>); <span class="comment">//高8位忽略掉  </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</span><a href="#3-3-irq-wai-bu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</span><a href="#3-3-1-yin-ru-wai-bu-zhong-duan" class="header-anchor">#</a></h3><p>我们想实现一个按键点灯程序，我们知道有以下两种方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>轮询方案:轮询检测按键的电平状态，当检测到被按下后，对应的gpio会拉低，点亮对应的led;(略)</span><br><span class="line"><span class="number">2.</span>中断方案:将按键配置成外部中断源，当有按键按下，触发中断，在中断服务程序（isr）中去完成点灯。</span><br></pre></td></tr></table></figure>

<p>我们用按键作为外部中断源，我们把按键对应的gpio配置成中断引脚，当按键按下，相应的gpio产生了电平跳变，就会触发外部中断。</p>
<h3><span id="3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</span><a href="#3-3-2-wai-bu-zhong-duan-shi-li" class="header-anchor">#</a></h3><p>我们想达到按下按键灯亮, 松开按键灯灭这种效果（配成双边沿触发，按下的时候产生下降沿中断，进行点亮，松开产生上升沿中断，进行熄灭）。当然也可做成按一下点亮，再按一下熄灭的效果（设成单边沿触发，每来一次中断，对led电平进行一次取反）。<br>原理图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/20.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/21.png"></p>
<p>从按键的原理图中得知，当按键没有按下时，接上拉电阻，按键为高电平状态。当按键按下时，电位被拉低，按键处于低电平状态。s2-s5分别对应GPF0，GPF2，GPG3，GPG11; D10-D12这3盏led所对应的gpio分别是GPF4，GPF5，GPF6。</p>
<p>那么我们让s2,s3,s4分别控制D10,D11,D12；s5对D10-D12同时控制（按下s5同时点亮3个led）。</p>
<h4><span id="3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</span><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan" class="header-anchor">#</a></h4><p>配置D10-D12的gpio为输出模式，s2-s4的gpio为外部中断模式。</p>
<p>打开芯片手册找到第九章 IO ports，找到对应的gpio控制寄存器，将对应的gpio配置成中断模式。</p>
<ol>
<li>配置GPF GPIO为中断引脚：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/22.png"><br>同理GPG的寄存器类似。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">4</span>));	<span class="comment">//先把eint0和eint2这两个引脚清零</span></span><br><span class="line">GPFCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">4</span>));   <span class="comment">//S2,S3被配置为中断引脚</span></span><br><span class="line"></span><br><span class="line">GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">22</span>));</span><br><span class="line">GPGCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">22</span>));   <span class="comment">//S4,S5被配置为中断引脚</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置中断触发方式:</li>
</ol>
<p>当电平从高变低时，此时表示按键按下，当电平由低变高，表示松开按键。不妨设置中断方式为双边沿触发，按下按键，触发下降沿中断，中断服务程序就可以去点亮led，反之，松开触发上升沿中断，就可以去熄灭led。<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/23.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/24.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTINT0 |= (<span class="number">7</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">7</span>&lt;&lt;<span class="number">8</span>);     <span class="comment">/* S2,S3 */</span></span><br><span class="line">EXTINT1 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S4 */</span></span><br><span class="line">EXTINT2 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S5 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置外部中断屏蔽寄存器EINTMASK：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/26.png"></li>
</ol>
<p>从上图我们知道外部中断0-3是直接连接到中断控制器，而外部中断4-7、外部中断8-23还要经过EINTMASK,那么我们需要配置EINTMASK来打开中断的通道：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/27.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EINTMASK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">19</span>));    <span class="comment">//打开外部中断通道</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>外部中断挂起寄存器EINTPEND:</li>
</ol>
<p>当一个外部中断（EINT4-EINT23）发生后，那么相应的位会被置1, 所以中断结束后需要清除对应位。这个寄存器可以用来区分外部中断4-23的哪一个中断源。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/28.png"></p>
<h4><span id="3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</span><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi" class="header-anchor">#</a></h4><p>我们先来看下中断控制器的总框图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/29.png"></p>
<p><strong>1. 首先是SRCPND:用来表示哪个中断源发出了中断请求。</strong></p>
<p>先看下中断源:<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/30.png"></p>
<p>从上图我们发现外部中断有24个外部中断，除了外部中断EINT，还有定时器中断，ADC中断，UART中断等…。</p>
<p>我们来认识下SRCPND寄存器：（用来表示哪个（哪些）中断源已产生中断请求，中断结束后要清中断）<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/31.png"></p>
<p>从上图中我们发现EINT4-7共用1bit，EINT8-23共用1bit，那么肯定有其他寄存器来区分它们，那就是EINTPEND寄存器（后面5会讲）。</p>
<p><strong>2. 然后到达INTMSK：（中断屏蔽寄存器）</strong></p>
<p>我们需要把INTMSK寄存器配置成非屏蔽状态，默认是中断源时屏蔽的，见下图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/32.png"></p>
<p><strong>3.INTMOD（中断模式，是fiq还是irq）</strong><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/33.png"></p>
<p><strong>4.Priroty:</strong></p>
<p><strong>5.INTPND:</strong><br>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p>中断发生后，SRCPND中会有bit置1，可能好几个（因为同时可能发生几个中断），这些中断会由优先级仲裁器选出一个最紧迫的，然后把INTPND中相应位置1。所以只有INTPND置1，CPU才会处理。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/34.png"></p>
<p>我们知道有可能同时出现多个中断请求，那么INTPND就挑选出当前优先级最高的、正在发生的中断。</p>
<p>当产生irq后，要去分辨是哪个中断源，根据不同的中断源去中断服务程序isr中做不同的事情，那么如何得知当前产生的中断是哪一个外部中断源产生的呢？那么就可以访问这个INTPND寄存器。</p>
<p>可是我们要去手工去解析INTPND里面的位，才能知道是哪个中断源产生了中断请求。那么有没有什么比较快捷的方式自动帮我们解析INTPND呢，直接返回中断号给我们？</p>
<p>当然有啦，有一个INTOFFSET寄存器的值就是代表哪个中断请求产生了，如果INTOFFSET&#x3D;0表示EINT0产生了中断请求，INTOFFSET&#x3D;2表示EINT2产生了中断请求。具体见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/35.png"></p>
<p>我们从上图看到ENIT4-7共用一个offset， EINT8-23也共用一个offset，那么要通过访问EINTPEND寄存器来区分它们。</p>
<p>中断控制器设置代码入下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化中断控制器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19</span></span><br><span class="line">    INTMSK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)); </span><br><span class="line">    <span class="comment">//INTMOD默认是irq，可以不设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</span><a href="#3-3-3-3-zhong-duan-zong-kai-guan" class="header-anchor">#</a></h4><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/36.png"></p>
<p>CPSR有I位，是irq的总开关，我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把bit7这一位清零 */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</span><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>到这里中断前的初始化工作知识点就已经讲完了，当然要提前准备好led初始化工作（就是将led对应的gpio配置成输出模式，这个不讲解）。</p>
<p>那么中断产生后，我们之前讲过，会跳转到0x18异常向量，执行跳转指令<code>ldr pc, =_irq</code>，和之前的swi异常，und异常框架一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	ldr pc, und_addr <span class="comment">/* vector 4 : und（绝对跳转） */</span></span><br><span class="line">	ldr pc, swi_addr <span class="comment">/* vector 8 : swi */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x0c : prefetch aboot */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x10 : data abort */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x14 : reserved */</span></span><br><span class="line">	ldr pc, irq_addr <span class="comment">/* vector 0x18 : irq */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x1c : fiq */</span></span><br><span class="line"></span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">	.word do_swi</span><br><span class="line">irq_addr:</span><br><span class="line">	.word do_irq</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/*初始化时钟*/</span></span><br><span class="line">	<span class="comment">/*初始化sdram,设置栈*/</span></span><br><span class="line">	<span class="comment">/*代码重定位,清bss*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把bit7这一位清零(打开中断总开关) */</span></span><br><span class="line">	bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">	msr cpsr, r0</span><br><span class="line"></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>1.我们在start.s中用汇编代码设置cpsr的I位，开启中断开关；</p>
<p>2.在main函数中初始化中断源key_eint_init，初始化中断控制器interrupt_init；</p>
<p>3.然后继续执行main主函数。</p>
<p>4.当中断产生，触发irq异常，进入0x18异常向量，执行do_irq。</p>
<p>do_irq实现如下（和do_und, do_swi类似）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">do_irq:</span><br><span class="line">	<span class="comment">/* 执行到这里之前: */</span></span><br><span class="line">	<span class="comment">/* 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址 */</span></span><br><span class="line">	<span class="comment">/* 2. SPSR_irq保存有被中断模式的CPSR */</span></span><br><span class="line">	<span class="comment">/* 3. CPSR中的M4-M0被设置为10010, 进入到irq模式 */</span></span><br><span class="line">	<span class="comment">/* 4. 跳到0x18的地方执行程序 */</span> </span><br><span class="line">	<span class="comment">/* sp_irq未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33d00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	sub lr, lr, #<span class="number">4</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">		</span><br><span class="line">	<span class="comment">/* 处理irq异常 */</span></span><br><span class="line">	bl handle_irq_c</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>


<p>handle_irq_c函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_eint_irq</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = EINTPEND;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val1 = GPFDAT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val2 = GPGDAT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (irq == <span class="number">0</span>) <span class="comment">/* eint0 : s2 控制 D12 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) <span class="comment">/* s2 --&gt; gpf6 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">2</span>) <span class="comment">/* eint2 : s3 控制 D11 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) <span class="comment">/* s3 --&gt; gpf5 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">5</span>) <span class="comment">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) <span class="comment">/* eint11 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) <span class="comment">/* s4 --&gt; gpf4 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下 */</span></span><br><span class="line">				GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">19</span>)) <span class="comment">/* eint19 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				<span class="comment">/* 熄灭所有LED */</span></span><br><span class="line">				GPFDAT |= ((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下: 点亮所有LED */</span></span><br><span class="line">				GPFDAT &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EINTPEND = val; 	<span class="comment">/* 清中断 : 源头*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*INTOFFSET中哪一位被设置成1，就表示哪一个 中断源*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);<span class="comment">/*清EINT0，EINT2，EINT5*/</span></span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</span><a href="#3-4-irq-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</span><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi" class="header-anchor">#</a></h3><p>s3c2440共有2种定时器：</p>
<pre><code>1.Watchdog看门狗定时器
2.PWM脉冲可调制定时器
</code></pre>
<p>下面详细介绍2种定时器的原理，来了解定时器是如何产生定时器中断的。</p>
<h4><span id="3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</span><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>Watchdog定时器的原理很简单，寄存器很少，框图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/37.png"></p>
<ol>
<li>定时器，定时器那肯定是需要用到时钟的，从框图中可以看到Watchdog定时器采用的时钟源是PCLK，从<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中也可以体现出来，接的是APB总线。</li>
<li>然后到达一个8 bit的分频器，可以通过配置WTCON[15:8]来设置分频器的预设值。</li>
<li>再设置WTCON[4:3]来设置除数因子来进一步分频。<br>所以最终的Watchdog定时器的时钟周期<code>t_watchdog = 1/[ PCLK / (Prescaler value + 1) / Division_factor ]</code></li>
<li>到达WTCNT：看门狗递减寄存器。WTCNT里的数据就开始在输入时钟频率下递减。WTCNT的值由WTDAT寄存器提供。</li>
<li>WTDAT：WTDAT寄存器用于指定计数器的初始值，也就是它的超时时间，<strong>系统上电之后硬件自动的将0x8000的初始值载入到WTCNT里，在发生了第一次超时操作时，WTDAT的值才会载入到WTCNT寄存器</strong>。</li>
</ol>
<p>当WTCNT的值减到0时，就会触发看门狗定时器中断，进而产生复位。中断框图中可以看到可以设置WTCON[2]来设置是否产生中断信号，可以设置WTCON[0]来设置是否产生复位信号。</p>
<h5><span id="3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</span><a href="#3-4-1-1-1-wtcon-ji-cun-qi" class="header-anchor">#</a></h5><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/38.png"></p>
<h5><span id="3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</span><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi" class="header-anchor">#</a></h5><p> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/39.png"></p>
<h3><span id="3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</span><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li" class="header-anchor">#</a></h3><h4><span id="3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</span><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>在之前的章节中，我们在start.s启动代码中首先做的就是关闭看门狗，把WTCON[5]&#x3D;0，也就是把Watchdog timer给disable。那么Watchdog Timer就不再工作了，这样做是为了防止在启动代码进行硬件初始化的时候出现超时，发出复位信号又去重启硬件，这样就陷入了不断重启过程中。因为s3c2440芯片默认WTCON[5]是1，也就是Watchdog Timer默认是处于使能状态。</p>
<p>从<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中配置了PCLK&#x3D;50M Hz, 那么让WTDAT取默认值0x8000，那么根据公式算出从开机到触发复位重启的时间：</p>
<p><code>t=WTDAT*( 1/[ PCLK / (Prescaler value + 1) / Division_factor ])</code>。</p>
<p>根据WTCON寄存器配置Prescaler value&#x3D;255，配置Division_factor&#x3D;128，这样最终定时器分得的频率更低，那么减数器递减的更慢，也就代表从开机到触发复位重启的时间:</p>
<p><code>T=0x8000 * (1/[50*10^6/(255+1)/128]) = 21474836.48us = 21s</code>。</p>
<p>之前的start.s中把看门狗已经关闭了，那么我们在跳转到main函数中调用wtd_timer_init函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//使能定时器，开启reset复位</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看测试结果：<br>果然初始化wtd_timer_init后，过21s后板子重启了，说明我们watchdog定时器功能已经OK了。</p>
<p>现在修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//使能定时器，开启watchdog定时器中断</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">	WTDAT = <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到我们现在定时器的初值被修改成了0x4000, 相对于默认值少了一半，那么触发wtd_timer中断的时间应该减半，也就是约等于10s。</p>
<h4><span id="3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</span><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>那么需要写一个wtd_timer的中断服务程序，同样需要先在do_irq中去保护现场、调用handle_irq_c、恢复现场。查看INTOFFSET寄存器：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/40.png"></p>
<p>得知：<br>handle_irq_c代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        这里还需区分子中断源</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看芯片手册查找“INT_WDT_AC97”如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/41.png"></p>
<p>从上图可以看到SRCPND和SUBSRCPND的映射关系。<br>SUBSRCPND寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/42.png"></p>
<p>我们可以读取SUBSRCPND来区分到底是哪一个子中断源产生了中断，当SUBSRCPND中哪一位被置1，表示对应的中断源发生了中断。</p>
<p>前面做完wtd_timer_init，还要进行中断控制器的初始化，查看INTMSK寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/43.png"></p>
<p>查看INTSUBMSK寄存器如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/44.png"></p>
<p>在interrupt_init中添加：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//不屏蔽INT_WDT_AC97</span></span><br><span class="line">INTSUBMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//不屏蔽INT_AC97</span></span><br></pre></td></tr></table></figure>

<p>修改handle_irq_c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">9</span>)<span class="comment">//INTOFFSET==9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SUBSRCPND &amp; <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;watchdog timer interrupt occured.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</span><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi" class="header-anchor">#</a></h3><p>PWM（Pulse Width Modulation），字面上是脉冲可调制的意思，就是可以调节占空比。</p>
<p>s3c2440有5个定时器，其中定时器0、1、2和3具有脉宽调制（PWM）功能。定时器4是一个无输出引脚的内部定时器。</p>
<p>先认识下s3c2440的pwm timer的框架：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/45.jpg"></p>
<pre><code>1.时钟源为PCLK
2.pclk经过8 bit的预分频系数（Prescaler），和4 bit的时钟除数因子（clock divider）,进行分频
3.经过MUX选择器选择用哪个定时器（5选1）
4.设置TCMPB0和TCNTB0和TCONn寄存器
</code></pre>
<h4><span id="3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</span><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>pwm定时器的逻辑控制单元结构如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/46.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> TCMPBn和TCNTBn寄存器中的值分别加载到TCMPn和TCNTn寄存器</span><br><span class="line"><span class="number">2</span> 每来一个clk(时钟)这个TCNTn减去<span class="number">1</span></span><br><span class="line"><span class="number">3</span> 当TCNTn == TCMPn时，可以产生中断，pwm输出引脚反转</span><br><span class="line"><span class="number">4</span> TCNTn继续减<span class="number">1</span>，当TCNTn == <span class="number">0</span>时，又产生一次中断，pwm引脚再次反转</span><br><span class="line"><span class="number">5</span> 重复<span class="number">1</span><span class="number">-4</span>过程</span><br></pre></td></tr></table></figure>

<p>设置TCNTBn寄存器来设置加载初值，设置后TCNTn中的值就会按照时钟周期递减。<br>设置TCMPBn寄存器来设置占空比，从而控制高低电平持续时间的比例。</p>
<h4><span id="3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</span><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian" class="header-anchor">#</a></h4><p>要开始一个PWM定时器功能的步骤如下：(假设使用的是timer0)</p>
<h5><span id="3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</span><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi" class="header-anchor">#</a></h5><p>定义一个pwm_timer_init()函数。</p>
<ol>
<li><p>设置时钟：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/47.png"><br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/48.png"></p>
<p> 分别设置定时器0的预分频器值(prescaler)和时钟分频值(clock divider)，从而控制TCNT0减数器的频率。</p>
</li>
</ol>
<p>根据公式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwm Timer clk = PCLK / &#123;(预分频数)prescaler value+<span class="number">1</span>&#125; / &#123;divider value(<span class="number">5.1</span>MUX值)&#125; </span><br></pre></td></tr></table></figure>
<p>PCLK是50M，设置prescaler value&#x3D;99， divider value&#x3D;16,所以pwm Timer clk&#x3D; 50000000&#x2F;(99+1)&#x2F;16 &#x3D; 31250 Hz</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TCFG0 = <span class="number">99</span>; </span><br><span class="line">TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">TCFG1 |= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置初值：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置比较缓存寄存器TCMPB0和计数缓存寄存器TCNTB0的初始值*/</span></span><br><span class="line">TCNTB0 = <span class="number">31250</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">/* 2s中断一次 */</span></span><br><span class="line">TCMPB0 = <span class="number">31250</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* 设置占空比*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>开启定时器0的手动更新TCNTB0&amp;TCMPB0功能(设置TCON的第1位)：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/49.png"></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开始需要手工更新,这样才能将TCNTB0&amp;TCMPB0同步到TCNT0&amp;TCMP0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启定时器0的自动加载：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开启自动加载要先清除手动更新</span></span><br><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动定时器0(设置TCON的第0位)；</li>
</ol>
<p>	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>初始化中断控制器:</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/50.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interrupt_init()&#123;</span><br><span class="line">	...</span><br><span class="line">	INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* enable timer0 int */</span>		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完这些初始化工作，就可以产生定时器中断了,同样我们需要在handle_irq_c函数中区分中断源：</p>
<h5><span id="3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</span><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h5><p>我们可以通过查看TCNTO0寄存器来查看当前TCNT的值。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/52.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>) <span class="comment">//INT_WDT_AC97</span></span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">10</span>) <span class="comment">//timer0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timer0 interrupt occured.\n&quot;</span>);</span><br><span class="line">		print_hex(TCNTO0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</span><a href="#3-5-irq-de-you-hua-gai-jin" class="header-anchor">#</a></h2><p>我们对比irq外部中断， irq定时器中断，发现每增加一个中断源，又要去修改中断控制器的初始化interrupt_init()和handle_irq_c(),要在handle_irq_c()中去添加分支去执行不同的中断服务。</p>
<p>那么我们现在不去改变interrupt文件，在timer.c、key_eint.c中去注册自己的中断服务程序即可，这里我们使用<strong>函数指针数组</strong>，建立一个中断号和中断服务程序的映射关系。这样就可以根据中断号来执行对应的中断服务程序，即在handle_irq_c()中去回调不同类型的中断源注册下来的函数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义函数指针数组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUM	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*irq_func)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">irq_func irq_array[IRQ_NUM];</span><br></pre></td></tr></table></figure>

<p>然后实现一个register_irq(…)如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_irq</span> <span class="params">(<span class="type">int</span> irq, irq_func fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_array[irq] = fp;</span><br><span class="line">	INTMASK &amp;= ~(<span class="number">1</span> &lt;&lt; irq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_irq_c()修改实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	irq_array[bit](bit); <span class="comment">//根据中断号回调不同的中断处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 清中断 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们的irq中断就被统一管理了起来，只要在其他各中断模块初始化的时候调用register_irq(…)注册即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/" data-id="clyylnk8p001l7wufhuyy0u3n" data-title="s3c2440裸机-异常中断" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-代码重定位和清bss" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/" class="article-date">
  <time class="dt-published" datetime="2024-04-15T07:28:42.000Z" itemprop="datePublished">2024-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</a><ul>
<li><a href="#1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</a></li>
<li><a href="#1-2-lian-jie-jiao-ben">1.2 链接脚本</a><ul>
<li><a href="#1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</a><ul>
<li><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</a></li>
<li><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</a></li>
</ul>
</li>
<li><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</a></li>
<li><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</a><ul>
<li><a href="#1-2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-qing-chu-bss">2 清除bss</a><ul>
<li><a href="#2-1-bss-duan-jie-shao">2.1 bss段介绍</a></li>
<li><a href="#2-2-qing-bss">2.2 清bss</a></li>
<li><a href="#2-3-qing-bss-you-hua">2.3 清bss优化</a><ul>
<li><a href="#2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</a></li>
<li><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wei-zhi-wu-guan-ma">3 位置无关码</a><ul>
<li><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</a><ul>
<li><a href="#3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</a></li>
<li><a href="#3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</a></li>
<li><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</span><a href="#1-yin-ru-dai-ma-chong-ding-wei" class="header-anchor">#</a></h1><p>s3c2440的cpu默认是从0地址开始取指令执行，当从nor启动时,0地址对应nor, nor可以像内存一样读，但不能像内存一样写，前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a> 讲过，写入norflash要进行按照spec进行命令表写入。因此我们能够从nor上取指令执行。</p>
<p>当nand启动的时候，我们nand中的前4K指令会变自动加载到sram中去，这时的0地址对应sram。那么我们的程序如果大于4K,要从nand启动，sram只拷贝了nand中的前4K代码，那么如何解决这个问题呢？</p>
<p>就需要重定位代码到dram(ddr)中去，dram的容量较大，又可以直接被cpu访问。</p>
<h2><span id="1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</span><a href="#1-1-cheng-xu-di-zhi-kong-jian" class="header-anchor">#</a></h2><p>我们知道，程序包含：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码段（.text）</span><br><span class="line">数据段(.data):存放初始值不为<span class="number">0</span>的全局变量/静态变量</span><br><span class="line">rodata段(.rodata)：<span class="type">const</span>修饰的全局变量或静态变量</span><br><span class="line">bss段(.bss)：存放初始值为<span class="number">0</span>或者未初始化的全局变量/静态变量</span><br><span class="line">commen段(.commen):注释</span><br></pre></td></tr></table></figure>

<p>下面展开一个实验引入为什么要代码重定位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharB = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharC = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharD = <span class="string">&#x27;D&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_roval = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效，由于nor启动，nor上不可写 */</span></span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将上面的代码编译出的裸机程序分别烧录到nand和nor flash，看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 烧录到nor flash, 程序一直输出`AAAA`。</span><br><span class="line">2. 烧录到nand flash,程序无任何输出。</span><br></pre></td></tr></table></figure>

<p>我们发现nor启动时, 对全局变量g_char++无效, nand启动程序无任何输出。我们对程序进行反汇编处理：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/1.png"></p>
<p>可以看到.text段是从0地址开始的，证明cpu的确从0地址取指令进行译码、执行。<br>当从nor启动时，0地址对应nor；当从nand启动时，0地址对应sram，所以无论从nand还是从nor启动cpu都能取指令执行。</p>
<p>再进一步分析反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/2.png"></p>
<p>可以看到.data段的起始地址是0x8474(即g_Char变量的地址为0x8474）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 当把程序烧录进nor,  .data段在nor上的某一段区域, 由于nor能像内存一样读，但不能像内存一样直接写，因此对<span class="string">&#x27;g_Char&#x27;</span>修改无效。</span><br><span class="line"><span class="number">2.</span> 当把程序烧录进nand, .data段在nand的某一区域，nand启动时硬件会自动把nand上的前<span class="number">4</span>K数据copy到SRAM,然后cpu从sram取指令执行。但是.data段的起始地址<span class="number">0x8474</span>&gt;<span class="number">0x1000</span>，超过了<span class="number">4</span>K, cpu没法把.data段也copy到SRAM,所以当访问<span class="string">&#x27;g_Char&#x27;</span>时，发生了异常（abt数据访问终止，这个异常后面有在下一节“异常与中断”里面专门讲解)，因此程序卡死。</span><br></pre></td></tr></table></figure>

<p>再仔细看看反汇编，发现.rodata段和.text段是连续的,但是.rodata段和.data段中间有一段”空洞”。用图形表示更形象，bin文件的内容分布如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/3.png"><br>那么我们怎么去掉空洞，让.data段了紧接着.rodata段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 链接脚本(后面1.2有专门讲)</span><br><span class="line">2. 直接在编译的时候用 &quot;-Tdata 0x800&quot;，这样指定.data段基地址为0x800,这样nand启动时.data就能自动copy到SRAM了。</span><br></pre></td></tr></table></figure>

<p>我们现在使用<code>-Tdata 0x800</code>编译出裸机程序，对应反汇编如下：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/4.png"></p>
<p>这时我们烧录程序到nand，从nand启动，发现能输出<code>ABCDEFG</code>了，这就对了，因为.data段数据从nand自动拷贝到了sram。</p>
<p>有人说为什么不吧.data段指向到dram呢，这样无论时nor启动还是nand启动不就都能对全局变量写了？<br>当然这个没错，我做了这个尝试，编译时用<code>-Tdata 0x30000000</code>, 发现编译出来的bin文件有800多M,为什么有这么大呢？由于我们指定.data段存放在0x30000000(sdram的基地址)，这时bin文件的内部结构如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/5.png"></p>
<p>这么大的bin文件根本无法烧录。通过上面的例子，现在总结下为什么要代码重定位:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.nand启动，前4K代码被自动copy到sram，当程序大于4K的时候需要重定位代码到sdram。</span><br><span class="line">2.nor启动， 全局变量在nor上，不能像内存一样直接写该全局变量，那么也需要重定位到sdram。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-lian-jie-jiao-ben">1.2 链接脚本</span><a href="#1-2-lian-jie-jiao-ben" class="header-anchor">#</a></h2><h3><span id="1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</span><a href="#1-2-1-chong-ding-wei-data-duan" class="header-anchor">#</a></h3><p>我们发现<code>arm-linux-ld -Ttext 0 -Tdata 0x30000000</code>这种方式编译出来的bin文件有800多M,这肯定是不行的。可以通过AT参数指定.data段在编译时的存放位置，我们发现这样指定太不方便了，而且不好确定要放在bin文件的哪个位置。这里就要引入链接脚本，它可以帮我们解决这个不必要的麻烦。</p>
<h4><span id="1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</span><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/6.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x00000000</span>; <span class="comment">//表示当前地址为0</span></span><br><span class="line">	. = ALIGN(<span class="number">4</span>);  <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.text  :   </span><br><span class="line">	&#123;</span><br><span class="line">	  cpu/arm920t/start.o	(.text)</span><br><span class="line">	  board/lyb2440/boot_init.o (.text)</span><br><span class="line">	  *(.text)</span><br><span class="line">	&#125;	<span class="comment">//表示.text段从0x4开始存放,其中可以手动调整代码段的位置，</span></span><br><span class="line">	    <span class="comment">//比如让start.o，boot_init.o中的函数放在最前面,然后存放剩余的代码段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.rodata : &#123; *(.rodata) &#125; <span class="comment">//从该位置开始存放所有的.rodata段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.data : <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//从该位置开始存放所有的.data段 设置运行</span></span><br><span class="line"></span><br><span class="line">	__bss_start = .; <span class="comment">//设置.bss段的起始位置</span></span><br><span class="line">	.bss : &#123; *(.bss) &#125; <span class="comment">//从该位置开始存放所有的.bss段</span></span><br><span class="line">	_end = .;<span class="comment">//设置.bss段的结束位置（也就是整个链接脚本的结束为止）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是从uboot中裁剪过来的链接脚本，注释已经链接脚本的结构讲解的差不多了。这里.data段指定了程序的<strong>运行（链接）地址为sdram的base_addr（0x30000000）</strong>，通过<strong>AT指定加载（在bin文件的存放）地址0x800</strong>。</p>
<h4><span id="1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</span><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi" class="header-anchor">#</a></h4><p>对于nor启动时，我们可以直接从nor上取指令执行，所以可以只进行数据段的重定位（数据段需要写入），我们编写链接脚本sdram.lds如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .text   <span class="number">0</span>  : &#123; *(.text) &#125;<span class="comment">//所有文件的.text</span></span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125; <span class="comment">//只读数据段</span></span><br><span class="line">    .data <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//放在0x800,但运行时在0x3000000</span></span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;<span class="comment">//所有文件的bss段，所有文件的.COMMON段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序烧录进nor flash，程序运行时会将.data拷贝到0x0x30000000也就是sdram中去。只重定位数据段的过程用下图更直观:</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/7.png"></p>
<p>因此就可以对g_char进行写入了。Makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">       arm-linux-gcc -c -o led.o led.c</span><br><span class="line">       arm-linux-gcc -c -o uart.o uart.c</span><br><span class="line">       arm-linux-gcc -c -o init.o init.c</span><br><span class="line">       arm-linux-gcc -c -o main.o main.c</span><br><span class="line">       arm-linux-gcc -c -o start.o start.S</span><br><span class="line">       <span class="comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span></span><br><span class="line">       arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf</span><br><span class="line">       arm-linux-objcopy -O binary -S sdram.elf sdram.bin</span><br><span class="line">       arm-linux-objdump -D sdram.elf &gt; sdram.dis</span><br></pre></td></tr></table></figure>

<p>修改start.s进行.data段的重定位。我们需要将以0x800为.data段基地址的整个数据段copy到0x30000000处:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		/* 关闭看门狗 */</span><br><span class="line">		/* 初始化时钟 */</span><br><span class="line">		/* 设置栈 */</span><br><span class="line">		/*初始化sdram*/</span><br><span class="line">	...</span><br><span class="line">		/* 重定位data段，把加载地址0x800（bin文件中在nor中）的数据段的内容重定位到sdram的baseaddr */</span><br><span class="line">		mov r1, #0x800</span><br><span class="line">		ldr r0, [r1]</span><br><span class="line">		mov r1, #0x30000000</span><br><span class="line">		str r0, [r1]</span><br><span class="line">	</span><br><span class="line">		bl main</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>用几行简单的数据加载存储指令即可实现数据段的重定位，这里是用的相对跳转指令bl main，因为还没有重定位整个完整的代码，所以不能用ldr绝对跳转。前面的初始化时钟、sdram我就不写了，参考<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> , <a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>。</p>
<p>缺点：<br>这里只是人为的对.data段写死了,那么当我有多个全局变量时，还要计算重定位的次数,而且我们也不知道有多少个全局变量，所以这重定位方式有缺陷。那么我们对这种重定位.data断的方法做一个改进，将链接脚本修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    .text   0  : &#123; *(.text) &#125;</span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125;</span><br><span class="line">    .data 0x30000000 : AT(0x800) </span><br><span class="line">    &#123; </span><br><span class="line">    data_load_addr = LOADADDR(.data);	/* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    data_start = . ;			/* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    *(.data) 				</span><br><span class="line">    data_end = . ;			/* data段结束地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本用一个变量data_load_addr指定了加载地址(data段在bin文件中的地址，即0x800），用变量data_start指定了运行地址（即为0x30000000），那么用data_end - data_start就是我们数据段的总长度。</p>
<p>对start.s重定位过程做出如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 重定位data段 */</span><br><span class="line">    ldr r1, =data_load_addr  /* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    ldr r2, =data_start 	 /* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    ldr r3, =data_end 	     /* data段结束地址 */</span><br><span class="line">cpy:</span><br><span class="line">    ldrb r4, [r1]</span><br><span class="line">    strb r4, [r2] /*r2存入data_load_addr 0x400, 然后，r2,r1依次自加*/</span><br><span class="line">    add r1, r1, #1</span><br><span class="line">    add r2, r2, #1</span><br><span class="line">    cmp r2, r3</span><br><span class="line">    ble cpy</span><br><span class="line"></span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">    b halt</span><br></pre></td></tr></table></figure>

<p>这里start.s中用到了链接脚本中的label地址。</p>
<h3><span id="1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</span><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan" class="header-anchor">#</a></h3><p>由于我们的程序可能会大于SRAM或者nor的容量，那么就必须连代码段也一起进行重定位，这种重定位方式更好，在实际应用中也是用的这种方式去做的重定位。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/8.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码段的地址设置为0x3000_0004，然后紧接着放.rodata段，然后再紧接着放.data段。这样我们的bin文件就不再有“空洞”了。再来看重定位代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		...</span><br><span class="line">		/* 重定位text, rodata, data段整个程序 */</span><br><span class="line">		mov r1, #0</span><br><span class="line">		ldr r2, =_start 	    /* 第1条指令运行时的地址，也就是.text段的runtime addr，在这里是0x3000_0004*/</span><br><span class="line">		ldr r3, =__bss_start    /* bss段的起始地址,也就是整个程序的结束地址  */</span><br><span class="line">	cpy:</span><br><span class="line">		ldrb r4, [r1]</span><br><span class="line">		strb r4, [r2]</span><br><span class="line">		add r1, r1, #1</span><br><span class="line">		add r2, r2, #1</span><br><span class="line">		cmp r2, r3</span><br><span class="line">		ble cpy</span><br><span class="line">	</span><br><span class="line">		bl main  	</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>整个bin文件程序的长度（.text + .rodata + .data）为__bss_start - _start,那么我们是把bin文件从存储介质的0地址copy到程序的运行地址0x3000_0004，这样我们访问.data段时就是访问sdram中重定位后的数据段了。</p>
<h3><span id="1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</span><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua" class="header-anchor">#</a></h3><h4><span id="1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h4><p>前面重定位时，我们使用的是ldrb命令从的Nor Flash读取1字节数据，再用strb命令将1字节数据写到SDRAM里面。<br>我们开发板的Nor Flash是16位，SDRAM是32位。 假设现在需要复制16byte数据。</p>
<table>
<thead>
<tr>
<th>不同的读写指令</th>
<th>cpu读取nor的次数</th>
<th>cpu写入sdram的次数</th>
</tr>
</thead>
<tbody><tr>
<td>ldrb、strb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>ldr、str</td>
<td>8</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以看出我们更换读写指令后读写次数变少了，提升了cpu的访问效率。修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cpy:</span><br><span class="line">    ldr r4, [r1]</span><br><span class="line">    str r4, [r2]</span><br><span class="line">    add r1, r1, #4 //r1加4</span><br><span class="line">    add r2, r2, #4 //r2加4</span><br><span class="line">    cmp r2, r3 //如果r2 =&lt; r3继续拷贝</span><br><span class="line">    ble cpy</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</span><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x30000000</span>;</span><br><span class="line">    __code_start = .;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> 	&#123;</span><br><span class="line">    <span class="comment">//要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line">    <span class="comment">//然后从0地址把数据复制到__code_start</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dest &lt; end) &#123;</span><br><span class="line">        *dest++ = *src++; <span class="comment">//从0地址依次copy到__code_start(代码段的运行地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start.s中设置栈指针sp后，即可执行bl copy2sdram进行重定位代码。如何设置栈指针参考<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> 有实现，重复代码我就不贴上来了。</p>
<h1><span id="2-qing-chu-bss">2 清除bss</span><a href="#2-qing-chu-bss" class="header-anchor">#</a></h1><h2><span id="2-1-bss-duan-jie-shao">2.1 bss段介绍</span><a href="#2-1-bss-duan-jie-shao" class="header-anchor">#</a></h2><p>bss段是什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效 ，重定位到sdram的baseaddr后有效*/</span></span><br><span class="line">		<span class="built_in">putchar</span>(g_Char3);</span><br><span class="line">		g_Char3++;</span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把程序烧进去，然后打印g_A，但是发现g_A这个值并不是0，而是一个随机值。我们学习linux时知道全局变量g_A, g_B输出肯定是0，裸机输出不是0，为什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原因：程序执行汇编过程做完了重定位后把代码copy到了sdram上，然后sdram上紧接着的地址就是.bss的基地址了，这时候bss段的这块内存没有经过任何处理，所以是随机的。</span><br><span class="line">那么我们重定位完代码后需要进行清除sdram上.bss段的数据，因为我们知道bss是未初始化和初始值为<span class="number">0</span>的全局变量。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-qing-bss">2.2 清bss</span><a href="#2-2-qing-bss" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x30000000;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .text      :&#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除bss段的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* 清除BSS段 */</span><br><span class="line">	ldr r1, =__bss_start</span><br><span class="line">	ldr r2, =_end</span><br><span class="line">	mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">	strb r3, [r1]</span><br><span class="line">	add r1, r1, #1</span><br><span class="line">	cmp r1, r2</span><br><span class="line">	ble clean</span><br><span class="line"></span><br><span class="line">	bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>我们把程序再烧进去，然后打印g_A，但是发现g_A的值是0了。本质上就是对重定位后的bss段数据清0。</p>
<h2><span id="2-3-qing-bss-you-hua">2.3 清bss优化</span><a href="#2-3-qing-bss-you-hua" class="header-anchor">#</a></h2><h3><span id="2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    ldr r1, =__bss_start</span><br><span class="line">    ldr r2, =_end</span><br><span class="line">    mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">    str r3, [r1]</span><br><span class="line">    add r1, r1, #4</span><br><span class="line">    cmp r1, r2</span><br><span class="line">    ble clean</span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</span><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_bss</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 从lds文件中获得 __bss_start, _end*/</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> _end, __bss_start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *start = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">		*start++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：汇编代码获取的是链接脚本中的变量的地址，而C语言代码中获取的是链接脚本中的变量的值</strong>，所以这里的用C语言改进重定位还是清bss都是要加取址符。</p>
<h3><span id="2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</span><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi" class="header-anchor">#</a></h3><p>前面为了加快重定位和清bss的速度,用到了ldr,str这样以4字节为单位进行读写，但是还可能导致一个问题，假设现在链接脚本没有进行用ALIGN(4)让不同的段以4字节对齐，那么就会出现访问错乱的情况。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链接脚本中.data段和.bss之间的**ALIGN(4)**去掉。那么我们会发现程序执行的时候输出的g_A&#x3D;0，为什么呢，我们明明初始化g_A&#x3D;‘A’呀？</p>
<p>打开反汇编分析：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/9.png"></p>
<p>我们的.bss段紧接着.data段后面，可知在对bss段进行清除的时候，由于我们是以4字节为单位操作的，所以我们清除g_A的时候，连带g_Char,g_Char的值也一起清除了。</p>
<p>所以data段和数据段之间添加ALIGN(4)。修改后就会发现bss段的地址以0x30000248开始了，如下图：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/10.png"></p>
<h1><span id="3-wei-zhi-wu-guan-ma">3 位置无关码</span><a href="#3-wei-zhi-wu-guan-ma" class="header-anchor">#</a></h1><h2><span id="3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</span><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</span><a href="#3-1-1-xiang-dui-tiao-zhuan" class="header-anchor">#</a></h3><p>使用b, bl跳转指令。</p>
<p>对<code>bl sdram_test</code>指令进行分析，查看反汇编, 代码段的链接地址为0x3000,0000。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/11.png"><br><code>这里的bl 3000036c不是跳转到3000036c，这个时候sdram并未初始化,那么这个物理地址是无法访问的.</code></p>
<p>为了验证，我们做另一个实验，修改连接脚本sdram.lds, 链接地址改为0x3000,0800，编译查看反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/12.png"><br><code>可以看到现在变成了bl 300003ec,但两个的机器码e1a0c00d都是一样的，机器码一样，执行的内容肯定都是一样的。 因此这里并不是跳转到显示的地址，而是跳转到: pc + offset，这个由链接器决定。</code></p>
<p>假设程序从0x30000000执行，当前指令地址：0x3000005c ,那么就是跳到0x3000036c；如果程序从0运行，当前指令地址:0x5c 跳到：0x000003ec。<br>因此：跳转到某个地址并不是由bl指令所决定，而是由当前pc值和offset偏移量决定。反汇编显示这个值只是为了方便读代码。</p>
<p>结论： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。</p>
<h3><span id="3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</span><a href="#3-1-2-jue-dui-tiao-zhuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</span><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao" class="header-anchor">#</a></h3><p>怎么写位置无关码？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用相对跳转命令 b或bl;</span><br><span class="line">重定位之前，不可使用绝对地址(因为你sdram还没初始化，没有重定位代码过去，跳转过去不就死机了)，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；</span><br><span class="line">重定位之后，使用ldr pc = xxx，跳转到/runtime地址；</span><br><span class="line">写位置无关码，其实就是不使用绝对地址</span><br></pre></td></tr></table></figure>

<p>因此，前面的重定位和清bss例子，程序使用bl命令相对跳转，程序仍在NOR&#x2F;sram执行，要想让main函数在SDRAM执行，需要修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/" data-id="clyylnk8q001u7wuf6q7ibl8k" data-title="s3c2440裸机编程-代码重定位和清bss" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-内存控制器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T11:57:48.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul>
<li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li>
<li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul>
<li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li>
<li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul>
<li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li>
<li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li>
<li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li>
<li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li>
<li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li>
</ul>
</li>
<li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul>
<li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li>
</ul>
</li>
<li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li>
<li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul>
<li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li>
<li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li>
<li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li>
<li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li>
<li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul>
<li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li>
<li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li>
<li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li>
<li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li>
<li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li>
<li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul>
<li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li>
<li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li>
<li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li>
<li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li>
<li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li>
<li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul>
<li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul>
<li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul>
<li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li>
<li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul>
<li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul>
<li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul>
<li><a href="#7-1-1-reset">7.1.1 reset</a></li>
<li><a href="#7-1-2-du-id">7.1.2 读ID</a></li>
<li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li>
<li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li>
<li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul>
<li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li>
<li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul>
<li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li>
<li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li>
<li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul>
<li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul>
<li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li>
<li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li>
<li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li>
</ul>
</li>
<li><a href="#8-2-du-shu-ju">8.2 读数据</a></li>
<li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li>
<li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p>
<h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p>
<h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p>
<p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure>

<p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p>
<p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p>
<p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]		bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">...				...</span><br><span class="line"><span class="number">0b110</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure>

<p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p>
<h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p>
<h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p>
<h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p>
<h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p>
<h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p>
<h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p>
<h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure>

<p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure>

<p>用表格更好理解：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址</th>
<th>ROM返回数据</th>
<th>内存控制器挑选出数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000011</td>
<td>0b000011</td>
<td>编号3的存储单元中的8数据</td>
<td>编号3的存储单元中的8数据</td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000011</td>
<td>0b000001</td>
<td>编号1的存储单元中的16数据</td>
<td>根据”A0&#x3D;1”,挑出低8bit数据</td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000011</td>
<td>0b000000</td>
<td>编号0的存储单元中的32数据</td>
<td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td>
</tr>
</tbody></table>
<p>对上图的数据再次整理：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址（内存控制器转发给rom）</th>
<th>ROM返回数据</th>
<th>内存控制器组装数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000100</td>
<td>0b000100</td>
<td>地址4的一个1byte数据</td>
<td>组装地址7、6、5、4数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000101</td>
<td>地址5的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000110</td>
<td>地址6的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000111</td>
<td>地址7的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000100</td>
<td>0b00010</td>
<td>地址2的一个2byte数据</td>
<td>组装地址3、2的数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b00011</td>
<td>地址3的一个2byte数据</td>
<td></td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000100</td>
<td>0b00001</td>
<td>地址1的一个4byte数据</td>
<td>直接返回4字节数据</td>
</tr>
</tbody></table>
<p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure>

<p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure>

<p>我们知道CPU发出的是32bit地址,那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p>
<h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p>
<table>
<thead>
<tr>
<th>外设类型</th>
<th>接内存控制器的哪个片选</th>
<th>基地址</th>
<th>占用CPU的地址总线</th>
<th>地址范围(offset + size)</th>
</tr>
</thead>
<tbody><tr>
<td>nor</td>
<td>nGCS0</td>
<td>0x0000,0000</td>
<td>ADDR0-ADDR20</td>
<td>0x0000,0000 ~ 0x001f,ffff(2M)</td>
</tr>
<tr>
<td>dm9000网卡</td>
<td>nGCS4</td>
<td>0x2000,0000</td>
<td>ADDR0和ADDR2</td>
<td>0x2000,0000 ~ 0x2000,0005(5byte)</td>
</tr>
<tr>
<td>sdram</td>
<td>nGCS6</td>
<td>0x3000,0000</td>
<td>ADDR0-ADDR25</td>
<td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td>
</tr>
</tbody></table>
<p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p>
<h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p>
<h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p>
<h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p>
<p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p>
<p>引脚说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p>
<p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p>
<p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p>
<p>框图翻译成中文形式：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure>

<h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p>
<p>答：当然是<strong>拆分地址了，多次传输</strong>。</p>
<p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p>
<p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr	r0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure>

<p>然后从sdram规格书确定行列地址的数目：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure>

<p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p>
<h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p>
<h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p>
<p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">	BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">	BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">	REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">	BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">	MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">	MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// write sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">		led_test();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p>
<h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Nor</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>XIP(片上执行)</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能(擦除)</td>
<td>非常慢(5s,块太大)</td>
<td>快(3ms)</td>
</tr>
<tr>
<td>性能(写)</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>性能(读)</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>一般（容易出现位反转）</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000 ~ 100000</td>
<td>100000 ~ 1000000</td>
</tr>
<tr>
<td>接口</td>
<td>与ram类似，可直接访问任意地址</td>
<td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>容量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>常用文件系统类型</td>
<td>jffs</td>
<td>yaffs</td>
</tr>
</tbody></table>
<p>nor有以下优缺点相对nand：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure>

<h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p>
<h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p>
<p>引脚信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure>

<p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p>
<h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p>
<h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p>
<p>时序含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure>
<p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure>

<p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p>
<p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p>
<p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p>
<h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p>
<h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p>
<p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p>
<p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p>
<h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	unsigned <span class="built_in">char</span> c;</span><br><span class="line">	uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">	puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		c = getchar();</span><br><span class="line">		putchar(c);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">			bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">			puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p>
<p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p>
<p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p>
<h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p>
<p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p>
<h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p>
<p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p>
<h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p>
<h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)	</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure>

<p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p>
<table>
<thead>
<tr>
<th>cpu地址</th>
<th>nor地址</th>
</tr>
</thead>
<tbody><tr>
<td>A15~A1</td>
<td>A14~A0</td>
</tr>
</tbody></table>
<p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p>
<p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p>
<table>
<thead>
<tr>
<th>Nor Flash的操作</th>
<th>cpu的操作</th>
<th>U-BOOT上的操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写入AAH(解锁)</td>
<td>往地址AAAH写入AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写入55H(解锁)</td>
<td>往地址554H写入55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写入90H(命令)</td>
<td>往地址AAAH写入90H(命令)</td>
<td>mw.w aaa 90</td>
</tr>
<tr>
<td>读0地址得到厂家ID(C2H)</td>
<td>读0地址得到厂家ID(C2H)</td>
<td>md.w 0 1 (1:表示读一次)</td>
</tr>
<tr>
<td>读1地址得到设备ID(22DAH或225BH)</td>
<td>读2地址得到设备ID(22DAH或225BH)</td>
<td>md.w 2 1</td>
</tr>
<tr>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>mw.w 0 f0</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p>
<p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p>
<h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p>
<p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p>
<h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p>
<p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p>
<p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p>
<p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p>
<p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Nor Flash上操作cfi</th>
<th>2440上操作cfi</th>
<th>U-BOOT上操作cfi</th>
</tr>
</thead>
<tbody><tr>
<td>往55H地址写入98H（进入cfi模式）</td>
<td>往AAH地址写入98H</td>
<td>mw.w aa 98</td>
</tr>
<tr>
<td>读地址10H得到0051（’q’）</td>
<td>读地址20H得到0051</td>
<td>md.w 20 1</td>
</tr>
<tr>
<td>读地址11H得到0052(‘r’)</td>
<td>读地址22H得到0052</td>
<td>md.w 22 1</td>
</tr>
<tr>
<td>读地址12H得到0059(‘y’)</td>
<td>读地址24H得到0059</td>
<td>md.w 24 1</td>
</tr>
<tr>
<td>读地址27H得到容量</td>
<td>读地址4EH得到容量</td>
<td>md.w 4e 1</td>
</tr>
<tr>
<td>读地址1BH得到VCCmin</td>
<td>读地址36H得到VCCmin</td>
<td>md.w 36 1</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p>
<p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p>
<h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p>
<ol>
<li><p>我们在Nor Flash地址0x10000读数据</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p>
<p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash上写操作</th>
<th>2440上写操作</th>
<th>U-BOOT上写操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH(解锁)</td>
<td>往地址AAAH写AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写55H(解锁)</td>
<td>往地址554H写55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写A0H</td>
<td>往地址AAAH写A0H</td>
<td>mw.w aaa a0</td>
</tr>
<tr>
<td>往地址PA写PD</td>
<td>往地址0x100000写1234h</td>
<td>mw.w 100000 1234</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p>
</li>
</ol>
<p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p>
<p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure>

<p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p>
<h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash擦操作</th>
<th>u-boot擦操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址555H写80H</td>
<td>mw.w    aaa   80</td>
</tr>
<tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址PA写30H</td>
<td>mw.w  100000  30</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p>
<p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p>
<h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p>
<p>现在数据就变成我们的0x5678了。</p>
<p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p>
<h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p>
<h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p>
<h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p>
<p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p>
<p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p>
<h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p>
<h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p>
<h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p>
<h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> regions, i;</span><br><span class="line">	<span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line">	<span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vendor, device;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">	vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">	device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);	<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">	str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);	<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">	str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);	<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">	str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印容量 */</span></span><br><span class="line">	size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line">	<span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment">	 * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment">	 * Erase block region[i] information:</span></span><br><span class="line"><span class="comment">	 *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment">	 *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">	regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">		blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">			<span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line">			<span class="built_in">printHex</span>(block_addr);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			block_addr += block_size;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		region_info_base += <span class="number">4</span>;	<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 退出CFI模式 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p>
<p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p>
<h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p>
<p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">	pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">		pre = val;</span><br><span class="line">		val = nor_dat(addr&gt;&gt;<span class="number">1</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>);	 <span class="comment">/* erase sector */</span></span><br><span class="line">	</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>);	 <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p>
<p>可以看到擦除后这个block就是全0xffff了。</p>
<h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">		val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 烧写 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">		nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">		<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">		wait_ready(addr);</span><br><span class="line"></span><br><span class="line">		i += <span class="number">2</span>;</span><br><span class="line">		j += <span class="number">2</span>;</span><br><span class="line">		addr += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val = str[i];</span><br><span class="line">	<span class="comment">/* 烧写 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">	<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p>
<p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p>
<p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" data-id="clyylnk8r001y7wuf347e093z" data-title="s3c2440裸机编程-内存控制器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-UART体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T09:11:05.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-UART体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li>
<li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li>
<li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul>
<li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul>
<li><a href="#3-1-1-rs232">3.1.1 RS232</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li>
<li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul>
<li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul>
<li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li>
<li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul>
<li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li>
<li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li>
<li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li>
<li><a href="#5-3-puts">5.3 puts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure>
<p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">	奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">	偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">	举个栗子：</span><br><span class="line">	‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’	</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure>
<h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p>
<pre><code>1.双方约定好波特率（每一位占据的时间）
2.规定传输协议
</code></pre>
<p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p>
<pre><code>1.arm拉低uart总线1bit的时间（起始位）
2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位
</code></pre>
<p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p>
<p>TTL&#x2F;CMOS逻辑电平：</p>
<pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;
1（高电平2-5v）  表示逻辑&#39;1&#39;
</code></pre>
<p>RS-232逻辑电平：</p>
<pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;
(-12V ~ -3V) 表示逻辑&#39;1&#39;
</code></pre>
<p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p>
<p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p>
<pre><code>    arm				pc
TxD=data[0:]，    data[0:]=RxD
TxD=data[1:]，    data[1:]=RxD
...	
TxD=data[7:]，    data[7:]=RxD
</code></pre>
<h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p>
<p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p>
<h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p>
<p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p>
<p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p>
<p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p>
<h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p>
<ol>
<li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li>
<li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure>
<img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li>
</ol>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p>
<h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p>
<h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p>
<h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。
getchar就是从接受寄存器(URXH0)取出值。
无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。
</code></pre>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p>
<pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；
查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">	UTXH0 = (unsigned <span class="built_in">char</span>)c;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line">	<span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s)&#123;</span><br><span class="line">		putchar(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" data-id="clyylnk8q001t7wufcpfm2bg0" data-title="s3c2440裸机编程-UART体系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 11.11px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.89px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.67px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 14.44px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.78px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 20px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12.22px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15.56px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11.11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.22px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.22px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.67px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13.33px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/26/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-2-%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/">字符设备驱动-2-总线模型和平台设备驱动</a>
          </li>
        
          <li>
            <a href="/2024/07/24/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-1-GPIO%E9%A9%B1%E5%8A%A8LED%E7%A4%BA%E4%BE%8B/">字符设备驱动-1-GPIO驱动LED示例</a>
          </li>
        
          <li>
            <a href="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/">Linux内核-kmalloc与vmalloc及CMA内存</a>
          </li>
        
          <li>
            <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/">Linux内核-并发与同步</a>
          </li>
        
          <li>
            <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/">Linux内核-rootfs构建移植</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>