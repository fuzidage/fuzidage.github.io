<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-s3c2440裸机编程-内存控制器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T11:57:48.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul>
<li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li>
<li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul>
<li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li>
<li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul>
<li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li>
<li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li>
<li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li>
<li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li>
<li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li>
</ul>
</li>
<li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul>
<li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li>
</ul>
</li>
<li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li>
<li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul>
<li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li>
<li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li>
<li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li>
<li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li>
<li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul>
<li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li>
<li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li>
<li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li>
<li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li>
<li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li>
<li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul>
<li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li>
<li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li>
<li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li>
<li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li>
<li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li>
<li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul>
<li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul>
<li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul>
<li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li>
<li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul>
<li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul>
<li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul>
<li><a href="#7-1-1-reset">7.1.1 reset</a></li>
<li><a href="#7-1-2-du-id">7.1.2 读ID</a></li>
<li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li>
<li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li>
<li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul>
<li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li>
<li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul>
<li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li>
<li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li>
<li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul>
<li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul>
<li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li>
<li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li>
<li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li>
</ul>
</li>
<li><a href="#8-2-du-shu-ju">8.2 读数据</a></li>
<li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li>
<li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p>
<h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p>
<h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p>
<p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure>

<p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p>
<p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p>
<p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]		bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">...				...</span><br><span class="line"><span class="number">0b110</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure>

<p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p>
<h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p>
<h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p>
<h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p>
<h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p>
<h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p>
<h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p>
<h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure>

<p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure>

<p>用表格更好理解：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址</th>
<th>ROM返回数据</th>
<th>内存控制器挑选出数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000011</td>
<td>0b000011</td>
<td>编号3的存储单元中的8数据</td>
<td>编号3的存储单元中的8数据</td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000011</td>
<td>0b000001</td>
<td>编号1的存储单元中的16数据</td>
<td>根据”A0&#x3D;1”,挑出低8bit数据</td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000011</td>
<td>0b000000</td>
<td>编号0的存储单元中的32数据</td>
<td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td>
</tr>
</tbody></table>
<p>对上图的数据再次整理：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址（内存控制器转发给rom）</th>
<th>ROM返回数据</th>
<th>内存控制器组装数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000100</td>
<td>0b000100</td>
<td>地址4的一个1byte数据</td>
<td>组装地址7、6、5、4数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000101</td>
<td>地址5的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000110</td>
<td>地址6的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000111</td>
<td>地址7的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000100</td>
<td>0b00010</td>
<td>地址2的一个2byte数据</td>
<td>组装地址3、2的数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b00011</td>
<td>地址3的一个2byte数据</td>
<td></td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000100</td>
<td>0b00001</td>
<td>地址1的一个4byte数据</td>
<td>直接返回4字节数据</td>
</tr>
</tbody></table>
<p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure>

<p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure>

<p>我们知道CPU发出的是32bit地址,那么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p>
<h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p>
<table>
<thead>
<tr>
<th>外设类型</th>
<th>接内存控制器的哪个片选</th>
<th>基地址</th>
<th>占用CPU的地址总线</th>
<th>地址范围(offset + size)</th>
</tr>
</thead>
<tbody><tr>
<td>nor</td>
<td>nGCS0</td>
<td>0x0000,0000</td>
<td>ADDR0-ADDR20</td>
<td>0x0000,0000 ~ 0x001f,ffff(2M)</td>
</tr>
<tr>
<td>dm9000网卡</td>
<td>nGCS4</td>
<td>0x2000,0000</td>
<td>ADDR0和ADDR2</td>
<td>0x2000,0000 ~ 0x2000,0005(5byte)</td>
</tr>
<tr>
<td>sdram</td>
<td>nGCS6</td>
<td>0x3000,0000</td>
<td>ADDR0-ADDR25</td>
<td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td>
</tr>
</tbody></table>
<p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p>
<h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p>
<h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p>
<h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p>
<p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p>
<p>引脚说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p>
<p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p>
<p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p>
<p>框图翻译成中文形式：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure>

<h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p>
<p>答：当然是<strong>拆分地址了，多次传输</strong>。</p>
<p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p>
<p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldr	r0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure>

<p>然后从sdram规格书确定行列地址的数目：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure>

<p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p>
<h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p>
<h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p>
<p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">	BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">	BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">	REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">	BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">	MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">	MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// write sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">		led_test();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p>
<h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Nor</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>XIP(片上执行)</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能(擦除)</td>
<td>非常慢(5s,块太大)</td>
<td>快(3ms)</td>
</tr>
<tr>
<td>性能(写)</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>性能(读)</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>一般（容易出现位反转）</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000 ~ 100000</td>
<td>100000 ~ 1000000</td>
</tr>
<tr>
<td>接口</td>
<td>与ram类似，可直接访问任意地址</td>
<td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>容量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>常用文件系统类型</td>
<td>jffs</td>
<td>yaffs</td>
</tr>
</tbody></table>
<p>nor有以下优缺点相对nand：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure>

<h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p>
<h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p>
<p>引脚信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure>

<p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p>
<h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p>
<h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p>
<p>时序含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure>
<p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure>

<p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p>
<p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p>
<p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p>
<h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p>
<h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p>
<p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p>
<p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p>
<h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	unsigned <span class="built_in">char</span> c;</span><br><span class="line">	uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">	puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		c = getchar();</span><br><span class="line">		putchar(c);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">			bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">			puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p>
<p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p>
<p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p>
<h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p>
<p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p>
<h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p>
<p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p>
<h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p>
<h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)	</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure>

<p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p>
<table>
<thead>
<tr>
<th>cpu地址</th>
<th>nor地址</th>
</tr>
</thead>
<tbody><tr>
<td>A15~A1</td>
<td>A14~A0</td>
</tr>
</tbody></table>
<p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p>
<p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p>
<table>
<thead>
<tr>
<th>Nor Flash的操作</th>
<th>cpu的操作</th>
<th>U-BOOT上的操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写入AAH(解锁)</td>
<td>往地址AAAH写入AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写入55H(解锁)</td>
<td>往地址554H写入55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写入90H(命令)</td>
<td>往地址AAAH写入90H(命令)</td>
<td>mw.w aaa 90</td>
</tr>
<tr>
<td>读0地址得到厂家ID(C2H)</td>
<td>读0地址得到厂家ID(C2H)</td>
<td>md.w 0 1 (1:表示读一次)</td>
</tr>
<tr>
<td>读1地址得到设备ID(22DAH或225BH)</td>
<td>读2地址得到设备ID(22DAH或225BH)</td>
<td>md.w 2 1</td>
</tr>
<tr>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>mw.w 0 f0</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p>
<p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p>
<h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p>
<p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p>
<h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p>
<p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p>
<p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p>
<p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p>
<p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Nor Flash上操作cfi</th>
<th>2440上操作cfi</th>
<th>U-BOOT上操作cfi</th>
</tr>
</thead>
<tbody><tr>
<td>往55H地址写入98H（进入cfi模式）</td>
<td>往AAH地址写入98H</td>
<td>mw.w aa 98</td>
</tr>
<tr>
<td>读地址10H得到0051（’q’）</td>
<td>读地址20H得到0051</td>
<td>md.w 20 1</td>
</tr>
<tr>
<td>读地址11H得到0052(‘r’)</td>
<td>读地址22H得到0052</td>
<td>md.w 22 1</td>
</tr>
<tr>
<td>读地址12H得到0059(‘y’)</td>
<td>读地址24H得到0059</td>
<td>md.w 24 1</td>
</tr>
<tr>
<td>读地址27H得到容量</td>
<td>读地址4EH得到容量</td>
<td>md.w 4e 1</td>
</tr>
<tr>
<td>读地址1BH得到VCCmin</td>
<td>读地址36H得到VCCmin</td>
<td>md.w 36 1</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p>
<p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p>
<h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p>
<ol>
<li><p>我们在Nor Flash地址0x10000读数据</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p>
<p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash上写操作</th>
<th>2440上写操作</th>
<th>U-BOOT上写操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH(解锁)</td>
<td>往地址AAAH写AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写55H(解锁)</td>
<td>往地址554H写55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写A0H</td>
<td>往地址AAAH写A0H</td>
<td>mw.w aaa a0</td>
</tr>
<tr>
<td>往地址PA写PD</td>
<td>往地址0x100000写1234h</td>
<td>mw.w 100000 1234</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p>
</li>
</ol>
<p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p>
<p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure>

<p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p>
<h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash擦操作</th>
<th>u-boot擦操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址555H写80H</td>
<td>mw.w    aaa   80</td>
</tr>
<tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址PA写30H</td>
<td>mw.w  100000  30</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p>
<p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p>
<h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p>
<p>现在数据就变成我们的0x5678了。</p>
<p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p>
<h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p>
<h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p>
<h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p>
<p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p>
<p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p>
<h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p>
<h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p>
<h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p>
<h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> regions, i;</span><br><span class="line">	<span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line">	<span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vendor, device;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">	vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">	device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);	<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">	str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);	<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">	str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);	<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">	str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印容量 */</span></span><br><span class="line">	size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line">	<span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment">	 * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment">	 * Erase block region[i] information:</span></span><br><span class="line"><span class="comment">	 *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment">	 *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">	regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">		blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">			<span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line">			<span class="built_in">printHex</span>(block_addr);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			block_addr += block_size;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		region_info_base += <span class="number">4</span>;	<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 退出CFI模式 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p>
<p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p>
<h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p>
<p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">	pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">		pre = val;</span><br><span class="line">		val = nor_dat(addr&gt;&gt;<span class="number">1</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>);	 <span class="comment">/* erase sector */</span></span><br><span class="line">	</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>);	 <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p>
<p>可以看到擦除后这个block就是全0xffff了。</p>
<h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">		val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 烧写 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">		nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">		<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">		wait_ready(addr);</span><br><span class="line"></span><br><span class="line">		i += <span class="number">2</span>;</span><br><span class="line">		j += <span class="number">2</span>;</span><br><span class="line">		addr += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val = str[i];</span><br><span class="line">	<span class="comment">/* 烧写 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">	<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p>
<p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p>
<p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/" data-id="clxztkv8w001otouf1guwfu1s" data-title="s3c2440裸机编程-内存控制器" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-UART体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T09:11:05.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-UART体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li>
<li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li>
<li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul>
<li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul>
<li><a href="#3-1-1-rs232">3.1.1 RS232</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li>
<li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul>
<li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul>
<li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li>
<li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul>
<li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li>
<li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li>
<li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li>
<li><a href="#5-3-puts">5.3 puts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure>
<p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">	奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">	偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">	举个栗子：</span><br><span class="line">	‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’	</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure>
<h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p>
<pre><code>1.双方约定好波特率（每一位占据的时间）
2.规定传输协议
</code></pre>
<p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p>
<pre><code>1.arm拉低uart总线1bit的时间（起始位）
2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位
</code></pre>
<p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p>
<p>TTL&#x2F;CMOS逻辑电平：</p>
<pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;
1（高电平2-5v）  表示逻辑&#39;1&#39;
</code></pre>
<p>RS-232逻辑电平：</p>
<pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;
(-12V ~ -3V) 表示逻辑&#39;1&#39;
</code></pre>
<p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p>
<p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p>
<pre><code>    arm				pc
TxD=data[0:]，    data[0:]=RxD
TxD=data[1:]，    data[1:]=RxD
...	
TxD=data[7:]，    data[7:]=RxD
</code></pre>
<h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p>
<p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p>
<h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p>
<p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p>
<p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p>
<p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p>
<h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：	</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p>
<ol>
<li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li>
<li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure>
<img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li>
</ol>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p>
<h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p>
<h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p>
<h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。
getchar就是从接受寄存器(URXH0)取出值。
无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。
</code></pre>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p>
<pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；
查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">	UTXH0 = (unsigned <span class="built_in">char</span>)c;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line">	<span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s)&#123;</span><br><span class="line">		putchar(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/" data-id="clxztkv8v001htouf0vfl79f0" data-title="s3c2440裸机编程-UART体系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">外设驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-s3c2440裸机编程-时钟体系" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T08:49:52.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-kuang-jia">1 总线框架</a></li>
<li><a href="#2-shi-zhong-kuang-jia">2 时钟框架</a><ul>
<li><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</a></li>
<li><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</a></li>
</ul>
</li>
<li><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</a><ul>
<li><a href="#3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</a></li>
<li><a href="#3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</a><ul>
<li><a href="#3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</a></li>
<li><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</a></li>
<li><a href="#3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-zong-xian-kuang-jia">1 总线框架</span><a href="#1-zong-xian-kuang-jia" class="header-anchor">#</a></h1><p>下图是s3c2440的总线框架，其中有AHB(Advanced High performance Bus)高速总线,APB(Advanced Peripheral Bus)外围总线。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/1.jpg"></p>
<p>不同总线对应不同的时钟。</p>
<pre><code>SOC &lt;-&gt; FCLK
AHB &lt;-&gt; HCLK	
APB &lt;-&gt; PCLK 
</code></pre>
<p>其中：</p>
<p>1.使用AHB总线的有：LCD控制器、usb控制器、中断控制器、内存控制器等…<br>2.使用APB总线的有：i2c、spi、timer、gpio、adc等…具体上图。</p>
<h1><span id="2-shi-zhong-kuang-jia">2 时钟框架</span><a href="#2-shi-zhong-kuang-jia" class="header-anchor">#</a></h1><p>下图表示s3c2440 Soc的时钟框图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/2.png"></p>
<p>下面从细节上讲解时钟体系：</p>
<h2><span id="2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</span><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan" class="header-anchor">#</a></h2><p>s3c2440时钟源有2个，一个是OSC，一个是外部时钟EXTCLK,上面的时钟框图有标记，当然大家也可以查看手册“Figure 7-1. Clock Generator Block Diagram”。</p>
<p>那么如何选择是OSC还是EXTCLK呢？</p>
<p>打开原理图，OM3,OM2的引脚接地，那么OM[3,2]&#x3D;00.所以根据手册“Table 7-1. Clock Source Selection at Boot-Up”可知时钟源为OSC晶振。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/3.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/4.png"></p>
<h2><span id="2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</span><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk" class="header-anchor">#</a></h2><p>先了解下PLL, DIV</p>
<pre><code>PLL:用锁相环进行倍频
DIV:用分频器进行分频
</code></pre>
<p>如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/5.png"></p>
<p>生成的MPLL(Main PLL)和UPLL(USB PLL)，MPLL直接提供给FCLK，通过HDIVN分频给HCLK，通过PDIVN分频给PCLK，再传给下面的各个设备。<br>osc经过UPLL(USB PLL)得到UCLK。</p>
<h1><span id="3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</span><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</span><a href="#3-1-s3c2440-shi-zhong-shi-xu" class="header-anchor">#</a></h2><p>下图是2440时钟配置时序：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/6.jpg"></p>
<p>1.上电后，nRESET复位信号拉低，此时cpu还无法取指令工作。<br>2.nRESET复位信号结束后变为高电平，此时cpu开始工作。此时cpu主频FCLK&#x3D;osc。<br>3.此时可以配置PLL，经过lock time后，FCLK倍频成新的时钟。</p>
<h2><span id="3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</span><a href="#3-2-ru-he-pei-zhi-shi-zhong" class="header-anchor">#</a></h2><p>在参考手册的特性里介绍了S3C2440的工作频率，Fclk最高400MHz，Hclk最高136MHz，Pclk最高68MHz。那么 我们干脆配置FCLK：HCLK:PCLK&#x3D; 400：100：50 (MHz).</p>
<h3><span id="3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</span><a href="#3-2-1-pei-zhi-lock-time" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/7.png"></p>
<pre><code>我们取芯片手册上的推荐值。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</span><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/8.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/9.png"></p>
<p>也可参考配置表取值<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/10.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** MPLL(FCLK) = 2*m*Fin/(p*2^s)</span><br><span class="line">** 不妨取：</span><br><span class="line">** m = MDIV+8 = 92+8=100</span><br><span class="line">** p = PDIV+2 = 1+2 = 3</span><br><span class="line">** s = SDIV = 1</span><br><span class="line">** 则：</span><br><span class="line">** FCLK= 2*100*12/(3*2^1)=400M</span><br><span class="line">*/</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果也要配置了UPLL,那么先配置UPLL,要个7个NOP后才能再配置MPLL.</p>
<p>###3,配置CLKDIVN得到HCLK,PCLK<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果HDIV设置为非0，CPU的总线模式要进行改变，默认情况下FCLK &#x3D; HCLK，CPU工作在fast bus mode快速总线模式下，HDIV设置为非0后， FCLK与HCLK不再相等，要将CPU改为asynchronous bus mod异步总线模式.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15, 0, r1, c1, c0, 0         /* 读取CP15 C1寄存器 */ </span><br><span class="line">orr r1, r1, #0xc0000000           /* 设置CPU总线模式 */ </span><br><span class="line">mcr p15, 0, r1, c1, c0, 0         /* 写回CP15 C1寄存器 */</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</span><a href="#3-2-2-wan-zheng-hui-bian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">ldr r0, =0x53000000</span><br><span class="line">ldr r1, =0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15,0,r0,c1,c0,0</span><br><span class="line">orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,0,r0,c1,c0,0</span><br><span class="line"></span><br><span class="line">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span><br><span class="line"> *  m = MDIV+8 = 92+8=100</span><br><span class="line"> *  p = PDIV+2 = 1+2 = 3</span><br><span class="line"> *  s = SDIV = 1</span><br><span class="line"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span><br><span class="line"> */</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span><br><span class="line"> * 然后CPU工作于新的频率FCLK</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 设置内存: sp 栈 */</span><br><span class="line">/* 分辨是nor/nand启动</span><br><span class="line"> * 写0到0地址, 再读出来</span><br><span class="line"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line"> * 否则就是nor启动</span><br><span class="line"> */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">str r1, [r1] /* 0-&gt;[0] */ </span><br><span class="line">ldr r2, [r1] /* r2=[0] */</span><br><span class="line">cmp r1, r2</span><br><span class="line">ldr sp, =0x40000000+4096</span><br><span class="line">moveq sp, #4096  /* r1=r2， nand启动，修改栈指针=4096（此时sram对应0地址） */</span><br><span class="line">streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" data-id="clxztkv8x001ptoufes1h9idd" data-title="s3c2440裸机编程-时钟体系" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-循环队列FIFO原理图解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T07:18:51.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/">循环队列FIFO原理图解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</a><ul>
<li><a href="#1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</a></li>
<li><a href="#1-2-fifo-chu-shi-hua">1.2 FIFO初始化</a></li>
<li><a href="#1-3-fifo-xiao-hui">1.3 FIFO销毁</a></li>
<li><a href="#1-4-ru-dui-lie">1.4 入队列</a></li>
<li><a href="#1-5-chu-dui-lie">1.5 出队列</a></li>
<li><a href="#1-6-fifo-pan-kong">1.6 FIFO判空</a></li>
<li><a href="#1-6-fifo-pan-man">1.6 FIFO判满</a></li>
<li><a href="#1-7-fifo-rong-liang">1.7 FIFO容量</a></li>
<li><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</a></li>
<li><a href="#1-9-fifo-bian-li">1.9 FIFO遍历</a></li>
<li><a href="#1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</a><ul>
<li><a href="#1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</a></li>
<li><a href="#1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ce-shi-yong-li">2 测试用例</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</span><a href="#1-xun-huan-dui-lie-fifo-jie-shao" class="header-anchor">#</a></h1><p>循环队列是把<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/1.png" alt="img"></p>
<p>入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针。</p>
<h2><span id="1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</span><a href="#1-1-xun-huan-dui-lie-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_HEAD(name, type)                                          \</span></span><br><span class="line">        <span class="keyword">struct</span> name &#123;                                                  \</span><br><span class="line">                <span class="keyword">struct</span> type *fifo;                                     \</span><br><span class="line">                <span class="built_in">int</span> front, tail, capacity;                             \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">front表示首元素索引</span><br><span class="line">tail表示最后一个元素索引</span><br><span class="line">capacity表示队列的长度</span><br><span class="line">struct type fifo表示该队列中的元素指针，可以指向任意结构体指针</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">struct</span> person_q &#123;                                                        \</span><br><span class="line">    <span class="keyword">struct</span> person* *fifo;                                        \</span><br><span class="line">        <span class="built_in">int</span> front, tail, capacity;                                \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-fifo-chu-shi-hua">1.2 FIFO初始化</span><a href="#1-2-fifo-chu-shi-hua" class="header-anchor">#</a></h2><p>分配一个连续的空间存储队列元素。用户自定义队列容量。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/2.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_INIT(head, _capacity) do &#123;                                  \</span></span><br><span class="line">        (head)-&gt;fifo = malloc(<span class="keyword">sizeof</span>(*(head)-&gt;fifo) * _capacity);        \</span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                               \</span><br><span class="line">        (head)-&gt;capacity = _capacity;                                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-fifo-xiao-hui">1.3 FIFO销毁</span><a href="#1-3-fifo-xiao-hui" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EXIT(head) do &#123;                                                \</span></span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                                \</span><br><span class="line">        (head)-&gt;capacity = <span class="number">0</span>;                                                \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;fifo)                                                \</span><br><span class="line">                free((head)-&gt;fifo);                                        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-ru-dui-lie">1.4 入队列</span><a href="#1-4-ru-dui-lie" class="header-anchor">#</a></h2><p>入队列就是尾元素的索引++，也就是tail++，让新元素放进队列的尾部。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PUSH(head, elm) do &#123;                                      \</span></span><br><span class="line">        <span class="keyword">if</span> (FIFO_EMPTY(head))                                          \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">0</span>;                      \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;tail = ((head)-&gt;tail == (head)-&gt;capacity - <span class="number">1</span>)  \</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;tail + <span class="number">1</span>;                        \</span><br><span class="line">        (head)-&gt;fifo[(head)-&gt;tail] = elm;                              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果队列是空的，则第一个元素入队列，front和tail索引都指向第一个元素，front &#x3D; tail &#x3D; 0;<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/3.png" alt="img"></p>
<p>其他情况入队，让tail++<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/4.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/5.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/6.png" alt="img"></p>
<h2><span id="1-5-chu-dui-lie">1.5 出队列</span><a href="#1-5-chu-dui-lie" class="header-anchor">#</a></h2><p>出队列就是让font对应的元素丢出去，font++。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_POP(head, pelm) do &#123;                                      \</span></span><br><span class="line">        *(pelm) = (head)-&gt;fifo[(head)-&gt;front];                         \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;front == (head)-&gt;tail)                             \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                     \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;front = ((head)-&gt;front == (head)-&gt;capacity - <span class="number">1</span>)\</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;front + <span class="number">1</span>;                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当front追上tail后，表示队列空了，重新设置起始点，需要将front &#x3D; tail &#x3D; -1 。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/7.png" alt="img"></p>
<p>其他情况出队，丢出front元素，让front++</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/8.png" alt="img"></p>
<h2><span id="1-6-fifo-pan-kong">1.6 FIFO判空</span><a href="#1-6-fifo-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EMPTY(head)    ((head)-&gt;front == -1)</span></span><br></pre></td></tr></table></figure>

<p>①队列初始化时，队列是空的，会让front为-1<br>②出队列时，font++, 当font追上tail表示空了，则可以重新设置起始点，令front &#x3D; tail &#x3D; -1<br>综合①②所以可以用-1判断</p>
<h2><span id="1-6-fifo-pan-man">1.6 FIFO判满</span><a href="#1-6-fifo-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FULL(head)     (((head)-&gt;front == ((head)-&gt;tail + 1)%(head)-&gt;capacity))</span></span><br></pre></td></tr></table></figure>

<p>①当front&#x3D;0时，那么tail到达capacity-1表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/9.png" alt="img"></p>
<p>②否则，tail追上front后(front &#x3D; tail + 1)表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/10.png" alt="img"></p>
<h2><span id="1-7-fifo-rong-liang">1.7 FIFO容量</span><a href="#1-7-fifo-rong-liang" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CAPACITY(head) ((head)-&gt;capacity)</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</span><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_SIZE(head)     (FIFO_EMPTY(head) ? \</span></span><br><span class="line">        <span class="number">0</span> : ((((head)-&gt;tail + (head)-&gt;capacity - (head)-&gt;front) % (head)-&gt;capacity) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>用tail - front就表示有效元素个数，不过由于循环FIFO,可能tail&lt;front,这个时候就需要取余运算，如下图:</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/11.png" alt="img"></p>
<h2><span id="1-9-fifo-bian-li">1.9 FIFO遍历</span><a href="#1-9-fifo-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FOREACH(var, head, idx) \</span></span><br><span class="line">　　<span class="keyword">for</span> (idx = (head)-&gt;front, <span class="keyword">var</span> = (head)-&gt;fifo[idx]; \</span><br><span class="line">　　　　idx &lt; (head)-&gt;front + FIFO_SIZE(head); \</span><br><span class="line">　　　　<span class="keyword">var</span> = (head)-&gt;fifo[++idx % (head)-&gt;capacity])</span><br></pre></td></tr></table></figure>

<h2><span id="1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</span><a href="#1-10-dui-lie-yuan-su-huo-qu" class="header-anchor">#</a></h2><h3><span id="1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</span><a href="#1-10-1-di-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_FRONT(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;front])</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</span><a href="#1-10-2-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_TAIL(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;tail])</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-ce-shi-yong-li">2 测试用例</span><a href="#2-ce-shi-yong-li" class="header-anchor">#</a></h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;fifo.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="keyword">struct</span> person_q person1_queue;</span><br><span class="line"><span class="keyword">struct</span> person_q person2_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">        FIFO_INIT(&amp;person1_queue, <span class="number">1</span>);</span><br><span class="line">        FIFO_INIT(&amp;person2_queue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person2_queue) != <span class="number">5</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">20</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1001</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person1_queue, person_a);<span class="comment">//把person_a这个结构体指针元素丢进FIFO,</span></span><br><span class="line">        <span class="comment">//后面对它pop出来又能拿到它，所以不用担心地址弄丢导致无法释放.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_FULL(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">30</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1002</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 3 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 4 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person1_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">20</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 5 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">40</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1003</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        FIFO_GET_FRONT(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_FRONT NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_GET_TAIL(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_TAIL NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 6 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 7 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_arr[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                person_arr[i] = malloc(<span class="keyword">sizeof</span>(*person_arr[<span class="number">0</span>]));</span><br><span class="line">                person_arr[i]-&gt;age = i;</span><br><span class="line">                person_arr[i]-&gt;id = <span class="number">1000</span> + i;</span><br><span class="line">                FIFO_PUSH(&amp;person2_queue, person_arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_EMPTY(&amp;person2_queue) &#123;</span><br><span class="line">                FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">                printf( <span class="string">&quot;age:%d, id:%d.\n&quot;</span>, person_a-&gt;age, person_a-&gt;id);</span><br><span class="line">                free(person_a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_EXIT(&amp;person1_queue);</span><br><span class="line">        FIFO_EXIT(&amp;person2_queue);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/12.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/" data-id="clxztkv960059touf41d89vpl" data-title="循环队列FIFO原理图解" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-tailq队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/11/tailq%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2024-04-11T06:15:23.000Z" itemprop="datePublished">2024-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/11/tailq%E9%98%9F%E5%88%97/">tailq队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tailq-dui-lie-jie-shao">1 tailq队列介绍</a><ul>
<li><a href="#1-1-queue-jian-jie">1.1 queue 简介</a></li>
<li><a href="#1-2-slist">1.2 SLIST</a></li>
<li><a href="#1-3-stailq">1.3 STAILQ</a></li>
<li><a href="#1-4-list">1.4 LIST</a></li>
<li><a href="#1-5-tailq">1.5 TAILQ</a></li>
<li><a href="#1-6-circleq">1.6 CIRCLEQ</a></li>
</ul>
</li>
<li><a href="#2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</a><ul>
<li><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</a></li>
<li><a href="#2-2-dui-lie-tou">2.2 队列头</a></li>
<li><a href="#2-3-chu-shi-hua">2.3 初始化</a></li>
<li><a href="#2-4-cha-ru-yuan-su">2.4 插入元素</a><ul>
<li><a href="#2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</a></li>
<li><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</a></li>
</ul>
</li>
<li><a href="#2-5-shan-chu-yuan-su">2.5 删除元素</a></li>
<li><a href="#2-6-di-yi-ge-yuan-su">2.6 第一个元素</a></li>
<li><a href="#2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</a></li>
<li><a href="#2-8-xia-yi-ge-yuan-su">2.8 下一个元素</a></li>
<li><a href="#2-9-qian-yi-ge-yuan-su">2.9 前一个元素</a></li>
<li><a href="#2-10-pan-kong">2.10 判空</a></li>
<li><a href="#2-11-pan-man">2.11 判满</a></li>
<li><a href="#2-12-bian-li">2.12 遍历</a></li>
<li><a href="#2-13-dao-bian-li">2.13 倒遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tailq-dui-lie-jie-shao">1 tailq队列介绍</span><a href="#1-tailq-dui-lie-jie-shao" class="header-anchor">#</a></h1><p>TAILQ队列是FreeBSD内核中的一种队列数据结构，主要是把队列头抽象成一个单独的结构体。它实现在Linux queue中。</p>
<h2><span id="1-1-queue-jian-jie">1.1 queue 简介</span><a href="#1-1-queue-jian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/1.png" alt="img"></p>
<p>可以include &lt;sys&#x2F;queue.h&gt;后直接使用。queue 分为 SLIST、LIST、STAILQ、TAILQ、CIRCLEQ 。queue 的所有源码都是宏定义，因此完全包含于queue.h当中，无需编译为库文件。</p>
<p>可以从toolchains或者系统路径&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;queue.h找到实现。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/2.png" alt="img"></p>
<h2><span id="1-2-slist">1.2 SLIST</span><a href="#1-2-slist" class="header-anchor">#</a></h2><p>SLIST 是Singly-linked List 的缩写，意为单向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/3.png" alt="img"></p>
<h2><span id="1-3-stailq">1.3 STAILQ</span><a href="#1-3-stailq" class="header-anchor">#</a></h2><p>单向有尾链表，节点n为尾节点。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/4.png" alt="img"></p>
<h2><span id="1-4-list">1.4 LIST</span><a href="#1-4-list" class="header-anchor">#</a></h2><p>双向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/5.png" alt="img"></p>
<h2><span id="1-5-tailq">1.5 TAILQ</span><a href="#1-5-tailq" class="header-anchor">#</a></h2><p>双向有尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/6.png" alt="img"></p>
<h2><span id="1-6-circleq">1.6 CIRCLEQ</span><a href="#1-6-circleq" class="header-anchor">#</a></h2><p>双向循环链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/7.png" alt="img"></p>
<h1><span id="2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</span><a href="#2-tailq-shi-xian-yuan-li-tu-jie" class="header-anchor">#</a></h1><p>双向有尾链表,也就是有一个表头和表尾，表头指向节点1和尾节点。</p>
<h2><span id="2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</span><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                                   \</span></span><br><span class="line"><span class="keyword">struct</span> &#123;                                                                    \</span><br><span class="line">    <span class="keyword">struct</span> type *tqe_next;      <span class="comment">/* next element */</span>                          \</span><br><span class="line">    <span class="keyword">struct</span> type **tqe_prev;     <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tqe_next是指向下一个元素的指针，tqe_prev是指向前一个元素的tqe_next地址，对它解引用后</span></span><br><span class="line"><span class="comment">（*tqe_priv）指向当前元素的地址。*/</span></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">struct</span> item&#123;</span><br><span class="line">　　<span class="built_in">int</span> val;</span><br><span class="line">　　TAILQ_ENTRY(item) entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/8.png" alt="img"></p>
<h2><span id="2-2-dui-lie-tou">2.2 队列头</span><a href="#2-2-dui-lie-tou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    TAILQ_HEAD(name, type)                        \</span></span><br><span class="line"><span class="keyword">struct</span> name &#123;                                \</span><br><span class="line">    <span class="keyword">struct</span> type *tqh_first;    <span class="comment">/* first element */</span>            \</span><br><span class="line">    <span class="keyword">struct</span> type **tqh_last;    <span class="comment">/* addr of last next element */</span>        \</span><br><span class="line">&#125;</span><br><span class="line">STAILQ_HEAD(my_tailq,  tailq_entry) queue_head;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/9.png" alt="img"></p>
<p>先看TAILQ_HEAD:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqh_first为队列第一个元素的地址；</span><br><span class="line">tqh_last为最后一个元素tqe_next的地址；</span><br><span class="line">tqh_last指向的指针为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>再看TAILQ_ENTRY:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tqe_next为队列下一个元素的地址；</span><br><span class="line">tqe_prev为队列上一个元素tqe_next的地址；</span><br><span class="line">tqe_prev指向的指针为当前元素的地址；</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-chu-shi-hua">2.3 初始化</span><a href="#2-3-chu-shi-hua" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/10.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head) do &#123;                                               \</span></span><br><span class="line">    (head)-&gt;tqh_first = NULL;                                               \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-cha-ru-yuan-su">2.4 插入元素</span><a href="#2-4-cha-ru-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;                  \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = NULL;                                 \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;                     \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                                    \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</span><a href="#2-4-1-cha-ru-1-ge-yuan-su" class="header-anchor">#</a></h3><ol>
<li><p>将要插入的node加入到尾部：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/11.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next = NULL;                         </span><br><span class="line">(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;<span class="comment">//将要插入的节点prev指向最后一个node </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>更新头节点:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/12.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);          </span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</span><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su" class="header-anchor">#</a></h3><p>同理多个元素时尾插。</p>
<ol>
<li><p>将要插入的node加入到尾部:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/13.png" alt="img"></p>
</li>
<li><p>更新头节点:</p>
</li>
</ol>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/14.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);           <span class="comment">//尾节点指向新的尾巴</span></span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; <span class="comment">//head的last指向新的尾巴</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-shan-chu-yuan-su">2.5 删除元素</span><a href="#2-5-shan-chu-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;                       \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                          \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;      \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                           \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/15.png"></p>
<p>我们现在要把val&#x3D;3的elm删除：<br>elm中的tqe_next不为空，表示elm不是尾节点。那么</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<p>这2句执行完后:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/16.png" alt="img"></p>
<p>然后free掉该elm,</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/17.png" alt="img"></p>
<p>同理再删除val&#x3D;2的elm：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/18.png" alt="img"></p>
<p>然后free掉该elm，</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/19.png" alt="img"></p>
<p>最后如果要把val&#x3D;4的elm删除：</p>
<p>elm中的tqe_next为空，表示elm是尾节点。那么，</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;               <span class="comment">//让head的last指向新的尾巴        </span></span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;    <span class="comment">//让elm的前一个node的next指向该elm的后一个node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/20.png" alt="img"></p>
<h2><span id="2-6-di-yi-ge-yuan-su">2.6 第一个元素</span><a href="#2-6-di-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</span><a href="#2-7-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_LAST(head, headname) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这个实现看起来有点绕，我们先做一个实验:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> _QUEUE_ITEM &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    TAILQ_ENTRY(QUEUE_ITEM) entries;</span><br><span class="line">&#125;QUEUE_ITEM;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(TAIL_QUEUE, QUEUE_ITEM) queue_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    QUEUE_ITEM *item[<span class="number">5</span>];</span><br><span class="line">    TAILQ_INIT(&amp;queue_head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        item[i] = (<span class="keyword">struct</span> QUEUE_ITEM*)malloc(<span class="keyword">sizeof</span>(QUEUE_ITEM));</span><br><span class="line">        item[i]-&gt;<span class="keyword">value</span> = i;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;queue_head, item[i], entries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;item[%d]: item:%#x, next:%#x,&amp;next:%#x, prev:%#x, *prev:%#x\n&quot;</span>,</span><br><span class="line">　　　　　　　　i, item[i], item[i]-&gt;entries.tqe_next, &amp;(item[i]-&gt;entries.tqe_next), item[i]-&gt;entries.tqe_prev, *(item[i]-&gt;entries.tqe_prev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;queue_head:%#x, first:%#x, last:%#x\n&quot;</span>, &amp;queue_head, queue_head.tqh_first, queue_head.tqh_last);</span><br><span class="line">    printf(<span class="string">&quot;last item:%p\n&quot;</span>, TAILQ_LAST(&amp;queue_head, TAIL_QUEUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/21.png" alt="img"></p>
<p>可以用图形来描述:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/22.png" alt="img"></p>
<p><code>TAILQ_LAST(&amp;queue_head, TAIL_QUEUE);</code>这句话展开:<br><code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code></p>
<p><code>((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))</code>这句话,我们把地址0x601060代入进去得0x602098，即为：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/23.png" alt="img"></p>
<p>然后<code>(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last)</code>得到0x602078,<br>认真的同学此时已经发现，此时对应倒数第二元素的next地址，</p>
<p>最后取<code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code>得到0x602090,这就是最后一个元素的地址。</p>
<p><strong>总结：这里核心其实就是把最后一个元素的entries成员当成head指针来使用</strong>。因为本质上最后一个节点的TAILQ_ENTRY域和TAILQ_HEAD是同样的结构。</p>
<h2><span id="2-8-xia-yi-ge-yuan-su">2.8 下一个元素</span><a href="#2-8-xia-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_NEXT(elm, field)                ((elm)-&gt;field.tqe_next)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-9-qian-yi-ge-yuan-su">2.9 前一个元素</span><a href="#2-9-qian-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_PREV(elm, headname, field) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这里和TAILQ_LAST原理一样，将0x602090代入进去得:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/24.png" alt="img"><br>然后对*(0x602058)得0x602070,即得到了前一个node的地址。</p>
<h2><span id="2-10-pan-kong">2.10 判空</span><a href="#2-10-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_EMPTY(head)                ((head)-&gt;tqh_first == NULL)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-11-pan-man">2.11 判满</span><a href="#2-11-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-12-bian-li">2.12 遍历</span><a href="#2-12-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH(var, head, field)                                        \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = ((head)-&gt;tqh_first);                                \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = ((<span class="keyword">var</span>)-&gt;field.tqe_next))</span><br></pre></td></tr></table></figure>

<h2><span id="2-13-dao-bian-li">2.13 倒遍历</span><a href="#2-13-dao-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH_REVERSE(var, head, headname, field)                \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last));        \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((<span class="keyword">var</span>)-&gt;field.tqe_prev))-&gt;tqh_last)))</span><br></pre></td></tr></table></figure>

<p>当看懂之前的<strong>最后一个元素</strong>原理时，倒遍历的实现是不是超级简单。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/11/tailq%E9%98%9F%E5%88%97/" data-id="clxztkv8x001ttoufeq2w6ss6" data-title="tailq队列" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-union和bit-field巧妙进行寄存器位操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2024-04-04T10:15:23.000Z" itemprop="datePublished">2024-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/">union和bit_field巧妙进行寄存器位操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</a></li>
<li><a href="#2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</a><ul>
<li><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</a></li>
<li><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</a></li>
<li><a href="#2-3-du-qu-ji-cun-qi">2.3 读取寄存器</a></li>
<li><a href="#2-4-xie-ji-cun-qi">2.4 写寄存器</a></li>
<li><a href="#2-5-wei-du-qu">2.5 位读取</a></li>
<li><a href="#2-6-wei-xie-ru">2.6 位写入</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</span><a href="#1-union-jie-gou-qu-fen-da-xiao-duan" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_bits(stc, field)(&#123;stc.raw = 0x12345678; stc.bits.field;&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> raw;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_a : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_b : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_c : <span class="number">5</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_d : <span class="number">3</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_e : <span class="number">1</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">num</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#x, %#x, %#x, %#x, %#x\n&quot;</span>,</span><br><span class="line">        read_bits(num, bit_a),</span><br><span class="line">        read_bits(num, bit_b),</span><br><span class="line">        read_bits(num, bit_c),</span><br><span class="line">        read_bits(num, bit_d),</span><br><span class="line">        read_bits(num, bit_e));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1-1.png" alt="img"></p>
<p>这样的结果，原理如下图:</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="img"><br>那么从这里可以看出，低地址对应低字节， 因此我们的运行机器是Little Endian。</p>
<p>那么bit_a&#x3D;0x78; bit_b&#x3D;0x56; bit_c等于0x34取低5位，也就是0x14; bit_d 等于0x34取高3位，也就是0x1； bit_e等于0x12取最低位，也就是0。</p>
<p>由于这里的num是union结构，因此对.raw进行操作，那么也就等于对.bits也进行了操作，那么返回bit field是不是和寄存器的位操作很类似。下面详细介绍如何用union和bit field巧妙进行寄存器位操作。</p>
<h1><span id="2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</span><a href="#2-ji-cun-qi-de-wei-cao-zuo" class="header-anchor">#</a></h1><p>举个例子，这是mipi-rx DPHY的寄存器的部分截取：</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/2.png" alt="img"></p>
<p>那么我们可以对该module进行结构定义如下：(当然如果觉得手动去定义麻烦，网上有专门的python工具可以对excel到寄存器定义的转换)<br><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/3.png" alt="img"></p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/4.png" alt="img"></p>
<p>这里对该module的每个寄存器都定义成union。</p>
<h2><span id="2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</span><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃define <span class="title function_">offsetof</span><span class="params">(<span class="type">struct_t</span>,member)</span> <span class="params">( (<span class="type">int</span>)&amp;((<span class="type">struct_t</span> *)<span class="number">0</span>)-&gt;member )</span></span><br></pre></td></tr></table></figure>

<p>(struct_t <em>)0)，可以看到这里*<em>把一个0地址转换成一个指针，它表示一个结构体指针变量，并且是值&#x3D;0的指针</em></em>, 那么访问它的成员，成员的地址自然就会往后递增，因此该成员的地址那么就等于该成员的偏移量。</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么offsetof(struct student, id)就为100 + 4&#x3D;104，同理.name的offsetof为0，.age的offsetof为100，.sex的offsetof为108。</p>
<h2><span id="2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</span><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti" class="header-anchor">#</a></h2><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/5.png" alt="img"></p>
<p>该函数实现位于include&#x2F;linux&#x2F;kernel.h， 源码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span>(<span class="params"> ((type *</span>)0)-&gt;member ) *__mptr</span> = (ptr);    \</span><br><span class="line">    (type *)( (<span class="built_in">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个结构体成员指针mptr指向该成员，</li>
<li>用该成员指针减去该成员在结构体中的偏移量，不就是该结构体的起始地址</li>
</ol>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;.name=<span class="string">&quot;robin&quot;</span>, .age=<span class="number">18</span>, .id=<span class="number">123456</span>, .sex=<span class="string">&#x27;M&#x27;</span>&#125;, *pstu;</span><br><span class="line">pstu = container_of(&amp;stu.sex, <span class="keyword">struct</span> student, sex);</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-du-qu-ji-cun-qi">2.3 读取寄存器</span><a href="#2-3-du-qu-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_read(addr) readl((void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPHY_BA_ADDR (0x0300b000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFST(_BLK_T, _REG)       ((uint64_t)&amp;(((struct _BLK_T *)0)-&gt;_REG))//this is same with offsetof</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_REG(_BA, _BLK_T, _REG) \</span></span><br><span class="line">(_reg_read(_BA+_OFST(_BLK_T, _REG)))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RD_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了read。</p>
<h2><span id="2-4-xie-ji-cun-qi">2.4 写寄存器</span><a href="#2-4-xie-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_write(addr, data) writel(data, (void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR_REG(_BA, _BLK_T, _REG, _V) \</span></span><br><span class="line">                (_reg_write((_BA+_OFST(_BLK_T, _REG)), _V))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WR_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, <span class="number">0x3333ffff</span>);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了write, write的数据为0x3333ffff。</p>
<h2><span id="2-5-wei-du-qu">2.5 位读取</span><a href="#2-5-wei-du-qu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RD_BITS(_BA, _BLK_T, _REG, _FLD) \</span></span><br><span class="line">        (&#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD;\</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RD_BITS</span>(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，typeof表示对该成员取数据结构类型，然后把该寄存器里的值读出来，最后返回bit[31:16]。</p>
<h2><span id="2-6-wei-xie-ru">2.6 位写入</span><a href="#2-6-wei-xie-ru" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WR_BITS(_BA, _BLK_T, _REG, _FLD, _V) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD = _V;\</span><br><span class="line">                _reg_write((_BA+_OFST(_BLK_T, _REG)), _r.raw);\</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">WR_BITS(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1, <span class="number">0x1111</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，然后把该寄存器里的值读出来, 再把该寄存器的bit[31:16]写入0x1111。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/" data-id="clxztkv950051touferdeb9kl" data-title="union和bit_field巧妙进行寄存器位操作" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-卷帘快门RollingShutter与全局快门GlobalShutter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/" class="article-date">
  <time class="dt-published" datetime="2024-04-03T07:56:37.000Z" itemprop="datePublished">2024-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/">卷帘快门RollingShutter与全局快门GlobalShutter</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-global-shutter">1 Global Shutter</a></li>
<li><a href="#2-rolling-shutter">2 Rolling Shutter</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-global-shutter">1 Global Shutter</span><a href="#1-global-shutter" class="header-anchor">#</a></h1><p>通过整幅场景在同一时间曝光实现的。Sensor所有像素点同时收集光线，同时曝光。即在曝光开始的时候，Sensor开始收集光线；在曝光结束的时候，光线收集电路被切断。CCD就是Global shutter工作方式。所有像元同时曝光</p>
<h1><span id="2-rolling-shutter">2 Rolling Shutter</span><a href="#2-rolling-shutter" class="header-anchor">#</a></h1><p>与Global shutter不同，它是通过Sensor逐行曝光的方式实现的。在曝光开始的时候，Sensor逐行扫描逐行进行曝光，直至所有像素点都被曝光。</p>
<p>对比优缺点:</p>
<p>Global shutter： 曝光时间更短，但会增加读出噪声；</p>
<p>Rolling shutter：可以达到更高的帧速，噪声小，但是运动场景会产生果冻效应。</p>
<p>卷帘快门与全局快门大致原理如下图：</p>
<p align="left">&nbsp;<img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/1.gif" alt width="292" height="165" loading="lazy"></p>

<p>卷帘快门：</p>
<p><img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/2.gif" alt width="409" height="187" loading="lazy"></p>

<p><strong>适用性：</strong></p>
<table>
<thead>
<tr>
<th><strong>Global shutter</strong></th>
<th><strong>rolling shutter</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>曝光时间短的应用（如</strong><strong>&lt;500μs****）</strong></td>
<td><strong>曝光时间长（如大于<strong><strong>500μs</strong></strong>）的应用可以有更低的噪声和帧速</strong></td>
</tr>
<tr>
<td><strong>快速移动物体拍适合</strong></td>
<td><strong>静止的物体适合</strong></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/" data-id="clxztkv960055touf2b5dar75" data-title="卷帘快门RollingShutter与全局快门GlobalShutter" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mipi-csi软件篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T09:20:23.000Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/">mipi-csi软件篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</a></li>
<li><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</a><ul>
<li><a href="#2-1-chuan-shu-mo-shi">2.1 传输模式</a></li>
<li><a href="#2-2-lane-states">2.2 lane states</a></li>
<li><a href="#2-3-lane-levels">2.3 Lane Levels</a></li>
<li><a href="#2-4-cao-zuo-mo-shi">2.4 操作模式</a></li>
<li><a href="#2-5-shi-zhong-mo-shi">2.5 时钟模式</a></li>
<li><a href="#2-6-shi-xu-yao-qiu">2.6 时序要求</a></li>
<li><a href="#2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</a></li>
<li><a href="#2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</a></li>
</ul>
</li>
<li><a href="#3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</a><ul>
<li><a href="#3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</a></li>
<li><a href="#3-2-bao-lei-xing">3.2 包类型</a><ul>
<li><a href="#3-2-1-duan-bao-jie-gou">3.2.1 短包结构</a></li>
<li><a href="#3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</a></li>
<li><a href="#3-2-3-chang-bao-jie-gou">3.2.3 长包结构</a></li>
<li><a href="#3-2-4-h-blanking-v-blanking">3.2.4 H-blanking &amp; V-blanking</a></li>
<li><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</a><ul>
<li><a href="#3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</a></li>
<li><a href="#3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</a><ul>
<li><a href="#4-1-rgb-ge-shi">4.1 RGB格式</a></li>
<li><a href="#4-2-yuv-ge-shi">4.2 YUV格式</a><ul>
<li><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</a><ul>
<li><a href="#4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</a></li>
<li><a href="#4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</a></li>
<li><a href="#4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</a></li>
</ul>
</li>
<li><a href="#4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</a><ul>
<li><a href="#4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</a><ul>
<li><a href="#4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</a></li>
<li><a href="#4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</a></li>
<li><a href="#4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</a></li>
<li><a href="#4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</a></li>
</ul>
</li>
<li><a href="#4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</a><ul>
<li><a href="#4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</a></li>
<li><a href="#4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-raw-ge-shi">4.3 RAW 格式</a><ul>
<li><a href="#4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</a></li>
<li><a href="#6-se-cai-shen-du">6 色彩深度</a></li>
<li><a href="#7-tu-xiang-jie-xi-du-fen-bian-lu">7 图像解析度&#x2F;分辨率</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</span><a href="#1-mipi-csi2-de-fa-song-he-jie-shou" class="header-anchor">#</a></h1><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<p>上图反映了sensor 和 soc 的数据关系，soc 通过 CCI (Camera Control Interface) 控制 sensor 寄存器，配置正确，sensor 将会通过 mipi 接口输出图像数据。</p>
<p>控制信息是 soc 通过 CCI 发送到 sensor，CCI 接口一般的就是 I2C 接口,最大支持400KHz。</p>
<p>data信息是CSI DPHY发送者发送到CSI DPHY接收者，由sensor端发送到soc的mipi-rx。</p>
<h1><span id="2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</span><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi" class="header-anchor">#</a></h1><p>D-PHY 是 MIPI 聯盟發布的高速物理層標準，規定了接口層的物理特性和傳輸協議。 DPHY 採用了 200mV 源同步的低压差分信號技術，每個 Lane 的數據綠率範圍支持到2500Mbps。 D-PHY 可以工作在低功耗 (Low Power, LP) 和高速 (High Speed, HS) 兩種模式下。</p>
<h2><span id="2-1-chuan-shu-mo-shi">2.1 传输模式</span><a href="#2-1-chuan-shu-mo-shi" class="header-anchor">#</a></h2><p><strong>LP（Low-Power） 模式</strong>：用于传输控制信号，最高速率 10 MHz</p>
<p><strong>HS（High-Speed）模</strong>式：用于高速传输数据，速率范围 [80 Mbps， 2.5Gbps] per Lane</p>
<p>传输的最小单元为 1 个字节，采用小端的方式，也就是 LSB first，MSB last。</p>
<p><strong>相关缩写名</strong>词：</p>
<p>HS-RX：高速接收器<br>HS-TX：高速发送器<br>LP-RX：低功耗接收器<br>LP-TX：低功耗发送器<br>LPS:  Low Power State, 封包之間的spacing間距。<br>ST:    Start of Transmission (SoT), 封包的起始訊號, 一般為低速轉換為高速的暫態訊號。<br>ET:    End of Transmission (EoT), 封包的結束訊號, 一般為高速轉換為低速的暫態訊號。<br>PH:   Packet Header, 32 bit表示, 為封包的標頭。<br>PF:    Packet Footer, 16 bit表示, 為封包的結尾。</p>
<h2><span id="2-2-lane-states">2.2 lane states</span><a href="#2-2-lane-states" class="header-anchor">#</a></h2><p>*  LP mode 有 4 种状态： LP00、LP01（<strong>0</strong>）、LP10（<strong>1</strong>）、LP11 （Dp、Dn）</p>
<p>* HS mode 有 2 种状态： HS-0、HS-1</p>
<p>HS 发送器发送的数据 LP 接收器看到的都是 LP00。</p>
<h2><span id="2-3-lane-levels">2.3 Lane Levels</span><a href="#2-3-lane-levels" class="header-anchor">#</a></h2><p>* LP： 0 ~ 1.2V</p>
<p>* HS： 100 ~ 300mV，HS common level &#x3D; 200mV，swing &#x3D; 200 mv</p>
<h2><span id="2-4-cao-zuo-mo-shi">2.4 操作模式</span><a href="#2-4-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p> • 数据Lane的3种操作模式 </p>
<ul>
<li><p>Escape mode,</p>
</li>
<li><p>High-Speed(Burst) mode</p>
</li>
<li><p>Control mode</p>
<p><strong>①Escape mode request</strong><br> LP-11→LP-10→LP-00→LP-01→LP-00<br> exit:LP-10 -&gt; LP-11</p>
</li>
</ul>
<p>当进入 Escape mode 需要发送 8-bit entry command 表明请求的动作，比如要进行低速数据传输则需要发送 cmd： 0x87，进入超低功耗模式则发送 cmd： 0x78。</p>
<p>  <strong>②High-Speed mode request :</strong><br>    LP-11→LP-01→LP-00-&gt;SOT(0001_1101)<br>    exit: EOT -&gt; LP-11</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>③Turnaround request</strong><br>    LP-11→LP-10→LP-00→LP-10→LP-00</p>
<p>这是开启 BTA 的时序，一般用于从 slave 返回数据如 ACK： 0x84.<br>    exit：LP00→LP10→LP11</p>
<p> 最常用的就是“低功耗进入高速模式”如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<p>我们的D0-D4都是一个差分信号，它从lowpower state进入到HS后，从hi speed mode 中sync出我们的data。</p>
<p>sensor控制的信号由绿色框圈出来，主要是以下三个讯号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HS-Prepare：表示从low power mode进入到hi speed mode需要prepare一段时间</span><br><span class="line">Hs-zero: 表示从low power mode进入到hi speed mode需要keep LP-00状态一段时间</span><br><span class="line">Hs-trail:表示送完1 st data后需要keep一段时间后才允许进入low power mode，进行下一轮数据传输。</span><br></pre></td></tr></table></figure>

<p>soc端的控制的信号由黄色框圈出来:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hs-settle:表示soc要等一段时间才去开始去parse “sync code”, 当抓到sync code后表示sensor已经进入了hi speed mode， 这个时候就可以sync data了。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.每次EOT(end of trans)结束讯号后，都会进入low power mode，而不是sensor 工作后就一直处于hi speed mode。也就是每传一个package，都会走一遍上述的过程。</p>
<p>2.hs-settle为mclk&#x2F;8 *n(这个n表示配置几个clk，对应code的话配置这个mipi_dev_attr_s-&gt;dphy)</p>
<p>当hs-settle的时间太长会压到data中的“sync code”,那么就会出现sync code parse不到,出现ecc err. 又或者从data中parse到一个假的“sync code”，那么最后就会出现数据不太对，出现ecc err.</p>
<p>Ecc还有一种出现可能就是lane mapping 出错，当我们传输数据出现ecc err, 有可能就是传输short pack时，4 byte的short pack拼接的不对（详见CSI的数据包结构），导致出现ecc error.</p>
<p>3.如果hs-trail持续的太短（拉高的太快），有可能会压到最后面的data，所以会出现crc&#x2F;wc(word count ) err.另外，如果hs -settle太大，也有可能hs-trail也会是错误的数据，所以出现wc, crc err，因此不一定是hs-trail的问题，得先确保前面的ecc&#x2F;decode无误后再来调整hs-trail。</p>
<p>一般排查流程如下：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<h2><span id="2-5-shi-zhong-mo-shi">2.5 时钟模式</span><a href="#2-5-shi-zhong-mo-shi" class="header-anchor">#</a></h2><ul>
<li>连续时钟模式：数据包传输间隔，clk lane 保持在高速模式；</li>
<li>非连续时钟模式：数据包传输间隔，clk lane 进入 LP-11 状态，退出hi speed mode；</li>
</ul>
<h2><span id="2-6-shi-xu-yao-qiu">2.6 时序要求</span><a href="#2-6-shi-xu-yao-qiu" class="header-anchor">#</a></h2><p>在调试 DSI 或者 CSI 的时候， HS mode 下的几个时序非常重要：T_LPX，T_HS-SETTLE ≈ T_HS-PREPARE + T_HS-ZERO，T_HS-TRAIL，一般遵循的原则为：Host 端的 T_HS-SETTLE &gt; Slave 端的 T_HS-SETTLE。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<h2><span id="2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</span><a href="#2-7-start-of-transmission-sot-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<p>当要进行数据传输的时候，data lane 将会通过信号（SoT）退出停止状态，进入高速模式。过程如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>退出停止状态 ( LP-11 )</td>
<td>检测停止状态</td>
</tr>
<tr>
<td>进入 HS-Rqst 状态 ( LP-01 )，并处于该状态的时间间隔为 TLPX</td>
<td>检测到 lane 从 LP-11 转变为 LP-01</td>
</tr>
<tr>
<td>进入 Bridge 状态 ( LP-00 )，并处于该状态的时间间隔为 THS-PREPARE</td>
<td>检测到 lane 从 LP-01 转变为 LP-00，间隔 TD-TERM-EN 时间之后将使能传输</td>
</tr>
<tr>
<td>同时退出低功耗模式，进入高速模式</td>
<td></td>
</tr>
<tr>
<td>处于 HS-0 状态，时长为 THS-ZERO</td>
<td>使能 HS-RX 并等待 THS-SETTLE，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>开始从数据流中等待同步序列</td>
</tr>
<tr>
<td>时钟上升边缘插入 HS 同步序列 ‘00011101’</td>
<td></td>
</tr>
<tr>
<td></td>
<td>识别到同步序列 ‘00011101’</td>
</tr>
<tr>
<td>高速模式开始传输有效数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>接收到有效数据</td>
</tr>
</tbody></table>
<h2><span id="2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</span><a href="#2-8-end-of-transmission-eot-guo-cheng" class="header-anchor">#</a></h2><p>在数据完成传输时，通过结束传输（EoT）过程，数据通道退出高速模式并进入停止状态，这个过程状态变化如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>传输数据</td>
<td>接收到数据</td>
</tr>
<tr>
<td>在完成最后一个字节数据的传输之后，保持该状态的时间间隔为 THS-TRAIL</td>
<td></td>
</tr>
<tr>
<td>关闭 HS-TX，启用 LP-TX，并在 THS-EXIT一段时间内处于停止状态 ( LP-11 )</td>
<td>检测到 lane 状态进入停止状态 ( LP-11 )，关闭传输功能</td>
</tr>
<tr>
<td></td>
<td>忽略 THS-SKIP一段时间内的 lane 变化，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>检测有效数据的最后一次转换，确定最后一次有效数据并忽略包尾序列</td>
</tr>
</tbody></table>
<p>接收器是如何判断数据将要开始传输了呢？</p>
<p>当出现LP11→LP01→LP00时，接收器将会判断，将会有数据达到，同时，使用示波器查看mipi波形，将会发现在PL00（THS-PREPARE）时会有一个小脉冲（峰刺），一般的，在这个小脉冲之后，接收器将会打开比较器（由于在THS-PREPARE会有这个小脉冲的存在，所以在接收器中，会通过设置接收器的settle time，避开这个小脉冲，在这个脉冲之后再打开比较器），准备接收数据。而HS-00011101则表示有效数据开始，同时数据的开头，将会有数据表明将要数据的数据量，所以mipi接收器将会按其数据量接收，直到接收完成。<br>每根 lane（data lane&#x2F;clk lane）从 LP 模式切换到 HS 模式都会有 LP11→LP01→LP00 这样的一个时序，同时还要检查 HS-00011101 ，HS-00011101 主要是用于同步，只有前面正确采集到 00011101 ，才能保证 clk 和 data 相位一一对应。</p>
<p><strong>mipi csi调试助手：</strong><br>测量 sensor 有相应的 mipi 信号输出，但是主控并没有接收到数据，通过查看主控的 mipi 寄存器发现，mipi接收器还处于 LP 模式，这种情况一般是mipi没有检测到sensor发送的从 LP 进入 HS 的时序。此时可测量sensor 开始输出图像数据时，clk lane 是否有 LP11→LP01→LP00 这样的一个时序。同时，应该先开 mipi，sensor 再开始 mipi 数据传输；<br>由于THS-PREPARE会有一个小脉冲的存在，所以，主控在接收mipi数据的时候，需要通过设置主控的settle time，这个时间需要在这个小脉冲之后，这样接收才不会有问题；<br>当出现 sensor 有数据输出，但是主控没有接收成功，这个情况一般是 mipi 的时序问题，sensor 端的时序没有和主控端的配合好，这个时候，可以尝试的减小sensor端的THS-PREPARE，增大THS-ZERO和THS-TRAIL；<br>由于一些主控的需求，在一帧数据完成之后，需要一定的时间才可以进行相应的ISP处理，当一帧传输完毕之后的LP11时间达不到主控ISP的时间要求导致ISP报错，可通过调节THS-TRAIL时间，以此得到ISP对帧间的时序长度要求 。</p>
<h1><span id="3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</span><a href="#3-csi-2-shu-ju-bao-xie-yi" class="header-anchor">#</a></h1><p>CSI-2 是針對攝像頭的數據協議， 規定了主機與外設通信的數據包格式。CSI-2 可以支持不同像素格式的圖像應用， 數據傳輸的最小粒度是字節。 為增加 CSI-2 的性能，可以選擇數據 Lane 的數量， CSI-2 協議規訂了發送端將像素數據打包成字節的機制， 並指明多個數據 Lane 分配和管理的方式。字節數據以數據包的形式組織，數據包在SoT 與 EoT 之間傳輸。 接收端根據協議解析相應的數據包， 恢復出原始的像素數據。</p>
<p>CSI-2 的數據包分為長包和短包兩種，包含有校驗碼，能進行誤碼糾正和錯誤檢測。長包和短包都是在 SoT 和 EoT 之間傳輸，在數據傳送的間隙， D-PHY 處於 LP 模式。 CSI-2數據包的傳輸機制如圖所示。 PH 和 PF 分別表示 Packet Header 和 Packet Footer。</p>
<h2><span id="3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</span><a href="#3-1-yi-ge-shu-ju-bao-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<h2><span id="3-2-bao-lei-xing">3.2 包类型</span><a href="#3-2-bao-lei-xing" class="header-anchor">#</a></h2><p>• 短包：4 bytes (固定)<br>• 长包：6~65541 bytes (可变) </p>
<h3><span id="3-2-1-duan-bao-jie-gou">3.2.1 短包结构</span><a href="#3-2-1-duan-bao-jie-gou" class="header-anchor">#</a></h3><p><strong>一个short packet（也叫做pack head(PH)）</strong></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p>包结构（4个字节）：<br>    • 数据标识(DI) 1个字节<br>    • WC （长度固定为2个字节）<br>    • 错误检测(ECC) 1个字节</p>
<p>包大小：<br>    • 长度固定为4个字节</p>
<h3><span id="3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</span><a href="#3-2-2-pack-footer-pf-de-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<h3><span id="3-2-3-chang-bao-jie-gou">3.2.3 长包结构</span><a href="#3-2-3-chang-bao-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/10.png" alt="img"></p>
<p>包头部（4个字节）（PH）：<br>• 　　数据标识(DI) 1个字节<br>• 　　数据计数WC (2个字节 )（PH和PF之間的資料個數）<br>• 　　错误检测(ECC) 1个字节<br>•　    数据填充(0~65535 字节)<br>•       长度&#x3D;WC*字节</p>
<p>包尾：校验和（2个字节）(PF)</p>
<p>长包 &#x3D; 短包（包头） + 数据 + 包尾 </p>
<p>包大小：<br>    4 + (0~65535) + 2 &#x3D; 6 ~ 65541 字节</p>
<h3><span id="3-2-4-h-blanking-amp-v-blanking">3.2.4 H-blanking &amp; V-blanking</span><a href="#3-2-4-h-blanking-amp-v-blanking" class="header-anchor">#</a></h3><p>传输多个pack和传输一个pack时对应的图像如下, VVALID&#x2F;HVALID&#x2F;DVALID可以先把它想成是影像的同步訊號VSync&#x2F;HSync&#x2F;DE，而Data就是影像資料，以方便理解。</p>
<p>从图中可以看到，当水平同步讯号HVALID为Low的这段区间，剛好就是每行的Blanking间隔, 也就是H-blanking。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/11.png" alt="img"></p>
<p>从下图可以看到上一FE到下一FS之间的间隔为V-blanking.</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/12.png" alt="img"></p>
<p>frame的封包示意图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/13.png" alt="img"></p>
<h3><span id="3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</span><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/14.png" alt="img"></p>
<p> Data Identifier (DI) 为虚拟通道(VC, 2 bit)和资料类型(DT, 6 bit)组成。</p>
<h4><span id="3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</span><a href="#3-2-5-1-vc-virtual-channel" class="header-anchor">#</a></h4><p>可以看出MIPI最多可以輸入4组影像来源，其ID为0~3，且內容可以是任意的內容，下图就表示用virtual chn来传输不同格式的数据。比如一般Sony, OV的HDR 模式基本都是VC mode，包括2帧HDR, 3帧HDR。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/15.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/16.png" alt="img"></p>
<h4><span id="3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</span><a href="#3-2-5-2-dt-data-type" class="header-anchor">#</a></h4><p>Data Type目前定义多种资料形态，范围从0x00<del>0x3F，其中0x00</del>0x0F为短封包类型，0x10~0x3F为長封包类型，如下表：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/17.png" alt="img"></p>
<p>用于同步的短包Data Type:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/18.png" alt="img"></p>
<p>从<strong>soc到外设</strong>发送的包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/19.png" alt="img"></p>
<p>从<strong>外设到soc</strong>的数据包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/20.png" alt="img"></p>
<h1><span id="4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</span><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi" class="header-anchor">#</a></h1><p>MIPI CSI 共支持五種pixel資料格式的傳輸， 包含 YUV422-8bit、 YUV422-10bit、 RAW8、RAW10 和 RAW12。</p>
<h2><span id="4-1-rgb-ge-shi">4.1 RGB格式</span><a href="#4-1-rgb-ge-shi" class="header-anchor">#</a></h2><p>传统的红绿蓝格式，比如RGB565，RGB888，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RGB565</td>
<td>1. 每个像素用16位表示，RGB分量分别使用5位、6位、5位。2. 内存中排列（高字节-&gt;低字节）：R R R R R G G G G G G B B B B B</td>
</tr>
<tr>
<td>RGB555</td>
<td>1. 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）2. 内存中排列（高字节-&gt;低字节）：X R R R R G G G G G B B B B B（X表示不用，可以忽略）</td>
</tr>
<tr>
<td>RGB24（RGB888）</td>
<td>1. 每个像素用24位表示，RGB分量各使用8位。在内存中RGB各分量的排列顺序为：BGR BGR BGR ……2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R</td>
</tr>
<tr>
<td>ARGB32（ARGB8888）</td>
<td>1. 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R A A A A A A A A</td>
</tr>
</tbody></table>
<h2><span id="4-2-yuv-ge-shi">4.2 YUV格式</span><a href="#4-2-yuv-ge-shi" class="header-anchor">#</a></h2><p>YUV是一种色彩编码方法，是一种彩色编码系统，相对于RGB色彩空间，YUV传输带宽占用更低，传输数据不易出错。</p>
<p>Y’UV、YUV、YCbCr、YPbPr 几个概念其实是一回事儿。由于历史关系，Y’UV、YUV 主要是用在彩色电视中，用于模拟信号表示。YCbCr 是用在数字视频、图像的压缩和传输，如 MPEG、JPEG。今天大家所讲的 YUV 其实就是指 YCbCr。Y 表示亮度（luma），CbCr 表示色度（chroma）。</p>
<p>人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感。所以在视频编码系统中为了降低带宽，可以保存更多的亮度信息(luma)，保存较少的色差信息(chroma)。</p>
<p>luminance 亮度，luma 是在视频编码系统中指亮度值；</p>
<p>chrominance 色度，chroma 是在视频编码系统中指色度值。</p>
<p>Y’UV 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是(UV)，那么在彩色电视显示的时候只显示亮度信息。</p>
<p>YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式。色度(UV)定义了颜色的两个方面─色调与饱和度，分别用CB和CR表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p>
<h3><span id="4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</span><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping" class="header-anchor">#</a></h3><p>原则：在数字图像中<br>    1) 每一个图形像素都要包含 luma（亮度）值；<br>    2）几个图形像素共用一个 Cb + Cr 值，一般是 2、4、8 个像素。</p>
<p>主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。</p>
<h4><span id="4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</span><a href="#4-2-1-1-yuv444-cai-yang" class="header-anchor">#</a></h4><p>全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br></pre></td></tr></table></figure>
<p>那么1920<em>1080文件的大小：1920</em>1080*3（B），那么一个像素对应3个字节。</p>
<h4><span id="4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</span><a href="#4-2-1-2-yuv422-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;3存储空间和1&#x2F;3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。如果水平方向有10个像素点，那么采样了10个Y分量，而只采样了5个UV分量。其中，每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br></pre></td></tr></table></figure>
<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.5+1920<em>1080</em>0.5（B），那么UV的数量减少了一半，相对于YUV444空间节省了1&#x2F;3。</p>
<h4><span id="4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</span><a href="#4-2-1-3-yuv420-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;2存储空间和1&#x2F;2的数据传输量。YUV 420采样，并不是指只采样U分量而不采样V分量。而是指，在每一行扫描时，只扫描一种色度分量（U或者V）和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402，也就是第一行只有U，而第二行只有V。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br></pre></td></tr></table></figure>

<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.25+1920<em>1080</em>0.25（B）相对于YUV444空间节省1&#x2F;2，因此也是比较主流的采样方式。</p>
<h3><span id="4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</span><a href="#4-2-2-yuv-cun-chu-fang-shi" class="header-anchor">#</a></h3><p>YUV的格式有两大类：<strong>planar（平面格式）和packed（打包格式）</strong>。</p>
<h4><span id="4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</span><a href="#4-2-2-1-planner-cun-chu" class="header-anchor">#</a></h4><p>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。</p>
<p>一般默认是3个平面，即y平面，u平面，v平面。但还有一种semi-planar是两个平面。也就是说uv为同一个平面，即一个y平面，一个uv平面。</p>
<h5><span id="4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</span><a href="#4-2-2-1-1-yuv420-planner" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/21.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/22.png" alt="img"></p>
<p>例如：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/23.png" alt="img"></p>
<p>可以看到第一行的Y1Y2和第二行的Y7Y8共同使用一组U1V1。</p>
<h5><span id="4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</span><a href="#4-2-2-1-2-yuv420sp" class="header-anchor">#</a></h5><p> two-planer双平面，Y一个平面，UV在同一个平面交叉存储。也叫做semi-planar的YUV格式。</p>
<ol>
<li><p>nv12</p>
<p>先存储全部的Y分量，然后UV分量交叉存储。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/24.png" alt="img"></p>
</li>
<li><p>nv21</p>
<p>先UV分量交叉存储, 然后存储全部的Y分量。</p>
</li>
</ol>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/25.png" alt="img"></p>
<h5><span id="4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</span><a href="#4-2-2-1-3-yuv422-planner" class="header-anchor">#</a></h5><p>3平面，数据量：u&#x3D;v&#x3D;y&#x2F;2，不画图展示</p>
<h5><span id="4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</span><a href="#4-2-2-1-4-yuv422sp" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/26.png" alt="img"></p>
<p>可以看到y0y82个像素公用一组u0v0。</p>
<h4><span id="4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</span><a href="#4-2-2-2-packed-cun-chu" class="header-anchor">#</a></h4><p>packed的YUV格式，每个像素点的Y、U、V都是连续交叉存储的。</p>
<h5><span id="4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</span><a href="#4-2-2-2-1-yuyv" class="header-anchor">#</a></h5><p>该格式属于4：2：2类型，且是用packed形式存储的，相邻的2个像素共用一个Cb(U)和Cr(V)，以16个像素为例如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/27.png" alt="img"></p>
<h5><span id="4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</span><a href="#4-2-2-2-2-yvyu" class="header-anchor">#</a></h5><p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p>4.2.2.2.2 uyvy</p>
<p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/28.png" alt="img"></p>
<h2><span id="4-3-raw-ge-shi">4.3 RAW 格式</span><a href="#4-3-raw-ge-shi" class="header-anchor">#</a></h2><p>RAW图像就是CMOS或者CCD图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。Raw data（Raw RGB）经过彩色插值就变成RGB。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/29.png" alt="img"></p>
<p>sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B 。</p>
<h3><span id="4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</span><a href="#4-3-1-bayer-zhen-lie" class="header-anchor">#</a></h3><p>人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和，那么bayer格式一般有下面4种：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/30.png" alt="img"></p>
<h1><span id="5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</span><a href="#5-mipi-csi-shu-ju-bao-chuan-shu" class="header-anchor">#</a></h1><p>raw8格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/31.png" alt="img"></p>
<p>raw10格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/32.png" alt="img"></p>
<p>raw12格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/33.png" alt="img"></p>
<p> 从图像看，RAW8是一传输个字节对应一个pixel， 而raw10是5个byte去对应4个pixel，第5个byte用来存储pixel 0~3的bit[0:1]。同理raw12用3个byte存储2个pixel。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/34.png" alt="img"></p>
<h1><span id="6-se-cai-shen-du">6 色彩深度</span><a href="#6-se-cai-shen-du" class="header-anchor">#</a></h1><p>8位彩色，有256种深度。<br>16位彩色：65,536种颜色。<br>24位彩色：每种原色都有256个层次，它们的组合便有256<em>256</em>256种颜色。<br>32位彩色：除了24位彩色的颜色外，额外的8位是储存重叠图层的图形资料(alpha透明度)。</p>
<h1><span id="7-tu-xiang-jie-xi-du-x2f-fen-bian-lu">7 图像解析度&#x2F;分辨率</span><a href="#7-tu-xiang-jie-xi-du-x2f-fen-bian-lu" class="header-anchor">#</a></h1><p>Resolution：</p>
<table>
<thead>
<tr>
<th>1280 * 720 &#x3D; 921600</th>
<th>1M</th>
<th>100万像素</th>
<th>720P</th>
<th>H65 sensor</th>
</tr>
</thead>
<tbody><tr>
<td>1920 * 1080 &#x3D; 2073600</td>
<td>2M</td>
<td>200万像素</td>
<td>1080P</td>
<td>Imx307&#x2F;imx327 sensor</td>
</tr>
<tr>
<td>2560 * 1440 &#x3D; 36864002560 * 1600 &#x3D; 40960002592 * 1944 &#x3D; 5038848</td>
<td>4M&#x2F;5M</td>
<td>400万像素500万像素</td>
<td>2K</td>
<td>Imx335&#x2F;sc4210 sensor</td>
</tr>
<tr>
<td>3840 * 2160 &#x3D; 8294400</td>
<td>8M</td>
<td>800万像素</td>
<td>4K</td>
<td>Imx334 sensor</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/" data-id="clxztkv8t0012touf0ch08nlu" data-title="mipi-csi软件篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-mipi-csi硬件篇" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/" class="article-date">
  <time class="dt-published" datetime="2024-04-02T06:28:07.000Z" itemprop="datePublished">2024-04-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/">mipi-csi硬件篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi-ying-jian">1 mipi-csi硬件</a><ul>
<li><a href="#1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</a></li>
<li><a href="#1-2-mipi-vs-dvp">1.2 MIPI vs DVP</a></li>
<li><a href="#1-3-csi-gui-ge">1.3 CSI规格</a></li>
<li><a href="#1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</a></li>
<li><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</a><ul>
<li><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</a></li>
<li><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</a></li>
</ul>
</li>
<li><a href="#1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</a></li>
<li><a href="#1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# 1 mipi-csi硬件

<h2><span id="1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</span><a href="#1-1-mipi-csi-gai-nian" class="header-anchor">#</a></h2><p><strong>DSI （Display serial interface）</strong>定义了一个位于处理器和显示模组之间的高速串行接口,对应MIPI-TX.<br><strong>CSI(Camera Serial Interface）</strong>定义了一个位于处理器和摄像模组之间的高速串行接口,也就是接下来要讲的MIPI-RX。</p>
<p>MIPI Rx (Mobile Industry Processor Interface Receiver) 模塊主要功能為接收由 CMOS sensor 所傳送的視頻數據， 支持 MIPI D-PHY、 sub-LVDS (Low-Voltage Differential Signal)、 HiSPi (High-Speed Serial Pixel Interface) 等不同的串行視頻信號輸入， 並將其處理轉化為內部視頻時序，傳遞給下一級的視頻處理模塊 (ISP)。MIPI Rx 模塊中可細分為 PHY 和 Controller 兩部分，其中 PHY 模塊集成了模擬和數字兩個部分，主要將串行信號轉換為並行信號，而 Controller 模塊則負責解碼不同的視頻數據格式，傳送給後端的視頻處理模塊 (ISP)。功能框圖及在系統中的位置如下图所示:</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<h2><span id="1-2-mipi-vs-dvp">1.2 MIPI vs DVP</span><a href="#1-2-mipi-vs-dvp" class="header-anchor">#</a></h2><p><strong>DVP:</strong></p>
<p>并口传输数据需要帧同步信号（Vsync）、行同步信号（Hsync）和八条数据线，共十根数据线, DVP 接口在信号完整性方面受限制，速率也受限制。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>MIPI:</strong></p>
<p>MIPI 传输只需要帧同步信号（Vsync）、行同步信号（Hsync）、mipi 时钟（mipi_clk）、mipi 数据（mipi_data）和像素时钟（PCLK）5 根数据线。对比MIPI 接口比 DVP 的接口信号线少，由于是低压差分信号，产生的干扰小，抗干扰能力也强。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<h2><span id="1-3-csi-gui-ge">1.3 CSI规格</span><a href="#1-3-csi-gui-ge" class="header-anchor">#</a></h2><p>可同時支持 2 路 sensor 輸入（2组D-PHY， 每组5对差分线（1C4D））</p>
<p>• sensor 0 最大支持 4K2K @60fps HDR or @30fps 線性輸入</p>
<p>• sensor 1 最大支持 3M(2304x1296) @60fps HDR or linear 輸入</p>
<p>• 單路最多支持 4-Lane MIPI D-PHY 接口，最大支持 2.5Gbps&#x2F;Lane</p>
<p>• 單路最多支持 4-Lane sub-LVDS&#x2F; HiSPi 接口，最大支持 1.5Gbps&#x2F;Lane</p>
<p>• 支持 RAW8&#x2F; RAW10&#x2F; RAW12 數據類型的解析</p>
<p>• 支持 YUV422 8-bit&#x2F; YUV422 10-bit 數據類型的解析</p>
<p>• 最多支持 2 幀 WDR，支持多種 WDR 時序</p>
<p>• 支持 sub-LVDS&#x2F; HiSPi 模式像素&#x2F;同步碼大小端配置</p>
<p>• 支持 Lane 數和 Lane 順序可配置</p>
<p>MIPI Rx 的帶寬有兩部分限制： PHY 的接口數據率和內部處理速度。</p>
<p>輸入接口最大支持 2.5Gbps&#x2F;Lane，內部處理速度最大為 600M*1pixels&#x2F;s（MAC clk）</p>
<h2><span id="1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</span><a href="#1-4-csi-jie-kou-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>Common modevoltage</th>
<th>Differential modevoltage</th>
<th>Maximum clockfrequency</th>
<th>Maximum datarate per lane</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MIPI DPHY</strong> 200mV</td>
<td>200mV</td>
<td>1.25GHz</td>
<td>2.5Gbps</td>
</tr>
<tr>
<td>Sub-LVDS 900mV</td>
<td>150mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(HiVCM) 900mV</td>
<td>280mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(SLVDS) 200mV</td>
<td>200mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
</tbody></table>
<h2><span id="1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</span><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian" class="header-anchor">#</a></h2><p>常用的电脑摄像头是USB接口, 主流的智能手机摄像头是MIPI接口, 下面讲解常用的智能手机 camera MIPI接口。</p>
<p>MIPI CSI一般会有1对I2C通信引脚，1对MIPI差分时钟引脚和1~4对MIPI差分数据信号引脚, 也就是1CD4(1 clk lane &amp; 4 data lane)。</p>
<h3><span id="1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</span><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>信号名</th>
<th>引脚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DOVDD</td>
<td>电源</td>
<td>1.8V IO 电源</td>
</tr>
<tr>
<td>DVDD</td>
<td>电源</td>
<td>1.2V 数字电源</td>
</tr>
<tr>
<td>AVDD</td>
<td>电源</td>
<td>2.8V 模拟电源</td>
</tr>
<tr>
<td>SCL</td>
<td>输入</td>
<td>I2C 时钟线</td>
</tr>
<tr>
<td>SDA</td>
<td>输入&#x2F;输出</td>
<td>I2C 数据线(open drain)</td>
</tr>
<tr>
<td>SID0</td>
<td>输入</td>
<td>I2C Device ID 的选择 0 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>SID1</td>
<td>输入</td>
<td>I2C Device ID 的选择 1 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>XSHUTDN （RST）</td>
<td>输入</td>
<td>复位信号输入(内置上拉电阻，低电位有效)</td>
</tr>
<tr>
<td>EXTCLK</td>
<td>输入</td>
<td>时钟输入</td>
</tr>
<tr>
<td>PWDNB</td>
<td>输入</td>
<td>Power Down 信号输入(内置上拉电阻， 低电位有效)</td>
</tr>
<tr>
<td>D&lt;3&gt;(MD3P)</td>
<td>输出</td>
<td>DVP 输出 bit[3]&#x2F;MIPI 数据 3 正极信号</td>
</tr>
<tr>
<td>D&lt;5&gt;(MD1P)</td>
<td>输出</td>
<td>DVP 输出 bit[5]&#x2F;MIPI 数据 1 正极信号</td>
</tr>
<tr>
<td>D&lt;7&gt;(MCP)</td>
<td>输出</td>
<td>DVP 输出 bit[7]&#x2F;MIPI 时钟正极信号</td>
</tr>
<tr>
<td>D&lt;8&gt;(MD0P)</td>
<td>输出</td>
<td>DVP 输出 bit[8]&#x2F;MIPI 数据 0 正极信号</td>
</tr>
<tr>
<td>D&lt;10&gt;(MD2P)</td>
<td>输出</td>
<td>DVP 输出 bit[10]&#x2F;MIPI 数据 2 正极信号</td>
</tr>
<tr>
<td>D&lt;4&gt;(MD3N)</td>
<td>输出</td>
<td>DVP 输出 bit[4]&#x2F;MIPI 数据 3 负极信号</td>
</tr>
<tr>
<td>D&lt;6&gt;(MD1N)</td>
<td>输出</td>
<td>DVP 输出 bit[6]&#x2F;MIPI 数据 1 负极信号</td>
</tr>
<tr>
<td>PCLK(MCN)</td>
<td>输出</td>
<td>DVP 输出时钟&#x2F;MIPI 时钟负极信号</td>
</tr>
<tr>
<td>D&lt;9&gt;(MD0N)</td>
<td>输出</td>
<td>DVP 输出 bit[9]&#x2F;MIPI 数据 0 负极信号</td>
</tr>
<tr>
<td>D&lt;11&gt;(MD2N)</td>
<td>输出</td>
<td>DVP 输出 bit[11]&#x2F;MIPI 数据 2 负极信号</td>
</tr>
</tbody></table>
<h3><span id="1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</span><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<p>一般mipi接口的sensor支持4 lane，2 lane，1 lane等数据传输方式。上图硬件上的连接了1组clk lane, 4组data lane。这幅图只连接了i2c和lane总线，还有EXTCLK ，PWDN, RST, VDD等引脚的连线需要外部soc去提供。这里就需要驱动人员会看原理图，知道lane id和pn swap的接线。clk lane, data lane等。</p>
<h2><span id="1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</span><a href="#1-6-chai-fen-xin-hao-jie-shao" class="header-anchor">#</a></h2><p>我们用一个方法对差分信号做一下比喻，差分信号就好比是跷跷板上的两个人，当一个人被跷上去的时候，另一个人被跷下来了 - 但是他们的平均位置是不变的。继续跷跷板的类推，正值可以表示左边的人比右边的人高，而负值表示右边的人比左边的人高。0 表示两个人都是同一水平。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<p>下图，应用到电学上，这两个跷跷板用一对标识为V+和V-的导线来表示。当V+ &gt; V-时，信号定义成正极信号，V+ &lt; V-时，信号定义成负极信号。 差分对的平均电压设置成 2.5V。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<h2><span id="1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</span><a href="#1-7-mipi-sensor-de-power-on-shi-xu" class="header-anchor">#</a></h2><p><strong>Sony imx334：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p><strong>SC4210：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<p>这里列举了sony imx334和格科微gc2093, sc4210的上电时序，现在市面上大部分的mipi接口sensor都可以让VDD，PWDN, RST，EXTCLK讯号同时发出，然后过一段时间后就可以进行I2c通信了。</p>
<p>在HW交接到SW后，要确保最基本的power on时序是ok的，最好是用示波器对VDD，PWDN, RST，EXTCLK，I2c等波形进行测量无误后再porting到SW手上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/" data-id="clxztkv8t0010toufe51y6bw5" data-title="mipi-csi硬件篇" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vim配置成类似source-insight的IDE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/" class="article-date">
  <time class="dt-published" datetime="2024-04-01T10:05:19.000Z" itemprop="datePublished">2024-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/">Vim配置成类似source-insight的IDE</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#qian-yan">前言</a><ul>
<li><a href="#ji-ben-an-zhuang">基本安装</a></li>
</ul>
</li>
<li><a href="#1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</a><ul>
<li><a href="#1-1-ctag-zuo-yong">1.1 ctag作用</a></li>
<li><a href="#1-2-an-zhuang-ctags">1.2 安装ctags</a></li>
<li><a href="#1-3-an-zhuang-taglist">1.3 安装taglist</a></li>
<li><a href="#1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</a><ul>
<li><a href="#1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</a></li>
</ul>
</li>
<li><a href="#1-5-pei-zhi-vimrc">1.5 配置.vimrc</a></li>
</ul>
</li>
<li><a href="#2-ctags-taglist-shi-yong">2 ctags + taglist使用</a><ul>
<li><a href="#2-1-ctags-shi-yong">2.1 ctags使用</a><ul>
<li><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</a></li>
<li><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</a></li>
<li><a href="#2-1-3-jia-zai-tags">2.1.3 加载tags</a></li>
<li><a href="#2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</a></li>
<li><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</a></li>
<li><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</a></li>
<li><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</a></li>
</ul>
</li>
<li><a href="#2-2-taglist-shi-yong">2.2 taglist使用</a><ul>
<li><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</a></li>
<li><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</a></li>
<li><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-nerdtree-cha-jian">3 NERDTree插件</a><ul>
<li><a href="#3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</a><ul>
<li><a href="#3-1-1-an-zhuang">3.1.1 安装</a></li>
<li><a href="#3-1-2-pei-zhi">3.1.2 配置</a></li>
</ul>
</li>
<li><a href="#3-2-shi-yong-nerdtree">3.2 使用NERDTree</a><ul>
<li><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</a></li>
<li><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</a></li>
<li><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</a></li>
<li><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</a><ul>
<li><a href="#4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</a></li>
<li><a href="#4-2-srcexpl-shi-yong">4.2 SrcExpl使用</a><ul>
<li><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</a><ul>
<li><a href="#5-1-an-zhuang-pei-zhi">5.1 安装配置</a></li>
<li><a href="#5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</a></li>
</ul>
</li>
<li><a href="#6-cscope-cha-jian">6 cscope插件</a><ul>
<li><a href="#6-1-an-zhuang">6.1 安装</a></li>
<li><a href="#6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</a></li>
<li><a href="#6-3-pei-zhi-vimrc">6.3 配置.vimrc</a></li>
<li><a href="#6-5-shi-yong">6.5 使用</a><ul>
<li><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</a></li>
<li><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</a></li>
<li><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-source-insight-kuo-zhan">7 source insight扩展</a><ul>
<li><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><h2><span id="ji-ben-an-zhuang">基本安装</span><a href="#ji-ben-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install vim vim-scripts vim-doc
</code></pre>
<p>vim-scripts是vim的一些基本插件，包括语法高亮的支持、缩进等等。<br>整体配置好后效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/1.png" alt="image"></p>
<h1><span id="1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</span><a href="#1-ctags-taglist-an-zhuang-pei-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-ctag-zuo-yong">1.1 ctag作用</span><a href="#1-1-ctag-zuo-yong" class="header-anchor">#</a></h2><p>ctags 最先是用来生成C代码的tags文件，后来扩展成可以生成各类语言的tags, 有些语言也有专有的tags生成工具（比如java的jtags, python的 ptags)，因此ctag用来进行vim阅读源码时进行函数，变量的快速定位跳转。</p>
<h2><span id="1-2-an-zhuang-ctags">1.2 安装ctags</span><a href="#1-2-an-zhuang-ctags" class="header-anchor">#</a></h2><pre><code>sudo apt-get install ctags
</code></pre>
<h2><span id="1-3-an-zhuang-taglist">1.3 安装taglist</span><a href="#1-3-an-zhuang-taglist" class="header-anchor">#</a></h2><p>taglist_46.zip压缩包：解压到~&#x2F;.vim目录下即可。<br><a target="_blank" rel="noopener" href="https://www.vim.org/scripts/script.php?script_id=273">https://www.vim.org/scripts/script.php?script_id=273</a></p>
<pre><code>mkdir ~/.vim
cd ~/.vim
unzip taglist_46.zip
</code></pre>
<h2><span id="1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</span><a href="#1-4-chuang-jian-tags-wen-jian" class="header-anchor">#</a></h2><p><code>$ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q</code><br>如果为了简单，也可以只进行：<br><code>$ctags -R *</code><br>不过，这种成员变量没有包含在里面。所以可能有些对象的成员时无法跳转。</p>
<h3><span id="1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</span><a href="#1-4-1-pei-zhi-xuan-xiang" class="header-anchor">#</a></h3><pre><code>  $ ctags -R　　　　　　　　　　　　　  #递归的为当前目录及子目录下的所有代码文件生成tags文件 (推荐使用此命令)
  $ ctags filename.c filename1.c file.h 　#为当前目录某些源码生成tags文件
  $ ctags *.c *.h　　　　　　　　　　　   #为当前目录所有.c, .h源码生成tags文件

  为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c++参数主要是：ctags -R --c++-kinds=+px --fields=+iaS --extra=+q
  其中：
    选项c++-kinds 用于指定C++语言的 tags记录类型,  --c-kinds用于指定c语言的，  通用格式是  --&#123;language&#125;-kinds
    选项 fileds 用于指定每条标记的扩展字段域
    extra 选项用于增加额外的条目:   f表示为每个文件增加一个条目，  q为每个类增加一个条目
</code></pre>
<h2><span id="1-5-pei-zhi-vimrc">1.5 配置.vimrc</span><a href="#1-5-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;--------------display-----------------
set nu                          &quot;行号
syntax on                       &quot;语法高亮
set ruler                       &quot;显示当前行和列
set showcmd                     &quot;显示部分命令
set showmode            &quot;最后一行显示当前模式
&quot;set match                      &quot;显示括号匹配
&quot;--------------display-----------------

&quot;---------------input------------------
set smartindent         &quot;自动缩进
set expandtab           &quot;将tab转化为空格
set smarttab            &quot;插入tab使用shiftwidth
set shiftwidth=4        &quot;缩进列数为4
&quot;---------------input------------------

&quot;---------------search-----------------
set hlsearch            &quot;搜索结果高亮显示
&quot;set inccase                    &quot;预览搜索结果
set ignorecase          &quot;不区分大小写
set smartcase           &quot;当有大写字母时区分大小写
&quot;---------------search-----------------

&quot;---------------encoding----------------
set encoding=utf-8              &quot;设置编码格式
set fileencodings=utf-8,gb18030,gbk,gb2312,big5
set termencoding=utf-8


&quot;--------------ctags----------------
set tags=tags;
set autochdir        &quot;通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。
&quot;--------------ctags----------------


&quot;--------------taglist----------------
let Tlist_Use_Left_Window=1             &quot;vim左侧窗口显示Taglist
let Tlist_Exit_OnlyWindow=1             &quot;Taglist是最后一个窗口是退出vim
let Tlist_WinWidth=60           &quot;设置Taglist窗口宽度为60
nmap &lt;F2&gt; :Tlist&lt;CR&gt;                    &quot;设置快捷键&lt;F2&gt;打开Taglist
&quot;--------------taglist----------------
</code></pre>
<h1><span id="2-ctags-taglist-shi-yong">2 ctags + taglist使用</span><a href="#2-ctags-taglist-shi-yong" class="header-anchor">#</a></h1><h2><span id="2-1-ctags-shi-yong">2.1 ctags使用</span><a href="#2-1-ctags-shi-yong" class="header-anchor">#</a></h2><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/2.png" alt="image"></p>
<h3><span id="2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</span><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/3.png" alt="image"></p>
<h3><span id="2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</span><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/4.png" alt="image"></p>
<h3><span id="2-1-3-jia-zai-tags">2.1.3 加载tags</span><a href="#2-1-3-jia-zai-tags" class="header-anchor">#</a></h3><p>默认从创建tags的目录去启动vim打开文件会自动加载当前目录的tags文件，因此可以直接跳转：<br>如我是从uboot根目录建立的tags文件，然后：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p>这样自动加载tags文件，能够进行跳转。<br>如果进入其他目录：可以看到就无法打开tags文件。</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ cd  drivers/usb/gadget/
book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/5.png" alt="image"></p>
<p>vim进入命令模式输入：</p>
<pre><code>:set tags+=&#39;/home/book/ftp/openedv/uboot-2016/tags
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/6.png" alt="image"><br>此时就可以正常跳转了。</p>
<h3><span id="2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</span><a href="#2-1-4-zi-dong-jia-zai-tags" class="header-anchor">#</a></h3><p>在~&#x2F;.vimrc文件中添加下面两行：</p>
<pre><code>set tags=tags;
set autochdir
</code></pre>
<p>通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。<br>这样就可以在不用在tags根路径去使用vim了。如：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/7.png" alt="image"></p>
<h3><span id="2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</span><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/8.png" alt="image"><br>可以看到有2处地方匹配，一个是cmd&#x2F;bootm.c，一个是include&#x2F;command.h<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/9.png" alt="image"></p>
<h3><span id="2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</span><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/10.png" alt="image"><br>输入:q退出分割窗口。</p>
<h3><span id="2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</span><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu" class="header-anchor">#</a></h3><p>例如stitch_event_handler_th函数位于当前tags目录中的stitch&#x2F;common&#x2F;stitch.c的第1212行。只需确保在tags中的子目录中任意位置输入：</p>
<p><code>robin.lee@WORKSTATION5:/robin.lee/zip/A2/osdrv/interdrv/v2/dwa$ vi -t stitch_event_handler_th</code><br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/11.png" alt="image"></p>
<h2><span id="2-2-taglist-shi-yong">2.2 taglist使用</span><a href="#2-2-taglist-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</span><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/12.png" alt="image"></p>
<h3><span id="2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</span><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/13.png" alt="image"></p>
<p>例如光标位置处于vim窗口的第1211行，按下ctrl w w键（w按2次），光标会跳到左边taglist窗口。按上下左右方向键可以查找宏定义，符号，函数等。再次按ctrl w w又会跳到vim的窗口。</p>
<h3><span id="2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</span><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/14.png" alt="image"><br>比如现在光标位于taglist界面的stitch_src_qbuf位置，按下回车会跳转到函数定义的具体位置：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/15.png" alt="image"></p>
<h1><span id="3-nerdtree-cha-jian">3 NERDTree插件</span><a href="#3-nerdtree-cha-jian" class="header-anchor">#</a></h1><p>NERDTree是Vim界面显示树形目录的文件管理器插件，可在vim操作界面进行文件打开、目录浏览操作。</p>
<h2><span id="3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</span><a href="#3-1-an-zhuang-pei-zhi-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-1-1-an-zhuang">3.1.1 安装</span><a href="#3-1-1-an-zhuang" class="header-anchor">#</a></h3><p><a target="_blank" rel="noopener" href="https://www.vim.org/scripts/script.php?script_id=1658">https://www.vim.org/scripts/script.php?script_id=1658</a><br>下载后放到~&#x2F;.vim目录，解压即可完成安装。</p>
<h3><span id="3-1-2-pei-zhi">3.1.2 配置</span><a href="#3-1-2-pei-zhi" class="header-anchor">#</a></h3><p><code>vi ~/.vimrc</code><br>添加如下配置：</p>
<pre><code>&quot;--------------NERDTree---------------
let NERDTreeWinPos=&#39;right&#39;		&quot;设置窗口在右侧
nmap &lt;F8&gt; :NERDTree&lt;CR&gt;			&quot;设置快捷键F8打开
let NERDTreeWinSize=40		 	&quot;窗口大小为40
&quot;--------------NERDTree---------------
</code></pre>
<h2><span id="3-2-shi-yong-nerdtree">3.2 使用NERDTree</span><a href="#3-2-shi-yong-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</span><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/16.png" alt="image"></p>
<h3><span id="3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</span><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/17.png" alt="image"><br>光标原本再右边窗口，输入ctrl w w(w按2次)切换到左边vim窗口。</p>
<h3><span id="3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</span><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p>同理，和taglist一样，也是光标移动到具体文件后回车即可跳转到具体文件。方向键上下移动选择具体文件。跳转到stitch_ctx.h：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/18.png" alt="image"></p>
<h3><span id="3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</span><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu" class="header-anchor">#</a></h3><p>选择‘up a dir’，按回车：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/19.png" alt="image"><br>返回上一层目录的结果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/20.png" alt="image"></p>
<h1><span id="4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</span><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao" class="header-anchor">#</a></h1><p>SrcExpl（源资源管理器）是一个源代码资源管理器，通过显示函数或类型定义来显示当前选定的关键字或在单独的窗口中声明。该插件旨在重新创建上下文 IDE 中可用的窗口。</p>
<p>结合“Taglist”和“NERD tree”效果更佳。</p>
<h2><span id="4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</span><a href="#4-1-srcexp-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>安装：<br><a target="_blank" rel="noopener" href="https://github.com/wenlongche/SrcExpl">https://github.com/wenlongche/SrcExpl</a><br><a target="_blank" rel="noopener" href="https://www.vim.org/scripts/script.php?script_id=2179">https://www.vim.org/scripts/script.php?script_id=2179</a><br>下载后放入<del>&#x2F;.vim进行解压即可。<br>配置：<br>打开</del>&#x2F;.vimrc,添加如下配置：</p>
<pre><code>&quot; // The switch of the Source Explorer
nmap &lt;F12&gt; :SrcExplToggle&lt;CR&gt;

&quot; // Set the height of Source Explorer window
let g:SrcExpl_winHeight = 16

&quot; // Set 100 ms for refreshing the Source Explorer
let g:SrcExpl_refreshTime = 500

&quot; // Set &quot;Enter&quot; key to jump into the exact definition context
let g:SrcExpl_jumpKey = &quot;&lt;ENTER&gt;&quot;

&quot; // Set &quot;Space&quot; key for back from the definition context
let g:SrcExpl_gobackKey = &quot;&lt;SPACE&gt;&quot;

&quot; // In order to avoid conflicts, the Source Explorer should know what plugins except
&quot; // itself are using buffers. And you need add their buffer names into below list
&quot; // according to the command &quot;:buffers!&quot;
let g:SrcExpl_pluginList = [
        \ &quot;__Tag_List__&quot;,
        \ &quot;_NERD_tree_&quot;,
        \ &quot;Source_Explorer&quot;
    \ ]

&quot; // The color schemes used by Source Explorer. There are five color schemes
&quot; // supported for now - Red, Cyan, Green, Yellow and Magenta. Source Explorer
&quot; // will pick up one of them randomly when initialization.
let g:SrcExpl_colorSchemeList = [
        \ &quot;Red&quot;,
        \ &quot;Cyan&quot;,
        \ &quot;Green&quot;,
        \ &quot;Yellow&quot;,
        \ &quot;Magenta&quot;
    \ ]

&quot; // Enable/Disable the local definition searching, and note that this is not
&quot; // guaranteed to work, the Source Explorer doesn&#39;t check the syntax for now.
&quot; // It only searches for a match with the keyword according to command &#39;gd&#39;
let g:SrcExpl_searchLocalDef = 1

&quot; // Workaround for Vim bug @https://goo.gl/TLPK4K as any plugins using autocmd for
&quot; // BufReadPre might have conflicts with Source Explorer. e.g. YCM, Syntastic etc.
let g:SrcExpl_nestedAutoCmd = 1

&quot; // Do not let the Source Explorer update the tags file when opening
let g:SrcExpl_isUpdateTags = 0

&quot; // Use &#39;Exuberant Ctags&#39; with &#39;--sort=foldcase -R .&#39; or &#39;-L cscope.files&#39; to
&quot; // create/update the tags file
let g:SrcExpl_updateTagsCmd = &quot;ctags --sort=foldcase -R .&quot;

&quot; // Set &quot;&lt;F12&gt;&quot; key for updating the tags file artificially
let g:SrcExpl_updateTagsKey = &quot;&lt;F12&gt;&quot;

&quot; // Set &quot;&lt;F3&gt;&quot; key for displaying the previous definition in the jump list
let g:SrcExpl_prevDefKey = &quot;&lt;F3&gt;&quot;

&quot; // Set &quot;&lt;F4&gt;&quot; key for displaying the next definition in the jump list
let g:SrcExpl_nextDefKey = &quot;&lt;F4&gt;&quot;
</code></pre>
<h2><span id="4-2-srcexpl-shi-yong">4.2 SrcExpl使用</span><a href="#4-2-srcexpl-shi-yong" class="header-anchor">#</a></h2><h3><span id="4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</span><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl" class="header-anchor">#</a></h3><h1><span id="5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</span><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian" class="header-anchor">#</a></h1><h2><span id="5-1-an-zhuang-pei-zhi">5.1 安装配置</span><a href="#5-1-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>先安装编译依赖工具：</p>
<pre><code>sudo apt install build-essential cmake python-dev python3-dev clang
</code></pre>
<p>下载YouCompleteMe源码：</p>
<pre><code>git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/
cd .vim/bundle/YouCompleteMe
git submodule update --init --recursive
</code></pre>
<p>编译安装 YouCompleteMe:</p>
<pre><code>./install.py --clang-completer
</code></pre>
<p>安装好后打印如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/21.png" alt="image"></p>
<h2><span id="5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</span><a href="#5-2-youcompleteme-shi-yong" class="header-anchor">#</a></h2><p>.vimrc添加配置：</p>
<pre><code>let g:ycm_global_ycm_extra_conf = &#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;
set runtimepath+=~/.vim/bundle/YouCompleteMe
autocmd InsertLeave * if pumvisible() == 0|pclose|endif
inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;
imap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
vmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
nmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
</code></pre>
<p>vim版本比较低达不到插件YCM的要求从而报错【YouCompleteMe unavailable: requires Vim 8.1.2269+.】，这样也好解决，从github上重新下最新版本的vim即可。命令如下所示：</p>
<pre><code>cd /usr/local/share
sudo git clone https://github.com/vim/vim.git
cd vim/src
sudo ./configure --with-features=huge \
--enable-multibyte \
--enable-rubyinterp=yes \
--enable-pythoninterp=yes \
--enable-python3interp=yes \
--prefix=/usr/local/vim82
</code></pre>
<p>之后make和make install一下，命令如下所示：</p>
<pre><code>sudo make
sudo make install
</code></pre>
<p>在&#x2F;usr&#x2F;bin目录下建立符号链接，命令如下所示：</p>
<pre><code>sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim82
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vi
</code></pre>
<p>补齐效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/22.png" alt="image"><br>输入vim –version信息可以看vim版本号，现已经v9.1,默认应该是8.1的。<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/23.png" alt="image"></p>
<p>vim配色方案：<br><a target="_blank" rel="noopener" href="https://github.com/flazz/vim-colorschemes">https://github.com/flazz/vim-colorschemes</a><br>设置函数高亮：</p>
<pre><code>vi /usr/share/vim/vim91/syntax/c.vim

&quot;highlight Functions
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1
hi cFunctions gui=NONE cterm=bold  ctermfg=40
</code></pre>
<h1><span id="6-cscope-cha-jian">6 cscope插件</span><a href="#6-cscope-cha-jian" class="header-anchor">#</a></h1><h2><span id="6-1-an-zhuang">6.1 安装</span><a href="#6-1-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install cscope
</code></pre>
<h2><span id="6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</span><a href="#6-2-pei-zhi-chan-sheng-cscope-out" class="header-anchor">#</a></h2><pre><code>cscope -Rbqk

-R: 在生成索引文件时，搜索子目录树中的代码
-b: 只生成索引文件，不进入cscope的界面
-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度
-k: 在生成索引文件时，不搜索/usr/include目录
-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”–“，表示由标准输入获得文件列表。
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/24.png" alt="image"></p>
<h2><span id="6-3-pei-zhi-vimrc">6.3 配置.vimrc</span><a href="#6-3-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; cscope setting
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
if has(&quot;cscope&quot;)
  set csprg=/usr/bin/cscope
  set csto=1
  set cst
  set nocsverb
  &quot; add any database in current directory
  if filereadable(&quot;cscope.out&quot;)
      cs add cscope.out
  endif
  set csverb
endif

nmap &lt;C-@&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;
nmap &lt;C-@&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;

set cscopequickfix=s-,c-,d-,i-,t-,e-
</code></pre>
<h2><span id="6-5-shi-yong">6.5 使用</span><a href="#6-5-shi-yong" class="header-anchor">#</a></h2><h3><span id="6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</span><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs add ./cscope.out
</code></pre>
<h3><span id="6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</span><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs show
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/25.png" alt="image"></p>
<h3><span id="6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</span><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi" class="header-anchor">#</a></h3><pre><code>:cs f s symbol #查看symbol和引用的地方, 如:cs find s IDLE_TIMEOUT_MS
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/26.png" alt="image"></p>
<h1><span id="7-source-insight-kuo-zhan">7 source insight扩展</span><a href="#7-source-insight-kuo-zhan" class="header-anchor">#</a></h1><h2><span id="7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</span><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight" class="header-anchor">#</a></h2><p><a target="_blank" rel="noopener" href="https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE">https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/" data-id="clxztkv8n0008touf0l3pgoh5" data-title="Vim配置成类似source-insight的IDE" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 20px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.25px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 10px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 18.75px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 17.5px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12.5px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">中断体系</a> <a href="/tags/%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.25px;">外设驱动</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11.25px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.5px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13.75px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/18/Linux%E5%86%85%E6%A0%B8%E9%A1%B6%E5%B1%82Makefile%E8%AF%A6%E8%A7%A3/">Linux内核顶层Makefile详解</a>
          </li>
        
          <li>
            <a href="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/">Makefile-常用函数和通用模板</a>
          </li>
        
          <li>
            <a href="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/">uboot-menuconfig和Kconfig图像化配置</a>
          </li>
        
          <li>
            <a href="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/">uboot-bootm和bootz启动内核</a>
          </li>
        
          <li>
            <a href="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">uboot-启动流程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>