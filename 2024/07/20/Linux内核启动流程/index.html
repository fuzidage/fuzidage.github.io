<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Linux内核启动流程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 链接脚本vmlinux.lds 2 Linux 内核启动流程 2.0 Linux kernel启动流程概述 2.1pre linux内核镜像解压 2.1 Linux 内核入口 stext 2.1.0 __create_page_tables 2.1.1 __enable_mmu 2.1.1.1 __mmap_switched 2.1.1.1.1 start_kernel 2.1.1.">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核启动流程">
<meta property="og:url" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 链接脚本vmlinux.lds 2 Linux 内核启动流程 2.0 Linux kernel启动流程概述 2.1pre linux内核镜像解压 2.1 Linux 内核入口 stext 2.1.0 __create_page_tables 2.1.1 __enable_mmu 2.1.1.1 __mmap_switched 2.1.1.1.1 start_kernel 2.1.1.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/0.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.1.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.2.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png">
<meta property="article:published_time" content="2024-07-20T06:13:25.000Z">
<meta property="article:modified_time" content="2024-08-10T09:25:22.796Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="linux系统构建">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/0.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux内核启动流程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-07-20T06:13:25.000Z" itemprop="datePublished">2024-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Linux内核启动流程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</a></li>
<li><a href="#2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</a><ul>
<li><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</a></li>
<li><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</a></li>
<li><a href="#2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</a><ul>
<li><a href="#2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></a></li>
<li><a href="#2-1-1-enable-mmu">2.1.1 <code>__enable_mmu</code></a><ul>
<li><a href="#2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></a><ul>
<li><a href="#2-1-1-1-1-start-kernel">2.1.1.1.1 start_kernel</a><ul>
<li><a href="#2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</a></li>
<li><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</a></li>
<li><a href="#2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</a><ul>
<li><a href="#2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</a><ul>
<li><a href="#2-2-1-1-driver-init">2.2.1.1 driver_init</a></li>
<li><a href="#2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</a></li>
<li><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</a><ul>
<li><a href="#2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</a><ul>
<li><a href="#2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</a><ul>
<li><a href="#3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</a></li>
<li><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</a><ul>
<li><a href="#3-2-1-do-initcalls">3.2.1 do_initcalls</a><ul>
<li><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-lian-jie-jiao-ben-vmlinux-lds">1 链接脚本vmlinux.lds</span><a href="#1-lian-jie-jiao-ben-vmlinux-lds" class="header-anchor">#</a></h1><p>先编译一下 Linux 源码，因为有很多文件是需要编译才会生成的。首先分析 Linux 内核的连接脚本文件 <code>arch/arm/kernel/vmlinux.lds</code>，通过链接脚本可以找到 Linux 内核的第一行程序是从哪里执行的。vmlinux.lds 中有如下代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">492</span> OUTPUT_ARCH(arm)</span><br><span class="line"><span class="number">493</span> ENTRY(stext)</span><br><span class="line"><span class="number">494</span> jiffies = jiffies_64;</span><br><span class="line"><span class="number">495</span> SECTIONS</span><br><span class="line"><span class="number">496</span> &#123;</span><br><span class="line"><span class="number">497</span> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">498 	* <span class="doctag">XXX:</span> The linker does not define how output sections are</span></span><br><span class="line"><span class="comment">499 	* assigned to input sections when there are multiple statements</span></span><br><span class="line"><span class="comment">500 	* matching the same input section name. There is no documented</span></span><br><span class="line"><span class="comment">501 	* order of matching.</span></span><br><span class="line"><span class="comment">502 	*</span></span><br><span class="line"><span class="comment">503 	* unwind exit sections must be discarded before the rest of the</span></span><br><span class="line"><span class="comment">504 	* unwind sections get included.</span></span><br><span class="line"><span class="comment">505 	*/</span></span><br><span class="line"><span class="number">506</span> 	/DISCARD/ : &#123;</span><br><span class="line"><span class="number">507</span> 	*(.ARM.exidx.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">508</span> 	*(.ARM.extab.<span class="built_in">exit</span>.text)</span><br><span class="line"><span class="number">509</span> 	</span><br><span class="line">......</span><br><span class="line"><span class="number">645</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ENTRY 指明了了 Linux 内核入口，入口为 stext，stext 定义在文件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 中 ， 因 此 要 分 析 Linux 内 核 的 启 动 流 程 ， 就 得 先 从 文 件arch&#x2F;arm&#x2F;kernel&#x2F;head.S 的 stext 处开始分析。</p>
<h1><span id="2-linux-nei-he-qi-dong-liu-cheng">2 Linux 内核启动流程</span><a href="#2-linux-nei-he-qi-dong-liu-cheng" class="header-anchor">#</a></h1><h2><span id="2-0-linux-kernel-qi-dong-liu-cheng-gai-shu">2.0 Linux kernel启动流程概述</span><a href="#2-0-linux-kernel-qi-dong-liu-cheng-gai-shu" class="header-anchor">#</a></h2><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/0.png" alt="image-20240720160759323"></p>
<h2><span id="2-1pre-linux-nei-he-jing-xiang-jie-ya">2.1pre linux内核镜像解压</span><a href="#2-1pre-linux-nei-he-jing-xiang-jie-ya" class="header-anchor">#</a></h2><p><code>kernel/lib/inflate.c</code>的<code>decompress_kernel</code>，<code> inflate.c</code>是从gzip 插件源代码移过来的。解压完后会看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UncompressingLinux...done, booting the kernel.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">call_kernel: bl    cache_clean_flush</span><br><span class="line">  bl    cache_off</span><br><span class="line">  mov       r0, #<span class="number">0</span>          @ must be zero</span><br><span class="line">  mov       r1, r7          @ restore architecture number</span><br><span class="line">  mov       r2, r8          @ restore atags pointer</span><br><span class="line">  mov       pc, r4          @ call kernel</span><br></pre></td></tr></table></figure>

<p> r4 中已经在head.S处预置为内核镜像的地址,因此会跳转到r4去执行，就是Linux 内核入口 stext。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_AUTO_ZRELADDR</span></span><br><span class="line">  @determine final kernel image address</span><br><span class="line">  mov       r4, pc</span><br><span class="line">  and r4, r4, #<span class="number">0xf8000000</span></span><br><span class="line">  add r4, r4, #TEXT_OFFSET</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  ldr   r4, =zreladdr</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="2-1-linux-nei-he-ru-kou-stext">2.1 Linux 内核入口 stext</span><a href="#2-1-linux-nei-he-ru-kou-stext" class="header-anchor">#</a></h2><p>打开arch&#x2F;arm&#x2F;kernel&#x2F;head.S可以看到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Kernel startup entry point.</span></span><br><span class="line"><span class="comment">* ---------------------------</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This is normally called from the decompressor code. The requirements</span></span><br><span class="line"><span class="comment">* are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,</span></span><br><span class="line"><span class="comment">* r1 = machine nr, r2 = atags or dtb pointer.</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Linux 内核的入口点 stext 其实相当于内核的入口函数，stext 函数内容如下：</p>
<p>依据上面的注释内容，Linux 内核启动之前要求如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①、关闭 MMU。</span><br><span class="line">②、关闭 D-cache。</span><br><span class="line">③、I-Cache 无所谓。</span><br><span class="line">④、r0=<span class="number">0</span>。</span><br><span class="line">⑤、r1=machine nr(也就是机器 ID)。</span><br><span class="line">⑥、r2=atags 或者设备树(dtb)首地址。</span><br></pre></td></tr></table></figure>

<p>stext代码如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image"></p>
<p>第 92 行，调用函数 <code>safe_svcmode_maskall</code> 确保 CPU 处于 SVC 模式，并且关闭了所有的中断。<code>safe_svcmode_maskall </code>定义在文件 <code>arch/arm/include/asm/assembler.h </code>中。<br>第 94 行，读处理器 ID，ID 值保存在 r9 寄存器中。<br>第 95 行，调用函数<code>__lookup_processor_type </code>检查当前系统是否支持此 CPU，如果支持就获取 procinfo 信 息 。 procinfo 是 <code>proc_info_list </code>类 型 的 结 构 体，<code>proc_info_list </code>在 文 件<code>arch/arm/include/asm/procinfo.h </code>中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_info_list</span> &#123;</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_val;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> cpu_mask;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_mm_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_io_mmu_flags; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">long</span> __cpu_flush; <span class="comment">/* used by head.S */</span></span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *arch_name;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *elf_name;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> elf_hwcap;</span><br><span class="line">	 <span class="type">const</span> <span class="type">char</span> *cpu_name;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">processor</span> *<span class="title">proc</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_tlb_fns</span> *<span class="title">tlb</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_user_fns</span> *<span class="title">user</span>;</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">cpu_cache_fns</span> *<span class="title">cache</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每种处理器都抽象为一个 proc_info_list 结构体，每种处理器都对应一个procinfo。因此可以通过处理器 ID 来找到对应的 procinfo 结构，<code>__lookup_processor_type </code>函数找到对应处理器的 procinfo 以后会将其保存到 r5 寄存器中。</p>
<p>第121行，函数<code>__vet_atags </code>验证 atags 或设备树(dtb)的合法性。函数<code>__vet_atags </code>定义在文件 <code>arch/arm/kernel/head-common.S </code>中。<br>第128行，调用函数<code>__create_page_tables </code>创建页表。<br>第 137 行，将函数<code>__mmap_switched</code> 的地址保存到 r13 寄存器中。<code>__mmap_switched </code>定义在文件 <code>arch/arm/kernel/head-common.S</code>，<code>__mmap_switched</code> 最终会调用 start_kernel 函数。<br>第 144 行 ， 调 用 <code>__enable_mmu </code>函 数 使 能 MMU ，<code>__enable_mmu</code>定 义 在 文 件<code>arch/arm/kernel/head.S </code>中。<code>__enable_mmu</code> 最终会通过调用<code>__turn_mmu_on </code>来打开 MMU，<code>__turn_mmu_on </code>最后会执行 r13 里面保存的<code>__mmap_switched </code>函数。</p>
<h3><span id="2-1-0-create-page-tables">2.1.0 <code>__create_page_tables</code></span><a href="#2-1-0-create-page-tables" class="header-anchor">#</a></h3><ul>
<li>内核所在物理内存块的初始地址，保存在寄存器 r8 中。</li>
<li>内核代码相对于初始地址的偏移值，是在程序编译前就确定的一个宏：<code>TEXT_OFFSET</code>，arm32 中通常是 0x8000，也就是偏移地址为 32 K，前面保留的 32K 内存就是用来存放页表。</li>
</ul>
<p>在建立页表之前，目前所处的相关寄存器环境为：<code>r8 = phys_offset, r9 = cpuid, r10 = procinfo.</code></p>
<h3><span id="2-1-1-enable-mmu">2.1.1  <code>__enable_mmu</code></span><a href="#2-1-1-enable-mmu" class="header-anchor">#</a></h3><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image"></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image"></p>
<h4><span id="2-1-1-1-mmap-switched">2.1.1.1 <code>__mmap_switched</code></span><a href="#2-1-1-1-mmap-switched" class="header-anchor">#</a></h4><p>前面讲到<code>__enable_mmu</code>会调用<code>__mmap_switched </code>函数（通过调用<code>__turn_mmu_on</code> 再调用r13）。现在具体分析它：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image"><br>可以看到<code>__mmap_switched</code>主要就是做clear bss,然后保存处理器ID, 序列号，最终跳转start_kernel函数。</p>
<h5><span id="2-1-1-1-1-start-kernel">2.1.1.1.1  start_kernel</span><a href="#2-1-1-1-1-start-kernel" class="header-anchor">#</a></h5><p>start_kernel会调用大量的子函数完成linux启动前的一些初始化工作，start_kernel 函数里面调用的子函数太多，而这些子函数又很复杂。我们简单的来看一下一些重要的子函数。精简并添加注释后的 start_kernel 函数内容如下：</p>
<details>
<summary>init/main/start_kenel函数</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __init <span class="title function_">start_kernel</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *command_line;</span><br><span class="line">	<span class="type">char</span> *after_dashes;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run as early as possible, to initialize the</span></span><br><span class="line"><span class="comment">	 * lockdep hash:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	lockdep_init();</span><br><span class="line">	set_task_stack_end_magic(&amp;init_task);</span><br><span class="line">	smp_setup_processor_id();</span><br><span class="line">	debug_objects_early_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the the initial canary ASAP:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	boot_init_stack_canary();</span><br><span class="line"></span><br><span class="line">	cgroup_init_early();</span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Interrupts are still disabled. Do necessary setups, then</span></span><br><span class="line"><span class="comment"> * enable them</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	boot_cpu_init();</span><br><span class="line">	page_address_init();</span><br><span class="line">	pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);</span><br><span class="line">	setup_arch(&amp;command_line);</span><br><span class="line">	mm_init_cpumask(&amp;init_mm);</span><br><span class="line">	setup_command_line(command_line);</span><br><span class="line">	setup_nr_cpu_ids();</span><br><span class="line">	setup_per_cpu_areas();</span><br><span class="line">	smp_prepare_boot_cpu();	<span class="comment">/* arch-specific boot-cpu hooks */</span></span><br><span class="line"></span><br><span class="line">	build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	page_alloc_init();</span><br><span class="line"></span><br><span class="line">	pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line);</span><br><span class="line">	parse_early_param();</span><br><span class="line">	after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">				  static_command_line, __start___param,</span><br><span class="line">				  __stop___param - __start___param,</span><br><span class="line">				  <span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">	<span class="keyword">if</span> (!IS_ERR_OR_NULL(after_dashes))</span><br><span class="line">		parse_args(<span class="string">&quot;Setting init args&quot;</span>, after_dashes, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">			   set_init_arg);</span><br><span class="line"></span><br><span class="line">	jump_label_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * These use large bootmem allocations and must precede</span></span><br><span class="line"><span class="comment">	 * kmem_cache_init()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	setup_log_buf(<span class="number">0</span>);</span><br><span class="line">	pidhash_init();</span><br><span class="line">	vfs_caches_init_early();</span><br><span class="line">	sort_main_extable();</span><br><span class="line">	trap_init();</span><br><span class="line">	mm_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Set up the scheduler prior starting any interrupts (such as the</span></span><br><span class="line"><span class="comment">	 * timer interrupt). Full topology setup happens at smp_init()</span></span><br><span class="line"><span class="comment">	 * time - but meanwhile we still have a functioning scheduler.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	sched_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Disable preemption - early bootup scheduling is extremely</span></span><br><span class="line"><span class="comment">	 * fragile until we cpu_idle() for the first time.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	preempt_disable();</span><br><span class="line">	<span class="keyword">if</span> (WARN(!irqs_disabled(),</span><br><span class="line">		 <span class="string">&quot;Interrupts were enabled *very* early, fixing it\n&quot;</span>))</span><br><span class="line">		local_irq_disable();</span><br><span class="line">	idr_init_cache();</span><br><span class="line">	rcu_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* trace_printk() and trace points may be used after this */</span></span><br><span class="line">	trace_init();</span><br><span class="line"></span><br><span class="line">	context_tracking_init();</span><br><span class="line">	radix_tree_init();</span><br><span class="line">	<span class="comment">/* init some links before init_ISA_irqs() */</span></span><br><span class="line">	early_irq_init();</span><br><span class="line">	init_IRQ();</span><br><span class="line">	tick_init();</span><br><span class="line">	rcu_init_nohz();</span><br><span class="line">	init_timers();</span><br><span class="line">	hrtimers_init();</span><br><span class="line">	softirq_init();</span><br><span class="line">	timekeeping_init();</span><br><span class="line">	time_init();</span><br><span class="line">	sched_clock_postinit();</span><br><span class="line">	perf_event_init();</span><br><span class="line">	profile_init();</span><br><span class="line">	call_function_init();</span><br><span class="line">	WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">	early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	kmem_cache_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * HACK ALERT! This is early. We&#x27;re enabling the console before</span></span><br><span class="line"><span class="comment">	 * we&#x27;ve done PCI setups etc, and console_init() must be aware of</span></span><br><span class="line"><span class="comment">	 * this. But we do want output early, in case something goes wrong.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	console_init();</span><br><span class="line">	<span class="keyword">if</span> (panic_later)</span><br><span class="line">		panic(<span class="string">&quot;Too many boot %s vars at `%s&#x27;&quot;</span>, panic_later,</span><br><span class="line">		      panic_param);</span><br><span class="line"></span><br><span class="line">	lockdep_info();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Need to run this when irqs are enabled, because it wants</span></span><br><span class="line"><span class="comment">	 * to self-test [hard/soft]-irqs on/off lock inversion bugs</span></span><br><span class="line"><span class="comment">	 * too:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	locking_selftest();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_INITRD</span></span><br><span class="line">	<span class="keyword">if</span> (initrd_start &amp;&amp; !initrd_below_start_ok &amp;&amp;</span><br><span class="line">	    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)) &lt; min_low_pfn) &#123;</span><br><span class="line">		pr_crit(<span class="string">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.\n&quot;</span>,</span><br><span class="line">		    page_to_pfn(virt_to_page((<span class="type">void</span> *)initrd_start)),</span><br><span class="line">		    min_low_pfn);</span><br><span class="line">		initrd_start = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	page_ext_init();</span><br><span class="line">	debug_objects_mem_init();</span><br><span class="line">	kmemleak_init();</span><br><span class="line">	setup_per_cpu_pageset();</span><br><span class="line">	numa_policy_init();</span><br><span class="line">	<span class="keyword">if</span> (late_time_init)</span><br><span class="line">		late_time_init();</span><br><span class="line">	sched_clock_init();</span><br><span class="line">	calibrate_delay();</span><br><span class="line">	pidmap_init();</span><br><span class="line">	anon_vma_init();</span><br><span class="line">	acpi_early_init();</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86</span></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES))</span><br><span class="line">		efi_enter_virtual_mode();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_ESPFIX64</span></span><br><span class="line">	<span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">	init_espfix_bsp();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	thread_info_cache_init();</span><br><span class="line">	cred_init();</span><br><span class="line">	fork_init();</span><br><span class="line">	proc_caches_init();</span><br><span class="line">	buffer_init();</span><br><span class="line">	key_init();</span><br><span class="line">	security_init();</span><br><span class="line">	dbg_late_init();</span><br><span class="line">	vfs_caches_init(totalram_pages);</span><br><span class="line">	signals_init();</span><br><span class="line">	<span class="comment">/* rootfs populating might need page-writeback */</span></span><br><span class="line">	page_writeback_init();</span><br><span class="line">	proc_root_init();</span><br><span class="line">	nsfs_init();</span><br><span class="line">	cpuset_init();</span><br><span class="line">	cgroup_init();</span><br><span class="line">	taskstats_init_early();</span><br><span class="line">	delayacct_init();</span><br><span class="line"></span><br><span class="line">	check_bugs();</span><br><span class="line"></span><br><span class="line">	acpi_subsystem_init();</span><br><span class="line">	sfi_init_late();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (efi_enabled(EFI_RUNTIME_SERVICES)) &#123;</span><br><span class="line">		efi_late_init();</span><br><span class="line">		efi_free_boot_services();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ftrace_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do the rest non-__init&#x27;ed, we&#x27;re now alive */</span></span><br><span class="line">	rest_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>如下，打上注释方便清楚每个子调用的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">lockdep_init() <span class="comment">//lockdep 是死锁检测模块，此函数会初始化两个 hash 表</span></span><br><span class="line">set_task_stack_end_magic() <span class="comment">//设置任务栈结束魔术数，用于栈溢出检测</span></span><br><span class="line">smp_setup_processor_id() <span class="comment">//跟 SMP 有关(多核处理器)，设置处理器 ID</span></span><br><span class="line">debug_objects_early_init() <span class="comment">//做一些和 debug 有关的初始化</span></span><br><span class="line">boot_init_stack_canary() <span class="comment">//栈溢出检测初始化</span></span><br><span class="line">cgroup_init_early() <span class="comment">//cgroup 初始化，cgroup 用于控制 Linux 系统资源</span></span><br><span class="line">local_irq_disable() <span class="comment">//关闭当前 CPU 中断, 中断关闭期间做一些重要的操作，然后打开中断</span></span><br><span class="line">boot_cpu_init() <span class="comment">//跟 CPU 有关的初始化</span></span><br><span class="line">page_address_init() <span class="comment">//页地址相关的初始化</span></span><br><span class="line">pr_notice(<span class="string">&quot;%s&quot;</span>, linux_banner);<span class="comment">/* 打印 Linux 版本号、编译时间等信息 */</span></span><br><span class="line">setup_arch(&amp;command_line); <span class="comment">//架构相关的初始化，此函数会解析传递进来的ATAGS 或者设备树(DTB)文件。会根据设备树里面的 model 和 compatible 这两个属性值来查找Linux 是否支持这个单板。此函数也会获取设备树中 chosen 节点下的 bootargs 属性值来得到命令行参数，也就是 uboot 中的 bootargs 环境变量的值，获取到的命令行参数会保存到command_line 中</span></span><br><span class="line">mm_init_cpumask(&amp;init_mm) <span class="comment">//内存有关的初始化</span></span><br><span class="line">setup_command_line(command_line) <span class="comment">//存储命令行参数</span></span><br><span class="line">setup_nr_cpu_ids() <span class="comment">//如果只是 SMP(多核 CPU)的话，此函数用于获取CPU 核心数量，CPU 数量保存在变量nr_cpu_ids 中</span></span><br><span class="line">setup_per_cpu_areas() <span class="comment">//在 SMP 系统中有用，设置每个 CPU 的 per-cpu 数据</span></span><br><span class="line">smp_prepare_boot_cpu()</span><br><span class="line">build_all_zonelists(<span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">/* 建立系统内存页区(zone)链表 */</span></span><br><span class="line">page_alloc_init(); <span class="comment">/* 处理用于热插拔 CPU 的页 */</span></span><br><span class="line">pr_notice(<span class="string">&quot;Kernel command line: %s\n&quot;</span>, boot_command_line); <span class="comment">//打印命令行信息</span></span><br><span class="line">parse_early_param(); <span class="comment">/* 解析命令行中的 console 参数 */</span></span><br><span class="line">after_dashes = parse_args(<span class="string">&quot;Booting kernel&quot;</span>,</span><br><span class="line">		static_command_line, __start___param,</span><br><span class="line">		__stop___param - __start___param,</span><br><span class="line">		<span class="number">-1</span>, <span class="number">-1</span>, &amp;unknown_bootoption);</span><br><span class="line">setup_log_buf(<span class="number">0</span>); <span class="comment">/* 设置 log 使用的缓冲区*/</span></span><br><span class="line">pidhash_init(); <span class="comment">// 构建 PID 哈希表，Linux 中每个进程都有一个 ID,这个 ID 叫做 PID。通过构建哈希表可以快速搜索进程信息结构体</span></span><br><span class="line">idr_init_cache(); <span class="comment">// IDR 初始化，IDR 是 Linux 内核的整数管理机制，也就是将一个整数 ID 与一个指针关联起来</span></span><br><span class="line">rcu_init(); <span class="comment">// 初始化 RCU，RCU 全称为 Read Copy Update(读-拷贝修改)</span></span><br><span class="line">trace_init(); <span class="comment">// 跟踪调试相关初始化 </span></span><br><span class="line">radix_tree_init(); <span class="comment">//基数树相关数据结构初始化</span></span><br><span class="line">early_irq_init(); <span class="comment">//初始中断相关初始化,主要是注册 irq_desc 结构体变量，因为 Linux 内核使用 irq_desc 来描述一个中断</span></span><br><span class="line">init_IRQ(); <span class="comment">/* 中断初始化 */</span></span><br><span class="line">tick_init(); <span class="comment">/* tick 初始化 */</span></span><br><span class="line">init_timers(); <span class="comment">/* 初始化定时器 */</span></span><br><span class="line">hrtimers_init(); <span class="comment">/* 初始化高精度定时器 */</span></span><br><span class="line">softirq_init(); <span class="comment">/* 软中断初始化 */</span></span><br><span class="line">timekeeping_init(); </span><br><span class="line">time_init(); <span class="comment">/* 初始化系统时间 */</span></span><br><span class="line">WARN(!irqs_disabled(), <span class="string">&quot;Interrupts were enabled early\n&quot;</span>);</span><br><span class="line">early_boot_irqs_disabled = <span class="literal">false</span>;</span><br><span class="line">local_irq_enable(); <span class="comment">/* 使能中断 */</span></span><br><span class="line">kmem_cache_init_late(); <span class="comment">/* slab 初始化，slab 是 Linux 内存分配器 */</span></span><br><span class="line">console_init(); <span class="comment">//初始化控制台，之前 printk 打印的信息都存放缓冲区中，并没有打印出来。只有调用此函数初始化控制台以后才能在控制台上打印信息</span></span><br><span class="line">locking_selftest() <span class="comment">/* 锁自测 */</span></span><br><span class="line">kmemleak_init(); <span class="comment">/* kmemleak 初始化，kmemleak 用于检查内存泄漏 */</span></span><br><span class="line">calibrate_delay(); <span class="comment">/* 测定 BogoMIPS 值，可以通过 BogoMIPS 来判断 CPU 的性能BogoMIPS 设置越大，说明 CPU 性能越好*/</span></span><br><span class="line">pidmap_init(); <span class="comment">/* PID 位图初始化 */</span></span><br><span class="line">anon_vma_init(); <span class="comment">/* 生成 anon_vma slab 缓存 */</span></span><br><span class="line">cred_init(); <span class="comment">/* 为对象的每个用于赋予资格(凭证) */</span></span><br><span class="line">fork_init(); <span class="comment">/* 初始化一些结构体以使用 fork 函数 */</span></span><br><span class="line">proc_caches_init(); <span class="comment">/* 给各种资源管理结构分配缓存 */</span></span><br><span class="line">buffer_init(); <span class="comment">/* 初始化缓冲缓存 */</span></span><br><span class="line">key_init(); <span class="comment">/* 初始化密钥 */</span></span><br><span class="line">security_init(); <span class="comment">/* 安全相关初始化 */</span></span><br><span class="line">vfs_caches_init(totalram_pages); <span class="comment">/* 为 VFS 创建缓存 */</span></span><br><span class="line">signals_init(); <span class="comment">/* 初始化信号 */</span></span><br><span class="line">page_writeback_init(); <span class="comment">/* 页回写初始化 */</span></span><br><span class="line">proc_root_init(); <span class="comment">/* 注册并挂载 proc 文件系统 */</span></span><br><span class="line">cpuset_init(); <span class="comment">/* 初始化 cpuset，cpuset 是将 CPU 和内存资源以逻辑性和层次性集成的一种机制，是 cgroup 使用的子系统之一*/</span></span><br><span class="line">cgroup_init(); <span class="comment">/* 初始化 cgroup */</span></span><br><span class="line">taskstats_init_early(); <span class="comment">/* 进程状态初始化 */</span></span><br><span class="line">check_bugs(); <span class="comment">/* 检查写缓冲一致性 */</span></span><br><span class="line">rest_init(); <span class="comment">/* rest_init 函数 */</span></span><br></pre></td></tr></table></figure>

<p>start_kernel完成内核初始化工作。具体包括以下部分：</p>
<p>（1）内核架构 、通用配置相关初始化</p>
<p>（2） 内存管理相关初始化</p>
<p>（3）进程管理相关初始化</p>
<p>（4）进程调度相关初始化</p>
<p>（5）网络子系统管理</p>
<p>（6）虚拟文件系统</p>
<p>（7）文件系统</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.1.png" alt="image-20240720151715291"></p>
<h6><span id="2-1-1-1-1-1-setup-arch">2.1.1.1.1.1 setup_arch</span><a href="#2-1-1-1-1-1-setup-arch" class="header-anchor">#</a></h6><p>内核架构相关的初始化函数, 包含了处理器相关参数的初始化、内核启动参数（tagged list）的获取和前期处理、内存子系统的早期初始化。</p>
<p><code>setup_arch(&amp;command_line);</code></p>
<p>若uboot中bootargs的值为空，<code>command_line = default_command_line</code>，即为内核中的默认命令行参数，其值在<code>.config</code>文件中配置，对应<code>CONFIG_CMDLINE</code>配置项。</p>
<h6><span id="2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args">2.1.1.1.1.2 setup_command_line、parse_early_param以及parse_args</span><a href="#2-1-1-1-1-2-setup-command-line-parse-early-param-yi-ji-parse-args" class="header-anchor">#</a></h6><p>完成命令行参数的解析、保存。譬如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmdline = console=ttySAC2,115200 root=/dev/mmcblk0p2 rw</span><br><span class="line">init=/linuxrc rootfstype=ext3 <span class="comment">#解析为一下四个参数：</span></span><br><span class="line">console=ttySAC2,115200 <span class="comment">#指定控制台的串口设备号，及其波特率</span></span><br><span class="line">root=/dev/mmcblk0p2 rw <span class="comment">#指定根文件系统rootfs的路径</span></span><br><span class="line">init=/linuxrc <span class="comment">#指定第一个用户进程init的路径rootf stype=ext3</span></span><br></pre></td></tr></table></figure>

<h6><span id="2-1-1-1-1-n-reset-init">2.1.1.1.1.n reset_init</span><a href="#2-1-1-1-1-n-reset-init" class="header-anchor">#</a></h6><p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.2.png" alt="image-20240720161109653"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1）调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd。</span><br><span class="line">    kernel_init线程中调用prepare_namespace函数挂载根文件系统rootfs；</span><br><span class="line">    然后调用init_post函数，执行根文件系统rootfs下的第一个用户进程init。</span><br><span class="line">    用户进程有4个备选方案，若command_line中init的路径错误，则会执行备用方案。</span><br><span class="line">    第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。</span><br><span class="line"></span><br><span class="line">2）调用schedule函数开启内核调度系统；</span><br><span class="line">3）调用cpu_idle函数，启动空闲进程idle，完成内核启动。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init_refok <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">	rcu_scheduler_starting();</span><br><span class="line">	smpboot_thread_init();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We need to spawn init first so that it obtains pid 1, however</span></span><br><span class="line"><span class="comment">	 * the init task will end up wanting to create kthreads, which, if</span></span><br><span class="line"><span class="comment">	 * we schedule it before we create kthreadd, will OOPS.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">	numa_default_policy();</span><br><span class="line">	pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	complete(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The boot idle thread must execute schedule()</span></span><br><span class="line"><span class="comment">	 * at least once to get things moving:</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	init_idle_bootup_task(current);</span><br><span class="line">	schedule_preempt_disabled();</span><br><span class="line">	<span class="comment">/* Call into cpu_idle with preempt disabled */</span></span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数 rcu_scheduler_starting，启动 RCU 锁调度器。<br>调用函数 kernel_thread 创建 kernel_init 进程，也就是大名鼎鼎的 init 内核进程。init 进程的 PID 为 1。init 进程一开始是内核进程(也就是运行在内核态)，后面 init 进程会在根文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程序，init 进程就会实现从内核态到用户态的转变。<br>调用函数 kernel_thread 创建 kthreadd 内核进程，此内核进程的 PID 为 2。kthreadd进程负责所有内核进程的调度和管理。<br>最后调用函数 cpu_startup_entry 来进入 idle 进程，cpu_startup_entry 会调用cpu_idle_loop，cpu_idle_loop 是个 while 循环，也就是 idle 进程代码。idle 进程的 PID 为 0，idle进程叫做空闲进程，如果学过 FreeRTOS 或者 UCOS 的话应该听说过空闲任务。idle 空闲进程就和空闲任务一样，当 CPU 没有事情做的时候就在 idle 空闲进程里面“瞎逛游”，反正就是给CPU 找点事做。当其他进程要工作的时候就会抢占 idle 进程，从而夺取 CPU 使用权。其实大家应该可以看到 idle 进程并没有使用 kernel_thread 或者 fork 函数来创建，因为它是有主进程演变而来的。<br>在 Linux 终端中输入<code>“ps -A”</code>就可以打印出当前系统中的所有进程，其中就能看到 init 进程和 kthreadd 进程：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png" alt="image"><br>init 进程的 PID 为 1，kthreadd 进程的 PID 为 2。没有显示 PID 为 0 的 idle 进程，那是因为 idle 进程是内核进程。kernel_init 就是 init 进程的进程函数。</p>
<h2><span id="2-2-kernel-init-init-jin-cheng-xiang-jie">2.2 kernel_init(init进程详解)</span><a href="#2-2-kernel-init-init-jin-cheng-xiang-jie" class="header-anchor">#</a></h2><p>把reset_init中的<code>kernel_init</code> 拆出来，函数<code>kernel_init</code> 就是 init 进程具体做的工作，函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __ref <span class="title function_">kernel_init</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	kernel_init_freeable(); <span class="comment">/* init 进程的一些其他初始化工作 */</span></span><br><span class="line">	<span class="comment">/* need to finish all async __init code before freeing the memory */</span></span><br><span class="line">	async_synchronize_full(); <span class="comment">/* 等待所有的异步调用执行完成 */</span></span><br><span class="line">	free_initmem(); <span class="comment">/* 释放 init 段内存 */</span></span><br><span class="line">	mark_rodata_ro();</span><br><span class="line">	system_state = SYSTEM_RUNNING; <span class="comment">/* 标记系统正在运行 */</span></span><br><span class="line">	numa_default_policy();</span><br><span class="line"></span><br><span class="line">	flush_delayed_fput();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		pr_err(<span class="string">&quot;Failed to execute %s (error %d)\n&quot;</span>,</span><br><span class="line">		ramdisk_execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* We try each of these until one succeeds.</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* The Bourne shell can be used instead of init if we are</span></span><br><span class="line"><span class="comment">	* trying to recover a really broken machine.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		ret = run_init_process(execute_command);</span><br><span class="line">		<span class="keyword">if</span> (!ret)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		panic(<span class="string">&quot;Requested init %s failed (error %d).&quot;</span>,</span><br><span class="line">		execute_command, ret);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>) ||</span><br><span class="line">		!try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No working init found. Try passing init= option to kernel. &quot;</span></span><br><span class="line">	<span class="string">&quot;See Linux Documentation/init.txt for guidance.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kernel_init_freeable </code>函数用于完成 init 进程的一些其他初始化工作，稍后再来具体看一下此函数。<br><code>ramdisk_execute_command </code>是一个全局的 char 指针变量，此变量值为<code>“/init”</code>，也就是根目录下的 init 程序。<code>ramdisk_execute_command </code>也可以通过 uboot 传递，在 bootargs 中使用<code>“rdinit=xxx”</code>即可，xxx 为具体的 init 程序名字。<br>如果存在<code>“/init”</code>程序的话就通过函数 <code>run_init_process </code>来运行此程序。<br>如果 <code>ramdisk_execute_command </code>为空的话就看 <code>execute_command </code>是否为空，反正不管如何一定要在根文件系统中找到一个可运行的 init 程序。<code>execute_command</code> 的值是通过uboot 传递，在 bootargs 中使用<code>“init=xxxx”</code>就可以了，比如<code>“init=/linuxrc”</code>表示根文件系统中的 linuxrc 就是要执行的用户空间 init 程序。<br>如果<code>ramdisk_execute_command</code>和 <code>execute_command </code>都为空，那么就依次查找<code>“/sbin/init”</code>、<code>“/etc/init”</code>、<code>“/bin/init”</code>和<code>“/bin/sh”</code>，这四个相当于备用 init 程序，如果这四个也不存在，那么 Linux 启动失败！<br>如果以上步骤都没有找到用户空间的 init 程序，那么就提示错误发生！</p>
<h3><span id="2-2-1-kernel-init-freeable">2.2.1 kernel_init_freeable</span><a href="#2-2-1-kernel-init-freeable" class="header-anchor">#</a></h3><p><code>kernel_init_freeable </code>定义在文件 init&#x2F;main.c 中，缩减后的函数内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span> __init <span class="title function_">kernel_init_freeable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Wait until kthreadd is all set-up.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	wait_for_completion(&amp;kthreadd_done);<span class="comment">/* 等待 kthreadd 进程准备就绪 */</span></span><br><span class="line">	smp_init(); <span class="comment">/* SMP 初始化 */</span></span><br><span class="line">	sched_init_smp(); <span class="comment">/* 多核(SMP)调度初始化 */</span></span><br><span class="line">	do_basic_setup(); <span class="comment">/* 设备初始化都在此函数中完成 */</span></span><br><span class="line">	<span class="comment">/* Open the /dev/console on the rootfs, this should never fail */</span></span><br><span class="line">	<span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)	</span><br><span class="line">		pr_err(<span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* check if there is an early userspace init. If yes, let it do </span></span><br><span class="line"><span class="comment">	* all the work</span></span><br><span class="line"><span class="comment">	*/</span>	</span><br><span class="line">	<span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">		ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (sys_access((<span class="type">const</span> <span class="type">char</span> __user *) ramdisk_execute_command, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		ramdisk_execute_command = <span class="literal">NULL</span>;</span><br><span class="line">		prepare_namespace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* Ok, we have completed the initial bootup, and</span></span><br><span class="line"><span class="comment">	* we&#x27;re essentially up and running. Get rid of the</span></span><br><span class="line"><span class="comment">	* initmem segments and start the user-mode stuff..</span></span><br><span class="line"><span class="comment">	*</span></span><br><span class="line"><span class="comment">	* rootfs is available now, try loading the public keys</span></span><br><span class="line"><span class="comment">	* and default modules</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	integrity_load_keys();</span><br><span class="line">	load_default_modules();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-1-1-driver-init">2.2.1.1 driver_init</span><a href="#2-2-1-1-driver-init" class="header-anchor">#</a></h4><p><code>do_basic_setup</code> 函数用于完成 Linux 下设备驱动初始化工作！非常重要。do_basic_setup 会调用 <code>driver_init </code>函数完成 Linux 下驱动模型子系统的初始化。</p>
<h4><span id="2-2-1-2-she-zhi-kong-zhi-tai">2.2.1.2 设置控制台</span><a href="#2-2-1-2-she-zhi-kong-zhi-tai" class="header-anchor">#</a></h4><p>打开设备<code>“/dev/console”</code>，在 Linux 中一切皆为文件！因此<code>“/dev/console”</code>也是一个文件，此文件为控制台设备。每个文件都有一个文件描述符，此处打开的<code>“/dev/console”</code>文件描述符为 0，作为标准输入(0)。<br><code>sys_dup </code>函数将标准输入(0)的文件描述符复制了 2 次，一个作为标准输出(1)，一个作为标准错误(2)。这样标准输入、输出、错误都是&#x2F;dev&#x2F;console 了。console 通过uboot 的 bootargs 环境变量设置，<code>“console=ttymxc0,115200”</code>表示将<code>/dev/ttymxc0 </code>设置为 console，也就是 I.MX6U 的串口 1。当然，也可以设置其他的设备为 console，比如虚拟控制台 tty1，设置 tty1 为 console 就可以在 LCD 屏幕上看到系统的提示信息。</p>
<h4><span id="2-2-1-3-gua-zai-gen-wen-jian-xi-tong">2.2.1.3 挂载根文件系统</span><a href="#2-2-1-3-gua-zai-gen-wen-jian-xi-tong" class="header-anchor">#</a></h4><p>调用函数 <code>prepare_namespace</code> 来挂载根文件系统。根文件系统也是由命令行参数指定的，就是 uboot 的 bootargs 环境变量。比如<code>“root=/dev/mmcblk1p2 rootwait rw”</code>就表示根文件系统在&#x2F;dev&#x2F;mmcblk1p2 中，也就是 EMMC 的分区 2 中。</p>
<p>下面2张图都是emmc存储，分别挂载ext3格式和squashfs格式根文件系统：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image"><br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image"></p>
<p>如果根文件系统缺失错误，这里我们故意将:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="string">&#x27;console=ttymxc0,115200&#x27;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>这时候挂载根文件系统时，由于没有指定<code>root=/dev/mmcblk1p2 rootwait rw</code>，因此报错如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image"><br>还能看到call trace如下：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image"></p>
<h5><span id="2-2-1-3-1-init-fu-wu">2.2.1.3.1 init 服务</span><a href="#2-2-1-3-1-init-fu-wu" class="header-anchor">#</a></h5><p>启动init服务时，init服务会读取<code>/etc/inittab</code>文件，<code>/etc/inittab</code>中设置了初始化系统环境的工作。 <code>/etc/inittab</code>定义 init 服务在 linux启动过程中必须依序执行以下几个Script ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/rc.sysinit</span><br><span class="line">/etc/rc.d/rc</span><br><span class="line">/etc/rc.d/rc.local</span><br></pre></td></tr></table></figure>

<h6><span id="2-2-1-3-1-1-rc-sysinit">2.2.1.3.1.1 rc.sysinit</span><a href="#2-2-1-3-1-1-rc-sysinit" class="header-anchor">#</a></h6><p><code>/etc/rc.d/rc.sysinit</code>主要的功能是设置系统的基本环境:</p>
<p>(1)启动<code>udev</code></p>
<p>(2)设置内核参数：执行<code>sysctl –p</code> ,以便从 <code>/etc/sysctl.conf </code>设置内核参数</p>
<p>(3)设置系统时间：将硬件时间设置为系统时间</p>
<p>(4)启用交换内存空间：执行<code> swpaon –a –e</code>，以便根据<code>/etc/fstab</code>的设置启用所有的交换内存空间。</p>
<p>(5)检查并挂载所有文件系统：检查所有需要挂载的文件系统，以确保这些文件系统的完整性。检查完毕后以可读可写的方式挂载文件系统。</p>
<p>(6)初始化硬件设备：Linux除了在启动内核时以静态驱动程序驱动部分的硬件外，在执行<code>rc.sysinit </code>时，也会试着驱动剩余的硬件设备</p>
<h1><span id="3-linux-nei-he-initcall-ji-zhi">3 Linux内核initcall机制</span><a href="#3-linux-nei-he-initcall-ji-zhi" class="header-anchor">#</a></h1><p>linux内核提供<code>xxx_init(init_func)</code>宏定义接口,驱动开发者只需要将驱动程序的<code>init_func</code>使用<code>xxx_init()</code>来修饰，这个函数就被自动添加到了上述的段中，开发者完全不需要关心实现细节。</p>
<h2><span id="3-1-xxx-initcall-de-yuan-ma">3.1 xxx_initcall的源码</span><a href="#3-1-xxx-initcall-de-yuan-ma" class="header-anchor">#</a></h2><p>在平台对应的<code>init.h</code>文件中，可以找到<code>xxx_initcall</code>的定义：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image"></p>
<p>n是一个数字或者是数字+s，这个数字代表这个fn执行的优先级，数字越小，优先级越高，带s的fn优先级低于不带s的fn优先级。可以看到上面的从<code>pure_initcall</code>到<code>late_initcall</code>优先级依次变低。</p>
<p>这里<code>__attribute__((__section__(&quot;.initcall&quot; #id &quot;.init&quot;)))</code>表示编译时将目标符号放置在括号指定的段中。</p>
<p>举个例子，对<code>pure_initcall(test_init);</code>展开：</p>
<ul>
<li>首先宏展开成：<code>__define_initcall(test_init, 0)</code></li>
<li>然后接着展开：<code>static initcall_t __initcall_test_init0 = test_init;</code>这就是一个简单的变量定义。</li>
<li>同时声明<code>__initcall_test_init0这个变量</code>即使没被引用也保留符号，且将其放置在内核镜像的<code>.initcall0.init</code>段处。</li>
</ul>
<p>在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<h2><span id="3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong">3.2 xxx_initcall修饰的函数怎么被调用</span><a href="#3-2-xxx-initcall-xiu-shi-de-han-shu-zen-me-bei-diao-yong" class="header-anchor">#</a></h2><p>见<code>Linux-4.9.88\init\main.c</code></p>
<h3><span id="3-2-1-do-initcalls">3.2.1 do_initcalls</span><a href="#3-2-1-do-initcalls" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start_kernel</span><br><span class="line">-&gt; rest_init();</span><br><span class="line">    -&gt; kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">        -&gt; kernel_init()</span><br><span class="line">            -&gt; kernel_init_freeable();</span><br><span class="line">                -&gt; do_basic_setup();</span><br><span class="line">                    -&gt; do_initcalls();</span><br></pre></td></tr></table></figure>

<p>这个<code>do_initcalls()</code>就是我们需要寻找的函数了，在这个函数中执行所有使用<code>xxx_initcall()</code>声明的函数。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png" alt="image"></p>
<p><code>do_initcalls() </code>循环调用 <code>do_initcall_level(level)</code>，level就是 <code>initcall </code>的优先级数字，由 for 循环的终止条件<code>ARRAY_SIZE(initcall_levels) - 1</code>可知，总共会调用8次。</p>
<p>而 <code>do_initcall_level(level)</code> 中则会遍历 <code>initcall_levels[level] </code>中的每个函数指针，<code>initcall_levels[level] </code>实际上是对应的<code>__initcall##level##_start </code>指针变量，然后依次取出<code>__initcall##level##_start </code>指向地址存储的每个函数指针，并调用 <code>do_one_initcall(*fn)</code>，实际上就是执行当前函数。</p>
<p>这个<code>__initcall##level##_start </code>所存储的函数指针就是开发者用 <code>xxx_initcall() </code>宏添加的函数，对应<code>&quot;.initcall_##level##.init&quot;</code>段。</p>
<p>听起来很绕，举个例子：</p>
<p>比如有一个<code>core_initcall(beagle_init);</code>展开为<code>__define_initcall(beagle_init, 1)</code>，所以 <code>beagle_init() </code>这个函数被放置在<code> &quot;.initcall1.init&quot;</code>段处。</p>
<p>再比如有一个<code>core_initcall(beagle2_init);</code>, 在<code> &quot;.initcall1.init&quot;</code>段就会增加一组函数。</p>
<p>那么<code>do_one_initcall(*fn)</code> 的执行：判断<code>initcall_debug</code>的值，如果为真，则调用 <code>do_one_initcall_debug(fn); </code>如果为假，则直接调用<code>fn</code>。</p>
<p>事实上，调用<code>do_one_initcall_debug(fn)</code>只是在调用<code>fn</code>的基础上添加一些额外的打印信息，可以直接看成是调用<code>fn</code>。</p>
<p>可能有些C语言基础不太好的朋友不太理解 <code>do_initcall_level() </code>函数中依次取出地址并执行的函数执行逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (fn = initcall_levels[level]; fn &lt; initcall_levels[level+<span class="number">1</span>]; fn++)</span><br><span class="line">    do_one_initcall(*fn);</span><br></pre></td></tr></table></figure>

<p><code>fn</code>为函数指针，<code>fn++</code>相当于函数指针+1，相当于：<code>内存地址+sizeof(fn)</code>，<code>sizeof(fn)</code>根据平台不同而不同，一般来说，32位机上是4字节，64位机则是8字节.</p>
<p>也就是在同等level下，会从同一个<code>&quot;.initcall_##level##.init&quot;</code>段中依次取出对应的函数指针。<br>也就是从<code>&quot;.initcall##level##.init&quot;</code>段开始，每次取一个函数出来执行，并累加指针，直到取完（即到了下一个段的起始地址就表示取完了）。</p>
<h4><span id="3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian">3.2.1.1 <code>__initcall##level##_start</code>与<code>.initcall##level##.init</code>段的关联</span><a href="#3-2-1-1-initcall-level-start-yu-initcall-level-init-duan-de-guan-lian" class="header-anchor">#</a></h4><p>前面说了在开发者添加 <code>xxx_initcall(fn)</code> 时，事实上是将<code>fn</code>放置到了 <code>&quot;.initcall##level##.init&quot; </code>的段中。</p>
<p>在<code>do_initcall()</code>的时候，却是从<code>initcall_levels[level]</code>(即<code>__initcall##level##_start</code>指针)取出，那么</p>
<p><code>initcall_levels[level] </code>是怎么关联到<code>&quot;.initcall##level##.init&quot;</code>段的呢？</p>
<p>在vmlinux.lds.h中：<br><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png" alt="image"></p>
<p>关联到<code>&quot;.initcallearly.init&quot;</code>段。</p>
<p>然后对每个 level 定义了<code>INIT_CALLS_LEVEL(level)</code>，将<code>INIT_CALLS_LEVEL(level)</code>展开之后的结果是定义<code> __initcall##level##_start</code>,并将<code>__initcall##level##_start</code>关联到 <code>&quot;.initcall##level##.init&quot; </code>段和<code>&quot;.initcall##level##s.init&quot;</code>段。</p>
<p>到这里，<code>__initcall##level##_start </code>和<code>&quot;.initcall##level##.init&quot;</code>段的对应就比较清晰了，所以，从 <code>initcall_levels[level] </code>部分一个个取出函数指针并执行函数就是执行<code>xxx_init_call()</code>定义的函数。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" data-id="cm0dxg145000ddsuf45tpfqo0" data-title="Linux内核启动流程" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux内核-rootfs构建移植
        
      </div>
    </a>
  
  
    <a href="/2024/07/18/Linux%E5%86%85%E6%A0%B8Makefile%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux内核Makefile编译过程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.33px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.67px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.83px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.5px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.17px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.67px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.83px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.83px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.5px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.67px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14.17px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>