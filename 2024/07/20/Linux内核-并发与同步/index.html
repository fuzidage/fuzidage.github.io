<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Linux内核-并发与同步 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 并发场景 2 并发解决方案 2.1 内存屏障 2.1.1 编译器指令重排（Compiler Instruction Reordering) 2.1.2 内存屏障API 2.1.2.1 barrier 2.1.2.2 cpu_relax 2.1.2.3 READ_ONCE()     2.2 原子操作 2.2.0 临界区的原子操作引入 2.2.1 整数原子操作API 2.2.2 位原子">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核-并发与同步">
<meta property="og:url" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 并发场景 2 并发解决方案 2.1 内存屏障 2.1.1 编译器指令重排（Compiler Instruction Reordering) 2.1.2 内存屏障API 2.1.2.1 barrier 2.1.2.2 cpu_relax 2.1.2.3 READ_ONCE()     2.2 原子操作 2.2.0 临界区的原子操作引入 2.2.1 整数原子操作API 2.2.2 位原子">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/1.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/2.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/3.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/4.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/5.png">
<meta property="og:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/6.png">
<meta property="article:published_time" content="2024-07-20T13:04:31.000Z">
<meta property="article:modified_time" content="2024-07-20T14:03:18.652Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="linux内核">
<meta property="article:tag" content="linux系统构建">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux内核-并发与同步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2024-07-20T13:04:31.000Z" itemprop="datePublished">2024-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Linux内核-并发与同步
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-bing-fa-chang-jing">1 并发场景</a></li>
<li><a href="#2-bing-fa-jie-jue-fang-an">2 并发解决方案</a><ul>
<li><a href="#2-1-nei-cun-ping-zhang">2.1 内存屏障</a><ul>
<li><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</a></li>
<li><a href="#2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</a><ul>
<li><a href="#2-1-2-1-barrier">2.1.2.1 barrier</a></li>
<li><a href="#2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</a></li>
<li><a href="#2-1-2-3-read-once">2.1.2.3 READ_ONCE()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-yuan-zi-cao-zuo">2.2 原子操作</a><ul>
<li><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</a></li>
<li><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</a></li>
<li><a href="#2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</a></li>
</ul>
</li>
<li><a href="#2-3-zi-xuan-suo">2.3 自旋锁</a><ul>
<li><a href="#2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</a><ul>
<li><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</a></li>
</ul>
</li>
<li><a href="#2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</a></li>
<li><a href="#2-3-3-shun-xu-suo">2.3.3 顺序锁</a></li>
</ul>
</li>
<li><a href="#2-4-xin-hao-liang">2.4 信号量</a><ul>
<li><a href="#2-4-1-xin-hao-liang-api">2.4.1 信号量 API</a></li>
</ul>
</li>
<li><a href="#2-5-hu-chi-suo">2.5 互斥锁</a><ul>
<li><a href="#2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</a></li>
</ul>
</li>
<li><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</a><ul>
<li><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</a></li>
<li><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</a></li>
<li><a href="#2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</a></li>
<li><a href="#2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</a></li>
<li><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</a><ul>
<li><a href="#2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-bing-fa-chang-jing">1 并发场景</span><a href="#1-bing-fa-chang-jing" class="header-anchor">#</a></h1><p>Linux 系统并发产生的原因很复杂，总结一下有下面几个主要原 因：</p>
<ol>
<li>多线程并发访问，Linux 是多任务(线程)的系统，所以多线程访问是最基本的原因。</li>
<li>抢占式并发访问，从 2.6 版本内核开始，Linux 内核支持抢占，也就是说调度程序可以 在任意时刻抢占正在运行的线程，从而运行其他的线程。 </li>
<li>中断程序并发访问，这个无需多说，学过 STM32 的同学应该知道，硬件中断的权利可 是很大的。</li>
<li>SMP(多核)核间并发访问，现在 ARM 架构的多核 SOC 很常见，多核 CPU 存在核间并 发访问。</li>
</ol>
<h1><span id="2-bing-fa-jie-jue-fang-an">2 并发解决方案</span><a href="#2-bing-fa-jie-jue-fang-an" class="header-anchor">#</a></h1><h2><span id="2-1-nei-cun-ping-zhang">2.1 内存屏障</span><a href="#2-1-nei-cun-ping-zhang" class="header-anchor">#</a></h2><h3><span id="2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering">2.1.1 编译器指令重排（Compiler Instruction Reordering)</span><a href="#2-1-1-bian-yi-qi-zhi-ling-chong-pai-compiler-instruction-reordering" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w0, [x0]       <span class="comment">//load b to w0</span></span><br><span class="line">    add w1, w0, #<span class="number">0x1</span></span><br><span class="line">    ...</span><br><span class="line">    str w1, [x0]       <span class="comment">//a = b + 1</span></span><br><span class="line">    ...</span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br></pre></td></tr></table></figure>

<p>我们把编译优化打开到-O2，再次反汇编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    add w0, w2, #<span class="number">0x1</span></span><br><span class="line">    str w0, [x1]       <span class="comment">//a = b + 1</span></span><br></pre></td></tr></table></figure>

<p>可以看到编译器 ”自作聪明“， b被提前赋值了。因此要使用内存屏障。</p>
<h3><span id="2-1-2-nei-cun-ping-zhang-api">2.1.2 内存屏障API</span><a href="#2-1-2-nei-cun-ping-zhang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">barrier();</span><br><span class="line">cpu_relax();</span><br><span class="line">READ_ONCE(val);</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-1-barrier">2.1.2.1 barrier</span><a href="#2-1-2-1-barrier" class="header-anchor">#</a></h4><p>前面用-O2选项顺序会被错误的排列。加入<code>barrier();//插入内存屏障</code>，再次反汇编可以看到OK符合我们的逻辑了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    a = b + <span class="number">1</span>;</span><br><span class="line"> 	barrier();<span class="comment">//插入内存屏障</span></span><br><span class="line">	b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反汇编如下：</span></span><br><span class="line">&lt;foo&gt;:</span><br><span class="line">    ...</span><br><span class="line">    ldr w2, [x0]       <span class="comment">//load b to w2</span></span><br><span class="line">    add w2, w2, #<span class="number">0x1</span></span><br><span class="line">    str w2, [x1]       <span class="comment">//a = a + 1</span></span><br><span class="line">    str wzr, [x0]      <span class="comment">//b = 0</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-2-cpu-relax">2.1.2.2 cpu_relax</span><a href="#2-1-2-2-cpu-relax" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>run 是个全局变量，foo() 在一个进程中执行，一直循环。我们期望的结果是 foo() 一直等到其他进程修改 run 的值为 0 才退出循环。反汇编看看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000748</span> &lt;foo&gt;:</span><br><span class="line"><span class="number">748</span>: <span class="number">90000080</span> adrp x0, <span class="number">10000</span></span><br><span class="line"><span class="number">74</span>c: f947e800 ldr x0, [x0, #<span class="number">4048</span>]</span><br><span class="line"><span class="number">750</span>: b9400000 ldr w0, [x0]            <span class="comment">//load run to w0</span></span><br><span class="line"><span class="number">754</span>: d503201f nop</span><br><span class="line"><span class="number">758</span>: <span class="number">35000000</span> cbnz w0, <span class="number">758</span> &lt;foo+<span class="number">0x10</span>&gt; <span class="comment">//if (w0) while (1);</span></span><br><span class="line"><span class="number">75</span>c: d65f03c0 ret</span><br></pre></td></tr></table></figure>

<p>但实际上编译器帮我们优化成了等效下面的样子：这样永远也不会退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> reg = run;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (reg)</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此加上内存屏障如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (run)</span><br><span class="line">        cpu_relax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="2-1-2-3-read-once">2.1.2.3 READ_ONCE()</span><a href="#2-1-2-3-read-once" class="header-anchor">#</a></h4><p>也可用这种方式作为内存屏障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> run = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (READ_ONCE(run)) <span class="comment">/* similar to while (*(volatile int *)&amp;run) */</span></span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-yuan-zi-cao-zuo">2.2 原子操作</span><a href="#2-2-yuan-zi-cao-zuo" class="header-anchor">#</a></h2><h3><span id="2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru">2.2.0 临界区的原子操作引入</span><a href="#2-2-0-lin-jie-qu-de-yuan-zi-cao-zuo-yin-ru" class="header-anchor">#</a></h3><p>所谓的临界区就是共享数据段，如全局变量，对于临界区必须保证一次只有一个线程访问，也就是要保证临 界区是原子访问的。我们都知道，原子是化学反应不可再分的基本微粒，这里的原子访问就表示这一个访问是一个步骤，不能再进行拆分。</p>
<p>示例1：</p>
<p><code>a=3;</code></p>
<p>假设变量 a 的地址为 0X3000000，“a&#x3D;3”这一行 C 语言可能会被编译为如下所示的汇编代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldr r0, =<span class="number">0X30000000</span> <span class="comment">/* 变量 a 地址 */</span></span><br><span class="line"><span class="number">2</span> ldr r1, = <span class="number">3</span> <span class="comment">/* 要写入的值 */</span></span><br><span class="line"><span class="number">3</span> str r1, [r0] <span class="comment">/* 将 3 写入到 a 变量中 */</span></span><br></pre></td></tr></table></figure>

<p>如果多线程同时执行这条语句。我们期望的执行顺序：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/1.png" alt="image"></p>
<p>实际执行顺序可能是：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/2.png" alt="image"></p>
<p>线程 A 最终将变量 a 设置为了 20，而并不是要求的 10线程 B 没有问题，是期望的a设置成了20，这就是并发竞态。我们希望三条汇编指令一次性执行完，不被打断和拆解，这就是原子操作。</p>
<h2><span id></span><a href="#" class="header-anchor">#</a></h2><h3><span id="2-2-1-zheng-shu-yuan-zi-cao-zuo-api">2.2.1 整数原子操作API</span><a href="#2-2-1-zheng-shu-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> counter;</span><br><span class="line">&#125; <span class="type">atomic_t</span>;</span><br><span class="line"><span class="type">atomic_t</span> b = ATOMIC_INIT(<span class="number">0</span>); <span class="comment">//定义原子变量 b 并赋初值为 0</span></span><br><span class="line"><span class="type">atomic_set</span>(&amp;b, <span class="number">10</span>); <span class="comment">/* 设置 b=10 */</span></span><br><span class="line"><span class="type">atomic_read</span>(&amp;b); <span class="comment">/* 读取 b 的值，肯定是 10 */</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;b); <span class="comment">/* b 的值加 1，v=11 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">long</span> <span class="type">long</span> counter;</span><br><span class="line">&#125; <span class="type">atomic64_t</span>;</span><br><span class="line"><span class="type">atomic64_t</span> c = ATOMIC64_INIT(<span class="number">0</span>); <span class="comment">//定义64位系统原子变量 c 并赋初值为 0</span></span><br><span class="line"><span class="comment">//注意：如果使用的是64 位的 SOC，那么建议使用 64 位的原子操作函数。Cortex-A7 (armv7)是 32 位的架构，Cortex-A53（armv8）64位架构。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ATOMIC_INIT(int i)</td>
<td>定义原子变量的时候对其初始化。</td>
</tr>
<tr>
<td>int atomic_read(atomic_t *v)</td>
<td>读取 v 的值，并且返回。</td>
</tr>
<tr>
<td>void atomic_set(atomic_t *v, int i)</td>
<td>向 v 写入 i 值。</td>
</tr>
<tr>
<td>void atomic_add(int i, atomic_t *v)</td>
<td>给 v 加上 i 值。</td>
</tr>
<tr>
<td>void atomic_sub(int i, atomic_t *v)</td>
<td>从 v 减去 i 值。</td>
</tr>
<tr>
<td>void atomic_inc(atomic_t *v)</td>
<td>给 v 加 1，也就是自增。</td>
</tr>
<tr>
<td>void atomic_dec(atomic_t *v)</td>
<td>从 v 减 1，也就是自减</td>
</tr>
<tr>
<td>int atomic_dec_return(atomic_t *v)</td>
<td>从 v 减 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_inc_return(atomic_t *v)</td>
<td>给 v 加 1，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_add_return(int i, atomic_t *v)</td>
<td>给 v 加 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>atomic_sub_return(int i, atomic_t *v)</td>
<td>给 v 减 i，并且返回 v 的值。</td>
</tr>
<tr>
<td>int atomic_sub_and_test(int i, atomic_t *v)</td>
<td>从 v 减 i，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_dec_and_test(atomic_t *v)</td>
<td>从 v 减 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_inc_and_test(atomic_t *v)</td>
<td>给 v 加 1，如果结果为 0 就返回真，否则返回假</td>
</tr>
<tr>
<td>int atomic_add_negative(int i, atomic_t *v)</td>
<td>给 v 加 i，如果结果为负就返回真，否则返回假</td>
</tr>
<tr>
<td>atomic_cmpxchg(atomic_t *ptr, int old, int new)</td>
<td>比较old和原子变量ptr中的值，如果相等，那么就把new值赋给原子变量。返回旧的原子变量ptr中的值</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!atomic_dec_and_test(&amp;gpioled.lock)) &#123;</span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;gpioled.lock);<span class="comment">/* 小于 0 的话就加 1,使其原子变量等于 0 */</span></span><br><span class="line">		<span class="keyword">return</span> -EBUSY; <span class="comment">/* LED 被使用，返回忙 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    filp-&gt;private_data = &amp;gpioled;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> =</span> filp-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭驱动文件的时候释放原子变量 */</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;dev-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;gpioled.lock, <span class="number">1</span>); <span class="comment">/* 原子变量初始值为 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该例子用来实现一次只能允许一个应用访问 LED 灯，不能多个进程同时操作LED。第一个用户程序进行open,成功此时原子值counter&#x3D;0，第二个用户程序进行open就会fail, 直到第一个用户程序close, counter会进行加一，此时第二个程序才可以open成功。</p>
<h3><span id="2-2-2-wei-yuan-zi-cao-zuo-api">2.2.2 位原子操作API</span><a href="#2-2-2-wei-yuan-zi-cao-zuo-api" class="header-anchor">#</a></h3><p>原 子位操作不像原子整形变量那样有个 atomic_t 的数据结构，原子位操作是直接对内存进行操作：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1。</td>
</tr>
<tr>
<td>void clear_bit(int nr,void *p)</td>
<td>将 p 地址的第 nr 位清零。</td>
</tr>
<tr>
<td>void change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位进行翻转。</td>
</tr>
<tr>
<td>int test_bit(int nr, void *p)</td>
<td>获取 p 地址的第 nr 位的值。</td>
</tr>
<tr>
<td>int test_and_set_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位置 1，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_clear_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位清零，并且返回 nr 位原来的值。</td>
</tr>
<tr>
<td>int test_and_change_bit(int nr, void *p)</td>
<td>将 p 地址的第 nr 位翻转，并且返回 nr 位原来的值。</td>
</tr>
</tbody></table>
<h2><span id="2-3-zi-xuan-suo">2.3 自旋锁</span><a href="#2-3-zi-xuan-suo" class="header-anchor">#</a></h2><p>原子操作只能对整形变量或者位进行保护，但是，在实际的使用环境中怎么可能只有整形 变量或位这么简单的临界区。</p>
<p>自旋锁的定义：</p>
<p>对于自旋锁而言，如果自旋锁 正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态，线 程 B 不会进入休眠状态或者说去做其他的处理，而是会一直傻傻的在那里“转圈圈”的等待锁 可用。比如现在有个公用电话亭，一次肯定只能进去一个人打电话，现在电话亭里面有人正在 打电话，相当于获得了自旋锁。此时你到了电话亭门口，因为里面有人，所以你不能进去打电 话，相当于没有获取自旋锁，这个时候你肯定是站在原地等待，你可能因为无聊的等待而转圈 圈消遣时光，反正就是哪里也不能去，要一直等到里面的人打完电话出来。终于，里面的人打 完电话出来了，相当于释放了自旋锁，这个时候你就可以使用电话亭打电话了，相当于获取到 了自旋锁。</p>
<p> 自旋锁的“自旋”也就是“原地打转”的意思，“原地打转”的目的是为了等待自旋锁可以 用，可以访问共享资源。把自旋锁比作一个变量 a，变量 a&#x3D;1 的时候表示共享资源可用，当 a&#x3D;0 的时候表示共享资源不可用。现在线程 A 要访问共享资源，发现 a&#x3D;0(自旋锁被其他线程持有)， 那么线程 A 就会不断的查询 a 的值，直到 a&#x3D;1。可</p>
<p><code>缺点：获取自旋锁会原地等待，会浪费处理器时间，降低系统性能，所以自旋锁 的持有时间不能太长。如果临界区比较大，运行时间比较长的话要选择信号量和互斥体。</code></p>
<p><code>适用范围：适用于短时期的轻量级加锁。</code></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/3.png" alt="image"></p>
<h3><span id="2-3-1-zi-xuan-suo-api">2.3.1 自旋锁API</span><a href="#2-3-1-zi-xuan-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SPINLOCK(spinlock_t lock)</td>
<td>定义并初始化一个自选变量。</td>
</tr>
<tr>
<td>int spin_lock_init(spinlock_t *lock)</td>
<td>初始化自旋锁。</td>
</tr>
<tr>
<td>void spin_lock(spinlock_t *lock)</td>
<td>获取指定的自旋锁，也叫做加锁。</td>
</tr>
<tr>
<td>void spin_unlock(spinlock_t *lock)</td>
<td>释放指定的自旋锁。</td>
</tr>
<tr>
<td>int spin_trylock(spinlock_t *lock)</td>
<td>尝试获取指定的自旋锁，如果没有获取到就返回 0</td>
</tr>
<tr>
<td>int spin_is_locked(spinlock_t *lock)</td>
<td>检查指定的自旋锁是否被获取，如果没有被获取就返回非 0，否则返回 0。</td>
</tr>
</tbody></table>
<p>被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的 API 函数，否则的话会可能会导致死锁现象（不能带锁休眠）。因为自旋锁会禁止抢占，也就说当线程 A 得到锁以后会暂时禁止内核抢占，那既然禁止内核抢占自己又休眠了，粗俗的形容就是“占着茅坑不拉屎”，自己休眠了又没有释放锁就导致死锁。</p>
<h4><span id="2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan">2.3.1.1 自旋锁和中断相关</span><a href="#2-3-1-1-zi-xuan-suo-he-zhong-duan-xiang-guan" class="header-anchor">#</a></h4><p>中断里面访问临界资源，也是可以使用自旋锁的，但是在获取锁之前一定要先禁止本地中断。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_irq(spinlock_t *lock)</td>
<td>禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irq(spinlock_t *lock)</td>
<td>激活本地中断，并释放自旋锁。</td>
</tr>
<tr>
<td>void spin_lock_irqsave(spinlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取自旋锁。</td>
</tr>
<tr>
<td>void spin_unlock_irqrestore(spinlock_t*lock, unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁</td>
</tr>
</tbody></table>
<p>如下图就是没有禁止本地中断导致死锁的例子：</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/4.png" alt="image"></p>
<p>线程 A 先运行，并且获取到了 lock 这个锁，当线程 A 运行 <code>functionA </code>函 数的时候中断发生了，中断抢走了 CPU 使用权。右边的中断服务函数也要获取 lock 这个锁， 但是这个锁被线程 A 占有着，中断就会一直自旋，等待锁有效。但是在中断服务函数执行完之前，线程 A 是不可能执行的，线程 A 说“你先放手”，中断说“你先放手”，场面就这么僵持着， 死锁发生！</p>
<p>使用<code> spin_lock_irq/spin_unlock_irq</code> 的时候需要用户能够确定加锁之前的中断状态，但实际上我们是很难确定某个时刻的中断状态，因此不推荐使用<code> spin_lock_irq/spin_unlock_irq</code>。建议使用 <code>spin_lock_irqsave/spin_unlock_irqrestore</code>，因为这一组函数会保存中断状态，在释放锁的时候会恢复中断状态。一般在线程中使用<code> spin_lock_irqsave/ spin_unlock_irqrestore</code>，在中断中使用<code> spin_lock/spin_unlock</code>，例如下面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock);</span><br><span class="line"><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">functionA</span> <span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">/* 中断状态 */</span></span><br><span class="line">	spin_lock_irqsave(&amp;lock, flags); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock_irqrestore(&amp;lock, flags); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">irq</span><span class="params">()</span> &#123;</span><br><span class="line">	spin_lock(&amp;lock); <span class="comment">/* 获取锁 */</span></span><br><span class="line">	<span class="comment">/* 临界区 */</span></span><br><span class="line">	spin_unlock(&amp;lock); <span class="comment">/* 释放锁 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有人说为什么中断服务程序不去使用<code>spin_lock_irqsave</code>呢？ 难道不需要去禁止中断吗？</p>
<p>因为GIC中断总入口已经帮我们做了禁止中断。调用了<code>local_irq_disable()</code>,详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17517136.html">设备驱动-10.中断子系统-1异常中断引入 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/5.png" alt="image"></p>
<p>如果下半部(BH)也会竞争共享资源，要在下半部里面使用自旋锁:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void spin_lock_bh(spinlock_t *lock)</td>
<td>关闭下半部，并获取自旋锁</td>
</tr>
<tr>
<td>void spin_unlock_bh(spinlock_t *lock)</td>
<td>打开下半部，并释放自旋锁</td>
</tr>
</tbody></table>
<h3><span id="2-3-2-du-xie-zi-xuan-suo">2.3.2 读写自旋锁</span><a href="#2-3-2-du-xie-zi-xuan-suo" class="header-anchor">#</a></h3><p>读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。但是当没有写操作的时候允许一个或多个线程持有读锁， 可以进行并发的读操作。Linux 内核使用 rwlock_t 结构体表示读写锁，结构体定义如下(删除了 条件编译)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 	<span class="type">arch_rwlock_t</span> raw_lock;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>现在有个学生信息表，此表存放着学生的年龄、家庭住址、班级等信息，此表可以随时被 修改和读取，那么必须要对其进行保护，如果我们现在使用自旋锁对其进行 保护。每次只能一个读操作或者写操作，但是，实际上此表是可以并发读取的。只需要保证在 修改此表的时候没人读取，或者在其他人读取此表的时候没有人修改此表就行了。也就是此表 的读和写不能同时进行，但是可以多人并发的读取此表。像这样，当某个数据结构符合读&#x2F;写或 生产者&#x2F;消费者模型的时候就可以使用读写自旋锁。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_RWLOCK(rwlock_t lock)</td>
<td>定义并初始化读写锁</td>
</tr>
<tr>
<td>void rwlock_init(rwlock_t *lock)</td>
<td>初始化读写锁。</td>
</tr>
<tr>
<td>读操作</td>
<td></td>
</tr>
<tr>
<td>void read_lock(rwlock_t *lock)</td>
<td>获取读锁。</td>
</tr>
<tr>
<td>void read_unlock(rwlock_t *lock)</td>
<td>释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放读锁。</td>
</tr>
<tr>
<td>void read_lock_irqsave(rwlock_t *lock, unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void read_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void read_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
<tr>
<td>写操作</td>
<td></td>
</tr>
<tr>
<td>void write_lock(rwlock_t *lock)</td>
<td>获取写锁。</td>
</tr>
<tr>
<td>void write_unlock(rwlock_t *lock)</td>
<td>释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irq(rwlock_t *lock)</td>
<td>禁止本地中断，并且获取写锁。</td>
</tr>
<tr>
<td>void write_unlock_irq(rwlock_t *lock)</td>
<td>打开本地中断，并且释放写锁。</td>
</tr>
<tr>
<td>void write_lock_irqsave(rwlock_t *lock,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写锁</td>
</tr>
<tr>
<td>void write_unlock_irqrestore(rwlock_t *lock,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放读锁。</td>
</tr>
<tr>
<td>void write_lock_bh(rwlock_t *lock)</td>
<td>关闭下半部，并获取读锁。</td>
</tr>
<tr>
<td>void write_unlock_bh(rwlock_t *lock)</td>
<td>打开下半部，并释放读锁。</td>
</tr>
</tbody></table>
<h3><span id="2-3-3-shun-xu-suo">2.3.3 顺序锁</span><a href="#2-3-3-shun-xu-suo" class="header-anchor">#</a></h3><p>顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> 		<span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> <span class="title">seqcount</span>;</span></span><br><span class="line"> 		<span class="type">spinlock_t</span> lock;</span><br><span class="line">&#125; <span class="type">seqlock_t</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEQLOCK(seqlock_t sl)</td>
<td>定义并初始化顺序锁</td>
</tr>
<tr>
<td>void seqlock_ini seqlock_t *sl)</td>
<td>初始化顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock(seqlock_t *sl)</td>
<td>获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock(seqlock_t *sl)</td>
<td>释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irq(seqlock_t *sl)</td>
<td>禁止本地中断，并且获取写顺序锁</td>
</tr>
<tr>
<td>void write_sequnlock_irq(seqlock_t *sl)</td>
<td>打开本地中断，并且释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_irqsave(seqlock_t *sl,unsigned long flags)</td>
<td>保存中断状态，禁止本地中断，并获取写顺序锁。</td>
</tr>
<tr>
<td>void write_sequnlock_irqrestore(seqlock_t *sl,unsigned long flags)</td>
<td>将中断状态恢复到以前的状态，并且激活本地中断，释放写顺序锁。</td>
</tr>
<tr>
<td>void write_seqlock_bh(seqlock_t *sl)</td>
<td>关闭下半部，并获取写读锁。</td>
</tr>
<tr>
<td>void write_sequnlock_bh(seqlock_t *sl)</td>
<td>打开下半部，并释放写读锁。</td>
</tr>
<tr>
<td>unsigned read_seqbegin(const seqlock_t *sl)</td>
<td>读单元访问共享资源的时候调用此函数，此函数会返回顺序锁的顺序号。</td>
</tr>
<tr>
<td>unsigned read_seqretry(const seqlock_t *sl,unsigned start)</td>
<td>读结束以后调用此函数检查在读的过程中有没有对资源进行写操作，如果有的话就要重读</td>
</tr>
</tbody></table>
<h2><span id="2-4-xin-hao-liang">2.4 信号量</span><a href="#2-4-xin-hao-liang" class="header-anchor">#</a></h2><p>相比于自旋锁，信号量可以使线程进入休眠状态，比如 A 与 B、C 合租了一套房子，这个 房子只有一个厕所，一次只能一个人使用。某一天早上 A 去上厕所了，过了一会 B 也想用厕 所，因为 A 在厕所里面，所以 B 只能等到 A 用来了才能进去。B 要么就一直在厕所门口等着， 等 A 出来，这个时候就相当于自旋锁。B 也可以告诉 A，让 A 出来以后通知他一下，然后 B 继 续回房间睡觉，这个时候相当于信号量。可以看出，使用信号量会提高处理器的使用效率，毕 竟不用一直傻乎乎的在那里“自旋”等待。但是，信号量的开销要比自旋锁大，因为信号量使 线程进入休眠状态以后会切换线程，切换线程就会有开销。</p>
<p>信号量的特点： </p>
<p><code>适用于那些占用资源比较久的场合，如线程同步。</code></p>
<p><code>因此信号量等待不能用于中断中，因为中断不能休眠。</code></p>
<h3><span id="2-4-1-xin-hao-liang-api">2.4.1 信号量 API</span><a href="#2-4-1-xin-hao-liang-api" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	 <span class="type">raw_spinlock_t</span> lock;</span><br><span class="line">	 <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_SEAMPHORE(name)</td>
<td>定义一个信号量，并且设置信号量的值为 1。</td>
</tr>
<tr>
<td>void sema_init(struct semaphore *sem, int val)</td>
<td>初始化信号量 sem，设置信号量值为 val。</td>
</tr>
<tr>
<td>void down(struct semaphore *sem)</td>
<td>获取信号量，因为会导致休眠，因此不能在中断中使用。</td>
</tr>
<tr>
<td>int down_trylock(struct semaphore *sem);</td>
<td>尝试获取信号量，如果能获取到信号量就获取，并且返回 0。如果不能就返回非 0，并且不会进入休眠。</td>
</tr>
<tr>
<td>int down_interruptible(struct semaphore *sem)</td>
<td>获取信号量，和 down 类似，只是使用 down 进入休眠状态的线程不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</td>
</tr>
<tr>
<td>void up(struct semaphore *sem)</td>
<td>释放信号量</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span> <span class="comment">/* 定义信号量 */</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>); <span class="comment">/* 初始化信号量 */</span></span><br><span class="line">threadA()&#123;</span><br><span class="line">    down(&amp;sem); <span class="comment">/* 申请信号量 */</span></span><br><span class="line">&#125;</span><br><span class="line">theadB()&#123;</span><br><span class="line">    up(&amp;sem); <span class="comment">/* 释放信号量 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-5-hu-chi-suo">2.5 互斥锁</span><a href="#2-5-hu-chi-suo" class="header-anchor">#</a></h2><p>将信号量的值设置为 1 就可以使用信号量进行互斥访问了，虽然可以通过信号量实现互斥，但是 Linux 提供了一个比信号量更专业的机制来进行互斥，它就是互斥体—mutex。互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">	 <span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line"> 	<span class="type">atomic_t</span> count;</span><br><span class="line">	 <span class="type">spinlock_t</span> wait_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 mutex 的时候要注意如下几点：</p>
<p><code>1. mutex 可以导致休眠，因此不能在中断中使用 mutex，中断中只能使用自旋锁。</code> </p>
<p><code>2. 和信号量一样，mutex 保护的临界区可以调用引起阻塞的 API 函数。</code></p>
<p><code> 3. 因为一次只有一个线程可以持有 mutex，因此，必须由 mutex 的持有者释放 mutex。并且 mutex 不能递归上锁和解锁。</code></p>
<h3><span id="2-5-1-hu-chi-suo-api">2.5.1 互斥锁API</span><a href="#2-5-1-hu-chi-suo-api" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DEFINE_MUTEX(name)</td>
<td>定义并初始化一个 mutex 变量。</td>
</tr>
<tr>
<td>void mutex_init(mutex *lock)</td>
<td>初始化 mutex。</td>
</tr>
<tr>
<td>void mutex_lock(struct mutex *lock)</td>
<td>获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</td>
</tr>
<tr>
<td>void mutex_unlock(struct mutex *lock)</td>
<td>释放 mutex，也就给 mutex 解锁。</td>
</tr>
<tr>
<td>int mutex_trylock(struct mutex *lock)</td>
<td>尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</td>
</tr>
<tr>
<td>int mutex_is_locked(struct mutex *lock)</td>
<td>判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</td>
</tr>
<tr>
<td>int mutex_lock_interruptible(struct mutex *lock)</td>
<td>使用此函数获取信号量失败进入休眠以后可以被信号打断</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span> <span class="comment">/* 定义一个互斥体 */</span></span><br><span class="line">mutex_init(&amp;lock); <span class="comment">/* 初始化互斥体 */</span></span><br><span class="line">mutex_lock(&amp;lock); <span class="comment">/* 上锁 */</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;lock); <span class="comment">/* 解锁 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi">2.6 SMP 架构下percpu变量机制</span><a href="#2-6-smp-jia-gou-xia-percpu-bian-liang-ji-zhi" class="header-anchor">#</a></h2><p>随着 SMP(对称多处理器架构) 的发展，程序确实是在并发执行，也为数据同步带来了更大的挑战。</p>
<p>在 SMP 架构中，每个 CPU 都拥有自己的高速缓存，通常，L1 cache 是 CPU 独占的，每个 CPU 都有一份，它的速度自然是最快的，而 L2 cache 通常是所有 CPU 共享的高速缓存，当 CPU 载入一个全局数据时，会逐级地查看高速缓存，如果没有在缓存中命中，就从内存中载入，并加入到各级 cache 中，当下次需要读取这个值时，直接读取 cache 。</p>
<p>假如进程在 CPU0 上操作一个共享变量，在某个时刻进程被调度到 CPU1 上执行时，CPU0 和 CPU1 上的 共享变量值就不同。</p>
<p><strong>percpu机制</strong>：为了避免多个 CPU 对全局数据的竞争而导致的性能损失，<strong>percpu 直接为每个 CPU 生成一份独有的数据备份，每个数据备份占用独立的内存</strong>，CPU 不应该修改不属于自己的这部分数据，这样就避免了多 CPU 对全局数据的竞争问题。</p>
<h3><span id="2-6-0-percpu-bian-liang-de-cun-chu-ge-shi">2.6.0 percpu 变量的存储格式</span><a href="#2-6-0-percpu-bian-liang-de-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>对于普通的变量而言，变量的加载地址就是程序中使用的该变量的地址，可以使用取址符获取变量地址。</p>
<p><strong>percpu 变量</strong>：percpu 变量的加载地址是不允许访问的，取而代之的是对于 n 核的 SMP 架构系统，内核将会为每一个 CPU 另行开辟一片内存，将该 percpu 变量复制 n 份分别放在每个 CPU 独有的内存区中。</p>
<p><img src="/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/6.png" alt="image"></p>
<p>也就是说，为 percpu 分配内存的时候，原始的变量 var 与 percpu 变量内存偏移值 offset 被保存了下来，每个 CPU 对应的 percpu 变量地址为 <code>(&amp;var + offset)</code>，当然真实情况要比这个复杂，将在后文中讲解。</p>
<h3><span id="2-6-1-percpu-bian-liang-shi-yong-chang-jing">2.6.1 percpu变量使用场景</span><a href="#2-6-1-percpu-bian-liang-shi-yong-chang-jing" class="header-anchor">#</a></h3><ol>
<li>计数器和统计信息：如果你有计数器或者统计信息需要在每个CPU上独立维护，那么<code>percpu</code>变量将会非常有用。</li>
<li>异步任务处理：通过<code>percpu</code>变量来维护异步任务的上下文信息。</li>
</ol>
<h3><span id="2-6-2-percpu-bian-liang-de-ding-yi">2.6.2 percpu 变量的定义</span><a href="#2-6-2-percpu-bian-liang-de-ding-yi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(type, name);<span class="comment">//静态定义一个 percpu变量，type 是变量类型，name 是变量名</span></span><br><span class="line"></span><br><span class="line">type __percpu *ptr <span class="title function_">alloc_percpu</span><span class="params">(type)</span>;<span class="comment">//动态分配一个percpu变量ptr,这只是一个原始数据，真正被使用的数据被 copy 成 n(n=CPU数量) 份分别保存在每个 CPU 独占的地址空间中，在访问 percpu 变量时就是对每个副本进行访问。</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-6-3-percpu-bian-liang-de-du-xie">2.6.3 percpu 变量的读写</span><a href="#2-6-3-percpu-bian-liang-de-du-xie" class="header-anchor">#</a></h3><p><strong>静态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="type">int</span>, val)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前CPU的percpu变量的值</span></span><br><span class="line"><span class="type">int</span> value = per_cpu(val, smp_processor_id());</span><br><span class="line"><span class="comment">// 遍历所有CPU，并打印percpu变量的值</span></span><br><span class="line">for_each_possible_cpu(cpu) &#123;</span><br><span class="line">    value = per_cpu(val, cpu);</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;my_percpu_var on CPU%d is %d\n&quot;</span>, cpu, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*put_cpu_var 和 get_cpu_var 是成对出现的,因为这段期间内静止内核抢占，</span></span><br><span class="line"><span class="comment"> *它们之间的代码不宜执行太长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> *pint = &amp;get_cpu_var(val);<span class="comment">//获取当前 CPU 的 percpu 变量的地址进行操作</span></span><br><span class="line">*pint++;</span><br><span class="line">put_cpu_var(val);</span><br></pre></td></tr></table></figure>

<p>为什么在调用 <code>get_cpu_var </code>时，第一步是禁止内核抢占呢?</p>
<p>想想这样一个场景，进程 A 在 CPU0 上执行，读取了 percpu 变量到寄存器中，这时候进程被高优先级进程抢占，继续执行的时候可能被转移到 CPU1 上执行，这时候在 CPU1 执行的代码操作的仍旧是 CPU0 上的 percpu 变量，这显然是错误的。</p>
<p><strong>动态定义的读写</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pint = alloc_percpu(<span class="type">int</span>);</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> *p = per_cpu_ptr(pint,raw_smp_processor_id());<span class="comment">//与静态变量的操作接口不一样，这个接口允许指定 CPU ，不再是只能获取当前 CPU 的值</span></span><br><span class="line">(*p)++;</span><br></pre></td></tr></table></figure>

<p><code>raw_smp_processor_id() </code>函数返回<code>当前 CPU num</code>，这个示例也就是操作当前 CPU 的 percpu 变量，这个接口<strong>并不需要禁止内核抢占</strong>，因为不管进程被切换到哪个 CPU 上执行，它所操作的都是第二个参数提供的 CPU。</p>
<h3><span id="2-6-4-percpu-bian-liang-shi-xian-yuan-li">2.6.4 percpu 变量实现原理</span><a href="#2-6-4-percpu-bian-liang-shi-xian-yuan-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    DEFINE_PER_CPU_SECTION(type, name, <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU_SECTION(type, name, sec)             \</span></span><br><span class="line"><span class="meta">    __PCPU_ATTRS(sec) PER_CPU_DEF_ATTRIBUTES            \</span></span><br><span class="line"><span class="meta">    __typeof__(type) name</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PCPU_ATTRS(sec)                       \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(PER_CPU_BASE_SECTION sec))) \</span></span><br><span class="line"><span class="meta">    PER_CPU_ATTRIBUTES</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data..percpu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> PER_CPU_BASE_SECTION <span class="string">&quot;.data&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>展开：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFINE_PER_CPU(type, name)                  \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data..percpu&quot;</span>))) type name;  \ </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span>   \</span></span><br><span class="line"><span class="meta">    __percpu __attribute__((section(<span class="string">&quot;.data&quot;</span>))) type name; \</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>在 SMP 架构下，被定义的 percpu 变量在编译后放在<code> .data..percpu</code> 这个 section 中;</li>
<li>在单核系统中， percpu 变量被放在<code>.data</code>也就是数据段中;</li>
</ol>
<h4><span id="2-6-4-1-get-cpu-var-shi-xian">2.6.4.1 get_cpu_var实现</span><a href="#2-6-4-1-get-cpu-var-shi-xian" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    this_cpu_ptr(&amp;var);                     \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> this_cpu_ptr(ptr) raw_cpu_ptr(ptr)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raw_cpu_ptr(ptr)                        \</span></span><br><span class="line"><span class="meta">(&#123;                                              \</span></span><br><span class="line"><span class="meta">    __verify_pcpu_ptr(ptr);                     \</span></span><br><span class="line"><span class="meta">    arch_raw_cpu_ptr(ptr);                      \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>首先，<code>preempt_disable </code>禁用内核抢占，然后使用 <code>this_cpu_ptr </code>接口获取当前 cpu 上对应的 var 变量地址。</p>
<p>对<code>get_cpu_var</code>展开：可以看到就能准确获取当前cpu的val地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_cpu_var(var)                    \</span></span><br><span class="line"><span class="meta">(*(&#123;                                        \</span></span><br><span class="line"><span class="meta">    preempt_disable();                      \</span></span><br><span class="line"><span class="meta">    &amp;var + __per_cpu_offset[raw_smp_processor_id()]  \</span></span><br><span class="line"><span class="meta">&#125;))</span></span><br></pre></td></tr></table></figure>

<p>使用完变量之后记得调用 <code>put_cpu_var</code> 以使能内核抢占功能，恢复系统状态。</p>
<h1><span id="3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing">3 linux内核下不同同步机制的适用场景</span><a href="#3-linux-nei-he-xia-bu-tong-tong-bu-ji-zhi-de-gua-yong-chang-jing" class="header-anchor">#</a></h1><ol>
<li>原子操作：主要用于进行原子性的读写操作，适用于计数器等场景。</li>
<li>自旋锁：用于短时间内锁定互斥资源，适用于锁持有时间短的场景。</li>
<li>读写锁：用于提供读模式和写模式下的锁操作，适用于读多写少的场景。</li>
<li>MUTEX：类似自旋锁，但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。(允许休眠)</li>
<li>信号量：用于实现互斥和同步，适用于保护临界区和控制访问频率。但是可以导致调用线程睡眠，适用于锁持有时间较长的场景。（允许休眠）</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/20/Linux%E5%86%85%E6%A0%B8-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%90%8C%E6%AD%A5/" data-id="clyylnk8h000a7wufe9802gxg" data-title="Linux内核-并发与同步" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/07/21/Linux%E5%86%85%E6%A0%B8-kmalloc%E4%B8%8Evmalloc%E5%8F%8ACMA%E5%86%85%E5%AD%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux内核-kmalloc与vmalloc及CMA内存
        
      </div>
    </a>
  
  
    <a href="/2024/07/20/Linux%E5%86%85%E6%A0%B8-rootfs%E6%9E%84%E5%BB%BA%E7%A7%BB%E6%A4%8D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux内核-rootfs构建移植</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 15px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 19px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 17px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 16px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 18px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 20px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 12px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 17px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-poll%E5%BA%95%E5%B1%82%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/">字符设备驱动-6-poll底层驱动机制</a>
          </li>
        
          <li>
            <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/">字符设备驱动-6-pre-休眠唤醒机制</a>
          </li>
        
          <li>
            <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/">字符设备驱动-5-设备树函数</a>
          </li>
        
          <li>
            <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/">字符设备驱动-4-设备树</a>
          </li>
        
          <li>
            <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-3-GPIO%E9%A9%B1%E5%8A%A8KEY%E7%A4%BA%E4%BE%8B/">字符设备驱动-3-GPIO驱动KEY示例</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>