<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>字符设备驱动-5-设备树函数 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1.设备树相关的头文件 2.设备树相关的函数 2.1 找res属性和platform device 2.2 找节点 2.3 找到属性 2.3.1 找到属性所指向的节点 2.3.2 设备节点找到资源信息   2.4 获取属性的值 2.5 读整数 u32&#x2F;u64 2.6 读数组 2.7 读字符串 2.8 其他of函数   3 使用设备树示例 3.1 led灯驱动设备树方式实现 3.">
<meta property="og:type" content="article">
<meta property="og:title" content="字符设备驱动-5-设备树函数">
<meta property="og:url" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.设备树相关的头文件 2.设备树相关的函数 2.1 找res属性和platform device 2.2 找节点 2.3 找到属性 2.3.1 找到属性所指向的节点 2.3.2 设备节点找到资源信息   2.4 获取属性的值 2.5 读整数 u32&#x2F;u64 2.6 读数组 2.7 读字符串 2.8 其他of函数   3 使用设备树示例 3.1 led灯驱动设备树方式实现 3.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/1.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2-1.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/3.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/4.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/5.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/6.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/7.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/8.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/9.png">
<meta property="og:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/10.png">
<meta property="article:published_time" content="2024-07-28T12:22:21.000Z">
<meta property="article:modified_time" content="2024-07-28T12:40:07.808Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux设备驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-字符设备驱动-5-设备树函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2024-07-28T12:22:21.000Z" itemprop="datePublished">2024-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      字符设备驱动-5-设备树函数
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</a></li>
<li><a href="#2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</a><ul>
<li><a href="#2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</a></li>
<li><a href="#2-2-zhao-jie-dian">2.2 找节点</a></li>
<li><a href="#2-3-zhao-dao-shu-xing">2.3 找到属性</a><ul>
<li><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</a></li>
<li><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</a></li>
</ul>
</li>
<li><a href="#2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</a></li>
<li><a href="#2-5-du-zheng-shu-u32-u64">2.5 读整数 u32&#x2F;u64</a></li>
<li><a href="#2-6-du-shu-zu">2.6 读数组</a></li>
<li><a href="#2-7-du-zi-fu-chuan">2.7 读字符串</a></li>
<li><a href="#2-8-qi-ta-of-han-shu">2.8 其他of函数</a></li>
</ul>
</li>
<li><a href="#3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</a><ul>
<li><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</a></li>
<li><a href="#3-2-qu-dong-cheng-xu">3.2 驱动程序</a></li>
</ul>
</li>
<li><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</a><ul>
<li><a href="#4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</a><ul>
<li><a href="#4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</a></li>
<li><a href="#4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</a></li>
<li><a href="#4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</a><ul>
<li><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</a><ul>
<li><a href="#4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</a></li>
</ul>
</li>
<li><a href="#4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</a><ul>
<li><a href="#5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</a></li>
<li><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</a></li>
<li><a href="#5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-she-bei-shu-xiang-guan-de-tou-wen-jian">1.设备树相关的头文件</span><a href="#1-she-bei-shu-xiang-guan-de-tou-wen-jian" class="header-anchor">#</a></h1><p>1.处理 <code>DTB</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">of_fdt.h <span class="comment">// dtb 文件的相关操作函数, 我们一般用不到,</span></span><br><span class="line"><span class="comment">// 因为 dtb 文件在内核中已经被转换为 device_node 树(它更易于使用)</span></span><br></pre></td></tr></table></figure>
<p>2.处理 <code>device_node</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">of.h <span class="comment">// 提供设备树的一般处理函数,</span></span><br><span class="line"><span class="comment">// 比如 of_property_read_u32(读取某个属性的 u32 值),</span></span><br><span class="line"><span class="comment">// of_get_child_count(获取某个 device_node 的子节点数)</span></span><br><span class="line">of_address.h <span class="comment">// 地址相关的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_get_address(获得 reg 属性中的 addr, size 值)</span></span><br><span class="line"><span class="comment">// of_match_device (从 matches 数组中取出与当前设备最匹配的一项)</span></span><br><span class="line">of_dma.h <span class="comment">// 设备树中 DMA 相关属性的函数</span></span><br><span class="line">of_gpio.h <span class="comment">// GPIO 相关的函数</span></span><br><span class="line">of_graph.h <span class="comment">// GPU 相关驱动中用到的函数, 从设备树中获得 GPU 信息</span></span><br><span class="line">of_iommu.h <span class="comment">// 很少用到</span></span><br><span class="line">of_irq.h <span class="comment">// 中断相关的函数</span></span><br><span class="line">of_mdio.h <span class="comment">// MDIO (Ethernet PHY) API</span></span><br><span class="line">of_net.h <span class="comment">// OF helpers for network devices.</span></span><br><span class="line">of_pci.h <span class="comment">// PCI 相关函数</span></span><br><span class="line">of_pdt.h <span class="comment">// 很少用到</span></span><br><span class="line">of_reserved_mem.h <span class="comment">// reserved_mem 的相关函数</span></span><br></pre></td></tr></table></figure>
<p>3.处理<code> platform_device</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">of_platform.h <span class="comment">// 把 device_node 转换为 platform_device 时用到的函数,</span></span><br><span class="line"><span class="comment">// 比如 of_device_alloc(根据 device_node 分配设置 platform_device),</span></span><br><span class="line"><span class="comment">// of_find_device_by_node (根据 device_node 查找到 platform_device),</span></span><br><span class="line"><span class="comment">// of_platform_bus_probe (处理 device_node 及它的子节点)</span></span><br><span class="line">of_device.h <span class="comment">// 设备相关的函数, 比如 of_match_device</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-she-bei-shu-xiang-guan-de-han-shu">2.设备树相关的函数</span><a href="#2-she-bei-shu-xiang-guan-de-han-shu" class="header-anchor">#</a></h1><h2><span id="2-1-zhao-res-shu-xing-he-platform-device">2.1 找res属性和platform device</span><a href="#2-1-zhao-res-shu-xing-he-platform-device" class="header-anchor">#</a></h2><p><strong>of_find_device_by_node</strong><br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> platform_device *<span class="title function_">of_find_device_by_node</span><span class="params">(<span class="keyword">struct</span> device_node *np)</span>;</span><br></pre></td></tr></table></figure>
<p>设备树中的每一个节点，在内核里都有一个 <code>device_node</code>；你可以使用device_node 去找到对应的 <code>platform_device</code>。</p>
<p><strong>platform_get_resource</strong><br>这 个 函 数 跟 设 备 树 没 什 么 关 系 ， 但 是 设 备 树 中 的 节 点 被 转 换 为<code> platform_device</code> 后，设备树中的<code> reg 属性、interrupts 属性</code>也会被转换为<code>“resource”</code>。 这时，你可以使用这个函数取出这些资源。<br>函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* platform_get_resource - get a resource for a device</span></span><br><span class="line"><span class="comment">* @dev: platform device</span></span><br><span class="line"><span class="comment">* @type: resource type // 取哪类资源？IORESOURCE_MEM、IORESOURCE_REG</span></span><br><span class="line"><span class="comment">* // IORESOURCE_IRQ 等</span></span><br><span class="line"><span class="comment">* @num: resource index // 这类资源中的哪一个？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> resource *<span class="title function_">platform_get_resource</span><span class="params">(<span class="keyword">struct</span> platform_device *dev, <span class="type">unsigned</span> <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>
<p>对于设备树节点中的 reg 属性，它对应 <code>IORESOURCE_MEM</code> 类型的资源； 对于设备树节点中的 interrupts 属性，它对应 <code>IORESOURCE_IRQ</code> 类型的资源。</p>
<h2><span id="2-2-zhao-jie-dian">2.2 找节点</span><a href="#2-2-zhao-jie-dian" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/1.png" alt="image"></p>
<p><strong>of_find_node_by_path</strong><br>根据路径找到节点，比如<code>“/”</code>就对应根节点，<code>“/memory”</code>对应 memory 节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_path</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span>;c</span><br></pre></td></tr></table></figure>

<p><strong>of_find_node_by_name</strong><br>根据名字找到节点，节点如果定义了 name 属性，那我们可以根据名字找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_name</span><span class="params">(<span class="keyword">struct</span> device_node *from,<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“name”</code>属性，所以这函数也不建议 使用。<br><strong>of_find_node_by_type</strong><br>根据类型找到节点，节点如果定义了 device_type 属性，那我们可以根据类型找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_type</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br></pre></td></tr></table></figure>
<p>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。 但是在设备树的官方规范中不建议使用<code>“device_type”</code>属性，所以这函数也不建议使用。<br><strong>of_find_compatible_node</strong><br>根据<code> device_type</code>和<code>compatible</code> 找到节点，节点如果定义了 <code>compatible</code> 属性，那我们可以根据 <code>compatible </code>属性找到它。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_compatible_node</span><span class="params">(<span class="keyword">struct</span> device_node *from, <span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <code>from </code>表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
<li>参数 <code>compat </code>是一个字符串，用来指定 <code>compatible </code>属性的值；</li>
<li>参数<code>type </code>是一个字符串，用来指定 <code>device_type</code> 属性的值，可以传入 NULL。</li>
</ul>
<p><strong>of_find_node_by_phandle</strong><br>根据 <code>phandle </code>找到节点。<code>dts</code> 文件被编译为 <code>dtb </code>文件时，每一个节点都有一个数字 ID，这些数字 ID 彼此不同。可以使用数字 ID 来找到 <code>device_node</code>。 这些数字 ID 就是<code> phandle</code>。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_find_node_by_phandle</span><span class="params">(phandle handle)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>of_find_matching_node_and_match</strong><br>通过<code> of_device_id</code> 匹配表来查找指定的节点.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</span></span><br><span class="line"><span class="comment">//matches：of_device_id 匹配表，也就是在此匹配表里面查找节点。</span></span><br><span class="line"><span class="comment">//match：找到的匹配的 of_device_id。</span></span><br><span class="line"><span class="comment">//返回值：找到的节点，如果为 NULL 表示查找失败</span></span><br><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_find_matching_node_and_match</span><span class="params">(<span class="keyword">struct</span> device_node *from,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id *matches,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="keyword">struct</span> of_device_id **match)</span></span><br></pre></td></tr></table></figure>

<p><strong>of_get_parent</strong><br>找到 <code>device_node</code> 的父节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_parent</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_parent</strong><br>这个函数名比较奇怪，怎么可能有<code>“next parent”</code>？<br>它实际上也是找到 device_node 的父节点，跟<code> of_get_parent</code> 的返回结果是一样的。差别在于它多调用下列函数，把 node 节点的引用计数减少了 1。这意味着 调用<code> of_get_next_parent</code> 之后，你不再需要调用<code> of_node_put</code> 释放 node 节点。<br><code>of_node_put(node);</code><br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_parent</span><span class="params">(<span class="keyword">struct</span> device_node *node)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 from 表示从哪一个节点开始寻找，传入 NULL 表示从根节点开始寻找。</li>
</ul>
<p><strong>of_get_next_child</strong><br>取出下一个子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_child</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p>不断调用 <code>of_get_next_child </code>时，不断更新<code>pre</code>参数，就可以得到所有的子节点。<br><strong>of_get_next_available_child</strong><br>取出下一个 “可用” 的子节点，有些节点的 status 是<code>“disabled”</code>，那就会跳过这些节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device_node *<span class="title function_">of_get_next_available_child</span><span class="params">( <span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="keyword">struct</span> device_node *prev)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>prev 表示上一个子节点，设为 NULL 时表示想找到第 1 个子节点。</li>
</ul>
<p><strong>of_get_child_by_name</strong><br>根据名字取出子节点。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_get_child_by_name</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *node, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 node 表示父节点；</li>
<li>name 表示子节点的名字。</li>
</ul>
<h2><span id="2-3-zhao-dao-shu-xing">2.3 找到属性</span><a href="#2-3-zhao-dao-shu-xing" class="header-anchor">#</a></h2><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2.png" alt="image"></p>
<p><strong>of_find_property</strong><br>内核源码 <code>incldue/linux/of.h </code>中声明了 device_node 的操作函数，当然也包括属性的操作函数：<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> property *<span class="title function_">of_find_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: proper = of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数np表示节点，我们要在这个节点中找到名为 name 的属性。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<h3><span id="2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian">2.3.1 找到属性所指向的节点</span><a href="#2-3-1-zhao-dao-shu-xing-suo-zhi-xiang-de-jie-dian" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ion_heap0: heap_carveout@<span class="number">0</span> &#123;</span><br><span class="line">	memory-region = &lt;&amp;ion_for_npu&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> device_node *<span class="title function_">of_parse_phandle</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np,</span></span><br><span class="line"><span class="params">	<span class="type">const</span> <span class="type">char</span> *phandle_name, <span class="type">int</span> index)</span>；</span><br><span class="line"><span class="comment">//例如:</span></span><br><span class="line"><span class="comment">// get reserved memory-region</span></span><br><span class="line">res_node = of_parse_phandle(np, <span class="string">&quot;memory-region&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!res_node) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get memory region node\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line">ret = of_address_to_resource(res_node, <span class="number">0</span>, res);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;failed to get reserved region address\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi">2.3.2 设备节点找到资源信息</span><a href="#2-3-2-she-bei-jie-dian-zhao-dao-zi-yuan-xin-xi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> resource *r)</span>；</span><br></pre></td></tr></table></figure>
<h2><span id="2-4-huo-qu-shu-xing-de-zhi">2.4 获取属性的值</span><a href="#2-4-huo-qu-shu-xing-de-zhi" class="header-anchor">#</a></h2><p><strong>of_get_property</strong><br>根据名字找到节点的属性，并且返回它的值。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Find a property with a given name for a given node</span></span><br><span class="line"><span class="comment">* and return the value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *<span class="title function_">of_get_property</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> *lenp)</span>;</span><br><span class="line"><span class="comment">//eg: of_find_property(dtsled.nd, &quot;compatible&quot;, NULL);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数 np 表示节点，我们要在这个节点中找到名为 name 的属性，然后返回它的值。</li>
<li>lenp 用来保存这个属性的长度，即它的值的长度。</li>
</ul>
<p><strong>of_property_count_elems_of_size</strong><br>根据名字找到节点的属性，确定它的值有多少个元素(elem)。<br>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* of_property_count_elems_of_size - Count the number of elements in a property</span><br><span class="line">*</span><br><span class="line">* @np:</span><br><span class="line">* device node from which the property value is to be read.</span><br><span class="line">* @propname: name of the property to be searched.</span><br><span class="line">* @elem_size: size of the individual element</span><br><span class="line">*</span><br><span class="line">* Search <span class="keyword">for</span> a property in a device node and count the number of elements of</span><br><span class="line">* size elem_size in it. Returns number of elements on sucess, -EINVAL <span class="keyword">if</span> the</span><br><span class="line">* property does not exist or its length does not match a multiple of elem_size</span><br><span class="line">* and -ENODATA <span class="keyword">if</span> the property does not have a value.</span><br><span class="line">*/</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_count_elems_of_size</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">int</span> elem_size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数 np 表示节点，我们要在这个节点中找到名为 propname 的属性，然后返回下列结果：<br>  <code>return prop-&gt;length / elem_size;</code><br>  在设备树中，节点大概是这样：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	xxx_pp_name = &lt;<span class="number">0x50000000</span> <span class="number">1024</span>&gt; &lt;<span class="number">0x60000000</span> <span class="number">2048</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>of_property_count_elems_of_size(np, “xxx_pp_name”, 8)</code>时，返回值是 2；</p>
</li>
<li><p>调用<code> of_property_count_elems_of_size(np, “xxx_pp_name”, 4)</code>时，返回值是 4。</p>
</li>
</ul>
<h2><span id="2-5-du-zheng-shu-u32-x2f-u64">2.5 读整数 u32&#x2F;u64</span><a href="#2-5-du-zheng-shu-u32-x2f-u64" class="header-anchor">#</a></h2><p><strong>of_property_read_u32</strong><br><strong>of_property_read_u64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">of_property_read_u32</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_value)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u64</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name1 = &lt;<span class="number">0x50000000</span>&gt;;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name1”, &amp;val)</code>时，val 将得到值 0x50000000；</li>
<li>调用 <code>of_property_read_u64 (np, “name2”, &amp;val)</code>时，val 将得到值 0x6000000050000000。</li>
</ul>
<p><strong>读某个整数 u32&#x2F;u64</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">of_property_read_u32_index</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 index, u32 *out_value)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000000</span> <span class="number">0x60000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用 <code>of_property_read_u32 (np, “name2”, 1, &amp;val)</code>时，val 将得到值 0x60000000。</li>
</ul>
<h2><span id="2-6-du-shu-zu">2.6 读数组</span><a href="#2-6-du-shu-zu" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u8_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u8 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u16_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u16 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u32_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u32 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_variable_u64_array</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, u64 *out_values, <span class="type">size_t</span> sz_min, <span class="type">size_t</span> sz_max)</span>;</span><br></pre></td></tr></table></figure>
<p>在设备树中，节点大概是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxx_node &#123;</span><br><span class="line">	name2 = &lt;<span class="number">0x50000012</span> <span class="number">0x60000034</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述例子中属性 name2 的值，长度为 8。</p>
<ul>
<li>调用 <code>of_property_read_variable_u8_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 8 个字节： <code>0x12,0x00,0x00,0x50,0x34,0x00,0x00,0x60</code>。</li>
<li>调用 <code>of_property_read_variable_u16_array (np, “name2”, out_values, 1, 10)</code>时， out_values 中将会保存这 4 个 16 位数值： <code>0x0012, 0x5000,0x0034,0x6000</code>。<br>总之，这些函数要么能取到全部的数值，要么一个数值都取不到；</li>
<li>如果值的长度在 <code>sz_min</code> 和 <code>sz_max</code> 之间，就返回全部的数值；</li>
<li>否则一个数值都不返回。</li>
</ul>
<h2><span id="2-7-du-zi-fu-chuan">2.7 读字符串</span><a href="#2-7-du-zi-fu-chuan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_property_read_string</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> device_node *np, <span class="type">const</span> <span class="type">char</span> *propname, <span class="type">const</span> <span class="type">char</span> **out_string)</span>;</span><br><span class="line"><span class="comment">// eg:of_property_read_string(dtsled.nd, &quot;status&quot;, &amp;str);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回节点 np 的属性(名为 <code>propname</code>)的值; </li>
<li><code>(*out_string)</code>指向这个值，把它当作字符串</li>
</ul>
<h2><span id="2-8-qi-ta-of-han-shu">2.8 其他of函数</span><a href="#2-8-qi-ta-of-han-shu" class="header-anchor">#</a></h2><p><strong>of_device_is_compatible</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_device_is_compatible</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span></span></span><br><span class="line"><span class="params">	device_node *device, <span class="type">const</span> <span class="type">char</span> *compat)</span>;</span><br></pre></td></tr></table></figure>
<p>检查设备节点的兼容性, 用于查看节点的 <code>compatible</code>属性是否有包含 <code>compat</code>指定的字符。</p>
<p><strong>of_translate_address</strong><br>函数负责将从设备树读取到的地址转换为物理地址，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u64 <span class="title function_">of_translate_address</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">const</span> __be32 *addr)</span>；</span><br></pre></td></tr></table></figure>

<p><strong>of_address_to_resource</strong><br>根据设备节点转成资源信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">of_address_to_resource</span><span class="params">(<span class="keyword">struct</span> device_node *dev, <span class="type">int</span> index, <span class="keyword">struct</span> resource *r)</span>;</span><br><span class="line"><span class="comment">//dev：设备节点。</span></span><br><span class="line"><span class="comment">//index：地址资源标号。</span></span><br><span class="line"><span class="comment">//r：得到的 resource 类型的资源值。</span></span><br><span class="line"><span class="comment">//返回值：0，成功；负值，失败。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/2-1.png" alt="image"><br><code>IIC、 SPI、 GPIO</code>等这些外设都有对应的寄存器，这些寄存器其实就是一组内存 空间， Linux内核使用 resource结构体来描述一段内存空间。<br>对于 32位的 SOC来说，<code> resource_size_t</code>是 u32类型的。其中 start表示开始地址， end表示结束地址， name是这个资源的名字， flags是资源标志位，一般表示资源类型，可选的资源标志定义在文件 <code>include/linux/ioport.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM          0x00000200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_REG          0x00000300      <span class="comment">/* Register offsets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_IRQ          0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DMA          0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUS          0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_PREFETCH     0x00002000      <span class="comment">/* No side effects */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_READONLY     0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_CACHEABLE    0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_RANGELENGTH  0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SHADOWABLE   0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SIZEALIGN    0x00040000      <span class="comment">/* size indicates alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_STARTALIGN   0x00080000      <span class="comment">/* start field is alignment */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MEM_64       0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_WINDOW       0x00200000      <span class="comment">/* forwarded by bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_MUXED        0x00400000      <span class="comment">/* Resource is software muxed */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXT_TYPE_BITS 0x01000000     <span class="comment">/* Resource extended types */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM       0x01000000      <span class="comment">/* System RAM (modifier) */</span></span></span><br><span class="line"><span class="comment">/* IORESOURCE_SYSRAM specific bits. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_DRIVER_MANAGED        0x02000000 <span class="comment">/* Always detected via a driver. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_SYSRAM_MERGEABLE             0x04000000 <span class="comment">/* Resource can be merged. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_EXCLUSIVE    0x08000000      <span class="comment">/* Userland may not map this resource */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_DISABLED     0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_UNSET        0x20000000      <span class="comment">/* No address assigned yet */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_AUTO         0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IORESOURCE_BUSY         0x80000000      <span class="comment">/* Driver has marked this resource busy */</span></span></span><br></pre></td></tr></table></figure>

<p>常 见 的 资 源 标 志 就 是<code> IORESOURCE_MEM 、 IORESOURCE_REG 和IORESOURCE_IRQ</code>。</p>
<p><strong>of_iomap</strong><br>以前我们会通过<code>ioremap</code>函数来完成物理地址到虚拟地址的映射，采用设备树以后就可以直接通过<code> of_iomap</code> 函数来获取内存地址所对应的虚拟地址，不需要使用 <code>ioremap</code> 函数。<br><code>of_iomap </code>函数本质上也是将 reg 属性中地址信息转换为虚拟地址，如果 reg 属性有多段的话，可以通过 index 参数指定要完成内存映射的是哪一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __iomem *<span class="title function_">of_iomap</span><span class="params">(<span class="keyword">struct</span> device_node *np, <span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure>
<h1><span id="3-shi-yong-she-bei-shu-shi-li">3 使用设备树示例</span><a href="#3-shi-yong-she-bei-shu-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian">3.1 led灯驱动设备树方式实现</span><a href="#3-1-led-deng-qu-dong-she-bei-shu-fang-shi-shi-xian" class="header-anchor">#</a></h2><p>led灯dts定义在根节点下,作为根节点子节点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alphaled &#123;</span><br><span class="line">	<span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	<span class="meta">#size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">	compatible = <span class="string">&quot;atkalpha-led&quot;</span>;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">	reg = &lt; <span class="number">0X020C406C</span> <span class="number">0X04</span> <span class="comment">/* CCM_CCGR1_BASE */</span></span><br><span class="line">	<span class="number">0X020E0068</span> <span class="number">0X04</span> <span class="comment">/* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X020E02F4</span> <span class="number">0X04</span> <span class="comment">/* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">	<span class="number">0X0209C000</span> <span class="number">0X04</span> <span class="comment">/* GPIO1_DR_BASE */</span></span><br><span class="line">	<span class="number">0X0209C004</span> <span class="number">0X04</span> &gt;; <span class="comment">/* GPIO1_GDIR_BASE */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-qu-dong-cheng-xu">3.2 驱动程序</span><a href="#3-2-qu-dong-cheng-xu" class="header-anchor">#</a></h2><details>
<summary>点击查看代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_CNT			1		  	<span class="comment">/* 设备号个数 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DTSLED_NAME			<span class="string">&quot;dtsled&quot;</span>	<span class="comment">/* 名字 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDOFF 					0			<span class="comment">/* 关灯 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEDON 					1			<span class="comment">/* 开灯 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 映射后的寄存器虚拟地址指针 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *IMX6U_CCM_CCGR1;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_DR;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span>&#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev 	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>		<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="type">int</span> major;				<span class="comment">/* 主设备号	  */</span></span><br><span class="line">	<span class="type">int</span> minor;				<span class="comment">/* 次设备号   */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> <span class="title">dtsled</span>;</span>	<span class="comment">/* led设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">led_switch</span><span class="params">(u8 sta)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(sta == LEDON) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta == LEDOFF) &#123;</span><br><span class="line">		val = readl(GPIO1_DR);</span><br><span class="line">		val|= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">		writel(val, GPIO1_DR);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	filp-&gt;private_data = &amp;dtsled; <span class="comment">/* 设置私有数据 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">led_write</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">const</span> <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *offt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> retvalue;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> databuf[<span class="number">1</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ledstat;</span><br><span class="line"></span><br><span class="line">	retvalue = copy_from_user(databuf, buf, cnt);</span><br><span class="line">	<span class="keyword">if</span>(retvalue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;kernel write failed!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ledstat = databuf[<span class="number">0</span>];		<span class="comment">/* 获取状态值 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ledstat == LEDON) &#123;	</span><br><span class="line">		led_switch(LEDON);		<span class="comment">/* 打开LED灯 */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(ledstat == LEDOFF) &#123;</span><br><span class="line">		led_switch(LEDOFF);	<span class="comment">/* 关闭LED灯 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">led_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dtsled_fops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = led_open,</span><br><span class="line">	.read = led_read,</span><br><span class="line">	.write = led_write,</span><br><span class="line">	.release = 	led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">led_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	u32 val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	u32 regdata[<span class="number">14</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *str;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">proper</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 获取设备树中的属性数据 */</span></span><br><span class="line">	<span class="comment">/* 1、获取设备节点：alphaled */</span></span><br><span class="line">	dtsled.nd = of_find_node_by_path(<span class="string">&quot;/alphaled&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(dtsled.nd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node nost find!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;alphaled node find!\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、获取compatible属性内容 */</span></span><br><span class="line">	proper = of_find_property(dtsled.nd, <span class="string">&quot;compatible&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(proper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible property find failed\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;compatible = %s\r\n&quot;</span>, (<span class="type">char</span>*)proper-&gt;value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、获取status属性内容 */</span></span><br><span class="line">	ret = of_property_read_string(dtsled.nd, <span class="string">&quot;status&quot;</span>, &amp;str);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		printk(<span class="string">&quot;status read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;status = %s\r\n&quot;</span>,str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、获取reg属性内容 */</span></span><br><span class="line">	ret = of_property_read_u32_array(dtsled.nd, <span class="string">&quot;reg&quot;</span>, regdata, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(<span class="string">&quot;reg property read failed!\r\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		u8 i = <span class="number">0</span>;</span><br><span class="line">		printk(<span class="string">&quot;reg data:\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">			printk(<span class="string">&quot;%#X &quot;</span>, regdata[i]);</span><br><span class="line">		printk(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化LED */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 1、寄存器地址映射 */</span></span><br><span class="line">	IMX6U_CCM_CCGR1 = ioremap(regdata[<span class="number">0</span>], regdata[<span class="number">1</span>]);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="number">2</span>], regdata[<span class="number">3</span>]);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="number">4</span>], regdata[<span class="number">5</span>]);</span><br><span class="line">	GPIO1_DR = ioremap(regdata[<span class="number">6</span>], regdata[<span class="number">7</span>]);</span><br><span class="line">	GPIO1_GDIR = ioremap(regdata[<span class="number">8</span>], regdata[<span class="number">9</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	IMX6U_CCM_CCGR1 = of_iomap(dtsled.nd, <span class="number">0</span>);</span><br><span class="line">	SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">1</span>);</span><br><span class="line">  	SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">2</span>);</span><br><span class="line">	GPIO1_DR = of_iomap(dtsled.nd, <span class="number">3</span>);</span><br><span class="line">	GPIO1_GDIR = of_iomap(dtsled.nd, <span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 2、使能GPIO1时钟 */</span></span><br><span class="line">	val = readl(IMX6U_CCM_CCGR1);</span><br><span class="line">	val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 清楚以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);	<span class="comment">/* 设置新值 */</span></span><br><span class="line">	writel(val, IMX6U_CCM_CCGR1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 3、设置GPIO1_IO03的复用功能，将其复用为</span></span><br><span class="line"><span class="comment">	 *    GPIO1_IO03，最后设置IO属性。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">5</span>, SW_MUX_GPIO1_IO03);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*寄存器SW_PAD_GPIO1_IO03设置IO属性</span></span><br><span class="line"><span class="comment">	 *bit 16:0 HYS关闭</span></span><br><span class="line"><span class="comment">	 *bit [15:14]: 00 默认下拉</span></span><br><span class="line"><span class="comment">     *bit [13]: 0 kepper功能</span></span><br><span class="line"><span class="comment">     *bit [12]: 1 pull/keeper使能</span></span><br><span class="line"><span class="comment">     *bit [11]: 0 关闭开路输出</span></span><br><span class="line"><span class="comment">     *bit [7:6]: 10 速度100Mhz</span></span><br><span class="line"><span class="comment">     *bit [5:3]: 110 R0/6驱动能力</span></span><br><span class="line"><span class="comment">     *bit [0]: 0 低转换率</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	writel(<span class="number">0x10B0</span>, SW_PAD_GPIO1_IO03);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、设置GPIO1_IO03为输出功能 */</span></span><br><span class="line">	val = readl(GPIO1_GDIR);</span><br><span class="line">	val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 清除以前的设置 */</span></span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	<span class="comment">/* 设置为输出 */</span></span><br><span class="line">	writel(val, GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、默认关闭LED */</span></span><br><span class="line">	val = readl(GPIO1_DR);</span><br><span class="line">	val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);	</span><br><span class="line">	writel(val, GPIO1_DR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">	<span class="comment">/* 1、创建设备号 */</span></span><br><span class="line">	<span class="keyword">if</span> (dtsled.major) &#123;		<span class="comment">/*  定义了设备号 */</span></span><br><span class="line">		dtsled.devid = MKDEV(dtsled.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;						<span class="comment">/* 没有定义设备号 */</span></span><br><span class="line">		alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT, DTSLED_NAME);	<span class="comment">/* 申请设备号 */</span></span><br><span class="line">		dtsled.major = MAJOR(dtsled.devid);	<span class="comment">/* 获取分配号的主设备号 */</span></span><br><span class="line">		dtsled.minor = MINOR(dtsled.devid);	<span class="comment">/* 获取分配号的次设备号 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;dtsled major=%d,minor=%d\r\n&quot;</span>,dtsled.major, dtsled.minor);	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 2、初始化cdev */</span></span><br><span class="line">	dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">	cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 3、添加一个cdev */</span></span><br><span class="line">	cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 4、创建类 */</span></span><br><span class="line">	dtsled.class = class_create(THIS_MODULE, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 5、创建设备 */</span></span><br><span class="line">	dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dtsled.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dtsled.device);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">led_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 取消映射 */</span></span><br><span class="line">	iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">	iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">	iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">	iounmap(GPIO1_DR);</span><br><span class="line">	iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">	cdev_del(&amp;dtsled.cdev);<span class="comment">/*  删除cdev */</span></span><br><span class="line">	unregister_chrdev_region(dtsled.devid, DTSLED_CNT); <span class="comment">/* 注销设备号 */</span></span><br><span class="line"></span><br><span class="line">	device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">	class_destroy(dtsled.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>
</details>

<h1><span id="4-gen-she-bei-shu-sao-miao-liu-cheng">4 根设备树扫描流程</span><a href="#4-gen-she-bei-shu-sao-miao-liu-cheng" class="header-anchor">#</a></h1><h2><span id="4-1-jie-xi-root-dts-zong-lan">4.1 解析root dts总览</span><a href="#4-1-jie-xi-root-dts-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> *<span class="title">mdesc</span>;</span></span><br><span class="line">    mdesc = setup_machine_fdt(__atags_pointer);</span><br><span class="line">    ...</span><br><span class="line">    arm_memblock_init(mdesc);</span><br><span class="line">    ...</span><br><span class="line">    unflatten_device_tree();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_machine_fdt() </code>根据传入的设备树dtb的首地址完成一些初始化操作。<br><code>arm_memblock_init()</code> 主要是内存相关，为设备树保留相应的内存空间，保证设备树dtb本身存在于内存中而不被覆盖。<br><code>unflatten_device_tree()</code>对设备树具体的解析，将设备树各节点转换成相应的struct device_node结构体.</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/3.png" alt="image-20240728203202947"></p>
<h3><span id="4-1-1-setup-machine-fdt">4.1.1 setup_machine_fdt</span><a href="#4-1-1-setup-machine-fdt" class="header-anchor">#</a></h3><p>参数<code>__atags_pointer</code>就是 r2 的寄存器值，是设备树在内存中的起始地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> * <span class="function">__init <span class="title">setup_machine_fdt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> dt_phys)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">machine_desc</span> *mdesc, *mdesc_best = <span class="literal">NULL</span>;                    </span><br><span class="line">    <span class="keyword">if</span> (!dt_phys || !<span class="built_in">early_init_dt_verify</span>(<span class="built_in">phys_to_virt</span>(dt_phys)))           ——————part <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mdesc = <span class="built_in">of_flat_dt_match_machine</span>(mdesc_best, arch_get_next_mach);       ——————part <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">early_init_dt_scan_nodes</span>();                                             ——————part <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一部分先将设备树在内存中的物理地址转换为虚拟地址，uboot 传递给内核的设备树地址为物理地址，因为设备树被放置在内存的线性映射区，因此可以简单地通过偏移计算得出其对应的虚拟地址，然后再<code>early_init_dt_verify</code>检查该地址上是否有设备树的魔数(<code>magic</code>)。检查设备树是否匹配成功。最后将设备树地址赋值给全局变量 <code>initial_boot_params</code>。</p>
</li>
<li><p><code>of_flat_dt_match_machine(mdesc_best, arch_get_next_mach)</code>，逐一读取dts根目录下的 compatible 属性, 返回<code>machine_desc</code>结构体。</p>
</li>
<li><p>第三部分就是扫描设备树中的各节点:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">early_init_dt_scan_nodes</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);</span><br><span class="line">    <span class="comment">//boot_command_line是一个静态数组，存放着启动参数,</span></span><br><span class="line">    <span class="comment">//而of_scan_flat_dt()函数的作用就是扫描设备树中的节点，然后对各节点分别调用传入的回调函数。</span></span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_root, <span class="literal">NULL</span>);</span><br><span class="line">    of_scan_flat_dt(early_init_dt_scan_memory, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这3个函数分别是处理<code>chosen</code>节点、root节点中除子节点外的属性信息、memory节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __init <span class="title">early_init_dt_scan_chosen</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    p = <span class="built_in">of_get_flat_dt_prop</span>(node, <span class="string">&quot;bootargs&quot;</span>, &amp;l);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; l &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">strlcpy</span>(data, p, <span class="built_in">min</span>((<span class="type">int</span>)l, COMMAND_LINE_SIZE));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>获取<code> bootargs</code>，然后将<code>bootargs</code>放入<code>boot_command_line</code>中，作为启动参数，而并非处理整个chosen节点。</p>
<p>再看第二个函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_root</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    dt_root_size_cells = OF_ROOT_NODE_SIZE_CELLS_DEFAULT;</span><br><span class="line">    dt_root_addr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#size-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">   		dt_root_size_cells = be32_to_cpup(prop);</span><br><span class="line">    prop = of_get_flat_dt_prop(node, <span class="string">&quot;#address-cells&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (prop)</span><br><span class="line">    	dt_root_addr_cells = be32_to_cpup(prop);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 root 节点中的<code>#size-cells</code>和 <code>#address-cells</code>属性提取出来，并非获取root节点中所有的属性，放到全局变量<code>dt_root_size_cells</code>和<code>dt_root_addr_cells</code>中。</p>
<p>接下来看第三个函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">early_init_dt_scan_memory</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> node, <span class="type">const</span> <span class="type">char</span> *uname,<span class="type">int</span> depth, <span class="type">void</span> *data)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!IS_ENABLED(CONFIG_PPC32) || depth != <span class="number">1</span> || <span class="built_in">strcmp</span>(uname, <span class="string">&quot;memory@0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    reg = of_get_flat_dt_prop(node, <span class="string">&quot;reg&quot;</span>, &amp;l);</span><br><span class="line">    endp = reg + (l / <span class="keyword">sizeof</span>(__be32));</span><br><span class="line">    <span class="keyword">while</span> ((endp - reg) &gt;= (dt_root_addr_cells + dt_root_size_cells)) &#123;</span><br><span class="line">    base = dt_mem_next_cell(dt_root_addr_cells, &amp;reg);</span><br><span class="line">    size = dt_mem_next_cell(dt_root_size_cells, &amp;reg);</span><br><span class="line">    early_init_dt_add_memory_arch(base, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数先判断节点的<code>uname</code>是<code>memory@0</code>,如果不是，则返回。然后将所有memory相关的reg属性取出来，根据<code>address-cell</code>和<code>size-cell</code>的值进行解析，然后调用<code>early_init_dt_add_memory_arch()</code>来申请相应的内存空间。</p>
<p>到这里，<code>setup_machine_fdt()</code>函数对于设备树的第一次扫描解析就完成了，主要是获取了一些设备树提供的总览信息。</p>
<h3><span id="4-1-2-arm-memblock-init">4.1.2 arm_memblock_init</span><a href="#4-1-2-arm-memblock-init" class="header-anchor">#</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __init <span class="title">arm_memblock_init</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> machine_desc *mdesc)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">early_init_fdt_reserve_self</span>();</span><br><span class="line">    <span class="built_in">early_init_fdt_scan_reserved_mem</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描设备树节点中的<code>&quot;reserved-memory&quot;</code>节点，为其分配保留空间。</p>
<h3><span id="4-1-3-unflatten-device-tree">4.1.3 unflatten_device_tree</span><a href="#4-1-3-unflatten-device-tree" class="header-anchor">#</a></h3><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/4.png" alt="image"></p>
<p>第一步是<code>__unflatten_device_tree</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/5.png" alt="image"></p>
<p><code>unflatten_dt_nodes</code>被调用两次，第一次是扫描得出设备树转换成device node需要的空间，然后系统申请内存空间，第二次就进行真正的解析工作。</p>
<h4><span id="4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian">4.1.3.1 unflatten_dt_nodes遍历子节点</span><a href="#4-1-3-1-unflatten-dt-nodes-bian-li-zi-jie-dian" class="header-anchor">#</a></h4><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/6.png" alt="image"></p>
<p>从根节点开始，对子节点依次调用<code>populate_node()</code>，从函数命名上来看，这个函数就是填充节点，为节点分配内存。</p>
<h5><span id="4-1-3-1-1-populate-node">4.1.3.1.1 populate_node</span><a href="#4-1-3-1-1-populate-node" class="header-anchor">#</a></h5><p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/7.png" alt="image"></p>
<p>为当前节点申请内存空间，使用<code>of_node_init() </code>函数对node进行初始化，<code>populate_properties</code>设置node属性。<code>populate_properties</code>设置节点的属性。</p>
<h4><span id="4-1-3-2-of-alias-scan">4.1.3.2 of_alias_scan</span><a href="#4-1-3-2-of-alias-scan" class="header-anchor">#</a></h4><p><code>/* Get pointer to &quot;/chosen&quot; and &quot;/aliases&quot; nodes for use everywhere */</code>。</p>
<p>这句就能看出它是用来处理<code>aliases，chosen</code>等特殊节点的。处理带有别名的节点，函数实现细节如下：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/8.png" alt="image"></p>
<p>1.先处理<code>chosen</code>节点中的<code>&quot;stdout-path&quot;</code>或者<code>&quot;stdout&quot;</code>属性(两者最多存在其一)，然后将<code>stdout</code>指定的path赋值给全局变量<code>of_stdout_options</code>，并将返回的全局struct device_node类型数据赋值给<code>of_stdout</code>，指定系统启动时的log输出。</p>
<p>2.接下来为<code>aliases</code>节点申请内存空间，如果一个节点中同时没有 <code>name/phandle/linux,phandle</code>，则被定义为特殊节点，对于这些特殊节点将不会申请内存空间。</p>
<p>3.<code>of_alias_add</code>添加到alias链表。</p>
<h1><span id="5-device-node-zhuan-huan-cheng-platform-device">5 device_node转换成platform_device</span><a href="#5-device-node-zhuan-huan-cheng-platform-device" class="header-anchor">#</a></h1><h2><span id="5-0-zhuan-huan-guo-cheng-zong-lan">5.0 转换过程总览</span><a href="#5-0-zhuan-huan-guo-cheng-zong-lan" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">of_platform_default_populate_init()</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_default_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_populate();</span><br><span class="line">                                            |</span><br><span class="line">                                of_platform_bus_create()</span><br><span class="line">                    _____________________|_________________</span><br><span class="line">                    |                                      |</span><br><span class="line">            of_platform_device_create_pdata()       of_platform_bus_create()</span><br><span class="line">            _________________|____________________</span><br><span class="line">           |                                      |</span><br><span class="line">     of_device_alloc()                        of_device_add()</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian">5.1 device_node转换到platform_device的条件</span><a href="#5-1-device-node-zhuan-huan-dao-platform-device-de-tiao-jian" class="header-anchor">#</a></h2><ul>
<li>一般情况下，只对设备树中根的一级子节点进行转换，也就是子节点的子节点并不处理。但是存在一种特殊情况，就是当某个根子节点的<code>compatible</code>属性为<code>&quot;simple-bus&quot;、&quot;simple-mfd&quot;、&quot;isa&quot;、&quot;arm,amba-bus&quot;</code>时，当前节点中的子节点将会被转换成platform_device节点。</li>
<li>节点中必须有<code>compatible</code>属性。</li>
</ul>
<p>设备树节点的<code>reg</code>和 <code>interrupts </code>资源将会被转换成 platform_device 内的 <code>struct resources </code>资源。</p>
<h2><span id="5-2-zhuan-huan-guo-cheng-jie-xi">5.2 转换过程解析</span><a href="#5-2-zhuan-huan-guo-cheng-jie-xi" class="header-anchor">#</a></h2><p>展开<code>of_platform_device_create_pdata</code>:</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/9.png" alt="image"></p>
<p>调用<code>of_device_alloc</code>，可以看到为设备树节点分配了一个<code>dev(struct platform_device)</code>，展开<code>of_device_alloc</code>函数：</p>
<p><img src="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/10.png" alt="image"></p>
<p>可以看到把设备树节点的属性转成platform_device的<code>io，irq等资源</code>信息。同时将<code>device_node *np</code>指针记录到<code>dev-&gt;dev.of_node</code>。这样就建立了设备树节点到platform_device的转换关系。</p>
<p>然后调用<code>of_device_add</code>注册到系统device中去。</p>
<p>最后调用<code>of_platform_bus_create</code>在用户空间创建相应的访问节点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-5-%E8%AE%BE%E5%A4%87%E6%A0%91%E5%87%BD%E6%95%B0/" data-id="cm0xxoge6003gqsuf5t9n6h5a" data-title="字符设备驱动-5-设备树函数" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/07/30/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-6-pre-%E4%BC%91%E7%9C%A0%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字符设备驱动-6-pre-休眠唤醒机制
        
      </div>
    </a>
  
  
    <a href="/2024/07/28/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-4-%E8%AE%BE%E5%A4%87%E6%A0%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">字符设备驱动-4-设备树</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.09px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.73px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.64px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 15.45px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-UART子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-RTC子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>