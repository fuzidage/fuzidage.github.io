<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>s3c2440裸机编程-电阻触摸屏 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 电阻触摸屏原理 1.1 计算Y坐标 1.2 计算X坐标   2 电阻触摸屏的几种模式 2.1 等待中断模式 2.2 读取x坐标模式 2.3 读取y坐标模式 2.4 TS中断流程 2.4.1 中断加入定时器 2.4.2 带定时器的TS中断处理流程     3 触摸屏接口模式 3.1 Normal Conversion Mode 3.2 Separate X&#x2F;Y positio">
<meta property="og:type" content="article">
<meta property="og:title" content="s3c2440裸机编程-电阻触摸屏">
<meta property="og:url" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 电阻触摸屏原理 1.1 计算Y坐标 1.2 计算X坐标   2 电阻触摸屏的几种模式 2.1 等待中断模式 2.2 读取x坐标模式 2.3 读取y坐标模式 2.4 TS中断流程 2.4.1 中断加入定时器 2.4.2 带定时器的TS中断处理流程     3 触摸屏接口模式 3.1 Normal Conversion Mode 3.2 Separate X&#x2F;Y positio">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png">
<meta property="og:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png">
<meta property="article:published_time" content="2024-05-01T07:13:12.000Z">
<meta property="article:modified_time" content="2024-07-23T15:55:48.118Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="arm裸机">
<meta property="article:tag" content="裸机外设驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-s3c2440裸机编程-电阻触摸屏" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/" class="article-date">
  <time class="dt-published" datetime="2024-05-01T07:13:12.000Z" itemprop="datePublished">2024-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      s3c2440裸机编程-电阻触摸屏
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</a><ul>
<li><a href="#1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</a></li>
<li><a href="#1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</a></li>
</ul>
</li>
<li><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</a><ul>
<li><a href="#2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</a></li>
<li><a href="#2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</a></li>
<li><a href="#2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</a></li>
<li><a href="#2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</a><ul>
<li><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</a></li>
<li><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</a><ul>
<li><a href="#3-1-normal-conversion-mode">3.1 Normal Conversion Mode</a></li>
<li><a href="#3-2-separate-x-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</a></li>
<li><a href="#3-3-auto-sequential-x-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</a></li>
<li><a href="#3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</a></li>
</ul>
</li>
<li><a href="#4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</a><ul>
<li><a href="#4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</a></li>
<li><a href="#4-2-data-ji-cun-qi">4.2 DATA寄存器</a><ul>
<li><a href="#4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</a></li>
<li><a href="#4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</a></li>
</ul>
</li>
<li><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</a></li>
</ul>
</li>
<li><a href="#5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</a><ul>
<li><a href="#5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</a><ul>
<li><a href="#5-1-1-zhong-duan-yuan">5.1.1 中断源</a></li>
<li><a href="#5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</a></li>
<li><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</a></li>
<li><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</a><ul>
<li><a href="#5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</a></li>
<li><a href="#5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</a><ul>
<li><a href="#5-2-1-chu-shi-hua">5.2.1 初始化</a><ul>
<li><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</a></li>
<li><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</a></li>
<li><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</a></li>
</ul>
</li>
<li><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</a><ul>
<li><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</a><ul>
<li><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</a></li>
<li><a href="#5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</a></li>
</ul>
</li>
<li><a href="#5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</a></li>
<li><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</a><ul>
<li><a href="#5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</a></li>
<li><a href="#5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</a><ul>
<li><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</a><ul>
<li><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</span><a href="#1-dian-zu-hong-mo-ping-yuan-li" class="header-anchor">#</a></h1><p>触摸屏包含上下叠合的两个透明层，一般覆盖在lcd表面，两个透明层是由均匀的电阻介质组成，如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png"></p>
<p>当触摸屏表面受到的压力（如通过笔尖或手指进行按压）足够大时，顶层与底层之间的薄膜会产生接触，此时会形成x方向和y方向的坐标。那么x，y坐标的值是怎么得来的呢？本质上就是通过ADC转换得来的。</p>
<p>触摸屏的等效电路可以看成如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg"></p>
<p>计算触点的X，Y坐标分为如下两步： </p>
<h2><span id="1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</span><a href="#1-1-ji-suan-y-zuo-biao" class="header-anchor">#</a></h2><p>在Y+电极施加驱动电压Vdrive， Y-电极接地，由于上下两层膜形成触点，X+做为触点的引出端，测量得到接触点的电压，触点电压与Vdrive电压之比等于触点Y坐标与屏高度之比。如下图：</p>
<h2><span id="1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</span><a href="#1-2-ji-suan-x-zuo-biao" class="header-anchor">#</a></h2><p>在X+电极施加驱动电压Vdrive， X-电极接地，由于上下两层膜形成触点，Y+做为触点的引出端，测量得到接触点的电压，Y+做为引出端测量得到接触点的电压，触点电压与Vdrive电压之比等于触点X坐标与屏宽度之比。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg"></p>
<h1><span id="2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</span><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi" class="header-anchor">#</a></h1><h2><span id="2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</span><a href="#2-1-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h2><p>平时的时候上下两层膜并不粘在一起，我们把这种状态称为<strong>“等待中断模式”</strong>， 等效电路如下图的右边那幅图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png"></p>
<p>s5、s4闭合，s1、s2、s3断开，这个时候Y_ADC&#x2F;XP通过S5接上拉电阻，处于高电平状态,X_ADC&#x2F;YP接地。没法读取x,y坐标。</p>
<h2><span id="2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</span><a href="#2-2-du-qu-x-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给X方向通电，也就是让S1、S3开关闭合，s2、s4断开，那么当屏幕按下，触点YP的电平就对应x坐标。（XP到XM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png"></p>
<pre><code>x_adc电压/vcc = x坐标/width, 所以x坐标= width * x_adc电压/vcc
</code></pre>
<h2><span id="2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</span><a href="#2-3-du-qu-y-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给Y方向通电，也就是让S2、S4开关闭合，s1、s3断开，那么当屏幕按下，触点XP的电平就对应y坐标。（YP到YM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png"></p>
<pre><code>y_adc电压/vcc = Y坐标/height, 所以y坐标= height * y_adc电压/vcc
</code></pre>
<h2><span id="2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</span><a href="#2-4-ts-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>总结一下单次触发TS中断，使用触摸屏的流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 按下触摸屏，产生TS中断</span><br><span class="line"><span class="number">2.</span> 启动ADC(目的是获取x,y方向上的坐标值)</span><br><span class="line"><span class="number">3.</span> ADC转换完成，产生adc中断（adc转换需要一定的时间）</span><br><span class="line"><span class="number">4.</span> ADC中断中来读取x y坐标</span><br><span class="line"><span class="number">5.</span> 松开，结束</span><br></pre></td></tr></table></figure>

<p>我们知道，现在的手机都是支持屏幕滑动翻页和长按的功能。那么这些功能是如何做到的呢？</p>
<h3><span id="2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</span><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi" class="header-anchor">#</a></h3><p>如何让触摸屏支持长按或者滑动操作（多次触发TS中断）？</p>
<p>答案:<strong>定时器</strong>，当长按屏幕，会产生多次TS中断，因此我们需要用定时器来判断，当定时一段时间后，还有TS中断产生，那么我们认为是长按操作，进行中断响应。滑动也是类似的道理，当定时时间到后，如果还有TS中断产生，且坐标发生了改变，就认为是滑动操作。</p>
<pre><code>&lt;5&gt; 启动定时器
&lt;6&gt; 一段时间后，定时器中断发生，判断触摸屏是否仍被按下(是否有定时器中断产生)，如果有就循环上述过程&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;
</code></pre>
<p>可以用如下流程图概括TSC的整个SW flow.</p>
<h3><span id="2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</span><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png" alt="image"></p>
<h1><span id="3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</span><a href="#3-hong-mo-ping-jie-kou-mo-shi" class="header-anchor">#</a></h1><h2><span id="3-1-normal-conversion-mode">3.1 Normal Conversion Mode</span><a href="#3-1-normal-conversion-mode" class="header-anchor">#</a></h2><p>正常转换模式，一般情况下可以配置ADCCON和ADCDAT0来读取数据。</p>
<h2><span id="3-2-separate-x-x2f-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</span><a href="#3-2-separate-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png"><br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png"></p>
<p>x,y坐标分离转换格式，x坐标会写入ADCDAT0, y坐标会写入ADCDAT1,所以会产生2次中断开分开完成x,y的坐标转换。</p>
<h2><span id="3-3-auto-sequential-x-x2f-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</span><a href="#3-3-auto-sequential-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p>自动转换模式，当触摸屏按下后，会一次性对x,y方向的坐标进行转换，x坐标会写入ADCDAT0, x坐标会写入ADCDAT1。会产生一次中断进行x,y坐标的自动转换。 </p>
<h2><span id="3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</span><a href="#3-4-waiting-for-interrupt-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg"></p>
<p> 等待中断模式 。可以设置rADCTSC&#x3D;0xd3;也就是对应下图寄存器 &#x2F;&#x2F; XP_PU, XP_Dis, XM_Dis, YP_Dis, YM_En.当产生中断信号(INT_TC)后，等待中断模式必须清除.(即XY_PST sets to the No operation Mode).</p>
<h1><span id="4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</span><a href="#4-hong-mo-ping-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</span><a href="#4-1-ts-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p>电阻触摸屏的原理本质上就是ADC，ADC相关寄存器介绍详见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/13396987.html">s3c2440裸机-ADC编程</a>或者<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC | Hexo (fuzidage.github.io)</a><br>TSC相比ADC多了一个ADCTSC寄存器，如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg" alt="image"><br>当bit[2]&#x3D;0，normal mode时，那么bit[1:0]需要配置成01或者10进行手工测量x,y.<br>当bit[2]&#x3D;1，auto mode时，那么bit[1:0]需要配置成0,进行自动测量。</p>
<h2><span id="4-2-data-ji-cun-qi">4.2 DATA寄存器</span><a href="#4-2-data-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</span><a href="#4-2-1-x-zuo-biao-adcdata0" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png" alt="image"></p>
<h3><span id="4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</span><a href="#4-2-2-y-zuo-biao-adcdata1" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png" alt="image"></p>
<h2><span id="4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</span><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi" class="header-anchor">#</a></h2><p>这个寄存器可以检测是否有触摸中断产生，是按下触摸屏了，还是松开触摸屏了。<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png" alt="image"></p>
<h1><span id="5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</span><a href="#5-hong-mo-ping-bian-cheng-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</span><a href="#5-1-adc-zhong-duan-chan-sheng" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png" alt="img"></p>
<h3><span id="5-1-1-zhong-duan-yuan">5.1.1 中断源</span><a href="#5-1-1-zhong-duan-yuan" class="header-anchor">#</a></h3><p>ADC和TSC共用一个中断源，如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png" alt="img"></p>
<p>SRCPND表示哪个中断源产生了中断请求。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png" alt="img"></p>
<h3><span id="5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</span><a href="#5-1-2-zhong-duan-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png" alt="img"></p>
<h3><span id="5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</span><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png" alt="img"></p>
<h3><span id="5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</span><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi" class="header-anchor">#</a></h3><p>用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png" alt="img"></p>
<p>从SRCPND寄存器可以读到ADC和TSC复用的同一个中断源，那么如何区分呢？</p>
<p>可以从SUBSRCPND寄存器配置，如下：</p>
<h4><span id="5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</span><a href="#5-1-4-1-subsrcpnd-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png" alt="img"></p>
<p> 当bit 9被置1时，表示TSC中断。那么我们需要打开subsrcmask寄存器：</p>
<h4><span id="5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</span><a href="#5-1-4-2-intsubmsk-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png" alt="img"></p>
<p>所以TSC中断的产生流程如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png" alt="img"></p>
<h2><span id="5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</span><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化TSC，ADCTSC寄存器</span><br><span class="line"><span class="number">2.</span> 设定TSC处于“等待中断模式”</span><br><span class="line"><span class="number">3.</span> 使能TSC中断</span><br><span class="line">　　　　　　INTSUBMSK</span><br><span class="line">　　　　　　MSK/MODE</span><br><span class="line"><span class="number">4.</span> 按下，进入TSC中断</span><br><span class="line">　　　　　　进入自动采集转换模式</span><br><span class="line">　　　　　　启动ADC</span><br><span class="line"><span class="number">5.</span> ADC中断</span><br><span class="line">　　　　　　读数据</span><br><span class="line">　　　　　　再次进入”等待中断模式“</span><br><span class="line">　　　　　　启动定时器（为了处理长按或者滑动操作）</span><br><span class="line"><span class="number">6.</span> 定时器中断</span><br><span class="line">　　　　　　若松开，结束</span><br><span class="line">　　　　　　如任然按下，进入步骤<span class="number">4</span>的启动ADC流程</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png" alt="img"></p>
<h3><span id="5-2-1-chu-shi-hua">5.2.1 初始化</span><a href="#5-2-1-chu-shi-hua" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置触摸屏接口:寄存器 */</span></span><br><span class="line">    adc_ts_reg_init();</span><br><span class="line">    <span class="comment">/* 设置中断 */</span></span><br><span class="line">    adc_ts_int_init();</span><br><span class="line">    <span class="comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</span><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>主要是设置预分频，产生ADC clk &#x3D; 1MHz。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">     * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">     * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">     * [2]   : STDBM</span></span><br><span class="line"><span class="comment">     * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    ADCDLY = <span class="number">0xff</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</span><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua" class="header-anchor">#</a></h4><p>为了将中断源开启，这里设置SUBSRCPND 和INTSUBMSK让中断源开启。通过register_irq（）注册中断号和中断服务程AdcTsIntHandle，查表得出中断号为31，这样当硬件产生中断后可以从INTOFFSET区分是哪个中断号。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_int_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    register_irq(<span class="number">31</span>, AdcTsIntHandle);    <span class="comment">/*31号中断*/</span></span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    INTSUBMSK &amp;= ~((<span class="number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="number">1</span>&lt;&lt;TC_INT_BIT));<span class="comment">//防止屏蔽（SUBMSK）</span></span><br><span class="line">    <span class="comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);//reg_irq已经使能了31中断号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</span><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png" alt="img"></p>
<p>进入等待中断模式，YM闭合， YP， XP， XM断开，需要pull up，WAIT_PEN_DOWN表示要等待的是按下中断，当触摸屏按下时就会产生一个TSC irq,反之WAIT_PEN_UP表示要等待的是松开中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_INT_BIT (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_INT_BIT  (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_ADC_TC   (31)</span></span><br><span class="line"><span class="comment">/* ADCTSC&#x27;s bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8) <span class="comment">/*触摸笔按下*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8) <span class="comment">/*触摸笔松开*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)    <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)    <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_down_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待按下模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | 	WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_up_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待松开模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</span><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h3><p>SUBSRCPND的bit9, bit10可以区分是TC中断还是ADC中断。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*触摸屏中断服务程序*/</span> &#123;</span><br><span class="line">　　	<span class="built_in">printf</span>(<span class="string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br><span class="line">　　	<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">//dat寄存器的第15位判断按下还是松开</span></span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">　　　　	enter_wait_pen_down_mode();</span><br><span class="line">　　	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">　　　　	<span class="comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span></span><br><span class="line">　　　　	enter_wait_pen_up_mode();</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　	<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT)) <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　	Isr_Tc();</span><br><span class="line">　　	<span class="comment">// if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT)) /* ADC中断 */</span></span><br><span class="line">　　	<span class="comment">// Isr_Adc();</span></span><br><span class="line">　　	SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">　　	<span class="comment">//SRCPND = 1&lt;&lt;31;/*在interrupt.c已经清中断了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AdcTsIntHandle函数： 这里先注解掉ADC中断，只检测单独的按下松开触摸屏操作。那当isr处理完后为了能够正常响应下一次中断，需要清中断，否则会一直触发interrupt。</span><br><span class="line">Isr_Tc函数：ADCDAT0 寄存器的第15位判断按下还是松开。那么当按下后，要将控制器进入”等待松开模式“，当松开后，要将控制器配置进入”等待按下模式“。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png" alt="img"></p>
<h4><span id="5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</span><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao" class="header-anchor">#</a></h4><h5><span id="5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</span><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi" class="header-anchor">#</a></h5><p>Auto(Sequential) X&#x2F;Y Position Conversion Mode。打开TS控制寄存器，也就是ADCTSC寄存器：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png" alt="img"></p>
<p>让bit[2] &#x3D;1, bit[1:0]&#x3D;00，则会进入auto measurement。如果bit[2]&#x3D;0，则需配置bit[1::0]&#x3D;01 or 10是手动测量x,y坐标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)        <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)        <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_auto_measure_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　ADCTSC = AUTO_PST | NO_OPR_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</span><a href="#5-2-2-1-2-qi-dong-adc" class="header-anchor">#</a></h5><p>触摸屏坐标就是通过ADC获取的。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以TSC isr程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">/*触摸屏中断服务程序*/</span></span><br><span class="line">      <span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">            enter_wait_pen_down_mode();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">            <span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">            enter_auto_measure_mode();</span><br><span class="line">            <span class="comment">/* 启动ADC */</span></span><br><span class="line">            ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当检测到按下后，需要进入auto measure mode，启动adc，然后就会进行自动坐标转换，转换结束后又会触发ADC中断，再次进入<code>AdcTsIntHandle</code>函数，进而进入<code>Isr_Adc</code>，SUBSRCPND可以区分中断源 。如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT))  <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="comment">/* ADC中断 */</span></span><br><span class="line">　　　　Isr_Adc();</span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道ADC进行坐标转换结束后，那么会产生ADC中断，在<code>Isr_Adc</code>中即可获取我们的x,y坐标数据。由于我们按下后是进入了 “自动测量” 模式，因此那当数据获取完后我们得进入 “等待松开” 模式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="type">int</span> x = ADCDAT0;</span><br><span class="line">      <span class="type">int</span> y = ADCDAT1;</span><br><span class="line">      <span class="keyword">if</span> (!(ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))) &#123; <span class="comment">/* 在isr_Tc按下后，如果仍然按下才打印 */</span></span><br><span class="line">            x &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            y &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      enter_wait_pen_up_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能触摸屏的测量过程非常长，那当ADC转换结束后，它已经松开了，这时不应该进行打印出坐标，所以这里在isr_Tc按下后，如果仍然按下才打印。</p>
<h4><span id="5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</span><a href="#5-2-2-2-adcdly-ji-cun-qi" class="header-anchor">#</a></h4><p>由于触摸屏采样的转换速率问题，按下后需要过一段电压才能稳定下来，那么数据才能稳定可能需要一定的延迟，所以需要配置ADC delay，让ADC慢一点产生中断，也就是等坐标稳定后在通知用户。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png" alt="img"></p>
<p>ADCDLY就是用来延时ADC启动的时间，让数据稳定后再进行转换。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png" alt="img"></p>
<p><code>可以看到，进行auto or manual measure 坐标转换的时序要满足：A = Dx,D表示ADCDLY的值。 现在晶振的频率是12Mhz, 那么根据触摸屏规格书我们取A= 5ms，那么D= 0.005s *12*1000000 = 60000，所以ADCDLY配置成60000.</code></p>
<p>修改前面的<code>adc_ts_reg_init</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">       * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">       * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">       * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">       * [2]   : STDBM</span></span><br><span class="line"><span class="comment">       * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">      <span class="comment">/*  按下触摸屏, 延时一会再发出TC中断</span></span><br><span class="line"><span class="comment">       *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCDLY = <span class="number">60000</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</span><a href="#5-3-ts-hong-mo-ping-ce-shi" class="header-anchor">#</a></h2><p>从左往右依次点击触摸屏，可以看到x坐标没有明显变化，y坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png" alt="img"></p>
<p>同理，从上往下依次按下触摸屏，可以看到y坐标没有明显变化，x坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png" alt="img"></p>
<p>这里是由于硬件上xp与yp接反了，ym与xm接反了，如下图：但这里并不影响我们的时候，这里我们软件上可以进行x,y坐标的转换：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png" alt="img"></p>
<p>我们软件上可以对x,y轴进行flip， mirror, rotaion旋转等一系列操作即可。比如：</p>
<p>Case1：ts与lcd吻合</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png" alt="img"></p>
<p>Case2：ts与lcd相反</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png" alt="img"></p>
<h2><span id="5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</span><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong" class="header-anchor">#</a></h2><h3><span id="5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</span><a href="#5-4-1-gai-jin-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有讲到在<code>handle_irq_c()</code>中去区分中断源，执行不同的<code>isr</code>。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png" alt="image-20240501173712329"></p>
<p>那现在通过<code>register_timer</code>注册对应的定时器中断服务程序，<code>timer_irq</code>进行执行不同的定时器中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_NUM  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL  ((void *)0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*timer_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_desc</span> &#123;</span></span><br><span class="line">　　<span class="type">char</span> *name;</span><br><span class="line">　　timer_func fp;</span><br><span class="line">&#125;timer_desc, *p_timer_desc;</span><br><span class="line"></span><br><span class="line">timer_desc timer_array[TIMER_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">register_timer</span><span class="params">(<span class="type">char</span> *name, timer_func fp)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = name;</span><br><span class="line">　　　　　　timer_array[i].fp   = fp;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_timer</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(timer_array[i].name, name)) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　timer_array[i].fp   = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].fp();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要用timer来进行进行流水灯实验，那么假如点灯函数为:<br><code>Isr_timer_led()&#123;&#125;</code></p>
<p>那么则只需要在<code>led init</code>的时候进行调用<code>register_timer(“led”, Isr_timer_led)</code>, 那么当时间到后触发定时器中断，便会执行<code>timer_irq</code>.进入<code>Isr_timer_led</code>。</p>
<h3><span id="5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</span><a href="#5-4-2-chu-shi-hua-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有具体讲解，这里采用PWM定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="comment">/* 设置TIMER0的时钟 */</span></span><br><span class="line">　　<span class="comment">/* Timer clk = PCLK / &#123;prescaler value+1&#125; / &#123;divider value&#125;</span></span><br><span class="line"><span class="comment">             = 50000000/(49+1)/16</span></span><br><span class="line"><span class="comment">             = 62500</span></span><br><span class="line"><span class="comment"> 　　*/</span></span><br><span class="line">　　TCFG0 = <span class="number">49</span>;  <span class="comment">/* Prescaler 0 = 49, 用于timer0,1 */</span></span><br><span class="line">　　TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">　　TCFG1 |= <span class="number">3</span>;  <span class="comment">/* MUX0 : 1/16 */</span></span><br><span class="line">　　<span class="comment">/* 设置TIMER0的初值 */</span></span><br><span class="line">　　TCNTB0 = <span class="number">625</span>;  <span class="comment">/* 10Ms中断一次 */</span></span><br><span class="line">　　<span class="comment">/* 加载初值, 启动timer0 */</span></span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);   <span class="comment">/* Update from TCNTB0 &amp; TCMPB0 */</span></span><br><span class="line">　　<span class="comment">/* 设置为自动加载并启动 */</span></span><br><span class="line">　　TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">/* bit0: start, bit3: auto reload */</span></span><br><span class="line">　　<span class="comment">/* 设置中断 */</span></span><br><span class="line">　　register_irq(<span class="number">10</span>, timer_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</span><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong" class="header-anchor">#</a></h4><p>我们之前是2s timer触发一次中断，那如果是要支持触摸屏，我们必须让定时器10ms就触发一次中断。因此需要修改timer_init中的寄存器参数。</p>
<p>当按下触摸屏会产生TSC中断，然后启动ADC进而产生<code>adc</code>中断的时候，在<code>Isr_Adc</code>函数中进行定时器的设置，检测长按和滑动操作。</p>
<h5><span id="5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</span><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_status_of_ts_timer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> g_ts_timer_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 每10ms该函数被调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (get_status_of_ts_timer() == <span class="number">0</span>)</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">/* 如果松开 */</span></span><br><span class="line">　　　　ts_timer_disable();</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;  <span class="comment">/* 按下状态 */</span></span><br><span class="line">　　　　<span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">　　　　enter_auto_measure_mode();</span><br><span class="line">　　　　<span class="comment">/* 启动ADC */</span></span><br><span class="line">　　　　ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png" alt="image-20240501174908562"></p>
<p>来分析一下这个程序的过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 在touchscreen_init的时候我们先注册了一个timer，然后修改了定时器的产生中断的时间间隔为<span class="number">10</span>ms中断一次，所以touchscreen_timer_irq会每间隔<span class="number">10</span>ms调用一次。没有按下，则touchscreen_timer_irq虽然也有走，但是就直接<span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 然后如果按下触摸屏，产生tsc中断，启动adc，产生adc中断。</span><br><span class="line"></span><br><span class="line">如果产生了adc中断，但是读取状态发现已经松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效。那么要是状态是被按下，则开启ts_timer_enable。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 当使能touchscreen_timer_irq这个定时器中断服务程序后，并且<span class="number">10</span>ms到了touchscreen_timer_irq函数执行生效。</span><br><span class="line"></span><br><span class="line">如果松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效，表示没有长按或者滑动。</span><br><span class="line"></span><br><span class="line">如果任然按下，输出长按或者滑动后的坐标结果。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/" data-id="cm0xxoge20028qsufc7fv0qfl" data-title="s3c2440裸机编程-电阻触摸屏" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          imx6ull裸机-ADC
        
      </div>
    </a>
  
  
    <a href="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">s3c2440裸机编程-LDC</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.09px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.73px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.64px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 15.45px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-IIO%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-IIO子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-regmap%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-regmap子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-UART%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-UART子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-RTC%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-RTC子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>