<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>字符设备驱动-I2C子系统 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 Linux I2C 驱动框架 2 数据结构 2.1 控制器相关 2.1.1 i2c_adapter-控制器 2.1.2 i2c_algorithm-通信方法   2.2 客户端相关 2.2.1 i2c_driver-I从设备驱动 2.2.2 i2c_client-从设备 2.2.2.1 i2c_board_info     2.3 i2c_msg-消息   3 I2C子系统API 3">
<meta property="og:type" content="article">
<meta property="og:title" content="字符设备驱动-I2C子系统">
<meta property="og:url" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 Linux I2C 驱动框架 2 数据结构 2.1 控制器相关 2.1.1 i2c_adapter-控制器 2.1.2 i2c_algorithm-通信方法   2.2 客户端相关 2.2.1 i2c_driver-I从设备驱动 2.2.2 i2c_client-从设备 2.2.2.1 i2c_board_info     2.3 i2c_msg-消息   3 I2C子系统API 3">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.1.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png">
<meta property="og:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png">
<meta property="article:published_time" content="2024-08-25T08:23:34.000Z">
<meta property="article:modified_time" content="2024-08-31T06:49:11.786Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="通信协议">
<meta property="article:tag" content="Linux设备驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-字符设备驱动-I2C子系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2024-08-25T08:23:34.000Z" itemprop="datePublished">2024-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      字符设备驱动-I2C子系统
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</a></li>
<li><a href="#2-shu-ju-jie-gou">2 数据结构</a><ul>
<li><a href="#2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</a><ul>
<li><a href="#2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</a></li>
<li><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</a></li>
</ul>
</li>
<li><a href="#2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</a><ul>
<li><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</a></li>
<li><a href="#2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</a><ul>
<li><a href="#2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</a></li>
</ul>
</li>
<li><a href="#3-i2c-zi-xi-tong-api">3 I2C子系统API</a><ul>
<li><a href="#3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</a><ul>
<li><a href="#3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</a></li>
<li><a href="#3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</a></li>
</ul>
</li>
<li><a href="#3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</a><ul>
<li><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</a></li>
<li><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</a></li>
<li><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</a></li>
<li><a href="#3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</a><ul>
<li><a href="#3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</a></li>
<li><a href="#3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</a></li>
<li><a href="#3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</a><ul>
<li><a href="#4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</a><ul>
<li><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</a></li>
</ul>
</li>
<li><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</a><ul>
<li><a href="#4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</a><ul>
<li><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</a></li>
<li><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</a></li>
</ul>
</li>
<li><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</a><ul>
<li><a href="#4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</a></li>
<li><a href="#4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</a><ul>
<li><a href="#4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</a><ul>
<li><a href="#4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</a><ul>
<li><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</a></li>
<li><a href="#4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</a></li>
</ul>
</li>
<li><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</a><ul>
<li><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</a></li>
<li><a href="#4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</a></li>
<li><a href="#4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</a></li>
<li><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-linux-i2c-qu-dong-kuang-jia">1 Linux I2C 驱动框架</span><a href="#1-linux-i2c-qu-dong-kuang-jia" class="header-anchor">#</a></h1><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/1.png" alt="image"></p>
<p>由上到下分为3层结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i2c设备驱动层: 作为client使用者使用i2c子系统。提供操作接口给应用层，与应用层交互数据。</span><br><span class="line"></span><br><span class="line">I2C核心层：提供transfer send recv函数。把client设备挂载到I2C总线上；</span><br><span class="line">    维护i2c driver和i2c client 链表 ，实现i2c_client和i2c_driver匹配。</span><br><span class="line"></span><br><span class="line">I2C适配器层：底层SOC I2C控制器驱动，实现i2c时序，实现i2c总线发送和接收数据的方法。</span><br></pre></td></tr></table></figure>

<p>目录结构位于drivers&#x2F;i2c：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">robin.lee@WORKSTATION5:/media/robin.lee/zip/A2/linux_5.10/drivers/i2c$ <span class="built_in">ls</span></span><br><span class="line">algos            i2c-core-acpi.c  i2c-core-of.c     i2c-dev.c           i2c-slave-testunit.c  Kconfig</span><br><span class="line">busses           i2c-core-base.c  i2c-core-slave.c  i2c-mux.c           i2c-smbus.c           Makefile</span><br><span class="line">i2c-boardinfo.c  i2c-core.h       i2c-core-smbus.c  i2c-slave-eeprom.c  i2c-stub.c            muxes</span><br></pre></td></tr></table></figure>

<h1><span id="2-shu-ju-jie-gou">2 数据结构</span><a href="#2-shu-ju-jie-gou" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-qi-xiang-guan">2.1 控制器相关</span><a href="#2-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="2-1-1-i2c-adapter-kong-zhi-qi">2.1.1 i2c_adapter-控制器</span><a href="#2-1-1-i2c-adapter-kong-zhi-qi" class="header-anchor">#</a></h3><p> I2C 适配器，也就是 SOC 的 I2C 控制器。<code>i2c_adapter</code> 结构体定义在<code> include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * i2c_adapter is the structure used to identify a physical i2c bus along</span></span><br><span class="line"><span class="comment"> * with the access algorithms necessary to access it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span>		  <span class="comment">/* classes to allow probing for */</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> *<span class="title">algo</span>;</span> <span class="comment">/* the algorithm to access the bus */</span></span><br><span class="line">	<span class="type">void</span> *algo_data;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* data fields that are valid for all devices	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rt_mutex</span> <span class="title">bus_lock</span>;</span></span><br><span class="line">	<span class="type">int</span> timeout;			<span class="comment">/* in jiffies */</span></span><br><span class="line">	<span class="type">int</span> retries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>		<span class="comment">/* the adapter device */</span></span><br><span class="line">	<span class="type">int</span> nr;   <span class="comment">//总线的编号</span></span><br><span class="line">	<span class="type">char</span> name[<span class="number">48</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">dev_released</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">userspace_clients_lock</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">userspace_clients</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_bus_recovery_info</span> *<span class="title">bus_recovery_info</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter_quirks</span> *<span class="title">quirks</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>适配器的类类型，在一些口I2C设备驱动中会检查该成员，以判断设备能否被该适配器操作</td>
</tr>
<tr>
<td>algo</td>
<td>指向该造配器通信方法描述结构的指针，就是该适配器具体操作I2C控制器的函数</td>
</tr>
<tr>
<td>algo_data</td>
<td>指向通信方法数据的指针，该成员不会被I2C核心层修改，仅供具体的 i2c_algorithm使用</td>
</tr>
<tr>
<td>timeout</td>
<td>传输超时时间</td>
</tr>
<tr>
<td>retries</td>
<td>传输超时的重试次数</td>
</tr>
<tr>
<td>name</td>
<td>适配器名称，该名称可以通过<code>sys/bus/i2c/devices/i2c-x/name</code> (x&#x3D;0,1,2 … ）来访问</td>
</tr>
<tr>
<td>nr</td>
<td>总线编号（也是适配器编号），同时对应设备节点<code>／dev/i2c-x</code> (x&#x3D;0,1,2 …）中的 x</td>
</tr>
</tbody></table>
<h3><span id="2-1-2-i2c-algorithm-tong-xin-fang-fa">2.1.2 i2c_algorithm-通信方法</span><a href="#2-1-2-i2c-algorithm-tong-xin-fang-fa" class="header-anchor">#</a></h3><p>对于一个 I2C 适配器，肯定要对外提供读 写 API 函数，设备驱动程序可以使用这些 API 函数来完成读写操作。<code>i2c_algorithm </code>就是 I2C 适 配器与 IIC 设备进行通信的方法。包括<code>transfer send recv</code>等函数<code>。i2c_algorithm </code>结构体定义在 <code>include/linux/i2c.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span></span><br><span class="line"><span class="comment">	 * to NULL. If an adapter algorithm can do SMBus access, set</span></span><br><span class="line"><span class="comment">	 * smbus_xfer. If set to NULL, the SMBus protocol is simulated</span></span><br><span class="line"><span class="comment">	 * using common I2C messages.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * master_xfer should return the number of messages successfully</span></span><br><span class="line"><span class="comment">	 * processed, or a negative value on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*master_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, <span class="keyword">struct</span> i2c_msg *msgs,</span><br><span class="line">			   <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*master_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap,</span><br><span class="line">				   <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">			  u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="type">int</span> (*smbus_xfer_atomic)(<span class="keyword">struct</span> i2c_adapter *adap, u16 addr,</span><br><span class="line">				 <span class="type">unsigned</span> <span class="type">short</span> flags, <span class="type">char</span> read_write,</span><br><span class="line">				 u8 command, <span class="type">int</span> size, <span class="keyword">union</span> i2c_smbus_data *data);</span><br><span class="line">	<span class="comment">/* To determine what the adapter supports */</span></span><br><span class="line">	u32 (*functionality)(<span class="keyword">struct</span> i2c_adapter *adap);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> IS_ENABLED(CONFIG_I2C_SLAVE)</span></span><br><span class="line">	<span class="type">int</span> (*reg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line">	<span class="type">int</span> (*unreg_slave)(<span class="keyword">struct</span> i2c_client *client);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>master_xfer </code>就是 I2C 适配器的传输函数，可以通过此函数来完成与 IIC 设备之 间的通信。 用于产生I2C访问周期需要的信号， 以<code>i2c_msg</code>为单位（i2c_msg中的成员表明了I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息） 。</p>
<p><code>smbus_xfer</code> 是 SMBUS 总线协议的传输函数。</p>
<p><code>functionality</code>：查看适配的能力。这些功能都是以宏定义的方式表示，定义在<code>include/linux/i2c.h</code>中，以<code>I2C_FUNC</code>开头：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* To determine what functionality is present */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_I2C			0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_10BIT_ADDR		0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_PROTOCOL_MANGLING	0x00000004 /* I2C_M_IGNORE_NAK etc. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PEC		0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_NOSTART		0x00000010 /* I2C_M_NOSTART */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SLAVE			0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_PROC_CALL	0x00008000 /* SMBus 2.0 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_QUICK		0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE	0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE	0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BYTE_DATA	0x00080000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BYTE_DATA	0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_WORD_DATA	0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_WORD_DATA	0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_PROC_CALL	0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_BLOCK_DATA	0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_BLOCK_DATA 0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_READ_I2C_BLOCK	0x04000000 /* I2C-like block xfer  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WRITE_I2C_BLOCK	0x08000000 /* w/ 1-byte reg. addr. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_HOST_NOTIFY	0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE		(I2C_FUNC_SMBUS_READ_BYTE | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BYTE_DATA	(I2C_FUNC_SMBUS_READ_BYTE_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BYTE_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_WORD_DATA	(I2C_FUNC_SMBUS_READ_WORD_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_WORD_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_BLOCK_DATA	(I2C_FUNC_SMBUS_READ_BLOCK_DATA | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_BLOCK_DATA)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_FUNC_SMBUS_I2C_BLOCK	(I2C_FUNC_SMBUS_READ_I2C_BLOCK | \</span></span><br><span class="line">					 I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)</span><br></pre></td></tr></table></figure>



<h2><span id="2-2-ke-hu-duan-xiang-guan">2.2 客户端相关</span><a href="#2-2-ke-hu-duan-xiang-guan" class="header-anchor">#</a></h2><p>i2c 设备(client使用者)驱动要使用<code>i2c_driver</code> 和<code>i2c_client</code>数据结构并填充i2c_driver中的成员函数。</p>
<h3><span id="2-2-1-i2c-driver-i-cong-she-bei-qu-dong">2.2.1 i2c_driver-I从设备驱动</span><a href="#2-2-1-i2c-driver-i-cong-she-bei-qu-dong" class="header-anchor">#</a></h3><p>代表一个i2c使用者设备驱动。结构体定义在 include&#x2F;linux&#x2F;i2c.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">	<span class="comment">/* Notifies the driver that a new bus has appeared. You should avoid</span></span><br><span class="line"><span class="comment">	 * using this, it will be removed in a near future.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*attach_adapter)(<span class="keyword">struct</span> i2c_adapter *) __deprecated;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Standard driver model interfaces */</span></span><br><span class="line">	<span class="type">int</span> (*probe)(<span class="keyword">struct</span> i2c_client *, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *);</span><br><span class="line">	<span class="type">int</span> (*remove)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* New driver model interface to aid the seamless removal of the</span></span><br><span class="line"><span class="comment">	 * current probe()&#x27;s, more commonly unused than used second parameter.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*probe_new)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* driver model interfaces that don&#x27;t relate to enumeration  */</span></span><br><span class="line">	<span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> i2c_client *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Alert callback, for example for the SMBus alert protocol.</span></span><br><span class="line"><span class="comment">	 * The format and meaning of the data value depends on the protocol.</span></span><br><span class="line"><span class="comment">	 * For the SMBus alert protocol, there is a single bit of data passed</span></span><br><span class="line"><span class="comment">	 * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span></span><br><span class="line"><span class="comment">	 * For the SMBus Host Notify protocol, the data corresponds to the</span></span><br><span class="line"><span class="comment">	 * 16-bit payload data reported by the slave device acting as master.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*alert)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">enum</span> i2c_alert_protocol protocol,</span><br><span class="line">		      <span class="type">unsigned</span> <span class="type">int</span> data); <span class="comment">// 警告回调函数（例如SMBus警报协议）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a ioctl like command that can be used to perform specific functions</span></span><br><span class="line"><span class="comment">	 * with the device.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*command)(<span class="keyword">struct</span> i2c_client *client, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *arg);<span class="comment">//类似于ioctl 的命令控制函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> *<span class="title">id_table</span>;</span> <span class="comment">// 这个i2c驱动支持的设备链表</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Device detection callback for automatic device creation */</span></span><br><span class="line">	<span class="type">int</span> (*detect)(<span class="keyword">struct</span> i2c_client *, <span class="keyword">struct</span> i2c_board_info *); <span class="comment">// 检测设备的回调函数；</span></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> *address_list; <span class="comment">// 要探测的I2C地址（用于检测）</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">clients</span>;</span> </span><br><span class="line">	<span class="type">bool</span> disable_i2c_core_irq_mapping;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>变量名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>attach_adapter</td>
<td>依附i2c_adapter的函数指针</td>
</tr>
<tr>
<td>detach_adapter</td>
<td>脱离i2c_adapter的函数指针</td>
</tr>
<tr>
<td>probe</td>
<td>设备和驱动匹配时调用</td>
</tr>
<tr>
<td>driver</td>
<td>在注册i2c_driver对象时，i2c_driver-&gt;driver的总线类型被指定为<code>i2c_bus_type</code></td>
</tr>
<tr>
<td>id_table</td>
<td>匹配列表，驱动和设备匹配时会用到</td>
</tr>
<tr>
<td>detect</td>
<td>基于设备探测机制实现的 12C 设备驱动：设备探测的回调函数</td>
</tr>
<tr>
<td>address_list</td>
<td>设备探测的地址范围</td>
</tr>
<tr>
<td>clients</td>
<td>探测到的设备列表</td>
</tr>
</tbody></table>
<p>i2c_driver对应于一套驱动方法， 其主要成员函数是<code>probe()</code>、<code>remove()</code>、<code>suspend()</code> 、<code>resume()</code>等。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* drivers/rtc/rtc-ds1307.c */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ds1307_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;rtc-ds1307&quot;</span>,</span><br><span class="line">        .of_match_table = of_match_ptr(ds1307_of_match),</span><br><span class="line">        .acpi_match_table = ACPI_PTR(ds1307_acpi_ids),</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe      = ds1307_probe,</span><br><span class="line">    .id_table   = ds1307_id,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-i2c-client-cong-she-bei">2.2.2 i2c_client-从设备</span><a href="#2-2-2-i2c-client-cong-she-bei" class="header-anchor">#</a></h3><p>代表一个连接到<code>i2c_bus</code>总线上的从设备，结构体定义在 <code>include/linux/i2c.h</code>。描述i2c从设备的i2c相关硬件信息。 一个i2c_driver可以支持多个同类型的i2c_client。i2c_client一般描述再设备树中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>&#123;</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> flags;   <span class="comment">//描述从设备的一些特性，如I2C_CLIENT_TEN---使用的10位地址</span></span><br><span class="line"> 	<span class="type">unsigned</span> <span class="type">short</span> addr;   <span class="comment">//设备的i2c地址，7位地址用低7位，10位地址用低10位。</span></span><br><span class="line"> 	<span class="type">char</span> name[I2C_NAME_SIZE]; <span class="comment">// 设备的名字；</span></span><br><span class="line"></span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_adapter</span> *<span class="title">adapter</span>;</span>   <span class="comment">//所属的适配器i2c_adapter,挂载在哪条i2c物理总线上</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>  *<span class="title">driver</span>;</span>    <span class="comment">//匹配成功的i2c_driver</span></span><br><span class="line">    <span class="type">int</span> irq;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-1-i2c-board-info">2.2.2.1 i2c_board_info</span><a href="#2-2-2-1-i2c-board-info" class="header-anchor">#</a></h4><p>也是描述从设备i2c硬件属性。通常情况下先填充i2c_board_info对象的成员，然后去初始化i2c_client对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> type[I2C_NAME_SIZE];<span class="comment">//名字，驱动层和设备层匹配参数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> flags;<span class="comment">//设备地址位数，一般不填或填0表示7位地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> addr;<span class="comment">//IIC设备地址</span></span><br><span class="line">    <span class="type">void</span> *platform_data;<span class="comment">//私有数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dev_archdata</span> *<span class="title">archdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">of_node</span>;</span></span><br><span class="line">    <span class="type">int</span> irq;<span class="comment">//中断号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-msg-xiao-xi">2.3 i2c_msg-消息</span><a href="#2-3-i2c-msg-xiao-xi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">	__u16 addr;	<span class="comment">/* 从机在I2C总线上的地址*/</span></span><br><span class="line">	__u16 flags;	<span class="comment">/* 消息特征的标志 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的宏定义就是消息特征的标志</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_TEN		0x0010	<span class="comment">/* this is a ten bit chip address */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RD		0x0001	<span class="comment">/* read data, from slave to master */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NOSTART		0x4000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_REV_DIR_ADDR	0x2000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_IGNORE_NAK	0x1000	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_NO_RD_ACK		0x0800	<span class="comment">/* if I2C_FUNC_PROTOCOL_MANGLING */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_M_RECV_LEN		0x0400	<span class="comment">/* length will be first received byte */</span></span></span><br><span class="line"></span><br><span class="line">	__u16 len;		<span class="comment">/* 消息数据长度，单位是字节 */</span></span><br><span class="line">	__u8 *buf;		<span class="comment">/* 指向存放消息数据的缓冲区 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>I2C的传输地址、 方向、 缓冲区、 缓冲区长度等信息。</p>
<h1><span id="3-i2c-zi-xi-tong-api">3 I2C子系统API</span><a href="#3-i2c-zi-xi-tong-api" class="header-anchor">#</a></h1><h2><span id="3-1-kong-zhi-qi-xiang-guan">3.1 控制器相关</span><a href="#3-1-kong-zhi-qi-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-zhu-ce-kong-zhi-qi">3.1.1 注册控制器</span><a href="#3-1-1-zhu-ce-kong-zhi-qi" class="header-anchor">#</a></h3><p>通过<code>i2c_add_numbered_adapter</code>或 <code>i2c_add_adapter</code> 这两个函数向系统注册设置好的 i2c_adapter。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_add_numbered_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数的区别在于 i2c_add_adapter 使用动态的总线号，而 i2c_add_numbered_adapter 使用静态总线号。</p>
<h3><span id="3-1-2-xie-zai-kong-zhi-qi">3.1.2 卸载控制器</span><a href="#3-1-2-xie-zai-kong-zhi-qi" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_adapter</span><span class="params">(<span class="keyword">struct</span> i2c_adapter * adap)</span>;</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-ke-hu-duan-she-bei-xiang-guan">3.2 客户端设备相关</span><a href="#3-2-ke-hu-duan-she-bei-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-tian-jia-i2c-she-bei-qu-dong">3.2.1 添加i2c设备驱动</span><a href="#3-2-1-tian-jia-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">i2c_register_driver</span>(<span class="params"><span class="keyword">struct</span> module *owner, <span class="keyword">struct</span> i2c_driver *driver</span>)</span>;<span class="comment">//include/linux/i2c.h</span></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> i2c_add_driver(driver) \</span></span><br><span class="line">	i2c_register_driver(THIS_MODULE, driver);</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-shan-chu-i2c-she-bei-qu-dong">3.2.2 删除i2c设备驱动</span><a href="#3-2-2-shan-chu-i2c-she-bei-qu-dong" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_del_driver</span><span class="params">(<span class="keyword">struct</span> i2c_driver *driver)</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-module-driver-he-builtin-driver-shi-yong">3.2.3 module_driver和builtin_driver使用</span><a href="#3-2-3-module-driver-he-builtin-driver-shi-yong" class="header-anchor">#</a></h3><p>在编写从设备驱动时为了方便也可以直接调用<code>module_i2c_driver</code>完成i2c驱动的<code>module_init</code>。或者使用<code>builtin_i2c_driver</code>完成i2c驱动的<code>device_initcall</code>。两者区别一个是编译成内核模块，一个是编译进内核镜像。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/2.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_driver(__driver, __register, __unregister, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_init(__driver<span class="meta">##_init); \</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __exit __driver<span class="meta">##_exit(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	__unregister(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">module_exit(__driver<span class="meta">##_exit);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * builtin_driver() - Helper macro for drivers that don&#x27;t do anything</span></span><br><span class="line"><span class="comment"> * special in init and have no exit. This eliminates some boilerplate.</span></span><br><span class="line"><span class="comment"> * Each driver may only use this macro once, and calling it replaces</span></span><br><span class="line"><span class="comment"> * device_initcall (or in some cases, the legacy __initcall).  This is</span></span><br><span class="line"><span class="comment"> * meant to be a direct parallel of module_driver() above but without</span></span><br><span class="line"><span class="comment"> * the __exit stuff that is not used for builtin cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @__driver: driver name</span></span><br><span class="line"><span class="comment"> * @__register: register function for this driver type</span></span><br><span class="line"><span class="comment"> * @...: Additional arguments to be passed to __register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use this macro to construct bus specific macros for registering</span></span><br><span class="line"><span class="comment"> * drivers, and do not use it on its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> builtin_driver(__driver, __register, ...) \</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> __init __driver<span class="meta">##_init(void) \</span></span><br><span class="line">&#123; \</span><br><span class="line">	<span class="keyword">return</span> __register(&amp;(__driver) , <span class="meta">##__VA_ARGS__); \</span></span><br><span class="line">&#125; \</span><br><span class="line">device_initcall(__driver<span class="meta">##_init);</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-2-4-shu-ju-chuan-shu">3.2.4 数据传输</span><a href="#3-2-4-shu-ju-chuan-shu" class="header-anchor">#</a></h3><h4><span id="3-2-4-1-i2c-transfer">3.2.4.1 i2c_transfer</span><a href="#3-2-4-1-i2c-transfer" class="header-anchor">#</a></h4><p>发送或接收指定字节数的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_transfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adap,<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-2-i2c-master-recv">3.2.4.2 i2c_master_recv</span><a href="#3-2-4-2-i2c-master-recv" class="header-anchor">#</a></h4><p>接收指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Int <span class="title function_">i2c_master_recv</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client,<span class="type">const</span> <span class="type">char</span> *buf,<span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-4-3-i2c-master-send">3.2.4.3 i2c_master_send</span><a href="#3-2-4-3-i2c-master-send" class="header-anchor">#</a></h4><p>发送指定字节的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">i2c_master_send</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li">4 i2c子系统驱动流程举例</span><a href="#4-i2c-zi-xi-tong-qu-dong-liu-cheng-ju-li" class="header-anchor">#</a></h1><h2><span id="4-1-he-xin-core-ceng-zhu-ce">4.1 核心core层注册</span><a href="#4-1-he-xin-core-ceng-zhu-ce" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i2c-core.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">i2c_bus_type</span> =</span> &#123;</span><br><span class="line">	.name		= <span class="string">&quot;i2c&quot;</span>,</span><br><span class="line">	.match		= i2c_device_match,	<span class="comment">//总线上驱动和设备的匹配函数</span></span><br><span class="line">	.probe		= i2c_device_probe,	<span class="comment">//总线上设备和驱动匹配时调用</span></span><br><span class="line">	.remove		= i2c_device_remove,</span><br><span class="line">	.shutdown	= i2c_device_shutdown,</span><br><span class="line">	.pm		= &amp;i2c_device_pm_ops,</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL_GPL(i2c_bus_type);</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">dummy_id</span>[] =</span> &#123;</span><br><span class="line">	&#123; <span class="string">&quot;dummy&quot;</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">dummy_driver</span> =</span> &#123;</span><br><span class="line">	.driver.name	= <span class="string">&quot;dummy&quot;</span>,</span><br><span class="line">	.probe		= dummy_probe,</span><br><span class="line">	.remove		= dummy_remove,</span><br><span class="line">	.id_table	= dummy_id,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="comment">//注册I2C总线</span></span><br><span class="line">	retval = bus_register(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">return</span> retval;	</span><br><span class="line">	<span class="comment">//向I2C总线注册一个名字为dummy的驱动，这个驱动没什么实际的功能，空实现的驱动</span></span><br><span class="line">	retval = i2c_add_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="keyword">if</span> (retval)</span><br><span class="line">		<span class="keyword">goto</span> class_err;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">class_err:</span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">i2c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">//删除dummy驱动</span></span><br><span class="line">	i2c_del_driver(&amp;dummy_driver);</span><br><span class="line">	<span class="comment">//卸载I2C总线</span></span><br><span class="line">	bus_unregister(&amp;i2c_bus_type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We must initialize early, because some subsystems register i2c drivers</span></span><br><span class="line"><span class="comment"> * in subsys_initcall() code, but are linked (and initialized) before i2c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">postcore_initcall(i2c_init);</span><br><span class="line">module_exit(i2c_exit);</span><br></pre></td></tr></table></figure>

<p>可以看到内核启动阶段就调用i2c_init 注册了I2C总线和注册了I2C设备驱动<code>dummy_driver</code>；</p>
<h3><span id="4-1-1-i2c-zong-xian-de-pi-pei-han-shu">4.1.1 I2C总线的匹配函数</span><a href="#4-1-1-i2c-zong-xian-de-pi-pei-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *<span class="title function_">i2c_match_id</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> <span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> (id-&gt;name[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(client-&gt;name, id-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> id;</span><br><span class="line">		id++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">/* Attempt an OF style match */</span></span><br><span class="line">	<span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Then ACPI style match */</span></span><br><span class="line">	<span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	driver = to_i2c_driver(drv);</span><br><span class="line">	<span class="comment">/* match on an id table if there is one */</span></span><br><span class="line">	<span class="keyword">if</span> (driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> i2c_match_id(driver-&gt;id_table, client) != <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向I2C总线注册I2C驱动或者I2C设备时，会逐一将I2C驱动的名字和I2C设备的名字进行匹配，如果匹配上则调用I2C总线的probe方法；</p>
<p>I2C总线的probe方法就是进一步调用i2c_driver的probe方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_device_probe</span><span class="params">(<span class="keyword">struct</span> device *dev)</span> &#123;</span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C设备结构体</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span>	*<span class="title">client</span> =</span> i2c_verify_client(dev);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span>	*<span class="title">driver</span>;</span></span><br><span class="line">	<span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!client)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//利用container_of宏获取到I2C驱动结构体</span></span><br><span class="line">	driver = to_i2c_driver(dev-&gt;driver);</span><br><span class="line">	<span class="keyword">if</span> (!driver-&gt;probe || !driver-&gt;id_table)</span><br><span class="line">		<span class="keyword">return</span> -ENODEV;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 把I2C设备驱动和I2C设备绑定，将来可以互相查找到对方</span></span><br><span class="line">	client-&gt;driver = driver;</span><br><span class="line">	<span class="keyword">if</span> (!device_can_wakeup(&amp;client-&gt;dev))</span><br><span class="line">		device_init_wakeup(&amp;client-&gt;dev,</span><br><span class="line">					client-&gt;flags &amp; I2C_CLIENT_WAKE);</span><br><span class="line">	dev_dbg(dev, <span class="string">&quot;probe\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用I2C驱动的probe函数</span></span><br><span class="line">	status = driver-&gt;probe(client, i2c_match_id(driver-&gt;id_table, client));</span><br><span class="line">	<span class="keyword">if</span> (status) &#123;</span><br><span class="line">		client-&gt;driver = <span class="literal">NULL</span>;</span><br><span class="line">		i2c_set_clientdata(client, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng">4.2 适配器驱动示例流程</span><a href="#4-2-gua-pei-qi-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-2-1-gua-pei-qi-zhu-ce">4.2.1 适配器注册</span><a href="#4-2-1-gua-pei-qi-zhu-ce" class="header-anchor">#</a></h3><h4><span id="4-2-1-1-i2c-kong-zhi-qi-miao-shu">4.2.1.1 i2c控制器描述</span><a href="#4-2-1-1-i2c-kong-zhi-qi-miao-shu" class="header-anchor">#</a></h4><p>以nxp的imx6ull芯片为例，在<code>imx6ull.dtsi</code>文件中找到 I2C1 控制器节点：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i2c1: i2c@<span class="number">021</span>a0000 &#123;</span><br><span class="line">	<span class="meta">#address-cells = &lt;1&gt;;</span></span><br><span class="line">	<span class="meta">#size-cells = &lt;0&gt;;</span></span><br><span class="line">	compatible = <span class="string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="string">&quot;fsl,imx21-i2c&quot;</span>;</span><br><span class="line">	reg = &lt;<span class="number">0x021a0000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line">	interrupts = &lt;GIC_SPI <span class="number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">	clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;</span><br><span class="line">	status = <span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1节点的compatible属性值有两个：<code>fsl,imx6ul-i2c</code>和<code>fsl,imx21-i2c</code>，在 Linux 源码中搜索这两个字符串即可找到对应的驱动文件为<code>drivers/i2c/busses/i2c-imx.c</code>。</p>
<h4><span id="4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li">4.2.1.2 i2c控制器驱动probe示例</span><a href="#4-2-1-2-i2c-kong-zhi-qi-qu-dong-probe-shi-li" class="header-anchor">#</a></h4><p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.png" alt="image"></p>
<p>I2C 适配器驱动也是使用标准的 platform 驱动框架。<code>compatible</code> 属性匹配成功后就会调用probe函数如下：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/3.1.png" alt="image"></p>
<details>
<summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">res</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imxi2c_platform_data</span> *<span class="title">pdata</span> =</span> dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="type">void</span> __iomem *base;</span><br><span class="line">	<span class="type">int</span> irq, ret;</span><br><span class="line">	<span class="type">dma_addr_t</span> phy_addr;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_hwdata</span> *<span class="title">match</span>;</span></span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;pdev-&gt;dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	irq = platform_get_irq(pdev, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (irq &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> irq;</span><br><span class="line"></span><br><span class="line">	res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">	base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(base))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(base);</span><br><span class="line"></span><br><span class="line">	phy_addr = (<span class="type">dma_addr_t</span>)res-&gt;start;</span><br><span class="line">	i2c_imx = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(*i2c_imx), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!i2c_imx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	match = device_get_match_data(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (match)</span><br><span class="line">		i2c_imx-&gt;hwdata = match;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		i2c_imx-&gt;hwdata = (<span class="keyword">struct</span> imx_i2c_hwdata *)</span><br><span class="line">				platform_get_device_id(pdev)-&gt;driver_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup i2c_imx driver structure */</span></span><br><span class="line">	strlcpy(i2c_imx-&gt;adapter.name, pdev-&gt;name, <span class="keyword">sizeof</span>(i2c_imx-&gt;adapter.name));</span><br><span class="line">	i2c_imx-&gt;adapter.owner		= THIS_MODULE;</span><br><span class="line">	i2c_imx-&gt;adapter.algo		= &amp;i2c_imx_algo;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.parent	= &amp;pdev-&gt;dev;</span><br><span class="line">	i2c_imx-&gt;adapter.nr		= pdev-&gt;id;</span><br><span class="line">	i2c_imx-&gt;adapter.dev.of_node	= pdev-&gt;dev.of_node;</span><br><span class="line">	i2c_imx-&gt;base			= base;</span><br><span class="line">	ACPI_COMPANION_SET(&amp;i2c_imx-&gt;adapter.dev, ACPI_COMPANION(&amp;pdev-&gt;dev));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Get I2C clock */</span></span><br><span class="line">	i2c_imx-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(i2c_imx-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span> dev_err_probe(&amp;pdev-&gt;dev, PTR_ERR(i2c_imx-&gt;clk),</span><br><span class="line">				     <span class="string">&quot;can&#x27;t get I2C clock\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	ret = clk_prepare_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t enable I2C clock, ret=%d\n&quot;</span>, ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init queue */</span></span><br><span class="line">	init_waitqueue_head(&amp;i2c_imx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up adapter data */</span></span><br><span class="line">	i2c_set_adapdata(&amp;i2c_imx-&gt;adapter, i2c_imx);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up platform driver data */</span></span><br><span class="line">	platform_set_drvdata(pdev, i2c_imx);</span><br><span class="line"></span><br><span class="line">	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, I2C_PM_TIMEOUT);</span><br><span class="line">	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_active(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Request IRQ */</span></span><br><span class="line">	ret = request_threaded_irq(irq, i2c_imx_isr, <span class="literal">NULL</span>, IRQF_SHARED,</span><br><span class="line">				   pdev-&gt;name, i2c_imx);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;can&#x27;t claim irq %d\n&quot;</span>, irq);</span><br><span class="line">		<span class="keyword">goto</span> rpm_disable;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up clock divider */</span></span><br><span class="line">	i2c_imx-&gt;bitrate = I2C_MAX_STANDARD_MODE_FREQ;</span><br><span class="line">	ret = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line">				   <span class="string">&quot;clock-frequency&quot;</span>, &amp;i2c_imx-&gt;bitrate);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; pdata &amp;&amp; pdata-&gt;bitrate)</span><br><span class="line">		i2c_imx-&gt;bitrate = pdata-&gt;bitrate;</span><br><span class="line">	i2c_imx-&gt;clk_change_nb.notifier_call = i2c_imx_clk_notifier_call;</span><br><span class="line">	clk_notifier_register(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	i2c_imx_set_clk(i2c_imx, clk_get_rate(i2c_imx-&gt;clk));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set up chip registers to defaults */</span></span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2cr_ien_opcode ^ I2CR_IEN,</span><br><span class="line">			i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">	imx_i2c_write_reg(i2c_imx-&gt;hwdata-&gt;i2sr_clr_opcode, i2c_imx, IMX_I2C_I2SR);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init optional bus recovery function */</span></span><br><span class="line">	ret = i2c_imx_init_recovery_info(i2c_imx, pdev);</span><br><span class="line">	<span class="comment">/* Give it another chance if pinctrl used is not ready yet */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EPROBE_DEFER)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Add I2C adapter */</span></span><br><span class="line">	ret = i2c_add_numbered_adapter(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> clk_notifier_unregister;</span><br><span class="line"></span><br><span class="line">	pm_runtime_mark_last_busy(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_put_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;claimed irq %d\n&quot;</span>, irq);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;device resources: %pR\n&quot;</span>, res);</span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;adapter name: \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">		i2c_imx-&gt;adapter.name);</span><br><span class="line">	dev_info(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;IMX I2C adapter registered\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Init DMA config if supported */</span></span><br><span class="line">	i2c_imx_dma_request(i2c_imx, phy_addr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* Return OK */</span></span><br><span class="line"></span><br><span class="line">clk_notifier_unregister:</span><br><span class="line">	clk_notifier_unregister(i2c_imx-&gt;clk, &amp;i2c_imx-&gt;clk_change_nb);</span><br><span class="line">	free_irq(irq, i2c_imx);</span><br><span class="line">rpm_disable:</span><br><span class="line">	pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_disable(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">	pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">	clk_disable_unprepare(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>

<ol>
<li><p><code>platform_get_irq</code> 函数获取中断号。</p>
</li>
<li><p><code>platform_get_resource </code>函数从设备树中获取 I2C1 控制器寄存器物理基 地址，也就是 <code>0X021A0000</code>。使用 <code>devm_ioremap_resource </code>函数对其进 行内存映射，得到可以在 Linux 内核中使用的虚拟地址。</p>
</li>
<li><p>使用 <code>imx_i2c_struct </code>结构体来表示 I.MX 系列 SOC 的 I2C 控制器，这里使 用 <code>devm_kzalloc</code> 函数来申请内存。</p>
</li>
<li><p>初始化<code>i2c_adapter</code>。设置i2c_adapter 的algo成员变量为<code>i2c_imx_algo</code>， 也就是设置<code> i2c_algorithm</code>。</p>
</li>
<li><p>开启i2c时钟。</p>
</li>
<li><p>注册 I2C 控制器中断，中断服务函数为<code> i2c_imx_isr</code>。</p>
</li>
<li><p>设置 I2C 频率默认为 <code>IMX_I2C_BIT_RATE=100KHz</code>，如果设备树节点设 置了<code>“clock-frequency”</code>属性的话 I2C 频率就使用 <code>clock-frequency</code> 属性值。</p>
</li>
<li><p>设置 I2C1 控制的 I2CR 和 I2SR 寄存器。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/4.png" alt="image-20240825172735043"></p>
</li>
<li><p>调用 <strong>i2c_add_numbered_adapter</strong> 函数向 Linux 内核注册 i2c_adapter。</p>
</li>
</ol>
<h3><span id="4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm">4.2.2 适配器操作-i2c_algorithm</span><a href="#4-2-2-gua-pei-qi-cao-zuo-i2c-algorithm" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_algorithm</span> <span class="title">i2c_imx_algo</span> =</span> &#123;</span><br><span class="line">    .master_xfer = i2c_imx_xfer,</span><br><span class="line">    .functionality = i2c_imx_func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-1-i2c-imx-func">4.2.2.1 i2c_imx_func</span><a href="#4-2-2-1-i2c-imx-func" class="header-anchor">#</a></h4><p><code>functionality</code>用于返回此I2C适配器支持什么样的通信协议， 在这里<code> functionality</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> u32 <span class="title function_">i2c_imx_func</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_READ_BLOCK_DATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="4-2-2-2-i2c-imx-xfer">4.2.2.2 i2c_imx_xfer</span><a href="#4-2-2-2-i2c-imx-xfer" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = pm_runtime_get_sync(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">false</span>);</span><br><span class="line">	pm_runtime_mark_last_busy(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	pm_runtime_put_autosuspend(i2c_imx-&gt;adapter.dev.parent);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_atomic</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter,</span></span><br><span class="line"><span class="params">			       <span class="keyword">struct</span> i2c_msg *msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	result = clk_enable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">	result = i2c_imx_xfer_common(adapter, msgs, num, <span class="literal">true</span>);</span><br><span class="line">	clk_disable(i2c_imx-&gt;clk);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="4-2-2-2-1-i2c-imx-xfer-common">4.2.2.2.1 i2c_imx_xfer_common</span><a href="#4-2-2-2-1-i2c-imx-xfer-common" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">i2c_imx_xfer_common</span><span class="params">(<span class="keyword">struct</span> i2c_adapter *adapter, <span class="keyword">struct</span> i2c_msg *msgs,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> num, <span class="type">bool</span> atomic)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, temp;</span><br><span class="line">	<span class="type">int</span> result;</span><br><span class="line">	<span class="type">bool</span> is_lastmsg = <span class="literal">false</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">imx_i2c_struct</span> *<span class="title">i2c_imx</span> =</span> i2c_get_adapdata(adapter);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt;\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Start I2C transfer */</span></span><br><span class="line">	result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">	<span class="keyword">if</span> (result) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Bus recovery uses gpiod_get_value_cansleep() which is not</span></span><br><span class="line"><span class="comment">		 * allowed within atomic context.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!atomic &amp;&amp; i2c_imx-&gt;adapter.bus_recovery_info) &#123;</span><br><span class="line">			i2c_recover_bus(&amp;i2c_imx-&gt;adapter);</span><br><span class="line">			result = i2c_imx_start(i2c_imx, atomic);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (result)</span><br><span class="line">		<span class="keyword">goto</span> fail0;</span><br><span class="line">	<span class="comment">/* read/write data */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i == num - <span class="number">1</span>)</span><br><span class="line">			is_lastmsg = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i) &#123;</span><br><span class="line">			dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">				<span class="string">&quot;&lt;%s&gt; repeated start\n&quot;</span>, __func__);</span><br><span class="line">			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			temp |= I2CR_RSTA;</span><br><span class="line">			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">			result = i2c_imx_bus_busy(i2c_imx, <span class="number">1</span>, atomic);</span><br><span class="line">			<span class="keyword">if</span> (result)</span><br><span class="line">				<span class="keyword">goto</span> fail0;</span><br><span class="line">		&#125;</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; transfer message: %d\n&quot;</span>, __func__, i);</span><br><span class="line">		<span class="comment">/* write/read data */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_I2C_DEBUG_BUS</span></span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; CONTROL: IEN=%d, IIEN=%d, MSTA=%d, MTX=%d, TXAK=%d, RSTA=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2CR_IEN ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_IIEN ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_MSTA ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_MTX ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2CR_TXAK ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2CR_RSTA ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">		temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2SR);</span><br><span class="line">		dev_dbg(&amp;i2c_imx-&gt;adapter.dev,</span><br><span class="line">			<span class="string">&quot;&lt;%s&gt; STATUS: ICF=%d, IAAS=%d, IBB=%d, IAL=%d, SRW=%d, IIF=%d, RXAK=%d\n&quot;</span>,</span><br><span class="line">			__func__,</span><br><span class="line">			(temp &amp; I2SR_ICF ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAAS ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_IBB ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IAL ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_SRW ? <span class="number">1</span> : <span class="number">0</span>), (temp &amp; I2SR_IIF ? <span class="number">1</span> : <span class="number">0</span>),</span><br><span class="line">			(temp &amp; I2SR_RXAK ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">if</span> (msgs[i].flags &amp; I2C_M_RD) &#123;</span><br><span class="line">			result = i2c_imx_read(i2c_imx, &amp;msgs[i], is_lastmsg, atomic);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (!atomic &amp;&amp;</span><br><span class="line">			    i2c_imx-&gt;dma &amp;&amp; msgs[i].len &gt;= DMA_THRESHOLD)</span><br><span class="line">				result = i2c_imx_dma_write(i2c_imx, &amp;msgs[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				result = i2c_imx_write(i2c_imx, &amp;msgs[i], atomic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (result)</span><br><span class="line">			<span class="keyword">goto</span> fail0;</span><br><span class="line">	&#125;</span><br><span class="line">fail0:</span><br><span class="line">	<span class="comment">/* Stop I2C transfer */</span></span><br><span class="line">	i2c_imx_stop(i2c_imx, atomic);</span><br><span class="line"></span><br><span class="line">	dev_dbg(&amp;i2c_imx-&gt;adapter.dev, <span class="string">&quot;&lt;%s&gt; exit with: %s: %d\n&quot;</span>, __func__,</span><br><span class="line">		(result &lt; <span class="number">0</span>) ? <span class="string">&quot;error&quot;</span> : <span class="string">&quot;success msg&quot;</span>,</span><br><span class="line">			(result &lt; <span class="number">0</span>) ? result : num);</span><br><span class="line">	<span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? result : num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用<code>i2c_imx_start</code>函数开启 I2C 通信。</li>
<li>读数据的话就调用 <code>i2c_imx_read</code> 函数。</li>
<li>向 I2C 设备写数据，如果要用 DMA 的话就使用<code> i2c_imx_dma_write</code> 函数来 完成写数据。如果不使用 DMA 的话就使用 <code>i2c_imx_write</code> 函数完成写数据。</li>
<li>I2C 通信完成以后调用<code>i2c_imx_stop</code>函数停止 I2C 通信。</li>
</ol>
<p><code>i2c_imx_start</code>、<code>i2c_imx_read</code>、<code>i2c_imx_write</code> 和 <code>i2c_imx_stop</code> 这些函数就是 I2C 寄存器的具体操作函数，按照<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/15384523.html">i2c协议</a>。</p>
<h2><span id="4-3-cong-she-bei-qu-dong-shi-li-liu-cheng">4.3 从设备驱动示例流程</span><a href="#4-3-cong-she-bei-qu-dong-shi-li-liu-cheng" class="header-anchor">#</a></h2><h3><span id="4-3-1-i2c-cong-she-bei-miao-shu">4.3.1 i2c从设备描述</span><a href="#4-3-1-i2c-cong-she-bei-miao-shu" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-bu-shi-yong-dts-shi-miao-shu">4.3.1.1 不使用dts时描述</span><a href="#4-3-1-1-bu-shi-yong-dts-shi-miao-shu" class="header-anchor">#</a></h4><p>在未使用设备树的时候需要在 BSP 里面使用<code>i2c_board_info</code>结构体来描 述一个具体的 I2C 设备。</p>
<p>举个例子，<code>arch/arm/mach-imx/mach-mx27_3ds.c</code>， <code>OV2640 摄像头</code>使用的 I2C 设备信息描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_board_info</span> <span class="title">mx27_3ds_i2c_camera</span> =</span> &#123;</span><br><span class="line">	I2C_BOARD_INFO(<span class="string">&quot;ov2640&quot;</span>, <span class="number">0x30</span>),</span><br><span class="line">&#125;;<span class="comment">//从设备OV2640 的名字和i2c地址</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-shi-yong-dts-miao-shu">4.3.1.2 使用dts描述</span><a href="#4-3-1-2-shi-yong-dts-miao-shu" class="header-anchor">#</a></h4><p>比如NXP 官方的 EVK 开发 板在<code> I2C1</code> 上接了 <code>mag3110 </code>这个磁力计芯片，因此必须在 i2c1 节点下创建 mag3110 子节点，然 后在这个子节点内描述 mag3110 这个i2c外设的相关信息。打开 <code>imx6ull-14x14-evk.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">	....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>重点 是 <code>compatible </code>属性和 reg 属性的设置，一个用于匹配驱动，一个用于设置器件地址。</p>
<h3><span id="4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li">4.3.2 从设备驱动代码示例</span><a href="#4-3-2-cong-she-bei-qu-dong-dai-ma-shi-li" class="header-anchor">#</a></h3><h4><span id="4-3-2-1-ap3216c-huan-jing-chuan-gan-qi">4.3.2.1 AP3216C环境传感器</span><a href="#4-3-2-1-ap3216c-huan-jing-chuan-gan-qi" class="header-anchor">#</a></h4><p>AP3216C是一个三合一环境传感器，包含<code>环境光强度(ALS)、接近距离(PS)和红外线强度(IR)</code>这 三个环境参数检测。接开发板子的<code>i2c1</code>。因此用这个外设作为i2c从设备来举例。</p>
<p>AP3216C 的特点 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. I2C 接口，快速模式下波特率可以到 400Kbit/S</span><br><span class="line">2. 多种工作模式选择：ALS、PS+IR、ALS+PS+IR、PD 等等。</span><br><span class="line">3. 内建温度补偿电路。</span><br><span class="line">4. 宽工作温度范围(-30°C ~ +80°C)。</span><br><span class="line">5. 超小封装，4.1mm x 2.4mm x 1.35mm</span><br><span class="line">6. 环境光传感器具有 16 位分辨率。</span><br><span class="line">7. 接近传感器和红外传感器具有 10 位分辨率</span><br></pre></td></tr></table></figure>

<p>AP3216C 常被用于手机、平板、导航设备等，其内置的接近传感器可以用于检测是否有物体接近，比如手机上用来检测耳朵是否接触听筒，如果检测到的话就表示正在打电话，手机就 会关闭手机屏幕以省电。也可以使用环境光传感器检测光照强度，可以实现自动背光亮度调节。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/5.png" alt="image"></p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/6.png" alt="image"></p>
<h4><span id="4-3-2-2-dts-she-zhi">4.3.2.2 dts设置</span><a href="#4-3-2-2-dts-she-zhi" class="header-anchor">#</a></h4><p>打开 <code>imx6ull-alientek-emmc.dts</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_i2c1: i2c1grp &#123;</span><br><span class="line">	fsl,pins = &lt;</span><br><span class="line">		MX6UL_PAD_UART4_TX_DATA__I2C1_SCL <span class="number">0x4001b8b0</span></span><br><span class="line">		MX6UL_PAD_UART4_RX_DATA__I2C1_SDA <span class="number">0x4001b8b0</span></span><br><span class="line">	&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">	mag3110@<span class="number">0</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;fsl,mag3110&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x0e</span>&gt;;</span><br><span class="line">		position = &lt;<span class="number">2</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>i2c1使用<code>pinctrl子系统</code>配置了iomux属性。<code>pinctrl_i2c1</code> 就是 I2C1 的 IO 节点，这里将<code> UART4_TXD</code> 和 <code>UART4_RXD </code>这两个 IO 分别 复用为<code> I2C1_SCL</code> 和<code> I2C1_SDA</code>，电气属性都设置为 <code>0x4001b8b0</code>。</p>
<p>默认i2c1 节点下并不是对应 <code>ap3216c</code> 从设备，而是<code>mag3110</code>。修改dts如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c1 &#123;</span><br><span class="line">	clock-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">	pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">	pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_i2c1&gt;;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    </span><br><span class="line">	ap3216c@<span class="number">1</span>e &#123;</span><br><span class="line">		compatible = <span class="string">&quot;alientek,ap3216c&quot;</span>;</span><br><span class="line">		reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ap3216c </code>子节点，@后面的<code>“1e”</code>是 ap3216c 的<code>器件地址</code>。</p>
<p>reg 属性也是设置 ap3216c 器件地址的，因此 reg 设置为 <code>0x1e</code>。</p>
<p>修改编译启动linux，可以看到<code>/sys/bus/i2c/devices </code>目录下存放着所有 I2C 设备，如果设备树修改正确的话，会在 <code>/sys/bus/i2c/devices </code>目录下看到一个名为<code>“0-001e”</code>的子目录：</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/7.png" alt="image"></p>
<p><code>“0-001e”</code>就是 ap3216c 的设备目录，<code>“1e”</code>就是 ap3216c 器件地址。进入<code> 0-001e</code> 目录，可以看到<code>“name”</code>文件，name 问价就保存着此设备名字，在这里就是<code>“ap3216c”</code>。</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/8.png" alt="image"></p>
<h4><span id="4-3-2-3-ap3216c-qu-dong-shi-li">4.3.2.3 AP3216C 驱动示例</span><a href="#4-3-2-3-ap3216c-qu-dong-shi-li" class="header-anchor">#</a></h4><p><code>ap3216creg.h</code>定义<code>AP3216C 的寄存器</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> AP3216C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_H</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ADDR    	0X1E	<span class="comment">/* AP3216C器件地址  */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_SYSTEMCONG	0x00	<span class="comment">/* 配置寄存器       */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTSTATUS	0X01	<span class="comment">/* 中断状态寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_INTCLEAR	0X02	<span class="comment">/* 中断清除寄存器   */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATALOW	0x0A	<span class="comment">/* IR数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_IRDATAHIGH	0x0B	<span class="comment">/* IR数据高字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATALOW	0x0C	<span class="comment">/* ALS数据低字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_ALSDATAHIGH	0X0D	<span class="comment">/* ALS数据高字节    */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATALOW	0X0E	<span class="comment">/* PS数据低字节     */</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> AP3216C_PSDATAHIGH	0X0F	<span class="comment">/* PS数据高字节     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>ap3216c.c:</p>
<details>     <summary>点击展开代码</summary>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ap3216creg.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_CNT	1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AP3216C_NAME	<span class="string">&quot;ap3216c&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> &#123;</span></span><br><span class="line">	<span class="type">dev_t</span> devid;			<span class="comment">/* 设备号 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span>		<span class="comment">/* cdev*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="keyword">class</span>;</span>	<span class="comment">/* 类 		*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span>	<span class="comment">/* 设备 	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device_node</span>	*<span class="title">nd</span>;</span> <span class="comment">/* 设备节点 */</span></span><br><span class="line">	<span class="type">int</span> major;			<span class="comment">/* 主设备号 */</span></span><br><span class="line">	<span class="type">void</span> *private_data;	<span class="comment">/* 私有数据 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;		<span class="comment">/* 三个光传感器数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> <span class="title">ap3216cdev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_read_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, <span class="type">void</span> *val, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[0]为发送要读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].addr = client-&gt;addr;			<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].flags = <span class="number">0</span>;			<span class="comment">/* 标记为发送数据 */</span></span><br><span class="line">	msg[<span class="number">0</span>].buf = &amp;reg;			<span class="comment">/* 读取的首地址 */</span></span><br><span class="line">	msg[<span class="number">0</span>].len = <span class="number">1</span>;				<span class="comment">/* reg长度*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* msg[1]读取数据 */</span></span><br><span class="line">	msg[<span class="number">1</span>].addr = client-&gt;addr;		<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg[<span class="number">1</span>].flags = I2C_M_RD;		<span class="comment">/* 标记为读取数据*/</span></span><br><span class="line">	msg[<span class="number">1</span>].buf = val;				<span class="comment">/* 读取数据缓冲区 */</span></span><br><span class="line">	msg[<span class="number">1</span>].len = len;			<span class="comment">/* 要读取的数据长度*/</span></span><br><span class="line"></span><br><span class="line">	ret = i2c_transfer(client-&gt;adapter, msg, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">2</span>) &#123;</span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		printk(<span class="string">&quot;i2c rd failed=%d reg=%06x len=%d\n&quot;</span>,ret, reg, len);</span><br><span class="line">		ret = -EREMOTEIO;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> s32 <span class="title function_">ap3216c_write_regs</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 *buf, u8 len)</span> &#123;</span><br><span class="line">	u8 b[<span class="number">256</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	</span><br><span class="line">	b[<span class="number">0</span>] = reg;					<span class="comment">/* 寄存器首地址 */</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;b[<span class="number">1</span>],buf,len);		<span class="comment">/* 将要写入的数据拷贝到数组b里面 */</span></span><br><span class="line">		</span><br><span class="line">	msg.addr = client-&gt;addr;	<span class="comment">/* ap3216c地址 */</span></span><br><span class="line">	msg.flags = <span class="number">0</span>;				<span class="comment">/* 标记为写数据 */</span></span><br><span class="line"></span><br><span class="line">	msg.buf = b;				<span class="comment">/* 要写入的数据缓冲区 */</span></span><br><span class="line">	msg.len = len + <span class="number">1</span>;			<span class="comment">/* 要写入的数据长度 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i2c_transfer(client-&gt;adapter, &amp;msg, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">ap3216c_read_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg)</span> &#123;</span><br><span class="line">	u8 data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ap3216c_read_regs(dev, reg, &amp;data, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">client</span> =</span> (<span class="keyword">struct</span> i2c_client *)dev-&gt;private_data;</span><br><span class="line">	<span class="keyword">return</span> i2c_smbus_read_byte_data(client, reg);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ap3216c_write_reg</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev, u8 reg, u8 data)</span> &#123;</span><br><span class="line">	u8 buf = <span class="number">0</span>;</span><br><span class="line">	buf = data;</span><br><span class="line">	ap3216c_write_regs(dev, reg, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ap3216c_readdata</span><span class="params">(<span class="keyword">struct</span> ap3216c_dev *dev)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">6</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 循环读取所有传感器数据 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)	</span><br><span class="line">        buf[i] = ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">0</span>] &amp; <span class="number">0X80</span>) 	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ir = <span class="number">0</span>;					</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取IR传感器的数据*/</span></span><br><span class="line">		dev-&gt;ir = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">1</span>] &lt;&lt; <span class="number">2</span>) | (buf[<span class="number">0</span>] &amp; <span class="number">0X03</span>); 			</span><br><span class="line">	</span><br><span class="line">	dev-&gt;als = ((<span class="type">unsigned</span> <span class="type">short</span>)buf[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">2</span>];<span class="comment">/* 读取ALS传感器的数据*/</span>  </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span>(buf[<span class="number">4</span>] &amp; <span class="number">0x40</span>)	<span class="comment">/* IR_OF位为1,则数据无效 */</span></span><br><span class="line">		dev-&gt;ps = <span class="number">0</span>;    													</span><br><span class="line">	<span class="keyword">else</span> 				<span class="comment">/* 读取PS传感器的数据    */</span></span><br><span class="line">		dev-&gt;ps = ((<span class="type">unsigned</span> <span class="type">short</span>)(buf[<span class="number">5</span>] &amp; <span class="number">0X3F</span>) &lt;&lt; <span class="number">4</span>) | (buf[<span class="number">4</span>] &amp; <span class="number">0X0F</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	filp-&gt;private_data = &amp;ap3216cdev;</span><br><span class="line">	<span class="comment">/* 初始化AP3216C */</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0x04</span>);<span class="comment">/* 复位AP3216C */</span></span><br><span class="line">	mdelay(<span class="number">50</span>);	<span class="comment">/* AP3216C复位最少10ms 	*/</span></span><br><span class="line">	ap3216c_write_reg(&amp;ap3216cdev, AP3216C_SYSTEMCONG, <span class="number">0X03</span>);<span class="comment">/* 开启ALS、PS+IR */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">ap3216c_read</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">char</span> __user *buf, <span class="type">size_t</span> cnt, <span class="type">loff_t</span> *off)</span> &#123;</span><br><span class="line">	<span class="type">short</span> data[<span class="number">3</span>];</span><br><span class="line">	<span class="type">long</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ap3216c_dev</span> *<span class="title">dev</span> =</span> (<span class="keyword">struct</span> ap3216c_dev *)filp-&gt;private_data;</span><br><span class="line">	ap3216c_readdata(dev);</span><br><span class="line"></span><br><span class="line">	data[<span class="number">0</span>] = dev-&gt;ir;</span><br><span class="line">	data[<span class="number">1</span>] = dev-&gt;als;</span><br><span class="line">	data[<span class="number">2</span>] = dev-&gt;ps;</span><br><span class="line">	err = copy_to_user(buf, data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_release</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ap3216c_ops</span> =</span> &#123;</span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.open = ap3216c_open,</span><br><span class="line">	.read = ap3216c_read,</span><br><span class="line">	.release = ap3216c_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_probe</span><span class="params">(<span class="keyword">struct</span> i2c_client *client, <span class="type">const</span> <span class="keyword">struct</span> i2c_device_id *id)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ap3216cdev.major) &#123;</span><br><span class="line">		ap3216cdev.devid = MKDEV(ap3216cdev.major, <span class="number">0</span>);</span><br><span class="line">		register_chrdev_region(ap3216cdev.devid, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		alloc_chrdev_region(&amp;ap3216cdev.devid, <span class="number">0</span>, AP3216C_CNT, AP3216C_NAME);</span><br><span class="line">		ap3216cdev.major = MAJOR(ap3216cdev.devid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;ap3216cdev.cdev, &amp;ap3216c_ops);</span><br><span class="line">	cdev_add(&amp;ap3216cdev.cdev, ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line"></span><br><span class="line">	ap3216cdev.class = class_create(THIS_MODULE, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.class)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.device = device_create(ap3216cdev.class, <span class="literal">NULL</span>, ap3216cdev.devid,</span><br><span class="line">                                      <span class="literal">NULL</span>, AP3216C_NAME);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(ap3216cdev.device)) &#123;</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(ap3216cdev.device);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ap3216cdev.private_data = client;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ap3216c_remove</span><span class="params">(<span class="keyword">struct</span> i2c_client *client)</span> &#123;</span><br><span class="line">	cdev_del(&amp;ap3216cdev.cdev);</span><br><span class="line">	unregister_chrdev_region(ap3216cdev.devid, AP3216C_CNT);</span><br><span class="line">	device_destroy(ap3216cdev.class, ap3216cdev.devid);</span><br><span class="line">	class_destroy(ap3216cdev.class);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">ap3216c_id</span>[] =</span> &#123;</span><br><span class="line">	&#123;<span class="string">&quot;alientek,ap3216c&quot;</span>, <span class="number">0</span>&#125;,  </span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">ap3216c_of_match</span>[] =</span> &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;alientek,ap3216c&quot;</span> &#125;,</span><br><span class="line">	&#123; <span class="comment">/* Sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">ap3216c_driver</span> =</span> &#123;</span><br><span class="line">	.probe = ap3216c_probe,</span><br><span class="line">	.remove = ap3216c_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">			.owner = THIS_MODULE,</span><br><span class="line">		   	.name = <span class="string">&quot;ap3216c&quot;</span>,</span><br><span class="line">		   	.of_match_table = ap3216c_of_match, </span><br><span class="line">		   &#125;,</span><br><span class="line">	.id_table = ap3216c_id,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">ap3216c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = i2c_add_driver(&amp;ap3216c_driver);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">ap3216c_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	i2c_del_driver(&amp;ap3216c_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ap3216c_init);</span><br><span class="line">module_exit(ap3216c_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">module_i2c_driver(ap3216c_driver);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

</details>

<ol>
<li>典型的i2c驱动框架编写的从设备驱动示例，<code>i2c_add_driver/i2c_del_driver</code>添加和删除从设备驱动。</li>
<li><code>ap3216c_of_match</code>中<code>compatible</code>匹配上，执行<code>ap3216c_probe</code>，把从设备ap3216c按照字符设备框架构造驱动。</li>
<li><code>ap3216cdev.private_data = client</code>， <code>private_data </code>成员变量用于存放 <code>ap3216c </code>对 应的 <code>i2c_client</code>。</li>
<li><code>ap3216c_open</code>初始化<code>ap3216c</code>。</li>
<li>传感器数据获取</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ap3216c_read</span><br><span class="line">   	ap3216c_readdata<span class="comment">//读取数据6字节</span></span><br><span class="line">   		ap3216c_read_reg<span class="comment">//读取一个字节</span></span><br><span class="line">   			ap3216c_read_regs<span class="comment">//构造i2c_msg[2]调用i2c_transfer获取1个字节传感器数据</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><code>ap3216c_write_reg</code>调用<code>ap3216c_write_regs</code>再调用<code>i2c_transfer</code>写入数据到指定地址寄存器。</li>
</ol>
<h4><span id="4-3-2-4-ap3216c-ying-yong-ce-shi">4.3.2.4 AP3216C应用测试</span><a href="#4-3-2-4-ap3216c-ying-yong-ce-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/ioctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="type">char</span> *filename;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> databuf[<span class="number">3</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ir, als, ps;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error Usage!\r\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filename = argv[<span class="number">1</span>];</span><br><span class="line">	fd = open(filename, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open file %s\r\n&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = read(fd, databuf, <span class="keyword">sizeof</span>(databuf));</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; 			<span class="comment">/* 数据读取成功 */</span></span><br><span class="line">			ir =  databuf[<span class="number">0</span>]; 	<span class="comment">/* ir传感器数据 */</span></span><br><span class="line">			als = databuf[<span class="number">1</span>]; 	<span class="comment">/* als传感器数据 */</span></span><br><span class="line">			ps =  databuf[<span class="number">2</span>]; 	<span class="comment">/* ps传感器数据 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;ir = %d, als = %d, ps = %d\r\n&quot;</span>, ir, als, ps);</span><br><span class="line">		&#125;</span><br><span class="line">		usleep(<span class="number">200000</span>); <span class="comment">/*100ms */</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);	<span class="comment">/* 关闭文件 */</span>	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行程序如下：</span><br><span class="line">./a.out /dev/ap3216c</span><br></pre></td></tr></table></figure>

<p>测试 APP 会不断的从 AP3216C 中读取数据，然后输出到终端上:</p>
<p><img src="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/9.png" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cm0dxg14l004bdsuffrq2di67" data-title="字符设备驱动-I2C子系统" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字符设备驱动-SPI子系统
        
      </div>
    </a>
  
  
    <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">字符设备驱动-内核led子系统</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.36px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.45px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.27px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.09px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.82px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14.55px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.45px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.91px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.73px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.64px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.36px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14.55px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-Framebuffer%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-Framebuffer子系统</a>
          </li>
        
          <li>
            <a href="/2024/09/01/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-PWM%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-PWM子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-SPI%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-SPI子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>