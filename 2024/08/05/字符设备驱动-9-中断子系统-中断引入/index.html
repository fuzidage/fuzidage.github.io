<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>字符设备驱动-9-中断子系统-中断引入 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 中断与异常种类 2 中断的处理流程 2.1 异常向量表 2.1.1 中断向量表偏移(vector base)   2.2 GIC概述 2.3 保护现场，恢复现场的核心：栈 2.3.1 ARM 处理器程序运行的过程 2.3.2 入栈保护现场&#x2F;出栈恢复现场   2.4 硬件中断、软件中断 2.4.1 硬中断 2.4.2 软中断 2.4.2.1 软中断的类型 2.4.2.2 软件">
<meta property="og:type" content="article">
<meta property="og:title" content="字符设备驱动-9-中断子系统-中断引入">
<meta property="og:url" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 中断与异常种类 2 中断的处理流程 2.1 异常向量表 2.1.1 中断向量表偏移(vector base)   2.2 GIC概述 2.3 保护现场，恢复现场的核心：栈 2.3.1 ARM 处理器程序运行的过程 2.3.2 入栈保护现场&#x2F;出栈恢复现场   2.4 硬件中断、软件中断 2.4.1 硬中断 2.4.2 软中断 2.4.2.1 软中断的类型 2.4.2.2 软件">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/2.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/3.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/4.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/5.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/6.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/7.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/8.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/9.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/10.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-1.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-2.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/12.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/13.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/14.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/15.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/16.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/17.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/18.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/19.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/20.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/21.png">
<meta property="og:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/22.png">
<meta property="article:published_time" content="2024-08-05T15:50:47.000Z">
<meta property="article:modified_time" content="2024-08-10T15:22:25.716Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="中断体系">
<meta property="article:tag" content="Linux设备驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-字符设备驱动-9-中断子系统-中断引入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2024-08-05T15:50:47.000Z" itemprop="datePublished">2024-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      字符设备驱动-9-中断子系统-中断引入
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</a></li>
<li><a href="#2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</a><ul>
<li><a href="#2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</a><ul>
<li><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</a></li>
</ul>
</li>
<li><a href="#2-2-gic-gai-shu">2.2 GIC概述</a></li>
<li><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</a><ul>
<li><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</a></li>
<li><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</a></li>
</ul>
</li>
<li><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</a><ul>
<li><a href="#2-4-1-ying-zhong-duan">2.4.1 硬中断</a></li>
<li><a href="#2-4-2-ruan-zhong-duan">2.4.2 软中断</a><ul>
<li><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</a></li>
<li><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</a><ul>
<li><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</a></li>
<li><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</a></li>
<li><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</a></li>
</ul>
</li>
<li><a href="#2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</a><ul>
<li><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</a></li>
<li><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</a></li>
<li><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</a></li>
<li><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</a></li>
</ul>
</li>
<li><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</a><ul>
<li><a href="#2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</a></li>
<li><a href="#2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</a></li>
<li><a href="#2-6-3-threaded-irq">2.6.3 threaded irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zhong-duan-yu-yi-chang-chong-lei">1 中断与异常种类</span><a href="#1-zhong-duan-yu-yi-chang-chong-lei" class="header-anchor">#</a></h1><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/1.png" alt="image"><br>CPU 在运行的过程中，也会被各种<code>“异常”</code>打断。这些<code>“异常”</code>有：</p>
<ol>
<li>指令未定义</li>
<li>Reset复位</li>
<li>指令、数据访问有问题</li>
<li>SWI(软中断)</li>
<li>快中断</li>
<li>IRQ中断</li>
</ol>
<p>IRQ中断只是一种（一类）异常而已。导致中断发生的情况有很多，比如：</p>
<ol>
<li>按键</li>
<li>定时器</li>
<li>ADC 转换完成</li>
<li>UART 发送完数据、收到数据</li>
</ol>
<p>这些众多的<code>“中断源”</code>，汇集到<code>“中断控制器”</code>，由<code>“中断控制器”</code>选择优先级最高的中断并通知 CPU。如上图所示：</p>
<h1><span id="2-zhong-duan-de-chu-li-liu-cheng">2 中断的处理流程</span><a href="#2-zhong-duan-de-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>arm 对异常(中断)处理过程：</p>
<ol>
<li>初始化：<br> a) 设置<strong>中断源</strong>，让它可以产生中断<br> b) 设置<strong>中断控制器</strong>(可以屏蔽某个中断，优先级)<br> c) 设置 <strong>CPU 总开关(使能中断)</strong></li>
<li>执行其他程序：正常程序</li>
<li>产生中断：比如按下按键（中断源发出中断请求）—&gt;中断控制器—&gt;CPU</li>
<li>CPU 每执行完一条指令都会检查有无中断&#x2F;异常产生</li>
<li>CPU 发现有中断&#x2F;异常产生，开始处理。</li>
</ol>
<p>对于不同的异常，跳去不同的地址执行程序。这地址上，只是一条跳转指令，跳去执行某个函数(地址)，这个就是异常向量。③④⑤都是硬件做的。③是中断源来做，④⑤是cpu来做</p>
<p>综上5个过程，软件要做的事情:<br>a) 保存现场(各种寄存器)<br>b) 处理异常(中断): 从<strong>异常向量表</strong>跳到不同的异常向量去执行，分辨中断源，再调用不同的处理函数<br>c) 恢复现场</p>
<h2><span id="2-1-yi-chang-xiang-liang-biao">2.1 异常向量表</span><a href="#2-1-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>可以参考我之前写的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="异常向量表">s3c2440裸机-异常中断（一. 异常、中断的原理与流程）</a> 介绍了异常向量表。<br>uboot中就有大量类似这种的异常向量表，不同系列芯片每个异常的偏移地址会有所不同。下图以s3c2440芯片为例：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/2.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/3.png" alt="image"></p>
<table>
<thead>
<tr>
<th>向量地址</th>
<th>中断类型</th>
<th>中断模式</th>
</tr>
</thead>
<tbody><tr>
<td>0X00</td>
<td>复位中断(Rest)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X04</td>
<td>未定义指令中断(Undefined Instruction)</td>
<td>未定义指令中止模式(Undef)</td>
</tr>
<tr>
<td>0X08</td>
<td>软中断(Software Interrupt,SWI)</td>
<td>特权模式(SVC)</td>
</tr>
<tr>
<td>0X0C</td>
<td>指令预取中止中断(Prefetch Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X10</td>
<td>数据访问中止中断(Data Abort)</td>
<td>中止模式</td>
</tr>
<tr>
<td>0X14</td>
<td>未使用(Not Used)</td>
<td>未使用</td>
</tr>
<tr>
<td>0X18</td>
<td>IRQ</td>
<td>中断(IRQ Interrupt)</td>
</tr>
<tr>
<td>0X1C</td>
<td>FIQ</td>
<td>中断(FIQ Interrupt)</td>
</tr>
</tbody></table>
<p>这就是异常向量表，每一条指令对应一种异常。<br>发生复位时，CPU 就去 执行第 1 条指令：<code>b reset</code>。<br>发生中断时，CPU 就去执行<code>“ldr pc, _irq”</code>这条指令。这些指令存放的位置是固定的，比如对于ARM9芯片中断向量的地址是<code>0x18</code>。当发生中断时，CPU 就强制跳去执行 <code>0x18 </code>处的代码。</p>
<h3><span id="2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base">2.1.1 中断向量表偏移(vector base)</span><a href="#2-1-1-zhong-duan-xiang-liang-biao-pian-yi-vector-base" class="header-anchor">#</a></h3><p>在向量表里，一般都是放置一条跳转指令，发生该异常时，CPU 就会执行向量表中的跳转指令，去调用更复杂的函数。当然，向量表的位置并不总是从 0 地址开始，很多芯片可以设置某个 <code>vector base </code>寄存器，指定向量表在其他位置，比如imx6ull芯片设置 <code>vector base </code>为 <code>0x80000000</code>，指定为 DDR 的某个地址。但是表中的各个异常向量的偏移地址，是固定的：复位向量偏移地址是 0，中断是 0x18。</p>
<h2><span id="2-2-gic-gai-shu">2.2 GIC概述</span><a href="#2-2-gic-gai-shu" class="header-anchor">#</a></h2><p>对于 ARM 的中断控制器，述语上称之为<code> GIC (Generic Interrupt Controller)</code>，到目前已经更新到 v4 版本了。在STM32叫做<code>NVIC</code>(内嵌向量中断控制器 <code>Nested Vectored Interrupt Controller</code>)<br>简单地说，<code>GIC v3/v4</code> 用于 <code>ARMv8</code> 架构，即 64 位 ARM 芯片。<br>而 <code>GIC v2</code> 用于<code> ARMv7</code> 和其他更低的32位架构。v2架构下一节：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17733146.html">设备驱动-10.中断子系统-5 armv7 GIC架构解析</a> 会展开细说。</p>
<p>v8架构是在32位ARM架构上进行开发的，将被首先用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域，如企业应用、高档消费电子产品。<code>ARMv8</code>架构包含两个执行状态：<code>AArch64</code>和<code>AArch32</code>。<code>AArch64</code>执行状态针对64位处理技术，引入了一个全新指令集A64；而<code>AArch32</code>执行状态将支持现有的ARM指令集。</p>
<h2><span id="2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan">2.3 保护现场，恢复现场的核心：栈</span><a href="#2-3-bao-hu-xian-chang-hui-fu-xian-chang-de-he-xin-zhan" class="header-anchor">#</a></h2><p>中断当前正在运行的进程、线程。进程、线程是什么？内核如何切换进程、线程、中断？要理解这些概念，必须理解栈的作用。</p>
<p>进程是资源分配的基本单位，线程是调度的基本单位。<br>    比如全局变量a, 对不同线程它是共享的，但是这个资源a是属于该进程独立的资源，对其他进程是不可见的。<br>    一个进程可以包含多个线程，线程有自己的栈空间，也就是局部变量。</p>
<h3><span id="2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng">2.3.1 ARM 处理器程序运行的过程</span><a href="#2-3-1-arm-chu-li-qi-cheng-xu-yun-xing-de-guo-cheng" class="header-anchor">#</a></h3><p>ARM 芯片属于精简指令集计算机(<code>RISC：Reduced Instruction Set  Computing</code>)，它所用的指令比较简单，有如下特点：</p>
<pre><code>对内存只有读、写指令
对于数据的运算是在 CPU 内部实现
使用 RISC 指令的 CPU 复杂度小一点，易于设计
</code></pre>
<p>比如对于<code>a=a+b</code>这样的算式，需要经过下面 4 个步骤才可以实现：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/4.png" alt="image"><br>我们先忽略各种 CPU 模式(系统模式、用户模式等等)。详细过程如下：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/5.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [a]</span><br><span class="line">LDR R1, [b]</span><br><span class="line">ADD R0, R0, R1</span><br><span class="line">STR R0, [a]</span><br><span class="line">/*翻译如下：</span><br><span class="line">把内存 a 的值读入 CPU 寄存器 R0</span><br><span class="line">把内存 b 的值读入 CPU 寄存器 R1</span><br><span class="line">把 R0、R1 累加，存入 R0</span><br><span class="line">把 R0 的值写入内存 a*/</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang">2.3.2 入栈保护现场&#x2F;出栈恢复现场</span><a href="#2-3-2-ru-zhan-bao-hu-xian-chang-x2f-chu-zhan-hui-fu-xian-chang" class="header-anchor">#</a></h3><p>当进行函数调用跳转到下一个函数，又或者中断一个程序，就需要把这些寄存器的值保存下来：这就称为<strong>保存现场</strong>。保存的寄存器那块内存就称为栈空间。<br>当跳转的函数执行完成，就需要从栈中恢复那些 CPU 内部寄存器的值，这一出栈的过程也被叫做<strong>“恢复现场”</strong>。</p>
<p><strong>①函数调用：</strong></p>
<pre><code>1.在函数 A 里调用函数 B，实际就是中断函数 A 的执行。
2.那么需要把函数 A 调用 B 之前瞬间的 CPU 寄存器的值，保存到栈里
</code></pre>
<p><strong>②中断处理：</strong></p>
<pre><code>a) 进程 A 正在执行，这时候发生了中断。
b) CPU 强制跳到中断异常向量地址去执行，
c) 这时就需要保存进程 A 被中断瞬间的 CPU 寄存器值，
d) 可以保存在进程 A 的内核态栈，也可以保存在进程 A 的内核结构体中。
e) 中断处理完毕，要继续运行进程 A 之前，恢复这些值
</code></pre>
<p><strong>③进程切换：</strong><br>进程 A 的时间用完了，就切换到进程 B。怎么切换？切换过程是发生在内核态里的，跟中断的处理类似。<br>a) 进程 A 被切换瞬间的 CPU 寄存器值保存在某个地方；<br>b) 恢复进程 B 之前保存的 CPU 寄存器值，这样就可以运行进程 B 了。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/6.png" alt="image"><br>总结有3种场景会要用到栈去保存和恢复现场：</p>
<p>①函数调用，②进程切换，③中断过程。<strong>进程调度核心就是靠定时器中断来实现</strong>。</p>
<h2><span id="2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan">2.4 硬件中断、软件中断</span><a href="#2-4-ying-jian-zhong-duan-ruan-jian-zhong-duan" class="header-anchor">#</a></h2><h3><span id="2-4-1-ying-zhong-duan">2.4.1 硬中断</span><a href="#2-4-1-ying-zhong-duan" class="header-anchor">#</a></h3><p>硬件产生的中断，称之为<code>“硬件中断”</code>(<code>hard irq</code>)。每个硬件中断都有对应的处理函数，比如按键中断、网卡中断，定时器中断的处理函数肯定不一样。<br>为方便理解，可以先认为对硬件中断的处理是用数组来实现的，数组里存放的是函数指针：一个中断号对应一个中断服务函数<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/7.png" alt="image"></p>
<h3><span id="2-4-2-ruan-zhong-duan">2.4.2 软中断</span><a href="#2-4-2-ruan-zhong-duan" class="header-anchor">#</a></h3><p>相对的，还可以人为地制造中断：软件中断(<code>soft irq</code>)，如下图所示：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/8.png" alt="image"></p>
<ol>
<li>软件中断何时生产？<br> 由软件决定，对于 X 号软件中断，只需要把它的 flag 设置为 1 就表示发生了该中断。</li>
<li>软件中断何时处理？<br> 软件中断嘛，并不是那么十万火急，有空再处理它好了,因此一般软件中断是硬件中断处理完后，顺便来处理软件中断。</li>
<li>有哪些软件中断？</li>
</ol>
<h4><span id="2-4-2-1-ruan-zhong-duan-de-lei-xing">2.4.2.1 软中断的类型</span><a href="#2-4-2-1-ruan-zhong-duan-de-lei-xing" class="header-anchor">#</a></h4><p>查内核源码<code> include/linux/interrupt.h</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/9.png" alt="image"><br>怎么设置使用软中断，比如<code>tasklet </code>（后面会讲中断上半部分， 和中断下半部分）就是使用软件中断实现的。还有<a target="_blank" rel="noopener" href="https://fuzidage.github.io/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/">字符设备驱动-8-内核定时器</a>   <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fuzidage/p/17473292.html">字符设备驱动-9.内核定时器</a>也是利用软中断实现的。</p>
<p>总结使用软中断的类型有:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优先级为<span class="number">0</span>，HI_SOFTIRQ，高优先级的tasklet</span><br><span class="line">优先级为<span class="number">1</span>，定时器软中断</span><br><span class="line">发送网络数据包的软中断</span><br><span class="line">接受网络数据包的软中断</span><br><span class="line">块设备的软中断</span><br><span class="line">优先级为<span class="number">0</span>，tasklet，低优先级的tasklet</span><br><span class="line">进程调度和负载均衡</span><br><span class="line">高进度定时器</span><br><span class="line">RCU</span><br></pre></td></tr></table></figure>

<h4><span id="2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong">2.4.2.2 软件中断的API使用</span><a href="#2-4-2-2-ruan-jian-zhong-duan-de-api-shi-yong" class="header-anchor">#</a></h4><h5><span id="2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq">2.4.2.2.1 注册软中断-open_softirq</span><a href="#2-4-2-2-1-zhu-ce-ruan-zhong-duan-open-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/10.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span>&#123;</span><br><span class="line">	softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如网络发包对应类型为<code>NET_TX_SOFTIRQ</code>的处理函数<code>net_tx_action</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/core/dev.c</span></span><br><span class="line">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ, net_rx_action);</span><br></pre></td></tr></table></figure>

<h5><span id="2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq">2.4.2.2.2 使能软中断-raise_softirq</span><a href="#2-4-2-2-2-shi-neng-ruan-zhong-duan-raise-softirq" class="header-anchor">#</a></h5><p>  <img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11.png" alt="image"><br>  最核心的函数是 <code>raise_softirq</code>，简单地理解就是设置<code> softirq_veq[nr]</code>的标记位，设置后表示使能该软中断号。</p>
<h5><span id="2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq">2.4.2.2.3 执行软中断-do_softirq</span><a href="#2-4-2-2-3-zhi-xing-ruan-zhong-duan-do-softirq" class="header-anchor">#</a></h5><p>每个 CPU 上会初始化一个 <code>ksoftirqd</code> 内核线程，负责处理各种类型的 <code>softirq </code>中断事件:</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-1.png" alt="image-20240810221847189"></p>
<p>当注册软中断使能后，<code>ksoftirqd</code> 线程，执行<code>pending</code>的软中断。<code>ksoftirqd</code> 里面会进一步调用到 <code>__do_softirq</code>。</p>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/11-2.png" alt="image-20240810223529233"></p>
<p>可以看到软中断执行，硬件中断是使能的。遍历使能的<code>softlrq</code>,执行对应的<code>action</code>函数。</p>
<h3><span id="2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie">2.4.3 硬件中断和软中断区别</span><a href="#2-4-3-ying-jian-zhong-duan-he-ruan-zhong-duan-qu-bie" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/12.png" alt="image"></p>
<ol>
<li>硬件中断包含gpio，网卡，外围电路IP等等，<code>tick</code>（产生一次tick系统滴答中断，<code>jiffies加1</code>）</li>
<li>软件中断包含<code>TIMER</code> 表示定时中断、RCU 表示 RCU 锁中断、<code>SCHED </code>表示内核调度中断</li>
</ol>
<p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/13.png" alt="image"></p>
<p><strong>区别：</strong><br>上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的工作，特点是快速执行；<br>下半部是由内核触发，也就说软中断，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行</p>
<p><code>cat /proc/softirqs</code>可以看软件中断信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/softirqs</span><br><span class="line">                  CPU0     CPU1  ...    CPU46    CPU47</span><br><span class="line">          HI:        2        0  ...        0        1</span><br><span class="line">       TIMER:   443727   467971  ...   313696   270110</span><br><span class="line">      NET_TX:    57919    65998  ...    42287    54840</span><br><span class="line">      NET_RX:    28728  5262341  ...    81106    55244</span><br><span class="line">       BLOCK:      261     1564  ...   268986   463918</span><br><span class="line">    IRQ_POLL:        0        0  ...        0        0</span><br><span class="line">     TASKLET:       98      207  ...      129      122</span><br><span class="line">       SCHED:  1854427  1124268  ...  5154804  5332269</span><br><span class="line">     HRTIMER:    12224    68926  ...    25497    24272</span><br><span class="line">         RCU:  1469356   972856  ...  5961737  5917455</span><br></pre></td></tr></table></figure>

<p><code>cat /proc/interrupts</code>可以看硬件中断</p>
<h2><span id="2-5-zhong-duan-chu-li-yuan-ze">2.5 中断处理原则</span><a href="#2-5-zhong-duan-chu-li-yuan-ze" class="header-anchor">#</a></h2><h3><span id="2-5-1-yuan-ze-1-bu-neng-qian-tao">2.5.1 原则 1:不能嵌套</span><a href="#2-5-1-yuan-ze-1-bu-neng-qian-tao" class="header-anchor">#</a></h3><p>中断 A 正在处理的过程中，假设又发生了中断 B，那么在栈里要保存 A 的现场，然后处理 B。在处理 B 的过程中又发生了中断 C，那么在栈里要保存 B 的现场，然后处理C。<br>如果中断嵌套突然暴发，那么栈将越来越大，栈终将耗尽。<br>为了防止这种情况发生，也是为了简单化中断的处理，在 Linux 系统上规定中断无法嵌套：即当前中断 A 没处理完之前，不会响应另一个中断 B(即使它的优先级更高)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local_irq_disable();</span><br></pre></td></tr></table></figure>
<h3><span id="2-5-2-yuan-ze-2-yue-kuai-yue-hao">2.5.2 原则 2:越快越好</span><a href="#2-5-2-yuan-ze-2-yue-kuai-yue-hao" class="header-anchor">#</a></h3><p>在单核心芯片系统中，假设中断处理很慢，那应用程序在这段时间内就无法执行：系统显得很迟顿。</p>
<h3><span id="2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu">2.5.3 原则 3:耗时久的中断操作切分为中断上半部、下半部</span><a href="#2-5-3-yuan-ze-3-hao-shi-jiu-de-zhong-duan-cao-zuo-qie-fen-wei-zhong-duan-shang-ban-bu-xia-ban-bu" class="header-anchor">#</a></h3><p>当处理某个中断要做的事情就是很多，没办法加快。比如对于按键中断，我们需要等待几十毫秒消除机械抖动。难道要在<code>irq_handler</code> 中等待吗？对于计算机来说，这可是一个段很长的时间。又比如图像处理中，当一个硬件IP处理完成一张图像的操作，那么对这张图像的后处理操作难道要放在中断服务中来操作嘛，显然这个耗时是非常久的。<br>那么中断操作切分为中断上半部、下半部。上半部分关中断，清中断执行关键紧急的事情，下半部分去处理耗时久的事情，如下图：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/14.png" alt="image"><br>中断下半部的实现有很多种方法： ①<code>tasklet</code>(小任务)、②<code>work queue</code>(工作队列)， ③<code>threaded irq</code>等。</p>
<h3><span id="2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian">2.5.4 原则 4:上半部和下半部均不能休眠</span><a href="#2-5-4-yuan-ze-4-shang-ban-bu-he-xia-ban-bu-jun-bu-neng-xiu-mian" class="header-anchor">#</a></h3><p>中断上半部、下半部的执行过程中，不能休眠：中断休眠的话，以后谁来调度进程啊？</p>
<h2><span id="2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa">2.6 中断下半部处理方法</span><a href="#2-6-zhong-duan-xia-ban-bu-chu-li-fang-fa" class="header-anchor">#</a></h2><h3><span id="2-6-1-xiao-ren-wu-tasklet">2.6.1 小任务tasklet</span><a href="#2-6-1-xiao-ren-wu-tasklet" class="header-anchor">#</a></h3><p><code>tasklet</code> 是使用软中断来实现的：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/15.png" alt="image"><br><strong>中断上半部和下半部的处理流程：</strong><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/16.png" alt="image"><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/17.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 中断源产生中断，执行irq_enter(), 最开始preempt_count=<span class="number">0</span>，preempt_count++后为<span class="number">1</span>, </span><br><span class="line">	generic_handle_irq中会找到该中断源对应的中断服务程序</span><br><span class="line"><span class="number">2.</span> 执行irq函数，执行中断上半部，（注意执行上半部分时是无法被中断的，调用了local_irq_disable()）</span><br><span class="line"><span class="number">3.</span> irq_exit(),preempt_count-- 后为<span class="number">0</span>，</span><br><span class="line"><span class="number">4.</span> 判断preempt_count是否等于<span class="number">0</span>，此时等于<span class="number">0</span>，也就是执行下半部分，也叫做软中断流程</span><br><span class="line"><span class="number">5.</span> 下半部过程中会对preempt_count++，开始软件中断</span><br><span class="line"><span class="number">6.</span> 由于是软件中断，开总中断，允许其他的硬件中断响应local_irq_enable();</span><br><span class="line"><span class="number">7.</span> 根据软中断号找到服务函数，执行所谓的中断下半部分（可以进行耗时的一些操作，因为有使能中断）</span><br><span class="line"><span class="number">8.</span> 下半部分执行完后，local_irq_disable()</span><br><span class="line"><span class="number">9.</span> preempt_count--，preempt_count又回到<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上半部中断（硬件中断）有<code>local_irq_disable()</code>，中断是不允许被另一个中断打断的。而下半部（软件中断）时中断是开的，它可以被其他中断打断<code>local_irq_enable()</code>。</p>
<p>那么软中断（下半部）A还没有执行到<code>⑨preempt_count--</code>，当被其他中断B打断时，又执行<code>①preempt_count++</code>，等于2，又进入了下一个硬件中断B流程。当下一个硬件中断B流程执行完后，<code>preempt_count--</code>，等于1，此时不会进入软总断流程直接结束，然后恢复A中断的下半部，继续执行完A中断下半部分的代码。<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/18.png" alt="image"><br>那这样B的下半部怎么执行呢？难道不要了吗？注意：<code>步骤7</code>中的中断下半部处理过程中，它处理的是所有中断的下半部分，处理完A的下半部后会继续处理B中断的下半部。所以，多个中断的下半部，是汇集在一起处理的。<br>总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.中断的处理可以分为上半部，下半部</span><br><span class="line">2.中断上半部，用来处理紧急的事，它是在关中断的状态下执行的</span><br><span class="line">3.中断下半部，用来处理耗时的、不那么紧急的事，它是在开中断的状态下执行的.</span><br><span class="line">   	中断下半部执行时，有可能会被其他硬件中断打断</span><br><span class="line">4.中断上半部、下半部的执行过程中，不能休眠</span><br></pre></td></tr></table></figure>
<h3><span id="2-6-2-gong-zuo-dui-lie-workqueue">2.6.2 工作队列workqueue</span><a href="#2-6-2-gong-zuo-dui-lie-workqueue" class="header-anchor">#</a></h3><p>如果下半部要做的事情太多，那么<code>tasklet</code>就有点不太符合需求了，我们希望建立一个线程来专门执行中断后处理，用内核线程来做：在中断上半部唤醒内核线程。<br>在linux操作系统中，有一个内核线程**<code>kworker</code>** 线程，是系统帮我们创建的。内核中有很多这样的线程：<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/19.png" alt="image"><br><code>kworker</code> 线程要去<code>“工作队列”(work queue)</code>上取出一个一个<code>“工作”(work)</code>，来执行它里面的函数。</p>
<p>1.创建 <code>work</code><br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/20.png" alt="image"></p>
<p>2.要执行这个函数时，把<code> work</code> 提交给 <code>work queue </code>就可以了<br><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/21.png" alt="image"><br>上述函数会把 <code>work</code> 提供给**<code>系统默认的 work queue：system_wq</code>**，它是一个队列。<code>schedule_work</code> 函数不仅仅是把 <code>work </code>放入队列，还会把<code>kworker </code>线程唤醒。</p>
<p>3.什么时候把 <code>work </code>提交给 <code>work queue</code>？<br>在中断场景中，可以在中断上半部调用 <code>schedule_work</code> 函数。<br>因此耗时久的中断下半部分，应该利用线程化处理方式，比如使用工作队列<code>workqueue</code>，上半部调用<code>schedule_work </code>函数，触发<code> work</code> 的处理。</p>
<h3><span id="2-6-3-threaded-irq">2.6.3 threaded irq</span><a href="#2-6-3-threaded-irq" class="header-anchor">#</a></h3><p><img src="/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/22.png" alt="image"><br><code>threaded_irq</code>：下半部也是利用线程化处理。前面的<code>workqueue</code>处理使用方法太麻烦，需要在上半部进行<code>work</code>定义，<code>schedule_work</code>操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">参数handler:上半部分可以为空</span><br><span class="line">参数：thread_fn，系统会为这个函数创建一个内核线程。发生中断时，内核线程就会执行这个函数</span><br></pre></td></tr></table></figure>
<p>以前用 <code>work </code>来线程化地处理中断，一个 <code>worker </code>线程只能由一个 CPU 执行，多个中断的 <code>work</code> 都由同一个<code> worker</code> 线程来处理，在单 CPU 系统中也只能忍着了。但是在 SMP 系统中，明明有那么多 CPU 空着，你偏偏让多个中断挤在这个CPU 上？<br>新技术 <code>threaded irq</code>，为每一个中断都创建一个内核线程；多个中断的内核线程可以分配到多个 CPU 上执行，这提高了效率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/05/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E5%BC%95%E5%85%A5/" data-id="cm0dxg14k0042dsuf1c898kgg" data-title="字符设备驱动-9-中断子系统-中断引入" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/08/07/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-GICv2%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字符设备驱动-9-中断子系统-GICv2架构解析
        
      </div>
    </a>
  
  
    <a href="/2024/08/04/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-8-%E5%86%85%E6%A0%B8%E5%AE%9A%E6%97%B6%E5%99%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">字符设备驱动-8-内核定时器</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 14px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 11px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 11px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 13px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>