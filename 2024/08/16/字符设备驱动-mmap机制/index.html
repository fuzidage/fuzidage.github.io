<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>字符设备驱动-mmap机制 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 引入mmap 1.1 内存映射现象 1.1.1 引入MMU 1.1.2 查看进程地址空间     2 mmap内核态的描述 2.1 进程结构体(task_struct)和进程地址空间(mm_struct) 2.1.1 vm_area_struct虚拟内存区域     3 页表映射 3.1 一级页表映射 3.2 二级页表映射   4 mmap函数调用过程 4.1 vm_area_str">
<meta property="og:type" content="article">
<meta property="og:title" content="字符设备驱动-mmap机制">
<meta property="og:url" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1 引入mmap 1.1 内存映射现象 1.1.1 引入MMU 1.1.2 查看进程地址空间     2 mmap内核态的描述 2.1 进程结构体(task_struct)和进程地址空间(mm_struct) 2.1.1 vm_area_struct虚拟内存区域     3 页表映射 3.1 一级页表映射 3.2 二级页表映射   4 mmap函数调用过程 4.1 vm_area_str">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png">
<meta property="og:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png">
<meta property="article:published_time" content="2024-08-16T13:58:58.000Z">
<meta property="article:modified_time" content="2024-08-16T16:06:19.087Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="Linux设备驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-字符设备驱动-mmap机制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="dt-published" datetime="2024-08-16T13:58:58.000Z" itemprop="datePublished">2024-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      字符设备驱动-mmap机制
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-mmap">1 引入mmap</a><ul>
<li><a href="#1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</a><ul>
<li><a href="#1-1-1-yin-ru-mmu">1.1.1 引入MMU</a></li>
<li><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</a><ul>
<li><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</a><ul>
<li><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-ye-biao-ying-she">3 页表映射</a><ul>
<li><a href="#3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</a></li>
<li><a href="#3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</a></li>
</ul>
</li>
<li><a href="#4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</a><ul>
<li><a href="#4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</a></li>
<li><a href="#4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</a><ul>
<li><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</a><ul>
<li><a href="#4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-mmap">1  引入mmap</span><a href="#1-yin-ru-mmap" class="header-anchor">#</a></h1><p>应用程序和驱动程序之间传递数据时，可以通过 read、write 函数进行, 用户态和内核态的数据交互一般用<code>copy_from_user</code>,<code>copy_to_user</code>。这种方式在数据量比较小时没什么问题；但是数据量比较大时效率就太低了。比如更新 LCD 显示时，如果每次都让 APP 传递一帧数据给内核，假设 LCD 采用<code>1024x600x32 bpp </code>的格式，一帧数据就有<code>1024x600x32/8=2.3MB</code> 左右,而且一般为了显示动态画面，LDC输出fps要求是<code>60fps or 30 fps</code>，那么一秒数据量为<code>30x2.3 = 70M</code>左右，显然<code>copy_from_user</code>，<code>copy_to_user</code>的方式不再适合。<br>改进的方法就是让程序可以直接读写驱动程序中的 buffer，这可以通过mmap 实现(memory map)，把内核的 buffer 映射到用户态，让 APP 在用户态直接读写。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/1.png" alt="image"><br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/2.png" alt="image"></p>
<h2><span id="1-1-nei-cun-ying-she-xian-xiang">1.1 内存映射现象</span><a href="#1-1-nei-cun-ying-she-xian-xiang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;number&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	a = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a&#x27;s address = 0x%lx, a&#x27;s value = %d\n&quot;</span>, &amp;a, a);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 PC 上如下编译(必须静态编译)：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test test.c -staitc</span><br></pre></td></tr></table></figure>
<p>分别后台执行 test 程序 2 次。最后执行 ps，可以看到这 2 个程序同时存在，这 2 个程序里 a 变量的地址相同，但是值不同。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/3.png" alt="image"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 个程序同时运行，它们的变量a的地址都是一样的：0x6bc3a0；</span><br><span class="line">2 个程序同时运行，它们的变量a的值是不一样的，一个是 111，另一个是 123。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-1-yin-ru-mmu">1.1.1 引入MMU</span><a href="#1-1-1-yin-ru-mmu" class="header-anchor">#</a></h3><p>来分析一下：<br>2个程序同时在内存中运行，它们的值不一样，所以变量 a 的物理内存地址肯定不同（2个变量存放不是同一个地方）；<br>但是打印出来的变量 a 的地址却是一样的。怎么回事？<br>这里要引入<strong>虚拟地址</strong>的概念：CPU 发出的地址是虚拟地址，它经过<code>MMU(Memory Manage Unit，内存管理单元)</code>映射到物理地址上，对于不同进程的同一个虚拟地址，MMU 会把它们映射到不同的物理地址。<br>总结:虽然虚拟地址一样，但物理地址不一样，这个是mmu的功劳，将同一虚拟地址映射到不同物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前运行的是 app1 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr1，用 paddr1 去访问内存。</span><br><span class="line">当前运行的是 app2 时，MMU 会把 CPU 发出的虚拟地址 addr 映射为物理地址paddr2，用 paddr2 去访问内存。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian">1.1.2 查看进程地址空间</span><a href="#1-1-2-cha-kan-jin-cheng-di-zhi-kong-jian" class="header-anchor">#</a></h3><p>MMU 负责把虚拟地址映射为物理地址，虚拟地址映射到哪个物理地址去？可以执行<code>ps</code>命令查看进程 ID，然后执行<code>“cat /proc/[PID]/maps”</code>得到虚拟地址空间映射关系。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/5.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00400000</span><span class="number">-004b</span>6000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>6000<span class="number">-006b</span>c000 rw-p <span class="number">000b</span>6000 <span class="number">08</span>:<span class="number">04</span> <span class="number">2228541</span>                            /home/book/ftp/a.out</span><br><span class="line"><span class="number">006b</span>c000<span class="number">-006b</span>d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">021</span>c8000<span class="number">-021</span>eb000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                                  [heap]</span><br><span class="line"><span class="number">7f</span>fe18738000<span class="number">-7f</span>fe18759000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fe187f9000<span class="number">-7f</span>fe187fc000 r--p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vvar]</span><br><span class="line"><span class="number">7f</span>fe187fc000<span class="number">-7f</span>fe187fd000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br></pre></td></tr></table></figure>
<p>第一行地址范围显示权限为可读可执行，表示该程序<code>代码段（.text）</code><br>第二行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code><br>第三行地址范围显示权限为可读可写， 表示该程序的<code>数据段（.data）</code>刚才变量a地址就在这段地址范围内<br>第四行地址范围是<code>堆空间（.heap段）</code>,malloc的内存就会处于这段<br>第5行地址范围是<code>栈空间（.stack段）</code>,局部变量处于这段<br>p表示<code>private</code>, s表示<code>share</code>, 再来看一个使用动态库的进程，比如bash进程：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/6.png" alt="image"></p>
<h1><span id="2-mmap-nei-he-tai-de-miao-shu">2 mmap内核态的描述</span><a href="#2-mmap-nei-he-tai-de-miao-shu" class="header-anchor">#</a></h1><h2><span id="2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct">2.1 进程结构体(task_struct)和进程地址空间(mm_struct)</span><a href="#2-1-jin-cheng-jie-gou-ti-task-struct-he-jin-cheng-di-zhi-kong-jian-mm-struct" class="header-anchor">#</a></h2><p>每一个 APP对应了很多虚拟地址空间，比如栈空间，堆空间，数据段，代码段等,也叫做进程地址空间<code>（mm_strcut）</code>。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/7.png" alt="image"></p>
<p>因此在内核里都有一个 tast_struct，这个结构体中保存有内存信息：mm_struct。而虚拟地址、物理地址的映射关系保存在页目录表中：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/8.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每个 APP 在内核中都有一个 task_struct 结构体，它用来描述一个进程；</span><br><span class="line"><span class="number">2.</span> 每个 APP 都要占据内存，在 task_struct 中用 mm_struct 来管理进程占用的内存；</span><br><span class="line"><span class="number">3.</span> 内存有虚拟地址、物理地址，mm_struct 中用 mmap 来描述虚拟地址，</span><br><span class="line">用 pgd 来描述对应的物理地址。(注意：pgd，Page Global Directory，页目录)</span><br><span class="line"><span class="number">4.</span> 每个 APP 都有一系列的 VMA：virtual memory，即mmap会指向vm_area_struct, </span><br><span class="line">比如 APP 含有代码段、数据段、BSS 段、栈等等，还有共享库。这些单元会保存在内存里，</span><br><span class="line">它们的地址空间不同，权限不同(代码段是只读的可运行的、数据段可读可写)，内核用一系列的 vm_area_struct 来描述它们。</span><br><span class="line"><span class="number">6.</span> vm_area_struct 中的 vm_start、vm_end 是虚拟地址。</span><br><span class="line"><span class="number">7.</span> vm_area_struct 中虚拟地址如何映射到物理地址去？ 每一个 APP 的虚拟地址可能相同，</span><br><span class="line">物理地址不相同，这些对应关系保存在 pgd 中。</span><br></pre></td></tr></table></figure>

<h3><span id="2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu">2.1.1 vm_area_struct虚拟内存区域</span><a href="#2-1-1-vm-area-struct-xu-ni-nei-cun-qu-yu" class="header-anchor">#</a></h3><p>每个进程有一个<code>task_struct</code>和一个<code>mm_struct</code>, 其中<code>mm_struct</code>中的mmap对应<code>vm_area_struct</code>虚拟内存区域：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/9.png" alt="image-20240816222839173"></p>
<p>可以看到<code>mm_struct</code>每一段都对应一块<code>vm_area_struct</code>。</p>
<h1><span id="3-ye-biao-ying-she">3 页表映射</span><a href="#3-ye-biao-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/10.png" alt="image"></p>
<p>页表是存在<code>ddr</code>中的一段连续地址空间，页表里面存放了要映射的物理地址集合，页表分为很多个页表项。<br>ARM 架构支持一级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址可以找到第 1 个页表，从第 1 个页表里就可以知道这个虚拟地址对应的物理地址。一级页表里地址映射的最小单位是 1M。<br>ARM 架构还支持二级页表映射，也就是说 MMU 根据 CPU 发来的虚拟地址先找到第 1 个页表，从第 1 个页表里就可以知道第 2 级页表在哪里；再取出第 2 级页表，从第 2 个页表里才能确定这个虚拟地址对应的物理地址。二级页表地址映射的最小单位有 4K、1K，Linux 使用 4K。<br><strong>一级页表项里的内容，决定了它是指向一块物理内存，还是指问二级页表</strong>，一个页表项格式如下图：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/11.png" alt="image"></p>
<h2><span id="3-1-yi-ji-ye-biao-ying-she">3.1 一级页表映射</span><a href="#3-1-yi-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>arm32系统中，一个页表项占4个byte, 32bit,它分为一级页表项和二级页表项，通过<code>bit[1:0]</code>区分，一级页表项保存有物理地址，用<code>bit[31:20]</code> 共12位表示段基地址，有1M物理内存。比如cpu发出虚拟地址<code>0x12345678</code>, MMU通过<code>bit[31:20]</code>发现为0x123,也就是从第0x123个页表项中找到<code>Section Base Address</code>, 比如第0个页表项中物理及地址为<code>0x8000,0000</code>， 那么第0x123个页表项目物理基地址就是<code>0x123 * 1M + 0x8000,0000</code>,也就是<code>0x9230,0000</code>, 因为每一个一级页表项物理内存大小为1M.<br>段内偏移是 <code>0x45678</code>，那么最终通过一级页表映射最终映射到物理地址就为<code>0x0x9230,0000 + 0x45678</code>,也就是<code>0x9234,5678</code>。<br><code>Section Base Address</code>的数量为多少呢？一共12bit，也就是4096个，每一个1级页表项大小为1M, 因此总共可表示4G。对于 32 位的系统，虚拟地址空间有 4G，<code>4G/1M=4096</code>。所以一级页表要映射整个 4G 空间的话，刚好需要 4096 个页表项。<br>所以 CPU 要访问虚拟地址 0x12345678 时，实际上访问的是 0x81045678 的物理地址。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/12.png" alt="image"></p>
<h2><span id="3-2-er-ji-ye-biao-ying-she">3.2 二级页表映射</span><a href="#3-2-er-ji-ye-biao-ying-she" class="header-anchor">#</a></h2><p>一级页表项每项有1M空间, 一级页表映射时是吧虚拟地址的1M映射到物理地址的1M连续空间，但有时我们的程序没有那么大，显然用1M太浪费空间。 那么引入二级页表映射来映射更小的块，对于二级页表，每一个页可以是1K, 4K，64K， Linux系统一般使用4K, 对应<code>Small Page</code>, 64K对应的是大页（<code>Large Page</code>）, 1K对应的是Tine Page(一般很少用)。<br><strong>二级页表映射过程：</strong><br>首先设置好一级页表、二级页表，并且把一级页表的首地址告诉 MMU,比如<code>0x8000,0000</code>。<br>二级页表首先也是要经过一级页表映射，用<code>bit[31:20] </code>共12位表示段基地址，找到对应的一级页表项比如<code>0x123</code>项，通过这一项里面的<code>bit[1:0]</code>发现它是一个二级页表项（注意不再是取出1M的物理地址），然后根据二级页表项的<code>bit[19：12]</code>这8位得到二级页表是得到索引0x45,表示为第0x45个二级页表项。从这个二级页表项中取出里面的物理地址，比如为addr。<br>二级页表格式如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/13.png" alt="image"></p>
<p>可以看到里面含有<code>64k(Large Page) 4k(Small Page）</code>或 <code>1K(Tine) </code>物理空间的基地址<code> page base addr</code>，假设从第0x45个二级页表项取出的物理地址为<code>0x8188,9000</code>。然后<code>offset=0x678</code>, 那么它跟 <code>vaddr[11:0] </code>组 合 得 到 物 理 地 址 ：<code> 0x8188,9000 + 0x678 = 0x8188,9678</code>，所以 CPU 要访问虚拟地址 <code>0x1234,5678 </code>时，实际上访问的是<code>0x8188,9678</code>的物理地址, 根据<code>bit[1:0]</code>得到映射的大小为<code>4K(linux Small Page)</code>。假如这里不使用二级页表映射，理论去计算对应物理地址则会是<code>0x8180,0000</code>往后1M内存，显然浪费了。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/14.png" alt="image"></p>
<h1><span id="4-mmap-han-shu-diao-yong-guo-cheng">4 mmap函数调用过程</span><a href="#4-mmap-han-shu-diao-yong-guo-cheng" class="header-anchor">#</a></h1><p>从上面内存映射的过程可以知道，要给 APP 新开劈一块虚拟内存，并且让它指向某块内核buffer，我们要做这些事：</p>
<ol>
<li>得到一个 <code>vm_area_struct</code>，它表示 APP 的一块虚拟内存空间：<br> 很 幸 运 ， APP 调 用 mmap 系 统 函 数 时 ， 内 核 就 帮 我 们 构 造 了 一 个<code>vm_area_stuct </code>结构体。里面含有虚拟地址的地址范围、权限，属性。</li>
<li>确定物理地址：<br> 你想映射某个内核 buffer，你需要得到它的物理地址，这得由你提供。</li>
<li>给<code>vm_area_struct</code>和物理地址建立映射关系</li>
</ol>
<p>比如APP 里调用 mmap 时，导致的内核相关函数调用过程如下：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/15.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p>可以传入一个addr虚拟地址，需要用户自己malloc。也可以将addr设置为NULL, 让linux内核帮你产生一段内存映射，返回虚拟地址给你。<br>内核得到可用的虚拟地址后会分配一个<code>vm_area_struct</code>, 用来描述一块虚拟地址空间，里面有这块虚拟地址空间的起始地址、结束地址、权限信息。最后会调用驱动里面的mmap函数，参数为刚刚分配的<code>vm_area_sruct</code>。<br>那么需要再驱动程序实现mmap函数，主要包括：</p>
<ol>
<li>提供物理地址</li>
<li>设置属性，<code>cache，buffer</code></li>
<li>给<code>vm_area_stuct</code>和物理地址建立映射</li>
</ol>
<h2><span id="4-1-vm-area-struct-miao-shu">4.1 vm_area_struct描述</span><a href="#4-1-vm-area-struct-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/16.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct describes a virtual memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task. A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">					   within vm_mm. */</span></span><br><span class="line">	<span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">	 * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">	 * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">	 * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">	<span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Access permissions of this VMA.</span></span><br><span class="line"><span class="comment">	 * See vmf_insert_mixed_prot() for discussion.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br></pre></td></tr></table></figure>

<p>它表示的是一块连续的虚拟地址空间区域，给进程使用的，地址空间范围是<code>0~3G</code>，对应的物理页面都可以是不连续的.<br>主要成员有起始地址、结束地址、权限信息，属性信息。<br><code>vm_flags:</code>可读，可写，可执行权限，私有，共享等权限</p>
<p>常用<strong>vm_flags</strong>访问权限的取值说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">VM_READ：可读</span><br><span class="line">VM_WRITE：可写</span><br><span class="line">VM_EXEC：可执行</span><br><span class="line">VM_SHARD：可多进程之间共享</span><br><span class="line">VM_IO：可映射至设备 IO 空间</span><br><span class="line">VM_RESERVED：内存区域不可被换出</span><br><span class="line">VM_SEQ_READ：内存区域可能被顺序访问</span><br><span class="line">VM_RAND_READ：内存区域可能被随机访问</span><br></pre></td></tr></table></figure>

<p><code>vm_pgoff:</code>是否使用cache? 是否使用buffer？</p>
<h2><span id="4-2-yin-ru-cache-he-buffer">4.2 引入cache和buffer</span><a href="#4-2-yin-ru-cache-he-buffer" class="header-anchor">#</a></h2><p>使用<code> mmap</code> 时，需要有<code>cache、 buffer</code>的知识。下图是 CPU 和内存之间的关系，有<code> cache、 buffer</code>(写缓冲器)。 Cache 是一块高速内存；写缓冲器相当于一个 FIFO，可以把多个写操作集合起来一次写入内存。<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/17.png" alt="image"></p>
<h3><span id="4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing">4.2.1 引入时间局部性和空间局部性</span><a href="#4-2-1-yin-ru-shi-jian-ju-bu-xing-he-kong-jian-ju-bu-xing" class="header-anchor">#</a></h3><p>当程序运行时有<code>“局部性原理”</code>，这又分为<strong>时间局部性、空间局部性</strong>。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	a++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间局部性：</strong><br>a++在很短的时间内被重复写了100次，与此同时i也被访问了100次，像这种在某个时间点访问了存储器的特定位置，反复地访问这个位置被称为<code>“时间局部性”</code>。<br><strong>空间局部性：</strong><br>访问变量a的同时也访问了它周围临近变量i, 像这种访问了存储器的特定位置，很可能在不久的将来访问它附近的位置被称作<code>”空间局部性“</code>， 那么为什么不用<code>buffer or cache</code>把它一次性访问完呢？<br>根据<code>“局部性原理”</code>，引入 <code>cache</code>和<code>buffer</code>。</p>
<h4><span id="4-2-1-1-cache-miss-he-cache-hit">4.2.1.1 cache miss和cache hit</span><a href="#4-2-1-1-cache-miss-he-cache-hit" class="header-anchor">#</a></h4><p>读数据：</p>
<ol>
<li>要读取内存指定addr处的数据时，先看看cache中有没有addr的数据，如果有则直接从cache返回数据，这一过程叫做<code>cache命中(cache hit)</code>。</li>
<li>假如cache中没有该addr的数据，触发<code>cache缺失 (cache miss)</code>, 那么会从addr读一段连续数据进去，注意：它不是仅仅读入一个数据，而是读入一行数据(cache line)。</li>
<li>那么CPU 短时间内很可能会再次用到甚至多次用到这个 addr 的数据或者周围临近的数据，那么就可以直接从cache快速的获取数据。这样<strong>弥补了时间和空间上的”局部性“</strong>。</li>
</ol>
<p>写数据：</p>
<ol>
<li>CPU 写数据时，可以<strong>直接写内存</strong>，这很慢；也可以先把数据<strong>写入 cache</strong>，这很快。</li>
<li>cache 中的数据终究是要写入内存的啊，这有 2 种写策略:<br> <strong>2.1 写通(write through)：</strong><br> ◆ 数据要同时写入 cache 和内存，所以 cache 和内存中的数据保持一致，但是它的效率很低。能改进吗？可以！使用“<strong>写缓冲器</strong>”：cache 大哥，你把数据给我就可以了，我来慢慢写，保证帮你写完。<br> ◆ 有些写缓冲器有“<strong>写合并</strong>”的功能，比如 CPU 执行了 4 条写指令：写第 0、 1、 2、 3 个字节，每次写 1 字节；写缓冲器会把这 4 个写操作合并成一个写操作：写 word。对于内存来说，这没什么差别，但是对于硬件寄存器，这就有可能导致问题。<br> ◆ 所以对于寄存器操作，不会启动 buffer 功能；对于内存操作，比如 LCD 的显存，可以启用 buffer 功能(cpu直接用<code>write buffer</code>进行操作<code>frame buffer内存</code>)<br> <strong>2.2 写回(write back)：</strong><br> ◆ 新数据只是写入<code> cache</code>，不会立刻写入内存， <code>cache </code>和内存中的数据并不一致。<br> ◆ 新数据写入 cache 时，这一行 cache 被标为<code>“脏” (dirty)</code>；当cache 不够用时，才需要把脏的数据写入内存。</li>
</ol>
<p>对内存或者变量进行写操作可以使用写回功能，可以大幅提高效率。但是要注意 cache 和内存中的数据很可能不一致。这在很多时间要小心处理：比如 CPU 产生了新数据， DMA 把数据从内存搬到网卡，这时候就要 CPU 执行命令先把新数据从 cache 刷到内存。反过来也是一样的， DMA 从网卡得过了新数据存在内存里， CPU 读数据之前先把 cache中的数据丢弃。下图举例说明哪些硬件可以用或者不能用cache：<br><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/18.png" alt="image"></p>
<p>是否使用 cache、是否使用 buffer，就有 4 种组合(位于<code>arch\arm\include\asm\pgtable-2level.h</code>：</p>
<p><img src="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/19.png" alt="image"></p>
<p>以s3c2440芯片为例，上面 4 种组合对应下表中的各项：</p>
<table>
<thead>
<tr>
<th>是否启用 cache</th>
<th>是否启用 buffer</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件；写操作通过 buffer 实现， CPU 不等待操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td><code>Cached, write-through mode (WT)</code>，写通    ①读：<code>cache hit</code>时从 cahce 读数据； <code>cache miss </code>时已入一行数据到 cache；②写：通过 buffer 实现， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><code>Cached, write-back mode (WB)</code>，写回    ①读：<code> cache hit</code> 时从 cahce 读数据；<code>cache miss</code>时已入一行数据到 cache；②写：通过 buffer 实现， <code>cache hit</code> 时新数据不会到达硬件，而是在 cahce 中被标为 “脏”； <code>cache miss</code> 时，通过 buffer写入硬件， CPU 不等待写操作完成， CPU 会马上执行下一条指令</td>
</tr>
</tbody></table>
<p>◼ 第 1 种是不使用 cache 也不使用 buffer，读写时都直达硬件，这适合寄存器的读写。<br>◼ 第 2 种是不使用 cache 但是使用 buffer，写数据时会用 buffer 进行优化，可能会有<code>“写合并”</code>，这适合显存的操作。因为对显存很少有读操作，基本都是写操作，而写操作即使被“合并”也没有关系。<br>◼ 第 3 种是使用 cache 不使用 buffer，就是<code>“ write through”</code>，适用于只读设备：在读数据时用 cache 加速，基本不需要写。<br>◼ 第 4 种是既使用 cache 又使用 buffer，适合一般的内存读写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E6%9C%BA%E5%88%B6/" data-id="cm0dxg14n004ndsuf9rq1g9la" data-title="字符设备驱动-mmap机制" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/08/16/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-mmap%E9%A9%B1%E5%8A%A8%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          字符设备驱动-mmap驱动应用实例
        
      </div>
    </a>
  
  
    <a href="/2024/08/11/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-9-%E4%B8%AD%E6%96%AD%E5%AD%90%E7%B3%BB%E7%BB%9F-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B%E5%8C%96-threaded_irq/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">字符设备驱动-9-中断子系统-中断线程化-threaded_irq</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag">Linux设备驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E6%B1%87%E7%BC%96/" rel="tag">arm汇编</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arm%E8%A3%B8%E6%9C%BA/" rel="tag">arm裸机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/boot%E5%90%AF%E5%8A%A8/" rel="tag">boot启动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ini%E8%A7%A3%E6%9E%90/" rel="tag">ini解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="tag">linux内存管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%86%85%E6%A0%B8/" rel="tag">linux内核</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" rel="tag">linux嵌入式环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" rel="tag">linux系统构建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" rel="tag">mipi图像处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/uboot/" rel="tag">uboot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" rel="tag">中断体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" rel="tag">字符编码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" rel="tag">存储驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" rel="tag">开源插件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" rel="tag">时钟体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" rel="tag">裸机外设驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" rel="tag">通信协议</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" style="font-size: 20px;">Linux设备驱动</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/arm%E6%B1%87%E7%BC%96/" style="font-size: 10px;">arm汇编</a> <a href="/tags/arm%E8%A3%B8%E6%9C%BA/" style="font-size: 18.33px;">arm裸机</a> <a href="/tags/boot%E5%90%AF%E5%8A%A8/" style="font-size: 16.67px;">boot启动</a> <a href="/tags/ini%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">ini解析</a> <a href="/tags/linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 10px;">linux内存管理</a> <a href="/tags/linux%E5%86%85%E6%A0%B8/" style="font-size: 15.83px;">linux内核</a> <a href="/tags/linux%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" style="font-size: 17.5px;">linux嵌入式环境搭建</a> <a href="/tags/linux%E7%B3%BB%E7%BB%9F%E6%9E%84%E5%BB%BA/" style="font-size: 19.17px;">linux系统构建</a> <a href="/tags/mipi%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.67px;">mipi图像处理</a> <a href="/tags/uboot/" style="font-size: 15px;">uboot</a> <a href="/tags/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB/" style="font-size: 15.83px;">中断体系</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/" style="font-size: 10px;">字符编码</a> <a href="/tags/%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8/" style="font-size: 10.83px;">存储驱动</a> <a href="/tags/%E5%BC%80%E6%BA%90%E6%8F%92%E4%BB%B6/" style="font-size: 12.5px;">开源插件</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/" style="font-size: 10px;">时钟体系</a> <a href="/tags/%E8%A3%B8%E6%9C%BA%E5%A4%96%E8%AE%BE%E9%A9%B1%E5%8A%A8/" style="font-size: 16.67px;">裸机外设驱动</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/" style="font-size: 14.17px;">通信协议</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">August 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">July 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-input%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-input子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/25/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-I2C%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-I2C子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-%E5%86%85%E6%A0%B8led%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-内核led子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/18/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-pinctrl子系统</a>
          </li>
        
          <li>
            <a href="/2024/08/17/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8-gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/">字符设备驱动-gpio子系统</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>