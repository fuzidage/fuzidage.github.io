<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>I2C-SMBus协议和I2C Tool</title>
    <url>/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-smbus-xie-yi">1 SMBus协议</a><ul>
<li><a href="#1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji">1.1 SMBus 是 I2C 协议的一个子集</a></li>
<li><a href="#1-2-he-i2c-xie-yi-te-xing-dui-bi">1.2 和I2C协议特性对比</a></li>
<li><a href="#1-3-smbus-shu-ju-ge-shi">1.3 SMBus数据格式</a><ul>
<li><a href="#1-3-1-smbus-quick-command">1.3.1 SMBus Quick Command</a></li>
<li><a href="#1-3-2-smbus-receive-byte">1.3.2 SMBus Receive Byte</a></li>
<li><a href="#1-3-3-smbus-send-byte">1.3.3 SMBus Send Byte</a></li>
<li><a href="#1-3-4-smbus-read-byte">1.3.4 SMBus Read Byte</a></li>
<li><a href="#1-3-5-smbus-read-word">1.3.5 SMBus Read Word</a></li>
<li><a href="#1-3-6-smbus-write-byte">1.3.6 SMBus Write Byte</a></li>
<li><a href="#1-3-7-smbus-write-word">1.3.7 SMBus Write Word</a></li>
<li><a href="#1-3-8-smbus-block-read">1.3.8 SMBus Block Read</a></li>
<li><a href="#1-3-8-smbus-block-write">1.3.8 SMBus Block Write</a></li>
<li><a href="#1-3-9-smbus-block-write-block-read-process-call">1.3.9 SMBus Block Write - Block Read Process Call</a></li>
<li><a href="#1-3-10-packet-error-checking-pec">1.3.10 Packet Error Checking (PEC)</a></li>
</ul>
</li>
<li><a href="#1-4-i2c-shu-ju-ge-shi">1.4 I2C数据格式</a><ul>
<li><a href="#1-4-1-i2c-block-read">1.4.1 I2C Block Read</a></li>
<li><a href="#1-4-2-i2c-block-write">1.4.2 I2C Block Write</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-i2c-tools">2 I2C Tools</a><ul>
<li><a href="#2-1-i2c-kong-zhi-qi-kuang-jia">2.1 I2C控制器框架</a></li>
<li><a href="#2-2-i2c-shu-ju-jie-gou">2.2 i2c数据结构</a><ul>
<li><a href="#2-2-1-i2c-adapter">2.2.1 i2c_adapter</a></li>
<li><a href="#2-2-3-i2c-algorithm">2.2.3 i2c_algorithm</a></li>
<li><a href="#2-3-4-i2c-device-i2c-client">2.3.4 I2c_device&#x2F;I2c_client</a></li>
<li><a href="#2-3-5-i2c-msg">2.3.5 i2c_msg</a></li>
</ul>
</li>
<li><a href="#2-3-i2c-tools-yi-zhi">2.3 I2C-Tools移植</a><ul>
<li><a href="#2-3-1-yuan-ma-xia-zai">2.3.1 源码下载</a></li>
<li><a href="#2-3-2-gong-ju-lian-pei-zhi">2.3.2 工具链配置</a></li>
<li><a href="#2-3-3-bian-yi">2.3.3 编译</a></li>
</ul>
</li>
<li><a href="#2-4-i2c-tools-shi-yong">2.4 I2C Tools使用</a><ul>
<li><a href="#2-4-1-i2cdetect-i2c-jian-ce">2.4.1 i2cdetect: I2C 检测</a></li>
<li><a href="#2-4-2-i2cget-i2c-du-smbus-xie-yi">2.4.2 i2cget:  I2C 读（SMBus协议）</a></li>
<li><a href="#2-4-3-i2cset-i2c-xie-smbus-xie-yi">2.4.3 i2cset: I2C 写（SMBus协议）</a></li>
<li><a href="#2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi">2.4.4 i2ctransfer：I2C传输（I2C协议）</a></li>
</ul>
</li>
<li><a href="#2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi">2.5 I2C-Tools 访问 I2C 设备的方式</a><ul>
<li><a href="#2-5-1-shu-ju-chuan-shu-fang-shi">2.5.1 数据传输方式</a><ul>
<li><a href="#2-5-1-1-shi-yong-i2c-fang-shi">2.5.1.1 使用I2C方式</a></li>
<li><a href="#2-5-1-2-shi-yong-smbus-fang-shi">2.5.1.2 使用SMBus方式</a></li>
<li><a href="#2-5-1-3-zhi-jie-shi-yong-read-write-fang-shi">2.5.1.3 直接使用read()&#x2F;write()方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-smbus-xie-yi">1 SMBus协议</span><a href="#1-smbus-xie-yi" class="header-anchor">#</a></h1><h2><span id="1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji">1.1 SMBus 是 I2C 协议的一个子集</span><a href="#1-1-smbus-shi-i2c-xie-yi-de-yi-ge-zi-ji" class="header-anchor">#</a></h2><p>SMBus: System Management Bus，系统管理总线。SMBus 最初的目的是为智能电池、充电电池、其他微控制器之间的通信链路而定义的。SMBus 也被用来连接各种设备，包括电源相关设备，系统传感器，EEPROM 通讯设备等等。SMBus 为系统和电源管理这样的任务提供了一条控制总线，使用 SMBus 的系 统，设备之间发送和接收消息都是通过 SMBus，而不是使用单独的控制线，这样可以节省设备的管脚数。</p>
<p>SMBus 是基于 I2C 协议的，SMBus 要求更严格，SMBus 是 I2C 协议的子集。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/1.png" alt="img"></p>
<h2><span id="1-2-he-i2c-xie-yi-te-xing-dui-bi">1.2 和I2C协议特性对比</span><a href="#1-2-he-i2c-xie-yi-te-xing-dui-bi" class="header-anchor">#</a></h2><p>SMBus 有哪些更严格的要求？跟一般的 I2C 协议有哪些差别？</p>
<ol>
<li>VDD 的极限值不一样<br>　　1.1 I2C 协议：范围很广，甚至讨论了高达 12V 的情况<br>　　　　　　　　　　　　　　　　1.2 SMBus：1.8V~5V</li>
<li>速率更高<br>　　I2C 协议：时钟频率最小值无限制，Clock Stretching 时长也没有限制<br>　　　　　　　　　　　　　　　　SMBus：时钟频率最小值是 10KHz，Clock Stretching 的最大时间值也有限制</li>
<li>地址回应(Address Acknowledge)：一个 I2C 设备接收到它的设备地址后， 是否必须发出回应信号？<br>　　I2C 协议：没有强制要求必须发出回应信号<br>　　　　　　　　　　　　　　　　SMBus：强制要求必须发出回应信号，这样对方才知道该设备的状态： busy，failed，或是被移除了</li>
<li>SMBus 协议明确了数据的传输格式<br>　　I2C 协议：它只定义了怎么传输数据，但是并没有定义数据的格式，这完全由设备来定义<br>　　　　　　　　　　　　　　　　SMBus：定义了几种数据格式</li>
<li><code>REPEATED START Condition(重复发出 S 信号)</code><br>　　比如读 EEPROM 时，涉及 2 个操作：<br>　　　　　　　　　　　　　　​	 把存储地址发给设备<br>　　　　　　　　　　　　　　​	 读数据<br>　　　　　　　　　　　　　　在写、读之间，可以不发出 P 信号，而是直接发出 S 信号：这个 S 信号就是<br>　　　　　　　　　　　　　　<code>REPEATED START</code></li>
</ol>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/2.png" alt="img"></p>
<h2><span id="1-3-smbus-shu-ju-ge-shi">1.3 SMBus数据格式</span><a href="#1-3-smbus-shu-ju-ge-shi" class="header-anchor">#</a></h2><p>下面文档中的 Functionality flag 是 Linux 的某个 I2C 控制器驱动所支持的功能。比如 Functionality flag: I2C_FUNC_SMBUS_QUICK，表示需要I2C 控制器支持 SMBus Quick Command。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">symbols(符号)：</span><br><span class="line">S (<span class="number">1</span> bit) : Start <span class="title function_">bit</span><span class="params">(开始位)</span></span><br><span class="line">　<span class="title function_">Sr</span> <span class="params">(<span class="number">1</span> bit)</span> : 重复的开始位</span><br><span class="line">　<span class="title function_">P</span> <span class="params">(<span class="number">1</span> bit)</span> : Stop <span class="title function_">bit</span><span class="params">(停止位)</span></span><br><span class="line">　R/W# <span class="params">(<span class="number">1</span> bit)</span> : Read/Write bit. Rd equals 1, Wr equals 0.<span class="params">(读写位)</span></span><br><span class="line">　A, <span class="title function_">N</span> <span class="params">(<span class="number">1</span> bit)</span> : Accept and reverse accept bit.<span class="params">(回应位)</span></span><br><span class="line">　<span class="title function_">Address</span><span class="params">(<span class="number">7</span> bits)</span>: I2C 7 bit address. Note that this can be expanded as usual to get a 10 bit I2C address.<span class="params">(地址位，<span class="number">7</span> 位地址)</span></span><br><span class="line">　Command <span class="title function_">Code</span> <span class="params">(<span class="number">8</span> bits)</span>: Command byte, a data byte which often selects a <span class="keyword">register</span> on the device.<span class="params">(命令字节，一般用来选择芯片内部的寄存器)</span></span><br><span class="line">  Data <span class="title function_">Byte</span> <span class="params">(<span class="number">8</span> bits)</span>: A plain data byte. Sometimes, I write DataLow, DataHigh <span class="keyword">for</span> 16 bit data.<span class="params">(数据字节，<span class="number">8</span> 位；如果是 <span class="number">16</span> 位数据的话，用 <span class="number">2</span> 个字节来表示：DataLow、DataHigh)</span></span><br><span class="line">　<span class="title function_">Count</span> <span class="params">(<span class="number">8</span> bits)</span>: A data byte containing the length of a block operation.<span class="params">(在 block 操作总，表示数据长度)</span></span><br><span class="line">　[..]: Data sent by I2C device, as opposed to data sent by the host adapter.<span class="params">(中括号表示 I2C 设备发送的数据，没有中括号表示 host adapter 发送的数据)</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-3-1-smbus-quick-command">1.3.1 SMBus Quick Command</span><a href="#1-3-1-smbus-quick-command" class="header-anchor">#</a></h3><p>只是用来发送一位数据：R&#x2F;W#本意是用来表示读或写，但是在 SMBus 里可以用来表示其他含义。比如某些开关设备，可以根据这一位来决定是打开还是关闭.</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/3.png" alt="img"></p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_QUICK</strong></p>
<h3><span id="1-3-2-smbus-receive-byte">1.3.2 SMBus Receive Byte</span><a href="#1-3-2-smbus-receive-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/4.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_byte()</code>。读取一个字节，Host adapter 接收到一个字节后不需要发出回应信号(上图中 N 表示不回应)。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE</strong></p>
<h3><span id="1-3-3-smbus-send-byte">1.3.3 SMBus Send Byte</span><a href="#1-3-3-smbus-send-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/5.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_byte()</code>。发送一个字节。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE</strong></p>
<h3><span id="1-3-4-smbus-read-byte">1.3.4 SMBus Read Byte</span><a href="#1-3-4-smbus-read-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/6.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_byte_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再读取一个字节的数据。上面介绍的 SMBus Receive Byte 是不发送 Comand，直接读取数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_BYTE_DATA</strong></p>
<h3><span id="1-3-5-smbus-read-word">1.3.5 SMBus Read Word</span><a href="#1-3-5-smbus-read-word" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/7.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_word_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再读取 2 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_WORD_DATA</strong></p>
<h3><span id="1-3-6-smbus-write-byte">1.3.6 SMBus Write Byte</span><a href="#1-3-6-smbus-write-byte" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/8.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_byte_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BYTE_DATA</strong></p>
<h3><span id="1-3-7-smbus-write-word">1.3.7 SMBus Write Word</span><a href="#1-3-7-smbus-write-word" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/9.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_word_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_WORD_DATA</strong></p>
<h3><span id="1-3-8-smbus-block-read">1.3.8 SMBus Block Read</span><a href="#1-3-8-smbus-block-read" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/10.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_read_block_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发起度操作：</p>
<p>　　1. 先读到一个字节(Block Count)，表示后续要读的字节数<br>　　1.  然后读取全部数据</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_BLOCK_DATA</strong></p>
<h3><span id="1-3-8-smbus-block-write">1.3.8 SMBus Block Write</span><a href="#1-3-8-smbus-block-write" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/11.png" alt="img"></p>
<p>I2C-tools 中的函数：<code>i2c_smbus_write_block_data()</code>。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的 Byte Conut(表示后续要发出的数据字节数)，最后发出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_BLOCK_DATA</strong></p>
<h3><span id="1-3-9-smbus-block-write-block-read-process-call">1.3.9 SMBus Block Write - Block Read Process Call</span><a href="#1-3-9-smbus-block-write-block-read-process-call" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/12.png" alt="img"></p>
<p>先写一块数据，再读一块数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_BLOCK_PROC_CALL</strong></p>
<h3><span id="1-3-10-packet-error-checking-pec">1.3.10 Packet Error Checking (PEC)</span><a href="#1-3-10-packet-error-checking-pec" class="header-anchor">#</a></h3><p>PEC 是一种错误校验码，如果使用 PEC，那么在 P 信号之前，数据发送方要发送一个字节的 PEC 码(它是 CRC-8 码)。以 SMBus Send Byte 为例，下图中，一个未使用 PEC，另一个使用 PEC：(一般很少使用)</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/13.png" alt="img"></p>
<h2><span id="1-4-i2c-shu-ju-ge-shi">1.4 I2C数据格式</span><a href="#1-4-i2c-shu-ju-ge-shi" class="header-anchor">#</a></h2><h3><span id="1-4-1-i2c-block-read">1.4.1 I2C Block Read</span><a href="#1-4-1-i2c-block-read" class="header-anchor">#</a></h3><p>在一般的 I2C 协议中，也可以连续读出多个字节。它跟 SMBus Block Read 的差别在于设备发出的第 1 个数据不是长度 N，如下图所示：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/14.png" alt="img"></p>
<p>I2C-tools 中的函数：&#96;i2c_smbus_read_i2c_block_data()。先发出 Command Code(它一般表示芯片内部的寄存器地址)，直接读出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_READ_I2C_BLOCK</strong></p>
<h3><span id="1-4-2-i2c-block-write">1.4.2 I2C Block Write</span><a href="#1-4-2-i2c-block-write" class="header-anchor">#</a></h3><p>在一般的 I2C 协议中，也可以连续发出多个字节。它跟 SMBus Block Write 的差别在于发出的第 1 个数据不是长度 N，如下图所示：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/15.png" alt="img"></p>
<p>I2C-tools 中的函数：i2c_smbus_write_i2c_block_data()。先发出 Command Code(它一般表示芯片内部的寄存器地址)，再发出 1 个字节的 data，最后发出全部数据。</p>
<p><strong>Functionality flag: I2C_FUNC_SMBUS_WRITE_I2C_BLOCK</strong></p>
<h1><span id="2-i2c-tools">2 I2C Tools</span><a href="#2-i2c-tools" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-kong-zhi-qi-kuang-jia">2.1 I2C控制器框架</span><a href="#2-1-i2c-kong-zhi-qi-kuang-jia" class="header-anchor">#</a></h2><p>APP 访问硬件肯定是需要驱动程序的，对于 I2C 设备，linux内核提供了默认的驱动程序 drivers&#x2F;i2c&#x2F;i2c-dev.c，通过它可以直接使用下面的 I2C 控制器驱动程序来 访问 I2C 设备。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/16.png" alt="img"></p>
<h2><span id="2-2-i2c-shu-ju-jie-gou">2.2 i2c数据结构</span><a href="#2-2-i2c-shu-ju-jie-gou" class="header-anchor">#</a></h2><h3><span id="2-2-1-i2c-adapter">2.2.1 i2c_adapter</span><a href="#2-2-1-i2c-adapter" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/17.png" alt="img"></p>
<p>i2c_adapter 表示一个 I2C BUS，或称为 I2C Controller，里面有 2 个重要的成员：</p>
<ol>
<li>nr：第几个 I2C BUS(I2C Controller)</li>
<li>i2c_algorithm，里面有该 I2C BUS 的传输函数，用来收发 I2C 数据</li>
</ol>
<p>怎么表示 I2C Controller , 一个芯片里可能有多个 I2C Controller，比如第 0 个、第 1 个、……</p>
<h3><span id="2-2-3-i2c-algorithm">2.2.3 i2c_algorithm</span><a href="#2-2-3-i2c-algorithm" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/18.png" alt="img"></p>
<h3><span id="2-3-4-i2c-device-x2f-i2c-client">2.3.4 I2c_device&#x2F;I2c_client</span><a href="#2-3-4-i2c-device-x2f-i2c-client" class="header-anchor">#</a></h3><p>一个 I2C Device，一定有设备地址， 那它连接在哪个 I2C Controller 上，即对应的 i2c_adapter 是什么。</p>
<p>使用 i2c_client 来表示一个 I2C Device。</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/19.png" alt="img"></p>
<h3><span id="2-3-5-i2c-msg">2.3.5 i2c_msg</span><a href="#2-3-5-i2c-msg" class="header-anchor">#</a></h3><p>在上面的i2c_algorithm结构体中可以看到要传输的数据被称为：i2c_msg</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/20.png" alt="img"></p>
<p>flags： 用来表示传输方向：bit 0 等于 I2C_M_RD 表示 读，bit 0 等于 0 表示写。一个 i2c_msg 要么是读，要么是写<br>举例：设备地址为 0x50 的 EEPROM，要读取它里面存储地址为 0x10 的一个字节， 应该构造几个 i2c_msg？<br>要构造 2 个 i2c_msg :</p>
<ol>
<li><p>第一个 i2c_msg 表示写操作，把要访问的存储地址 0x10 发给设备</p>
</li>
<li><p>第二个 i2c_msg 表示读操作,并且返回读出的数据</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">　　<span class="comment">//例如：</span></span><br><span class="line">　　u8 data_addr = <span class="number">0x10</span>;</span><br><span class="line">　　i8 data;</span><br><span class="line">　　<span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msgs</span>[2];</span></span><br><span class="line">　　</span><br><span class="line">　　msgs[<span class="number">0</span>].addr = <span class="number">0x50</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].flags = <span class="number">0</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].len = <span class="number">1</span>;</span><br><span class="line">　　msgs[<span class="number">0</span>].buf = &amp;data_addr;</span><br><span class="line">　　msgs[<span class="number">1</span>].addr = <span class="number">0x50</span>;</span><br><span class="line">　　msgs[<span class="number">1</span>].flags = I2C_M_RD;</span><br><span class="line">　　msgs[<span class="number">1</span>].len = <span class="number">1</span>;</span><br><span class="line">　　msgs[<span class="number">1</span>].buf = &amp;data;</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-i2c-tools-yi-zhi">2.3 I2C-Tools移植</span><a href="#2-3-i2c-tools-yi-zhi" class="header-anchor">#</a></h2><h3><span id="2-3-1-yuan-ma-xia-zai">2.3.1 源码下载</span><a href="#2-3-1-yuan-ma-xia-zai" class="header-anchor">#</a></h3><p><a href="https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/">https://mirrors.edge.kernel.org/pub/software/utils/i2c-tools/</a></p>
<h3><span id="2-3-2-gong-ju-lian-pei-zhi">2.3.2 工具链配置</span><a href="#2-3-2-gong-ju-lian-pei-zhi" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueab ihf_sdk-buildroot/bin</span><br></pre></td></tr></table></figure>

<h3><span id="2-3-3-bian-yi">2.3.3 编译</span><a href="#2-3-3-bian-yi" class="header-anchor">#</a></h3><p>修改 I2C-Tools 的 Makefile 指定交叉编译工具链</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC ?= gcc</span><br><span class="line">AR ?= ar</span><br><span class="line">STRIP ?= strip</span><br></pre></td></tr></table></figure>

<p>改为(指定交叉编译工具链前缀, 去掉问号)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC = $(CROSS_COMPILE)gcc</span><br><span class="line">AR = $(CROSS_COMPILE)ar</span><br><span class="line">STRIP = $(CROSS_COMPILE)strip</span><br></pre></td></tr></table></figure>

<p>在 Makefile 中，“?&#x3D;”在第一次设置变量时才会起效果，如果之前设置过该变量，则不会起效果。</p>
<p>执行 make 时，是动态链接，需要把 libi2c.so 也放到单板上。 想静态链接的话，执行：make USE_STATIC_LIB&#x3D;1</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/21.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/22.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/23.png" alt="img"></p>
<h2><span id="2-4-i2c-tools-shi-yong">2.4 I2C Tools使用</span><a href="#2-4-i2c-tools-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-4-1-i2cdetect-i2c-jian-ce">2.4.1 i2cdetect: I2C 检测</span><a href="#2-4-1-i2cdetect-i2c-jian-ce" class="header-anchor">#</a></h3><p>&#x2F;&#x2F; 列出当前的 I2C Adapter(或称为 I2C Bus、I2C Controller)</p>
<p><code>i2cdetect -l</code></p>
<p>&#x2F;&#x2F; 打印某个 I2C Adapter 的 Functionalities, I2CBUS 为 0、1、2 等整数 i2cdetect -F I2CBUS</p>
<p>&#x2F;&#x2F; 看看有哪些 I2C 设备, I2CBUS 为 0、1、2 等整数</p>
<p><code>i2cdetect -y -a I2CBUS</code></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/24.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/25.png" alt="img"></p>
<h3><span id="2-4-2-i2cget-i2c-du-smbus-xie-yi">2.4.2 i2cget:  I2C 读（SMBus协议）</span><a href="#2-4-2-i2cget-i2c-du-smbus-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/26.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/27.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/28.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/29.png" alt="img"></p>
<h3><span id="2-4-3-i2cset-i2c-xie-smbus-xie-yi">2.4.3 i2cset: I2C 写（SMBus协议）</span><a href="#2-4-3-i2cset-i2c-xie-smbus-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/30.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/31.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/32.png" alt="img"></p>
<h3><span id="2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi">2.4.4 i2ctransfer：I2C传输（I2C协议）</span><a href="#2-4-4-i2ctransfer-i2c-chuan-shu-i2c-xie-yi" class="header-anchor">#</a></h3><p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/33.png" alt="img"></p>
<p>使用示例：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/34.png" alt="img"></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/35.png" alt="img"></p>
<p>从i2c总线0，往0x1e设备地址，写2个字节，第一个字节写入寄存器地址0，第二个字节表示往寄存器0地址写入0x4。<br>从i2c总线0，往0x1e设备地址，写2个字节，第一个字节写入寄存器地址0，第二个字节表示往寄存器0地址写入0x3。<br>从i2c总线0，往0x1e设备地址，写1个字节，写入寄存器地址0xc表示要读0xc里面的值，再从0xc读2个字节。</p>
<h2><span id="2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi">2.5 I2C-Tools 访问 I2C 设备的方式</span><a href="#2-5-i2c-tools-fang-wen-i2c-she-bei-de-fang-shi" class="header-anchor">#</a></h2><p>I2C-Tools 可以通过 <strong>SMBus</strong> 来访问 I2C 设备，也可以使用一般的 <strong>I2C 协议</strong> 来访问 I2C 设备。 使用一句话概括 I2C 传输：APP 通过 I2C Controller 与 I2C Device 传 输数据.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Open(<span class="string">&quot;dev/i2c-0&quot;</span>);</span><br><span class="line">ioctl(file, I2C_SLAVE, address);</span><br></pre></td></tr></table></figure>

<p>如果该设备已经有了对应的设备驱动程序，则返回失败。</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(file, I2C_SLAVE_FORCE, address);</span><br></pre></td></tr></table></figure>

<p> 如果该设备已经有了对应的设备驱动程序但是还是想通过 i2c-dev 驱 动来访问它，则使用这个 ioctl 来指定 I2C 设备地址。</p>
<h3><span id="2-5-1-shu-ju-chuan-shu-fang-shi">2.5.1 数据传输方式</span><a href="#2-5-1-shu-ju-chuan-shu-fang-shi" class="header-anchor">#</a></h3><h4><span id="2-5-1-1-shi-yong-i2c-fang-shi">2.5.1.1 使用I2C方式</span><a href="#2-5-1-1-shi-yong-i2c-fang-shi" class="header-anchor">#</a></h4><p><code>ioctl(file, I2C_RDWR, &amp;rdwr)；(使用I2C方式)</code></p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/36.png" alt="img"></p>
<p>该结构体表示一个或者多个i2c_msg。</p>
<p>示例代码：i2ctransfer.c</p>
<p>以<code>i2ctransfer -f -y 0 w1@0x1e 0xe r2</code>为例：</p>
<p>流程如下：</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/37.png" alt="img"></p>
<p>构造i2c_rdwr_ioctl_data结构，要用2个i2c_msg结构，第一个表示写入0xe寄存器地址给设备，第二个表示要从0xe寄存器读出2个字节。</p>
<h4><span id="2-5-1-2-shi-yong-smbus-fang-shi">2.5.1.2 使用SMBus方式</span><a href="#2-5-1-2-shi-yong-smbus-fang-shi" class="header-anchor">#</a></h4><p><code>ioctl(file, I2C_SMBUS, &amp;args) ；（使用SMBus方式）</code></p>
<p>示例代码：i2cget.c i2cset.c</p>
<p><img src="/2024/05/26/I2c-SMBus%E5%8D%8F%E8%AE%AE%E5%92%8CI2C-Tools/38.png" alt="img"></p>
<h4><span id="2-5-1-3-zhi-jie-shi-yong-read-x2f-write-fang-shi">2.5.1.3 直接使用read()&#x2F;write()方式</span><a href="#2-5-1-3-zhi-jie-shi-yong-read-x2f-write-fang-shi" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gc2053_read_register</span><span class="params">(VI_PIPE ViPipe, <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ret, data;</span><br><span class="line">        CVI_U8 buf[<span class="number">8</span>];</span><br><span class="line">        CVI_U8 idx = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (g_fd[ViPipe] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CVI_FAILURE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gc2053_addr_byte == <span class="number">2</span>)</span><br><span class="line">                buf[idx++] = (addr &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add address byte 0</span></span><br><span class="line">        buf[idx++] = addr &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        ret = write(g_fd[ViPipe], buf, gc2053_addr_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_WRITE error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        ret = read(g_fd[ViPipe], buf, gc2053_data_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_READ error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// pack read back data</span></span><br><span class="line">        data = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (gc2053_data_byte == <span class="number">2</span>) &#123;</span><br><span class="line">                data = buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">                data += buf[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data = buf[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        syslog(LOG_DEBUG, <span class="string">&quot;i2c r 0x%x = 0x%x\n&quot;</span>, addr, data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gc2053_write_register</span><span class="params">(VI_PIPE ViPipe, <span class="type">int</span> addr, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">        CVI_U8 idx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        CVI_U8 buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g_fd[ViPipe] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (gc2053_addr_byte == <span class="number">1</span>) &#123;</span><br><span class="line">                buf[idx] = addr &amp; <span class="number">0xff</span>;</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gc2053_data_byte == <span class="number">1</span>) &#123;</span><br><span class="line">                buf[idx] = data &amp; <span class="number">0xff</span>;</span><br><span class="line">                idx++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = write(g_fd[ViPipe], buf, gc2053_addr_byte + gc2053_data_byte);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                CVI_TRACE_SNS(CVI_DBG_ERR, <span class="string">&quot;I2C_WRITE error!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> CVI_FAILURE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ret = read(g_fd[ViPipe], buf, gc2053_addr_byte + gc2053_data_byte);</span><br><span class="line">        <span class="comment">//syslog(LOG_DEBUG, &quot;i2c w 0x%x 0x%x\n&quot;, addr, data);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>开源插件</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-dynamic_debug</title>
    <url>/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dynamic-debug-jie-shao">1 dynamic_debug介绍</a><ul>
<li><a href="#1-1-kai-qi-dynamic-debug">1.1 开启dynamic debug</a></li>
<li><a href="#1-2-dynamic-debug-shi-yong">1.2 dynamic debug使用</a><ul>
<li><a href="#1-2-1-kai-qi-dynamic-debug">1.2.1 开启dynamic debug</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-dev-err-dev-info-dev-warn">2 dev_err&#x2F;dev_info&#x2F;dev_warn</a></li>
<li><a href="#3-ke-bian-can-shu-hong">3 可变参数宏</a></li>
<li><a href="#4-mo-kuai-da-yin-deng-ji-kong-zhi">4 模块打印等级控制</a><ul>
<li><a href="#4-1-an-zhao-da-yin-deng-ji-kong-zhi">4.1 按照打印等级控制</a></li>
<li><a href="#4-2-jing-que-kong-zhi-da-yin-deng-ji">4.2 精确控制打印等级</a></li>
</ul>
</li>
<li><a href="#5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi">5 用户态模块打印等级控制</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dynamic-debug-jie-shao">1 dynamic_debug介绍</span><a href="#1-dynamic-debug-jie-shao" class="header-anchor">#</a></h1><p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/1.png" alt="img"></p>
<p>这里强烈推荐驱动开发者用这种方式输出log。linux kernel space中有<code>pr_debug</code>及<code>dev_dbg</code>来使用dynamic debug。可以看到当用户<code>define DEBUG</code>后，<code>pr_debug</code>和<code>dev_dbg</code>就等于printk的KERN_DEBUG级别输出了；否则什么也不打印。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/2.png" alt="img"></p>
<h2><span id="1-1-kai-qi-dynamic-debug">1.1 开启dynamic debug</span><a href="#1-1-kai-qi-dynamic-debug" class="header-anchor">#</a></h2><p>要使用dynamic_debug需要在kernel的defconfig中开启。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_DEBUG_FS=y</span><br><span class="line">CONFIG_DYNAMIC_DEBUG=y</span><br></pre></td></tr></table></figure>

<p>用menuconfig去配置的话如下图：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/3.png" alt="img"></p>
<h2><span id="1-2-dynamic-debug-shi-yong">1.2 dynamic debug使用</span><a href="#1-2-dynamic-debug-shi-yong" class="header-anchor">#</a></h2><p>编译好image后，需要挂载debugfs（不挂载的话将不会创建debugfs,那么<code>/sys/kernel/debug/</code>下是空的）。</p>
<p>修改etc&#x2F;fstab文件，追加下面这段字符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nodev      /sys/kernel/debug debugfs   defaults    0   0</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/4.png" alt="img"></p>
<p>可以用<code>cat /sys/kernel/debug/dynamic_debug/control | grep xxx.c</code>来查看自己想要查看的log所在文件有没有包含进去。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/5.png" alt="img"></p>
<p>这里可以看到该文件所有用<code>dev_dbg()</code>打印出的讯息。</p>
<p>那如果不开启<code>CONFIG_DYNAMIC_DEBUG</code>，将不会产生<code>/sys/kernel/debug/dynamic_debug</code>目录, 是不能进行动态打印的。</p>
<h3><span id="1-2-1-kai-qi-dynamic-debug">1.2.1 开启dynamic debug</span><a href="#1-2-1-kai-qi-dynamic-debug" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;module cvi_mipi_rx +p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span><br><span class="line">echo <span class="string">&quot;file cvi_vip_cif.c +p&quot;</span> &gt;/sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>这两种方式都是开dynamic debug，第一种是对模块开启，第二种只对文件开启。</p>
<p>下面举一个栗子：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/6.png" alt="img"></p>
<p>开启之后，可以看到<code>dev_dbg()</code>打印的log都会输出。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/7.png" alt="img"></p>
<p>反之，关闭<code>dynamic debug</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;module cvi_mipi_rx -p&quot;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span><br><span class="line">echo <span class="string">&quot;file cvi_vip_cif.c -p&quot;</span> &gt;/sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>除了上面的两种方式还有一种可以只开启某个function:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;func _init_resource +p&quot; &gt; /sys/kernel/debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/8.png" alt="img"></p>
<h1><span id="2-dev-err-x2f-dev-info-x2f-dev-warn">2 dev_err&#x2F;dev_info&#x2F;dev_warn</span><a href="#2-dev-err-x2f-dev-info-x2f-dev-warn" class="header-anchor">#</a></h1><p>在Linux驱动代码中，有大量的调试信息，那么推荐使用<code>dev_err/dev_info/dev_warn</code>这一系列函数族。这一系列函数族定义在<code>include/linux/device.h</code>。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/9.png" alt="img"></p>
<p>其实这些函数族本质上和下面printk.h中的定义也是完全一致的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_emerg(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_alert(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_crit(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_err(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warning(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warn pr_warning</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_notice(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>

<p>下图是示例，可以看到err级别以下的log没有打印，那么设置printk的控制台级别可以把对应的log输出到console。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/10.png" alt="img"></p>
<p>如何设置printk console level可以看上一篇<a href="https://fuzidage.github.io/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/">Linux日志管理-printk和dmesg</a>。</p>
<h1><span id="3-ke-bian-can-shu-hong">3 可变参数宏</span><a href="#3-ke-bian-can-shu-hong" class="header-anchor">#</a></h1><p>##__VA_ARGS__表示可变参数宏，可以用来传递多个参数，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> my_dbg(fmt, ...) \</span></span><br><span class="line"><span class="meta">do &#123;                        \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;[%s] [%d] &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__);\</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> my_dbg(fmt...) \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">　　printf(<span class="string">&quot;[%s] [%d] &quot;</span>, __func__, __LINE__); \</span></span><br><span class="line"><span class="meta">　　printf(fmt); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *name = <span class="string">&quot;robin&quot;</span>; <span class="type">int</span> age = <span class="number">18</span>; my_dbg(<span class="string">&quot;this is a test. name:%s, age:%d\n&quot;</span>, name, age);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/11.png" alt="img"></p>
<p>那和下面这种写法呢本质上是完全一样的。</p>
<p><img src="/2024/06/08/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-dynamic-debug/12.png" alt="img"></p>
<h1><span id="4-mo-kuai-da-yin-deng-ji-kong-zhi">4 模块打印等级控制</span><a href="#4-mo-kuai-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h1><h2><span id="4-1-an-zhao-da-yin-deng-ji-kong-zhi">4.1 按照打印等级控制</span><a href="#4-1-an-zhao-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _VPSS_DEBUG_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _VPSS_DEBUG_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/debugfs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> u32 vpss_log_lv;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ERR        1   <span class="comment">/* error conditions                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_WARN       2   <span class="comment">/* warning conditions                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_NOTICE     3   <span class="comment">/* normal but significant condition     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_INFO       4   <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_DEBUG      5   <span class="comment">/* debug-level messages                 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_CVI_LOG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= vpss_log_lv) &#123; \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (level == CVI_DBG_ERR) \</span></span><br><span class="line"><span class="meta">                pr_err(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_WARN) \</span></span><br><span class="line"><span class="meta">                pr_warn(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_NOTICE) \</span></span><br><span class="line"><span class="meta">                pr_notice(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_INFO) \</span></span><br><span class="line"><span class="meta">                pr_info(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == CVI_DBG_DEBUG) \</span></span><br><span class="line"><span class="meta">                printk(KERN_DEBUG <span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _VPSS_DEBUG_H_ */</span></span></span><br></pre></td></tr></table></figure>

<p>当级别高于DBG,即可输出高于DBG的所有级别打印。</p>
<h2><span id="4-2-jing-que-kong-zhi-da-yin-deng-ji">4.2 精确控制打印等级</span><a href="#4-2-jing-que-kong-zhi-da-yin-deng-ji" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u32 vi_log_lv;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">vi_msg_pri</span> &#123;</span></span><br><span class="line">    VI_ERR        = <span class="number">0x1</span>,</span><br><span class="line">    VI_WARN        = <span class="number">0x2</span>,</span><br><span class="line">    VI_NOTICE    = <span class="number">0x4</span>,</span><br><span class="line">    VI_INFO        = <span class="number">0x8</span>,</span><br><span class="line">    VI_DBG        = <span class="number">0x10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vi_pr(level, fmt, arg...) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (vi_log_lv &amp; level) &#123; \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (level == VI_ERR) \</span></span><br><span class="line"><span class="meta">                pr_err(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_WARN) \</span></span><br><span class="line"><span class="meta">                pr_warn(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_NOTICE) \</span></span><br><span class="line"><span class="meta">                pr_notice(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_INFO) \</span></span><br><span class="line"><span class="meta">                pr_info(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">            <span class="keyword">else</span> <span class="keyword">if</span> (level == VI_DBG) \</span></span><br><span class="line"><span class="meta">                pr_debug(<span class="string">&quot;%s:%d(): &quot;</span> fmt, __func__, __LINE__, ## arg); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>可以随意开启任意级别打印，比如只开启DBG，只开启WARN。</p>
<h1><span id="5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi">5 用户态模块打印等级控制</span><a href="#5-yong-hu-tai-mo-kuai-da-yin-deng-ji-kong-zhi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CVI_S32 *log_levels;</span><br><span class="line">CVI_CHAR <span class="type">const</span> *log_name[<span class="number">8</span>] = &#123;</span><br><span class="line">    (CVI_CHAR *)<span class="string">&quot;EMG&quot;</span>, (CVI_CHAR *)<span class="string">&quot;ALT&quot;</span>, (CVI_CHAR *)<span class="string">&quot;CRI&quot;</span>, (CVI_CHAR *)<span class="string">&quot;ERR&quot;</span>,</span><br><span class="line">    (CVI_CHAR *)<span class="string">&quot;WRN&quot;</span>, (CVI_CHAR *)<span class="string">&quot;NOT&quot;</span>, (CVI_CHAR *)<span class="string">&quot;INF&quot;</span>, (CVI_CHAR *)<span class="string">&quot;DBG&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CVI_S32 <span class="title function_">CVI_LOG_SetLevelConf</span><span class="params">(LOG_LEVEL_CONF_S *pstConf)</span></span><br><span class="line">&#123;</span><br><span class="line">    log_levels[pstConf-&gt;enModId] = pstConf-&gt;s32Level;</span><br><span class="line">    <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CVI_S32 <span class="title function_">CVI_LOG_GetLevelConf</span><span class="params">(LOG_LEVEL_CONF_S *pstConf)</span></span><br><span class="line">&#123;</span><br><span class="line">    pstConf-&gt;s32Level = log_levels[pstConf-&gt;enModId];</span><br><span class="line">    <span class="keyword">return</span> CVI_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (C) Cvitek Co., Ltd. 2019-2020. All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * File Name: include/cvi_debug.h</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CVI_DEBUG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CVI_DEBUG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cvi_common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* End of #ifdef __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Debug Config</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_GDB_NO 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_GDB <span class="string">&quot;n&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_SUPPORT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_ALL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CVI_LOG_TRACE_LEVEL 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_EMERG      0   <span class="comment">/* system is unusable                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ALERT      1   <span class="comment">/* action must be taken immediately     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_CRIT       2   <span class="comment">/* critical conditions                  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_ERR        3   <span class="comment">/* error conditions                     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_WARN       4   <span class="comment">/* warning conditions                   */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_NOTICE     5   <span class="comment">/* normal but significant condition     */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_INFO       6   <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_DBG_DEBUG      7   <span class="comment">/* debug-level messages                 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LOG_LEVEL_CONF_S</span> &#123;</span></span><br><span class="line">    MOD_ID_E  enModId;</span><br><span class="line">    CVI_S32   s32Level;</span><br><span class="line">    <span class="type">char</span>   cModName[<span class="number">16</span>];</span><br><span class="line">&#125; LOG_LEVEL_CONF_S;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_PRINT printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic ignored <span class="string">&quot;-Wunused-variable&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> CVI_S32 * log_levels;</span><br><span class="line"><span class="keyword">extern</span> CVI_CHAR <span class="type">const</span> *log_name[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC diagnostic pop</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GENERATE_STRING(STRING) (#STRING),</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> MOD_STRING[] = FOREACH_MOD(_GENERATE_STRING);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_GET_MOD_NAME(id) (id &lt; CVI_ID_BUTT)? MOD_STRING[id] : <span class="string">&quot;UNDEF&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* #ifdef CVI_DEBUG */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CVI_LOG_TRACE_SUPPORT</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_ASSERT(expr)                               \</span></span><br><span class="line"><span class="meta">    do &#123;                                                   \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!(expr)) &#123;                                 \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;\nASSERT at:\n&quot;</span>                \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Function : %s\n&quot;</span>            \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Line No. : %d\n&quot;</span>            \</span></span><br><span class="line"><span class="meta">                   <span class="string">&quot;  &gt;Condition: %s\n&quot;</span>,           \</span></span><br><span class="line"><span class="meta">                   __func__, __LINE__, #expr);     \</span></span><br><span class="line"><span class="meta">            _exit(-1);                             \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FPGA_PORTING</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt, ...)            \</span></span><br><span class="line"><span class="meta">    do &#123;                                                   \</span></span><br><span class="line"><span class="meta">        CVI_S32 LogLevel = (log_levels == NULL) ? CONFIG_CVI_LOG_TRACE_LEVEL : log_levels[enModId];      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= LogLevel)           \</span></span><br><span class="line"><span class="meta">            syslog(LOG_LOCAL5|level, <span class="string">&quot;[%s-%s] &quot;</span> fmt, CVI_GET_MOD_NAME(enModId), log_name[level],    \</span></span><br><span class="line"><span class="meta">                ##__VA_ARGS__);           \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt, ...) \</span></span><br><span class="line"><span class="meta">        printf(fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_ASSERT(expr)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CVI_TRACE(level, enModId, fmt...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_ID(level, id, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, id, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_LOG(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_LOG, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_SYS(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_SYS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VB(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VB, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_SNS(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VI(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VPSS(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VPSS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_VO(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_VO, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_GDC(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_GDC, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_RGN(level, fmt, ...)                                           \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_RGN, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_MISC(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_SYS, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_DWA(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_DWA, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_DPU(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_DPU, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_STITCH(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_STITCH, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVI_TRACE_HDMI(level, fmt, ...)  \</span></span><br><span class="line"><span class="meta">        CVI_TRACE(level, CVI_ID_HDMI, <span class="string">&quot;%s:%d:%s(): &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* __CVI_COMM_SYS_H__ */</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-printk和demsg</title>
    <url>/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-printk">1 printk</a><ul>
<li><a href="#1-1-ri-zhi-ji-bie">1.1 日志级别</a></li>
<li><a href="#1-2-kong-zhi-tai-ji-bie">1.2 <strong>控制台级别</strong></a></li>
<li><a href="#1-3-xiu-gai-kong-zhi-tai-ji-bie">1.3 修改控制台级别</a></li>
<li><a href="#1-4-printk-dai-shi-jian-chuo-xun-xi">1.4 printk带时间戳讯息</a></li>
<li><a href="#1-5-printk-di-ceng-shi-xian">1.5 printk底层实现</a><ul>
<li><a href="#1-5-1-ming-ling-xing-can-shu-console">1.5.1 命令行参数console</a></li>
<li><a href="#1-5-2-console-qu-dong-zhu-ce-guo-cheng">1.5.2 console驱动注册过程</a><ul>
<li><a href="#1-5-2-1-chu-li-ming-ling-xing-can-shu">1.5.2.1 处理命令行参数</a></li>
<li><a href="#1-5-2-2-register-console">1.5.2.2 register_console</a></li>
<li><a href="#1-5-2-3-dev-console">1.5.2.3 &#x2F;dev&#x2F;console</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-6-nei-he-xin-xi-de-zao-qi-da-yin">1.6 内核信息的早期打印</a><ul>
<li><a href="#1-6-1-early-printk">1.6.1 early_printk</a></li>
<li><a href="#1-6-2-earlycon">1.6.2 earlycon</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-prink-h-jie-shao">2 prink.h介绍</a></li>
<li><a href="#3-dmesg-ming-ling">3 dmesg命令</a><ul>
<li><a href="#3-1-proc-kmsg">3.1 &#x2F;proc&#x2F;kmsg</a></li>
<li><a href="#3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao">3.2 修改内核日志缓冲区大小</a></li>
<li><a href="#3-3-dmesg">3.3 dmesg</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-printk">1 printk</span><a href="#1-printk" class="header-anchor">#</a></h1><p>printk函数主要做两件事情：第一件就是将信息记录到log中，而第二件事就是调用控制台驱动来将信息输出。printk的相关函数定义在linux&#x2F;printk.h。</p>
<h2><span id="1-1-ri-zhi-ji-bie">1.1 日志级别</span><a href="#1-1-ri-zhi-ji-bie" class="header-anchor">#</a></h2><p>printk需要设置日志级别，用来控制printk打印的这条信息是否在终端上显示的，当printk设置的日志级别高于控制台级别时，printk要打印的信息才会在控制台打印出来。</p>
<p>内核日志一共有8种级别:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_EMERG        <span class="string">&quot;&lt;0&gt;&quot;</span>        <span class="comment">/* system is unusable                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_ALERT        <span class="string">&quot;&lt;1&gt;&quot;</span>        <span class="comment">/* action must be taken immediately        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_CRIT        <span class="string">&quot;&lt;2&gt;&quot;</span>        <span class="comment">/* critical conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_ERR        <span class="string">&quot;&lt;3&gt;&quot;</span>        <span class="comment">/* error conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_WARNING        <span class="string">&quot;&lt;4&gt;&quot;</span>        <span class="comment">/* warning conditions                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_NOTICE        <span class="string">&quot;&lt;5&gt;&quot;</span>        <span class="comment">/* normal but significant condition        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_INFO        <span class="string">&quot;&lt;6&gt;&quot;</span>        <span class="comment">/* informational                        */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        KERN_DEBUG        <span class="string">&quot;&lt;7&gt;&quot;</span>        <span class="comment">/* debug-level messages                        */</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="1-2-kong-zhi-tai-ji-bie">1.2 <strong>控制台级别</strong></span><a href="#1-2-kong-zhi-tai-ji-bie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MINIMUM_CONSOLE_LOGLEVEL 1 <span class="comment">/*可以使用的最小日志级别*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CONSOLE_LOGLEVEL 7 <span class="comment">/*默认的控制台级别*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MESSAGE_LOGLEVEL 4 <span class="comment">/* 默认的日志级别 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,<span class="comment">/*控制台日志级别：优先级高于该值的消息将被打印至控制台*/</span></span><br><span class="line">    DEFAULT_MESSAGE_LOGLEVEL,<span class="comment">/*缺省的消息日志级别：将用该优先级来打印没有优先级的消息*/</span></span><br><span class="line">    MINIMUM_CONSOLE_LOGLEVEL,<span class="comment">/*最低的控制台日志级别：控制台日志级别可被设置的最小值（最高优先级）*/</span></span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,<span class="comment">/*缺省的控制台日志级别：控制台日志级别的缺省值*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> console_loglevel (console_printk[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_message_loglevel (console_printk[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minimum_console_loglevel (console_printk[2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_console_loglevel (console_printk[3])</span></span><br></pre></td></tr></table></figure>

<p>使用命令 <code>cat /proc/sys/kernel/printk </code>来查看这四个值:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/1.png" alt="img"></p>
<p>结果显示了 <em>current</em>, <em>default</em>, <em>minimum</em> 和 <em>boot-time-default</em> 日志级别。</p>
<p>其中的 4 4 1 7，分别对应与：<code>console_loglevel、default_message_loglevel、minimum_console_loglevel、default_console_loglevel</code></p>
<p><strong>default_message_loglevel</strong>：</p>
<p>缺省时的消息日志级别，因此当printk未指定优先级时，将以该默认级别输出，也就是<code>DEFAULT_MESSAGE_LOGLEVEL =4， 对应KERN_WARNING。</code></p>
<p>也就是说<code>printk(&quot;hello world\n&quot;);就表示printk(KERN_WARNING &quot;hello world\n&quot;);</code></p>
<p>那如果我们将控制台级别设成&lt;4，如：</p>
<p><code>echo 3 &gt; /proc/sys/kernel/printk</code></p>
<p>那么<code>printk(&quot;hello world\n&quot;);</code>就无法输出到控制台。</p>
<table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">字符串</th>
<th align="left">别名函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">KERN_EMERG</td>
<td align="left">“0”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_emerg"><code>pr_emerg()</code></a></td>
</tr>
<tr>
<td align="left">KERN_ALERT</td>
<td align="left">“1”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_alert"><code>pr_alert()</code></a></td>
</tr>
<tr>
<td align="left">KERN_CRIT</td>
<td align="left">“2”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_crit"><code>pr_crit()</code></a></td>
</tr>
<tr>
<td align="left">KERN_ERR</td>
<td align="left">“3”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_err"><code>pr_err()</code></a></td>
</tr>
<tr>
<td align="left">KERN_WARNING</td>
<td align="left">“4”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_warn"><code>pr_warn()</code></a></td>
</tr>
<tr>
<td align="left">KERN_NOTICE</td>
<td align="left">“5”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_notice"><code>pr_notice()</code></a></td>
</tr>
<tr>
<td align="left">KERN_INFO</td>
<td align="left">“6”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_info"><code>pr_info()</code></a></td>
</tr>
<tr>
<td align="left">KERN_DEBUG</td>
<td align="left">“7”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_debug"><code>pr_debug()</code></a> and <a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_devel"><code>pr_devel()</code></a> 若定义了DEBUG</td>
</tr>
<tr>
<td align="left">KERN_DEFAULT</td>
<td align="left">“”</td>
<td align="left">KERN_WARNING</td>
</tr>
<tr>
<td align="left">KERN_CONT</td>
<td align="left">“c”</td>
<td align="left"><a href="https://www.kernel.org/doc/html/next/core-api/printk-basics.html#c.pr_cont"><code>pr_cont()</code></a></td>
</tr>
</tbody></table>
<h2><span id="1-3-xiu-gai-kong-zhi-tai-ji-bie">1.3 修改控制台级别</span><a href="#1-3-xiu-gai-kong-zhi-tai-ji-bie" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;n&quot;</span> &gt; /proc/sys/kernel/printk</span><br><span class="line"><span class="comment">#Eg:</span></span><br><span class="line"><span class="built_in">echo</span> 8 &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>



<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/2.png" alt="img"></p>
<p>另一种方式，使用 <code>dmesg</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg -n 8</span><br></pre></td></tr></table></figure>

<p>此时所有的printk日志级别都会被输出到控制台，如下图所示:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk ( KERN_EMERG <span class="string">&quot;Hello, EMERG.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_ALERT <span class="string">&quot;Hello, ALERT.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_CRIT <span class="string">&quot;Hello, CRIT.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_ERR <span class="string">&quot;Hello, ERR.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_WARNING <span class="string">&quot;Hello, WARNING.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_NOTICE <span class="string">&quot;Hello, NOTICE.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_INFO <span class="string">&quot;Hello, INFO.\n&quot;</span> ) ;</span><br><span class="line">printk ( KERN_DEBUG <span class="string">&quot;Hello, DEBUG.\n&quot;</span> ) ;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/3.png" alt="img"></p>
<p>再来一种方法，修改bootargs：</p>
<p>Uboot中修改<code>console=ttyS0,115200</code>改为<code>loglevel=7 console=ttyS0,115200</code>,表示设置内核的<code>console_loglevel 值=7</code>，开机<code>cat /proc/sys/kernel/printk</code>，可以看到控制台级别被设置成了7:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/4.png" alt="img"></p>
<h2><span id="1-4-printk-dai-shi-jian-chuo-xun-xi">1.4 printk带时间戳讯息</span><a href="#1-4-printk-dai-shi-jian-chuo-xun-xi" class="header-anchor">#</a></h2><p>make menuconfig开启如下:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/5.png" alt="img"></p>
<h2><span id="1-5-printk-di-ceng-shi-xian">1.5 printk底层实现</span><a href="#1-5-printk-di-ceng-shi-xian" class="header-anchor">#</a></h2><p>源码位于<code>kernel\printk\printk.c</code>。</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk</span><br><span class="line">    <span class="comment">// linux 4.9: kernel/printk/internal.h</span></span><br><span class="line">    <span class="comment">// linux 5.4: kernel/printk/printk_safe.c</span></span><br><span class="line">    vprintk_func </span><br><span class="line">        <span class="title function_">vprintk_default</span><span class="params">(fmt, args)</span>;</span><br><span class="line">            vprintk_emit</span><br><span class="line">                vprintk_store <span class="comment">// 把要打印的信息保存在log_buf中</span></span><br><span class="line">                    log_output</span><br><span class="line">                <span class="title function_">preempt_disable</span><span class="params">()</span>;</span><br><span class="line">                <span class="keyword">if</span> (console_trylock_spinning())</span><br><span class="line">                    console_unlock();</span><br><span class="line">                preempt_enable();</span><br><span class="line">console_unlock</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(;;)</span> &#123;</span><br><span class="line">        msg = log_from_idx(console_idx);</span><br><span class="line">        <span class="keyword">if</span> (suppress_message_printing(msg-&gt;level)) &#123;</span><br><span class="line">            <span class="comment">/* 如果消息的级别数值大于console_loglevel, 则不打印此信息 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        printk_safe_enter_irqsave(flags);</span><br><span class="line">        call_console_drivers(ext_text, ext_len, text, len);</span><br><span class="line">        printk_safe_exit_irqrestore(flags);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/7.png" alt="img"></p>
<h3><span id="1-5-1-ming-ling-xing-can-shu-console">1.5.1 命令行参数console</span><a href="#1-5-1-ming-ling-xing-can-shu-console" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* IMX6ULL */</span><br><span class="line">[root@100ask:~]<span class="comment"># cat /proc/cmdline</span></span><br><span class="line">console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</span><br></pre></td></tr></table></figure>

<p>命令行信息可以来自设备树或者环境变量:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    chosen &#123;</span><br><span class="line">                bootargs = <span class="string">&quot;console=ttymxc1,115200&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>修改环境变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入IMX6ULL的UBOOT */</span></span><br><span class="line">=&gt; print mmcargs</span><br><span class="line">mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</span><br><span class="line">=&gt; print console</span><br><span class="line">console=ttymxc0</span><br><span class="line">=&gt; print baudrate</span><br><span class="line">baudrate=<span class="number">115200</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-5-2-console-qu-dong-zhu-ce-guo-cheng">1.5.2 console驱动注册过程</span><a href="#1-5-2-console-qu-dong-zhu-ce-guo-cheng" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>    name[<span class="number">16</span>];  <span class="comment">// name为&quot;ttyXXX&quot;，在cmdline中用&quot;console=ttyXXX0&quot;来匹配</span></span><br><span class="line">    <span class="comment">// 输出函数</span></span><br><span class="line">    <span class="type">void</span>    (*write)(<span class="keyword">struct</span> console *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">unsigned</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span>        (*read)(<span class="keyword">struct</span> console *, <span class="type">char</span> *, <span class="type">unsigned</span>);</span><br><span class="line">    <span class="comment">// APP访问/dev/console时通过这个函数来确定是哪个(index)设备</span></span><br><span class="line">    <span class="comment">// 举例:</span></span><br><span class="line">    <span class="comment">// a. cmdline中&quot;console=ttymxc1&quot;</span></span><br><span class="line">    <span class="comment">// b. 则注册对应的console驱动时：console-&gt;index = 1</span></span><br><span class="line">    <span class="comment">// c. APP访问/dev/console时调用&quot;console-&gt;device&quot;来返回这个index</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">tty_driver</span> *(*<span class="title">device</span>)(<span class="keyword">struct</span> <span class="title">console</span> *<span class="title">co</span>, <span class="title">int</span> *<span class="title">index</span>);</span></span><br><span class="line">    <span class="type">void</span>    (*unblank)(<span class="type">void</span>);</span><br><span class="line">    <span class="comment">// 设置函数, 可设为NULL</span></span><br><span class="line">    <span class="type">int</span>        (*setup)(<span class="keyword">struct</span> console *, <span class="type">char</span> *);</span><br><span class="line">    <span class="comment">// 匹配函数, 可设为NULL</span></span><br><span class="line">    <span class="type">int</span>        (*match)(<span class="keyword">struct</span> console *, <span class="type">char</span> *name, <span class="type">int</span> idx, <span class="type">char</span> *options); </span><br><span class="line">    <span class="type">short</span>    flags;</span><br><span class="line">    <span class="comment">// 哪个设备用作console: </span></span><br><span class="line">    <span class="comment">// a. 可以设置为-1, 表示由cmdline确定</span></span><br><span class="line">    <span class="comment">// b. 也可以直接指定</span></span><br><span class="line">    <span class="type">short</span>    index;</span><br><span class="line">    <span class="comment">// 常用: CON_PRINTBUFFER</span></span><br><span class="line">    <span class="type">int</span>        cflag;</span><br><span class="line">    <span class="type">void</span>    *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>     <span class="title">console</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4><span id="1-5-2-1-chu-li-ming-ling-xing-can-shu">1.5.2.1 处理命令行参数</span><a href="#1-5-2-1-chu-li-ming-ling-xing-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__setup(<span class="string">&quot;console=&quot;</span>, console_setup);</span><br><span class="line">console=ttymxc0,<span class="number">115200</span>  console=ttyVIRT0</span><br></pre></td></tr></table></figure>

<p>处理u-boot通过dts传给内核的cmdline参数，比如bootparam参数。</p>
<p>对于这两个”console&#x3D;xxx”就会调用console_setup函数两次，构造得到2个数组项:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">console_cmdline</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>    name[<span class="number">16</span>];            <span class="comment">/* Name of the driver        */</span></span><br><span class="line">    <span class="type">int</span>    index;                <span class="comment">/* Minor dev. to use        */</span></span><br><span class="line">    <span class="type">char</span>    *options;            <span class="comment">/* Options for the driver   */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_A11Y_BRAILLE_CONSOLE</span></span><br><span class="line">    <span class="type">char</span>    *brl_options;            <span class="comment">/* Options for braille driver */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console_cmdline</span> <span class="title">console_cmdline</span>[<span class="title">MAX_CMDLINECONSOLES</span>];</span></span><br></pre></td></tr></table></figure>

<p>在cmdline中，最后的”console&#x3D;xxx”就是”selected_console”(被选中的console，对应&#x2F;dev&#x2F;console)：</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/8.png" alt="img"></p>
<h4><span id="1-5-2-2-register-console">1.5.2.2 register_console</span><a href="#1-5-2-2-register-console" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uart_add_one_port</span><br><span class="line">    uart_configure_port</span><br><span class="line">        <span class="title function_">register_console</span><span class="params">(port-&gt;cons)</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/fuzidage/p/18203864">Linux下Uart子系统驱动 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h4><span id="1-5-2-3-x2f-dev-x2f-console">1.5.2.3 &#x2F;dev&#x2F;console</span><a href="#1-5-2-3-x2f-dev-x2f-console" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_open</span><br><span class="line">    tty = tty_open_by_driver(device, inode, filp);</span><br><span class="line">        driver = tty_lookup_driver(device, filp, &amp;index);</span><br><span class="line">            <span class="keyword">case</span> <span class="title function_">MKDEV</span><span class="params">(TTYAUX_MAJOR, <span class="number">1</span>)</span>: &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">console_driver</span> =</span> console_device(index);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 从console_drivers链表头开始寻找</span></span><br><span class="line"><span class="comment"> * 如果console-&gt;device成功，就返回它对应的tty_driver</span></span><br><span class="line"><span class="comment"> * 这就是/dev/console对应的tty_driver</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="keyword">struct</span> tty_driver *<span class="title function_">console_device</span><span class="params">(<span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">console</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    console_lock();</span><br><span class="line">    for_each_console(c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;device)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        driver = c-&gt;device(c, index);</span><br><span class="line">        <span class="keyword">if</span> (driver)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    console_unlock();</span><br><span class="line">    <span class="keyword">return</span> driver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/fuzidage/p/18203864">Linux下Uart子系统驱动 - fuzidage - 博客园 (cnblogs.com)</a></p>
<h2><span id="1-6-nei-he-xin-xi-de-zao-qi-da-yin">1.6 内核信息的早期打印</span><a href="#1-6-nei-he-xin-xi-de-zao-qi-da-yin" class="header-anchor">#</a></h2><p>当我们注册了uart_driver、并调用uart_add_one_port后，它里面才注册console，在这之后才能使用printk。</p>
<p>如果想更早地使用printk函数，比如在安装UART驱动之前就使用printk，这时就需要自己去注册console。</p>
<p>更早地、单独地注册console，有两种方法：</p>
<p>early_printk：自己实现write函数，不涉及设备树，简单明了</p>
<p>earlycon：通过设备树传入硬件信息，跟内核中驱动程序匹配<br>earlycon是新的、推荐的方法，在内核已经有驱动的前提下，通过设备树或cmdline指定寄存器地址即可。</p>
<h3><span id="1-6-1-early-printk">1.6.1 early_printk</span><a href="#1-6-1-early-printk" class="header-anchor">#</a></h3><p>arch\arm\kernel\early_printk.c，必须实现这几点：</p>
<ul>
<li>配置内核，选择：CONFIG_EARLY_PRINTK</li>
<li>内核中实现：printch函数</li>
<li>cmdline中添加：earlyprintk</li>
</ul>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/9.png" alt="img"></p>
<h3><span id="1-6-2-earlycon">1.6.2 earlycon</span><a href="#1-6-2-earlycon" class="header-anchor">#</a></h3><h1><span id="2-prink-h-jie-shao">2 prink.h介绍</span><a href="#2-prink-h-jie-shao" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pr_emerg(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_EMERG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_alert(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_crit(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_CRIT pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_err(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warning(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_WARNING pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_warn pr_warning</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_notice(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_NOTICE pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_info(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_INFO pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">/* If you are writing a driver, please use dev_dbg instead */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DYNAMIC_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dynamic_debug.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dynamic_pr_debug() uses pr_fmt() internally so we don&#x27;t need it here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        dynamic_pr_debug(fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pr_debug(fmt, ...) \</span></span><br><span class="line"><span class="meta">        no_printk(KERN_DEBUG pr_fmt(fmt), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/10.png" alt="img"></p>
<p><code>pr_emerg到pr_info</code>都是一些基本的kernel打印函数，用来设置内核日志打印级别，可以看到它和下面这种打印本质上并无差异。</p>
<p>而<code>pr_debug</code>则有3种输出方式，当开启dynamic_debug后，则走dynamic_pr_debug流程（dynamic_debug见下一节）。当用户开启了DEBUG宏，则走printk流程，否则什么都不打印。</p>
<h1><span id="3-dmesg-ming-ling">3 dmesg命令</span><a href="#3-dmesg-ming-ling" class="header-anchor">#</a></h1><h2><span id="3-1-x2f-proc-x2f-kmsg">3.1 &#x2F;proc&#x2F;kmsg</span><a href="#3-1-x2f-proc-x2f-kmsg" class="header-anchor">#</a></h2><p><code>/proc/kmsg</code> 是一个特殊的文件，它提供了内核消息缓冲区的访问，这个缓冲区包含了内核产生的所有消息，包括各种调试和错误信息，如内核的启动打印</p>
<p><code>dmesg命令就是cat /proc/kmsg</code>。</p>
<h2><span id="3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao">3.2 修改内核日志缓冲区大小</span><a href="#3-2-xiu-gai-nei-he-ri-zhi-huan-chong-qu-da-xiao" class="header-anchor">#</a></h2><p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/11.png" alt="img"></p>
<h2><span id="3-3-dmesg">3.3 dmesg</span><a href="#3-3-dmesg" class="header-anchor">#</a></h2><p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/12.png" alt="img"></p>
<p>dmesg命令是从kernel ring buffer中读取内核日志信息。因此可以用dmesg命令查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-C:  直接清除ring buffer</span><br><span class="line">-c： 当完成打印显示后清除环缓冲内的内容。</span><br><span class="line">-s： 缓冲区大小</span><br><span class="line">　	定义一个大小为&quot;缓冲区大小&quot;的缓冲区用于查询内核环缓冲区。默认大小为 8196，如果你设置了一个大于默认值的环缓冲区，那你就可以用这个选项定义一个相当的缓冲区来查看完整的环缓冲区内容。</span><br><span class="line"></span><br><span class="line">-n：级别</span><br><span class="line"></span><br><span class="line">dmesg -k：打印内核信息</span><br><span class="line">dmesg -u：打印用户空间信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实用dmesg -n也是可以设置控制台打印级别:</p>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/13.png" alt="img"></p>
<p>有时候在调试kernel驱动时内核panic了or死锁了，那么无法敲命令，如何查看日志呢？重启后日志就没了，那么可以敲如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/kmsg &gt; /mnt/data/ker.log &amp; 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p> 用后台进程将日志导入到文件。</p>
<ol>
<li>dmesg -f：根据系统打印信息:</li>
</ol>
<p>可用系统有</p>
<pre><code>kern - kernel messages（内核信息）
user - random user-level messages（随机用户信息）
mail - mail system（邮件系统信息）
daemon - system daemons（系统守护进程信息）
auth - security/authorization messages（认证授权安全信息）
syslog - messages generated internally by syslogd（系统日志信息）
lpr - line printer subsystem（打印机信息）
news - network news subsystem（网络系统信息）
</code></pre>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/14.png" alt="img"></p>
<ol start="2">
<li>dmesg -l：根据level来打印信息:</li>
</ol>
<p>   可用的level信息有</p>
<pre><code>   emerg - system is unusable（系统无法使用）
      alert - action must be taken immediately
       crit - critical conditions（临界条件）
        err - error conditions（错误条件）
       warn - warning conditions（警告条件）
     notice - normal but significant condition
       info - informational
      debug - debug-level messages（debug）
</code></pre>
<p><img src="/2024/06/07/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-printk%E5%92%8Cdemsg/15.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux日志管理-syslog和rsyslog</title>
    <url>/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-syslogd-jian-jie">1 syslogd简介</a><ul>
<li><a href="#1-1-ri-zhi-ge-shi">1.1 日志格式</a></li>
<li><a href="#1-2-etc-syslog-conf-fu-wu-pei-zhi">1.2 &#x2F;etc&#x2F;syslog.conf服务配置</a><ul>
<li><a href="#1-2-1-zong-pei-zhi-etc-syslog-conf">1.2.1 总配置&#x2F;etc&#x2F;syslog.conf</a></li>
<li><a href="#1-2-2-rsyslog-gui-ze-etc-rsyslog-d-conf">1.2.2 rsyslog规则（&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf）</a><ul>
<li><a href="#1-2-2-1-facility-ri-zhi-lei-xing">1.2.2.1 facility-日志类型</a></li>
<li><a href="#1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu">1.2.2.2 level-按严重程度由低到高排序</a></li>
<li><a href="#1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi">1.2.2.3 action-表示log保存的位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze">1.3 程序如何配置syslog子服务(自定义rsyslog规则)</a></li>
</ul>
</li>
<li><a href="#2-syslog-han-shu">2 syslog()函数</a><ul>
<li><a href="#2-1-openlog-han-shu">2.1 openlog函数</a></li>
<li><a href="#2-2-syslog-han-shu">2.2 syslog函数</a></li>
<li><a href="#2-3-chong-ding-xiang-log">2.3 重定向log</a><ul>
<li><a href="#2-3-1-fang-fa-1-xiu-gai-rsyslog-conf">2.3.1 方法1-修改rsyslog.conf</a></li>
<li><a href="#2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility">2.3.2 方法2-修改code中的facility</a></li>
</ul>
</li>
<li><a href="#2-4-she-zhi-log-deng-ji">2.4 设置log等级</a></li>
<li><a href="#2-5-chong-ding-xiang-log-dao-console">2.5 重定向log到console</a></li>
</ul>
</li>
<li><a href="#3-dup-han-shu-jie-shao">3 dup函数介绍</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-syslogd-jian-jie">1 syslogd简介</span><a href="#1-syslogd-jian-jie" class="header-anchor">#</a></h1><p>syslogd不仅仅是记录kernel log的服务，还能记录user space中的日志。</p>
<p>syslogd是Linux下的一个记录日志文件服务。新版本叫做rsyslogd。</p>
<p>syslogd有一系列的子服务，例如mail、auth、cron、kern等等，这些子服务提供日志记录的功能,。当程序要记录log时,可以直接调用这些子服务将日志记录到设定的地方。</p>
<p><strong>syslogd</strong>是一个守护进程，配置这整个守护进程以及其子服务的地方就是&#x2F;etc&#x2F;syslog.conf这个文件。可以从<a href="https://www.rsyslog.com/doc/master/%E8%8E%B7%E5%8F%96%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E3%80%82">https://www.rsyslog.com/doc/master/获取官方文档。</a></p>
<h2><span id="1-1-ri-zhi-ge-shi">1.1 日志格式</span><a href="#1-1-ri-zhi-ge-shi" class="header-anchor">#</a></h2><p>如果配置好并运行了 syslogd 或 klogd，一般所有 log的信息也会追加到<code> /var/log/messages</code>。并且kernel log信息被记录在<code>/val/log/kern.log</code>。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/1.png" alt="img"></p>
<p>可以看到基本日志格式包含以下四列:</p>
<ol>
<li>事件产生的时间(Jan 1 08:00:09)</li>
<li>发生事件的服务器的主机名 (cvitek)</li>
<li>产生事件的服务名或程序名 (kernel or local5)</li>
<li>事件的具体信息(…cif a0c2000.cif:..)</li>
</ol>
<p>当开启rsyslogd后，不能透过&#x2F;proc&#x2F;kmsg来查看kernel log。</p>
<h2><span id="1-2-x2f-etc-x2f-syslog-conf-fu-wu-pei-zhi">1.2 &#x2F;etc&#x2F;syslog.conf服务配置</span><a href="#1-2-x2f-etc-x2f-syslog-conf-fu-wu-pei-zhi" class="header-anchor">#</a></h2><ol>
<li>&#x2F;etc&#x2F;rsyslog.conf 是rsyslog服务的总配置文件</li>
<li>&#x2F;etc&#x2F;rsyslog.d 该目录是单独配置的rsyslog配置文件</li>
</ol>
<h3><span id="1-2-1-zong-pei-zhi-x2f-etc-x2f-syslog-conf">1.2.1 总配置&#x2F;etc&#x2F;syslog.conf</span><a href="#1-2-1-zong-pei-zhi-x2f-etc-x2f-syslog-conf" class="header-anchor">#</a></h3><p>rsyslog记录哪些日志，到底记录了什么样的日志，是通过这个<code>/etc/rsyslog.conf</code>配置文件来决定的，先分析一下rsyslogd的总配置文件：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/2.png" alt="img"></p>
<p>默认规则会定义在<code>/etc/rsyslog.d/50-default.conf</code>中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################</span></span><br><span class="line"><span class="comment">#### MODULES ####</span></span><br><span class="line"><span class="comment">#################</span></span><br><span class="line">module(load=<span class="string">&quot;imuxsock&quot;</span>) <span class="comment"># provides support for local system logging   ；加载提供对本地系统日志的支持</span></span><br><span class="line">module(load=<span class="string">&quot;imklog&quot;</span>)   <span class="comment"># provides kernel logging support；加载读取内核消息模块</span></span><br><span class="line"><span class="comment">#module(load=&quot;immark&quot;)  # provides --MARK-- message capability</span></span><br><span class="line"><span class="comment"># provides UDP syslog reception  （接收使用UDP 协议转发过来的日志，这里#注释掉了表示不启用）</span></span><br><span class="line"><span class="comment">#module(load=&quot;imudp&quot;)</span></span><br><span class="line"><span class="comment">#input(type=&quot;imudp&quot; port=&quot;514&quot;)  （允许514端口接收）</span></span><br><span class="line"><span class="comment"># provides TCP syslog reception （接收使用UDP 协议转发过来的日志）</span></span><br><span class="line"><span class="comment">#module(load=&quot;imtcp&quot;)</span></span><br><span class="line"><span class="comment">#input(type=&quot;imtcp&quot; port=&quot;514&quot;)（允许514端口接收）</span></span><br><span class="line"><span class="comment"># Enable non-kernel facility klog messages</span></span><br><span class="line"><span class="variable">$KLogPermitNonKernelFacility</span> on</span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#### GLOBAL DIRECTIVES ####</span></span><br><span class="line"><span class="comment">###########################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Use traditional timestamp format.</span></span><br><span class="line"><span class="comment"># To enable high precision timestamps, comment out the following line.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$ActionFileDefaultTemplate</span> RSYSLOG_TraditionalFileFormat</span><br><span class="line"><span class="comment"># Filter duplicated messages</span></span><br><span class="line"><span class="variable">$RepeatedMsgReduction</span> on</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set the default permissions for all log files.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$FileOwner</span> syslog</span><br><span class="line"><span class="variable">$FileGroup</span> adm</span><br><span class="line"><span class="variable">$FileCreateMode</span> 0640</span><br><span class="line"><span class="variable">$DirCreateMode</span> 0755</span><br><span class="line"><span class="variable">$Umask</span> 0022</span><br><span class="line"><span class="variable">$PrivDropToUser</span> syslog</span><br><span class="line"><span class="variable">$PrivDropToGroup</span> syslog</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Where to place spool and state files</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span><br><span class="line">(记录所有日志类型的info级别以及大于info级别的信息到/var/log/messages,但是mail邮件信息,authpriv验证方面的信息和cron时间任务相关的信息除外)</span><br><span class="line"><span class="comment">#*.info;mail.none;authpriv.none;cron.none    /var/log/messages</span></span><br><span class="line"><span class="comment"># Include all config files in /etc/rsyslog.d/ </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="variable">$IncludeConfig</span> /etc/rsyslog.d/*.conf  （表示加载该目录中的所有配置）</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-2-rsyslog-gui-ze-x2f-etc-x2f-rsyslog-d-x2f-conf">1.2.2 rsyslog规则（&#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf）</span><a href="#1-2-2-rsyslog-gui-ze-x2f-etc-x2f-rsyslog-d-x2f-conf" class="header-anchor">#</a></h3><p>rsyslog规则配置文件一般由以下3部分组成，每一行表示一个项目，格式为：facility.level action，分别表示日志类型，日志等级，日志输出路径。一般系统默认的规则定义在<code>/etc/rsyslog.d/50-default.conf</code>：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/3.png" alt="img"></p>
<p>一般所有日志类型都会被追加在<code>/val/log/messages</code>。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*.info;mail.none;authpriv.none;cron.none    /var/log/messages  </span><br></pre></td></tr></table></figure>

<h4><span id="1-2-2-1-facility-ri-zhi-lei-xing">1.2.2.1 facility-日志类型</span><a href="#1-2-2-1-facility-ri-zhi-lei-xing" class="header-anchor">#</a></h4><ul>
<li>kern: 内核信息</li>
<li>user: 用户进程相关信息</li>
<li>mail: 电子邮件相关信息</li>
<li>Local0- local7: 为本地使用预留的服务</li>
<li>daemon: 后台进程相关信息</li>
<li>syslog: 系统日志信息</li>
</ul>
<h4><span id="1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu">1.2.2.2 level-按严重程度由低到高排序</span><a href="#1-2-2-2-level-an-yan-chong-cheng-du-you-di-dao-gao-pai-xu" class="header-anchor">#</a></h4><ul>
<li>none: 没有重要级</li>
<li>debug: 调试信息</li>
<li>info: 打印的信息</li>
<li>notice: 具有重要信息的普通条件</li>
<li>warning: 警告信息</li>
<li>err: 错误信息</li>
<li>crit: 阻止某些工具或子系统功能实现的错误条件</li>
<li>alert: 需要立即被修改的条件</li>
<li>emerg: 该系统不可用</li>
</ul>
<h4><span id="1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi">1.2.2.3 action-表示log保存的位置</span><a href="#1-2-2-3-action-biao-shi-log-bao-cun-de-wei-zhi" class="header-anchor">#</a></h4><p>那下面我也抄过来一份比较全面的规则定义示例供大家参考:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录mail日志等级为error及以上日志</span></span><br><span class="line">mail.err                                                        /var/log/mail_err.log</span><br><span class="line"><span class="comment"># 记录mail所有等级为warn级别的日志（仅记录warn级别）</span></span><br><span class="line">mail.=warn                                                        /var/log/mail_err.log</span><br><span class="line"><span class="comment"># 记录kern所有日志</span></span><br><span class="line">kern.*                                                                /var/log/kern.log</span><br><span class="line"><span class="comment"># 将mail的所有信息，除了info以外，其他的都写入/var/adm/mail</span></span><br><span class="line">mail.*;mail.!=info   /var/adm/mail</span><br><span class="line"><span class="comment"># 将日志等级为crit或更高的内核消息定向到远程主机finlandia</span></span><br><span class="line"><span class="comment"># 如果主机崩溃，磁盘出现不可修复的错误，可能无法读取存储的消息。如果有日志在远程主机上，可以尝试找出崩溃的原因。</span></span><br><span class="line">kern.crit                                                     @finlandia</span><br><span class="line"><span class="comment"># 记录所有类型的warning等级及以上日志</span></span><br><span class="line">*.warning                                                        /var/log/syslog_warn.log</span><br><span class="line"><span class="comment"># 记录mail的warning日志和kern的error日志,其他所有的info日志</span></span><br><span class="line">*.info;mail.warning;kern.error                /var/log/messages</span><br><span class="line"><span class="comment"># 记录kernel的info到warning日志</span></span><br><span class="line">kern.info;kern.!err   /var/adm/kernel-info</span><br><span class="line"><span class="comment"># 将mail和news的info级别日志写入/var/adminfo</span></span><br><span class="line">mail,news.=info    /var/adm/info</span><br><span class="line"><span class="comment"># 将所有系统中所有类型的info日志和notice日志存入/var/log/massages,mail的所有日志除外。</span></span><br><span class="line">*.=info;*.=notice;\</span><br><span class="line">mail.none /var/log/messages</span><br><span class="line"><span class="comment"># 紧急消息（emerg级别）将使用wall显示给当前所有登录的用户，这里用等号表示只对emerg日志级别有效</span></span><br><span class="line">*.=emerg                   *</span><br><span class="line"><span class="comment"># 该规则将所有alert以及更高级别的消息定向到操作员的终端，即登录的用户“root”和“joey”的终端。</span></span><br><span class="line">*.alert      root,joey</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze">1.3 程序如何配置syslog子服务(自定义rsyslog规则)</span><a href="#1-3-cheng-xu-ru-he-pei-zhi-syslog-zi-fu-wu-zi-ding-yi-rsyslog-gui-ze" class="header-anchor">#</a></h2><p><strong>问题：进程如何发送消息给rsyslog守护进程，rsyslog守护进程是如何对各种日志区分开来的？</strong></p>
<p>像<code>/usr/sbin/sshd、/usr/bin/login、/usr/bin/su</code>这些进程，它们是调用一个叫syslog的系统调用, syslog系统调用是一个用于向rsyslog守护进程发送消息的的系统函数。<br><code>/usr/sbin/sshd,/usr/bin/login、/usr/bin/su</code>这些进程专门执行登录验证时，它们在调用syslog系统函数会一般会传入<code>LOG_AUTH</code>这个常量。</p>
<p>而<code>/usr/bin/crond和/usr/bin/at</code>这些在调用syslog系统调用会传入<code>LOG_CRON</code>这个常量（具体请看**syslog()**函数），日志归类规则如下：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/4.png" alt="img"></p>
<p>所以如果用<code>LOG_AUTH</code>的syslog()函数调用，那么会归类到了<code>/val/log/secure</code>。</p>
<p>如果用<code>LOG_CRON</code>的syslog()调用则归类到了<code>/val/log/cron</code>。而kernel等其他log被记录在了<code>/val/log/messages</code>中。</p>
<p>那么我们可以自定义规则如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/5.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syslogfacility-text：表示facility日志类型</span><br><span class="line">syslogseverity-text：表示level日志级别</span><br><span class="line"></span><br><span class="line">这里对aisdk.conf用local7日志类型产生的大于warn日志级别的<span class="built_in">log</span>都将记录到/val/log/aisdk，</span><br><span class="line">对kern.conf用kern类型产生的所有级别日志都记录到/val/log/kern，</span><br><span class="line">Local5类型的日志记录到/val/log/middleware, 并且当日志级别等于或高于4（warn）时也会追加到console.</span><br></pre></td></tr></table></figure>

<p>注意busybox要开启使能syslog.conf解析：<code>/etc/syslog.conf</code>解析，<code>CONFIG_FEATURE_SYSLOGD_CFG=y</code></p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/5-1.png" alt="img"></p>
<h1><span id="2-syslog-han-shu">2 syslog()函数</span><a href="#2-syslog-han-shu" class="header-anchor">#</a></h1><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/6.png" alt="img"></p>
<p>用户空间也可以用syslog()函数来记录自己的进程的日志，所以用户进程可以自定义日志规则。<br>调用openlog是可选择的。如果不调用openlog，则在第一次调用syslog时，会自动调用openlog。<br>syslog的相关函数和宏定义一般在toolchain中都会有定义:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/7.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span> <span class="params">(<span class="type">char</span>*ident,<span class="type">int</span> option ,<span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority,<span class="type">char</span>*format,……)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>



<h2><span id="2-1-openlog-han-shu">2.1 openlog函数</span><a href="#2-1-openlog-han-shu" class="header-anchor">#</a></h2><p>第1个参数为ident，该参数常用来表示信息的来源。ident信息会被固定地添加在每行日志的前面：<br>第2个参数 option控制标志:</p>
<table>
<thead>
<tr>
<th>option控制标志</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_CONS</td>
<td>如果将信息发送给syslogd守护进程时发生错误，直接将相关信息输出到终端</td>
</tr>
<tr>
<td>LOG_PID</td>
<td>每条日志信息中都包括进程号</td>
</tr>
</tbody></table>
<p>第3个参数为facility：</p>
<table>
<thead>
<tr>
<th>facility参数</th>
<th>syslog.conf中对应的facility取值</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_KERN</td>
<td>kern</td>
</tr>
<tr>
<td>LOG_USER</td>
<td>user</td>
</tr>
<tr>
<td>LOG_MAIL</td>
<td>mail</td>
</tr>
<tr>
<td>LOG_DAEMON</td>
<td>daemon</td>
</tr>
<tr>
<td>LOG_AUTH</td>
<td>auth</td>
</tr>
<tr>
<td>LOG_SYSLOG</td>
<td>syslog</td>
</tr>
<tr>
<td>LOG_LPR</td>
<td>lpr</td>
</tr>
<tr>
<td>LOG_NEWS</td>
<td>news</td>
</tr>
<tr>
<td>LOG_UUCP</td>
<td>uucp</td>
</tr>
<tr>
<td>LOG_CRON</td>
<td>cron</td>
</tr>
<tr>
<td>LOG_AUTHPRIV</td>
<td>authpriv</td>
</tr>
<tr>
<td>LOG_FTP</td>
<td>ftp</td>
</tr>
<tr>
<td>LOG_LOCAL0～LOG_LOCAL7</td>
<td>local0～local7</td>
</tr>
</tbody></table>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/8.png" alt="img"></p>
<h2><span id="2-2-syslog-han-shu">2.2 syslog函数</span><a href="#2-2-syslog-han-shu" class="header-anchor">#</a></h2><p>第一个参数priority表示日志级别：</p>
<table>
<thead>
<tr>
<th>priority参数</th>
<th>syslog.conf中对应的level取值</th>
</tr>
</thead>
<tbody><tr>
<td>LOG_EMERG</td>
<td>emerg</td>
</tr>
<tr>
<td>LOG_ALERT</td>
<td>alert</td>
</tr>
<tr>
<td>LOG_CRIT</td>
<td>crit</td>
</tr>
<tr>
<td>LOG_ERR</td>
<td>err</td>
</tr>
<tr>
<td>LOG_WARNING</td>
<td>warning</td>
</tr>
<tr>
<td>LOG_NOTICE</td>
<td>notice</td>
</tr>
<tr>
<td>LOG_INFO</td>
<td>info</td>
</tr>
<tr>
<td>LOG_DEBUG</td>
<td>debug</td>
</tr>
</tbody></table>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/9.png" alt="img"></p>
<p>下面是具体的例子：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/10.png" alt="img"></p>
<p>这里<code>printf(&quot;%m&quot;)等价于printf(&quot;%s&quot;,strerror(errno));</code>它表示把errno用string形式打印出来。</p>
<p>由于我这里facility为user时，是记录在&#x2F;val&#x2F;log&#x2F;syslog中的:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/11.png" alt="img"></p>
<p>因此打印log如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/12.png" alt="img"></p>
<h2><span id="2-3-chong-ding-xiang-log">2.3 重定向log</span><a href="#2-3-chong-ding-xiang-log" class="header-anchor">#</a></h2><p>我们也可以把log定向到自己想要的地方。</p>
<h3><span id="2-3-1-fang-fa-1-xiu-gai-rsyslog-conf">2.3.1 方法1-修改rsyslog.conf</span><a href="#2-3-1-fang-fa-1-xiu-gai-rsyslog-conf" class="header-anchor">#</a></h3><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/13.png" alt="img"></p>
<p>将<code>facility=user</code>时的所有level级别的log重定向到<code>/val/log/user.log</code>, 重启rsyslog服务:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/14.png" alt="img"></p>
<p>此时log将被写入到新配置的位置&#x2F;val&#x2F;log&#x2F;user.log, 当然&#x2F;val&#x2F;log&#x2F;syslog也会保留一份.（因为也符合&#x2F;val&#x2F;log&#x2F;syslog这条规则）</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/15.png" alt="img"></p>
<h3><span id="2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility">2.3.2 方法2-修改code中的facility</span><a href="#2-3-2-fang-fa-2-xiu-gai-code-zhong-de-facility" class="header-anchor">#</a></h3><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/16.png" alt="img"></p>
<p>那这里的facility被设置成了local0, 那也会记录在<code>/val/log/syslog</code>:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/17.png" alt="img"></p>
<h2><span id="2-4-she-zhi-log-deng-ji">2.4 设置log等级</span><a href="#2-4-she-zhi-log-deng-ji" class="header-anchor">#</a></h2><ol>
<li>这里新增一个app.conf，然后自定义log路径:</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/18.png" alt="img"></p>
<p>当然还可以类似于这样子写， syslogfacility-text和syslogseverity-text是rsyslog自带的系统变量。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/19.png" alt="img"></p>
<ol start="2">
<li><p>重启rsyslog服务</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/20.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/21.png" alt="img"></p>
<p>这里切成4个文件，每个文件记录1024k。</p>
<ol start="3">
<li><p>运行程序,查看log如下:</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/22.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/23.png" alt="img"></p>
<ol start="4">
<li><p>那现在修改log等级为warn, 表示只有大于等于该等级的log才会记录。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/24.png" alt="img"></p>
</li>
<li><p>再次重启rsyslog服务，运行程序，可以看到”log debug”不再打印：</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/25.png" alt="img"></p>
</li>
</ol>
<h2><span id="2-5-chong-ding-xiang-log-dao-console">2.5 重定向log到console</span><a href="#2-5-chong-ding-xiang-log-dao-console" class="header-anchor">#</a></h2><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/26.png" alt="img"></p>
<p>再次重启rsyslog服务，运行程序，那么可以看到err级别的log打印在了console上，但是低于err级别还是会记录在&#x2F;val&#x2F;log&#x2F;app。</p>
<p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/27.png" alt="img"></p>
<h1><span id="3-dup-han-shu-jie-shao">3 dup函数介绍</span><a href="#3-dup-han-shu-jie-shao" class="header-anchor">#</a></h1><p><img src="/2024/06/02/Linux%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86-syslog%E5%92%8Crsyslog/28.png" alt="img"></p>
<p>用来将标准输出重定向到文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> dup_fd;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dup_fd_bak = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dup_fd</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    dup_fd = open( <span class="string">&quot;./printf_dup_log.txt &quot;</span>, O_CREAT | O_RDWR | O_TRUNC);</span><br><span class="line">    dup2(STDOUT_FILENO, dup_fd_bak);<span class="comment">/*backup stdout*/</span></span><br><span class="line">    dup2(dup_fd, STDOUT_FILENO);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">rst_fd</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    dup2(dup_fd_bak, fileno(<span class="built_in">stdout</span>));<span class="comment">/*recover stdout*/</span></span><br><span class="line">    close(dup_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
        <tag>linux系统构建</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim配置成类似source-insight的IDE</title>
    <url>/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#qian-yan">前言</a><ul>
<li><a href="#ji-ben-an-zhuang">基本安装</a></li>
</ul>
</li>
<li><a href="#1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</a><ul>
<li><a href="#1-1-ctag-zuo-yong">1.1 ctag作用</a></li>
<li><a href="#1-2-an-zhuang-ctags">1.2 安装ctags</a></li>
<li><a href="#1-3-an-zhuang-taglist">1.3 安装taglist</a></li>
<li><a href="#1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</a><ul>
<li><a href="#1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</a></li>
</ul>
</li>
<li><a href="#1-5-pei-zhi-vimrc">1.5 配置.vimrc</a></li>
</ul>
</li>
<li><a href="#2-ctags-taglist-shi-yong">2 ctags + taglist使用</a><ul>
<li><a href="#2-1-ctags-shi-yong">2.1 ctags使用</a><ul>
<li><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</a></li>
<li><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</a></li>
<li><a href="#2-1-3-jia-zai-tags">2.1.3 加载tags</a></li>
<li><a href="#2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</a></li>
<li><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</a></li>
<li><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</a></li>
<li><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</a></li>
</ul>
</li>
<li><a href="#2-2-taglist-shi-yong">2.2 taglist使用</a><ul>
<li><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</a></li>
<li><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</a></li>
<li><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-nerdtree-cha-jian">3 NERDTree插件</a><ul>
<li><a href="#3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</a><ul>
<li><a href="#3-1-1-an-zhuang">3.1.1 安装</a></li>
<li><a href="#3-1-2-pei-zhi">3.1.2 配置</a></li>
</ul>
</li>
<li><a href="#3-2-shi-yong-nerdtree">3.2 使用NERDTree</a><ul>
<li><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</a></li>
<li><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</a></li>
<li><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</a></li>
<li><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</a><ul>
<li><a href="#4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</a></li>
<li><a href="#4-2-srcexpl-shi-yong">4.2 SrcExpl使用</a><ul>
<li><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</a><ul>
<li><a href="#5-1-an-zhuang-pei-zhi">5.1 安装配置</a></li>
<li><a href="#5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</a></li>
</ul>
</li>
<li><a href="#6-cscope-cha-jian">6 cscope插件</a><ul>
<li><a href="#6-1-an-zhuang">6.1 安装</a></li>
<li><a href="#6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</a></li>
<li><a href="#6-3-pei-zhi-vimrc">6.3 配置.vimrc</a></li>
<li><a href="#6-5-shi-yong">6.5 使用</a><ul>
<li><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</a></li>
<li><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</a></li>
<li><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-source-insight-kuo-zhan">7 source insight扩展</a><ul>
<li><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="qian-yan">前言</span><a href="#qian-yan" class="header-anchor">#</a></h1><h2><span id="ji-ben-an-zhuang">基本安装</span><a href="#ji-ben-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install vim vim-scripts vim-doc
</code></pre>
<p>vim-scripts是vim的一些基本插件，包括语法高亮的支持、缩进等等。<br>整体配置好后效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/1.png" alt="image"></p>
<h1><span id="1-ctags-taglist-an-zhuang-pei-zhi">1 ctags + taglist安装配置</span><a href="#1-ctags-taglist-an-zhuang-pei-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-ctag-zuo-yong">1.1 ctag作用</span><a href="#1-1-ctag-zuo-yong" class="header-anchor">#</a></h2><p>ctags 最先是用来生成C代码的tags文件，后来扩展成可以生成各类语言的tags, 有些语言也有专有的tags生成工具（比如java的jtags, python的 ptags)，因此ctag用来进行vim阅读源码时进行函数，变量的快速定位跳转。</p>
<h2><span id="1-2-an-zhuang-ctags">1.2 安装ctags</span><a href="#1-2-an-zhuang-ctags" class="header-anchor">#</a></h2><pre><code>sudo apt-get install ctags
</code></pre>
<h2><span id="1-3-an-zhuang-taglist">1.3 安装taglist</span><a href="#1-3-an-zhuang-taglist" class="header-anchor">#</a></h2><p>taglist_46.zip压缩包：解压到~&#x2F;.vim目录下即可。<br><a href="https://www.vim.org/scripts/script.php?script_id=273">https://www.vim.org/scripts/script.php?script_id=273</a></p>
<pre><code>mkdir ~/.vim
cd ~/.vim
unzip taglist_46.zip
</code></pre>
<h2><span id="1-4-chuang-jian-tags-wen-jian">1.4 创建tags文件</span><a href="#1-4-chuang-jian-tags-wen-jian" class="header-anchor">#</a></h2><p><code>$ctags -R --c++-kinds=+p+l+x+c+d+e+f+g+m+n+s+t+u+v --fields=+liaS --extra=+q</code><br>如果为了简单，也可以只进行：<br><code>$ctags -R *</code><br>不过，这种成员变量没有包含在里面。所以可能有些对象的成员时无法跳转。</p>
<h3><span id="1-4-1-pei-zhi-xuan-xiang">1.4.1配置选项</span><a href="#1-4-1-pei-zhi-xuan-xiang" class="header-anchor">#</a></h3><pre><code>  $ ctags -R　　　　　　　　　　　　　  #递归的为当前目录及子目录下的所有代码文件生成tags文件 (推荐使用此命令)
  $ ctags filename.c filename1.c file.h 　#为当前目录某些源码生成tags文件
  $ ctags *.c *.h　　　　　　　　　　　   #为当前目录所有.c, .h源码生成tags文件

  为了使得字段补全有效，在生成tags时需要一些额外的参数，推荐的c++参数主要是：ctags -R --c++-kinds=+px --fields=+iaS --extra=+q
  其中：
    选项c++-kinds 用于指定C++语言的 tags记录类型,  --c-kinds用于指定c语言的，  通用格式是  --&#123;language&#125;-kinds
    选项 fileds 用于指定每条标记的扩展字段域
    extra 选项用于增加额外的条目:   f表示为每个文件增加一个条目，  q为每个类增加一个条目
</code></pre>
<h2><span id="1-5-pei-zhi-vimrc">1.5 配置.vimrc</span><a href="#1-5-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;--------------display-----------------
set nu                          &quot;行号
syntax on                       &quot;语法高亮
set ruler                       &quot;显示当前行和列
set showcmd                     &quot;显示部分命令
set showmode            &quot;最后一行显示当前模式
&quot;set match                      &quot;显示括号匹配
&quot;--------------display-----------------

&quot;---------------input------------------
set smartindent         &quot;自动缩进
set expandtab           &quot;将tab转化为空格
set smarttab            &quot;插入tab使用shiftwidth
set shiftwidth=4        &quot;缩进列数为4
&quot;---------------input------------------

&quot;---------------search-----------------
set hlsearch            &quot;搜索结果高亮显示
&quot;set inccase                    &quot;预览搜索结果
set ignorecase          &quot;不区分大小写
set smartcase           &quot;当有大写字母时区分大小写
&quot;---------------search-----------------

&quot;---------------encoding----------------
set encoding=utf-8              &quot;设置编码格式
set fileencodings=utf-8,gb18030,gbk,gb2312,big5
set termencoding=utf-8


&quot;--------------ctags----------------
set tags=tags;
set autochdir        &quot;通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。
&quot;--------------ctags----------------


&quot;--------------taglist----------------
let Tlist_Use_Left_Window=1             &quot;vim左侧窗口显示Taglist
let Tlist_Exit_OnlyWindow=1             &quot;Taglist是最后一个窗口是退出vim
let Tlist_WinWidth=60           &quot;设置Taglist窗口宽度为60
nmap &lt;F2&gt; :Tlist&lt;CR&gt;                    &quot;设置快捷键&lt;F2&gt;打开Taglist
&quot;--------------taglist----------------
</code></pre>
<h1><span id="2-ctags-taglist-shi-yong">2 ctags + taglist使用</span><a href="#2-ctags-taglist-shi-yong" class="header-anchor">#</a></h1><h2><span id="2-1-ctags-shi-yong">2.1 ctags使用</span><a href="#2-1-ctags-shi-yong" class="header-anchor">#</a></h2><pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/2.png" alt="image"></p>
<h3><span id="2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan">2.1.1 <code>ctrl + ]</code>可以进行函数跳转</span><a href="#2-1-1-ctrl-ke-yi-jin-xing-han-shu-tiao-zhuan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/3.png" alt="image"></p>
<h3><span id="2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi">2.1.2 <code>ctrl + T</code>可以返回跳转之前位置</span><a href="#2-1-2-ctrl-t-ke-yi-fan-hui-tiao-zhuan-zhi-qian-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/4.png" alt="image"></p>
<h3><span id="2-1-3-jia-zai-tags">2.1.3 加载tags</span><a href="#2-1-3-jia-zai-tags" class="header-anchor">#</a></h3><p>默认从创建tags的目录去启动vim打开文件会自动加载当前目录的tags文件，因此可以直接跳转：<br>如我是从uboot根目录建立的tags文件，然后：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ vi drivers/usb/gadget/f_fastboot.c
</code></pre>
<p>这样自动加载tags文件，能够进行跳转。<br>如果进入其他目录：可以看到就无法打开tags文件。</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016$ cd  drivers/usb/gadget/
book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/5.png" alt="image"></p>
<p>vim进入命令模式输入：</p>
<pre><code>:set tags+=&#39;/home/book/ftp/openedv/uboot-2016/tags
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/6.png" alt="image"><br>此时就可以正常跳转了。</p>
<h3><span id="2-1-4-zi-dong-jia-zai-tags">2.1.4 自动加载tags</span><a href="#2-1-4-zi-dong-jia-zai-tags" class="header-anchor">#</a></h3><p>在~&#x2F;.vimrc文件中添加下面两行：</p>
<pre><code>set tags=tags;
set autochdir
</code></pre>
<p>通用方式，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。<br>这样就可以在不用在tags根路径去使用vim了。如：</p>
<pre><code>book@100ask:~/ftp/openedv/uboot-2016/drivers/usb/gadget$ vi f_fastboot.c
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/7.png" alt="image"></p>
<h3><span id="2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian">2.1.5 ts 列出所有匹配的标签</span><a href="#2-1-5-ts-lie-chu-suo-you-pi-pei-de-biao-qian" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/8.png" alt="image"><br>可以看到有2处地方匹配，一个是cmd&#x2F;bootm.c，一个是include&#x2F;command.h<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/9.png" alt="image"></p>
<h3><span id="2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou">2.1.5 <code>Ctrl + W + ]</code>分割当前窗口</span><a href="#2-1-5-ctrl-w-fen-ge-dang-qian-chuang-kou" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/10.png" alt="image"><br>输入:q退出分割窗口。</p>
<h3><span id="2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu">2.1.6 vi –t tag 找到名为 tag 的变量的定义处</span><a href="#2-1-6-vi-t-tag-zhao-dao-ming-wei-tag-de-bian-liang-de-ding-yi-chu" class="header-anchor">#</a></h3><p>例如stitch_event_handler_th函数位于当前tags目录中的stitch&#x2F;common&#x2F;stitch.c的第1212行。只需确保在tags中的子目录中任意位置输入：</p>
<p><code>robin.lee@WORKSTATION5:/robin.lee/zip/A2/osdrv/interdrv/v2/dwa$ vi -t stitch_event_handler_th</code><br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/11.png" alt="image"></p>
<h2><span id="2-2-taglist-shi-yong">2.2 taglist使用</span><a href="#2-2-taglist-shi-yong" class="header-anchor">#</a></h2><h3><span id="2-2-1-f2-jian-da-kai-guan-bi-taglist">2.2.1 F2键打开关闭Taglist</span><a href="#2-2-1-f2-jian-da-kai-guan-bi-taglist" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/12.png" alt="image"></p>
<h3><span id="2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan">2.2.2 ctrl w w键taglist和vim窗口光标切换</span><a href="#2-2-2-ctrl-w-w-jian-taglist-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/13.png" alt="image"></p>
<p>例如光标位置处于vim窗口的第1211行，按下ctrl w w键（w按2次），光标会跳到左边taglist窗口。按上下左右方向键可以查找宏定义，符号，函数等。再次按ctrl w w又会跳到vim的窗口。</p>
<h3><span id="2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi">2.2.3 回车键taglist跳转到具体位置</span><a href="#2-2-3-hui-che-jian-taglist-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/14.png" alt="image"><br>比如现在光标位于taglist界面的stitch_src_qbuf位置，按下回车会跳转到函数定义的具体位置：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/15.png" alt="image"></p>
<h1><span id="3-nerdtree-cha-jian">3 NERDTree插件</span><a href="#3-nerdtree-cha-jian" class="header-anchor">#</a></h1><p>NERDTree是Vim界面显示树形目录的文件管理器插件，可在vim操作界面进行文件打开、目录浏览操作。</p>
<h2><span id="3-1-an-zhuang-pei-zhi-nerdtree">3.1 安装配置NERDTree</span><a href="#3-1-an-zhuang-pei-zhi-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-1-1-an-zhuang">3.1.1 安装</span><a href="#3-1-1-an-zhuang" class="header-anchor">#</a></h3><p><a href="https://www.vim.org/scripts/script.php?script_id=1658">https://www.vim.org/scripts/script.php?script_id=1658</a><br>下载后放到~&#x2F;.vim目录，解压即可完成安装。</p>
<h3><span id="3-1-2-pei-zhi">3.1.2 配置</span><a href="#3-1-2-pei-zhi" class="header-anchor">#</a></h3><p><code>vi ~/.vimrc</code><br>添加如下配置：</p>
<pre><code>&quot;--------------NERDTree---------------
let NERDTreeWinPos=&#39;right&#39;		&quot;设置窗口在右侧
nmap &lt;F8&gt; :NERDTree&lt;CR&gt;			&quot;设置快捷键F8打开
let NERDTreeWinSize=40		 	&quot;窗口大小为40
&quot;--------------NERDTree---------------
</code></pre>
<h2><span id="3-2-shi-yong-nerdtree">3.2 使用NERDTree</span><a href="#3-2-shi-yong-nerdtree" class="header-anchor">#</a></h2><h3><span id="3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao">3.2.1 F8键开启关闭右图文件列表</span><a href="#3-2-1-f8-jian-kai-qi-guan-bi-you-tu-wen-jian-lie-biao" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/16.png" alt="image"></p>
<h3><span id="3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan">3.2.2 ctrl w w键NERDTree和vim窗口光标切换</span><a href="#3-2-2-ctrl-w-w-jian-nerdtree-he-vim-chuang-kou-guang-biao-qie-huan" class="header-anchor">#</a></h3><p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/17.png" alt="image"><br>光标原本再右边窗口，输入ctrl w w(w按2次)切换到左边vim窗口。</p>
<h3><span id="3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi">3.2.3 回车键NERDTree跳转到具体位置</span><a href="#3-2-3-hui-che-jian-nerdtree-tiao-zhuan-dao-ju-ti-wei-zhi" class="header-anchor">#</a></h3><p>同理，和taglist一样，也是光标移动到具体文件后回车即可跳转到具体文件。方向键上下移动选择具体文件。跳转到stitch_ctx.h：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/18.png" alt="image"></p>
<h3><span id="3-2-3-fan-hui-shang-yi-ceng-mu-lu">3.2.3 返回上一层目录</span><a href="#3-2-3-fan-hui-shang-yi-ceng-mu-lu" class="header-anchor">#</a></h3><p>选择‘up a dir’，按回车：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/19.png" alt="image"><br>返回上一层目录的结果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/20.png" alt="image"></p>
<h1><span id="4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao">4 SrcExpl插件（功能鸡肋先不介绍）</span><a href="#4-srcexpl-cha-jian-gong-neng-ji-le-xian-bu-jie-shao" class="header-anchor">#</a></h1><p>SrcExpl（源资源管理器）是一个源代码资源管理器，通过显示函数或类型定义来显示当前选定的关键字或在单独的窗口中声明。该插件旨在重新创建上下文 IDE 中可用的窗口。</p>
<p>结合“Taglist”和“NERD tree”效果更佳。</p>
<h2><span id="4-1-srcexp-an-zhuang-pei-zhi">4.1 SrcExp安装配置</span><a href="#4-1-srcexp-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>安装：<br><a href="https://github.com/wenlongche/SrcExpl">https://github.com/wenlongche/SrcExpl</a><br><a href="https://www.vim.org/scripts/script.php?script_id=2179">https://www.vim.org/scripts/script.php?script_id=2179</a><br>下载后放入<del>&#x2F;.vim进行解压即可。<br>配置：<br>打开</del>&#x2F;.vimrc,添加如下配置：</p>
<pre><code>&quot; // The switch of the Source Explorer
nmap &lt;F12&gt; :SrcExplToggle&lt;CR&gt;

&quot; // Set the height of Source Explorer window
let g:SrcExpl_winHeight = 16

&quot; // Set 100 ms for refreshing the Source Explorer
let g:SrcExpl_refreshTime = 500

&quot; // Set &quot;Enter&quot; key to jump into the exact definition context
let g:SrcExpl_jumpKey = &quot;&lt;ENTER&gt;&quot;

&quot; // Set &quot;Space&quot; key for back from the definition context
let g:SrcExpl_gobackKey = &quot;&lt;SPACE&gt;&quot;

&quot; // In order to avoid conflicts, the Source Explorer should know what plugins except
&quot; // itself are using buffers. And you need add their buffer names into below list
&quot; // according to the command &quot;:buffers!&quot;
let g:SrcExpl_pluginList = [
        \ &quot;__Tag_List__&quot;,
        \ &quot;_NERD_tree_&quot;,
        \ &quot;Source_Explorer&quot;
    \ ]

&quot; // The color schemes used by Source Explorer. There are five color schemes
&quot; // supported for now - Red, Cyan, Green, Yellow and Magenta. Source Explorer
&quot; // will pick up one of them randomly when initialization.
let g:SrcExpl_colorSchemeList = [
        \ &quot;Red&quot;,
        \ &quot;Cyan&quot;,
        \ &quot;Green&quot;,
        \ &quot;Yellow&quot;,
        \ &quot;Magenta&quot;
    \ ]

&quot; // Enable/Disable the local definition searching, and note that this is not
&quot; // guaranteed to work, the Source Explorer doesn&#39;t check the syntax for now.
&quot; // It only searches for a match with the keyword according to command &#39;gd&#39;
let g:SrcExpl_searchLocalDef = 1

&quot; // Workaround for Vim bug @https://goo.gl/TLPK4K as any plugins using autocmd for
&quot; // BufReadPre might have conflicts with Source Explorer. e.g. YCM, Syntastic etc.
let g:SrcExpl_nestedAutoCmd = 1

&quot; // Do not let the Source Explorer update the tags file when opening
let g:SrcExpl_isUpdateTags = 0

&quot; // Use &#39;Exuberant Ctags&#39; with &#39;--sort=foldcase -R .&#39; or &#39;-L cscope.files&#39; to
&quot; // create/update the tags file
let g:SrcExpl_updateTagsCmd = &quot;ctags --sort=foldcase -R .&quot;

&quot; // Set &quot;&lt;F12&gt;&quot; key for updating the tags file artificially
let g:SrcExpl_updateTagsKey = &quot;&lt;F12&gt;&quot;

&quot; // Set &quot;&lt;F3&gt;&quot; key for displaying the previous definition in the jump list
let g:SrcExpl_prevDefKey = &quot;&lt;F3&gt;&quot;

&quot; // Set &quot;&lt;F4&gt;&quot; key for displaying the next definition in the jump list
let g:SrcExpl_nextDefKey = &quot;&lt;F4&gt;&quot;
</code></pre>
<h2><span id="4-2-srcexpl-shi-yong">4.2 SrcExpl使用</span><a href="#4-2-srcexpl-shi-yong" class="header-anchor">#</a></h2><h3><span id="4-2-1-f12-qi-dong-he-jin-yong-srcexpl">4.2.1 F12启动和禁用SrcExpl</span><a href="#4-2-1-f12-qi-dong-he-jin-yong-srcexpl" class="header-anchor">#</a></h3><h1><span id="5-youcompleteme-dai-ma-bu-qi-cha-jian">5 YouCompleteMe代码补齐插件</span><a href="#5-youcompleteme-dai-ma-bu-qi-cha-jian" class="header-anchor">#</a></h1><h2><span id="5-1-an-zhuang-pei-zhi">5.1 安装配置</span><a href="#5-1-an-zhuang-pei-zhi" class="header-anchor">#</a></h2><p>先安装编译依赖工具：</p>
<pre><code>sudo apt install build-essential cmake python-dev python3-dev clang
</code></pre>
<p>下载YouCompleteMe源码：</p>
<pre><code>git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/
cd .vim/bundle/YouCompleteMe
git submodule update --init --recursive
</code></pre>
<p>编译安装 YouCompleteMe:</p>
<pre><code>./install.py --clang-completer
</code></pre>
<p>安装好后打印如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/21.png" alt="image"></p>
<h2><span id="5-2-youcompleteme-shi-yong">5.2 YouCompleteMe使用</span><a href="#5-2-youcompleteme-shi-yong" class="header-anchor">#</a></h2><p>.vimrc添加配置：</p>
<pre><code>let g:ycm_global_ycm_extra_conf = &#39;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#39;
set runtimepath+=~/.vim/bundle/YouCompleteMe
autocmd InsertLeave * if pumvisible() == 0|pclose|endif
inoremap &lt;expr&gt; &lt;CR&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;CR&gt;&quot;
imap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
vmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
nmap &lt;silent&gt;&lt;leader&gt;&lt;TAB&gt; &lt;Plug&gt;(coc-complete)
</code></pre>
<p>vim版本比较低达不到插件YCM的要求从而报错【YouCompleteMe unavailable: requires Vim 8.1.2269+.】，这样也好解决，从github上重新下最新版本的vim即可。命令如下所示：</p>
<pre><code>cd /usr/local/share
sudo git clone https://github.com/vim/vim.git
cd vim/src
sudo ./configure --with-features=huge \
--enable-multibyte \
--enable-rubyinterp=yes \
--enable-pythoninterp=yes \
--enable-python3interp=yes \
--prefix=/usr/local/vim82
</code></pre>
<p>之后make和make install一下，命令如下所示：</p>
<pre><code>sudo make
sudo make install
</code></pre>
<p>在&#x2F;usr&#x2F;bin目录下建立符号链接，命令如下所示：</p>
<pre><code>sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim82
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vim
sudo ln -s /usr/local/vim82/bin/vim /usr/bin/vi
</code></pre>
<p>补齐效果如下：<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/22.png" alt="image"><br>输入vim –version信息可以看vim版本号，现已经v9.1,默认应该是8.1的。<br><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/23.png" alt="image"></p>
<p>vim配色方案：<br><a href="https://github.com/flazz/vim-colorschemes">https://github.com/flazz/vim-colorschemes</a><br>设置函数高亮：</p>
<pre><code>vi /usr/share/vim/vim91/syntax/c.vim

&quot;highlight Functions
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2
syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1
hi cFunctions gui=NONE cterm=bold  ctermfg=40
</code></pre>
<h1><span id="6-cscope-cha-jian">6 cscope插件</span><a href="#6-cscope-cha-jian" class="header-anchor">#</a></h1><h2><span id="6-1-an-zhuang">6.1 安装</span><a href="#6-1-an-zhuang" class="header-anchor">#</a></h2><pre><code>sudo apt-get install cscope
</code></pre>
<h2><span id="6-2-pei-zhi-chan-sheng-cscope-out">6.2 配置产生cscope.out</span><a href="#6-2-pei-zhi-chan-sheng-cscope-out" class="header-anchor">#</a></h2><pre><code>cscope -Rbqk

-R: 在生成索引文件时，搜索子目录树中的代码
-b: 只生成索引文件，不进入cscope的界面
-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度
-k: 在生成索引文件时，不搜索/usr/include目录
-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用”–“，表示由标准输入获得文件列表。
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/24.png" alt="image"></p>
<h2><span id="6-3-pei-zhi-vimrc">6.3 配置.vimrc</span><a href="#6-3-pei-zhi-vimrc" class="header-anchor">#</a></h2><pre><code>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; cscope setting
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
if has(&quot;cscope&quot;)
  set csprg=/usr/bin/cscope
  set csto=1
  set cst
  set nocsverb
  &quot; add any database in current directory
  if filereadable(&quot;cscope.out&quot;)
      cs add cscope.out
  endif
  set csverb
endif

nmap &lt;C-@&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
nmap &lt;C-@&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;
nmap &lt;C-@&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;

set cscopequickfix=s-,c-,d-,i-,t-,e-
</code></pre>
<h2><span id="6-5-shi-yong">6.5 使用</span><a href="#6-5-shi-yong" class="header-anchor">#</a></h2><h3><span id="6-5-1-jian-li-shu-ju-ku-lian-jie">6.5.1 建立数据库连接</span><a href="#6-5-1-jian-li-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs add ./cscope.out
</code></pre>
<h3><span id="6-5-2-cha-xun-shu-ju-ku-lian-jie">6.5.2 查询数据库连接</span><a href="#6-5-2-cha-xun-shu-ju-ku-lian-jie" class="header-anchor">#</a></h3><pre><code>:cs show
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/25.png" alt="image"></p>
<h3><span id="6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi">6.5.3 查看引用调用位置</span><a href="#6-5-3-cha-kan-yin-yong-diao-yong-wei-zhi" class="header-anchor">#</a></h3><pre><code>:cs f s symbol #查看symbol和引用的地方, 如:cs find s IDLE_TIMEOUT_MS
</code></pre>
<p><img src="/2024/04/01/Vim%E9%85%8D%E7%BD%AE%E6%88%90%E7%B1%BB%E4%BC%BCsource-insight%E7%9A%84IDE/26.png" alt="image"></p>
<h1><span id="7-source-insight-kuo-zhan">7 source insight扩展</span><a href="#7-source-insight-kuo-zhan" class="header-anchor">#</a></h1><h2><span id="7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight">7.1 将kernel工程精确快速导入到sourceinsight</span><a href="#7-1-jiang-kernel-gong-cheng-jing-que-kuai-su-dao-ru-dao-sourceinsight" class="header-anchor">#</a></h2><p><a href="https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE">https://github.com/tonyho/Generate_Kernel_Uboot_Project_forIDE</a></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows10搭建NFS服务</title>
    <url>/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</a></li>
<li><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</a><ul>
<li><a href="#2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</a></li>
<li><a href="#2-2-bao-cun-pei-zhi">2.2 保存配置</a></li>
</ul>
</li>
<li><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3 让NFS服务通过防火墙</a></li>
<li><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</a></li>
<li><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</a></li>
<li><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</a></li>
<li><a href="#5-nfs-pei-zhi-wen-jian">5 nfs配置文件</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-hanewin-nfs-server-for-windows">1 下载haneWIN NFS Server for Windows</span><a href="#1-xia-zai-hanewin-nfs-server-for-windows" class="header-anchor">#</a></h1><p>链接如下：<br><a href="https://www.hanewin.net/nfs-e.htm">https://www.hanewin.net/nfs-e.htm</a><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/1.png" alt="image"></p>
<h1><span id="2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server">2 安装并且执行 haneWIN NFS Server</span><a href="#2-an-zhuang-bing-qie-zhi-xing-hanewin-nfs-server" class="header-anchor">#</a></h1><p>安装完后，打开hanWin如下：进入Edit-&gt;Preferences<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/2.png" alt="image"></p>
<p>进入Exports-&gt;Edit exports file<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/3.png" alt="image"></p>
<h2><span id="2-1-xiu-gai-pei-zhi-wen-jian">2.1 修改配置文件</span><a href="#2-1-xiu-gai-pei-zhi-wen-jian" class="header-anchor">#</a></h2><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/4.png" alt="image"><br>添加一行配置如下：<br><code>D:\ldc_res -name:nfs *(rw,sync,no_root_squash)</code><br>表示把D盘ldc_res目录当成nfs共享目录，-name:nfs表示客户端挂载时使用nfs表示D:\ldc_res路径<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code></p>
<h2><span id="2-2-bao-cun-pei-zhi">2.2 保存配置</span><a href="#2-2-bao-cun-pei-zhi" class="header-anchor">#</a></h2><p>勾选如下2个选项：仅对授权用户可见，通过nfs将导出添加到文件夹的上下文菜单<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/5.png" alt="image"></p>
<h1><span id="3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang">3  让NFS服务通过防火墙</span><a href="#3-rang-nfs-fu-wu-tong-guo-fang-huo-qiang" class="header-anchor">#</a></h1><p>方法1：打开电脑防火墙设置，将专用网络和公用网络的防火墙禁用。<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/6.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/7.png" alt="image"></p>
<p>方法2：设置防火墙入栈连接规则<br>查看haneWIN NFS server的端口映射：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/8.png" alt="image"><br>可以看到haneWIN使用的端口如下：</p>
<pre><code>TCP：111, 1058, 2049
UDP：111, 1058, 2049
</code></pre>
<p>进入windows防火墙高级设置，设置入栈规则-&gt;新建规则：</p>
<pre><code>规则类型选端口，
协议选TCP, 规则应用于特定本地端口，输入刚才查看的映射端口号：111，1058， 2049
操作选允许连接
配置文件将域，专用，公用网络全部勾选
最后设置好名称和描述
</code></pre>
<p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/9.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/10.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/11.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/12.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/13.png" alt="image"><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/14.png" alt="image"></p>
<h1><span id="4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi">4 开发板客服端挂载测试</span><a href="#4-kai-fa-ban-ke-fu-duan-gua-zai-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/15.png" alt="image"></p>
<p>设置板端IP地址：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/16.png" alt="image"><br>先确保windows和板端能ping通<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/17.png" alt="image"></p>
<h1><span id="4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban">4.1 挂载共享目录到开发板</span><a href="#4-1-gua-zai-gong-xiang-mu-lu-dao-kai-fa-ban" class="header-anchor">#</a></h1><p><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/18.png" alt="image"></p>
<p><code>mount -t nfs -o nolock 192.168.0.100:/nfs /mnt/sd</code><br>可以看到已经挂载上了，并且能访问挂载目录的文件</p>
<h1><span id="4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian">4.2 添加可写可执行权限</span><a href="#4-2-tian-jia-ke-xie-ke-zhi-xing-quan-xian" class="header-anchor">#</a></h1><p>挂载上后发现没有可写权限，<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/19.png" alt="image"></p>
<p>修改配置exports选项，添加-maproot:0 -public<br><code>D:\ldc_res -name:nfs -maproot:0 -public *(rw,sync,no_root_squash)</code><br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/20.png" alt="image"></p>
<p>可以可写可执行了：<br><img src="/2024/03/31/Windows10%E6%90%AD%E5%BB%BANFS%E6%9C%8D%E5%8A%A1/21.png" alt="image"></p>
<h1><span id="5-nfs-pei-zhi-wen-jian">5 nfs配置文件</span><a href="#5-nfs-pei-zhi-wen-jian" class="header-anchor">#</a></h1><pre><code>#
# exports example
#
# please read doc for a list of all options
# drive letters should be in upper case, because file-id returns upper case
#   by default (option setting) they are mapped to lower case for clients
# Option -range restricts access to specified address range
#   a list of addresses restricts to these clients only
# Option -readonly prohibits create/write/delete
# Option -name:&lt;x&gt; makes folder for clients avalailable as /&lt;x&gt;
# Option -maproot:&lt;uid&gt; maps unix root to specified &lt;uid&gt;
#   without it uid root -&gt; uid NOBODY
# Option -alldirs allows clients to mount folder or any subfolder
# Use UNC path specification for access to remote drive
# Hidden volumes without a drive letter can be mounted by volume GUID
#
C:\ftp -range 192.168.1.1 192.168.1.10
C:\video -readonly 192.168.1.1 192.168.1.4 192.18.1.23
C:\server -alldirs -name:server -maproot:0 -range 192.168.1.1 192.168.1.30
\\router\FRITZ.NAS\SanDisk-U3CruzerMicro-00 -name:fritz
\\?\Volume&#123;6afa3aa3-1b38-11e6-a140-0000fbaa0005&#125;\ -name:drive1
D:\ldc_res -name:nfs -public -maproot:0 *(rw,sync,no_root_squash)
E:\ -name:nfs_udisk -public -maproot:0 *(rw,sync,no_root_squash)
</code></pre>
<p>挂载：<br><code>mount -t nfs -o nolock 192.168.0.100:/nfs_udisk /mnt/</code></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb移植到arm开发板</title>
    <url>/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-gdb">1.下载gdb</a></li>
<li><a href="#2-bian-yi-an-zhuang">2.编译安装</a><ul>
<li><a href="#2-1-she-zhi-gong-ju-lian">2.1 设置工具链</a></li>
<li><a href="#2-2-bian-yi-ncurses">2.2 编译ncurses</a></li>
<li><a href="#2-3-bian-yi-gdb">2.3 编译gdb</a></li>
</ul>
</li>
<li><a href="#3-yun-xing-ce-shi">3.运行测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-gdb">1.下载gdb</span><a href="#1-xia-zai-gdb" class="header-anchor">#</a></h1><p><a href="https://ftp.gnu.org/gnu/gdb/">https://ftp.gnu.org/gnu/gdb/</a></p>
<p><a href="http://ftp.gnu.org/gnu/ncurses/">http://ftp.gnu.org/gnu/ncurses/</a></p>
<p>我这里选择的是gdb-7.12.tar.gz和ncurses-5.6.tar.gz</p>
<h1><span id="2-bian-yi-an-zhuang">2.编译安装</span><a href="#2-bian-yi-an-zhuang" class="header-anchor">#</a></h1><h2><span id="2-1-she-zhi-gong-ju-lian">2.1 设置工具链</span><a href="#2-1-she-zhi-gong-ju-lian" class="header-anchor">#</a></h2><p><code>export PATH=$PATH:/home/robin/share/cv183x/host-tools/gcc/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin/</code><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/1.png"><br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/2.png"></p>
<h2><span id="2-2-bian-yi-ncurses">2.2 编译ncurses</span><a href="#2-2-bian-yi-ncurses" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host=aarch64-linux-gnu-gcc --prefix=/home/robin/share/ncurses --without-ada --enable-termcap --with-shared CFLAGS=<span class="string">&quot;-O3 -fPIC&quot;</span></span><br><span class="line">    make</span><br><span class="line">	make install</span><br></pre></td></tr></table></figure>

<p>执行.&#x2F;configure时可能会失败，报错如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/3.png"><br>这是由于64bit machine配置引起的，进行如下操作后继续尝试。</p>
<pre><code>wget -O config.guess &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD&#39;
wget -O config.sub &#39;http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD&#39;
</code></pre>
<p>编译出的ncurses库如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/4.png"></p>
<h2><span id="2-3-bian-yi-gdb">2.3 编译gdb</span><a href="#2-3-bian-yi-gdb" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf gdb-7.12.tar.gz;</span><br><span class="line"><span class="built_in">cd</span> gdb-7.12</span><br><span class="line">./configure --host=aarch64-linux-gnu-gcc(--host=arm-linux-gnueabihf) --enable-shared --prefix=/home/robin/share/gdb --without-x --disable-gdbtk --disable-tui --without-included-regex --without-included-gettext  --disable-werror CFLAGS=<span class="string">&quot;-O0 -fPIC&quot;</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>.&#x2F;configure后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/5.png"></p>
<p>make install后结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/6.png"></p>
<h1><span id="3-yun-xing-ce-shi">3.运行测试</span><a href="#3-yun-xing-ce-shi" class="header-anchor">#</a></h1><p>1.将gdb和ncureses库cp到板子运行，结果如下：<br><img src="/2024/03/28/gdb%E7%A7%BB%E6%A4%8D%E5%88%B0arm%E5%BC%80%E5%8F%91%E6%9D%BF/7.png"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span><a href="#quick-start" class="header-anchor">#</a></h2><h3><span id="create-a-new-post">Create a new post</span><a href="#create-a-new-post" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span><a href="#run-server" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span><a href="#generate-static-files" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span><a href="#deploy-to-remote-sites" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>imx6ull裸机-ADC</title>
    <url>/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</a><ul>
<li><a href="#1-1-adcx-cfg-x-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</a></li>
<li><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</a></li>
<li><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</a></li>
<li><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</a></li>
<li><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</a></li>
<li><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</a></li>
</ul>
</li>
<li><a href="#2-liu-cheng-dai-ma">2 流程代码</a><ul>
<li><a href="#2-1-chu-shi-hua">2.1 初始化</a></li>
<li><a href="#2-2-zi-dong-xiao-zhun">2.2 自动校准</a></li>
<li><a href="#2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</a></li>
<li><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</a></li>
<li><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-imx6ull-ji-cun-qi">1 IMX6ULL寄存器</span><a href="#1-imx6ull-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi">1.1 ADCx_CFG(x&#x3D;1~2) 配置寄存器</span><a href="#1-1-adcx-cfg-x-x3d-1-2-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/1.jpg" alt="image"><br><strong>OVWREN</strong> (bit16)：数据复写使能位，为 1 的时候使能复写功能，为 0 的时候关闭复写功能。<br><strong>AVGS</strong>(bit15:14)：硬件平均次数，只有当 ADC1_GC 寄存器的 AVGE 位为 1 的时候才有效<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/2.png" alt="image"><br><strong>ADTRG</strong>(bit13)：转换触发选择。为 0 的时候选择软件触发，为 1 的时候，不选择软件触发。<br><strong>REFSEL</strong>(bit12:11)：参考电压选择，为 00 时选择 VREFH&#x2F;VREFL 这两个引脚上的电压为参考电压，正点原子 ALPHA 开发板上 VREFH 为 3.3V，VREFL 为 0V。<br><strong>ADHSC</strong>(bit10)：高速转换使能位，当为 0 时为正常模式，为 1 时为高速模式。<br><strong>ADSTS</strong>(bit9:8)：设置 ADC 的采样周期，与 ADLSMP 位一起决定采样周期：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/3.png" alt="image"><br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/4.png" alt="image"><br><strong>ADLSMP</strong>(bit4)：长采样周期使能位，当值为 0 时为短采样周期模式，为 1 时为长采样周期模式。搭配 ADSTS 位一起控制 ADC 的采样周期。<br><strong>MODE</strong>(bit3:2)：选择转换精度：<br><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/5.png" alt="image"><br><strong>ADICLK</strong>(bit1:0)：输入时钟源选择，为 00 的时候选择 IPG Clock，为 01 的时候选择 IPG Clock&#x2F;2，为 10 的时候无效，为 11 的时候选择呢 ADACK。本教程我们设置为 11，也就是选择ADACK 为 ADC 的时钟源。</p>
<h2><span id="1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi">1.2 ADCx_GC 通用控制寄存器</span><a href="#1-2-adcx-gc-tong-yong-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/6.png" alt="image"><br><strong>CAL</strong>(bit7)：当该位写入 1 时，硬件校准功能将会启动，校准过程中该位会一直保持 1，校准完成后会清 0，校准完成后需要检查一下ADC_GS[CALF]位，确认校准结果。<br><strong>ADCO</strong>(bit6)：连续转换使能位，只有在开启了硬件平均功能时有效，为 0 时只能转换一次或一组，当 ADCO 为 1 时可以连续转换或多组。<br><strong>AVGE</strong>(bit5)：硬件平均使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFE</strong>(bit4)：比较功能使能位。为 0 时关闭，为 1 时使能。<br><strong>ACFGT</strong>(bit3)：配置比较方法，如果为 0 的话就比较转换结果是否小于 ADC_CV 寄存器值，如果为 1 的话就比较装换结果是否大于或等于 ADC_CV 寄存器值。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>ACREN</strong>(bit2)：范围比较功能使能位。为 0 的话仅和 ADC_CV 里的 CV1 比较，为 1 的话和 ADC_CV 里的 CV1、CV2 比较。<br><strong>DMAEN</strong>(bit1)：DMA 功能使能位，为 0 是关闭，为 1 是开启<br><strong>ADACKEN</strong>(bit0)：异步时钟输出使能位，为 0 是关闭，为 1 时开启</p>
<h2><span id="1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi">1.3 ADCx_GS 通用状态寄存器</span><a href="#1-3-adcx-gs-tong-yong-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/7.png" alt="image"><br><strong>AWKST</strong>(bit2)：异步唤醒中断状态，为 1 时表示发生了异步唤醒中断。为 0 时没有发生异步中断。<br><strong>CALF</strong>(bit1)：校准失败标志位，为 0 的时候表示校准正常完成，为 1 的时候表示校准失败。<br><strong>ADACT</strong>(bit0)：转换活动标志，为 0 的时候表示转换没有进行，为 1 的时候表示正在进行转换。</p>
<h2><span id="1-4-adcx-hs-zhuang-tai-ji-cun-qi">1.4 ADCx_HS 状态寄存器</span><a href="#1-4-adcx-hs-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h2><p>COCO0表示转换完成.</p>
<p><strong>COCO0</strong>(bit0)：每次转换完成此位就会被置 1。</p>
<h2><span id="1-5-adcx-hc0-kong-zhi-ji-cun-qi">1.5 ADCx_HC0 控制寄存器</span><a href="#1-5-adcx-hc0-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/8.png" alt="image"><br><strong>AIEN</strong>(bit7)：转换完成中断控制位，为 1 的时候打开转换完成中断，为 0 的时候关闭。<br><strong>ADCH</strong>(bit4:0)：转换通道选择，可以设置为 00000~01111 分别对应通道 0~15。11001 为内部通道，用于 ADC 自测。</p>
<h2><span id="1-6-adcx-r0-shu-ju-ji-cun-qi">1.6 ADCx_R0 数据寄存器</span><a href="#1-6-adcx-r0-shu-ju-ji-cun-qi" class="header-anchor">#</a></h2><p><img src="/2024/05/01/imx6ull%E8%A3%B8%E6%9C%BA-ADC/9.png" alt="image"></p>
<h1><span id="2-liu-cheng-dai-ma">2 流程代码</span><a href="#2-liu-cheng-dai-ma" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、初始化 ADC1_CH1</span><br><span class="line"><span class="comment">//初始化 ADC1_CH1，配置 ADC 位数，时钟源，采样时间等。</span></span><br><span class="line"><span class="number">2</span>、校准 ADC</span><br><span class="line"><span class="comment">//ADC 在使用之前需要校准一次。</span></span><br><span class="line"><span class="number">3</span>、使能 ADC</span><br><span class="line"><span class="comment">//配置好 ADC 以后就可以开启了。</span></span><br><span class="line"><span class="number">4</span>、读取 ADC 值</span><br><span class="line"><span class="comment">//ADC 正常工作以后就可以读取 ADC 值。</span></span><br></pre></td></tr></table></figure>
<h2><span id="2-1-chu-shi-hua">2.1 初始化</span><a href="#2-1-chu-shi-hua" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc1ch1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ADC1-&gt;CFG = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;CFG |= (<span class="number">2</span> &lt;&lt; <span class="number">2</span>) | (<span class="number">3</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">    ADC1-&gt;GC = <span class="number">0</span>;</span><br><span class="line">    ADC1-&gt;GC |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* CFG寄存器</span></span><br><span class="line"><span class="comment">     * bit16        0       关闭复写功能</span></span><br><span class="line"><span class="comment">     * bit15:14     00      硬件平均设置为默认值，00的时候4次平均，</span></span><br><span class="line"><span class="comment">     *                      但是得ADC_GC寄存器的AVGE位置1来使能硬件平均</span></span><br><span class="line"><span class="comment">     * bit13        0       软件触发</span></span><br><span class="line"><span class="comment">     * bit12:1      00      参考电压为VREFH/VREFL，也就是3.3V/0V</span></span><br><span class="line"><span class="comment">     * bit10        0       正常转换速度</span></span><br><span class="line"><span class="comment">     * bit9:8       00      采样时间2/12，ADLSMP=0(短采样)的时候为2个周期</span></span><br><span class="line"><span class="comment">     *                      ADLSMP=1(长采样)的时候为12个周期</span></span><br><span class="line"><span class="comment">     * bit7         0       非低功耗模式</span></span><br><span class="line"><span class="comment">     * bit6:5       00      ADC时钟源1分频 </span></span><br><span class="line"><span class="comment">     * bit4         0       短采样</span></span><br><span class="line"><span class="comment">     * bit3:2       10      12位ADC</span></span><br><span class="line"><span class="comment">     * bit1:0       11      ADC时钟源选择ADACK</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="comment">/* GC寄存器</span></span><br><span class="line"><span class="comment">     * bit7     0       先关闭校准功能，后面会校准</span></span><br><span class="line"><span class="comment">     * bit6     0       关闭持续转换</span></span><br><span class="line"><span class="comment">     * bit5     0       关闭硬件平均功能</span></span><br><span class="line"><span class="comment">     * bit4     0       关闭比较功能</span></span><br><span class="line"><span class="comment">     * bit3     0       关闭比较的Greater Than功能</span></span><br><span class="line"><span class="comment">     * bit2     0       关闭比较的Range功能</span></span><br><span class="line"><span class="comment">     * bit1     0       关闭DMA</span></span><br><span class="line"><span class="comment">     * bit0     1       使能ADACK</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
<h2><span id="2-2-zi-dong-xiao-zhun">2.2 自动校准</span><a href="#2-2-zi-dong-xiao-zhun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">status_t</span> <span class="title function_">adc1_autocalibration</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">status_t</span> ret  = kStatus_Success;</span><br><span class="line">	ADC1-&gt;GS |= (<span class="number">1</span> &lt;&lt; <span class="number">2</span>);   <span class="comment">/* 清除CALF位，写1清零 */</span></span><br><span class="line">	ADC1-&gt;GC |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">/* 使能校准功能 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 校准完成之前GC寄存器的CAL位会一直为1，直到校准完成此位自动清零 */</span></span><br><span class="line">	<span class="keyword">while</span>((ADC1-&gt;GC &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>)) != <span class="number">0</span>) &#123; </span><br><span class="line">		<span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line">		<span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">			ret = kStatus_Fail;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 校准成功以后HS寄存器的COCO0位会置1 */</span></span><br><span class="line">	<span class="keyword">if</span>((ADC1-&gt;HS  &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>) </span><br><span class="line">		ret = kStatus_Fail;</span><br><span class="line">	<span class="comment">/* 如果GS寄存器的CALF位为1的话表示校准失败 */</span></span><br><span class="line">		<span class="keyword">if</span>((ADC1-&gt;GS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) != <span class="number">0</span>) </span><br><span class="line">		ret = kStatus_Fail;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2><span id="2-3-huo-qu-adc-yuan-shi-zhi">2.3 获取ADC原始值</span><a href="#2-3-huo-qu-adc-yuan-shi-zhi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">getadc_value</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 配置ADC通道1 */</span></span><br><span class="line">	ADC1-&gt;HC[<span class="number">0</span>] = <span class="number">0</span>;            <span class="comment">/* 关闭转换结束中断    */</span></span><br><span class="line">	ADC1-&gt;HC[<span class="number">0</span>] |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);     <span class="comment">/* 通道1            */</span></span><br><span class="line">	<span class="keyword">while</span>((ADC1-&gt;HS &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>);  <span class="comment">/* 等待转换完成 */</span></span><br><span class="line">	<span class="keyword">return</span> ADC1-&gt;R[<span class="number">0</span>];    <span class="comment">/* 返回ADC值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun">2.4 获取ADC原始值(多次取平均)</span><a href="#2-4-huo-qu-adc-yuan-shi-zhi-duo-ci-qu-ping-jun" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_average</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> times)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> temp_val = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> t;</span><br><span class="line">	<span class="keyword">for</span>(t = <span class="number">0</span>; t &lt; times; t++)&#123;</span><br><span class="line">		temp_val += getadc_value();</span><br><span class="line">		delayms(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp_val / times;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya">2.5 获取模数转换后的电压</span><a href="#2-5-huo-qu-mo-shu-zhuan-huan-hou-de-dian-ya" class="header-anchor">#</a></h2><p>由于精度为12 bit, ADC范围为[0, 4095]。同时电压满输出时为3.3v，因此当ADC数据拉满，得到3300mv，也就是3.3v</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">getadc_volt</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> adcvalue=<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	adcvalue = getadc_average(<span class="number">5</span>);</span><br><span class="line">	ret = (<span class="type">float</span>)adcvalue * (<span class="number">3300.0f</span> / <span class="number">4096.0f</span>);    	<span class="comment">/* 获取计算后的带小数的实际电压值 */</span></span><br><span class="line">	<span class="keyword">return</span>  ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull裸机-SPI</title>
    <url>/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-spi-jie-shao">1 SPI介绍</a><ul>
<li><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</a><ul>
<li><a href="#1-1-1-te-dian">1.1.1 特点</a></li>
<li><a href="#1-1-2-kuang-tu">1.1.2 框图</a></li>
<li><a href="#1-1-3-shi-xu">1.1.3 时序</a></li>
</ul>
</li>
<li><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</a><ul>
<li><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</a></li>
<li><a href="#1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</a><ul>
<li><a href="#1-2-2-1-rxdata">1.2.2.1 RXDATA</a></li>
<li><a href="#1-2-2-2-txdata">1.2.2.2 TXDATA</a></li>
<li><a href="#1-2-2-3-conreg">1.2.2.3 CONREG</a></li>
<li><a href="#1-2-2-4-configreg">1.2.2.4 CONFIGREG</a></li>
<li><a href="#1-2-2-5-statreg">1.2.2.5 STATREG</a></li>
<li><a href="#1-2-2-6-periodreg">1.2.2.6 PERIODREG</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</a></li>
</ul>
</li>
<li><a href="#2-spi-ying-yong">2 SPI 应用</a><ul>
<li><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</a><ul>
<li><a href="#2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</a></li>
<li><a href="#2-1-2-ying-yong-chang-jing">2.1.2 应用场景</a></li>
<li><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</a></li>
<li><a href="#2-1-4-dian-qi-te-xing">2.1.4 电器特性</a></li>
<li><a href="#2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</a></li>
<li><a href="#2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</a></li>
<li><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</a></li>
</ul>
</li>
<li><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</a><ul>
<li><a href="#2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</a></li>
<li><a href="#2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</a></li>
<li><a href="#2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</a></li>
<li><a href="#2-2-4-pwr-mgmt-1-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-3-dai-ma-jie-xi">2.3 代码解析</a><ul>
<li><a href="#2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-spi-jie-shao">1 SPI介绍</span><a href="#1-spi-jie-shao" class="header-anchor">#</a></h1><p><a href="https://fuzidage.github.io/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/">s3c2440裸机编程-SPI | Hexo (fuzidage.github.io)</a>有详细介绍SPI协议。</p>
<h2><span id="1-1-imx6ull-spi-kong-zhi-qi-jie-shao">1.1 imx6ull SPI控制器介绍</span><a href="#1-1-imx6ull-spi-kong-zhi-qi-jie-shao" class="header-anchor">#</a></h2><p>NXP的6ull参考手册第Chapter 20介绍了SPI控制器，<code>Enhanced Configurable SPI (ECSPI)</code> 。</p>
<h3><span id="1-1-1-te-dian">1.1.1 特点</span><a href="#1-1-1-te-dian" class="header-anchor">#</a></h3><p>①、全双工同步串行接口。<br>②、可配置的主&#x2F;从模式。<br>③、四个硬件片选信号，支持多从机。<br>④、发送和接收都有一个 32x64 的 FIFO。<br>⑤、片选信号 SS&#x2F;CS，时钟信号 SCLK 的极性相位<code>(CPOL,CPHA)</code>可配置。<br>⑥、支持 DMA<br>⑦、SCK最高可以到输入参考时钟高达60Mhz</p>
<h3><span id="1-1-2-kuang-tu">1.1.2 框图</span><a href="#1-1-2-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/1.png" alt="image"><br>最右边是引脚，SCLK,MISO,MOSI等，上面是外围总线，通过APB总线进行寄存器读写，<code>INTREG,CONREG</code>等等。TXDATA和TXDATA寄存器存放了要发送的数据和接收的收据。<br>时钟源来自<code>Reference Clock or Low Frequency Clock</code>。可选时钟源如下：这里选用<code>ecspi_clk_root</code>。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/2.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/3.png" alt="image"><br>① CSCDR2的ECSPI_CLK_SEL位设置为0，选择出PLL3_SW_CLK 进行8分频作为 ECSPI 根时钟源。PLL3_SW_CLK&#x3D;480MHz,8分频就是60MHz。<br>② CSCDR2 的 ECSPI_CLK_PODF位再次进行分频，ECSPI_CLK_PODF位设置成0，表示2^0分频，也就是1分频。<br>③ 最后ECSPI_CLK_ROOT就为60MHz</p>
<h3><span id="1-1-3-shi-xu">1.1.3 时序</span><a href="#1-1-3-shi-xu" class="header-anchor">#</a></h3><p>CPOL时钟极性 和CPHA时钟相位组合成了4种模式：</p>
<pre><code>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平
CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿
</code></pre>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/4.png" alt="image"></p>
<h2><span id="1-2-spi-kong-zhi-qi-ji-cun-qi">1.2 SPI控制器寄存器</span><a href="#1-2-spi-kong-zhi-qi-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng">1.2.1 控制器初始化流程</span><a href="#1-2-1-kong-zhi-qi-chu-shi-hua-liu-cheng" class="header-anchor">#</a></h3><p><strong>CONREG</strong>[EN]：复位，0表示复位<br><strong>CCM</strong>开启ECSPI时钟<br><strong>CONREG</strong>[EN]：复位，1表示反选复位<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/5.png" alt="image"></p>
<h3><span id="1-2-2-ji-cun-qi-jie-shao">1.2.2 寄存器介绍</span><a href="#1-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="1-2-2-1-rxdata">1.2.2.1 RXDATA</span><a href="#1-2-2-1-rxdata" class="header-anchor">#</a></h4><p><strong>RXDATA寄存器</strong>：接收数据寄存器，RR位的状态决定接受数据是否就绪<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/6.png" alt="image"></p>
<h4><span id="1-2-2-2-txdata">1.2.2.2 TXDATA</span><a href="#1-2-2-2-txdata" class="header-anchor">#</a></h4><p><strong>TXDATA寄存器</strong>:发送数据寄存器，实际传输的位数由相应SPI控制寄存器的BURST_LENGTH位来决定。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/7.png" alt="image"></p>
<h4><span id="1-2-2-3-conreg">1.2.2.3 CONREG</span><a href="#1-2-2-3-conreg" class="header-anchor">#</a></h4><p><strong>CONREG寄存器</strong>:控制寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/8.png" alt="image"><br><strong>EN</strong>:使能位，1为使能<br><strong>SMC</strong>:为1表示当数据写入TXFIFO时，立即启动SPI突发；这里使用该模式<br><strong>CHANNEL_MODE</strong>：硬件片选模式选择，bit[7:4]分别表示通道3到通道0，这里采用通道0设定为Master mode.因此bit[7:4]配置成1<br><strong>POST_DIVIDER</strong>:后分频，0到15表示2^n次方分频，比如0就是1分频，15就是2^15分频<br><strong>PRE_DIVIDER</strong>:前分频，0到15表示1到16分频<br>前面spi clk的时钟源为ECSPI_CLK_ROOT 60MHz，这里我们用6MHz，因此可以设置POST_DIVIDER&#x3D;0，PRE_DIVIDER&#x3D;9，表示10分频。<br><strong>CHANNEL_SELECT</strong>:通道选择，也就是硬件片选SS选择，这里选择SS0,通道0<br><strong>BURST_LENGTH</strong>：突发访问长度，这里我们用一次突发8bit, 配置成0x7</p>
<h4><span id="1-2-2-4-configreg">1.2.2.4 CONFIGREG</span><a href="#1-2-2-4-configreg" class="header-anchor">#</a></h4><p><strong>CONFIGREG寄存器</strong>：配置寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/9.png" alt="image"><br><strong>SCLK_PHA</strong>：时钟相位，SCLK_PHA[3:0]分别对应通道3~0，设置为0表示第一个时钟沿采集数据，设置成1表示第二个时钟沿采集数据。（同POL组成4种模式）<br><strong>SCLK_POL</strong>：时钟极性，表示时钟初始空闲时的电平，0为低电平，1为高电平。（同PHA组成4种模式）<br><strong>SS_CTL</strong>:硬件片选的wave form select,这个用不上设置成0<br><strong>SS_POL</strong>：硬件片选的极性选择，用不上设置成0<br><strong>DATA_CTL</strong>：数据线空闲时电平状态，我们设置成0表示高电平<br><strong>SCLK_CTL</strong>：时钟线空闲时电平状态，我们设置成0表示低电平（POL设置了时钟初始空闲时的电平为低电平)<br><strong>HT_LENGTH</strong>: HT Mode不用，无需配置</p>
<h4><span id="1-2-2-5-statreg">1.2.2.5 STATREG</span><a href="#1-2-2-5-statreg" class="header-anchor">#</a></h4><p><strong>STATREG寄存器</strong>：状态寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/10.png" alt="image"><br><strong>TE</strong>:TXFIFO empty, 为1表示TXFIFO为空，0表示TXFIFO还没空，因此往TXDATA发送数据时，需要先等待TXFIFO为空。<br><strong>RR</strong>: RXFIFO Ready,1表示有数据，0表示数据还没ready.读取RXDATA需要等RXFIFO先ready。</p>
<h4><span id="1-2-2-6-periodreg">1.2.2.6 PERIODREG</span><a href="#1-2-2-6-periodreg" class="header-anchor">#</a></h4><p><strong>PERIODREG寄存器</strong>：采样周期寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/11.png" alt="image"><br><strong>SAMPLE_ PERIOD</strong>:突发访问时的等待周期，表示等待多少个时钟周期后进行一下次突发访问。我们设置为0x2000。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/12.png" alt="image"><br><strong>CSRC</strong>: 等待周期的单位，0表示以SPI clk为单位, 1表示以low-frequency reference clk 32.768KHz为单位。<br><strong>CSD_CTL</strong>:硬件片选延时，表示片选后多少个时钟周期才可以进行数据传输。（这里不用，我们用软件片选)</p>
<h2><span id="1-3-spi-kong-zhi-qi-dai-ma-bian-xie">1.3 SPI控制器代码编写</span><a href="#1-3-spi-kong-zhi-qi-dai-ma-bian-xie" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(ECSPI_Type *base)</span> &#123;</span><br><span class="line">	<span class="comment">/* 配置CONREG寄存器</span></span><br><span class="line"><span class="comment">	 * bit0 : 		1 	使能ECSPI</span></span><br><span class="line"><span class="comment">	 * bit3 : 		1	当向TXFIFO写入数据以后立即开启SPI突发。</span></span><br><span class="line"><span class="comment">	 * bit[7:4] : 	0001 SPI通道0主模式，根据实际情况选择，</span></span><br><span class="line"><span class="comment">	 *            	   	开发板上的ICM-20608接在SS0上，所以设置通道0为主模式</span></span><br><span class="line"><span class="comment">	 * bit[19:18]:	00 	选中通道0(其实不需要，因为片选信号我们我们自己控制)</span></span><br><span class="line"><span class="comment">	 * bit[31:20]:	0x7	突发长度为8个bit。 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONREG = <span class="number">0</span>; <span class="comment">/* 先清除控制寄存器 */</span></span><br><span class="line">	base-&gt;CONREG |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">7</span> &lt;&lt; <span class="number">20</span>); <span class="comment">/* 配置CONREG寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ECSPI通道0设置,即设置CONFIGREG寄存器</span></span><br><span class="line"><span class="comment">	 * bit0:	0 通道0 PHA为0</span></span><br><span class="line"><span class="comment">	 * bit4:	0 通道0 SCLK高电平有效</span></span><br><span class="line"><span class="comment">	 * bit8: 	0 通道0片选信号 当SMC为1的时候此位无效</span></span><br><span class="line"><span class="comment">	 * bit12：	0 通道0 POL为0</span></span><br><span class="line"><span class="comment">	 * bit16：	0 通道0 数据线空闲时高电平</span></span><br><span class="line"><span class="comment">	 * bit20:	0 通道0 时钟线空闲时低电平</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONFIGREG = <span class="number">0</span>; 		<span class="comment">/* 设置通道寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*  </span></span><br><span class="line"><span class="comment">	 * ECSPI通道0设置，设置采样周期</span></span><br><span class="line"><span class="comment">	 * bit[14:0] :	0X2000  采样等待周期，比如当SPI时钟为10MHz的时候</span></span><br><span class="line"><span class="comment">	 *  		    0X2000就等于1/10000 * 0X2000 = 0.8192ms，也就是连续</span></span><br><span class="line"><span class="comment">	 *          	读取数据的时候每次之间间隔0.8ms</span></span><br><span class="line"><span class="comment">	 * bit15	 :  0  采样时钟源为SPI CLK</span></span><br><span class="line"><span class="comment">	 * bit[21:16]:  0  片选延时，可设置为0~63</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;PERIODREG = <span class="number">0X2000</span>;		<span class="comment">/* 设置采样周期寄存器 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ECSPI的SPI时钟配置，SPI的时钟源来源于pll3_sw_clk/8=480/8=60MHz</span></span><br><span class="line"><span class="comment">	 * 通过设置CONREG寄存器的PER_DIVIDER(bit[11:8])和POST_DIVEDER(bit[15:12])来</span></span><br><span class="line"><span class="comment">	 * 对SPI时钟源分频，获取到我们想要的SPI时钟：</span></span><br><span class="line"><span class="comment">	 * SPI CLK = (SourceCLK / PER_DIVIDER) / (2^POST_DIVEDER)</span></span><br><span class="line"><span class="comment">	 * 比如我们现在要设置SPI时钟为6MHz，那么PER_DIVEIDER和POST_DEIVIDER设置如下：</span></span><br><span class="line"><span class="comment">	 * PER_DIVIDER = 0X9。</span></span><br><span class="line"><span class="comment">	 * POST_DIVIDER = 0X0。</span></span><br><span class="line"><span class="comment">	 * SPI CLK = 60000000/(0X9 + 1) = 60000000=6MHz</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;CONREG &amp;= ~((<span class="number">0XF</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">0XF</span> &lt;&lt; <span class="number">8</span>));	<span class="comment">/* 清除PER_DIVDER和POST_DIVEDER以前的设置 */</span></span><br><span class="line">	base-&gt;CONREG |= (<span class="number">0X9</span> &lt;&lt; <span class="number">12</span>);					<span class="comment">/* 设置SPI CLK = 6MHz */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: SPI通道0发送/接收一个字节的数据</span></span><br><span class="line"><span class="comment"> * @param - base	: 要使用的SPI</span></span><br><span class="line"><span class="comment"> * @param - txdata	: 要发送的数据</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">spich0_readwrite_byte</span><span class="params">(ECSPI_Type *base, <span class="type">unsigned</span> <span class="type">char</span> txdata)</span> &#123; </span><br><span class="line">	<span class="type">uint32_t</span>  spirxdata = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span>  spitxdata = txdata;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 选择通道0 */</span></span><br><span class="line">	base-&gt;CONREG &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line">	base-&gt;CONREG |= (<span class="number">0</span> &lt;&lt; <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待发送FIFO为空 */</span></span><br><span class="line">		base-&gt;TXDATA = spitxdata;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>((base-&gt;STATREG &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) == <span class="number">0</span>)&#123;&#125; <span class="comment">/* 等待接收FIFO有数据 */</span></span><br><span class="line">		spirxdata = base-&gt;RXDATA;</span><br><span class="line">	<span class="keyword">return</span> spirxdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-spi-ying-yong">2 SPI 应用</span><a href="#2-spi-ying-yong" class="header-anchor">#</a></h1><h2><span id="2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g">2.1 6轴陀螺仪加速度传感器ICM-20608-G</span><a href="#2-1-6-zhou-tuo-luo-yi-jia-su-du-chuan-gan-qi-icm-20608-g" class="header-anchor">#</a></h2><h3><span id="2-1-1-icm-20608-g-gai-shu">2.1.1 ICM-20608-G概述</span><a href="#2-1-1-icm-20608-g-gai-shu" class="header-anchor">#</a></h3><p><code>The ICM-20608-G is a 6-axis MotionTracking device that combines a 3-axis gyroscope, and a 3-axis accelerometer in a small 3x3x0.75mm (16-pin LGA) package. The gyroscope has a programmable full-scale range of ±250, ±500, ±1000, and ±2000 degrees/sec. The accelerometer has a user programmable accelerometer full-scale range of ±2g, ±4g, ±8g, and ±16g. Other industry-leading features include on-chip 16-bit ADCs, programmable digital filters, an embedded temperature sensor, and programmable interrupts. The device features I2 C and SPI serial interfaces, a VDD operating range of 1.71 to 3.45V, and a separate digital IO supply, VDDIO from 1.71V to 3.45V. Communication with all registers of the device is performed using either I2 C at 400kHz or SPI at 8MHz.</code><br>1.包含3轴陀螺仪数据和3轴加速度数据。<br>2.陀螺仪和加速度量程可设定，陀螺仪量程可设定位+-250，+-500，+-1000， +-2000角度每秒。加速度同理也可设定量程。<br>3.精度为16bit ADC转换。<br>4.使用I2C&#x2F;SPI接口通信，I2C速率高达400KHz, SPI高达8MHz。</p>
<h3><span id="2-1-2-ying-yong-chang-jing">2.1.2 应用场景</span><a href="#2-1-2-ying-yong-chang-jing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/13.png" alt="image"></p>
<h3><span id="2-1-3-tuo-luo-yi-he-jia-su-du-te-xing">2.1.3 陀螺仪和加速度特性</span><a href="#2-1-3-tuo-luo-yi-he-jia-su-du-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/14.png" alt="image"></p>
<h3><span id="2-1-4-dian-qi-te-xing">2.1.4 电器特性</span><a href="#2-1-4-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/15.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/16.png" alt="image"><br>可以看到FS_SEL，AFS_SEL用来选择陀螺仪和加速度计的量程。举个例子，当角速度量程为+-250时，那么ADC的数据为多少表示为1度呢？已知ADC精度16bit, 数据范围[0,65535], 假如ADC的数据为x, 那么x&#x2F;65636 &#x3D; 1&#x2F;500,算出x&#x3D; 131.272x,对应表格数据中的131。加速度的换算公式也是同理， 当AFS_SEL&#x3D;0时，x&#x2F;65536 &#x3D; 1&#x2F;4， x&#x3D;16384。</p>
<h3><span id="2-1-5-jiao-liu-dian-qi-te-xing">2.1.5 交流电器特性</span><a href="#2-1-5-jiao-liu-dian-qi-te-xing" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/17.png" alt="image"><br>当用i2c通信，AD0引脚决定i2c从地址是0x68还是0x69。可以看到power-on reset上电时序，需要Valid power-on RESET时间最少0.01ms, 从启动到寄存器读写等11ms。</p>
<h3><span id="2-1-6-gong-zuo-mo-shi">2.1.6 工作模式</span><a href="#2-1-6-gong-zuo-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/18.png" alt="image"></p>
<h3><span id="2-1-7-spi-fang-shi-ji-cun-qi-fang-wen">2.1.7 SPI方式寄存器访问</span><a href="#2-1-7-spi-fang-shi-ji-cun-qi-fang-wen" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/19.png" alt="image"><br>数据上升沿锁存，下降沿数据发生改变。最大高达8MHz时钟，一次读写需要16个或者更多时钟周期，第一个字节传输寄存器地址，第二个字节传输数据。首字节的首位表示是读还是写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ICM20608_CSN(n)    (n ? gpio_pinwrite(GPIO1, 20, 1) : gpio_pinwrite(GPIO1, 20, 0))   <span class="comment">/* SPI片选信号	 */</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description  : 写ICM20608指定寄存器</span></span><br><span class="line"><span class="comment"> * @param - reg  : 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @param - value: 要写入的值</span></span><br><span class="line"><span class="comment"> * @return		 : 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_write_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> value)</span> &#123;</span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment">	 * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment">	 * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg &amp;= ~<span class="number">0X80</span>;	</span><br><span class="line"></span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);						<span class="comment">/* 使能SPI传输			*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg); 	<span class="comment">/* 发送寄存器地址		*/</span> </span><br><span class="line">	spich0_readwrite_byte(ECSPI3, value);	<span class="comment">/* 发送要写入的值			*/</span></span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);						<span class="comment">/* 禁止SPI传输			*/</span></span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 读取ICM20608寄存器值</span></span><br><span class="line"><span class="comment"> * @param - reg	: 要读取的寄存器地址</span></span><br><span class="line"><span class="comment"> * @return 		: 读取到的寄存器值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">icm20608_read_reg</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> reg_val;	   	</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址</span></span><br><span class="line"><span class="comment">	 * 只有低7位有效,寄存器地址最高位是读/写标志位</span></span><br><span class="line"><span class="comment">	 * 读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg |= <span class="number">0x80</span>; 	</span><br><span class="line"></span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);               					<span class="comment">/* 使能SPI传输	 		*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg);     		<span class="comment">/* 发送寄存器地址  		*/</span> </span><br><span class="line">	reg_val = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);	<span class="comment">/* 读取寄存器的值 			*/</span></span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);                				<span class="comment">/* 禁止SPI传输 			*/</span></span><br><span class="line">	<span class="keyword">return</span>(reg_val);               	 				<span class="comment">/* 返回读取到的寄存器值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-icm-20608-g-ji-cun-qi-miao-shu">2.2 ICM-20608-G寄存器描述</span><a href="#2-2-icm-20608-g-ji-cun-qi-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/20.png" alt="image"><br>ICM-20608-G寄存器的地址和数据都是单字节。</p>
<h3><span id="2-2-1-kong-zhi-ji-cun-qi">2.2.1 控制寄存器</span><a href="#2-2-1-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>控制配置寄存器0x1a,0x1b,0x1c,0x1d，设置量程等配置。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/21.png" alt="image"><br>0x19设置分频，不分频，配成0<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/22.png" alt="image"><br>0x1a设置陀螺仪低通滤波带宽BW&#x3D;20Hz，配成0x4.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/23.png" alt="image"><br>0x1b设置gyro量程，配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/24.png" alt="image"><br>0x1c设置加速度计的量程，也配成最大0x18.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/25.png" alt="image"><br>0x1d设置加速度计低通滤波BW&#x3D;21.2Hz<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/26.png" alt="image"><br> 0x1e设置low power，配成0，关闭低功耗.<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/27.png" alt="image"><br>0x23设置fifo功能，这里配置0x0,禁用fifo.</p>
<p>设定量程，配置相关参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line">icm20608_write_reg(ICM20_SMPLRT_DIV, <span class="number">0x00</span>); 	<span class="comment">/* 输出速率是内部采样率					*/</span></span><br><span class="line">icm20608_write_reg(ICM20_GYRO_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 陀螺仪±2000dps量程 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG, <span class="number">0x18</span>); 	<span class="comment">/* 加速度计±16G量程 					*/</span></span><br><span class="line">icm20608_write_reg(ICM20_CONFIG, <span class="number">0x04</span>); 		<span class="comment">/* 陀螺仪低通滤波BW=20Hz 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_ACCEL_CONFIG2, <span class="number">0x04</span>); 	<span class="comment">/* 加速度计低通滤波BW=21.2Hz 			*/</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_2, <span class="number">0x00</span>); 	<span class="comment">/* 打开加速度计和陀螺仪所有轴 				*/</span></span><br><span class="line">icm20608_write_reg(ICM20_LP_MODE_CFG, <span class="number">0x00</span>); 	<span class="comment">/* 关闭低功耗 						*/</span></span><br><span class="line">icm20608_write_reg(ICM20_FIFO_EN, <span class="number">0x00</span>);		<span class="comment">/* 关闭FIFO						*/</span></span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-shu-ju-ji-cun-qi">2.2.2 数据寄存器</span><a href="#2-2-2-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p>数据寄存器0x3b<del>0x48表示加速度和陀螺仪数据，可以看到该传感器的寄存器地址都是单字节，ADC精度16bit,因此需要2个寄存器来表示一个轴的坐标数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/28.png" alt="image"><br>0x3b-0x40表示加速度计3轴数据。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/29.png" alt="image"><br>0x42 温度数据<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/30.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/31.png" alt="image"><br>0x43</del>0x48陀螺仪3轴数据。</p>
<h3><span id="2-2-3-who-am-i-ji-cun-qi">2.2.3 WHO_AM_I寄存器</span><a href="#2-2-3-who-am-i-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/32.png" alt="image"><br>寄存器表示设备ID,默认0xAF.</p>
<h3><span id="2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi">2.2.4 PWR_MGMT_1&#x2F;PWR_MGMT_2寄存器</span><a href="#2-2-4-pwr-mgmt-1-x2f-pwr-mgmt-2-ji-cun-qi" class="header-anchor">#</a></h3><p>电源管理模式寄存器<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/33.png" alt="image"><br>可以看到bit6默认是一个sleep mode, bit7是复位信号，复位后，默认bit6会变成1，进入睡眠模式。Bit4 陀螺仪待机，bit3关闭温度传感器等等都不要开启，设置成0，bit[2:0]时钟选择自动。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/34.png" alt="image"><br>可以看到设置成0，6轴数据全使能</p>
<p>复位初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x80</span>);		<span class="comment">/* 复位，复位后为0x40,睡眠模式 			*/</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">icm20608_write_reg(ICM20_PWR_MGMT_1, <span class="number">0x01</span>);		<span class="comment">/* 关闭睡眠，自动选择时钟 					*/</span></span><br><span class="line">delayms(<span class="number">50</span>);</span><br><span class="line">regvalue = icm20608_read_reg(ICM20_WHO_AM_I);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;icm20608 id = %#X\r\n&quot;</span>, regvalue);</span><br></pre></td></tr></table></figure>

<h1><span id="2-3-dai-ma-jie-xi">2.3 代码解析</span><a href="#2-3-dai-ma-jie-xi" class="header-anchor">#</a></h1><p>icm20608.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ICM20608寄存器 </span></span><br><span class="line"><span class="comment"> *复位后所有寄存器地址都为0，除了</span></span><br><span class="line"><span class="comment"> *Register 107(0X6B) Power Management 1 	= 0x40</span></span><br><span class="line"><span class="comment"> *Register 117(0X75) WHO_AM_I 				= 0xAF或0xAE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* 陀螺仪和加速度自测(出产时设置，用于与用户的自检输出值比较） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_GYRO		0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_GYRO		0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_GYRO		0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_X_ACCEL		0x0D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Y_ACCEL		0x0E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SELF_TEST_Z_ACCEL		0x0F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRH			0x13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XG_OFFS_USRL			0x14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRH			0x15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YG_OFFS_USRL			0x16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRH			0x17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZG_OFFS_USRL			0x18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SMPLRT_DIV			0x19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_CONFIG				0x1A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_CONFIG			0x1B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG			0x1C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_CONFIG2			0x1D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_LP_MODE_CFG			0x1E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_WOM_THR			0x1F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_EN				0x23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FSYNC_INT				0x36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_PIN_CFG			0x37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_ENABLE			0x38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_INT_STATUS			0x3A</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_H			0x3B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_XOUT_L			0x3C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_H			0x3D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_YOUT_L			0x3E</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_H			0x3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_ZOUT_L			0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 温度输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_H			0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_TEMP_OUT_L			0x42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 陀螺仪输出 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_H			0x43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_XOUT_L			0x44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_H			0x45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_YOUT_L			0x46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_H			0x47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_GYRO_ZOUT_L			0x48</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_SIGNAL_PATH_RESET		0x68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ACCEL_INTEL_CTRL 		0x69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_USER_CTRL				0x6A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_1			0x6B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_PWR_MGMT_2			0x6C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTH			0x72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_COUNTL			0x73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_FIFO_R_W				0x74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_WHO_AM_I 				0x75</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 加速度静态偏移 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_H			0x77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_XA_OFFSET_L			0x78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_H			0x7A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_YA_OFFSET_L			0x7B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_H			0x7D</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	ICM20_ZA_OFFSET_L 			0x7E</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ICM20608结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> &#123;</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_adc;		<span class="comment">/* 陀螺仪X轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_adc;		<span class="comment">/* 陀螺仪Y轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_adc;		<span class="comment">/* 陀螺仪Z轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_adc;		<span class="comment">/* 加速度计X轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_adc;		<span class="comment">/* 加速度计Y轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_adc;		<span class="comment">/* 加速度计Z轴原始值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_adc;		<span class="comment">/* 温度原始值 				*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 下面是计算得到的实际值，扩大100倍 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_x_act;		<span class="comment">/* 陀螺仪X轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_y_act;		<span class="comment">/* 陀螺仪Y轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> gyro_z_act;		<span class="comment">/* 陀螺仪Z轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_x_act;		<span class="comment">/* 加速度计X轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_y_act;		<span class="comment">/* 加速度计Y轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> accel_z_act;		<span class="comment">/* 加速度计Z轴实际值 			*/</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> temp_act;		<span class="comment">/* 温度实际值 				*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">icm20608_dev_struc</span> <span class="title">icm20608_dev</span>;</span>	<span class="comment">/* icm20608设备 */</span></span><br></pre></td></tr></table></figure>
<p><code>icm20608.h</code>定义了该模块的6轴数据寄存器地址和值。<br> 连续顺序读写模块：前一个字节得写入寄存器地址，然后每次突发读取1字节数据，注意：这里不用每次都发送寄存器地址，顺序访问时，地址自动增长，即可顺序依次访问寄存器。如：向<code>0x00~0x05</code>地址依次发送<code>6 byte</code>数据，<code>icm20608_read_len(0x00, buf, 6)</code>;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">icm20608_read_len</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> reg, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">char</span> len)</span> &#123;  </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	<span class="comment">/* ICM20608在使用SPI接口的时候寄存器地址，只有低7位有效,</span></span><br><span class="line"><span class="comment">	 * 寄存器地址最高位是读/写标志位读的时候要为1，写的时候要为0。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	reg |= <span class="number">0x80</span>; </span><br><span class="line">	ICM20608_CSN(<span class="number">0</span>);               				<span class="comment">/* 使能SPI传输	 		*/</span></span><br><span class="line">	spich0_readwrite_byte(ECSPI3, reg);			<span class="comment">/* 发送寄存器地址  		*/</span>   	   </span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)					<span class="comment">/* 顺序读取寄存器的值 			*/</span></span><br><span class="line">		buf[i] = spich0_readwrite_byte(ECSPI3, <span class="number">0XFF</span>);	</span><br><span class="line">	ICM20608_CSN(<span class="number">1</span>);                			<span class="comment">/* 禁止SPI传输 			*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>icm20608_gyro_scaleget()</code>和<code>icm20608_accel_scaleget()</code>是获取陀螺仪和加速度计的最小单位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">icm20608_gyro_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">float</span> gyroscale;</span><br><span class="line">	data = (icm20608_read_reg(ICM20_GYRO_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line">	<span class="keyword">switch</span>(data) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			gyroscale = <span class="number">131</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			gyroscale = <span class="number">65.5</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			gyroscale = <span class="number">32.8</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			gyroscale = <span class="number">16.4</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gyroscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 获取加速度计的分辨率</span></span><br><span class="line"><span class="comment"> * @param		: 无</span></span><br><span class="line"><span class="comment"> * @return		: 获取到的分辨率</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">icm20608_accel_scaleget</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> accelscale;</span><br><span class="line">	data = (icm20608_read_reg(ICM20_ACCEL_CONFIG) &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0X3</span>;</span><br><span class="line">	<span class="keyword">switch</span>(data) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">			accelscale = <span class="number">16384</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			accelscale = <span class="number">8192</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			accelscale = <span class="number">4096</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			accelscale = <span class="number">2048</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> accelscale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description : 读取ICM20608的加速度、陀螺仪和温度原始值</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">icm20608_getdata</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">float</span> gyroscale;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> accescale;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">14</span>];</span><br><span class="line"></span><br><span class="line">	icm20608_read_len(ICM20_ACCEL_XOUT_H, data, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">	gyroscale = icm20608_gyro_scaleget();</span><br><span class="line">	accescale = icm20608_accel_scaleget();</span><br><span class="line"></span><br><span class="line">	icm20608_dev.accel_x_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">1</span>]);</span><br><span class="line">	icm20608_dev.accel_y_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">3</span>]);</span><br><span class="line">	icm20608_dev.accel_z_adc = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">5</span>]);</span><br><span class="line">	icm20608_dev.temp_adc    = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">7</span>]);</span><br><span class="line">	icm20608_dev.gyro_x_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">8</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">9</span>]);</span><br><span class="line">	icm20608_dev.gyro_y_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">10</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">11</span>]);</span><br><span class="line">	icm20608_dev.gyro_z_adc  = (<span class="type">signed</span> <span class="type">short</span>)((data[<span class="number">12</span>] &lt;&lt; <span class="number">8</span>) | data[<span class="number">13</span>]);</span><br><span class="line">	<span class="comment">/* 计算实际值 */</span></span><br><span class="line">	icm20608_dev.gyro_x_act = ((<span class="type">float</span>)(icm20608_dev.gyro_x_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.gyro_y_act = ((<span class="type">float</span>)(icm20608_dev.gyro_y_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.gyro_z_act = ((<span class="type">float</span>)(icm20608_dev.gyro_z_adc)  / gyroscale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	icm20608_dev.accel_x_act = ((<span class="type">float</span>)(icm20608_dev.accel_x_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.accel_y_act = ((<span class="type">float</span>)(icm20608_dev.accel_y_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line">	icm20608_dev.accel_z_act = ((<span class="type">float</span>)(icm20608_dev.accel_z_adc) / accescale) * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	icm20608_dev.temp_act = (((<span class="type">float</span>)(icm20608_dev.temp_adc) - <span class="number">25</span> ) / <span class="number">326.8</span> + <span class="number">25</span>) * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于前面设置的陀螺仪和加速度计量程都是拉满的设置的<code>0x18</code>，因此<code>gyroscale</code>读出来就是对应<code>16.4</code>（最小单位），<code>accescale</code>读出来就是对应<code>2048</code>（最小单位）<br>然后读出<code>14 byte</code>数据，组装成short类型数据，16位ADC, 一轴数据刚好16位数据。最后转成人眼直观的实际的陀螺仪和加速度计数据，放大了100倍，放大一百倍目的是为了能够将小数的部分也能记录下来。<br>以陀螺仪为例：量程位<code>+-2000</code>时，换算出16.4为<code>1°</code>。同理以加速度计为例：量程为<code>+-16</code>是，换算出<code>2048</code>为1g。</p>
<p>可以看到用到了浮点运算，那么IMX6ULL属于armv7,支持硬件浮点运算：执行浮点运算前调用<code>imx6ul_hardfpu_enable()</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 使能I.MX6U的硬件NEON和FPU</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">imx6ul_hardfpu_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> cpacr;</span><br><span class="line">	<span class="type">uint32_t</span> fpexc;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能NEON和FPU */</span></span><br><span class="line">	cpacr = __get_CPACR();</span><br><span class="line">	cpacr = (cpacr &amp; ~(CPACR_ASEDIS_Msk | CPACR_D32DIS_Msk))</span><br><span class="line">		   |  (<span class="number">3UL</span> &lt;&lt; CPACR_cp10_Pos) | (<span class="number">3UL</span> &lt;&lt; CPACR_cp11_Pos);</span><br><span class="line">	__set_CPACR(cpacr);</span><br><span class="line">	fpexc = __get_FPEXC();</span><br><span class="line">	fpexc |= <span class="number">0x40000000</span>UL;</span><br><span class="line">	__set_FPEXC(fpexc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打开<code>Cortex-A7 MPCore Technical Reference Manual</code>的<code>4.3.34 Non-Secure Access Control Register</code>介绍：开启硬件NEON和FPU<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/35.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/36.png" alt="image"><br>打开<code>ARM®Architecture Reference Manual ARMv7-A and ARMv7-R edition</code>介绍FPEXC寄存器， bit30置1，使能浮点运算<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/37.png" alt="image"></p>
<p>打开IM6ULL 参考手册：可见IMX6U支持浮点单元：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/38.png" alt="image"><br>编译选项开启硬件浮点编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">		`<span class="variable">$(CC)</span> -Wall **-march=armv7-a -mfpu=neon-vfpv4 -mfloat-abi=hard -Wa,-mimplicit-it=thumb** -nostdlib -fno-builtin -c -O2  <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span>`</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-1-ce-shi-xiao-guo">2.3.1 测试效果</span><a href="#2-3-1-ce-shi-xiao-guo" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 指定的位置显示小数数据,比如5123，显示为51.23</span></span><br><span class="line"><span class="comment"> * @param - x	: X轴位置</span></span><br><span class="line"><span class="comment"> * @param - y 	: Y轴位置</span></span><br><span class="line"><span class="comment"> * @param - size: 字体大小</span></span><br><span class="line"><span class="comment"> * @param - num : 要显示的数据，实际小数扩大100倍，</span></span><br><span class="line"><span class="comment"> * @return 		: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decimals_display</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> x, <span class="type">unsigned</span> <span class="type">short</span> y, <span class="type">unsigned</span> <span class="type">char</span> size, <span class="type">signed</span> <span class="type">int</span> num)</span> &#123;</span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> integ; 	<span class="comment">/* 整数部分 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> fract;	<span class="comment">/* 小数部分 */</span></span><br><span class="line">	<span class="type">signed</span> <span class="type">int</span> uncomptemp = num; </span><br><span class="line">	<span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">		uncomptemp = -uncomptemp;</span><br><span class="line">	integ = uncomptemp / <span class="number">100</span>;</span><br><span class="line">	fract = uncomptemp % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">if</span>(num &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">&quot;-%d.%d&quot;</span>, integ, fract);</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d.%d&quot;</span>, integ, fract);</span><br><span class="line">	lcd_fill(x, y, x + <span class="number">60</span>, y + size, tftlcd_dev.backcolor);</span><br><span class="line">	lcd_show_string(x, y, <span class="number">60</span>, size, size, buf); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/39.png" alt="image"><br>静止时，有一个z方向的加速度2048，也就是1g,刚好时重力加速度。静止时，陀螺仪几乎没有角速度，因此3轴数据都几乎为0°。</p>
<p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-SPI/40.png" alt="image"><br>左右晃动时，陀螺仪数据明显增加。</p>
]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>imx6ull裸机-定时器</title>
    <url>/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-rtc-ding-shi-qi">1 RTC定时器</a><ul>
<li><a href="#1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</a></li>
<li><a href="#1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</a></li>
<li><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</a></li>
<li><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</a></li>
</ul>
</li>
<li><a href="#2-pwm-ding-shi-qi">2 PWM定时器</a><ul>
<li><a href="#2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</a></li>
<li><a href="#2-2-pwm-kong-zhi-qi">2.2 PWM控制器</a><ul>
<li><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</a></li>
<li><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</a></li>
<li><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</a></li>
<li><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</a></li>
<li><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</a></li>
</ul>
</li>
<li><a href="#2-3-ce-shi">2.3 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-rtc-ding-shi-qi">1 RTC定时器</span><a href="#1-rtc-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="1-1-rtc-ding-shi-qi-jie-shao">1.1 RTC定时器介绍</span><a href="#1-1-rtc-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>RTC定时器被叫做实时时钟（real time clock）。 CPU内部有很多定时器，像看门狗WDT，PWM定时器，高精度定时器Timer等等, 只在“启动”即“通电时”运行，断电时停止。当然，如果时钟不能连续跟踪时间，则必须手动设置。那么当关机后就没办法自动计数统计时间了。<br>定时器的本质就是计数器，有向上计数，也有向下计数。RTC有一个与主机单独分离的电源，如纽扣电池（备用电池），即使主机电源关闭，它也保持计数定时功能。这也是为什么我们手机关机后时间还能保持准确。再比如以前的老诺基亚手机，拆掉电池就时间不准了，因为rtc电源被切断了，无法在计数，RTC定时器的计数器会被清0，需要手动设置当前时间。<br>RTC一般都是用纽扣电池给外部晶振和电路供电。<br>!<img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/1.png" alt="image"></p>
<h2><span id="1-2-rtc-ding-shi-qi-yuan-li">1.2 RTC定时器原理</span><a href="#1-2-rtc-ding-shi-qi-yuan-li" class="header-anchor">#</a></h2><p>以IMX6U芯片的RTC定时器为例，I.MX6U 内部也有 个 RTC 模块，但是不叫作“RTC”，而是叫做“SNVS”。<br>RTC模块结构图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/2.png" alt="image"><br>SNVS 分为两个子模块：SNVS_HP 和 SNVS_LP，也就是高功耗域(SNVS_HP)和低功耗域(SNVS_LP)，这两个域的电源来源如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SNVS_LP：专用的 always-powered-on 电源域，系统主电源和备用电源都可以为其供电。</span><br><span class="line">SNVS_HP：系统(芯片)电源。 </span><br></pre></td></tr></table></figure>
<p>系统主电源断电以后 SNVS_HP 也会断电，但是在备用电源支持下，SNVS_LP 是不会断电的，而且 SNVS_LP 是和芯片复位隔离开的，因此 SNVS_LP 相关的寄存器的值会一直保存着, 也就是low Power Domain是不受系统电源影响。<br>上图各个序号含义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> VDD_HIGH_IN 是系统(芯片)主电源，这个电源会同时供给给 SNVS_HP 和 SNVS_LP。</span><br><span class="line"><span class="number">2.</span> VDD_SNVS_IN 是纽扣电池供电的电源，这个电源只会供给给 SNVS_LP，保证在系统主电源 VDD_HIGH_IN 掉电以后 SNVS_LP 会继续运行。</span><br><span class="line"><span class="number">3.</span> SNVS_HP 部分。</span><br><span class="line"><span class="number">4.</span> SNVS_LP 部分，此部分有个 SRTC，这个就是要使用的 RTC。</span><br></pre></td></tr></table></figure>
<p>SRTC 需要外界提供一个 32.768KHz 的时钟，I.MX6U-ALPHA 核心板上的 32.768KHz 的晶振就是提供这个时钟的。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/3.png" alt="image"></p>
<h2><span id="1-3-rtc-ding-shi-qi-ji-cun-qi">1.3 RTC定时器寄存器</span><a href="#1-3-rtc-ding-shi-qi-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SNVS_SRTCMR[<span class="number">14</span>:<span class="number">0</span>]代表SRTC计数器的高<span class="number">15</span>位</span><br><span class="line">SNVS_SRTCLR[<span class="number">31</span>:<span class="number">15</span>]代表SRTC计数器的低<span class="number">17</span>位</span><br><span class="line">注意：是以 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日<span class="number">0</span>点<span class="number">0</span>分<span class="number">0</span>秒为起点，加上经过的总秒数即可得到现在的时间点。 </span><br><span class="line">SNVS_HPCOMR[<span class="number">31</span>], NPSWA_EN位，非特权软件访问控制位，如果非特权软件要访问 SNVS 的话此位必须为 <span class="number">1</span>。</span><br><span class="line">SNVS_LPCR[<span class="number">0</span>], SRTC_ENV位，使能 STC 计数器。</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-rtc-luo-ji-yuan-ma-zhan-shi">1.4 RTC裸机源码展示</span><a href="#1-4-rtc-luo-ji-yuan-ma-zhan-shi" class="header-anchor">#</a></h2><p>NXP 官方 SDK 包是针对 I.MX6ULL 编写的，因此文件 MCIMX6Y2.h中的结构体 SNVS_Type 里面的寄存器是不全的，我们需要在其中加入本章实验所需要的寄存器，修改 SNVS_Type 为如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @addtogroup SNVS_Peripheral_Access_Layer SNVS Peripheral Access Layer</span></span><br><span class="line"><span class="comment"> * @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/** SNVS - Register Layout Typedef */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPLR;                              <span class="comment">/**&lt; SNVS_HP Lock register, offset: 0x0 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCOMR;                            <span class="comment">/**&lt; SNVS_HP Command register, offset: 0x4 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPCR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSICR;                              <span class="comment">/**&lt; SNVS_HP Control register, offset: 0x8 */</span></span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVCR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSR;   </span><br><span class="line">  __IO <span class="type">uint32_t</span> HPSVSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACIVR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPHACR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTAMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> HPTALR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPMKCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSVCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTGFCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTDCR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSRTCLR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPTAR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCMR;</span><br><span class="line">  __IO <span class="type">uint32_t</span> LPSMCLR;</span><br><span class="line">&#125;SNVS_Type;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _BSP_RTC_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imx6ul.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相关宏定义 */</span>	</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_DAY 		(86400) <span class="comment">/* 一天86400秒	 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_HOUR 		(3600)	<span class="comment">/* 一个小时3600秒 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDS_IN_A_MINUTE 	(60)	<span class="comment">/* 一分钟60秒  		 	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DAYS_IN_A_YEAR 			(365)	<span class="comment">/* 一年365天 			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_START 		(1970)	<span class="comment">/* 开始年份1970年 		*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YEAR_RANGE_END 			(2099)	<span class="comment">/* 结束年份2099年 		*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间日期结构体 */</span>	</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> year;  <span class="comment">/* 范围为:1970 ~ 2099 		*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> month;  <span class="comment">/* 范围为:1 ~ 12				*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> day;    <span class="comment">/* 范围为:1 ~ 31 (不同的月，天数不同).*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hour;   <span class="comment">/* 范围为:0 ~ 23 			*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> minute; <span class="comment">/* 范围为:0 ~ 59				*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> second; <span class="comment">/* 范围为:0 ~ 59				*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bsp_rtc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置HPCOMR寄存器</span></span><br><span class="line"><span class="comment">     * bit[31] 1 : 允许访问SNVS寄存器，一定要置1</span></span><br><span class="line"><span class="comment">     * bit[8]  1 : 此位置1，需要签署NDA协议才能看到此位的详细说明，</span></span><br><span class="line"><span class="comment">     *             这里不置1也没问题</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	SNVS-&gt;HPCOMR |= (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rtc_datetime</span> <span class="title">rtcdate</span>;</span></span><br><span class="line">	rtcdate.year = <span class="number">2018U</span>;</span><br><span class="line">    rtcdate.month = <span class="number">12U</span>;</span><br><span class="line">    rtcdate.day = <span class="number">13U</span>;</span><br><span class="line">    rtcdate.hour = <span class="number">14U</span>;</span><br><span class="line">    rtcdate.minute = <span class="number">52</span>;</span><br><span class="line">    rtcdate.second = <span class="number">0</span>;</span><br><span class="line">	rtc_setDatetime(&amp;rtcdate); <span class="comment">//初始化时间和日期</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	rtc_enable();	<span class="comment">//使能RTC</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * LPCR寄存器bit0置1，使能RTC</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">	SNVS-&gt;LPCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;	</span><br><span class="line">	<span class="keyword">while</span>(!(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>));<span class="comment">//等待使能完成</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * LPCR寄存器bit0置0，关闭RTC</span></span><br><span class="line"><span class="comment"> 	 */</span></span><br><span class="line">	SNVS-&gt;LPCR &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>);	</span><br><span class="line">	<span class="keyword">while</span>(SNVS-&gt;LPCR &amp; <span class="number">0X01</span>);<span class="comment">//等待关闭完成</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 判断指定年份是否为闰年，闰年条件如下:</span></span><br><span class="line"><span class="comment"> * @param - year: 要判断的年份</span></span><br><span class="line"><span class="comment"> * @return 		: 1 是闰年，0 不是闰年</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">rtc_isleapyear</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> year)</span> &#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> value=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">		value = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>))</span><br><span class="line">			value = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			value = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 将时间转换为秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要转换日期和时间。</span></span><br><span class="line"><span class="comment"> * @return 			: 转换后的秒数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_coverdate_to_seconds</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> days = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> monthdays[] = &#123;<span class="number">0U</span>, <span class="number">0U</span>, <span class="number">31U</span>, <span class="number">59U</span>, <span class="number">90U</span>, <span class="number">120U</span>, <span class="number">151U</span>, <span class="number">181U</span>, <span class="number">212U</span>, <span class="number">243U</span>, <span class="number">273U</span>, <span class="number">304U</span>, <span class="number">334U</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1970</span>; i &lt; datetime-&gt;year; i++) &#123;</span><br><span class="line">		days += DAYS_IN_A_YEAR; 		<span class="comment">/* 平年，每年365天 */</span></span><br><span class="line">		<span class="keyword">if</span>(rtc_isleapyear(i)) days += <span class="number">1</span>;<span class="comment">/* 闰年多加一天 		*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	days += monthdays[datetime-&gt;month];</span><br><span class="line">	<span class="keyword">if</span>(rtc_isleapyear(i) &amp;&amp; (datetime-&gt;month &gt;= <span class="number">3</span>)) days += <span class="number">1</span>;<span class="comment">/* 闰年，并且当前月份大于等于3月的话加一天 */</span></span><br><span class="line"></span><br><span class="line">	days += datetime-&gt;day - <span class="number">1</span>;</span><br><span class="line">	seconds = days * SECONDS_IN_A_DAY + </span><br><span class="line">				datetime-&gt;hour * SECONDS_IN_A_HOUR +</span><br><span class="line">				datetime-&gt;minute * SECONDS_IN_A_MINUTE +</span><br><span class="line">				datetime-&gt;second;</span><br><span class="line">	<span class="keyword">return</span> seconds;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 设置时间和日期</span></span><br><span class="line"><span class="comment"> * @param - datetime: 要设置的日期和时间</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_setdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp = SNVS-&gt;LPCR; </span><br><span class="line">	rtc_disable();	<span class="comment">/* 设置寄存器HPRTCMR和HPRTCLR的时候一定要先关闭RTC */</span></span><br><span class="line">	<span class="comment">/* 先将时间转换为秒 */</span></span><br><span class="line">	seconds = rtc_coverdate_to_seconds(datetime);</span><br><span class="line">	SNVS-&gt;LPSRTCMR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &gt;&gt; <span class="number">17</span>); <span class="comment">/* 设置高16位 */</span></span><br><span class="line">	SNVS-&gt;LPSRTCLR = (<span class="type">unsigned</span> <span class="type">int</span>)(seconds &lt;&lt; <span class="number">15</span>); <span class="comment">/* 设置地16位 */</span></span><br><span class="line">	<span class="comment">/* 如果此前RTC是打开的在设置完RTC时间以后需要重新打开RTC */</span></span><br><span class="line">	<span class="keyword">if</span> (tmp &amp; <span class="number">0x1</span>)</span><br><span class="line">		rtc_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 将秒数转换为时间</span></span><br><span class="line"><span class="comment"> * @param - seconds	: 要转换的秒数</span></span><br><span class="line"><span class="comment"> * @param - datetime: 转换后的日期和时间</span></span><br><span class="line"><span class="comment"> * @return 			: 无</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_convertseconds_to_datetime</span><span class="params">(u64 seconds, <span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">    u64 x;</span><br><span class="line">    u64  secondsRemaining, days;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> daysInYear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 每个月的天数       */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> daysPerMonth[] = &#123;<span class="number">0U</span>, <span class="number">31U</span>, <span class="number">28U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>, <span class="number">30U</span>, <span class="number">31U</span>&#125;;</span><br><span class="line">    secondsRemaining = seconds; <span class="comment">/* 剩余秒数初始化 */</span></span><br><span class="line">    days = secondsRemaining / SECONDS_IN_A_DAY + <span class="number">1</span>; 		<span class="comment">/* 根据秒数计算天数,加1是当前天数 */</span></span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_DAY; <span class="comment">/*计算天数以后剩余的秒数 */</span></span><br><span class="line">	<span class="comment">/* 计算时、分、秒 */</span></span><br><span class="line">    datetime-&gt;hour = secondsRemaining / SECONDS_IN_A_HOUR;</span><br><span class="line">    secondsRemaining = secondsRemaining % SECONDS_IN_A_HOUR;</span><br><span class="line">    datetime-&gt;minute = secondsRemaining / <span class="number">60</span>;</span><br><span class="line">    datetime-&gt;second = secondsRemaining % SECONDS_IN_A_MINUTE;</span><br><span class="line">    <span class="comment">/* 计算年 */</span></span><br><span class="line">    daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">    datetime-&gt;year = YEAR_RANGE_START;</span><br><span class="line">    <span class="keyword">while</span>(days &gt; daysInYear) &#123;</span><br><span class="line">        <span class="comment">/* 根据天数计算年 */</span></span><br><span class="line">        days -= daysInYear;</span><br><span class="line">        datetime-&gt;year++;</span><br><span class="line">        <span class="comment">/* 处理闰年 */</span></span><br><span class="line">        <span class="keyword">if</span> (!rtc_isleapyear(datetime-&gt;year))</span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">/*闰年，天数加一 */</span></span><br><span class="line">            daysInYear = DAYS_IN_A_YEAR + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*根据剩余的天数计算月份 */</span></span><br><span class="line">    <span class="keyword">if</span>(rtc_isleapyear(datetime-&gt;year)) <span class="comment">/* 如果是闰年的话2月加一天 */</span></span><br><span class="line">        daysPerMonth[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = <span class="number">1</span>; x &lt;= <span class="number">12</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (days &lt;= daysPerMonth[x]) &#123;</span><br><span class="line">            datetime-&gt;month = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            days -= daysPerMonth[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    datetime-&gt;day = days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description	: 获取RTC当前秒数</span></span><br><span class="line"><span class="comment"> * @param 		: 无</span></span><br><span class="line"><span class="comment"> * @return 		: 当前秒数 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">rtc_getseconds</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> seconds = <span class="number">0</span>;</span><br><span class="line">	seconds = (SNVS-&gt;LPSRTCMR &lt;&lt; <span class="number">17</span>) | (SNVS-&gt;LPSRTCLR &gt;&gt; <span class="number">15</span>);</span><br><span class="line">	<span class="keyword">return</span> seconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description		: 获取当前时间</span></span><br><span class="line"><span class="comment"> * @param - datetime: 获取到的时间，日期等参数</span></span><br><span class="line"><span class="comment"> * @return 			: 无 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rtc_getdatetime</span><span class="params">(<span class="keyword">struct</span> rtc_datetime *datetime)</span> &#123;</span><br><span class="line">	<span class="comment">//unsigned int seconds = 0;</span></span><br><span class="line">	u64 seconds;</span><br><span class="line">	seconds = rtc_getseconds();</span><br><span class="line">	rtc_convertseconds_to_datetime(seconds, datetime);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到RTC定时器是以秒为计时单位的，每过1s SRTC计数器的值加1。<br>首先调用<code>rtc_init</code>初始化并启动，然后调用<code>rtc_setdatetime</code>设定当前日期时间，调用<code>rtc_getdatetime</code>获取当前日期时间，期间会利用<code>rtc_convertseconds_to_datetime</code>把总秒数转换成当前的日期和时间。</p>
<h1><span id="2-pwm-ding-shi-qi">2 PWM定时器</span><a href="#2-pwm-ding-shi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-pwm-ding-shi-qi-jie-shao">2.1 pwm定时器介绍</span><a href="#2-1-pwm-ding-shi-qi-jie-shao" class="header-anchor">#</a></h2><p>imx6ull一共有 8 路 PWM 信号，每个 PWM 包含一个 16 位的计数器和一个 4 x 16 的数据 FIFO。一路框图如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/4.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">①、此部分是一个选择器，用于选择 PWM 信号的时钟源，一共有三种时钟源：ipg_clk,pg_clk_highfreq 和 ipg_clk_32k。</span><br><span class="line">②、这是一个 <span class="number">12</span> 位的分频器，可以对①中选择的时钟源进行分频。</span><br><span class="line">③、这是 PWM 的 <span class="number">16</span> 位计数器寄存器，保存着 PWM 的计数值。</span><br><span class="line">④、这是 PWM 的 <span class="number">16</span> 位周期寄存器，此寄存器用来控制 PWM 的频率。</span><br><span class="line">⑤、这是 PWM 的 <span class="number">16</span> 位采样寄存器，此寄存器用来控制 PWM 的占空比。</span><br><span class="line">⑥、此部分是 PWM 的中断信号，PWM 是提供中断功能的，如果使能了相应的中断的话就会产生中断。</span><br><span class="line">⑦、此部分是 PWM 对应的输出 IO，产生的 PWM 信号就会从对应的 IO 中输出。</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-pwm-kong-zhi-qi">2.2 PWM控制器</span><a href="#2-2-pwm-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi">2.2.1 PWMx_PWMPR寄存器-周期设置</span><a href="#2-2-1-pwmx-pwmpr-ji-cun-qi-zhou-qi-she-zhi" class="header-anchor">#</a></h3><p>PWM 的 16 位计数器是个上计数器，此计数器会从 0X0000 开始计数，直到计数值等于寄存器PWMx_PWMPR(x&#x3D;1~8)+ 1，然后计数器就会重新从0X0000 开始计数，如此往复。PWMx_PWMPR设置频率。PWM周期公式如下：<br>    PWM_FRE &#x3D; PWM_CLK &#x2F; (PERIOD + 2)<br>    也就是PWMO(Hz) &#x3D; PCLK(Hz) &#x2F; (PERIOD + 2)<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/5.png" alt="image"></p>
<p>比如当前PWM_CLK&#x3D;1MHz, 要产生1KHz的PWM，那么PERIOD &#x3D; 1000000&#x2F;1K - 2 &#x3D; 	998。,如下设置1000，即可得到PERIOD&#x3D;998，也就是1khz.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setperiod_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> regvalue = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(value &lt; <span class="number">2</span>)</span><br><span class="line">		regvalue = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		regvalue = value - <span class="number">2</span>;</span><br><span class="line">	PWM1-&gt;PWMPR = (regvalue &amp; <span class="number">0XFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi">2.2.2 PWMx_PWMSAR寄存器-占空比</span><a href="#2-2-2-pwmx-pwmsar-ji-cun-qi-zhan-kong-bi" class="header-anchor">#</a></h3><p>设置Sample采样寄存器，Sample数据会写入到FIFO中。当计数器的值小于 SAMPLE 的时候输出高电平(或低电平)。当计数器值大于等于 SAMPLE，小于寄存器PWM1_PWMPR 的 PERIO 的时候输出低电平(或高电平)。<br>假如我们要设置 PWM 信号的占空比为 50%，那么就可以将 SAMPLE 设置为(PERIOD + 2) &#x2F; 2 &#x3D; 1000 &#x2F; 2&#x3D;500。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/6.png" alt="image"></p>
<p>如下设置50，即可得到sample&#x3D;500，也就是占空比50%.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> &#123;</span>	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> pwm_duty;		<span class="comment">/* 占空比	*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">backlight_dev_struc</span> <span class="title">backlight_dev</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setsample_value</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMSAR = (value &amp; <span class="number">0XFFFF</span>);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_setduty</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> duty)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> preiod;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> sample;</span><br><span class="line">	backlight_dev.pwm_duty = duty;</span><br><span class="line">	preiod = PWM1-&gt;PWMPR + <span class="number">2</span>;</span><br><span class="line">	sample = preiod * backlight_dev.pwm_duty / <span class="number">100</span>;</span><br><span class="line">	pwm1_setsample_value(sample);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-3-pwmcr-kong-zhi-ji-cun-qi">2.2.3 PWMCR 控制寄存器</span><a href="#2-2-3-pwmcr-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/7.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FWM(bit27:<span class="number">26</span>)：FIFO 水位线，用来设置 FIFO 空余位置为多少的时候表示 FIFO 为空。</span><br><span class="line">	设置为 <span class="number">0</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">1</span> 的时候 FIFO 为空；</span><br><span class="line">	设置为 <span class="number">1</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">2</span> 的时候 FIFO 为空；</span><br><span class="line">	设置为 <span class="number">2</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">3</span> 的时候FIFO 为空；</span><br><span class="line">	设置为 <span class="number">3</span> 的时候表示 FIFO 空余位置大于等于 <span class="number">4</span> 的时候 FIFO 为空。</span><br><span class="line">STOPEN(bit25)：此位用来设置停止模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在停止模式下PWM 不工作，为 <span class="number">1</span> 的话表示停止模式下激活 PWM。</span><br><span class="line">DOZEN(bit24)：此位用来设置休眠模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在休眠模式下PWM 不工作，为 <span class="number">1</span> 的话表示休眠模式下激活 PWM。</span><br><span class="line">WAITEN(bit23)：此位用来设置等待模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在等待模式下PWM 不工作，为 <span class="number">1</span> 的话表示等待模式下激活 PWM。</span><br><span class="line">DEGEN(bit22)：此位用来设置调试模式下 PWM 是否工作，为 <span class="number">0</span> 的话表示在调试模式下PWM 不工作，为 <span class="number">1</span> 的话表示调试模式下激活 PWM。</span><br><span class="line">BCTR(bit21)：字节交换控制位，用来控制 <span class="number">16</span> 位的数据进入 FIFO 的字节顺序。为 <span class="number">0</span> 的时候不进行字节交换，为 <span class="number">1</span> 的时候进行字节交换。</span><br><span class="line">HCRT(bit20)：半字交换控制位，用来决定从 <span class="number">32</span> 位 IP 总线接口传输来的哪个半字数据写入采样寄存器的低 <span class="number">16</span> 位中。</span><br><span class="line">POUTC(bit19:<span class="number">18</span>)：PWM 输出控制控制位，用来设置 PWM 输出模式，</span><br><span class="line">	为 <span class="number">0</span> 的时候表示PWM 先输出高电平，当计数器值和采样值相等的话就输出低电平。</span><br><span class="line">	为 <span class="number">1</span> 的时候相反，当为 <span class="number">2</span> 或者 <span class="number">3</span> 的时候 PWM 信号不输出。本章我们设置为 <span class="number">0</span>，</span><br><span class="line">	也就是一开始输出高电平，当计数器值和采样值相等的话就改为低电平，这样采样值越大高电平时间就越长，占空比就越大。</span><br><span class="line">CLKSRC(bit17:<span class="number">16</span>)：PWM 时钟源选择，</span><br><span class="line">	为 <span class="number">0</span> 的话关闭；</span><br><span class="line">	为 <span class="number">1</span> 的话选择 ipg_clk 为时钟源；</span><br><span class="line">	为 <span class="number">2</span> 的话选择 ipg_clk_highfreq 为时钟源；</span><br><span class="line">	为 <span class="number">3</span> 的话选择 ipg_clk_32k 为时钟源。本章我们设置为 <span class="number">1</span>，也就是选择 ipg_clk 为 PWM 的时钟源，因此 PWM 时钟源频率为 <span class="number">66</span>MHz。</span><br><span class="line">PRESCALER(bit15:<span class="number">4</span>)：分频值，可设置为 <span class="number">0</span>~<span class="number">4095</span>，对应着 <span class="number">1</span>~<span class="number">4096</span> 分频。</span><br><span class="line">SWR(bit3)：软件复位，向此位写 <span class="number">1</span> 就复位 PWM，此位是自清零的，当复位完成以后此位会自动清零。</span><br><span class="line">REPEAT(bit2:<span class="number">1</span>)：重复采样设置，此位用来设置 FIFO 中的每个数据能用几次。</span><br><span class="line">	可设置 <span class="number">0</span>~<span class="number">3</span>，分别表示 FIFO 中的每个数据能用 <span class="number">1</span>~<span class="number">4</span> 次。本章我们设置为 <span class="number">0</span>，即 FIFO 中的每个数据只能用一次。</span><br><span class="line">EN(bit0)：PWM 使能位，为 <span class="number">1</span> 的时候使能 PWM，为 <span class="number">0</span> 的时候关闭 PWM。</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMCR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;	 </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm1_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	PWM1-&gt;PWMCR = <span class="number">0</span>;	<span class="comment">/* 寄存器先清零 */</span></span><br><span class="line">	PWM1-&gt;PWMCR |= (<span class="number">1</span> &lt;&lt; <span class="number">26</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) | (<span class="number">65</span> &lt;&lt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置PWM周期为1000,那么PWM频率就是1M/1000 = 1KHz。 */</span></span><br><span class="line">	pwm1_setperiod_value(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置占空比，默认50%占空比   ,写四次是因为有4个FIFO */</span></span><br><span class="line">	backlight_dev.pwm_duty = <span class="number">50</span>;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		pwm1_setduty(backlight_dev.pwm_duty);	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">	PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">	system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);	<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">	GIC_EnableIRQ(PWM1_IRQn);	<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">	PWM1-&gt;PWMSR = <span class="number">0</span>;			<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line"></span><br><span class="line">	pwm1_enable();				<span class="comment">/* 使能PWM1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">27</span>:<span class="number">26</span>]	: <span class="number">01</span>  当FIFO中空余位置大于等于<span class="number">2</span>的时候FIFO空标志值位</span><br><span class="line">bit[<span class="number">25</span>]		:<span class="number">0</span>  停止模式下PWM不工作</span><br><span class="line">bit[<span class="number">24</span>]		: <span class="number">0</span>	  休眠模式下PWM不工作</span><br><span class="line">bit[<span class="number">23</span>]		: <span class="number">0</span>   等待模式下PWM不工作</span><br><span class="line">bit[<span class="number">22</span>]		: <span class="number">0</span>   调试模式下PWM不工作</span><br><span class="line">it[<span class="number">21</span>]		: <span class="number">0</span>   关闭字节交换</span><br><span class="line">bit[<span class="number">20</span>]		: <span class="number">0</span>	  关闭半字数据交换</span><br><span class="line">bit[<span class="number">19</span>:<span class="number">18</span>]	: <span class="number">00</span>  PWM输出引脚在计数器重新计数的时候输出高电平,在计数器计数值达到比较值以后输出低电平</span><br><span class="line">bit[<span class="number">17</span>:<span class="number">16</span>]	: <span class="number">01</span>  PWM时钟源选择IPG CLK = <span class="number">66</span>MHz</span><br><span class="line">bit[<span class="number">15</span>:<span class="number">4</span>]	: <span class="number">65</span>  分频系数为<span class="number">65</span>+<span class="number">1</span>=<span class="number">66</span>，PWM时钟源 = <span class="number">66</span>MHZ/<span class="number">66</span>=<span class="number">1</span>MHz</span><br><span class="line">bit[<span class="number">3</span>]		: <span class="number">0</span>	  PWM不复位</span><br><span class="line">bit[<span class="number">2</span>:<span class="number">1</span>]	: <span class="number">00</span>  FIFO中的sample数据每个只能使用一次。</span><br><span class="line">bit[<span class="number">0</span>]		: <span class="number">0</span>   先关闭PWM，后面再使能</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi">2.2.4 PWM1_PWMIR中断控制寄存器</span><a href="#2-2-4-pwm1-pwmir-zhong-duan-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/8.png" alt="image"><br><strong>CIE</strong>(bit2)：比较中断使能位，为 1 的时候使能比较中断，为 0 的时候关闭比较中断。<br><strong>RIE</strong>(bit1)：翻转中断使能位，当计数器值等于采样值并回滚到 0X0000 的时候就会产生此中断，为 1 的时候使能翻转中断，为 0 的时候关闭翻转中断。<br><strong>FIE</strong>(bit0)：FIFO 空中断，为 1 的时候使能，为 0 的时候关闭。前面代码写的是使能FIFO空中断.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使能FIFO空中断，设置寄存器PWMIR寄存器的bit0为1 */</span></span><br><span class="line">PWM1-&gt;PWMIR |= <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi">2.2.5 PWM1_PWMSR 状态寄存器</span><a href="#2-2-5-pwm1-pwmsr-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/9.png" alt="image"><br><strong>FWE</strong>(bit6)：FIFO 写错误事件，为 1 的时候表示发生了 FIFO 写错误。<br><strong>CMP</strong>(bit5)：FIFO 比较事件发标志位，为 1 的时候表示发生 FIFO 比较事件。<br><strong>ROV</strong>(bit4)：翻转事件标志位，为 1 的话表示翻转事件发生。<br><strong>FE</strong>(bit3)：FIFO 空标志位，为 1 的时候表示 FIFO 位空。<br><strong>FIFOAV</strong>(bit2:0)：此位记录 FIFO 中的有效数据个数，有效值为 0<del>4，分别表示 FIFO 中有0</del>4 个有效数据</p>
<p>初始化先清0，中断服务程序读取状态，并且清中断。FIFO 中的采样值每个周期都会少一个，所以需要不断的向 FIFO 中写入采样值，防止其为空。我们可以使能 FIFO 空中断，这样当 FIFO 为空的时候就会触发相应的中断，然后在中断处理函数中向 FIFO 写入采样值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pwm1_irqhandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span>(PWM1-&gt;PWMSR &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>)) 	<span class="comment">/* FIFO为空中断 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 将占空比信息写入到FIFO中,其实就是设置占空比 */</span></span><br><span class="line">		pwm1_setduty(backlight_dev.pwm_duty);</span><br><span class="line">		PWM1-&gt;PWMSR |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>); <span class="comment">/* 写1清除中断标志位 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system_register_irqhandler(PWM1_IRQn, (<span class="type">system_irq_handler_t</span>)pwm1_irqhandler, <span class="literal">NULL</span>);	<span class="comment">/* 注册中断服务函数 */</span></span><br><span class="line">GIC_EnableIRQ(PWM1_IRQn);	<span class="comment">/* 使能GIC中对应的中断 */</span></span><br><span class="line">PWM1-&gt;PWMSR = <span class="number">0</span>;			<span class="comment">/* PWM中断状态寄存器清零 */</span></span><br><span class="line">pwm1_enable();				<span class="comment">/* 使能PWM1 */</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-3-ce-shi">2.3 测试</span><a href="#2-3-ce-shi" class="header-anchor">#</a></h2><p>初始化时设置占空比为50%，测试代码读取按键，每次该按键按下就对占空比加10%，如果占空比超过100%，重新从10%开始。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	keyvalue = key_getvalue();</span><br><span class="line">	<span class="keyword">if</span>(keyvalue == KEY0_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		duty += <span class="number">10</span>;				<span class="comment">/* 占空比加10% */</span></span><br><span class="line">		<span class="keyword">if</span>(duty &gt; <span class="number">100</span>)			<span class="comment">/* 如果占空比超过100%，重新从10%开始 */</span></span><br><span class="line">			duty = <span class="number">10</span>;</span><br><span class="line">		lcd_shownum(<span class="number">50</span> + <span class="number">72</span>, <span class="number">90</span>, duty, <span class="number">3</span>, <span class="number">16</span>);</span><br><span class="line">		pwm1_setduty(duty);		<span class="comment">/* 设置占空比 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	delayms(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>占空比10%时亮度波形如下，亮度很暗。<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/10.png" alt="image"><br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/11.png" alt="image"><br>占空比90%时亮度如下：<br><img src="/2024/05/02/imx6ull%E8%A3%B8%E6%9C%BA-%E5%AE%9A%E6%97%B6%E5%99%A8/12.png" alt="image"></p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>ini_parse配置解析功能移植</title>
    <url>/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ini-parse-yi-zhi">1 ini_parse移植</a><ul>
<li><a href="#1-1-xia-zai-ini-jie-xi-yuan-ma">1.1 下载ini解析源码</a></li>
<li><a href="#1-2-shi-yong-ini-parse-gong-neng">1.2 使用ini_parse功能</a><ul>
<li><a href="#1-2-1-zi-ding-yi-ini-wen-jian">1.2.1 自定义ini文件</a></li>
<li><a href="#1-2-2-zhi-chi-yu-fa-jian-ce">1.2.2 支持语法检测</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-minini-yi-zhi-shi-yong">2 minIni移植使用</a><ul>
<li><a href="#2-1-xia-zai-minini">2.1 下载minIni</a></li>
<li><a href="#2-2-te-zheng">2.2 特征</a></li>
<li><a href="#2-3-ini-wen-jian-yu-fa">2.3 INI 文件语法</a></li>
<li><a href="#2-4-minini-zhi-chi-wen-jian-xi-tong">2.4 minIni支持文件系统</a></li>
<li><a href="#2-5-minini-de-api-jie-shao">2.5 minIni的API介绍</a><ul>
<li><a href="#2-5-1-ini-gets">2.5.1 ini_gets()</a><ul>
<li><a href="#2-5-1-1-getkeystring">2.5.1.1 getkeystring</a></li>
</ul>
</li>
<li><a href="#2-5-2-ini-getl">2.5.2 ini_getl()</a></li>
<li><a href="#2-5-3-ini-puts">2.5.3 ini_puts()</a></li>
<li><a href="#2-5-4-ini-putl">2.5.4 ini_putl()</a></li>
<li><a href="#2-5-5-section-key-enumeration">2.5.5 section&#x2F;key enumeration</a></li>
<li><a href="#2-5-6-section-key-cun-zai-xing-jian-cha">2.5.6 section&#x2F;key存在性检查</a></li>
<li><a href="#2-5-7-pei-zhi-wen-jian-yue-du-da-yin">2.5.7 配置文件阅读打印</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-ini-parse-yi-zhi">1 ini_parse移植</span><a href="#1-ini-parse-yi-zhi" class="header-anchor">#</a></h1><h2><span id="1-1-xia-zai-ini-jie-xi-yuan-ma">1.1 下载ini解析源码</span><a href="#1-1-xia-zai-ini-jie-xi-yuan-ma" class="header-anchor">#</a></h2><p>源码的github地址<a href="https://github.com/benhoyt/inih">https://github.com/benhoyt/ini</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/benhoyt/inih.git</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/1.png" alt="img"></p>
<h2><span id="1-2-shi-yong-ini-parse-gong-neng">1.2 使用ini_parse功能</span><a href="#1-2-shi-yong-ini-parse-gong-neng" class="header-anchor">#</a></h2><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/2.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/3.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/4.png" alt="img"></p>
<p>可以看到核心就是一个ini_parse函数。用户自定义一个callback函数去解析自己的配置ini。测试代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ini.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SAMPLE_INI_CFG_S</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> bus_id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">char</span> name2[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> bus_id2;</span><br><span class="line">        <span class="type">int</span> age2;</span><br><span class="line">&#125; SAMPLE_INI_CFG_S;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">parse_handler</span><span class="params">(<span class="type">void</span> *user, <span class="type">const</span> <span class="type">char</span> *section, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value)</span> &#123;</span><br><span class="line">        SAMPLE_INI_CFG_S *cfg = (SAMPLE_INI_CFG_S *)user;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section, <span class="string">&quot;person1&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">strcpy</span>(cfg-&gt;name, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;bus_id&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;bus_id = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;age&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;age = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* unknown section/name */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(section, <span class="string">&quot;person2&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;name&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">strcpy</span>(cfg-&gt;name2, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;bus_id&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;bus_id2 = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;age&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        cfg-&gt;age2 = atoi(value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       <span class="comment">/* unknown section/name */</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* unknown section/name */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">        SAMPLE_INI_CFG_S ini_cfg;</span><br><span class="line">        <span class="type">int</span> ret = ini_parse(<span class="string">&quot;./sensor_cfg.ini&quot;</span>, parse_handler, &amp;ini_cfg);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Parse err in %d line.\n&quot;</span>, ret);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Parse incomplete, use default cfg ./sensor_cfg.ini\n&quot;</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s, %d, %d\n&quot;</span>, ini_cfg.name, ini_cfg.bus_id, ini_cfg.age);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s, %d, %d\n&quot;</span>, ini_cfg.name2, ini_cfg.bus_id2, ini_cfg.age2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="1-2-1-zi-ding-yi-ini-wen-jian">1.2.1 自定义ini文件</span><a href="#1-2-1-zi-ding-yi-ini-wen-jian" class="header-anchor">#</a></h3><p>ini配置文件sensor_cfg.ini如下：</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/5.png" alt="img"></p>
<p><code>gcc test.c ini.c</code>。我的callback定义是<code>parse_handler</code>，从ini中解析section，每个section会调用一次callback，解析出所有的section。</p>
<p>运行代码:</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/6.png" alt="img"></p>
<h3><span id="1-2-2-zhi-chi-yu-fa-jian-ce">1.2.2 支持语法检测</span><a href="#1-2-2-zhi-chi-yu-fa-jian-ce" class="header-anchor">#</a></h3><p>ini_parse还支持语法检测。但ini写的不和语法规范会报错。手工制造ini语法错误，测试结果如下：</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/7.png" alt="img"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/8.png" alt="img"></p>
<h1><span id="2-minini-yi-zhi-shi-yong">2 minIni移植使用</span><a href="#2-minini-yi-zhi-shi-yong" class="header-anchor">#</a></h1><p>MiniINI 是一个用来解析 INI&#x2F;CFG 配置文件的 C++ 库，主要特点是可移植性、性能和小体积。支持上千种 INI 格式配置，易用简单。</p>
<h2><span id="2-1-xia-zai-minini">2.1 下载minIni</span><a href="#2-1-xia-zai-minini" class="header-anchor">#</a></h2><p><a href="https://github.com/compuphase/minIni">GitHub - compuphase&#x2F;minIni: A small and portable INI file library with read&#x2F;write support</a></p>
<h2><span id="2-2-te-zheng">2.2 特征</span><a href="#2-2-te-zheng" class="header-anchor">#</a></h2><ul>
<li>minIni 支持读取senction外部的key，因此它支持不使用section的配置文件（但在其他方面与 INI 文件兼容）。</li>
<li>可以使用冒号分隔键和值;冒号等价于等号。也就是说，字符串“Name： Value”和“Name&#x3D;Value”具有相同的含义。</li>
<li>minIni 不需要标准 C&#x2F;C++ 库中的 文件 I&#x2F;O 函数，且允许通过宏配置要选择文件 I&#x2F;O 接口。</li>
<li>哈希字符 （“#”） 是分号开始注释的替代方法。允许尾随注释（即在一行上的键&#x2F;值对后面）。</li>
<li>key名称和val周围的前导和尾随空格将被忽略。</li>
<li>当写入包含注释字符（“;”或“#”）的值时，该值将自动放在双引号之间;读取值时，将删除这些引号。当设置中出现双引号本身时，这些字符将被转义。</li>
<li>支持section和key枚举。</li>
<li>您可以选择设置 minIni 将使用的行终止符（对于文本文件）。（这是编译时设置，而不是运行时设置)。</li>
<li>由于写入速度远低于闪存（SD&#x2F;MMC 卡、U 盘）中的读取速度，因此 minIni 以双倍“文件读取”为代价将“文件写入”降至最低。</li>
<li>内存占用是确定性的。没有动态内存分配。</li>
</ul>
<h2><span id="2-3-ini-wen-jian-yu-fa">2.3 INI 文件语法</span><a href="#2-3-ini-wen-jian-yu-fa" class="header-anchor">#</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Network]  <span class="comment">#section</span></span><br><span class="line">hostname=My Computer  <span class="comment">#key = val</span></span><br><span class="line">address=dhcp</span><br><span class="line">dns = <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-4-minini-zhi-chi-wen-jian-xi-tong">2.4 minIni支持文件系统</span><a href="#2-4-minini-zhi-chi-wen-jian-xi-tong" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INI_FILETYPE                  FILE*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_openread(filename,file)   ((*(file) = fopen((filename),<span class="string">&quot;r&quot;</span>)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_openwrite(filename,file)  ((*(file) = fopen((filename),<span class="string">&quot;w&quot;</span>)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_close(file)               (fclose(*(file)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_read(buffer,size,file)    (fgets((buffer),(size),*(file)) != NULL)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_write(buffer,file)        (fputs((buffer),*(file)) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_rename(source,dest)       (rename((source), (dest)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_remove(filename)          (remove(filename) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INI_FILEPOS                   fpos_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_tell(file,pos)            (fgetpos(*(file), (pos)) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ini_seek(file,pos)            (fsetpos(*(file), (pos)) == 0)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-minini-de-api-jie-shao">2.5 minIni的API介绍</span><a href="#2-5-minini-de-api-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/9.png" alt="image-20240602144015881"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;minIni.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sizearray(a)  (sizeof(a) / sizeof((a)[0]))</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> inifile[] = <span class="string">&quot;example.ini&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">char</span> section[<span class="number">50</span>];</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line"></span><br><span class="line">    n = ini_gets(<span class="string">&quot;Network&quot;</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;dummy&quot;</span>, str, sizearray(str), inifile);</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;Network/address=%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    n = ini_getl(<span class="string">&quot;Network&quot;</span>, <span class="string">&quot;timeout&quot;</span>, <span class="number">-1</span>, inifile);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Network/timeout=%ld\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>example.ini如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Network]</span><br><span class="line">hostname=My Computer</span><br><span class="line">address=dhcp</span><br><span class="line">dns=<span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">timeout=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Network/address=dhcp</span><br><span class="line">Network/timeout=10</span><br></pre></td></tr></table></figure>

<h3><span id="2-5-1-ini-gets">2.5.1 ini_gets()</span><a href="#2-5-1-ini-gets" class="header-anchor">#</a></h3><p>获取字符串类型的值.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>   <span class="title function_">ini_gets</span><span class="params">(<span class="type">const</span> mTCHAR *Section, <span class="type">const</span> mTCHAR *Key, <span class="type">const</span> mTCHAR *DefValue, mTCHAR *Buffer, <span class="type">int</span> BufferSize, <span class="type">const</span> mTCHAR *Filename)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数 1 是 Section;</span></span><br><span class="line"><span class="comment">参数 2 是 Key;</span></span><br><span class="line"><span class="comment">参数 3 是获取不到值时的默认值;</span></span><br><span class="line"><span class="comment">参数 4 是用于保存目标键值的 Buffer;</span></span><br><span class="line"><span class="comment">参数 5 是 Buffer 的长度;</span></span><br><span class="line"><span class="comment">参数 6 是 INI 文件的路径;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/10.png" alt="image-20240602144722018"></p>
<p>先打开文件，然后用 <code>getkeystring() </code>找到目标键值，最后拷贝给调用者。</p>
<h4><span id="2-5-1-1-getkeystring">2.5.1.1 getkeystring</span><a href="#2-5-1-1-getkeystring" class="header-anchor">#</a></h4><p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/11.png" alt="image-20240602150058567"></p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/12.png" alt="image-20240602145619533"></p>
<ol>
<li>用 fgets 进行逐行读取，用 strrchr 找到包含 ‘[‘ 和 ‘]’ 的行，然后再用 strncasecmp 找到目标 Section 所在的行。</li>
<li>继续用 fgets 进行逐行读取，用 strrchr 找到包含 ‘&#x3D;’ 的行，然后再用 strncasecmp 找到目标 Key 所在的行。</li>
<li>用 strncpy 将目标 Key 的值拷贝给调用者。</li>
</ol>
<p>大致就是这3个关键步骤，当然还有很多其他异常处理，语法检测和边界判断的逻辑，这里不做展示。</p>
<h3><span id="2-5-2-ini-getl">2.5.2 ini_getl()</span><a href="#2-5-2-ini-getl" class="header-anchor">#</a></h3><p><code>ini_getl() </code>用于获取整型类型的值，也是间接调用<code>int_gets</code>， 最后将字符串转换成数字。</p>
<h3><span id="2-5-3-ini-puts">2.5.3 ini_puts()</span><a href="#2-5-3-ini-puts" class="header-anchor">#</a></h3><p>写出参数到ini,保存到ini。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** ini_puts()</span></span><br><span class="line"><span class="comment"> * \param Section     the name of the section to write the string in</span></span><br><span class="line"><span class="comment"> * \param Key         the name of the entry to write, or NULL to erase all keys in the section</span></span><br><span class="line"><span class="comment"> * \param Value       a pointer to the buffer the string, or NULL to erase the key</span></span><br><span class="line"><span class="comment"> * \param Filename    the name and full path of the .ini file to write to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \return            1 if successful, otherwise 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ini_puts</span><span class="params">(<span class="type">const</span> TCHAR *Section, <span class="type">const</span> TCHAR *Key, <span class="type">const</span> TCHAR *Value, <span class="type">const</span> TCHAR *Filename)</span></span><br><span class="line"><span class="comment">//eg:</span></span><br><span class="line"><span class="title function_">ini_putl</span><span class="params">(<span class="string">&quot;second&quot;</span>, <span class="string">&quot;age&quot;</span>, <span class="number">20</span>, inifile)</span>;</span><br><span class="line">n = ini_puts(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;alt&quot;</span>, <span class="literal">NULL</span>, inifile);<span class="comment">//当val等于NULL表示删除该key</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-4-ini-putl">2.5.4 ini_putl()</span><a href="#2-5-4-ini-putl" class="header-anchor">#</a></h3><p><code>ini_putl() </code>用于写出整型类型的值，也是间接调用<code>int_puts</code>， 将数字转换成字符串,然后保存字符串到ini。</p>
<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/13.png" alt="image-20240602171648913"></p>
<h3><span id="2-5-5-section-x2f-key-enumeration">2.5.5 section&#x2F;key enumeration</span><a href="#2-5-5-section-x2f-key-enumeration" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;4. Section/key enumeration, file structure follows\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (s = <span class="number">0</span>; ini_getsection(s, section, sizearray(section), inifile) &gt; <span class="number">0</span>; s++) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;    [%s]\n&quot;</span>, section);</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; ini_getkey(section, k, str, sizearray(str), inifile) &gt; <span class="number">0</span>; k++) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>, str);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;<span class="comment">//对section和key进行枚举</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-5-6-section-x2f-key-cun-zai-xing-jian-cha">2.5.6 section&#x2F;key存在性检查</span><a href="#2-5-6-section-x2f-key-cun-zai-xing-jian-cha" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* section/key presence check */</span></span><br><span class="line">assert(ini_hassection(<span class="string">&quot;first&quot;</span>, inifile));<span class="comment">//检查是否有first 段</span></span><br><span class="line">assert(!ini_hassection(<span class="string">&quot;fourth&quot;</span>, inifile));</span><br><span class="line">assert(ini_haskey(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;val&quot;</span>, inifile));<span class="comment">//检查first段是否有val这个key</span></span><br><span class="line">assert(!ini_haskey(<span class="string">&quot;first&quot;</span>, <span class="string">&quot;test&quot;</span>, inifile));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;5. checking presence of sections and keys passed\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="2-5-7-pei-zhi-wen-jian-yue-du-da-yin">2.5.7 配置文件阅读打印</span><a href="#2-5-7-pei-zhi-wen-jian-yue-du-da-yin" class="header-anchor">#</a></h3><p><code>ini_browse</code>用来打印出每个段的每个key的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Callback</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *section, <span class="type">const</span> <span class="type">char</span> *key, <span class="type">const</span> <span class="type">char</span> *value, <span class="type">void</span> *userdata)</span> &#123;</span><br><span class="line">	(<span class="type">void</span>)userdata; <span class="comment">/* this parameter is not used in this example */</span></span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;    [%s]\t%s=%s\n&quot;</span>, section, key, value);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* browsing through the file */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;6. browse through all settings, file field list follows\n&quot;</span>);</span><br><span class="line">ini_browse(Callback, <span class="literal">NULL</span>, inifile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (access(filename, F_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">	perror(<span class="string">&quot;open %s fail&quot;</span>, filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/ini-parse%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E7%A7%BB%E6%A4%8D/14.png" alt="image-20240602173647362"></p>
]]></content>
      <tags>
        <tag>开源插件</tag>
        <tag>ini解析</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本命令集合</title>
    <url>/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-qian-yan-can-kao-zi-liao">1 前言-参考资料</a></li>
<li><a href="#2-linux-ming-ling">2 linux 命令</a><ul>
<li><a href="#1-1-ci-pan-xiang-guan">1.1 磁盘相关</a><ul>
<li><a href="#1-1-1-fdisk">1.1.1 fdisk</a><ul>
<li><a href="#1-1-1-1-cha-kan-fen-qu">1.1.1.1 查看分区</a></li>
<li><a href="#1-1-1-2-shan-chu-fen-qu">1.1.1.2 删除分区</a></li>
<li><a href="#1-1-1-3-chuang-jian-fen-qu">1.1.1.3 创建分区</a></li>
</ul>
</li>
<li><a href="#1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs">1.1.2 磁盘格式化命令-mkfs</a></li>
<li><a href="#1-1-3-du">1.1.3 du</a></li>
<li><a href="#1-1-4-df">1.1.4 df</a></li>
</ul>
</li>
<li><a href="#1-2-wen-jian-zi-fu-cao-zuo-ming-ling">1.2 文件字符操作命令</a><ul>
<li><a href="#1-2-1-xargs">1.2.1 xargs</a></li>
<li><a href="#1-2-2-grep">1.2.2 grep</a></li>
</ul>
</li>
<li><a href="#1-3-wang-luo-ming-ling">1.3 网络命令</a></li>
</ul>
</li>
<li><a href="#3-shell-jiao-ben-ming-ling">3 shell脚本命令</a><ul>
<li><a href="#3-1-jie-shi-qi">3.1 解释器</a></li>
<li><a href="#3-2-duan-dai-ma-zhu-shi">3.2 段代码注释</a></li>
<li><a href="#3-3-read-ming-ling">3.3 read命令</a></li>
<li><a href="#3-4-test-ming-ling">3.4 test命令</a></li>
<li><a href="#3-5-ming-ling-xing-can-shu">3.5 命令行参数</a></li>
<li><a href="#3-6-tiao-jian-yu-ju">3.6 条件语句</a></li>
<li><a href="#3-7-case-yu-ju">3.7 case语句</a></li>
<li><a href="#3-8-han-shu">3.8 函数</a></li>
<li><a href="#3-9-xun-huan-yu-ju">3.9 循环语句</a></li>
<li><a href="#3-10-typeset-huo-zhe-declare">3.10 typeset或者declare</a></li>
<li><a href="#3-11-unset">3.11 unset</a></li>
<li><a href="#3-12-readonly">3.12 readonly</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-qian-yan-can-kao-zi-liao">1 前言-参考资料</span><a href="#1-qian-yan-can-kao-zi-liao" class="header-anchor">#</a></h1><p>正点原子：<a href="http://www.openedv.com/docs/boards/arm-linux/zdyz-i.mx6ull.html">http://www.openedv.com/docs/boards/arm-linux/zdyz-i.mx6ull.html</a></p>
<h1><span id="2-linux-ming-ling">2 linux 命令</span><a href="#2-linux-ming-ling" class="header-anchor">#</a></h1><h2><span id="1-1-ci-pan-xiang-guan">1.1 磁盘相关</span><a href="#1-1-ci-pan-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-1-1-fdisk">1.1.1 fdisk</span><a href="#1-1-1-fdisk" class="header-anchor">#</a></h3><h4><span id="1-1-1-1-cha-kan-fen-qu">1.1.1.1 查看分区</span><a href="#1-1-1-1-cha-kan-fen-qu" class="header-anchor">#</a></h4><p><code>fdisk -l</code>显示磁盘分区使用情况</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/0.png" alt="image"></p>
<h4><span id="1-1-1-2-shan-chu-fen-qu">1.1.1.2 删除分区</span><a href="#1-1-1-2-shan-chu-fen-qu" class="header-anchor">#</a></h4><p><code>fdisk /dev/sdb1 </code>用来对sdb1进行分区.</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/1.png" alt="image"></p>
<p>输入m表示获取帮助，默认有分区sdb1, 然后输入d删除分区1，p打印出分区表，i表示打印出详细分区信息，n表示新增分区信息，w表示保存，q表示退出。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/2.png" alt="image"></p>
<p>来看dev&#x2F;sd*信息，发现已经没有了sdb1.</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/3.png" alt="image"></p>
<h4><span id="1-1-1-3-chuang-jian-fen-qu">1.1.1.3 创建分区</span><a href="#1-1-1-3-chuang-jian-fen-qu" class="header-anchor">#</a></h4><p>再来看如何建立分区1：<br>先建立一个1GB的分区，<code>1GB= 1024 * 1024 * 1024=1073741824 B = 2097152</code>个sector，一个sector有512 byte,再加上2048 个sector，那么等于2099200个sector。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/4.png" alt="image"></p>
<p>再来何建立分区2：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/5.png" alt="image"></p>
<p>这里First sector使用默认值2101248，Last sector使用4198400（1G是2097152， 2101248 + 2097152 &#x3D; 4198400），分区2也是1GB<br>再来何建立分区3：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/6.png" alt="image"></p>
<p>First sector和Last sector使用默认，那么最终分区3有26.8GiB。</p>
<p>最后输入w保存退出，来看下分区:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/7.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/8.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/9.png" alt="image"></p>
<h3><span id="1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs">1.1.2 磁盘格式化命令-mkfs</span><a href="#1-1-2-ci-pan-ge-shi-hua-ming-ling-mkfs" class="header-anchor">#</a></h3><p>mkfs命令用来对磁盘分区格式化，将格式化好的sd卡放入windows系统查看，可以看到3个盘:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/10.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/11.png" alt="image"></p>
<h3><span id="1-1-3-du">1.1.3 du</span><a href="#1-1-3-du" class="header-anchor">#</a></h3><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/12.png" alt="image"></p>
<h3><span id="1-1-4-df">1.1.4 df</span><a href="#1-1-4-df" class="header-anchor">#</a></h3><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/13.png" alt="image"></p>
<h2><span id="1-2-wen-jian-zi-fu-cao-zuo-ming-ling">1.2 文件字符操作命令</span><a href="#1-2-wen-jian-zi-fu-cao-zuo-ming-ling" class="header-anchor">#</a></h2><h3><span id="1-2-1-xargs">1.2.1 xargs</span><a href="#1-2-1-xargs" class="header-anchor">#</a></h3><p><code>find -name *.sh |xargs grep -rn &quot;build_all&quot;</code></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/14.png" alt="image"></p>
<h3><span id="1-2-2-grep">1.2.2 grep</span><a href="#1-2-2-grep" class="header-anchor">#</a></h3><p><code>find /path/to/directory -type f -name &quot;*.txt&quot; | grep &quot;keyword&quot;</code></p>
<p>-w 全词匹配。<br>-v 反向搜索<br>-i 不区分大小写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$匹配以字符串结尾的行</span><br><span class="line">^ 匹配以字符串开头的行</span><br><span class="line"></span><br><span class="line">找出空行 grep <span class="string">&quot;^$&quot;</span> test.txt -n</span><br><span class="line">找出unix开头的行grep <span class="string">&quot;^unix&quot;</span> geekfile.txt</span><br><span class="line">找出.结尾的行 grep <span class="string">&quot;\.$&quot;</span> test.txt -n -o</span><br><span class="line">找出os.结尾的行，grep <span class="string">&quot;os.$&quot;</span> geekfile.txt</span><br></pre></td></tr></table></figure>

<p><strong>[abc]中括号</strong></p>
<p>匹配abc字符中的任意一个:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/15.png" alt="image"></p>
<p>匹配a-z:</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/16.png" alt="image"></p>
<p>下面一个脚本用grep -v排除掉不需要的行，也就是删除包含指定字符的行从一个文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 定义要删除的特定字符</span></span><br><span class="line">pattern=<span class="string">&quot;特定字符&quot;</span></span><br><span class="line"><span class="comment"># 定义要处理的文件名</span></span><br><span class="line">filename=<span class="string">&quot;文件名&quot;</span></span><br><span class="line"><span class="comment"># 使用grep命令找到含有特定字符的行，并将结果输出到一个临时文件中</span></span><br><span class="line">grep -v <span class="string">&quot;<span class="variable">$pattern</span>&quot;</span> <span class="string">&quot;<span class="variable">$filename</span>&quot;</span> &gt; temp.txt</span><br><span class="line"><span class="comment"># 将临时文件的内容复制回原始文件</span></span><br><span class="line"><span class="built_in">cat</span> temp.txt &gt; <span class="string">&quot;<span class="variable">$filename</span>&quot;</span></span><br><span class="line"><span class="comment"># 删除临时文件</span></span><br><span class="line"><span class="built_in">rm</span> temp.txt</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-wang-luo-ming-ling">1.3 网络命令</span><a href="#1-3-wang-luo-ming-ling" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up/down</span><br><span class="line">udhcpc -i eth0 //通过路由器分配 IP 地址</span><br><span class="line">ifconfig eth0 192.168.1.251 netmask 255.255.255.0 //设置 IP 地址和子网掩码</span><br><span class="line">route add default gw 192.168.1.1 //添加默认网关</span><br></pre></td></tr></table></figure>

<h1><span id="3-shell-jiao-ben-ming-ling">3 shell脚本命令</span><a href="#3-shell-jiao-ben-ming-ling" class="header-anchor">#</a></h1><h2><span id="3-1-jie-shi-qi">3.1 解释器</span><a href="#3-1-jie-shi-qi" class="header-anchor">#</a></h2><ol>
<li><p>sh解释器</p>
</li>
<li><p>bash解释器<br>脚本开头用<code>#！</code>用来申明用什么解释器，如：</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/17.png" alt="image"></p>
</li>
</ol>
<h2><span id="3-2-duan-dai-ma-zhu-shi">3.2 段代码注释</span><a href="#3-2-duan-dai-ma-zhu-shi" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;EOF</span><br><span class="line">...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/18.png" alt="image"></p>
<h2><span id="3-3-read-ming-ling">3.3 read命令</span><a href="#3-3-read-ming-ling" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/19.png" alt="image"></p>
<h2><span id="3-4-test-ming-ling">3.4 test命令</span><a href="#3-4-test-ming-ling" class="header-anchor">#</a></h2><p>测试文件，数值，权限，字符串等参数。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/20.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/21.png" alt="image"></p>
<p>中括号也能表示测试，里面只能用&#x3D;&#x3D;或!&#x3D;。</p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/22.png" alt="image"></p>
<h2><span id="3-5-ming-ling-xing-can-shu">3.5 命令行参数</span><a href="#3-5-ming-ling-xing-can-shu" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>...</span><br><span class="line"><span class="variable">$0</span>表示脚本文件名</span><br><span class="line"><span class="variable">$1</span>表示第一个参数</span><br><span class="line"><span class="variable">$n</span>表示第n个参数</span><br><span class="line"><span class="variable">$#</span>表示一共有多少个命令行参数</span><br><span class="line"><span class="variable">$@</span>表示所有的命令行参数集合，<span class="variable">$0</span> <span class="variable">$1</span> <span class="variable">$2</span> ... <span class="variable">$n</span></span><br><span class="line">$*表示等价<span class="variable">$@</span></span><br><span class="line">$?表示上一条命令是否返回成功，成功为0,错误非0</span><br><span class="line">$$表示当前脚本的进程号</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/23.png" alt="image"></p>
<h2><span id="3-6-tiao-jian-yu-ju">3.6 条件语句</span><a href="#3-6-tiao-jian-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/24.png" alt="image"></p>
<h2><span id="3-7-case-yu-ju">3.7 case语句</span><a href="#3-7-case-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/25.png" alt="image"></p>
<h2><span id="3-8-han-shu">3.8 函数</span><a href="#3-8-han-shu" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/26.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/27.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/28.png" alt="image"></p>
<h2><span id="3-9-xun-huan-yu-ju">3.9 循环语句</span><a href="#3-9-xun-huan-yu-ju" class="header-anchor">#</a></h2><p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/29.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/30.png" alt="image"></p>
<p><img src="/2024/05/26/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E9%9B%86%E5%90%88/31.png" alt="image"></p>
<h2><span id="3-10-typeset-huo-zhe-declare">3.10 typeset或者declare</span><a href="#3-10-typeset-huo-zhe-declare" class="header-anchor">#</a></h2><p>sh脚本默认所有变量都是字符串，比如val&#x3D;1，也表示val是一个字符串“1”。那么需要如何声明一个变量类型，用typeset或者declare。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeset</span> -i data=1</span><br></pre></td></tr></table></figure>

<h2><span id="3-11-unset">3.11 unset</span><a href="#3-11-unset" class="header-anchor">#</a></h2><p>清除变量值.</p>
<h2><span id="3-12-readonly">3.12 readonly</span><a href="#3-12-readonly" class="header-anchor">#</a></h2><p>只读变量.</p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建nfs服务</title>
    <url>/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</a></li>
<li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li>
<li><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</a></li>
<li><a href="#4-pei-zhi-nfs">4 配置NFS</a></li>
<li><a href="#5-qi-dong-nfs-fu-wu">5 启动NFS服务</a></li>
<li><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xia-zai-an-zhuang-nfs-fu-wu">1 下载安装NFS服务</span><a href="#1-xia-zai-an-zhuang-nfs-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install nfs-kernel-server nfs-common</code></p>
<h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo ufw disable</code></p>
<h1><span id="3-chuang-jian-nfs-gong-xiang-wen-jian-jia">3 创建NFS共享文件夹</span><a href="#3-chuang-jian-nfs-gong-xiang-wen-jian-jia" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chown</span> book:book /home/book/nfs_share</span><br><span class="line">sudo <span class="built_in">chmod</span> 777 /home/book/nfs_share -R</span><br></pre></td></tr></table></figure>
<h1><span id="4-pei-zhi-nfs">4 配置NFS</span><a href="#4-pei-zhi-nfs" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br><span class="line">/home/book/nfs_share *(rw,<span class="built_in">sync</span>,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p>
<h1><span id="5-qi-dong-nfs-fu-wu">5 启动NFS服务</span><a href="#5-qi-dong-nfs-fu-wu" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nfs-kernel-serve</span><br><span class="line">或者sudo service nfs-kernel-server restart</span><br><span class="line">或者sudo /etc/init.d/nfs-kernel-server restart</span><br></pre></td></tr></table></figure>

<h1><span id="6-ke-hu-duan-jin-xing-nfs-gua-zai">6 客户端进行NFS挂载</span><a href="#6-ke-hu-duan-jin-xing-nfs-gua-zai" class="header-anchor">#</a></h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">运行开发板</span><br><span class="line"><span class="meta prompt_">[root@book]~# </span><span class="language-bash">mount -t nfs -o nolock -o tcp 192.168.2.100:/home/book/nfs_share /mnt/nfs</span></span><br><span class="line">-t nfs                          #挂载类型</span><br><span class="line">-o nolock                       #读写的时候不锁定</span><br><span class="line">-o tcp                          #tcp模式</span><br><span class="line">客户端退出NFS挂载</span><br><span class="line">umount /mnt/nfs</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建samba服务</title>
    <url>/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-an-zhuang-fu-wu">1 安装服务</a></li>
<li><a href="#2-guan-bi-fang-huo-qiang">2 关闭防火墙</a></li>
<li><a href="#3-tian-jia-yong-hu-book">3 添加用户book</a></li>
<li><a href="#4-chong-qi-fu-wu">4 重启服务</a></li>
<li><a href="#5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</a></li>
<li><a href="#6-chang-jian-wen-ti">6 常见问题</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-an-zhuang-fu-wu">1 安装服务</span><a href="#1-an-zhuang-fu-wu" class="header-anchor">#</a></h1><p><code>sudo apt-get install samba samba-common</code></p>
<h1><span id="2-guan-bi-fang-huo-qiang">2 关闭防火墙</span><a href="#2-guan-bi-fang-huo-qiang" class="header-anchor">#</a></h1><p><code>sudo systemctl stop ufw</code></p>
<h1><span id="3-tian-jia-yong-hu-book">3 添加用户book</span><a href="#3-tian-jia-yong-hu-book" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo smbpasswd -a book</span><br><span class="line">配置samba</span><br><span class="line">sudo vim /etc/samba/smb.conf</span><br><span class="line">[book_share_samba_dir]</span><br><span class="line">        comment = share samba <span class="built_in">dir</span></span><br><span class="line">        path = /home/book/ftp</span><br><span class="line">        valid <span class="built_in">users</span> = book</span><br><span class="line">        force user = book</span><br><span class="line">        force group = book</span><br><span class="line">        creat mask = 0644</span><br><span class="line">        directory mask = 0755</span><br><span class="line">        browseable= <span class="built_in">yes</span></span><br><span class="line">        available = <span class="built_in">yes</span></span><br><span class="line">        public = <span class="built_in">yes</span></span><br><span class="line">        <span class="built_in">read</span> only = no</span><br><span class="line">        writeable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<h1><span id="4-chong-qi-fu-wu">4 重启服务</span><a href="#4-chong-qi-fu-wu" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~$ sudo service smbd restart</span><br><span class="line">~$ sudo /etc/init.d/smbd restart</span><br><span class="line">~$ /etc/init.d/smbd restart</span><br></pre></td></tr></table></figure>



<h1><span id="5-windows-jin-xing-samba-ying-she">5 windows进行samba映射</span><a href="#5-windows-jin-xing-samba-ying-she" class="header-anchor">#</a></h1><p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/1.png" alt="img"></p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/2.png" alt="img"></p>
<p>注意不能用NAT虚拟网络IP访问samba, 要用桥接网络ip，不过ssh可以两种方式访问，但是NAT虚拟网络是用来虚拟机上网的IP地址可能会发生变化，还是建议用桥接网络IP地址。</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/3.png" alt="img"></p>
<h1><span id="6-chang-jian-wen-ti">6 常见问题</span><a href="#6-chang-jian-wen-ti" class="header-anchor">#</a></h1><p>samba不允许一个用户使用一个以上用户名与一个服务器或共享资源的多重连接，因此需要windows进入cmd</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/4.png" alt="img"></p>
<p>可以windows cmd下用 net use 命令查看下当前的共享访问到底有没有它。</p>
<p>有的话，net use * &#x2F;del &#x2F;y</p>
<p>重新映射网络驱动器即可</p>
<p><img src="/2024/03/27/linux%E6%90%AD%E5%BB%BAsamba%E6%9C%8D%E5%8A%A1/5.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>linux搭建tftp和ftp服务</title>
    <url>/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</a><ul>
<li><a href="#1-1-pei-zhi">1.1 配置</a></li>
<li><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</a></li>
<li><a href="#1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</a><ul>
<li><a href="#1-3-1-ben-ji-ce-shi">1.3.1 本机测试</a></li>
<li><a href="#1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ftp-fu-wu">2 ftp服务</a><ul>
<li><a href="#2-1-windows-ke-hu-duan">2.1 windows客户端</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-an-zhuang-tftp-fu-wu-he-ke-hu-duan">1 安装tftp服务和客户端</span><a href="#1-an-zhuang-tftp-fu-wu-he-ke-hu-duan" class="header-anchor">#</a></h1><pre><code>sudo apt-get install xinetd tftp tftpd
</code></pre>
<h2><span id="1-1-pei-zhi">1.1 配置</span><a href="#1-1-pei-zhi" class="header-anchor">#</a></h2><p>vim &#x2F;etc&#x2F;xinetd.d&#x2F;tftp<br>内容如下：</p>
<pre><code>service tftp
&#123;
        socket_type     		= dgram
        protocol                = udp
        wait                    = yes
        user                    = root
        server          		= /usr/sbin/in.tftpd
        server_args     		= -s /home/lyb/tftpshare/
        disable         		= no
        per_source      		=11
        cps                     = 100 2
        flags                   = IPv4
&#125;
</code></pre>
<h2><span id="1-2-chuang-jian-tftp-gong-xiang-mu-lu">1.2 创建tftp共享目录</span><a href="#1-2-chuang-jian-tftp-gong-xiang-mu-lu" class="header-anchor">#</a></h2><pre><code>1.创建服务器目录
mkdir /home/lyb/tftpshare/
2.然后修改目录权限
chmod 777 /home/lyb/tftpshare/
3.重启xinetd服务
sudo /etc/init.d/xinetd restart（如果启动失败先关闭防火墙 service iptables stop）
</code></pre>
<h2><span id="1-3-ce-shi-yan-zheng-gong-neng">1.3 测试验证功能</span><a href="#1-3-ce-shi-yan-zheng-gong-neng" class="header-anchor">#</a></h2><h3><span id="1-3-1-ben-ji-ce-shi">1.3.1 本机测试</span><a href="#1-3-1-ben-ji-ce-shi" class="header-anchor">#</a></h3><pre><code>重新启动一个终端，
输入命令 tftp 192.168.1.11（我的虚拟机ip）进入tftp,
输入get test,这样就可以获取到test文件,
输入q退出tftp
</code></pre>
<p>如下图所示：<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/1.png" alt="1"></p>
<h3><span id="1-3-2-kai-fa-ban-ce-shi">1.3.2 开发板测试</span><a href="#1-3-2-kai-fa-ban-ce-shi" class="header-anchor">#</a></h3><p>2440开发板的uboot可以支持tftp下载功能，在uboot命令行输入：</p>
<pre><code>tftp 0x30000000  uImage_4.3
</code></pre>
<p>如下图所示。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/2.png" alt="2"></p>
<h1><span id="2-ftp-fu-wu">2 ftp服务</span><a href="#2-ftp-fu-wu" class="header-anchor">#</a></h1><pre><code>sudo apt install vsftpd
vi /etc/vsftpd.conf

local_enable=YES
write_enable=YES
sudo /etc/init.d/vsftpd restart
</code></pre>
<p><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/3.png" alt="3"></p>
<h2><span id="2-1-windows-ke-hu-duan">2.1 windows客户端</span><a href="#2-1-windows-ke-hu-duan" class="header-anchor">#</a></h2><p><a href="https://filezilla-project.org/">https://filezilla-project.org/</a></p>
<p>新建站点，配置ftp协议, 主机输入ubuntu IP地址，用户密码信息，即可连接成功。<br><img src="/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/4.png" alt="4"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法教程</title>
    <url>/2024/05/26/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-duo-ji-biao-ti-mu-lu-jie-gou">1 多级标题目录结构</a></li>
<li><a href="#yi-ji-biao-ti">一级标题</a><ul>
<li><a href="#er-ji-biao-ti">二级标题</a><ul>
<li><a href="#san-ji-biao-ti">三级标题</a><ul>
<li><a href="#si-ji-biao-ti">四级标题</a><ul>
<li><a href="#wu-ji-biao-ti">五级标题</a><ul>
<li><a href="#liu-ji-biao-ti">六级标题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-duan-luo">2 段落</a><ul>
<li><a href="#2-1-huan-xing">2.1 换行</a></li>
</ul>
</li>
<li><a href="#3-zi-ti">3 字体</a></li>
<li><a href="#4-zi-ti-yan-se-da-xiao">4 字体颜色,大小</a></li>
<li><a href="#5-zi-ti-bei-jing-yan-se">5 字体背景颜色</a></li>
<li><a href="#5-xia-hua-xian">5 下划线</a></li>
<li><a href="#6-lie-biao-xiang">6 列表项</a></li>
<li><a href="#7-dai-ma-kuai-yu-yu-fa-gao-liang">7 代码块与语法高亮</a><ul>
<li><a href="#7-1-xing-nei-dai-ma">7.1 行内代码</a></li>
<li><a href="#7-2-kuai-dai-ma">7.2 块代码</a></li>
</ul>
</li>
<li><a href="#8-dai-ma-zhe-die">8 代码折叠</a></li>
<li><a href="#9-cha-ru-lian-jie">9 插入链接</a><ul>
<li><a href="#9-1-zi-dong-lian-jie">9.1 自动链接</a></li>
</ul>
</li>
<li><a href="#10-tian-jia-tu-pian">10 添加图片</a></li>
<li><a href="#11-biao-ge">11 表格</a></li>
<li><a href="#12-zhuan-yi-zi-fu">12 转义字符</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-duo-ji-biao-ti-mu-lu-jie-gou">1 多级标题目录结构</span><a href="#1-duo-ji-biao-ti-mu-lu-jie-gou" class="header-anchor">#</a></h1><pre><code># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<p>效果如下：</p>
<h1><span id="yi-ji-biao-ti">一级标题</span><a href="#yi-ji-biao-ti" class="header-anchor">#</a></h1><h2><span id="er-ji-biao-ti">二级标题</span><a href="#er-ji-biao-ti" class="header-anchor">#</a></h2><h3><span id="san-ji-biao-ti">三级标题</span><a href="#san-ji-biao-ti" class="header-anchor">#</a></h3><h4><span id="si-ji-biao-ti">四级标题</span><a href="#si-ji-biao-ti" class="header-anchor">#</a></h4><h5><span id="wu-ji-biao-ti">五级标题</span><a href="#wu-ji-biao-ti" class="header-anchor">#</a></h5><h6><span id="liu-ji-biao-ti">六级标题</span><a href="#liu-ji-biao-ti" class="header-anchor">#</a></h6><h1><span id="2-duan-luo">2 段落</span><a href="#2-duan-luo" class="header-anchor">#</a></h1><h2><span id="2-1-huan-xing">2.1 换行</span><a href="#2-1-huan-xing" class="header-anchor">#</a></h2><p>Markdown段落的换行是使用两个以上空格加上回车，当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p>
<h1><span id="3-zi-ti">3 字体</span><a href="#3-zi-ti" class="header-anchor">#</a></h1><pre><code>*斜体*
**粗体**
***加粗斜体***

&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;
&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;
&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;
</code></pre>
<p>效果：</p>
<p><em>斜体</em><br><strong>粗体</strong><br><em><strong>加粗斜体</strong></em></p>
<p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font></p>
<h1><span id="4-zi-ti-yan-se-da-xiao">4 字体颜色,大小</span><a href="#4-zi-ti-yan-se-da-xiao" class="header-anchor">#</a></h1><pre><code>&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;
&lt;font color=gray size=5&gt;gray&lt;/font&gt;
&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;
</code></pre>
<p>效果：</p>
<p><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="gray" size="5">gray</font><br><font color="#00ffff" size="3">null</font></p>
<h1><span id="5-zi-ti-bei-jing-yan-se">5 字体背景颜色</span><a href="#5-zi-ti-bei-jing-yan-se" class="header-anchor">#</a></h1><pre><code>&lt;table&gt;&lt;td bgcolor=pink&gt; 
背景色是pink &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=LightGoldenRodYellow&gt; 
LightGoldenRodYellow &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PeachPuff&gt; 
PeachPuff &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PapayaWhip&gt; 
PapayaWhip &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PaleGreen&gt; 
PaleGreen &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=PaleGoldenRod&gt; 
PaleGoldenRod &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=MistyRose&gt; 
MistyRose &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=Linen&gt; 
Linen &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=LightPink&gt; 
LightPink &lt;/table&gt;

&lt;table&gt;&lt;td bgcolor=BurlyWood&gt; 
BurlyWood &lt;/table&gt;
</code></pre>
<p>效果：</p>
<table><td bgcolor="pink"> 
背景色是pink </td></table>

<table><td bgcolor="LightGoldenRodYellow"> 
LightGoldenRodYellow </td></table>

<table><td bgcolor="PeachPuff"> 
PeachPuff </td></table>

<table><td bgcolor="PapayaWhip"> 
PapayaWhip </td></table>

<table><td bgcolor="PaleGreen"> 
PaleGreen </td></table>

<table><td bgcolor="PaleGoldenRod"> 
PaleGoldenRod </td></table>

<table><td bgcolor="MistyRose"> 
MistyRose </td></table>

<table><td bgcolor="Linen"> 
Linen </td></table>

<table><td bgcolor="LightPink"> 
LightPink </td></table>

<table><td bgcolor="BurlyWood"> 
BurlyWood </td></table>


<h1><span id="5-xia-hua-xian">5 下划线</span><a href="#5-xia-hua-xian" class="header-anchor">#</a></h1><p>写法：<br>    <code>&lt;u&gt;下划线&lt;/u&gt;</code></p>
<p>效果如下：<br><u>下划线</u></p>
<h1><span id="6-lie-biao-xiang">6 列表项</span><a href="#6-lie-biao-xiang" class="header-anchor">#</a></h1><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记：</p>
<pre><code>* 第一项
* 第二项
* 第三项
</code></pre>
<p>显示效果：  </p>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<p>有序列表使用数字并加上 <code>.</code> 号来表示： 	<br>    1. 第一项<br>        1. 小一项<br>        2. 小二项<br>    2. 第二项<br>    3. 第三项<br>显示效果： </p>
<ol>
<li>第一项<ol>
<li>小一项</li>
<li>小二项</li>
</ol>
</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h1><span id="7-dai-ma-kuai-yu-yu-fa-gao-liang">7 代码块与语法高亮</span><a href="#7-dai-ma-kuai-yu-yu-fa-gao-liang" class="header-anchor">#</a></h1><h2><span id="7-1-xing-nei-dai-ma">7.1 行内代码</span><a href="#7-1-xing-nei-dai-ma" class="header-anchor">#</a></h2><p>用反引号 &#96;&#96; 来标记或插入代码区段</p>
<p>效果：<br><code>int main(void)</code></p>
<h2><span id="7-2-kuai-dai-ma">7.2 块代码</span><a href="#7-2-kuai-dai-ma" class="header-anchor">#</a></h2><p>用tab键或者用&#96;&#96;&#96;</p>
<p>效果：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(vpod)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="8-dai-ma-zhe-die">8 代码折叠</span><a href="#8-dai-ma-zhe-die" class="header-anchor">#</a></h1><p>写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;点击展开代码&lt;/summary&gt;</span><br><span class="line">&lt;pre&gt;&lt;code&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<details>
<summary>点击展开代码</summary>
<pre><code>
    #include &lt;stdio.h&gt;
    int main(int argc, char **argv)
    &#123;
        printf("hello world\n");
        return 0;
    &#125;

<p></p></code></pre><p></p>
</details>

<h1><span id="9-cha-ru-lian-jie">9 插入链接</span><a href="#9-cha-ru-lian-jie" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用:</span><br><span class="line">[fuzidage的博客](https://www.cnblogs.com/fuzidage/)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><a href="https://www.cnblogs.com/fuzidage/">fuzidage的博客</a></p>
<h2><span id="9-1-zi-dong-lian-jie">9.1 自动链接</span><a href="#9-1-zi-dong-lian-jie" class="header-anchor">#</a></h2><p>只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接：</p>
<p>效果：<br><a href="https://github.com/fuzidage">https://github.com/fuzidage</a></p>
<h1><span id="10-tian-jia-tu-pian">10 添加图片</span><a href="#10-tian-jia-tu-pian" class="header-anchor">#</a></h1><pre><code>写法：![](https://img2018.cnblogs.com/blog/1876680/201912/1876680-20191214155002138-1798053565.png)
当然如果是本地图片写法：
![](./markdown语法教程/1.png)
</code></pre>
<p>引用网络效果：</p>
<p><img src="https://img2018.cnblogs.com/blog/1876680/201912/1876680-20191214155002138-1798053565.png"></p>
<p>引用本地图片效果：<br><img src="/2024/05/26/markdown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/1.png" alt="image-20240526174126727"></p>
<h1><span id="11-biao-ge">11 表格</span><a href="#11-biao-ge" class="header-anchor">#</a></h1><p>写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----:|</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h1><span id="12-zhuan-yi-zi-fu">12 转义字符</span><a href="#12-zhuan-yi-zi-fu" class="header-anchor">#</a></h1><table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>输入</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td>&amp;nbsp；</td>
<td>&amp;#160；</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt；</td>
<td>&amp;#60；</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt；</td>
<td>&amp;#62；</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp；</td>
<td>&amp;#38；</td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td>&amp;quot；</td>
<td>&amp;#34；</td>
</tr>
<tr>
<td>‘</td>
<td>撇号</td>
<td>&amp;apos；</td>
<td>(IE不支持)	&amp;#39；</td>
</tr>
<tr>
<td>￠</td>
<td>分</td>
<td>&amp;cent；</td>
<td>&amp;#162；</td>
</tr>
<tr>
<td>£</td>
<td>镑</td>
<td>&amp;pound；</td>
<td>&amp;#163；</td>
</tr>
<tr>
<td>¥</td>
<td>日圆</td>
<td>&amp;yen；</td>
<td>&amp;#165；</td>
</tr>
<tr>
<td>§</td>
<td>节</td>
<td>&amp;sect；</td>
<td>&amp;#167；</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy；</td>
<td>&amp;#169；</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg；</td>
<td>&amp;#174；</td>
</tr>
<tr>
<td>×</td>
<td>乘号</td>
<td>&amp;times；</td>
<td>&amp;#215；</td>
</tr>
<tr>
<td>÷</td>
<td>除号</td>
<td>&amp;divide；</td>
<td>&amp;#247；</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>mipi-csi硬件篇</title>
    <url>/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi-ying-jian">1 mipi-csi硬件</a><ul>
<li><a href="#1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</a></li>
<li><a href="#1-2-mipi-vs-dvp">1.2 MIPI vs DVP</a></li>
<li><a href="#1-3-csi-gui-ge">1.3 CSI规格</a></li>
<li><a href="#1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</a></li>
<li><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</a><ul>
<li><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</a></li>
<li><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</a></li>
</ul>
</li>
<li><a href="#1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</a></li>
<li><a href="#1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>
# 1 mipi-csi硬件

<h2><span id="1-1-mipi-csi-gai-nian">1.1 mipi-csi概念</span><a href="#1-1-mipi-csi-gai-nian" class="header-anchor">#</a></h2><p><strong>DSI （Display serial interface）</strong>定义了一个位于处理器和显示模组之间的高速串行接口,对应MIPI-TX.<br><strong>CSI(Camera Serial Interface）</strong>定义了一个位于处理器和摄像模组之间的高速串行接口,也就是接下来要讲的MIPI-RX。</p>
<p>MIPI Rx (Mobile Industry Processor Interface Receiver) 模塊主要功能為接收由 CMOS sensor 所傳送的視頻數據， 支持 MIPI D-PHY、 sub-LVDS (Low-Voltage Differential Signal)、 HiSPi (High-Speed Serial Pixel Interface) 等不同的串行視頻信號輸入， 並將其處理轉化為內部視頻時序，傳遞給下一級的視頻處理模塊 (ISP)。MIPI Rx 模塊中可細分為 PHY 和 Controller 兩部分，其中 PHY 模塊集成了模擬和數字兩個部分，主要將串行信號轉換為並行信號，而 Controller 模塊則負責解碼不同的視頻數據格式，傳送給後端的視頻處理模塊 (ISP)。功能框圖及在系統中的位置如下图所示:</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<h2><span id="1-2-mipi-vs-dvp">1.2 MIPI vs DVP</span><a href="#1-2-mipi-vs-dvp" class="header-anchor">#</a></h2><p><strong>DVP:</strong></p>
<p>并口传输数据需要帧同步信号（Vsync）、行同步信号（Hsync）和八条数据线，共十根数据线, DVP 接口在信号完整性方面受限制，速率也受限制。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>MIPI:</strong></p>
<p>MIPI 传输只需要帧同步信号（Vsync）、行同步信号（Hsync）、mipi 时钟（mipi_clk）、mipi 数据（mipi_data）和像素时钟（PCLK）5 根数据线。对比MIPI 接口比 DVP 的接口信号线少，由于是低压差分信号，产生的干扰小，抗干扰能力也强。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<h2><span id="1-3-csi-gui-ge">1.3 CSI规格</span><a href="#1-3-csi-gui-ge" class="header-anchor">#</a></h2><p>可同時支持 2 路 sensor 輸入（2组D-PHY， 每组5对差分线（1C4D））</p>
<p>• sensor 0 最大支持 4K2K @60fps HDR or @30fps 線性輸入</p>
<p>• sensor 1 最大支持 3M(2304x1296) @60fps HDR or linear 輸入</p>
<p>• 單路最多支持 4-Lane MIPI D-PHY 接口，最大支持 2.5Gbps&#x2F;Lane</p>
<p>• 單路最多支持 4-Lane sub-LVDS&#x2F; HiSPi 接口，最大支持 1.5Gbps&#x2F;Lane</p>
<p>• 支持 RAW8&#x2F; RAW10&#x2F; RAW12 數據類型的解析</p>
<p>• 支持 YUV422 8-bit&#x2F; YUV422 10-bit 數據類型的解析</p>
<p>• 最多支持 2 幀 WDR，支持多種 WDR 時序</p>
<p>• 支持 sub-LVDS&#x2F; HiSPi 模式像素&#x2F;同步碼大小端配置</p>
<p>• 支持 Lane 數和 Lane 順序可配置</p>
<p>MIPI Rx 的帶寬有兩部分限制： PHY 的接口數據率和內部處理速度。</p>
<p>輸入接口最大支持 2.5Gbps&#x2F;Lane，內部處理速度最大為 600M*1pixels&#x2F;s（MAC clk）</p>
<h2><span id="1-4-csi-jie-kou-lei-xing">1.4 CSI接口類型</span><a href="#1-4-csi-jie-kou-lei-xing" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>Common modevoltage</th>
<th>Differential modevoltage</th>
<th>Maximum clockfrequency</th>
<th>Maximum datarate per lane</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MIPI DPHY</strong> 200mV</td>
<td>200mV</td>
<td>1.25GHz</td>
<td>2.5Gbps</td>
</tr>
<tr>
<td>Sub-LVDS 900mV</td>
<td>150mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(HiVCM) 900mV</td>
<td>280mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
<tr>
<td>HiSPi(SLVDS) 200mV</td>
<td>200mV</td>
<td>750MHz</td>
<td>1.5Gbps</td>
</tr>
</tbody></table>
<h2><span id="1-5-csi-ying-jian-yin-jiao-ji-jie-xian">1.5 CSI 硬件引脚及接线</span><a href="#1-5-csi-ying-jian-yin-jiao-ji-jie-xian" class="header-anchor">#</a></h2><p>常用的电脑摄像头是USB接口, 主流的智能手机摄像头是MIPI接口, 下面讲解常用的智能手机 camera MIPI接口。</p>
<p>MIPI CSI一般会有1对I2C通信引脚，1对MIPI差分时钟引脚和1~4对MIPI差分数据信号引脚, 也就是1CD4(1 clk lane &amp; 4 data lane)。</p>
<h3><span id="1-5-1-mipi-sensor-yin-jiao-miao-shu">1.5.1 mipi sensor引脚描述:</span><a href="#1-5-1-mipi-sensor-yin-jiao-miao-shu" class="header-anchor">#</a></h3><table>
<thead>
<tr>
<th>信号名</th>
<th>引脚类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>DOVDD</td>
<td>电源</td>
<td>1.8V IO 电源</td>
</tr>
<tr>
<td>DVDD</td>
<td>电源</td>
<td>1.2V 数字电源</td>
</tr>
<tr>
<td>AVDD</td>
<td>电源</td>
<td>2.8V 模拟电源</td>
</tr>
<tr>
<td>SCL</td>
<td>输入</td>
<td>I2C 时钟线</td>
</tr>
<tr>
<td>SDA</td>
<td>输入&#x2F;输出</td>
<td>I2C 数据线(open drain)</td>
</tr>
<tr>
<td>SID0</td>
<td>输入</td>
<td>I2C Device ID 的选择 0 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>SID1</td>
<td>输入</td>
<td>I2C Device ID 的选择 1 (内置下拉电阻，默认Device ID 是 7’h30)</td>
</tr>
<tr>
<td>XSHUTDN （RST）</td>
<td>输入</td>
<td>复位信号输入(内置上拉电阻，低电位有效)</td>
</tr>
<tr>
<td>EXTCLK</td>
<td>输入</td>
<td>时钟输入</td>
</tr>
<tr>
<td>PWDNB</td>
<td>输入</td>
<td>Power Down 信号输入(内置上拉电阻， 低电位有效)</td>
</tr>
<tr>
<td>D&lt;3&gt;(MD3P)</td>
<td>输出</td>
<td>DVP 输出 bit[3]&#x2F;MIPI 数据 3 正极信号</td>
</tr>
<tr>
<td>D&lt;5&gt;(MD1P)</td>
<td>输出</td>
<td>DVP 输出 bit[5]&#x2F;MIPI 数据 1 正极信号</td>
</tr>
<tr>
<td>D&lt;7&gt;(MCP)</td>
<td>输出</td>
<td>DVP 输出 bit[7]&#x2F;MIPI 时钟正极信号</td>
</tr>
<tr>
<td>D&lt;8&gt;(MD0P)</td>
<td>输出</td>
<td>DVP 输出 bit[8]&#x2F;MIPI 数据 0 正极信号</td>
</tr>
<tr>
<td>D&lt;10&gt;(MD2P)</td>
<td>输出</td>
<td>DVP 输出 bit[10]&#x2F;MIPI 数据 2 正极信号</td>
</tr>
<tr>
<td>D&lt;4&gt;(MD3N)</td>
<td>输出</td>
<td>DVP 输出 bit[4]&#x2F;MIPI 数据 3 负极信号</td>
</tr>
<tr>
<td>D&lt;6&gt;(MD1N)</td>
<td>输出</td>
<td>DVP 输出 bit[6]&#x2F;MIPI 数据 1 负极信号</td>
</tr>
<tr>
<td>PCLK(MCN)</td>
<td>输出</td>
<td>DVP 输出时钟&#x2F;MIPI 时钟负极信号</td>
</tr>
<tr>
<td>D&lt;9&gt;(MD0N)</td>
<td>输出</td>
<td>DVP 输出 bit[9]&#x2F;MIPI 数据 0 负极信号</td>
</tr>
<tr>
<td>D&lt;11&gt;(MD2N)</td>
<td>输出</td>
<td>DVP 输出 bit[11]&#x2F;MIPI 数据 2 负极信号</td>
</tr>
</tbody></table>
<h3><span id="1-5-2-dian-lu-tu-xian-lu-jie-gou">1.5.2 电路图线路结构</span><a href="#1-5-2-dian-lu-tu-xian-lu-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<p>一般mipi接口的sensor支持4 lane，2 lane，1 lane等数据传输方式。上图硬件上的连接了1组clk lane, 4组data lane。这幅图只连接了i2c和lane总线，还有EXTCLK ，PWDN, RST, VDD等引脚的连线需要外部soc去提供。这里就需要驱动人员会看原理图，知道lane id和pn swap的接线。clk lane, data lane等。</p>
<h2><span id="1-6-chai-fen-xin-hao-jie-shao">1.6 差分信号介绍</span><a href="#1-6-chai-fen-xin-hao-jie-shao" class="header-anchor">#</a></h2><p>我们用一个方法对差分信号做一下比喻，差分信号就好比是跷跷板上的两个人，当一个人被跷上去的时候，另一个人被跷下来了 - 但是他们的平均位置是不变的。继续跷跷板的类推，正值可以表示左边的人比右边的人高，而负值表示右边的人比左边的人高。0 表示两个人都是同一水平。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<p>下图，应用到电学上，这两个跷跷板用一对标识为V+和V-的导线来表示。当V+ &gt; V-时，信号定义成正极信号，V+ &lt; V-时，信号定义成负极信号。 差分对的平均电压设置成 2.5V。</p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<h2><span id="1-7-mipi-sensor-de-power-on-shi-xu">1.7 MIPI sensor的 power on时序</span><a href="#1-7-mipi-sensor-de-power-on-shi-xu" class="header-anchor">#</a></h2><p><strong>Sony imx334：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p><strong>SC4210：</strong></p>
<p><img src="/2024/04/02/mipi-csi%E7%A1%AC%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<p>这里列举了sony imx334和格科微gc2093, sc4210的上电时序，现在市面上大部分的mipi接口sensor都可以让VDD，PWDN, RST，EXTCLK讯号同时发出，然后过一段时间后就可以进行I2c通信了。</p>
<p>在HW交接到SW后，要确保最基本的power on时序是ok的，最好是用示波器对VDD，PWDN, RST，EXTCLK，I2c等波形进行测量无误后再porting到SW手上。</p>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>mipi-csi软件篇</title>
    <url>/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</a></li>
<li><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</a><ul>
<li><a href="#2-1-chuan-shu-mo-shi">2.1 传输模式</a></li>
<li><a href="#2-2-lane-states">2.2 lane states</a></li>
<li><a href="#2-3-lane-levels">2.3 Lane Levels</a></li>
<li><a href="#2-4-cao-zuo-mo-shi">2.4 操作模式</a></li>
<li><a href="#2-5-shi-zhong-mo-shi">2.5 时钟模式</a></li>
<li><a href="#2-6-shi-xu-yao-qiu">2.6 时序要求</a></li>
<li><a href="#2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</a></li>
<li><a href="#2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</a></li>
</ul>
</li>
<li><a href="#3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</a><ul>
<li><a href="#3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</a></li>
<li><a href="#3-2-bao-lei-xing">3.2 包类型</a><ul>
<li><a href="#3-2-1-duan-bao-jie-gou">3.2.1 短包结构</a></li>
<li><a href="#3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</a></li>
<li><a href="#3-2-3-chang-bao-jie-gou">3.2.3 长包结构</a></li>
<li><a href="#3-2-4-h-blanking-v-blanking">3.2.4 H-blanking &amp; V-blanking</a></li>
<li><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</a><ul>
<li><a href="#3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</a></li>
<li><a href="#3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</a><ul>
<li><a href="#4-1-rgb-ge-shi">4.1 RGB格式</a></li>
<li><a href="#4-2-yuv-ge-shi">4.2 YUV格式</a><ul>
<li><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</a><ul>
<li><a href="#4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</a></li>
<li><a href="#4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</a></li>
<li><a href="#4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</a></li>
</ul>
</li>
<li><a href="#4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</a><ul>
<li><a href="#4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</a><ul>
<li><a href="#4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</a></li>
<li><a href="#4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</a></li>
<li><a href="#4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</a></li>
<li><a href="#4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</a></li>
</ul>
</li>
<li><a href="#4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</a><ul>
<li><a href="#4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</a></li>
<li><a href="#4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-3-raw-ge-shi">4.3 RAW 格式</a><ul>
<li><a href="#4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</a></li>
<li><a href="#6-se-cai-shen-du">6 色彩深度</a></li>
<li><a href="#7-tu-xiang-jie-xi-du-fen-bian-lu">7 图像解析度&#x2F;分辨率</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-mipi-csi2-de-fa-song-he-jie-shou">1 MIPI CSI2的发送和接收</span><a href="#1-mipi-csi2-de-fa-song-he-jie-shou" class="header-anchor">#</a></h1><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/1.png" alt="img"></p>
<p>上图反映了sensor 和 soc 的数据关系，soc 通过 CCI (Camera Control Interface) 控制 sensor 寄存器，配置正确，sensor 将会通过 mipi 接口输出图像数据。</p>
<p>控制信息是 soc 通过 CCI 发送到 sensor，CCI 接口一般的就是 I2C 接口,最大支持400KHz。</p>
<p>data信息是CSI DPHY发送者发送到CSI DPHY接收者，由sensor端发送到soc的mipi-rx。</p>
<h1><span id="2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi">2 D-PHY(DSI和CSI的物理层定义)</span><a href="#2-d-phy-dsi-he-csi-de-wu-li-ceng-ding-yi" class="header-anchor">#</a></h1><p>D-PHY 是 MIPI 聯盟發布的高速物理層標準，規定了接口層的物理特性和傳輸協議。 DPHY 採用了 200mV 源同步的低压差分信號技術，每個 Lane 的數據綠率範圍支持到2500Mbps。 D-PHY 可以工作在低功耗 (Low Power, LP) 和高速 (High Speed, HS) 兩種模式下。</p>
<h2><span id="2-1-chuan-shu-mo-shi">2.1 传输模式</span><a href="#2-1-chuan-shu-mo-shi" class="header-anchor">#</a></h2><p><strong>LP（Low-Power） 模式</strong>：用于传输控制信号，最高速率 10 MHz</p>
<p><strong>HS（High-Speed）模</strong>式：用于高速传输数据，速率范围 [80 Mbps， 2.5Gbps] per Lane</p>
<p>传输的最小单元为 1 个字节，采用小端的方式，也就是 LSB first，MSB last。</p>
<p><strong>相关缩写名</strong>词：</p>
<p>HS-RX：高速接收器<br>HS-TX：高速发送器<br>LP-RX：低功耗接收器<br>LP-TX：低功耗发送器<br>LPS:  Low Power State, 封包之間的spacing間距。<br>ST:    Start of Transmission (SoT), 封包的起始訊號, 一般為低速轉換為高速的暫態訊號。<br>ET:    End of Transmission (EoT), 封包的結束訊號, 一般為高速轉換為低速的暫態訊號。<br>PH:   Packet Header, 32 bit表示, 為封包的標頭。<br>PF:    Packet Footer, 16 bit表示, 為封包的結尾。</p>
<h2><span id="2-2-lane-states">2.2 lane states</span><a href="#2-2-lane-states" class="header-anchor">#</a></h2><p>*  LP mode 有 4 种状态： LP00、LP01（<strong>0</strong>）、LP10（<strong>1</strong>）、LP11 （Dp、Dn）</p>
<p>* HS mode 有 2 种状态： HS-0、HS-1</p>
<p>HS 发送器发送的数据 LP 接收器看到的都是 LP00。</p>
<h2><span id="2-3-lane-levels">2.3 Lane Levels</span><a href="#2-3-lane-levels" class="header-anchor">#</a></h2><p>* LP： 0 ~ 1.2V</p>
<p>* HS： 100 ~ 300mV，HS common level &#x3D; 200mV，swing &#x3D; 200 mv</p>
<h2><span id="2-4-cao-zuo-mo-shi">2.4 操作模式</span><a href="#2-4-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p> • 数据Lane的3种操作模式 </p>
<ul>
<li><p>Escape mode,</p>
</li>
<li><p>High-Speed(Burst) mode</p>
</li>
<li><p>Control mode</p>
<p><strong>①Escape mode request</strong><br> LP-11→LP-10→LP-00→LP-01→LP-00<br> exit:LP-10 -&gt; LP-11</p>
</li>
</ul>
<p>当进入 Escape mode 需要发送 8-bit entry command 表明请求的动作，比如要进行低速数据传输则需要发送 cmd： 0x87，进入超低功耗模式则发送 cmd： 0x78。</p>
<p>  <strong>②High-Speed mode request :</strong><br>    LP-11→LP-01→LP-00-&gt;SOT(0001_1101)<br>    exit: EOT -&gt; LP-11</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/2.png" alt="img"></p>
<p><strong>③Turnaround request</strong><br>    LP-11→LP-10→LP-00→LP-10→LP-00</p>
<p>这是开启 BTA 的时序，一般用于从 slave 返回数据如 ACK： 0x84.<br>    exit：LP00→LP10→LP11</p>
<p> 最常用的就是“低功耗进入高速模式”如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/3.png" alt="img"></p>
<p>我们的D0-D4都是一个差分信号，它从lowpower state进入到HS后，从hi speed mode 中sync出我们的data。</p>
<p>sensor控制的信号由绿色框圈出来，主要是以下三个讯号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HS-Prepare：表示从low power mode进入到hi speed mode需要prepare一段时间</span><br><span class="line">Hs-zero: 表示从low power mode进入到hi speed mode需要keep LP-00状态一段时间</span><br><span class="line">Hs-trail:表示送完1 st data后需要keep一段时间后才允许进入low power mode，进行下一轮数据传输。</span><br></pre></td></tr></table></figure>

<p>soc端的控制的信号由黄色框圈出来:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hs-settle:表示soc要等一段时间才去开始去parse “sync code”, 当抓到sync code后表示sensor已经进入了hi speed mode， 这个时候就可以sync data了。</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.每次EOT(end of trans)结束讯号后，都会进入low power mode，而不是sensor 工作后就一直处于hi speed mode。也就是每传一个package，都会走一遍上述的过程。</p>
<p>2.hs-settle为mclk&#x2F;8 *n(这个n表示配置几个clk，对应code的话配置这个mipi_dev_attr_s-&gt;dphy)</p>
<p>当hs-settle的时间太长会压到data中的“sync code”,那么就会出现sync code parse不到,出现ecc err. 又或者从data中parse到一个假的“sync code”，那么最后就会出现数据不太对，出现ecc err.</p>
<p>Ecc还有一种出现可能就是lane mapping 出错，当我们传输数据出现ecc err, 有可能就是传输short pack时，4 byte的short pack拼接的不对（详见CSI的数据包结构），导致出现ecc error.</p>
<p>3.如果hs-trail持续的太短（拉高的太快），有可能会压到最后面的data，所以会出现crc&#x2F;wc(word count ) err.另外，如果hs -settle太大，也有可能hs-trail也会是错误的数据，所以出现wc, crc err，因此不一定是hs-trail的问题，得先确保前面的ecc&#x2F;decode无误后再来调整hs-trail。</p>
<p>一般排查流程如下：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/4.png" alt="img"></p>
<h2><span id="2-5-shi-zhong-mo-shi">2.5 时钟模式</span><a href="#2-5-shi-zhong-mo-shi" class="header-anchor">#</a></h2><ul>
<li>连续时钟模式：数据包传输间隔，clk lane 保持在高速模式；</li>
<li>非连续时钟模式：数据包传输间隔，clk lane 进入 LP-11 状态，退出hi speed mode；</li>
</ul>
<h2><span id="2-6-shi-xu-yao-qiu">2.6 时序要求</span><a href="#2-6-shi-xu-yao-qiu" class="header-anchor">#</a></h2><p>在调试 DSI 或者 CSI 的时候， HS mode 下的几个时序非常重要：T_LPX，T_HS-SETTLE ≈ T_HS-PREPARE + T_HS-ZERO，T_HS-TRAIL，一般遵循的原则为：Host 端的 T_HS-SETTLE &gt; Slave 端的 T_HS-SETTLE。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/5.png" alt="img"></p>
<h2><span id="2-7-start-of-transmission-sot-guo-cheng">2.7 Start-of-Transmission ( SoT )过程</span><a href="#2-7-start-of-transmission-sot-guo-cheng" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/6.png" alt="img"></p>
<p>当要进行数据传输的时候，data lane 将会通过信号（SoT）退出停止状态，进入高速模式。过程如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>退出停止状态 ( LP-11 )</td>
<td>检测停止状态</td>
</tr>
<tr>
<td>进入 HS-Rqst 状态 ( LP-01 )，并处于该状态的时间间隔为 TLPX</td>
<td>检测到 lane 从 LP-11 转变为 LP-01</td>
</tr>
<tr>
<td>进入 Bridge 状态 ( LP-00 )，并处于该状态的时间间隔为 THS-PREPARE</td>
<td>检测到 lane 从 LP-01 转变为 LP-00，间隔 TD-TERM-EN 时间之后将使能传输</td>
</tr>
<tr>
<td>同时退出低功耗模式，进入高速模式</td>
<td></td>
</tr>
<tr>
<td>处于 HS-0 状态，时长为 THS-ZERO</td>
<td>使能 HS-RX 并等待 THS-SETTLE，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>开始从数据流中等待同步序列</td>
</tr>
<tr>
<td>时钟上升边缘插入 HS 同步序列 ‘00011101’</td>
<td></td>
</tr>
<tr>
<td></td>
<td>识别到同步序列 ‘00011101’</td>
</tr>
<tr>
<td>高速模式开始传输有效数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td>接收到有效数据</td>
</tr>
</tbody></table>
<h2><span id="2-8-end-of-transmission-eot-guo-cheng">2.8 End-of-Transmission ( EoT )过程</span><a href="#2-8-end-of-transmission-eot-guo-cheng" class="header-anchor">#</a></h2><p>在数据完成传输时，通过结束传输（EoT）过程，数据通道退出高速模式并进入停止状态，这个过程状态变化如下：</p>
<table>
<thead>
<tr>
<th><strong>TX Side</strong></th>
<th><strong>RX Side</strong></th>
</tr>
</thead>
<tbody><tr>
<td>传输数据</td>
<td>接收到数据</td>
</tr>
<tr>
<td>在完成最后一个字节数据的传输之后，保持该状态的时间间隔为 THS-TRAIL</td>
<td></td>
</tr>
<tr>
<td>关闭 HS-TX，启用 LP-TX，并在 THS-EXIT一段时间内处于停止状态 ( LP-11 )</td>
<td>检测到 lane 状态进入停止状态 ( LP-11 )，关闭传输功能</td>
</tr>
<tr>
<td></td>
<td>忽略 THS-SKIP一段时间内的 lane 变化，以忽略转换状态</td>
</tr>
<tr>
<td></td>
<td>检测有效数据的最后一次转换，确定最后一次有效数据并忽略包尾序列</td>
</tr>
</tbody></table>
<p>接收器是如何判断数据将要开始传输了呢？</p>
<p>当出现LP11→LP01→LP00时，接收器将会判断，将会有数据达到，同时，使用示波器查看mipi波形，将会发现在PL00（THS-PREPARE）时会有一个小脉冲（峰刺），一般的，在这个小脉冲之后，接收器将会打开比较器（由于在THS-PREPARE会有这个小脉冲的存在，所以在接收器中，会通过设置接收器的settle time，避开这个小脉冲，在这个脉冲之后再打开比较器），准备接收数据。而HS-00011101则表示有效数据开始，同时数据的开头，将会有数据表明将要数据的数据量，所以mipi接收器将会按其数据量接收，直到接收完成。<br>每根 lane（data lane&#x2F;clk lane）从 LP 模式切换到 HS 模式都会有 LP11→LP01→LP00 这样的一个时序，同时还要检查 HS-00011101 ，HS-00011101 主要是用于同步，只有前面正确采集到 00011101 ，才能保证 clk 和 data 相位一一对应。</p>
<p><strong>mipi csi调试助手：</strong><br>测量 sensor 有相应的 mipi 信号输出，但是主控并没有接收到数据，通过查看主控的 mipi 寄存器发现，mipi接收器还处于 LP 模式，这种情况一般是mipi没有检测到sensor发送的从 LP 进入 HS 的时序。此时可测量sensor 开始输出图像数据时，clk lane 是否有 LP11→LP01→LP00 这样的一个时序。同时，应该先开 mipi，sensor 再开始 mipi 数据传输；<br>由于THS-PREPARE会有一个小脉冲的存在，所以，主控在接收mipi数据的时候，需要通过设置主控的settle time，这个时间需要在这个小脉冲之后，这样接收才不会有问题；<br>当出现 sensor 有数据输出，但是主控没有接收成功，这个情况一般是 mipi 的时序问题，sensor 端的时序没有和主控端的配合好，这个时候，可以尝试的减小sensor端的THS-PREPARE，增大THS-ZERO和THS-TRAIL；<br>由于一些主控的需求，在一帧数据完成之后，需要一定的时间才可以进行相应的ISP处理，当一帧传输完毕之后的LP11时间达不到主控ISP的时间要求导致ISP报错，可通过调节THS-TRAIL时间，以此得到ISP对帧间的时序长度要求 。</p>
<h1><span id="3-csi-2-shu-ju-bao-xie-yi">3 CSI-2数据包协议</span><a href="#3-csi-2-shu-ju-bao-xie-yi" class="header-anchor">#</a></h1><p>CSI-2 是針對攝像頭的數據協議， 規定了主機與外設通信的數據包格式。CSI-2 可以支持不同像素格式的圖像應用， 數據傳輸的最小粒度是字節。 為增加 CSI-2 的性能，可以選擇數據 Lane 的數量， CSI-2 協議規訂了發送端將像素數據打包成字節的機制， 並指明多個數據 Lane 分配和管理的方式。字節數據以數據包的形式組織，數據包在SoT 與 EoT 之間傳輸。 接收端根據協議解析相應的數據包， 恢復出原始的像素數據。</p>
<p>CSI-2 的數據包分為長包和短包兩種，包含有校驗碼，能進行誤碼糾正和錯誤檢測。長包和短包都是在 SoT 和 EoT 之間傳輸，在數據傳送的間隙， D-PHY 處於 LP 模式。 CSI-2數據包的傳輸機制如圖所示。 PH 和 PF 分別表示 Packet Header 和 Packet Footer。</p>
<h2><span id="3-1-yi-ge-shu-ju-bao-jie-gou">3.1 一个数据包结构</span><a href="#3-1-yi-ge-shu-ju-bao-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/7.png" alt="img"></p>
<h2><span id="3-2-bao-lei-xing">3.2 包类型</span><a href="#3-2-bao-lei-xing" class="header-anchor">#</a></h2><p>• 短包：4 bytes (固定)<br>• 长包：6~65541 bytes (可变) </p>
<h3><span id="3-2-1-duan-bao-jie-gou">3.2.1 短包结构</span><a href="#3-2-1-duan-bao-jie-gou" class="header-anchor">#</a></h3><p><strong>一个short packet（也叫做pack head(PH)）</strong></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/8.png" alt="img"></p>
<p>包结构（4个字节）：<br>    • 数据标识(DI) 1个字节<br>    • WC （长度固定为2个字节）<br>    • 错误检测(ECC) 1个字节</p>
<p>包大小：<br>    • 长度固定为4个字节</p>
<h3><span id="3-2-2-pack-footer-pf-de-jie-gou">3.2.2 pack footer(PF)的结构</span><a href="#3-2-2-pack-footer-pf-de-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/9.png" alt="img"></p>
<h3><span id="3-2-3-chang-bao-jie-gou">3.2.3 长包结构</span><a href="#3-2-3-chang-bao-jie-gou" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/10.png" alt="img"></p>
<p>包头部（4个字节）（PH）：<br>• 　　数据标识(DI) 1个字节<br>• 　　数据计数WC (2个字节 )（PH和PF之間的資料個數）<br>• 　　错误检测(ECC) 1个字节<br>•　    数据填充(0~65535 字节)<br>•       长度&#x3D;WC*字节</p>
<p>包尾：校验和（2个字节）(PF)</p>
<p>长包 &#x3D; 短包（包头） + 数据 + 包尾 </p>
<p>包大小：<br>    4 + (0~65535) + 2 &#x3D; 6 ~ 65541 字节</p>
<h3><span id="3-2-4-h-blanking-amp-v-blanking">3.2.4 H-blanking &amp; V-blanking</span><a href="#3-2-4-h-blanking-amp-v-blanking" class="header-anchor">#</a></h3><p>传输多个pack和传输一个pack时对应的图像如下, VVALID&#x2F;HVALID&#x2F;DVALID可以先把它想成是影像的同步訊號VSync&#x2F;HSync&#x2F;DE，而Data就是影像資料，以方便理解。</p>
<p>从图中可以看到，当水平同步讯号HVALID为Low的这段区间，剛好就是每行的Blanking间隔, 也就是H-blanking。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/11.png" alt="img"></p>
<p>从下图可以看到上一FE到下一FS之间的间隔为V-blanking.</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/12.png" alt="img"></p>
<p>frame的封包示意图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/13.png" alt="img"></p>
<h3><span id="3-2-5-mipi-zheng-shu-ju-lei-xing-di">3.2.5 MIPI帧数据类型DI</span><a href="#3-2-5-mipi-zheng-shu-ju-lei-xing-di" class="header-anchor">#</a></h3><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/14.png" alt="img"></p>
<p> Data Identifier (DI) 为虚拟通道(VC, 2 bit)和资料类型(DT, 6 bit)组成。</p>
<h4><span id="3-2-5-1-vc-virtual-channel">3.2.5.1 VC(virtual channel)</span><a href="#3-2-5-1-vc-virtual-channel" class="header-anchor">#</a></h4><p>可以看出MIPI最多可以輸入4组影像来源，其ID为0~3，且內容可以是任意的內容，下图就表示用virtual chn来传输不同格式的数据。比如一般Sony, OV的HDR 模式基本都是VC mode，包括2帧HDR, 3帧HDR。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/15.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/16.png" alt="img"></p>
<h4><span id="3-2-5-2-dt-data-type">3.2.5.2 DT(data type)</span><a href="#3-2-5-2-dt-data-type" class="header-anchor">#</a></h4><p>Data Type目前定义多种资料形态，范围从0x00<del>0x3F，其中0x00</del>0x0F为短封包类型，0x10~0x3F为長封包类型，如下表：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/17.png" alt="img"></p>
<p>用于同步的短包Data Type:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/18.png" alt="img"></p>
<p>从<strong>soc到外设</strong>发送的包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/19.png" alt="img"></p>
<p>从<strong>外设到soc</strong>的数据包类型:</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/20.png" alt="img"></p>
<h1><span id="4-mipi-zhi-chi-de-tu-xiang-ge-shi">4 mipi支持的图像格式</span><a href="#4-mipi-zhi-chi-de-tu-xiang-ge-shi" class="header-anchor">#</a></h1><p>MIPI CSI 共支持五種pixel資料格式的傳輸， 包含 YUV422-8bit、 YUV422-10bit、 RAW8、RAW10 和 RAW12。</p>
<h2><span id="4-1-rgb-ge-shi">4.1 RGB格式</span><a href="#4-1-rgb-ge-shi" class="header-anchor">#</a></h2><p>传统的红绿蓝格式，比如RGB565，RGB888，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RGB565</td>
<td>1. 每个像素用16位表示，RGB分量分别使用5位、6位、5位。2. 内存中排列（高字节-&gt;低字节）：R R R R R G G G G G G B B B B B</td>
</tr>
<tr>
<td>RGB555</td>
<td>1. 每个像素用16位表示，RGB分量都使用5位（剩下1位不用）2. 内存中排列（高字节-&gt;低字节）：X R R R R G G G G G B B B B B（X表示不用，可以忽略）</td>
</tr>
<tr>
<td>RGB24（RGB888）</td>
<td>1. 每个像素用24位表示，RGB分量各使用8位。在内存中RGB各分量的排列顺序为：BGR BGR BGR ……2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R</td>
</tr>
<tr>
<td>ARGB32（ARGB8888）</td>
<td>1. 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）2. 内存中排列（高字节-&gt;低字节）：B B B B B B B B G G G G G G G G R R R R R R R R A A A A A A A A</td>
</tr>
</tbody></table>
<h2><span id="4-2-yuv-ge-shi">4.2 YUV格式</span><a href="#4-2-yuv-ge-shi" class="header-anchor">#</a></h2><p>YUV是一种色彩编码方法，是一种彩色编码系统，相对于RGB色彩空间，YUV传输带宽占用更低，传输数据不易出错。</p>
<p>Y’UV、YUV、YCbCr、YPbPr 几个概念其实是一回事儿。由于历史关系，Y’UV、YUV 主要是用在彩色电视中，用于模拟信号表示。YCbCr 是用在数字视频、图像的压缩和传输，如 MPEG、JPEG。今天大家所讲的 YUV 其实就是指 YCbCr。Y 表示亮度（luma），CbCr 表示色度（chroma）。</p>
<p>人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感。所以在视频编码系统中为了降低带宽，可以保存更多的亮度信息(luma)，保存较少的色差信息(chroma)。</p>
<p>luminance 亮度，luma 是在视频编码系统中指亮度值；</p>
<p>chrominance 色度，chroma 是在视频编码系统中指色度值。</p>
<p>Y’UV 设计的初衷是为了使彩色电视能够兼容黑白电视。对于黑白电视信号，没有色度信息也就是(UV)，那么在彩色电视显示的时候只显示亮度信息。</p>
<p>YUV是一个比较笼统地说法，针对它的具体排列方式，可以分为很多种具体的格式。色度(UV)定义了颜色的两个方面─色调与饱和度，分别用CB和CR表示。其中，Cr反映了RGB输入信号红色部分与RGB信号亮度值之间的差异。而Cb反映的是RGB输入信号蓝色部分与RGB信号亮度值之间的差异。</p>
<h3><span id="4-2-1-yuv-cai-yang-mo-shi-subsamping">4.2.1 YUV采样模式(subsamping)</span><a href="#4-2-1-yuv-cai-yang-mo-shi-subsamping" class="header-anchor">#</a></h3><p>原则：在数字图像中<br>    1) 每一个图形像素都要包含 luma（亮度）值；<br>    2）几个图形像素共用一个 Cb + Cr 值，一般是 2、4、8 个像素。</p>
<p>主要的采样格式有YCbCr 4:2:0、YCbCr 4:2:2、YCbCr 4:1:1和 YCbCr 4:4:4。</p>
<h4><span id="4-2-1-1-yuv444-cai-yang">4.2.1.1 YUV444采样</span><a href="#4-2-1-1-yuv444-cai-yang" class="header-anchor">#</a></h4><p>全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br><span class="line">[y u v] [y u v] [y u v] [y u v]</span><br></pre></td></tr></table></figure>
<p>那么1920<em>1080文件的大小：1920</em>1080*3（B），那么一个像素对应3个字节。</p>
<h4><span id="4-2-1-2-yuv422-cai-yang">4.2.1.2 YUV422采样</span><a href="#4-2-1-2-yuv422-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;3存储空间和1&#x2F;3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。如果水平方向有10个像素点，那么采样了10个Y分量，而只采样了5个UV分量。其中，每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br><span class="line">[y u] [y v] [y u] [y v]</span><br><span class="line">[y v] [y u] [y v] [y u]</span><br></pre></td></tr></table></figure>
<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.5+1920<em>1080</em>0.5（B），那么UV的数量减少了一半，相对于YUV444空间节省了1&#x2F;3。</p>
<h4><span id="4-2-1-3-yuv420-cai-yang">4.2.1.3 YUV420采样</span><a href="#4-2-1-3-yuv420-cai-yang" class="header-anchor">#</a></h4><p>部分采样，可节省1&#x2F;2存储空间和1&#x2F;2的数据传输量。YUV 420采样，并不是指只采样U分量而不采样V分量。而是指，在每一行扫描时，只扫描一种色度分量（U或者V）和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。其实yuv420的取名方式不是很高明，更确切的命名为yuv420yuv402，也就是第一行只有U，而第二行只有V。<br>假设4*4像素，采样格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br><span class="line">[y u] [y] [y u] [y]</span><br><span class="line">[y v] [y] [y v] [y]</span><br></pre></td></tr></table></figure>

<p>1920<em>1080文件的大小：1920</em>1080+1920<em>1080</em>0.25+1920<em>1080</em>0.25（B）相对于YUV444空间节省1&#x2F;2，因此也是比较主流的采样方式。</p>
<h3><span id="4-2-2-yuv-cun-chu-fang-shi">4.2.2 YUV存储方式</span><a href="#4-2-2-yuv-cun-chu-fang-shi" class="header-anchor">#</a></h3><p>YUV的格式有两大类：<strong>planar（平面格式）和packed（打包格式）</strong>。</p>
<h4><span id="4-2-2-1-planner-cun-chu">4.2.2.1 planner存储</span><a href="#4-2-2-1-planner-cun-chu" class="header-anchor">#</a></h4><p>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。</p>
<p>一般默认是3个平面，即y平面，u平面，v平面。但还有一种semi-planar是两个平面。也就是说uv为同一个平面，即一个y平面，一个uv平面。</p>
<h5><span id="4-2-2-1-1-yuv420-planner">4.2.2.1.1 yuv420 planner</span><a href="#4-2-2-1-1-yuv420-planner" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/21.png" alt="img"></p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/22.png" alt="img"></p>
<p>例如：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/23.png" alt="img"></p>
<p>可以看到第一行的Y1Y2和第二行的Y7Y8共同使用一组U1V1。</p>
<h5><span id="4-2-2-1-2-yuv420sp">4.2.2.1.2 yuv420sp</span><a href="#4-2-2-1-2-yuv420sp" class="header-anchor">#</a></h5><p> two-planer双平面，Y一个平面，UV在同一个平面交叉存储。也叫做semi-planar的YUV格式。</p>
<ol>
<li><p>nv12</p>
<p>先存储全部的Y分量，然后UV分量交叉存储。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/24.png" alt="img"></p>
</li>
<li><p>nv21</p>
<p>先UV分量交叉存储, 然后存储全部的Y分量。</p>
</li>
</ol>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/25.png" alt="img"></p>
<h5><span id="4-2-2-1-3-yuv422-planner">4.2.2.1.3 yuv422 planner</span><a href="#4-2-2-1-3-yuv422-planner" class="header-anchor">#</a></h5><p>3平面，数据量：u&#x3D;v&#x3D;y&#x2F;2，不画图展示</p>
<h5><span id="4-2-2-1-4-yuv422sp">4.2.2.1.4 yuv422sp</span><a href="#4-2-2-1-4-yuv422sp" class="header-anchor">#</a></h5><p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/26.png" alt="img"></p>
<p>可以看到y0y82个像素公用一组u0v0。</p>
<h4><span id="4-2-2-2-packed-cun-chu">4.2.2.2 packed存储</span><a href="#4-2-2-2-packed-cun-chu" class="header-anchor">#</a></h4><p>packed的YUV格式，每个像素点的Y、U、V都是连续交叉存储的。</p>
<h5><span id="4-2-2-2-1-yuyv">4.2.2.2.1 yuyv</span><a href="#4-2-2-2-1-yuyv" class="header-anchor">#</a></h5><p>该格式属于4：2：2类型，且是用packed形式存储的，相邻的2个像素共用一个Cb(U)和Cr(V)，以16个像素为例如下图：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/27.png" alt="img"></p>
<h5><span id="4-2-2-2-2-yvyu">4.2.2.2.2 yvyu</span><a href="#4-2-2-2-2-yvyu" class="header-anchor">#</a></h5><p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p>4.2.2.2.2 uyvy</p>
<p>与YUYV相似，只是存储时UV分量顺序不同而已。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/28.png" alt="img"></p>
<h2><span id="4-3-raw-ge-shi">4.3 RAW 格式</span><a href="#4-3-raw-ge-shi" class="header-anchor">#</a></h2><p>RAW图像就是CMOS或者CCD图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如ISO的设置、快门速度、光圈值、白平衡等）的文件。RAW是未经处理、也未经压缩的格式，可以把RAW概念化为“原始图像编码数据”或更形象的称为“数字底片”。Raw data（Raw RGB）经过彩色插值就变成RGB。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/29.png" alt="img"></p>
<p>sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B 。</p>
<h3><span id="4-3-1-bayer-zhen-lie">4.3.1 bayer阵列</span><a href="#4-3-1-bayer-zhen-lie" class="header-anchor">#</a></h3><p>人眼对绿色比较敏感，所以一般bayer格式的图片绿色格式的像素是是r和g像素的和，那么bayer格式一般有下面4种：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/30.png" alt="img"></p>
<h1><span id="5-mipi-csi-shu-ju-bao-chuan-shu">5 mipi csi数据包传输</span><a href="#5-mipi-csi-shu-ju-bao-chuan-shu" class="header-anchor">#</a></h1><p>raw8格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/31.png" alt="img"></p>
<p>raw10格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/32.png" alt="img"></p>
<p>raw12格式传输：</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/33.png" alt="img"></p>
<p> 从图像看，RAW8是一传输个字节对应一个pixel， 而raw10是5个byte去对应4个pixel，第5个byte用来存储pixel 0~3的bit[0:1]。同理raw12用3个byte存储2个pixel。</p>
<p><img src="/2024/04/02/mipi-csi%E8%BD%AF%E4%BB%B6%E7%AF%87/34.png" alt="img"></p>
<h1><span id="6-se-cai-shen-du">6 色彩深度</span><a href="#6-se-cai-shen-du" class="header-anchor">#</a></h1><p>8位彩色，有256种深度。<br>16位彩色：65,536种颜色。<br>24位彩色：每种原色都有256个层次，它们的组合便有256<em>256</em>256种颜色。<br>32位彩色：除了24位彩色的颜色外，额外的8位是储存重叠图层的图形资料(alpha透明度)。</p>
<h1><span id="7-tu-xiang-jie-xi-du-x2f-fen-bian-lu">7 图像解析度&#x2F;分辨率</span><a href="#7-tu-xiang-jie-xi-du-x2f-fen-bian-lu" class="header-anchor">#</a></h1><p>Resolution：</p>
<table>
<thead>
<tr>
<th>1280 * 720 &#x3D; 921600</th>
<th>1M</th>
<th>100万像素</th>
<th>720P</th>
<th>H65 sensor</th>
</tr>
</thead>
<tbody><tr>
<td>1920 * 1080 &#x3D; 2073600</td>
<td>2M</td>
<td>200万像素</td>
<td>1080P</td>
<td>Imx307&#x2F;imx327 sensor</td>
</tr>
<tr>
<td>2560 * 1440 &#x3D; 36864002560 * 1600 &#x3D; 40960002592 * 1944 &#x3D; 5038848</td>
<td>4M&#x2F;5M</td>
<td>400万像素500万像素</td>
<td>2K</td>
<td>Imx335&#x2F;sc4210 sensor</td>
</tr>
<tr>
<td>3840 * 2160 &#x3D; 8294400</td>
<td>8M</td>
<td>800万像素</td>
<td>4K</td>
<td>Imx334 sensor</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机-异常中断</title>
    <url>/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</a><ul>
<li><a href="#1-1-cpu-mo-shi">1.1 CPU模式</a></li>
<li><a href="#1-2-gong-zuo-state">1.2 工作State</a></li>
<li><a href="#1-3-arm-ji-cun-qi">1.3 ARM寄存器</a><ul>
<li><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</a></li>
<li><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</a></li>
</ul>
</li>
<li><a href="#1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</a></li>
</ul>
</li>
<li><a href="#2-yi-chang-chu-li-liu-cheng">2 异常处理流程</a><ul>
<li><a href="#2-1-zhong-duan-qian">2.1 中断前</a><ul>
<li><a href="#2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</a></li>
</ul>
</li>
<li><a href="#2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</a><ul>
<li><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</a></li>
</ul>
</li>
<li><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</a></li>
</ul>
</li>
<li><a href="#3-zhong-duan-shi-li">3 中断实例</a><ul>
<li><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</a><ul>
<li><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</a></li>
<li><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</a></li>
<li><a href="#3-1-3-shi-li-gai-jin">3.1.3 示例改进</a><ul>
<li><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</a></li>
<li><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</a></li>
<li><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-swi-ruan-zhong-duan">3.2 swi-软中断</a><ul>
<li><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</a><ul>
<li><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</a><ul>
<li><a href="#3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</a></li>
<li><a href="#3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</a><ul>
<li><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</a></li>
<li><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</a></li>
<li><a href="#3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</a></li>
<li><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</a><ul>
<li><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</a><ul>
<li><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</a><ul>
<li><a href="#3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</a></li>
<li><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</a><ul>
<li><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</a></li>
<li><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</a></li>
</ul>
</li>
<li><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</a><ul>
<li><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</a></li>
<li><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</a><ul>
<li><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</a></li>
<li><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-yi-chang-zhong-duan-yin-ru">1 异常中断引入</span><a href="#1-yi-chang-zhong-duan-yin-ru" class="header-anchor">#</a></h1><p>在arm架构的处理器中，cpu有7中工作模式，2中工作状态。</p>
<h2><span id="1-1-cpu-mo-shi">1.1 CPU模式</span><a href="#1-1-cpu-mo-shi" class="header-anchor">#</a></h2><pre><code>7种Mode: 除了usr/sys，其他5种都是异常模式。我们知道中断属于异常的2中，中断有irq,fiq。
</code></pre>
<table>
<thead>
<tr>
<th>usr</th>
<th>sys</th>
<th>undefined(und)</th>
<th>Supervisor(svc)</th>
<th>Abort(abt)</th>
<th>irq</th>
<th>fiq</th>
</tr>
</thead>
<tbody><tr>
<td>用户模式</td>
<td>系统模式</td>
<td>未定义指令异常模</td>
<td>svc管理模式</td>
<td>终止模式（1.指令预取终止(读写某条错误的指令导致终止运行)；2.数据访问终止(读写某个非法地址程序终止)）</td>
<td>irq中断</td>
<td>快中断</td>
</tr>
</tbody></table>
<p>除了usr模式，其他6中为特权模式。 CPU无法从usr模式直接进入特权模式。不能直接进入特权模式，那么<strong>怎么进入特权模式</strong>呢？</p>
<p>可以通过<strong>设置CPSR</strong>进入其他模式。</p>
<h2><span id="1-2-gong-zuo-state">1.2 工作State</span><a href="#1-2-gong-zuo-state" class="header-anchor">#</a></h2><pre><code>ARM state
Thumb state(几乎用不上)
</code></pre>
<h2><span id="1-3-arm-ji-cun-qi">1.3 ARM寄存器</span><a href="#1-3-arm-ji-cun-qi" class="header-anchor">#</a></h2><pre><code>(1)通用寄存器:
(2)备份寄存器(banked register):
    CPSR:当前程序状态寄存器(Current Program Status Register) 反映程序处在那种状态
    SPSR:CPSR的备份寄存器 (Saved Program Status Register)  用来保存&quot;被中断前的CPSR&quot;
</code></pre>
<p>下图是我们arm状态下的通用寄存器和程序状态寄存器<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/1.png"></p>
<p><strong>R13是SP（栈指针）</strong><br><strong>R14是LR</strong>（link register），程序跳转或者发成异常时的返回地址<br><strong>R15是PC</strong>（程序计数器）</p>
<p>假设cpu执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov R0, R8</span><br><span class="line">mov R0,R8_fiq</span><br></pre></td></tr></table></figure>

<p>在usr&#x2F;System 模式下访问的R8, 但是在FIQ模式下，访问R8是访问FIQ模式专属的R8寄存器，不是同一个物理上的寄存器。<br>在5种异常模式中每个模式都有自己专属的R13 R14寄存器，R13用作SP(栈)， R14(LR)是用来保存发生异常时的指令地址。</p>
<p>为什么快中断(FIQ)有那么多专属寄存器?<br>这些寄存器称为备份寄存器，我们先看下<strong>中断处理流程</strong>：</p>
<pre><code>1 保存现场(保存被中断模式的寄存器)---(比如程序正在sys/usr模式下运行，当发生中断时，需要把R0-R14这些寄存器全部保存下来)
2 异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
3 恢复现场(恢复被中断时保存下来的寄存器R0-R14)
</code></pre>
<p>但如果是快中断，那么我就不需要保存系统&#x2F;用户模式下的R8 ~ R12这几个寄存器，因为在FIQ模式下有自己专属的R8 ~ R12寄存器，省略保存寄存器的时间，加快处理速度，所以它才称得上快中断。</p>
<h3><span id="1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi">1.3.1 CPSR程序状态寄存器</span><a href="#1-3-1-cpsr-cheng-xu-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>在异常中断中PSR寄存器会使用的很频繁，PSR寄存器的格式如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/2.png"></p>
<p>我们再来看看下表，反映的是PSR的 M[4:0]与arm工作模式的关系：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/3.png"></p>
<p>我们可以按照上图的对应关系设置CPSR，让其进入与之对应的模式。</p>
<h3><span id="1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi">1.3.2 SPSR程序状态备份寄存器</span><a href="#1-3-2-spsr-cheng-xu-zhuang-tai-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h2><span id="1-4-yi-chang-xiang-liang-biao">1.4 异常向量表</span><a href="#1-4-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p><strong>异常向量</strong>：不同的异常有不同的入口函数，那么这个异常入口函数的地址就是存放在该异常向量的位置。从该异常向量读取到的数据就是异常入口函数的地址。<br><strong>异常向量表</strong>：就是由异常向量组成的集合。</p>
<p>下图是从uboot源代码中截取的smdk2410 的异常向量表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.globl _start</span><br><span class="line">_start:	b       reset</span><br><span class="line">	ldr	pc, _undefined_instruction</span><br><span class="line">	ldr	pc, _software_interrupt</span><br><span class="line">	ldr	pc, _prefetch_abort</span><br><span class="line">	ldr	pc, _data_abort</span><br><span class="line">	ldr	pc, _not_used</span><br><span class="line">	ldr	pc, _irq</span><br><span class="line">	ldr	pc, _fiq</span><br></pre></td></tr></table></figure>

<p>异常向量表对应的地址如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/4.png"></p>
<h1><span id="2-yi-chang-chu-li-liu-cheng">2 异常处理流程</span><a href="#2-yi-chang-chu-li-liu-cheng" class="header-anchor">#</a></h1><p>CPU是如何进入到中断模式，执行中断服务程序的？</p>
<h2><span id="2-1-zhong-duan-qian">2.1 中断前</span><a href="#2-1-zhong-duan-qian" class="header-anchor">#</a></h2><p>下图是中断未触发前的程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/5.png"></p>
<h3><span id="2-1-1-chu-shi-hua-zhong-duan">2.1.1 初始化中断</span><a href="#2-1-1-chu-shi-hua-zhong-duan" class="header-anchor">#</a></h3><pre><code>1，设置中断源（使中断能够产生，让CPU知道是哪个中断）
2，设置中断控制器（设置中断屏蔽，中断优先级）
3，设置中断总开关CPSR (使能中断)
</code></pre>
<h2><span id="2-2-zhong-duan-chan-sheng-hou">2.2 中断产生后</span><a href="#2-2-zhong-duan-chan-sheng-hou" class="header-anchor">#</a></h2><p>举个栗子：按键按下，产生按键irq。</p>
<h3><span id="2-2-1-ying-jian-shang-de-chu-li-liu-cheng">2.2.1 硬件上的处理流程</span><a href="#2-2-1-ying-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h3><p>cpu强制跳转到异常向量表上对应的_irq异常向量（0x18）去读取指令（这个是CPU强制执行的，不需要我们去控制）。</p>
<p>具体的进入中断向量和中断返回流程见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">进入：</span><br><span class="line">	 (<span class="number">1</span>) LR_异常=PC + offset（具体多少看下图）</span><br><span class="line">	（<span class="number">2</span>）SPSR_异常=被中断前的程序模式CPSR</span><br><span class="line">	 (<span class="number">3</span>) CPSR被设置成对应的异常模式</span><br><span class="line">	（<span class="number">4</span>）跳转到对应的异常向量去执行</span><br><span class="line">退出（返回）：进入和退出就是一个逆过程</span><br><span class="line">	（<span class="number">1</span>）PC= LR_异常 -offset</span><br><span class="line">	（<span class="number">2</span>）被中断前的程序模式CPSR = SPSR_异常</span><br><span class="line">	（<span class="number">3</span>）中断结束，清中断</span><br></pre></td></tr></table></figure>

<p>进入异常和返回异常时pc和lr的关系如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/7.png"></p>
<p>从图中我们发现进入不同异常，offset的值也是有差异的。</p>
<h2><span id="2-2-2-ruan-jian-shang-de-chu-li-liu-cheng">2.2.2 软件上的处理流程</span><a href="#2-2-2-ruan-jian-shang-de-chu-li-liu-cheng" class="header-anchor">#</a></h2><pre><code>1.当跳转到irq异常向量(0x18)后，发现该处是一条跳转指令“ldr pc, _irq”,
那么会通过ldr绝对跳转指令跳到到真正的中断处理函数_irq去执行。
2.那么在_irq的函数中我们需要按照之前说的**中断处理流程**去执行：
    （1）保存现场
    （2）异常处理（去分辨是哪一个中断源产生了中断，去执行对应的中断服务程序）
    （3）恢复现场
</code></pre>
<p>流程图总结下中断产生后的详细处理过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/8.png"></p>
<h1><span id="3-zhong-duan-shi-li">3 中断实例</span><a href="#3-zhong-duan-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-und-wei-ding-yi-zhi-ling-yi-chang">3.1 und-未定义指令异常</span><a href="#3-1-und-wei-ding-yi-zhi-ling-yi-chang" class="header-anchor">#</a></h2><p>先来看下当cpu解析到什么样的指令才会触发未定义指令异常呢？</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/9.png"></p>
<p>从上面的arm指令格式中可知，只要指令码属于划线的格式，就属于未定义指令异常。</p>
<h3><span id="3-1-1-hui-bian-xiang-c-han-shu-chuan-can">3.1.1 汇编向c函数传参</span><a href="#3-1-1-hui-bian-xiang-c-han-shu-chuan-can" class="header-anchor">#</a></h3><p>我们知道汇编给C语言函数传参是通过r0，r1，…通过堆栈的方式去传递的参数，比如r0&#x3D;1, r1&#x3D;2;那么在被调用的c函数中argv0就是r0, argv1就是r1…,那么我们如果通过汇编给C函数传递字符串呢？</p>
<p>声明und_string为一个字符串:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>ldr r1, =und_string</code>，这样r1中就保存了und_string的地址。<br>这样调用我们的c函数就可以把und_string传入进去。</p>
<h3><span id="3-1-2-und-yi-chang-cheng-xu-shi-li">3.1.2 und异常程序示例</span><a href="#3-1-2-und-yi-chang-cheng-xu-shi-li" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	sdram</span></span><br><span class="line"><span class="comment">	设置SP</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">	...</span><br><span class="line">	bl print1</span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>; <span class="comment">/*定义一条未定义指令*/</span></span><br><span class="line">	<span class="comment">/*故意以一个数据的方式引入一条未定义指令，当cpu执行到这里，读取0xdeadc0de指令码的时候，</span></span><br><span class="line"><span class="comment">	发现无法识别这条指令，就发生未定义指令异常，就跳转到0x4的中断向量去执行*/</span></span><br><span class="line">	</span><br><span class="line">	bl print2</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>


<p>在未定义指令异常前后加上打印print1, print2，<strong>如果出现未定义指令异常后，就会跳到0x4的地方去读取指令，print2也就没法执行</strong>。</p>
<p>当跳转到0x4的中断向量后，发现此处是一条跳转指令<code>bl do_und</code>, 我们再到未定义指令异常的服务程序do_und中打印出und_string这个字符串的内容。<br>现在开始写指令异常的服务程序do_und，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>

<p>下面来分析一下这个未定义指令异常服务程序:</p>
<ol>
<li><p>进入未定义指令异常服务do_und之前硬件自动完成的事情如下：</p>
<ol>
<li>lr_und保存有被中断模式中的下一条即将执行的指令的地址</li>
<li>SPSR_und保存有被中断模式的CPSR</li>
<li>CPSR中的M4-M0被设置为11011, 进入到und模式</li>
<li>跳到0x4的地方执行程序 （bl do_und）</li>
</ol>
</li>
<li><p>进入指令异常服务程序do_und后，我们需要保存现场，处理und异常,恢复现场，<strong>注意：由于发生了cpu模式切换，如果要用到栈，那么先要设置对应模式的栈。</strong>由于栈的地址是向下生长的，这里我就用sdram的末位地址作为栈指针，把sp_und&#x3D;0x34000000。</p>
</li>
<li><p>在und异常服务程序中有可能会用到栈, 所以先保存现场，通过<code>stmdb sp!, &#123;r0-r12, lr&#125;</code>语句把栈中的值备份到r0-r12和lr，然后恢复现场的时候通过<code>ldmia sp!, &#123;r0-r12, pc&#125;^</code>，详见上面的注释。</p>
</li>
<li><p>我们看到保存现场后，我们把cpsr的值放到r0, 把und_string放到r1, 然后用bl printException调用c函数，这样我们的c函数printException就能收到汇编传过来的参数，一个是cpsr模式（r0），一个是und_string汇编传过来的字符串(r1)。我们用C函数实现printException：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printException</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpsr, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Exception! cpsr = &quot;</span>);</span><br><span class="line">	printHex(cpsr);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(str);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br><span class="line"></span><br><span class="line">do_und:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_und保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_und保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为11011, 进入到und模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x4的地方执行程序 （bl do_und）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* sp_und未设置, 先设置它 （由于之前一直处于管理模式，现在处在und状态）*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x34000000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在und异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  <span class="comment">/*先减后存*/</span> <span class="comment">/* 把栈中的值备份到r0-r12*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理und异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =und_string <span class="comment">/*保存und_string地址*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/*（ldmia先读后加）,把备份的值恢复到栈中，让pc=lr就可以恢复到异常前的指令地址。^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undefined instruction exception&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">	<span class="comment">/* sdram */</span>	</span><br><span class="line">	bl copy2sdram</span><br><span class="line">	bl clean_bss</span><br><span class="line"></span><br><span class="line">	bl uart0_init</span><br><span class="line"></span><br><span class="line">	bl print1</span><br><span class="line">	<span class="comment">/* 故意加入一条未定义指令 */</span></span><br><span class="line">und_code:</span><br><span class="line">	.word <span class="number">0xdeadc0de</span>  <span class="comment">/* 未定义指令 */</span></span><br><span class="line">	bl print2</span><br><span class="line"></span><br><span class="line">	<span class="comment">//bl main  /* 使用BL命令相对跳转, 程序仍然在NOR/sram执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong>如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/10.png"></p>
<p>打印出print1中的字符串‘abc’后，紧接着打印printException函数中的结果，cpsr&#x3D;0x600000db,那么对应的M[4:0]&#x3D;11011， 对应下图为und模式。然后从und异常返回，恢复原来的模式继续执行。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/11.png"></p>
<h3><span id="3-1-3-shi-li-gai-jin">3.1.3 示例改进</span><a href="#3-1-3-shi-li-gai-jin" class="header-anchor">#</a></h3><h4><span id="3-1-3-1-zhi-ling-4-zi-jie-dui-qi">3.1.3.1 指令4字节对齐</span><a href="#3-1-3-1-zhi-ling-4-zi-jie-dui-qi" class="header-anchor">#</a></h4><p>我们将上面的代码的und_string字符串修改一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>编译烧录再次运行，发现没有任何打印输出，这是为什么呢？我明明只是把und_string字符串改了一下呀。</p>
<p>查看反汇编：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/12.png"></p>
<p>我们发现reset的地址是0x30000032，竟然不是4字节对齐的，我们知道arm指令集是以4字节为基本单位的，那么这里没有对齐，肯定无法解析指令。那么我们手工改进代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">und_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;undef instruction&quot;</span></span><br></pre></td></tr></table></figure>

<font color="red" size="2.5">
.align 4
</font>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/* 时钟 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/13.png"></p>
<p>我们再来看看反汇编，发现reset的地址是30000040，是以4字节对齐的，再次烧录运行，发现能够正常输出print1, 能够进入未定义指令异常。</p>
<h4><span id="3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang">3.1.3.2 绝对跳转进入异常向量</span><a href="#3-1-3-2-jue-dui-tiao-zhuan-jin-ru-yi-chang-xiang-liang" class="header-anchor">#</a></h4><p>如果我们程序非常大，中断向量入口代码的地址可能会大于sram的容量4k，比如do_und和do_swi，那么这个时候就需要用绝对跳转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">    b do_und <span class="comment">/* vector 4 : und （看中断向量表）*/</span></span><br></pre></td></tr></table></figure>

<p>将上面的相对跳转换成如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> .text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">	ldr pc, und_addr </span><br><span class="line">    ldr pc, swi_addr</span><br><span class="line">    ...</span><br><span class="line">    ... </span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">    .word do_swi</span><br></pre></td></tr></table></figure>

<p>这样我们的do_und， do_swi就可放在4k之外的地方, 放到sdram。</p>
<h4><span id="3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing">3.1.3.3 重定位后跳转sdram上执行</span><a href="#3-1-3-3-chong-ding-wei-hou-tiao-zhuan-sdram-shang-zhi-xing" class="header-anchor">#</a></h4><p>我们现在不断增加的程序代码量，那么有可能在 <code>ldr pc, =main</code> 这条指令执行之前程序就已经超过4k。那么我们当从nand启动的时候，还没执行到ldr pc, &#x3D;main这句来，就无法取指令执行了。nor同理超过2M也就无法取指令执行了。 所以我们干脆重定位完代码后就直接跳转到sdram上去执行,代码简要概述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位*/</span></span><br><span class="line">ldr pc, =sdram</span><br><span class="line">sdram：</span><br><span class="line">   ...</span><br><span class="line">ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<p>我们再来分析下整个程序执行过程：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/14.jpg"></p>
<pre><code>1.一上电，cpu从0地址执行，执行b reset（进行初始化硬件）
2.重定位程序
3.跳转到sdram去继续执行
4.执行到 deadc0de,发生未定义指令异常
5.跳转到异常向量表的0x4地址去执行
6.跳转到sdram上执行异常处理函数（do_und）
7.异常返回，继续执行
</code></pre>
<h2><span id="3-2-swi-ruan-zhong-duan">3.2 swi-软中断</span><a href="#3-2-swi-ruan-zhong-duan" class="header-anchor">#</a></h2><p>arm有7中工作模式，除了usr模式，其他6种都是特权模式。</p>
<p>我们知道usr模式无法修改CPSR直接进入其他特权模式，但linux应用程序一般运行在usr模式，既然usr模式权限非常低，是无法直接访问硬件寄存器的，那么它是如何访问硬件的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux应用程序是通过系统调用，从而进入内核态，运行驱动程序来访问的硬件，那么系统调用又是如何实现的呢，就是通过软中断swi指令来进入svc模式，进入到svc模式后当然就能访问硬件啦。</span><br></pre></td></tr></table></figure>

<p>所以我们的应用程序在usr模式想访问硬件，必须切换模式:</p>
<p>有以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 发生异常或中断(被动的)</span><br><span class="line"><span class="number">2.</span> swi + 某个值(主动的)</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-1-jin-ru-ruan-zhong-duan-swi">3.2.1 进入软中断swi</span><a href="#3-2-1-jin-ru-ruan-zhong-duan-swi" class="header-anchor">#</a></h3><p>s3c2440 一上电会跳到0地址（reset复位）执行代码，此时CPU处于svc模式，2440异常向量表如下图所示:<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/15.png"></p>
<p>为了验证usr模式能够主动的通过swi软中断指令来进入svc模式, 我们先将模式切换到usr模式，那么这个时候就不能访问硬件了，也不能直接修改cpsr直接进入其他模式。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/16.png"></p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/17.png"></p>
<p>从上图我们设置CPSR让M4-M0处在10000，这样就进入了usr模式。修改start.s如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>那么当执行到swi 0x123，就会触发SWI异常, 进入0x8的向量去执行，调用do_swi，我们参考do_und实现我们的软中断服务程序do_swi。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_swi:</span><br><span class="line">	<span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment">	 * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment">	 * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment">	 * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment">	 * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 处理swi异常 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">	bl printException</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>完整代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">		b reset  </span><br><span class="line">		ldr pc, und_addr </span><br><span class="line">		ldr pc, swi_addr</span><br><span class="line">		...</span><br><span class="line">	und_addr:</span><br><span class="line">		.word do_und</span><br><span class="line">	swi_addr:</span><br><span class="line">		.word do_swi</span><br><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string <span class="comment">/*这里r0, r1只是为了给printException传参*/</span></span><br><span class="line">bl printException</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复现场 */</span></span><br><span class="line">ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line"></span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line"></span><br><span class="line">reset：</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	看门狗</span></span><br><span class="line"><span class="comment">	时钟</span></span><br><span class="line"><span class="comment">	set SP</span></span><br><span class="line"><span class="comment">	sdram_init</span></span><br><span class="line"><span class="comment">	重定位</span></span><br><span class="line"><span class="comment">	bl uart0_init</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">/*先进入usr模式*/</span></span><br><span class="line">	mrs r0, cpsr      <span class="comment">/* 读出cpsr 读到r0 */</span></span><br><span class="line">	<span class="comment">/*使用bic命令 bitclean 把低4位清零*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0xf</span>  <span class="comment">/* 修改M4-M0为0b10000, 进入usr模式 */</span></span><br><span class="line">	msr cpsr, r0	 <span class="comment">/* 写入cpsr */</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置usr模式下的栈sp_usr */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33f00000</span></span><br><span class="line">	swi <span class="number">0x123</span>  <span class="comment">/* 执行此命令, 触发SWI异常, 进入0x8执行 */</span></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>do_swi中调用printException，打印出了软中断异常的字符串和CPSR对应的svc模式。</p>
<h4><span id="3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao">3.2.1.1 打印出swi软中断号</span><a href="#3-2-1-1-da-yin-chu-swi-ruan-zhong-duan-hao" class="header-anchor">#</a></h4><p>我们要读出swi 0x123指令，我们知道当执行完swi 0x123指令以后，会发生swi异常，那么lr_svc &#x3D; PC + offset。从下图看出offset是4：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/18.png"></p>
<p>修改中断服务函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_swi:</span><br><span class="line"><span class="comment">/* 执行到这里之前:</span></span><br><span class="line"><span class="comment"> * 1. lr_svc保存有被中断模式中的下一条即将执行的指令的地址</span></span><br><span class="line"><span class="comment"> * 2. SPSR_svc保存有被中断模式的CPSR</span></span><br><span class="line"><span class="comment"> * 3. CPSR中的M4-M0被设置为10011, 进入到svc模式</span></span><br><span class="line"><span class="comment"> * 4. 跳到0x08的地方执行程序 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* sp_svc未设置, 先设置它 */</span></span><br><span class="line">ldr sp, =<span class="number">0x33e00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 保存现场 */</span></span><br><span class="line"><span class="comment">/* 在swi异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line"><span class="comment">/* lr是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">stmdb sp!, &#123;r0-r12, lr&#125;</span><br></pre></td></tr></table></figure>

<p>我们要把lr拿出来保存,因为bl printException会破坏lr，那么把lr保存在哪个个寄存器比较好呢？</p>
<p>我们知道当调用<code>bl printException</code>可能会修改某些寄存器，但是又会恢复这些寄存器，那么得知道它会保护哪些些寄存器。<br>来看下ATPCS规则：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/19.png" alt="img"></p>
<p>在子程序中,使用R4~R11来保存局部变量,子程序进入时必须保存这些寄存器的值,在返回前必须恢复这些寄存器的值。所以对于 r4 ~ r11在C函数里会保存这几个寄存器，执行完C函数再把它释放掉并且恢复原来的值。我们把lr 保存在r4寄存器里，r4寄存器不会被C语言破坏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov r4, lr</span><br><span class="line"><span class="comment">/* 处理swi异常 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">ldr r1, =swi_string</span><br><span class="line">bl printException</span><br></pre></td></tr></table></figure>

<p>当执行完<code>swi 0x123</code>指令后，会发生swi异常，swi异常模式里的lr寄存器会保存下一条指令的地址（即’ldr pc, &#x3D;main’），我们把lr寄存器的地址减去4就是<code>swi 0x123</code>这条指令的地址。</p>
<p>把r4的寄存器赋给r0让后打印我们得写出打印函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    mov r0, r4</span><br><span class="line"></span><br><span class="line">    sub r0, r4, #<span class="number">4</span>	<span class="comment">//得到swi指令的地址</span></span><br><span class="line">    bl printSWIVal</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr的值恢复到cpsr里 */</span></span><br><span class="line">	</span><br><span class="line">swi_string:</span><br><span class="line">	.<span class="built_in">string</span> <span class="string">&quot;swi exception&quot;</span></span><br></pre></td></tr></table></figure>

<p>在uart.c添加printSWIVal打印函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printSWIVal</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *pSWI)</span> &#123;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;SWI val = &quot;</span>);</span><br><span class="line">	printHEx(*pSWI &amp; ~<span class="number">0xff000000</span>); <span class="comment">//高8位忽略掉  </span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-irq-wai-bu-zhong-duan">3.3 irq-外部中断</span><a href="#3-3-irq-wai-bu-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-3-1-yin-ru-wai-bu-zhong-duan">3.3.1 引入外部中断</span><a href="#3-3-1-yin-ru-wai-bu-zhong-duan" class="header-anchor">#</a></h3><p>我们想实现一个按键点灯程序，我们知道有以下两种方案：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>轮询方案:轮询检测按键的电平状态，当检测到被按下后，对应的gpio会拉低，点亮对应的led;(略)</span><br><span class="line"><span class="number">2.</span>中断方案:将按键配置成外部中断源，当有按键按下，触发中断，在中断服务程序（isr）中去完成点灯。</span><br></pre></td></tr></table></figure>

<p>我们用按键作为外部中断源，我们把按键对应的gpio配置成中断引脚，当按键按下，相应的gpio产生了电平跳变，就会触发外部中断。</p>
<h3><span id="3-3-2-wai-bu-zhong-duan-shi-li">3.3.2 外部中断示例</span><a href="#3-3-2-wai-bu-zhong-duan-shi-li" class="header-anchor">#</a></h3><p>我们想达到按下按键灯亮, 松开按键灯灭这种效果（配成双边沿触发，按下的时候产生下降沿中断，进行点亮，松开产生上升沿中断，进行熄灭）。当然也可做成按一下点亮，再按一下熄灭的效果（设成单边沿触发，每来一次中断，对led电平进行一次取反）。<br>原理图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/20.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/21.png"></p>
<p>从按键的原理图中得知，当按键没有按下时，接上拉电阻，按键为高电平状态。当按键按下时，电位被拉低，按键处于低电平状态。s2-s5分别对应GPF0，GPF2，GPG3，GPG11; D10-D12这3盏led所对应的gpio分别是GPF4，GPF5，GPF6。</p>
<p>那么我们让s2,s3,s4分别控制D10,D11,D12；s5对D10-D12同时控制（按下s5同时点亮3个led）。</p>
<h4><span id="3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan">3.3.1.1 配置GPIO和中断源</span><a href="#3-3-1-1-pei-zhi-gpio-he-zhong-duan-yuan" class="header-anchor">#</a></h4><p>配置D10-D12的gpio为输出模式，s2-s4的gpio为外部中断模式。</p>
<p>打开芯片手册找到第九章 IO ports，找到对应的gpio控制寄存器，将对应的gpio配置成中断模式。</p>
<ol>
<li>配置GPF GPIO为中断引脚：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/22.png"><br>同理GPG的寄存器类似。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPFCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">4</span>));	<span class="comment">//先把eint0和eint2这两个引脚清零</span></span><br><span class="line">GPFCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">4</span>));   <span class="comment">//S2,S3被配置为中断引脚</span></span><br><span class="line"></span><br><span class="line">GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">22</span>));</span><br><span class="line">GPGCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">22</span>));   <span class="comment">//S4,S5被配置为中断引脚</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置中断触发方式:</li>
</ol>
<p>当电平从高变低时，此时表示按键按下，当电平由低变高，表示松开按键。不妨设置中断方式为双边沿触发，按下按键，触发下降沿中断，中断服务程序就可以去点亮led，反之，松开触发上升沿中断，就可以去熄灭led。<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/23.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/24.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTINT0 |= (<span class="number">7</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">7</span>&lt;&lt;<span class="number">8</span>);     <span class="comment">/* S2,S3 */</span></span><br><span class="line">EXTINT1 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S4 */</span></span><br><span class="line">EXTINT2 |= (<span class="number">7</span>&lt;&lt;<span class="number">12</span>);             <span class="comment">/* S5 */</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>设置外部中断屏蔽寄存器EINTMASK：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/26.png"></li>
</ol>
<p>从上图我们知道外部中断0-3是直接连接到中断控制器，而外部中断4-7、外部中断8-23还要经过EINTMASK,那么我们需要配置EINTMASK来打开中断的通道：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/27.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EINTMASK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">19</span>));    <span class="comment">//打开外部中断通道</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>外部中断挂起寄存器EINTPEND:</li>
</ol>
<p>当一个外部中断（EINT4-EINT23）发生后，那么相应的位会被置1, 所以中断结束后需要清除对应位。这个寄存器可以用来区分外部中断4-23的哪一个中断源。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/28.png"></p>
<h4><span id="3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi">3.3.3.2 中断控制器设置</span><a href="#3-3-3-2-zhong-duan-kong-zhi-qi-she-zhi" class="header-anchor">#</a></h4><p>我们先来看下中断控制器的总框图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/29.png"></p>
<p><strong>1. 首先是SRCPND:用来表示哪个中断源发出了中断请求。</strong></p>
<p>先看下中断源:<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/30.png"></p>
<p>从上图我们发现外部中断有24个外部中断，除了外部中断EINT，还有定时器中断，ADC中断，UART中断等…。</p>
<p>我们来认识下SRCPND寄存器：（用来表示哪个（哪些）中断源已产生中断请求，中断结束后要清中断）<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/31.png"></p>
<p>从上图中我们发现EINT4-7共用1bit，EINT8-23共用1bit，那么肯定有其他寄存器来区分它们，那就是EINTPEND寄存器（后面5会讲）。</p>
<p><strong>2. 然后到达INTMSK：（中断屏蔽寄存器）</strong></p>
<p>我们需要把INTMSK寄存器配置成非屏蔽状态，默认是中断源时屏蔽的，见下图：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/32.png"></p>
<p><strong>3.INTMOD（中断模式，是fiq还是irq）</strong><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/33.png"></p>
<p><strong>4.Priroty:</strong></p>
<p><strong>5.INTPND:</strong><br>INTPND 用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p>中断发生后，SRCPND中会有bit置1，可能好几个（因为同时可能发生几个中断），这些中断会由优先级仲裁器选出一个最紧迫的，然后把INTPND中相应位置1。所以只有INTPND置1，CPU才会处理。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/34.png"></p>
<p>我们知道有可能同时出现多个中断请求，那么INTPND就挑选出当前优先级最高的、正在发生的中断。</p>
<p>当产生irq后，要去分辨是哪个中断源，根据不同的中断源去中断服务程序isr中做不同的事情，那么如何得知当前产生的中断是哪一个外部中断源产生的呢？那么就可以访问这个INTPND寄存器。</p>
<p>可是我们要去手工去解析INTPND里面的位，才能知道是哪个中断源产生了中断请求。那么有没有什么比较快捷的方式自动帮我们解析INTPND呢，直接返回中断号给我们？</p>
<p>当然有啦，有一个INTOFFSET寄存器的值就是代表哪个中断请求产生了，如果INTOFFSET&#x3D;0表示EINT0产生了中断请求，INTOFFSET&#x3D;2表示EINT2产生了中断请求。具体见下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/35.png"></p>
<p>我们从上图看到ENIT4-7共用一个offset， EINT8-23也共用一个offset，那么要通过访问EINTPEND寄存器来区分它们。</p>
<p>中断控制器设置代码入下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化中断控制器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//1是屏蔽我们需要清零，外部中断0 外部中断2 外部中8_23里面还有外部中断11到19</span></span><br><span class="line">    INTMSK &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)); </span><br><span class="line">    <span class="comment">//INTMOD默认是irq，可以不设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-3-zhong-duan-zong-kai-guan">3.3.3.3 中断总开关</span><a href="#3-3-3-3-zhong-duan-zong-kai-guan" class="header-anchor">#</a></h4><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/36.png"></p>
<p>CPSR有I位，是irq的总开关，我们需要把CPSR寄存器 bit7给清零，这是中断的总开关，如果bit7设置为1，CPU无法响应任何中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把bit7这一位清零 */</span></span><br><span class="line">bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">msr cpsr, r0</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-3-4-zhong-duan-fu-wu-cheng-xu">3.3.3.4 中断服务程序</span><a href="#3-3-3-4-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>到这里中断前的初始化工作知识点就已经讲完了，当然要提前准备好led初始化工作（就是将led对应的gpio配置成输出模式，这个不讲解）。</p>
<p>那么中断产生后，我们之前讲过，会跳转到0x18异常向量，执行跳转指令<code>ldr pc, =_irq</code>，和之前的swi异常，und异常框架一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	b reset  <span class="comment">/* vector 0 : reset */</span> </span><br><span class="line">	</span><br><span class="line">	ldr pc, und_addr <span class="comment">/* vector 4 : und（绝对跳转） */</span></span><br><span class="line">	ldr pc, swi_addr <span class="comment">/* vector 8 : swi */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x0c : prefetch aboot */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x10 : data abort */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x14 : reserved */</span></span><br><span class="line">	ldr pc, irq_addr <span class="comment">/* vector 0x18 : irq */</span></span><br><span class="line">	b halt			 <span class="comment">/* vector 0x1c : fiq */</span></span><br><span class="line"></span><br><span class="line">und_addr:</span><br><span class="line">	.word do_und</span><br><span class="line">swi_addr:</span><br><span class="line">	.word do_swi</span><br><span class="line">irq_addr:</span><br><span class="line">	.word do_irq</span><br><span class="line"></span><br><span class="line">reset:</span><br><span class="line">	<span class="comment">/* 关闭看门狗 */</span></span><br><span class="line">	<span class="comment">/*初始化时钟*/</span></span><br><span class="line">	<span class="comment">/*初始化sdram,设置栈*/</span></span><br><span class="line">	<span class="comment">/*代码重定位,清bss*/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 把bit7这一位清零(打开中断总开关) */</span></span><br><span class="line">	bic r0, r0, #(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)  <span class="comment">/* 清除I位, 使能中断 */</span></span><br><span class="line">	msr cpsr, r0</span><br><span class="line"></span><br><span class="line">	ldr pc, =main  <span class="comment">/* 绝对跳转, 跳到SDRAM */</span></span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>1.我们在start.s中用汇编代码设置cpsr的I位，开启中断开关；</p>
<p>2.在main函数中初始化中断源key_eint_init，初始化中断控制器interrupt_init；</p>
<p>3.然后继续执行main主函数。</p>
<p>4.当中断产生，触发irq异常，进入0x18异常向量，执行do_irq。</p>
<p>do_irq实现如下（和do_und, do_swi类似）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_irq:</span><br><span class="line">	<span class="comment">/* 执行到这里之前: */</span></span><br><span class="line">	<span class="comment">/* 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址 */</span></span><br><span class="line">	<span class="comment">/* 2. SPSR_irq保存有被中断模式的CPSR */</span></span><br><span class="line">	<span class="comment">/* 3. CPSR中的M4-M0被设置为10010, 进入到irq模式 */</span></span><br><span class="line">	<span class="comment">/* 4. 跳到0x18的地方执行程序 */</span> </span><br><span class="line">	<span class="comment">/* sp_irq未设置, 先设置它 */</span></span><br><span class="line">	ldr sp, =<span class="number">0x33d00000</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 保存现场 */</span></span><br><span class="line">	<span class="comment">/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */</span></span><br><span class="line">	<span class="comment">/* lr-4是异常处理完后的返回地址, 也要保存 */</span></span><br><span class="line">	sub lr, lr, #<span class="number">4</span></span><br><span class="line">	stmdb sp!, &#123;r0-r12, lr&#125;  </span><br><span class="line">		</span><br><span class="line">	<span class="comment">/* 处理irq异常 */</span></span><br><span class="line">	bl handle_irq_c</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 恢复现场 */</span></span><br><span class="line">	ldmia sp!, &#123;r0-r12, pc&#125;^  <span class="comment">/* ^会把spsr_irq的值恢复到cpsr里 */</span></span><br></pre></td></tr></table></figure>


<p>handle_irq_c函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">key_eint_irq</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = EINTPEND;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val1 = GPFDAT;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val2 = GPGDAT;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (irq == <span class="number">0</span>) <span class="comment">/* eint0 : s2 控制 D12 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) <span class="comment">/* s2 --&gt; gpf6 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">2</span>) <span class="comment">/* eint2 : s3 控制 D11 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val1 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) <span class="comment">/* s3 --&gt; gpf5 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 松开 */</span></span><br><span class="line">			GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 按下 */</span></span><br><span class="line">			GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (irq == <span class="number">5</span>) <span class="comment">/* eint8_23, eint11--s4 控制 D10, eint19---s5 控制所有LED */</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) <span class="comment">/* eint11 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) <span class="comment">/* s4 --&gt; gpf4 */</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下 */</span></span><br><span class="line">				GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">19</span>)) <span class="comment">/* eint19 */</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (val2 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">11</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 松开 */</span></span><br><span class="line">				<span class="comment">/* 熄灭所有LED */</span></span><br><span class="line">				GPFDAT |= ((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">/* 按下: 点亮所有LED */</span></span><br><span class="line">				GPFDAT &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	EINTPEND = val; 	<span class="comment">/* 清中断 : 源头*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*INTOFFSET中哪一位被设置成1，就表示哪一个 中断源*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">	&#123;</span><br><span class="line">		key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);<span class="comment">/*清EINT0，EINT2，EINT5*/</span></span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-irq-ding-shi-qi-zhong-duan">3.4 irq-定时器中断</span><a href="#3-4-irq-ding-shi-qi-zhong-duan" class="header-anchor">#</a></h2><h3><span id="3-4-1-yin-ru-kan-men-gou-ding-shi-qi">3.4.1 引入看门狗定时器</span><a href="#3-4-1-yin-ru-kan-men-gou-ding-shi-qi" class="header-anchor">#</a></h3><p>s3c2440共有2种定时器：</p>
<pre><code>1.Watchdog看门狗定时器
2.PWM脉冲可调制定时器
</code></pre>
<p>下面详细介绍2种定时器的原理，来了解定时器是如何产生定时器中断的。</p>
<h4><span id="3-4-1-1-watchdog-ding-shi-qi-yuan-li">3.4.1.1 WatchDog定时器原理</span><a href="#3-4-1-1-watchdog-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>Watchdog定时器的原理很简单，寄存器很少，框图如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/37.png"></p>
<ol>
<li>定时器，定时器那肯定是需要用到时钟的，从框图中可以看到Watchdog定时器采用的时钟源是PCLK，从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中也可以体现出来，接的是APB总线。</li>
<li>然后到达一个8 bit的分频器，可以通过配置WTCON[15:8]来设置分频器的预设值。</li>
<li>再设置WTCON[4:3]来设置除数因子来进一步分频。<br>所以最终的Watchdog定时器的时钟周期<code>t_watchdog = 1/[ PCLK / (Prescaler value + 1) / Division_factor ]</code></li>
<li>到达WTCNT：看门狗递减寄存器。WTCNT里的数据就开始在输入时钟频率下递减。WTCNT的值由WTDAT寄存器提供。</li>
<li>WTDAT：WTDAT寄存器用于指定计数器的初始值，也就是它的超时时间，<strong>系统上电之后硬件自动的将0x8000的初始值载入到WTCNT里，在发生了第一次超时操作时，WTDAT的值才会载入到WTCNT寄存器</strong>。</li>
</ol>
<p>当WTCNT的值减到0时，就会触发看门狗定时器中断，进而产生复位。中断框图中可以看到可以设置WTCON[2]来设置是否产生中断信号，可以设置WTCON[0]来设置是否产生复位信号。</p>
<h5><span id="3-4-1-1-1-wtcon-ji-cun-qi">3.4.1.1.1 WTCON寄存器</span><a href="#3-4-1-1-1-wtcon-ji-cun-qi" class="header-anchor">#</a></h5><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/38.png"></p>
<h5><span id="3-4-1-1-2-wtcnt-wtdat-ji-cun-qi">3.4.1.1.2 WTCNT、WTDAT寄存器</span><a href="#3-4-1-1-2-wtcnt-wtdat-ji-cun-qi" class="header-anchor">#</a></h5><p> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/39.png"></p>
<h3><span id="3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li">3.4.2 WatchDog定时器中断示例</span><a href="#3-4-2-watchdog-ding-shi-qi-zhong-duan-shi-li" class="header-anchor">#</a></h3><h4><span id="3-4-2-1-ding-shi-qi-chu-shi-hua">3.4.2.1 定时器初始化</span><a href="#3-4-2-1-ding-shi-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>在之前的章节中，我们在start.s启动代码中首先做的就是关闭看门狗，把WTCON[5]&#x3D;0，也就是把Watchdog timer给disable。那么Watchdog Timer就不再工作了，这样做是为了防止在启动代码进行硬件初始化的时候出现超时，发出复位信号又去重启硬件，这样就陷入了不断重启过程中。因为s3c2440芯片默认WTCON[5]是1，也就是Watchdog Timer默认是处于使能状态。</p>
<p>从<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440时钟体系</a>中配置了PCLK&#x3D;50M Hz, 那么让WTDAT取默认值0x8000，那么根据公式算出从开机到触发复位重启的时间：</p>
<p><code>t=WTDAT*( 1/[ PCLK / (Prescaler value + 1) / Division_factor ])</code>。</p>
<p>根据WTCON寄存器配置Prescaler value&#x3D;255，配置Division_factor&#x3D;128，这样最终定时器分得的频率更低，那么减数器递减的更慢，也就代表从开机到触发复位重启的时间:</p>
<p><code>T=0x8000 * (1/[50*10^6/(255+1)/128]) = 21474836.48us = 21s</code>。</p>
<p>之前的start.s中把看门狗已经关闭了，那么我们在跳转到main函数中调用wtd_timer_init函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//使能定时器，开启reset复位</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们查看测试结果：<br>果然初始化wtd_timer_init后，过21s后板子重启了，说明我们watchdog定时器功能已经OK了。</p>
<p>现在修改代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wtd_timer_init2</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	WTCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//使能定时器，开启watchdog定时器中断</span></span><br><span class="line">	WTCON |= (<span class="number">3</span>&lt;&lt;<span class="number">3</span>) | (<span class="number">255</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">	WTDAT = <span class="number">0x4000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到我们现在定时器的初值被修改成了0x4000, 相对于默认值少了一半，那么触发wtd_timer中断的时间应该减半，也就是约等于10s。</p>
<h4><span id="3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.2.2 定时器中断服务程序</span><a href="#3-4-2-2-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h4><p>那么需要写一个wtd_timer的中断服务程序，同样需要先在do_irq中去保护现场、调用handle_irq_c、恢复现场。查看INTOFFSET寄存器：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/40.png"></p>
<p>得知：<br>handle_irq_c代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        这里还需区分子中断源</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看芯片手册查找“INT_WDT_AC97”如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/41.png"></p>
<p>从上图可以看到SRCPND和SUBSRCPND的映射关系。<br>SUBSRCPND寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/42.png"></p>
<p>我们可以读取SUBSRCPND来区分到底是哪一个子中断源产生了中断，当SUBSRCPND中哪一位被置1，表示对应的中断源发生了中断。</p>
<p>前面做完wtd_timer_init，还要进行中断控制器的初始化，查看INTMSK寄存器如下图：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/43.png"></p>
<p>查看INTSUBMSK寄存器如下图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/44.png"></p>
<p>在interrupt_init中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">9</span>);<span class="comment">//不屏蔽INT_WDT_AC97</span></span><br><span class="line">INTSUBMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">14</span>);<span class="comment">//不屏蔽INT_AC97</span></span><br></pre></td></tr></table></figure>

<p>修改handle_irq_c:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">9</span>)<span class="comment">//INTOFFSET==9</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (SUBSRCPND &amp; <span class="number">1</span>&lt;&lt;<span class="number">14</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;watchdog timer interrupt occured.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi">3.4.3 PWM脉冲宽度调制定时器</span><a href="#3-4-3-pwm-mai-chong-kuan-du-diao-zhi-ding-shi-qi" class="header-anchor">#</a></h3><p>PWM（Pulse Width Modulation），字面上是脉冲可调制的意思，就是可以调节占空比。</p>
<p>s3c2440有5个定时器，其中定时器0、1、2和3具有脉宽调制（PWM）功能。定时器4是一个无输出引脚的内部定时器。</p>
<p>先认识下s3c2440的pwm timer的框架：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/45.jpg"></p>
<pre><code>1.时钟源为PCLK
2.pclk经过8 bit的预分频系数（Prescaler），和4 bit的时钟除数因子（clock divider）,进行分频
3.经过MUX选择器选择用哪个定时器（5选1）
4.设置TCMPB0和TCNTB0和TCONn寄存器
</code></pre>
<h4><span id="3-4-1-1-pwm-ding-shi-qi-yuan-li">3.4.1.1 pwm定时器原理</span><a href="#3-4-1-1-pwm-ding-shi-qi-yuan-li" class="header-anchor">#</a></h4><p>pwm定时器的逻辑控制单元结构如下：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/46.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> TCMPBn和TCNTBn寄存器中的值分别加载到TCMPn和TCNTn寄存器</span><br><span class="line"><span class="number">2</span> 每来一个clk(时钟)这个TCNTn减去<span class="number">1</span></span><br><span class="line"><span class="number">3</span> 当TCNTn == TCMPn时，可以产生中断，pwm输出引脚反转</span><br><span class="line"><span class="number">4</span> TCNTn继续减<span class="number">1</span>，当TCNTn == <span class="number">0</span>时，又产生一次中断，pwm引脚再次反转</span><br><span class="line"><span class="number">5</span> 重复<span class="number">1</span><span class="number">-4</span>过程</span><br></pre></td></tr></table></figure>

<p>设置TCNTBn寄存器来设置加载初值，设置后TCNTn中的值就会按照时钟周期递减。<br>设置TCMPBn寄存器来设置占空比，从而控制高低电平持续时间的比例。</p>
<h4><span id="3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian">3.4.3.2 pwm定时器编程实现</span><a href="#3-4-3-2-pwm-ding-shi-qi-bian-cheng-shi-xian" class="header-anchor">#</a></h4><p>要开始一个PWM定时器功能的步骤如下：(假设使用的是timer0)</p>
<h5><span id="3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi">3.4.3.2.1 初始化pwm定时器</span><a href="#3-4-3-2-1-chu-shi-hua-pwm-ding-shi-qi" class="header-anchor">#</a></h5><p>定义一个pwm_timer_init()函数。</p>
<ol>
<li><p>设置时钟：<br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/47.png"><br> <img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/48.png"></p>
<p> 分别设置定时器0的预分频器值(prescaler)和时钟分频值(clock divider)，从而控制TCNT0减数器的频率。</p>
</li>
</ol>
<p>根据公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pwm Timer clk = PCLK / &#123;(预分频数)prescaler value+<span class="number">1</span>&#125; / &#123;divider value(<span class="number">5.1</span>MUX值)&#125; </span><br></pre></td></tr></table></figure>
<p>PCLK是50M，设置prescaler value&#x3D;99， divider value&#x3D;16,所以pwm Timer clk&#x3D; 50000000&#x2F;(99+1)&#x2F;16 &#x3D; 31250 Hz</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCFG0 = <span class="number">99</span>; </span><br><span class="line">TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">TCFG1 |= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>设置初值：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置比较缓存寄存器TCMPB0和计数缓存寄存器TCNTB0的初始值*/</span></span><br><span class="line">TCNTB0 = <span class="number">31250</span> &lt;&lt; <span class="number">1</span>;  <span class="comment">/* 2s中断一次 */</span></span><br><span class="line">TCMPB0 = <span class="number">31250</span> &gt;&gt; <span class="number">1</span>;  <span class="comment">/* 设置占空比*/</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>开启定时器0的手动更新TCNTB0&amp;TCMPB0功能(设置TCON的第1位)：</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/49.png"></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开始需要手工更新,这样才能将TCNTB0&amp;TCMPB0同步到TCNT0&amp;TCMP0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启定时器0的自动加载：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>); <span class="comment">//开启自动加载要先清除手动更新</span></span><br><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动定时器0(设置TCON的第0位)；</li>
</ol>
<p>	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>初始化中断控制器:</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/50.png"><br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/51.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">interrupt_init()&#123;</span><br><span class="line">	...</span><br><span class="line">	INTMSK &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">10</span>);  <span class="comment">/* enable timer0 int */</span>		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做完这些初始化工作，就可以产生定时器中断了,同样我们需要在handle_irq_c函数中区分中断源：</p>
<h5><span id="3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu">3.4.3.2.2 pwm定时器中断服务程序</span><a href="#3-4-3-2-2-pwm-ding-shi-qi-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h5><p>我们可以通过查看TCNTO0寄存器来查看当前TCNT的值。</p>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/52.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 分辨中断源 */</span></span><br><span class="line">    <span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 调用对应的处理函数 */</span></span><br><span class="line">    <span class="keyword">if</span> (bit == <span class="number">0</span> || bit == <span class="number">2</span> || bit == <span class="number">5</span>)  <span class="comment">/* eint0,2,bit==5还需细分eint8_23 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        key_eint_irq(bit); <span class="comment">/* 处理中断, 清中断源EINTPEND（eint11,2 eint11, eint11） */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">9</span>) <span class="comment">//INT_WDT_AC97</span></span><br><span class="line">	&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">10</span>) <span class="comment">//timer0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;timer0 interrupt occured.\n&quot;</span>);</span><br><span class="line">		print_hex(TCNTO0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清中断 : 从源头开始清 */</span></span><br><span class="line">    SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">    INTPND = (<span class="number">1</span>&lt;&lt;bit);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2><span id="3-5-irq-de-you-hua-gai-jin">3.5 irq的优化改进</span><a href="#3-5-irq-de-you-hua-gai-jin" class="header-anchor">#</a></h2><p>我们对比irq外部中断， irq定时器中断，发现每增加一个中断源，又要去修改中断控制器的初始化interrupt_init()和handle_irq_c(),要在handle_irq_c()中去添加分支去执行不同的中断服务。</p>
<p>那么我们现在不去改变interrupt文件，在timer.c、key_eint.c中去注册自己的中断服务程序即可，这里我们使用<strong>函数指针数组</strong>，建立一个中断号和中断服务程序的映射关系。这样就可以根据中断号来执行对应的中断服务程序，即在handle_irq_c()中去回调不同类型的中断源注册下来的函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义函数指针数组 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRQ_NUM	32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*irq_func)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">irq_func irq_array[IRQ_NUM];</span><br></pre></td></tr></table></figure>

<p>然后实现一个register_irq(…)如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">register_irq</span> <span class="params">(<span class="type">int</span> irq, irq_func fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	irq_array[irq] = fp;</span><br><span class="line">	INTMASK &amp;= ~(<span class="number">1</span> &lt;&lt; irq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_irq_c()修改实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_irq_c</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 分辨中断源 */</span></span><br><span class="line">	<span class="type">int</span> bit = INTOFFSET;</span><br><span class="line"></span><br><span class="line">	irq_array[bit](bit); <span class="comment">//根据中断号回调不同的中断处理函数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 清中断 */</span></span><br><span class="line">	SRCPND = (<span class="number">1</span>&lt;&lt;bit);</span><br><span class="line">	INTPND = (<span class="number">1</span>&lt;&lt;bit);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子我们的irq中断就被统一管理了起来，只要在其他各中断模块初始化的时候调用register_irq(…)注册即可。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>中断体系</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-ADC</title>
    <url>/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-adc-ying-jian-yuan-li">1 ADC硬件原理</a><ul>
<li><a href="#1-1-adc-shu-xing">1.1 ADC属性</a></li>
<li><a href="#1-2-adc-kuang-tu">1.2 ADC框图</a></li>
</ul>
</li>
<li><a href="#2-adc-ji-cun-qi">2 ADC寄存器</a><ul>
<li><a href="#2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</a></li>
<li><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</a></li>
<li><a href="#2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</a></li>
</ul>
</li>
<li><a href="#3-bian-cheng-ce-shi">3 编程测试</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-adc-ying-jian-yuan-li">1 ADC硬件原理</span><a href="#1-adc-ying-jian-yuan-li" class="header-anchor">#</a></h1><p>模数转换器即A&#x2F;D转换器，或简称ADC，通常是指一个将模拟信号转变为数字信号的电子元件。</p>
<p>如图，把可变电阻上的电压值变换的模拟信号通过ADC转换，输出数字信号。以s3c2440为例：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/1.jpg"></p>
<h2><span id="1-1-adc-shu-xing">1.1  ADC属性</span><a href="#1-1-adc-shu-xing" class="header-anchor">#</a></h2><p>对于数字信号我们需要得到它的2个属性：</p>
<ol>
<li><p>转换精度：<br>用多少位来存储这个数据（假如是10 bit）。那么最大值0b111111111对应3.3v， 0b0对应0v。</p>
</li>
<li><p>采样&#x2F;转换速度：</p>
</li>
</ol>
<p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/2.png"><br>可以看出s3c2440的转换精度可达10 bit, 转换速率可达 500ksps.</p>
<h2><span id="1-2-adc-kuang-tu">1.2 ADC框图</span><a href="#1-2-adc-kuang-tu" class="header-anchor">#</a></h2><p>下图是s3c2440芯片的ADC转换框图：<br><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/3.png"></p>
<p>可以看出AD converter前有一个MUX选择器，用来选择模拟输入源，这里选择A[3:0]作为输入源。</p>
<p>下面是编写程序要做的步骤：</p>
<pre><code>1.确定是哪一路信号：设置8：1MUX
2.设置工作时钟
3.启动ADC
4.读状态，判断ADC转换是否成功。
5.读数据
</code></pre>
<h1><span id="2-adc-ji-cun-qi">2 ADC寄存器</span><a href="#2-adc-ji-cun-qi" class="header-anchor">#</a></h1><h2><span id="2-1-kong-zhi-ji-cun-qi-adccon">2.1 控制寄存器（ADCCON）</span><a href="#2-1-kong-zhi-ji-cun-qi-adccon" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/4.png"></p>
<pre><code>bit[15]：只读，用来表示转换是否完成
bit[14:6]:用来设置adc频率（如果是auto TSC则不用设置该位）
bit[5：3]:用来选择模拟输入源
bit[2]:用来设置是否待机
bit[0]:用来启动adc
</code></pre>
<h2><span id="2-2-qi-dong-yan-shi-ji-cun-qi-adcdly">2.2 启动延时寄存器（ADCDLY）</span><a href="#2-2-qi-dong-yan-shi-ji-cun-qi-adcdly" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/5.png"></p>
<h2><span id="2-3-shu-ju-ji-cun-qi-adcdat0">2.3 数据寄存器（ADCDAT0）</span><a href="#2-3-shu-ju-ji-cun-qi-adcdat0" class="header-anchor">#</a></h2><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/6.png"></p>
<pre><code>bit[9:0]表示转换后的数据
</code></pre>
<h1><span id="3-bian-cheng-ce-shi">3 编程测试</span><a href="#3-bian-cheng-ce-shi" class="header-anchor">#</a></h1><p><img src="/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/7.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>); <span class="comment">//设置输入源AIN0, ADC时钟为1Mhz,并且使能预分频</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">adc_read_ain0</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">		<span class="comment">/* 启动ADC */</span></span><br><span class="line">	ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!(ADCCON &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)));  <span class="comment">/* 等待ADC结束 */</span></span><br><span class="line">	<span class="keyword">return</span> ADCDAT0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-I2C</title>
    <url>/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-i2c-yuan-li">1 I2C原理</a><ul>
<li><a href="#1-1-ying-jian-dian-lu">1.1 硬件电路</a></li>
<li><a href="#1-2-i2c-xie-yi">1.2 i2c协议</a><ul>
<li><a href="#1-2-1-s-p-xin-hao">1.2.1 S&#x2F;P信号</a></li>
<li><a href="#1-2-2-ack-xin-hao">1.2.2 ACK信号</a></li>
<li><a href="#1-2-3-data-ge-shi">1.2.3 DATA格式</a></li>
<li><a href="#1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</a></li>
</ul>
</li>
<li><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</a></li>
<li><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</a></li>
<li><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</a></li>
</ul>
</li>
<li><a href="#2-i2c-kong-zhi-qi">2 I2C控制器</a><ul>
<li><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</a></li>
<li><a href="#2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</a><ul>
<li><a href="#2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</a></li>
<li><a href="#2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</a><ul>
<li><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</a></li>
<li><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</a></li>
<li><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</a></li>
<li><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</a><ul>
<li><a href="#3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</a><ul>
<li><a href="#3-1-1-zhu-fa-master-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-2-zhu-shou-master-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</a></li>
<li><a href="#3-1-3-cong-fa-slave-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</a></li>
<li><a href="#3-1-4-cong-shou-slave-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-i2c-cheng-xu-shi-li">4 I2C程序示例</a><ul>
<li><a href="#4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</a><ul>
<li><a href="#4-1-1-at24cxx-eeprom">4.1.1 AT24CXX EEPROM</a></li>
</ul>
</li>
<li><a href="#4-2-cheng-xu-kuang-jia">4.2 程序框架</a><ul>
<li><a href="#4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</a></li>
<li><a href="#4-2-2-i2c-test-c">4.2.2 i2c_test.c</a></li>
<li><a href="#4-2-3-at24cxx-c">4.2.3 at24cxx.c</a></li>
<li><a href="#4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</a></li>
<li><a href="#4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</a></li>
<li><a href="#4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</a></li>
</ul>
</li>
<li><a href="#4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</a></li>
<li><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</a><ul>
<li><a href="#4-4-1-xie-cao-zuo">4.4.1 写操作</a></li>
<li><a href="#4-4-2-du-cao-zuo">4.4.2 读操作</a></li>
</ul>
</li>
<li><a href="#4-5-ce-shi">4.5 测试</a><ul>
<li><a href="#4-5-1-i2c-test-c">4.5.1 i2c_test.c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-i2c-yuan-li">1 I2C原理</span><a href="#1-i2c-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-ying-jian-dian-lu">1.1 硬件电路</span><a href="#1-1-ying-jian-dian-lu" class="header-anchor">#</a></h2><p>I2C总线是由Philips公司开发的一种简单、双向二线制同步串行总线。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/1.png" alt="img"></p>
<p>SDA（串行数据线）和SCL（串行时钟线）都是双向I&#x2F;O线，需通过上拉电阻接电源VCC．当总线空闲时．两根线都是高电平。</p>
<p>I2C 总线标准模式下速度可以达到 100Kb&#x2F;S，快速模式下可以达到 400Kb&#x2F;S。SDA 和 SCL 这两根线必须要接一个上拉电阻，一般是 4.7K。</p>
<h2><span id="1-2-i2c-xie-yi">1.2 i2c协议</span><a href="#1-2-i2c-xie-yi" class="header-anchor">#</a></h2><p>传输过程如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/2.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 主控发送start讯号(S)</span><br><span class="line"><span class="number">2.</span> 主控发送从设备地址(slave dev addr)</span><br><span class="line"><span class="number">3.</span> 主控发送方向（W/R）</span><br><span class="line"><span class="number">4.</span> 从设备应答（ack）</span><br><span class="line"><span class="number">5.</span> 主控（or从设备）发送数据(data)</span><br><span class="line"><span class="number">6.</span> 从设备（or主控）应答(ack)</span><br><span class="line">...</span><br><span class="line"><span class="number">7.</span> 主控发送停止信号(P)</span><br></pre></td></tr></table></figure>

<p>s3c2440 一次i2c读写过程:</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/3.png" alt="img"></p>
<h3><span id="1-2-1-s-x2f-p-xin-hao">1.2.1 S&#x2F;P信号</span><a href="#1-2-1-s-x2f-p-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/4.png" alt="img"></p>
<p>start信号：SCL是高电平，SDA被主控拉低。<br>stop信号：SCL是高电平，SDA被主控拉高。</p>
<p>示波器测量出start信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/5.png" alt="img"></p>
<p>示波器测量出stop信号:<br><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/6.png" alt="img"></p>
<h3><span id="1-2-2-ack-xin-hao">1.2.2 ACK信号</span><a href="#1-2-2-ack-xin-hao" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/7.png" alt="img"></p>
<p>第9个时钟周期，SDA被拉低表示ack讯号。</p>
<h3><span id="1-2-3-data-ge-shi">1.2.3 DATA格式</span><a href="#1-2-3-data-ge-shi" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/8.png" alt="img"></p>
<p>用 9个clk传输8bit数据（7bit 从设备地址 + 1bit方向 ），MSB高位先出。第9个clk是ack讯号。</p>
<h3><span id="1-2-4-shu-ju-you-xiao-xing">1.2.4 数据有效性</span><a href="#1-2-4-shu-ju-you-xiao-xing" class="header-anchor">#</a></h3><p>SDA 线上的数据必须在<strong>SCL高电平周期保持稳定，在 SCL 低电平时才能允许改变</strong>。</p>
<h2><span id="1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li">1.3 一次完整的I2C数据传输举例</span><a href="#1-3-yi-ci-wan-zheng-de-i2c-shu-ju-chuan-shu-ju-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/9.jpg" alt="img"></p>
<ol>
<li>主控发送了S信号；</li>
<li>发送地址0x34，包含读写位；</li>
<li>发送数据0x30, 0x00, 0x01共3个字节数据；</li>
<li>最后SDA被拉高发送P信号。</li>
</ol>
<p>这里我是用了带I2C解码的示波器，能将I2C协议解码出来方便调试者阅读分析。</p>
<h2><span id="1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li">1.4 一条SDA上实现双向传输的原理</span><a href="#1-4-yi-tiao-sda-shang-shi-xian-shuang-xiang-chuan-shu-de-yuan-li" class="header-anchor">#</a></h2><p>电路设计内部结构使用<strong>开极电路</strong>。如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/10.png" alt="img"></p>
<p><strong>条件</strong>：</p>
<ol>
<li><p>主设备发送时，从设备不发送（通过SCL控制即可，比如让前8个clk主控发送数据到SDA,让第9个clk从设备发送数据到SDA）</p>
</li>
<li><p>主设备发送数据时，从设备的“发送引脚”不能影响SDA数据。反之，从设备发送数据时，主设备的”发送引脚”不能影响到SDA数据。那么如何做到？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SDA内部电路用三极管，开集电路,原理如下图：</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/11.png" alt="img"></p>
<p>从上图知道：</p>
<ol>
<li><p>当A,B都为低电平时，三极管不导通，SDA的电平取决于外部电路，这里SDA有上拉电阻，所以对应高电平；</p>
</li>
<li><p>当主控拉高A时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
<li><p>同理，当从设备拉高B时，三极管导通，此时SDA接地，电平被拉低</p>
</li>
</ol>
</li>
</ol>
<p>那么电平真值表如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/12.png" alt="img"></p>
<p>所以，要实现双向传输：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果要master-&gt; slave进行数据传输，那么让主控驱动三极管，拉低SDA。</span><br><span class="line">如果要slave-&gt; master进行数据传输，那么让从设备驱动三极管，拉低SDA。</span><br><span class="line">否则，都不驱动三极管，SDA一直输出高电平，处于idle状态。</span><br></pre></td></tr></table></figure>

<p>从下面的例子可以看看数据是怎么传的（实现双向传输）。</p>
<p>举例：主设备发送（8bit）给从设备:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">前 <span class="number">8</span> 个 clk</span><br><span class="line">	◼ 从设备不要影响 SDA，从设备不驱动三极管</span><br><span class="line">	◼ 主设备决定数据，主设备要发送 <span class="number">1</span> 时不驱动三极管，要发送 <span class="number">0</span> 时驱动三极管</span><br><span class="line">第 <span class="number">9</span> 个 clk，由从设备决定数据</span><br><span class="line">	◼ 主设备不驱动三极管</span><br><span class="line">	◼ 从设备决定数据，要发出回应信号的话，就驱动三极管让 SDA 变为 <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从这里也可以知道 ACK 信号是低电平从上面的例子，就可以知道怎样在一条线上实现双向传输，这就是 SDA 上要使用上拉电阻的原因。</p>
<p>为何 SCL 也要使用上拉电阻？在第 9 个时钟之后，如果有某一方需要更多的时间来处理数据，它可以一直驱动三极管把 SCL 拉低。</p>
<p>当 SCL 为低电平时候，大家都不应该使用 IIC 总线，只有当 SCL 从低电平变为高电平的时候，IIC 总线才能被使用。当它就绪后，就可以不再驱动三极管，这是上拉电阻把 SCL 变为高电平，其他设备就可以继续使用 I2C 总线了。</p>
<h2><span id="1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai">1.5 SCL被从设备拉低表示busy状态</span><a href="#1-5-scl-bei-cong-she-bei-la-di-biao-shi-busy-zhuang-tai" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/13.png" alt="img"></p>
<p>在<strong>第9个clk 后i2c会产生中断，此时SCL被拉低，表示busy状态</strong>，表示谁都不允许再使用i2c, 然后等到中断处理结束了，也就是处于idle状态了，此时会释放出SCL，那么主控可以继续发送SCL讯号表示可以继续进行i2c通信了。</p>
<h1><span id="2-i2c-kong-zhi-qi">2 I2C控制器</span><a href="#2-i2c-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-i2c-zhu-cong-she-bei-guan-xi">2.1 I2c主从设备关系</span><a href="#2-1-i2c-zhu-cong-she-bei-guan-xi" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/14.png" alt="img"></p>
<p>对于写操作，主控作为transmitter,从设备作为receiver。<br>对于读操作，主控作为receiver， 从设备作为transmitter。</p>
<h2><span id="2-2-s3c2440-i2c-kong-zhi-qi">2.2 s3c2440 I2C控制器</span><a href="#2-2-s3c2440-i2c-kong-zhi-qi" class="header-anchor">#</a></h2><h3><span id="2-2-1-kong-zhi-qi-kuang-tu">2.2.1 控制器框图</span><a href="#2-2-1-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/15.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pclk = <span class="number">50</span>Mhz, 经过prescaler分频，可以得到SCL。</span><br><span class="line"></span><br><span class="line">IICSTAT: 发出S（start）信号或者P(stop)信号。</span><br><span class="line"></span><br><span class="line">Data Bus可以把数据写入IICDS寄存器，然后会自动产生SCL，并且会将<span class="number">8</span>位数据从SDA同步给slave dev，</span><br><span class="line"></span><br><span class="line">在数据发送出去后，在第<span class="number">9</span>个SCL时钟，会受到slave dev的ack应答，可以通过查询IICSTAT来判断是否有ACK回应。</span><br><span class="line"></span><br><span class="line">当slave dev回应ACK后，那么又可以继续发送数据，继续写入据到IICDS。</span><br><span class="line"></span><br><span class="line">当主控想结束，设置IICSTAT发出P信号。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-2-ji-cun-qi-jie-shao">2.2.2 寄存器介绍</span><a href="#2-2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h3><h4><span id="2-2-2-1-iiccon-shi-zhong-pei-zhi">2.2.2.1 IICCON-时钟配置</span><a href="#2-2-2-1-iiccon-shi-zhong-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/16.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bit[<span class="number">7</span>]: 对于发送模式，不需要配置ack信号，ack是接收者发送回来的应答。对于接受模式，设置成<span class="number">1</span>，让它在第<span class="number">9</span>个CLK发出ack讯号（拉低sda）。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">6</span>]:SCL时钟源，pclk分频即可</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:中断使能，使用i2c时要去enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>]:中断状态标识 表示中断有没有结束，当该bit读出来是<span class="number">1</span>时，SCL被拉低表示busy，也就是i2c中断还在处理中。当i2c中断处理结束后，可以将该bit 清<span class="number">0</span>，释放出SCL。</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>:<span class="number">0</span>]:i2c时钟分频系数配置，SCL时钟 = IICCLK/(IICCON[<span class="number">3</span>:<span class="number">0</span>]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-2-iicstat-mo-shi-pei-zhi">2.2.2.2 IICSTAT-模式配置</span><a href="#2-2-2-2-iicstat-mo-shi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/17.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">7</span>:<span class="number">6</span>]:模式选择</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">5</span>]:当读的时候，<span class="number">0</span>表示not busy,<span class="number">1</span>表示busy, 当写的时候，<span class="number">0</span>表示写入STOP, <span class="number">1</span>表示写入START</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">4</span>] : 数据输出使能，<span class="number">0</span>：表示disable, <span class="number">1</span>表示enable</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">3</span>]:仲裁flag</span><br><span class="line"></span><br><span class="line">Bit[<span class="number">0</span>]:表示i2c总线上的第<span class="number">9</span>个时钟周期有没有ack，<span class="number">1</span>表示有ack, <span class="number">0</span>表示无ack</span><br></pre></td></tr></table></figure>

<h4><span id="2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi">2.2.2.3 IICADD-从机地址配置</span><a href="#2-2-2-3-iicadd-cong-ji-di-zhi-pei-zhi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/18.png" alt="img"></p>
<h4><span id="2-2-2-4-iicds-shu-ju-ji-cun-qi">2.2.2.4 IICDS-数据寄存器</span><a href="#2-2-2-4-iicds-shu-ju-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/19.png" alt="img"></p>
<h1><span id="3-i2c-du-xie-cao-zuo-liu-cheng">3 I2C读写操作流程</span><a href="#3-i2c-du-xie-cao-zuo-liu-cheng" class="header-anchor">#</a></h1><p>The following steps must be executed before any IIC Tx&#x2F;Rx operations.</p>
<ol>
<li>Write own slave address on IICADD register, if needed.</li>
<li>Set IICCON register.<ol>
<li>Enable interrupt</li>
<li>Define SCL period</li>
</ol>
</li>
<li>Set IICSTAT to enable Serial Output</li>
</ol>
<p>在操作tx,rx前，要先执行以下几步骤：</p>
<ol>
<li>IICADD写入从设备地址</li>
<li>设置IICCON，设置时钟，使能中断</li>
<li>设置IICSTAT，使能传输</li>
</ol>
<h2><span id="3-1-i2c-cao-zuo-mo-shi">3.1 I2C操作模式</span><a href="#3-1-i2c-cao-zuo-mo-shi" class="header-anchor">#</a></h2><p>The S3C2440A IIC-bus interface has four operation modes:<br><strong>— Master transmitter mode</strong><br><strong>— Master receive mode</strong><br><strong>— Slave transmitter mode</strong><br><strong>— Slave receive mode</strong></p>
<h3><span id="3-1-1-zhu-fa-master-x2f-transmitter-mode">3.1.1 主发Master&#x2F;Transmitter Mode</span><a href="#3-1-1-zhu-fa-master-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/20.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master tx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">11</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xF0（使能传输,发S信号，使能tx/rx）</span><br><span class="line">3. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">			IICDS = buf</span><br><span class="line">			Clear pending bit</span><br><span class="line">			数据被发送出去，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">			IICSTAT = <span class="number">0xd0</span></span><br><span class="line">			Clear pending bit（IICCON[<span class="number">4</span>]）</span><br><span class="line">			Delay一会儿等待停止条件生效</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-2-zhu-shou-master-x2f-receiver-mode">3.1.2 主收Master&#x2F;Receiver Mode</span><a href="#3-1-2-zhu-shou-master-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/21.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 配置成master rx <span class="title function_">mode</span><span class="params">(也就是IICSTAT[<span class="number">7</span>:<span class="number">6</span>]配置成<span class="number">10</span>)</span></span><br><span class="line">2. 把从设备地址写入IICDS，（第一次传输地址）</span><br><span class="line">3. IICSTAT写入0xB0（使能传输）</span><br><span class="line">4. IICDS中配置的数据（从设备地址7bit + 读写位1bit）就被发送出去了（每传输完一个数据将产生一个中断）</span><br><span class="line">5. 判断第9个clk从设备是否有ack</span><br><span class="line">	5.1 如果从设备有ack,恢复i2c传输</span><br><span class="line">		Buf = IICDS</span><br><span class="line">		Clear pending bit</span><br><span class="line">		数据被接受到，继续i2c传输</span><br><span class="line">	<span class="number">5.2</span> 如果没有ack, stop，返回错误</span><br><span class="line">		IICSTAT = <span class="number">0x90</span></span><br><span class="line">		Clear pending bit</span><br><span class="line">		Delay一会儿</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-cong-fa-slave-x2f-transmitter-mode">3.1.3 从发Slave&#x2F;Transmitter Mode</span><a href="#3-1-3-cong-fa-slave-x2f-transmitter-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/22.png" alt="img"></p>
<h3><span id="3-1-4-cong-shou-slave-x2f-receiver-mode">3.1.4 从收Slave&#x2F;Receiver Mode</span><a href="#3-1-4-cong-shou-slave-x2f-receiver-mode" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/23.png" alt="img"></p>
<h1><span id="4-i2c-cheng-xu-shi-li">4 I2C程序示例</span><a href="#4-i2c-cheng-xu-shi-li" class="header-anchor">#</a></h1><h2><span id="4-1-i2c-cong-she-bei-jie-shao">4.1 I2C从设备介绍</span><a href="#4-1-i2c-cong-she-bei-jie-shao" class="header-anchor">#</a></h2><p>IIC控制器只提供了传输数据的能力，至于数据有什么含义，IIC控制器并不知道，数据的含义有外部i2c从设备，我们需要阅读芯片手册，才知道IIC控制器应该发出怎样的数据。</p>
<h3><span id="4-1-1-at24cxx-eeprom">4.1.1  AT24CXX EEPROM</span><a href="#4-1-1-at24cxx-eeprom" class="header-anchor">#</a></h3><p>AT24Cxx系列EEPROM是由美国Mcrochip公司出品，1-512K位的支持I2C总线数据传送协议的串行CMOS E2PROM。I2c传输规则如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/24.png" alt="img"></p>
<h2><span id="4-2-cheng-xu-kuang-jia">4.2 程序框架</span><a href="#4-2-cheng-xu-kuang-jia" class="header-anchor">#</a></h2><p>我们的程序应该分为两层（IIC设备层，IIC控制器层），框架如下图所示：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/25.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最上层是i2c_test层，用来对i2c的功能进行测试和验证。</span><br><span class="line"></span><br><span class="line">第2层是i2c设备层，用来对具体某一型号的从设备进行i2c读写。</span><br><span class="line"></span><br><span class="line">第3层是通用i2c控制器层，用来提供对具体某一型号的i2c主控进行管理操作。</span><br><span class="line"></span><br><span class="line">最底层是i2c控制器具体的型号层。</span><br></pre></td></tr></table></figure>

<p>在通用i2c控制层，我们提供一个统一的接口i2c_transfer，不关使用哪个芯片，他最终都会调用i2c_transfer，来选择某一款I2C控制器，把数据发送出去，或者从I2c设备读到数据。这种层次分明的架构是作为软件开发人员必备的素养和技能。这里也是借鉴了linux内核I2C子系统的模型。</p>
<h3><span id="4-2-1-i2c-msg-jie-gou-ti">4.2.1 i2c_msg结构体</span><a href="#4-2-1-i2c-msg-jie-gou-ti" class="header-anchor">#</a></h3><p>我们借鉴Linux I2C子系统的数据结构定义。对于每一次传输的数据都可以用一个i2c_msg结构体来表示。但是，读某个地址的数据时，就要用两个i2c_msg结构体来描述它，因为一个i2c_msg结构体只能描述一个传输方向(读&#x2F;写)，我们读取ac24ccxx某个地址上的数据时，要先写出要读取的地址，然后来读取设备地址上的数据。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/26.png" alt="img"></p>
<h3><span id="4-2-2-i2c-test-c">4.2.2 i2c_test.c</span><a href="#4-2-2-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 初始化: 选择I2C控制器 */</span></span><br><span class="line">        <span class="comment">/* 提供菜单供测试 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个菜单会调用到at24cxx.c里面的函数进行i2c外设读写。</p>
<h3><span id="4-2-3-at24cxx-c">4.2.3 at24cxx.c</span><a href="#4-2-3-at24cxx-c" class="header-anchor">#</a></h3><p>定义描述at24cxx外设，并且实现该外设的操作，里面会使用标准的接口i2c_transfer来启动I2C传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24CXX_ADDR 0x50</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buf[<span class="number">0</span>] = addr++;</span><br><span class="line">                buf[<span class="number">1</span>] = data[i];</span><br><span class="line">                <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">                msg.addr  = AT24CXX_ADDR;</span><br><span class="line">                msg.flags = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">                msg.len   = <span class="number">2</span>;</span><br><span class="line">                msg.buf   = buf;</span><br><span class="line">                msg.err   = <span class="number">0</span>;</span><br><span class="line">                msg.cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">                <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">                err = i2c_transfer(&amp;msg, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">at24cxx_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *data, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        i2c_msg msg[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line">        <span class="comment">/* 构造i2c_msg */</span></span><br><span class="line">        msg[<span class="number">0</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">0</span>].flags  = <span class="number">0</span>; <span class="comment">/* write */</span></span><br><span class="line">        msg[<span class="number">0</span>].len   = <span class="number">1</span>;</span><br><span class="line">        msg[<span class="number">0</span>].buf   = &amp;addr;</span><br><span class="line">        msg[<span class="number">0</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">0</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg[<span class="number">1</span>].addr  = AT24CXX_ADDR;</span><br><span class="line">        msg[<span class="number">1</span>].lags  = <span class="number">1</span>; <span class="comment">/* read */</span></span><br><span class="line">        msg[<span class="number">1</span>].len   = len;</span><br><span class="line">        msg[<span class="number">1</span>].buf   = data;</span><br><span class="line">        msg[<span class="number">1</span>].err   = <span class="number">0</span>;</span><br><span class="line">        msg[<span class="number">1</span>].cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/* 调用i2c_transfer */</span></span><br><span class="line">        err = i2c_transfer(&amp;msg, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-4-i2c-controller-h">4.2.4 i2c_controller.h</span><a href="#4-2-4-i2c-controller-h" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> addr;  <span class="comment">/* 7bits */</span></span><br><span class="line">        <span class="type">int</span> flags;  <span class="comment">/* 0 - write, 1 - read */</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">int</span> cnt_transferred;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">&#125;i2c_msg, *p_i2c_msg;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_controller</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> (*<span class="type">int</span>)(<span class="type">void</span>);</span><br><span class="line">        <span class="type">int</span> (*master_xfer)(i2c_msg msgs, <span class="type">int</span> num);</span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">&#125;i2c_controller, *p_i2c_controller;</span><br></pre></td></tr></table></figure>

<p>构造i2c_msg和i2c_controller结构。</p>
<h3><span id="4-2-5-i2c-controller-c">4.2.5 i2c_controller.c</span><a href="#4-2-5-i2c-controller-c" class="header-anchor">#</a></h3><p>实现通用i2c控制器管理，用来注册具体i2c控制器，调用具体控制器去做i2c通信。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I2C_CONTROLLER_NUM 10</span></span><br><span class="line"><span class="comment">/* 有一个i2c_controller数组用来存放各种不同芯片的操作结构体 */</span></span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_controllers[I2C_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_i2c_controller p_i2c_con_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">register_i2c_controller</span><span class="params">(p_i2c_controller *p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!p_i2c_controllers[i]) &#123;</span><br><span class="line">                        p_i2c_controllers[i] = p;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据名字来选择某款I2C控制器 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_i2c_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; I2C_CONTROLLER_NUM; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (p_i2c_controllers[i] &amp;&amp; !<span class="built_in">strcmp</span>(name, p_i2c_controllers[i]-&gt;name))</span><br><span class="line">                &#123;</span><br><span class="line">                        p_i2c_con_selected = p_i2c_controllers[i];</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现 i2c_transfer 接口函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">i2c_transfer</span><span class="params">(i2c_msg msgs, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p_i2c_con_selected-&gt;master_xfer(msgs, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册下面的I2C控制器 */</span></span><br><span class="line">	s3c2440_i2c_con_add();</span><br><span class="line">	<span class="comment">/* 选择某款I2C控制器 */</span></span><br><span class="line">	select_i2c_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line">	<span class="comment">/* 调用它的init函数 */</span></span><br><span class="line">	p_i2c_con_selected-&gt;init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-2-6-s3c2440-i2c-controller-c">4.2.6 s3c2440_i2c_controller.c</span><a href="#4-2-6-s3c2440-i2c-controller-c" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">i2c_interrupt_func</span>(<span class="params"><span class="built_in">int</span> irq</span>)</span> &#123;</span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_init</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* 配置引脚用于I2C*/</span></span><br><span class="line">        GPECON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line">        GPECON |= ((<span class="number">2</span>&lt;&lt;<span class="number">28</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置时钟 */</span></span><br><span class="line">        <span class="comment">/* [7] : IIC-bus acknowledge enable bit, 1-enable in rx mode</span></span><br><span class="line"><span class="comment">         * [6] : 时钟源, 0: IICCLK = fPCLK /16; 1: IICCLK = fPCLK /512</span></span><br><span class="line"><span class="comment">         * [5] : 1-enable interrupt</span></span><br><span class="line"><span class="comment">         * [4] : 读出为1时表示中断发生了, 写入0来清除并恢复I2C操作</span></span><br><span class="line"><span class="comment">         * [3:0] : Tx clock = IICCLK/(IICCON[3:0]+1).</span></span><br><span class="line"><span class="comment">         * Tx Clock = 100khz = 50Mhz/16/(IICCON[3:0]+1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        IICCON = (<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">        register_irq(<span class="number">27</span>, i2c_interrupt_func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_tx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 master tx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* TX mode, 在ACK周期释放SDA */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/*IIC-bus data output enable/disable(1: Enable Rx/Tx)*/</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>;<span class="comment">//[slave addr [7:1], addr[0] is trans dir]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xf0 (启动传输), slave addr数据即被发送出去,当到达第9个clk,无论是否有ack, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xf0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">do_master_rx</span>(<span class="params">p_i2c_msg msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        p_cur_msg = msg;</span><br><span class="line">        msg-&gt;cnt_transferred = <span class="number">-1</span>;</span><br><span class="line">        msg-&gt;err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 设置寄存器启动传输 */</span></span><br><span class="line">        <span class="comment">/* 1. 配置为 Master Rx mode */</span></span><br><span class="line">        IICCON |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* RX mode, 在ACK周期回应ACK */</span></span><br><span class="line">        IICSTAT = (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);  <span class="comment">/*IIC-bus data output enable/disable*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 2. 把从设备地址写入IICDS */</span></span><br><span class="line">        IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 3. IICSTAT = 0xb0 , 从设备地址即被发送出去, 将导致中断产生 */</span></span><br><span class="line">        IICSTAT = <span class="number">0xb0</span>;</span><br><span class="line">        <span class="comment">/* 后续的传输由中断驱动 */</span></span><br><span class="line">        <span class="comment">/* 循环等待中断处理完毕 */</span></span><br><span class="line">        <span class="keyword">while</span> (!msg-&gt;err &amp;&amp; msg-&gt;cnt_transferred != msg-&gt;len);</span><br><span class="line">        <span class="keyword">if</span> (msg-&gt;err)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">s3c2440_master_xfer</span>(<span class="params">p_i2c_msg msgs, <span class="built_in">int</span> num</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">int</span> i;</span><br><span class="line">        <span class="built_in">int</span> err;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)        </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgs[i].flags == <span class="number">0</span>)<span class="comment">/* write */</span></span><br><span class="line">                        err = do_master_tx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        err = do_master_rx(&amp;msgs[i]);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">s3c2440_i2c_con_add</span>(<span class="params"><span class="keyword">void</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        register_i2c_controller(&amp;s3c2440_i2c_con);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> i2c_controller s3c2440_i2c_con = &#123;</span><br><span class="line">        .name = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">        .<span class="keyword">init</span> = s3c2440_i2c_con_init,</span><br><span class="line">        .master_xfer = s3c2440_master_xfer,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>s3c2440_i2c_con_add函数：注册 s3c2440的i2c控制器， 当调用i2c_init就会对选中的这款控制器初始化，也就是调用s3c2440_i2c_con_init。</p>
<p>s3c2440_i2c_con_init函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>).IICCON = (<span class="number">0</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">5</span>) | (<span class="number">30</span>&lt;&lt;<span class="number">0</span>); 设置IICCON控制寄存器。选择发送时钟，使能中断。设置ACK应答使能，bit[<span class="number">7</span>]。</span><br><span class="line"><span class="number">2</span>).register_irq(<span class="number">27</span>, i2c_interrupt_func)：注册中断处理函数，当发生I2C中断的时候就会调用i2c_interrupt_func中断处理函数。</span><br></pre></td></tr></table></figure>

<p>s3c2440_master_xfer函数：</p>
<p>当发起i2c传输时，调用i2c_transfer，进而调用s3c2440_master_xfer进行数据传输。写的话do_master_tx，读的话do_master_rx。</p>
<p>do_master_rx函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IICDS = (msg-&gt;addr&lt;&lt;<span class="number">1</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)：把从设备地址写入IICDS，前<span class="number">7</span>位是从机地址，第<span class="number">8</span>位表示传输方向(<span class="number">0</span>表示写操作，<span class="number">1</span>表示读操作)。</span><br></pre></td></tr></table></figure>

<p>do_master_tx函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> IICDS = msg-&gt;addr&lt;&lt;<span class="number">1</span>: 把从机地址（高<span class="number">7</span>位，所以需要向右移一位）写入到IICDS寄存器中。</span><br><span class="line"><span class="number">2.</span> IICSTAT = <span class="number">0xf0</span>:设置IICSTAT寄存器，将s3c2440设为主机发送器，并发出S信号后，紧接着就发出从机地址。后续的传输工作将在中断服务程序中完成。</span><br></pre></td></tr></table></figure>

<h2><span id="4-3-cheng-xu-kuang-jia-zong-jie">4.3 程序框架总结</span><a href="#4-3-cheng-xu-kuang-jia-zong-jie" class="header-anchor">#</a></h2><p>对应程序框架的4层架构。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-I2C/27.png" alt="img"></p>
<h2><span id="4-4-i2c-zhong-duan-fu-wu-cheng-xu">4.4 I2C中断服务程序</span><a href="#4-4-i2c-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h2><p>Start信号之后，发出设备地址，在第9个时钟就会产生第一个中断，我们根据i2c的流程图来编写中断程序。每传输完一个数据将又产生一个中断，I2C操作的主体在<strong>中断服务程序</strong>，它可以分为两部分：写操作，读操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> p_i2c_msg p_cur_msg;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">isLastData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == p_cur_msg-&gt;len - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">/* 正要开始传输最后一个数据 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_with_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>); <span class="comment">/* 回应ACK */</span></span><br><span class="line">        iiccon &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">/* 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">resume_iic_without_ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon = IICCON;</span><br><span class="line">        iiccon &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">7</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)); <span class="comment">/* 不回应ACK, 恢复IIC操作 */</span></span><br><span class="line">        IICCON =  iiccon;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_interrupt_func</span><span class="params">(<span class="type">int</span> irq)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iicstat = IICSTAT;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> iiccon;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//printf(&quot;i2c_interrupt_func! flags = %d\n\r&quot;, p_cur_msg-&gt;flags);</span></span><br><span class="line"> </span><br><span class="line">        p_cur_msg-&gt;cnt_transferred++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 每传输完一个数据将产生一个中断 */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对于每次传输, 第1个中断是&quot;已经发出了设备地址&quot; */</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (p_cur_msg-&gt;flags == <span class="number">0</span>) &#123;<span class="comment">//write</span></span><br><span class="line">				<span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;  <span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/*iicstat [0] == 1表示no ack*/</span></span><br><span class="line">								<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;tx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						<span class="comment">/* 对于其他中断, 要继续发送下一个数据</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">						IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred];</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//clear pending bit</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 停止传输 */</span></span><br><span class="line">						IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//read</span></span><br><span class="line">                <span class="comment">/* 对于第1个中断, 它是发送出设备地址后产生的</span></span><br><span class="line"><span class="comment">                 * 需要判断是否有ACK</span></span><br><span class="line"><span class="comment">                 * 有ACK : 设备存在, 恢复I2C传输, 这样在下一个中断才可以得到第1个数据</span></span><br><span class="line"><span class="comment">                 * 无ACK : 无设备, 出错, 直接结束传输</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred == <span class="number">0</span>) &#123;<span class="comment">/* 第1次中断 */</span></span><br><span class="line">                        <span class="keyword">if</span> (iicstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &#123;<span class="comment">/* no ack */</span></span><br><span class="line">                                <span class="comment">/* 停止传输 */</span></span><br><span class="line">                                IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">                                IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>); <span class="comment">//clear pending bit</span></span><br><span class="line">                                p_cur_msg-&gt;err = <span class="number">-1</span>;</span><br><span class="line">                                <span class="built_in">printf</span>(<span class="string">&quot;rx err, no ack\n\r&quot;</span>);</span><br><span class="line">                                delay(<span class="number">1000</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ack */</span></span><br><span class="line">                                <span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">                                <span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">                                <span class="keyword">if</span> (isLastData())</span><br><span class="line">                                        resume_iic_without_ack();</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        resume_iic_with_ack();</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">				<span class="comment">/* 非第1个中断, 表示得到了一个新数据</span></span><br><span class="line"><span class="comment">				 * 从IICDS读出、保存</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">if</span> (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len) &#123;</span><br><span class="line">						index = p_cur_msg-&gt;cnt_transferred - <span class="number">1</span>;</span><br><span class="line">						p_cur_msg-&gt;buf[index] = IICDS;</span><br><span class="line">		 </span><br><span class="line">						<span class="comment">/* 如果是最后一个数据, 启动传输时要设置为不回应ACK */</span></span><br><span class="line">						<span class="comment">/* 恢复I2C传输 */</span></span><br><span class="line">						<span class="keyword">if</span> (isLastData())</span><br><span class="line">								resume_iic_without_ack();</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">								resume_iic_with_ack();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">/* 发出停止信号 */</span></span><br><span class="line">						IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">						IICCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">						delay(<span class="number">1000</span>);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-1-xie-cao-zuo">4.4.1 写操作</span><a href="#4-4-1-xie-cao-zuo" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. p_cur_msg-&gt;cnt_transferred初始值为-1(do_master_tx启动时设置)。</span><br><span class="line">2. p_cur_msg-&gt;cnt_transferred == 0表示是第一次传输数据完后产生的中断，即发送从设备地址产生的中断。</span><br><span class="line">3. iicstat &amp; (1&lt;&lt;0)表示主机没有接受到ACK信号(即发出的设备地址不存在)，需要停止传输。</span><br><span class="line">4. IICSTAT = 0xd0置IICSTAT寄存器的[5]写为0，产生P信号。但是由于这时IICCON[4]仍为1，P信号没有实际发出，当执行IICCON &amp;= ~(1&lt;&lt;4);清除IICCON[4]后，P信号才真正发出。</span><br><span class="line">5. 等待一段时间，确保P信号已经发送完毕。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">1).假如if (p_cur_msg-&gt;cnt_transferred &lt; p_cur_msg-&gt;len)条件成立，表示数据还没有发送完毕，需要继续发送数据。</span><br><span class="line">2).执行IICDS = p_cur_msg-&gt;buf[p_cur_msg-&gt;cnt_transferred]把要发送的数据写入到IICDS寄存器中，经过执行IICCON &amp;= ~(1&lt;&lt;4);清除中断标志后后，紧接着就自动把数据发送出去了，这将触发下一个中断。</span><br><span class="line">3).如果条件不成立表示数据传输完毕，发出P信号，停止数据的传输。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-du-cao-zuo">4.4.2 读操作</span><a href="#4-4-2-du-cao-zuo" class="header-anchor">#</a></h3><p>见注释。</p>
<h2><span id="4-5-ce-shi">4.5 测试</span><a href="#4-5-ce-shi" class="header-anchor">#</a></h2><h3><span id="4-5-1-i2c-test-c">4.5.1 i2c_test.c</span><a href="#4-5-1-i2c-test-c" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">    gets(str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">    err = at24cxx_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_write ret = %d\n\r&quot;</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_at24cxx</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">100</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获得地址 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">    addr = get_uint();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addr &gt; <span class="number">256</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;address &gt; 256, error!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得长度 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter the length to read: &quot;</span>);</span><br><span class="line">    len = get_int();</span><br><span class="line"></span><br><span class="line">    err = at24cxx_read(addr, data, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at24cxx_read ret = %d\n\r&quot;</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">    <span class="comment">/* 长度固定为64 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            <span class="comment">/* 先打印数值 */</span></span><br><span class="line">            c = data[cnt++];</span><br><span class="line">            str[j] = c;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    i2c_init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/* 打印菜单, 供我们选择测试内容 */</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[w] Write at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[r] Read at24cxx\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;[q] quit\n\r&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Enter selection: &quot;</span>);</span><br><span class="line"></span><br><span class="line">            c = getchar();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c\n\r&quot;</span>, c);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/* 测试内容:</span></span><br><span class="line"><span class="comment">             * 3. 编写某个地址</span></span><br><span class="line"><span class="comment">             * 4. 读某个地址</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                    do_write_at24cxx();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">				<span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">					do_read_at24cxx();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-LDC</title>
    <url>/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-lcd-ying-jian-yuan-li">1 LCD硬件原理</a><ul>
<li><a href="#1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</a></li>
<li><a href="#1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</a><ul>
<li><a href="#1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</a></li>
<li><a href="#1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</a><ul>
<li><a href="#1-2-2-1-xing-shi-xu">1.2.2.1 行时序</a></li>
<li><a href="#1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</a></li>
<li><a href="#1-3-lcd-chong-lei">1.3 LCD种类</a></li>
<li><a href="#1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</a></li>
</ul>
</li>
<li><a href="#2-lcd-kong-zhi-qi">2 LCD控制器</a><ul>
<li><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</a></li>
<li><a href="#2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</a><ul>
<li><a href="#2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</a><ul>
<li><a href="#2-2-1-1-bswp-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</a><ul>
<li><a href="#2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</a></li>
<li><a href="#2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</a></li>
<li><a href="#2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</a><ul>
<li><a href="#2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</a></li>
</ul>
</li>
<li><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</a></li>
<li><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</a></li>
<li><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</a></li>
<li><a href="#2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</a></li>
<li><a href="#2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</a><ul>
<li><a href="#3-1-ruan-jian-kuang-jia">3.1 软件框架</a></li>
<li><a href="#3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</a><ul>
<li><a href="#3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</a></li>
</ul>
</li>
<li><a href="#3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</a><ul>
<li><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1 LCD操作方法-lcd_controller.c</a></li>
<li><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</a></li>
</ul>
</li>
<li><a href="#3-4-lcd-chu-shi-hua">3.4 LCD初始化</a><ul>
<li><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</a><ul>
<li><a href="#3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</a><ul>
<li><a href="#3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</a></li>
<li><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</a></li>
<li><a href="#3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</a></li>
</ul>
</li>
<li><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</a></li>
<li><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</a></li>
</ul>
</li>
<li><a href="#3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</a></li>
</ul>
</li>
<li><a href="#3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</a><ul>
<li><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</a><ul>
<li><a href="#3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</a></li>
<li><a href="#3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</a></li>
<li><a href="#3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</a></li>
<li><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</a><ul>
<li><a href="#3-6-1-hua-dian">3.6.1 画点</a></li>
<li><a href="#3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</a></li>
<li><a href="#3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</a></li>
<li><a href="#3-6-4-ce-shi">3.6.4 测试</a></li>
</ul>
</li>
<li><a href="#3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</a><ul>
<li><a href="#3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-lcd-ying-jian-yuan-li">1 LCD硬件原理</span><a href="#1-lcd-ying-jian-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-lcd-xiang-su-sao-miao">1.1 LCD像素扫描</span><a href="#1-1-lcd-xiang-su-sao-miao" class="header-anchor">#</a></h2><p>里面的每个点就是一个像素点。</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/1.jpg"></p>
<p>它里面有一个电子枪，一边移动，一边发出各种颜色的光。用动态图表示如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/2.jpg"></p>
<ol>
<li><p>电子枪是如何移动的？</p>
<pre><code> 有一条CLK时钟线与LCD相连，每发出一次CLK(高低电平)，电子枪就移动一个像素。
</code></pre>
</li>
<li><p>颜色如何确定？</p>
<pre><code> 由连接LCD的三组线RGB三原色混合而成：R(Red)、G(Green)、B(Blue)确定。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到下一行？</p>
<pre><code> 有一条HSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到下一行，该信号叫做行同步信号。
</code></pre>
</li>
<li><p>电子枪如何得知应跳到原点？</p>
<pre><code> 有一条VSYNC信号线与LCD相连，每发出一次脉冲(高低电平)，电子枪就跳到原点，该信号叫做帧同步信号。
</code></pre>
</li>
<li><p>RGB线上的数据从何而来？</p>
<pre><code> 内存里面划分一块显存(FrameBuffer)，里面存放了要显示的数据，LCD控制器从里面将数据读出来，通过RGB三组线传给电子枪，电子枪再依次打到显示屏上。
</code></pre>
</li>
<li><p>前面的信号由谁发给LCD？</p>
<pre><code> 有S3C2440里面的LCD控制器来控制发出信号。
</code></pre>
</li>
</ol>
<h2><span id="1-2-lcd-ying-jian-yuan-li-tu">1.2 LCD硬件原理图</span><a href="#1-2-lcd-ying-jian-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/3.png"></p>
<p>①是时钟信号，每来一个CLK，电子枪就移动一个像素；</p>
<p>②是用来传输颜色数据；</p>
<p>③是垂直方向同步信号，FRAME(帧)；</p>
<p>④是水平方向同步信号，LINE(行)；</p>
<p>⑤LED+、LED-背光灯电源。</p>
<p>⑥TSYP、TSXP、TSYM、TSXM是触摸屏信号，暂时不用。</p>
<p>⑦VM接DE是数据使能</p>
<h3><span id="1-2-1-rgb-lcd-mo-shi">1.2.1 RGB LCD模式</span><a href="#1-2-1-rgb-lcd-mo-shi" class="header-anchor">#</a></h3><p>HV模式: HS与VS来控制刷新。比如对于分辨率为1024x600RGB的LCD，LCD控制器发出HS信号后，就会发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个HS信号后，就会发出一个VS信号<br>DE模式：DE信号来控制刷新，比如对于分辨率为1024x600RGB的LCD，LCD控制器发出DE信号后，就要发出1024个DCLK，在每个DCLK上传输像素数据；当发出600个DE信号，刷新完一帧数据</p>
<h3><span id="1-2-2-lcd-shi-xu-fen-xi">1.2.2 LCD时序分析</span><a href="#1-2-2-lcd-shi-xu-fen-xi" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/4.png" alt="image"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/5.png"></p>
<p>①从一行最开始的像素开始分析，如上图标号①，DE信号开始有效，电子枪每次在CLK下降沿时从数据线Dn0-Dn7上得到数据（Dn0-Dn7上的数据来源于FrameBuffer，后面会讲），然后发射到显示屏上，然后移动到下一个位置。从<em>1 st pixel</em>到<em>last pixel</em>，就这样从一行的最左边，一直移动到一行的最右边，完成了一行的显示，假设一行有x个pixel。可以看到每发送一个pixel，需要1个时钟周期（1&#x2F;tc）。</p>
<p>②当打完一行的最后一个数据后，会收到Hsync行同步信号，那么电子枪会跳到下一行，如上图标号②，根据时序图，一个Hsync周期，也就是一行数据刷新时间th, 可以大致分为五部分组成：thp、thb、1&#x2F;tc、thd、thf。<br>    thp:称为脉冲宽度，这个时间不能太短，太短电子枪可能识别不到。<br>    thb:电子枪正确识别到thp后，会从最右端移动最左端，这个移动的时间就是thb，称之为移动时间。<br>    thd：表示显示一行数据的时间<br>    thf：表示显示完最右像素，再过多久Hsync才来。</p>
<p>③同理，当电子枪移动到最后一行时，就会发送一个Vsync垂直同步信号，让电子枪移动回最上边。如上图标号③，根据时序图，一个Vsync周期，也就是一帧数据刷新时间tv, 可以大致分为：tvp、tvb、tvd、tvf。<br>    tvp:Vsync信号的脉冲宽度<br>    tvb：电子枪从最后一行移动到第一行的移动时间<br>    tvf：表示显示完最后一行像素，再过多久Vsync才来。</p>
<p> 假设一共有y行，那么LCD的分辨率就是x*y。</p>
<p>下面是LCD显示配置示意图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/6.png"></p>
<p>从左往右看，可以看到Total width &#x3D; HSYNC width + HBP + Active width + HFP。当发出一个HSYNC信号后，电子枪就会从最右边花费HBP时长移动到最左边，等到了最右边后，等待HFP时长后下一轮HSYNC信号才会发出。因此，HBP和HFP分别决定了左边和右边的黑框。</p>
<pre><code> HSYNC是行同步信号的脉冲宽度（低电平有效）
 HBP表示屏幕左边黑框的宽度（电子枪要花多久才能从最右边移动到最左边）行后肩
 Active width表示有效数据宽度
 HFP表示屏幕右边黑框的宽度（再过多久HSYNC才会发出）行前肩
</code></pre>
<p>同理从上往下看，Total height &#x3D; Vsync width + VBP + Active width + VFP。当发出一个VSYNC信号后，电子枪就会从最下边花费VBP时长移动到最上边，等到了最下边后，等待VFP时长后下一轮VSYNC信号才会发出。因此，VBP和VFP分别决定了上边和下边的黑框。 中间灰色区域才是有效显示区域。</p>
<pre><code>VSYNC是帧同步信号的脉冲宽度（低电平有效）
VBP表示屏幕上边黑框的宽度（电子枪要花多久才能从最后一行移动到最上面一行）帧后肩
Active height表示有效数据高度
VFP表示屏幕下边黑框的宽度(再过多久VSYNC才会发出) 帧前肩
</code></pre>
<p>总结：</p>
<h4><span id="1-2-2-1-xing-shi-xu">1.2.2.1 行时序</span><a href="#1-2-2-1-xing-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/7.png" alt="image"></p>
<pre><code>HSPW：有些地方也叫做 thp，是 HSYNC 信号宽度，也就是 HSYNC 信号持续时间。HSYNC信号不是一个脉冲，而是需要持续一段时间才是有效的，单位为 CLK。
HOZVAL：有些地方叫做 thd，显示一行数据所需的时间，假如屏幕分辨率为 1024*600，那么 HOZVAL 就是 1024，单位为 CLK。
</code></pre>
<h4><span id="1-2-2-2-zheng-shi-xu">1.2.2.2 帧时序</span><a href="#1-2-2-2-zheng-shi-xu" class="header-anchor">#</a></h4><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/8.png" alt="image"></p>
<pre><code>VSPW：有些地方也叫做 tvp，是 VSYNC 信号宽度，也就是 VSYNC 信号持续时间，单位为 1 行的时间
LINE：有些地方叫做 tvd，显示一帧有效数据所需的时间，假如屏幕分辨率为 1024*600，那么 LINE 就是 600 行的时间。
</code></pre>
<h2><span id="1-2-framebuffer-he-bpp-gai-nian">1.2 FrameBuffer和BPP概念</span><a href="#1-2-framebuffer-he-bpp-gai-nian" class="header-anchor">#</a></h2><p>FrameBuffer是在内存中的一段区域，这段区域专门用来存放颜色数据的。如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/9.png"></p>
<p>BPP(Bits Per Pixels)表示每个像素占据多少位。 前面的LCD引脚功能图里，有R0-R7、G0-G7、B0-B7，那么每个像素是占据3<em>8&#x3D;24位的，*<em>所以硬件上LCD的BPP是确定的.</em></em></p>
<p>那么在FrameBuffer中，每个像素在FrameBuffer中，占据多少位BPP(Bits Per Pixels)？</p>
<p>虽然LCD上的引脚是固定的，但我们使用的时候，可以根据实际情况进行取舍，查看我们的硬件原理图，发现我们的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以每个像素就只占据16位数据。等效连接图如下：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/10.png"></p>
<h2><span id="1-3-lcd-chong-lei">1.3 LCD种类</span><a href="#1-3-lcd-chong-lei" class="header-anchor">#</a></h2><p>S3C2440芯片手册介绍了LCD控制器支持TFT和STN两种LCD，我们常用的都是TFT材质的，本开发板采用的就是一款TFT材质的LCD.</p>
<h2><span id="1-4-lcd-fang-wen-kuang-jia">1.4 LCD访问框架</span><a href="#1-4-lcd-fang-wen-kuang-jia" class="header-anchor">#</a></h2><p>如下图，LCD控制器从SDRAM中的FrameBuffer区域取出颜色数据，发送给电子枪，电子枪按照特定的时钟周期将颜色数据显示在LCD上。<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/11.png"></p>
<h1><span id="2-lcd-kong-zhi-qi">2 LCD控制器</span><a href="#2-lcd-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu">2.1 s3c2440 LCD控制器框图</span><a href="#2-1-s3c2440-lcd-kong-zhi-qi-kuang-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/12.png"></p>
<p>S3C2440 LCD控制器用于传输视频数据并且生成必要的控制信号，如VFRAME，VLINE，VCLK，VM等。除了控制信号，S3C2440还有视频数据端口，即VD [23：0]。通过设置REGBANK(寄存器组)，LCDCDMA会自动(无需CPU参与)把内存上FrameBuffer里的数据，通过VIDPRCS发送到引脚VD[23:0]数据总线上，再配合VIDEOMUX引脚的控制信号，正确的显示出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REGBANK：具有<span class="number">17</span>个可编程寄存器组和<span class="number">256</span>x16调色板存储器，用于配置LCD控制器。 </span><br><span class="line">TIMEGEN：产生控制信号，例如 VSYNC、HSYNC、VCLK等信号</span><br><span class="line">LCDCDMA：可以自动从FrameBuff中把数据copy出来。</span><br><span class="line">VIDPRCS：从LCDCDMA接收视频数据，将数据输出到VD[<span class="number">23</span>:<span class="number">0</span>]数据总线上。</span><br></pre></td></tr></table></figure>

<p>总结LCD控制器主要功能如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 取：从内存(FrameBuffer)取出某个像素的数据（之后需要把FrameBuffer地址、BPP、分辨率告诉LCD控制器）</span><br><span class="line"><span class="number">2.</span> 发：配合其它信号把FrameBuffer中的数据发给LCD；（那么需要设置LCD控制器时序、设置引脚极性）</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-ji-cun-qi-jie-shao">2.2 寄存器介绍</span><a href="#2-2-ji-cun-qi-jie-shao" class="header-anchor">#</a></h2><h3><span id="2-2-1-shu-ju-cun-chu-ge-shi">2.2.1 数据存储格式</span><a href="#2-2-1-shu-ju-cun-chu-ge-shi" class="header-anchor">#</a></h3><p>可以配置寄存器的BSWP、HWSWP来设置Framebuff中的像素存储格式。</p>
<h4><span id="2-2-1-1-bswp-x2f-hwswp-ji-cun-qi">2.2.1.1 BSWP&#x2F;HWSWP寄存器</span><a href="#2-2-1-1-bswp-x2f-hwswp-ji-cun-qi" class="header-anchor">#</a></h4><h5><span id="2-2-2-1-1-24bpp">2.2.2.1.1 24BPP</span><a href="#2-2-2-1-1-24bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/13.png"></p>
<p>从图中可以看到24bpp的像素，在lcd控制器的VD[7:0]表示BLUE， VD[15:8]表示GREEN，VD[23:16]表示RED。在内存中的FrameBuffer中每一个像素占据4个字节，当BPP24BL&#x3D;0时，低24位为颜色数据，当BPP24BL&#x3D;1时，高24位为颜色数据。</p>
<h5><span id="2-2-2-1-2-16bpp">2.2.2.1.2 16BPP</span><a href="#2-2-2-1-2-16bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/14.png"></p>
<p>也可以看到16bpp的像素，在内存中的FrameBuffer中每一个像素占据2个字节，HWSWP用来设置像素数据的存放方式。</p>
<p>再看下LCD控制器的VD引脚输出情况，可以看到16bpp时分5:6:5和5：5：5：i两种数据格式。当5：6：5模式时，VD[7:3]表示BLUE， VD[15:10]表示Green数据，VD[23:19]表示RED。当5：5:5：i模式时，VD[7:3]表示BLUE， VD[15:11]表示Green，VD[23:19]表示RED。其中i表示透明度。</p>
<h5><span id="2-2-2-1-3-8bpp">2.2.2.1.3 8BPP</span><a href="#2-2-2-1-3-8bpp" class="header-anchor">#</a></h5><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/15.png"></p>
<h3><span id="2-2-2-diao-se-ban-ji-cun-qi">2.2.2 调色板寄存器</span><a href="#2-2-2-diao-se-ban-ji-cun-qi" class="header-anchor">#</a></h3><p>我们外接的LCD硬件上只有R1-R5、G0-G5、B1-B5与SOC相连，5+6+5&#x3D;16BPP，所以LCD上每个像素就只占据16位数据。那么当我们的Frame buffer中是8BPP颜色数据时，是如何把颜色数据填充到LCD上的呢？</p>
<p><code>用调色板</code></p>
<p>S3C2440A 中的 TFT LCD 控制器支持 1、2、4 或 8bpp调色显示（伪彩色）和16、24bpp无调色显示（真彩色）。S3C2440A 可以支持 256 色调色板给各种色彩映射的选择，以提供灵活操作给用户。</p>
<p>假如是16BPP的数据，LCD控制器从FB取出16bit数据，显示到LCD上，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/16.png"></p>
<p>那么当8BPP的数据时，就需要用到调色板，调色板里存放了256个16bit的数据，FB(frame buffer)只存放每个像素的索引，根据索引去调色板找到对应的数据传给LCD控制器，比如从FB中的第0个元素拿到调色板中的第0个16bit数据，再通过电子枪显示出来，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/17.png"></p>
<p>调色板支持 5:6:5（R:G:B）格式和 5:5:5:I（R:G:B:I）格式。当用户使用5:5:5:I格式时，I表示强度，也就是透明度。I是用作每个RGB 数据的共用 LSB 位，因此 5:5:5:I与R(5+I):G(5+I):B(5+I)格式相同。</p>
<h4><span id="2-2-2-1-diao-se-ban-ge-shi">2.2.2.1 调色板格式</span><a href="#2-2-2-1-diao-se-ban-ge-shi" class="header-anchor">#</a></h4><p>0x4D000400为调色板起始地址:</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/18.png"></p>
<h3><span id="2-2-3-lcd-kong-zhi-ji-cun-qi-1">2.2.3 LCD控制寄存器1</span><a href="#2-2-3-lcd-kong-zhi-ji-cun-qi-1" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/19.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">27</span>:<span class="number">18</span>]为只读数据位，不需要设置；</span><br><span class="line">[<span class="number">17</span>:<span class="number">8</span>]设置CLKVAL(像素时钟频率)，我们使用的是TFT屏，因此采用的公式是VCLK = HCLK / [(CLKVAL+<span class="number">1</span>) x <span class="number">2</span>]，其中HCLK为<span class="number">100</span>M。LCD手册里面Clock cycle的要求范围为<span class="number">5</span><span class="number">-12</span>MHz即可，那么取VCLK=<span class="number">9</span>，根据公式<span class="number">9</span>=<span class="number">100</span>/[(CLKVAL+<span class="number">1</span>)x2],算出CLKVAL≈<span class="number">4.5</span>=<span class="number">5</span>，设置CLKVAL=<span class="number">5</span>。</span><br><span class="line">[<span class="number">7</span>]不用管，默认即可；</span><br><span class="line">[<span class="number">6</span>:<span class="number">5</span>]TFT lcd配置为<span class="number">0b11</span>；</span><br><span class="line">[<span class="number">4</span>:<span class="number">1</span>]设置bpp模式，用户可选</span><br><span class="line">[<span class="number">0</span>]LCD输出使能，先暂时关闭不输出；</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu">2.2.4 LCD控制寄存器2(垂直方向参数)</span><a href="#2-2-4-lcd-kong-zhi-ji-cun-qi-2-chui-zhi-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/20.png"></p>
<p>s3c2440 LCD控制器时序图如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/21.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">31</span>:<span class="number">24</span>] : VBPD = tvb - <span class="number">1</span> （表示显示完最后一行像素，再过多久Vsync才来，表示上边黑框）</span><br><span class="line">[<span class="number">23</span>:<span class="number">14</span>] : LINEVAL = 每帧有多少行 - <span class="number">1</span> </span><br><span class="line">[<span class="number">13</span>:<span class="number">6</span>]  : VFPD = tvf - <span class="number">1</span>（下边黑框）</span><br><span class="line">[<span class="number">5</span>:<span class="number">0</span>]  : VSPW = tvp - <span class="number">1</span> （Vsync信号的脉冲宽度）</span><br></pre></td></tr></table></figure>



<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu">2.2.5 LCD控制寄存器3(水平方向参数)</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-3-shui-ping-fang-xiang-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/22.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">25</span>:<span class="number">19</span>] : HBPD = thb - <span class="number">1</span>（左边黑框）</span><br><span class="line">[<span class="number">18</span>:<span class="number">8</span>]  : HOZVAL = 每行有多少列 - <span class="number">1</span></span><br><span class="line">[<span class="number">7</span>:<span class="number">0</span>]  : HFPD = thf - <span class="number">1</span> （右边黑框）</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-4">2.2.5 LCD控制寄存器4</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-4" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/23.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">7</span>:<span class="number">0</span>]: HSPW = thp - <span class="number">1</span> (Hsync信号的脉冲宽度)</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-5-lcd-kong-zhi-ji-cun-qi-5">2.2.5 LCD控制寄存器5</span><a href="#2-2-5-lcd-kong-zhi-ji-cun-qi-5" class="header-anchor">#</a></h3><p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/24.png"></p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">12</span>] : BPP24BL（表示<span class="number">24b</span>pp的数据是大端还是小端）</span><br><span class="line">[<span class="number">11</span>] : FRM565 （数据存放格式）</span><br><span class="line">[<span class="number">10</span>] : INVVCLK（时钟是否反转极性，当配置成<span class="number">0</span>时数据在时钟下降沿被锁存）</span><br><span class="line">[<span class="number">9</span>]  : HSYNC是否反转</span><br><span class="line">[<span class="number">8</span>]  : VSYNC是否反转</span><br><span class="line">[<span class="number">7</span>]  : INVVD, rgb是否反转</span><br><span class="line">[<span class="number">6</span>]  : INVVDEN</span><br><span class="line">[<span class="number">5</span>]  : INVPWREN</span><br><span class="line">[<span class="number">4</span>]  : INVLEND</span><br><span class="line">[<span class="number">3</span>]  : PWREN(LCD_PWREN output signal enable/disable)</span><br><span class="line">[<span class="number">2</span>]  : ENLEND</span><br><span class="line">[<span class="number">1</span>]  : BSWP</span><br><span class="line">[<span class="number">0</span>]  : HWSWP</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-6-lcdsaddr1-ji-cun-qi">2.2.6 LCDSADDR1寄存器</span><a href="#2-2-6-lcdsaddr1-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的起始地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/26.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">29</span>:<span class="number">21</span>] : LCDBANK, A[<span class="number">30</span>:<span class="number">22</span>] of fb</span><br><span class="line">[<span class="number">20</span>:<span class="number">0</span>]  : LCDBASEU, A[<span class="number">21</span>:<span class="number">1</span>] of fb</span><br><span class="line">即[<span class="number">29</span>:<span class="number">0</span>]表示Frame buffer的起始地址的[<span class="number">30</span>:<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-7-lcdsaddr2-ji-cun-qi">2.2.7 LCDSADDR2寄存器</span><a href="#2-2-7-lcdsaddr2-ji-cun-qi" class="header-anchor">#</a></h3><p>frame buffer的结束地址寄存器：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/27.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[<span class="number">20</span>:<span class="number">0</span>] : LCDBASEL，A[<span class="number">21</span>:<span class="number">1</span>] of end addr,即framebuffer的结束地址。</span><br></pre></td></tr></table></figure>

<h1><span id="3-lcd-luo-ji-bian-cheng">3 LCD裸机编程</span><a href="#3-lcd-luo-ji-bian-cheng" class="header-anchor">#</a></h1><h2><span id="3-1-ruan-jian-kuang-jia">3.1 软件框架</span><a href="#3-1-ruan-jian-kuang-jia" class="header-anchor">#</a></h2><p>为了让程序更加好扩展，体现出<strong>高内聚、低耦合</strong>的特点，能够兼容各种不同型号的lcd，假如有两款尺寸大小的lcd，如何快速的在两个lcd上切换？</p>
<p>首先我们抽象出lcd_3.5.c和lcd_4.3.c的共同点，比如都有初始化函数init(),我们可以新建一个lcd.c，然后定义一个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_opr</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> (*init)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用户不接触lcd_3.5.c和lcd_4.3.c，只需要在lcd.c里通过指针访问对应的结构体的函数，也就调用了不同init():</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/28.jpg" alt="img"></p>
<p>我们的目的是在LCD显示屏上画线、画圆(geomentry.c)和写字(font.c)其核心是画点(farmebuffer.c)，这些都属于纯软件。此外还需要一个lcd_test.c测试程序提供操作菜单，调用画线、画圆和写字操作。</p>
<p>往下操作的是LCD相关的内容，不同的LCD，其配置的参数也会不一样，通过lcd_3.5.c或lcd_4.3.c来设置属性参数。</p>
<p>根据LCD的特性，来设置LCD控制器，首先编写lcd_controller.c，它向上要接收不同LCD的参数，向下要使用这些参数设置对应具体的某一款LCD控制器。</p>
<p>对于我们开发板，就是s3c2440_lcd_controller.c，假如希望在其它开发板上也实现LCD显示，只需添加相应的代码文件即可。文件自上而下的框架如下：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/29.jpg"></p>
<h2><span id="3-2-shu-ju-jie-gou-ding-yi">3.2 数据结构定义</span><a href="#3-2-shu-ju-jie-gou-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-2-1-lcd-she-bei-jie-gou-ti">3.2.1 LCD设备结构体</span><a href="#3-2-1-lcd-she-bei-jie-gou-ti" class="header-anchor">#</a></h3><p>我们知道LCD的参数属性有：引脚的极性、时序、数据的格式bpp、分辨率等，使用面向对象的思维方式，将这些封装成结构体放在lcd.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	NORMAL = <span class="number">0</span>,</span><br><span class="line">	INVERT = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NORMAL : 正常极性</span></span><br><span class="line"><span class="comment"> * INVERT : 反转极性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pins_polarity</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> vclk;  <span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">	<span class="type">int</span> rgb;   <span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">	<span class="type">int</span> hsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	<span class="type">int</span> vsync; <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">&#125; pins_polarity, *p_pins_polarity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">time_sequence</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 垂直方向 */</span></span><br><span class="line">	<span class="type">int</span> tvp; <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> tvb; <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">	<span class="type">int</span> tvf; <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line">	<span class="comment">/* 水平方向 */</span></span><br><span class="line">	<span class="type">int</span> thp; <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">	<span class="type">int</span> thb; <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">	<span class="type">int</span> thf; <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line">	<span class="type">int</span> vclk;</span><br><span class="line">&#125; time_sequence, *p_time_sequence;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_params</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 引脚极性 */</span></span><br><span class="line">	pins_polarity pins_pol;</span><br><span class="line">	<span class="comment">/* 时序 */</span></span><br><span class="line">	time_sequence time_seq;</span><br><span class="line">	<span class="comment">/* 分辨率, bpp */</span></span><br><span class="line">	<span class="type">int</span> xres;</span><br><span class="line">	<span class="type">int</span> yres;</span><br><span class="line">	<span class="type">int</span> bpp;</span><br><span class="line">	<span class="comment">/* framebuffer的地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line">&#125; lcd_params, *p_lcd_params;</span><br></pre></td></tr></table></figure>

<h2><span id="3-3-cao-zuo-fang-fa-ding-yi">3.3 操作方法定义</span><a href="#3-3-cao-zuo-fang-fa-ding-yi" class="header-anchor">#</a></h2><h3><span id="3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c">3.3.1  LCD操作方法-lcd_controller.c</span><a href="#3-3-1-lcd-cao-zuo-fang-fa-lcd-controller-c" class="header-anchor">#</a></h3><p>我们知道在c++中是面向对象编程的，那么一个对象就有它的属性和方法，LCD属性我们上面已经定义好了，那么方法我们可以定义一个lcd_controller.c用来控制管理LCD，定义个一个lcd_controller.h, struct lcd_controller结构体放置lcd对象的一些成员函数，即对象的方法，或者称之为对象的行为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> (*init)(p_lcd_params plcdparams);</span><br><span class="line">    <span class="type">void</span> (*enable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*disable)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*init_palette)(<span class="type">void</span>);</span><br><span class="line">&#125; lcd_controller, *p_lcd_controller;</span><br></pre></td></tr></table></figure>
<p>那么lcd_controller.c相当于一个管理者，会去选择具体型号的LCD对象去执行具体的成员函数，比如管理s3c2440_lcd_controller.c，它向上接受传入的LCD参数，向下传给具体的LCD控制器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">    <span class="comment">/* 调用2440的LCD控制器的初始化函数，lcd_controller是一个被选中的对象，即s3c2440_lcd_controller*/</span></span><br><span class="line">    lcd_controller.init(plcdparams);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样在s3c2440_lcd_controller.c再构造一个具体的lcd对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = xxx,</span><br><span class="line">	.init    = xxx,</span><br><span class="line">	.enalbe  = xxx,</span><br><span class="line">	.disable = xxx,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>lcd_controller.c代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lcd_controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CONTROLLER_NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> p_lcd_controller p_array_lcd_controller[LCD_CONTROLLER_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_controller g_p_lcd_controller_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd_controller</span><span class="params">(p_lcd_controller plcdcon)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd_controller[i]) &#123;</span><br><span class="line">			p_array_lcd_controller[i] = plcdcon;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd_controller</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_CONTROLLER_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd_controller[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd_controller[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_controller_selected = p_array_lcd_controller[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向上: 接收不同LCD的参数</span></span><br><span class="line"><span class="comment"> * 向下: 使用这些参数设置对应的LCD控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* 调用所选择的LCD控制器的初始化函数 */</span></span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected) &#123;</span><br><span class="line">		g_p_lcd_controller_selected-&gt;init(plcdparams);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (g_p_lcd_controller_selected)</span><br><span class="line">		g_p_lcd_controller_selected-&gt;disable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面详细分析lcd_controller.c框架的含义以及作用：</p>
<ol>
<li>开始定义了一个p_array_lcd_controller数组和g_p_lcd_controller_selected，p_array_lcd_controller数组表示lcd控制器的集合，g_p_lcd_controller_selected表示被选中的那一个lcd_controller;</li>
<li>当我们初始化时要先调用register_lcd_controller，select_lcd_controller选中具体的lcd_controller；</li>
<li>然后才能调用lcd_controller_init初始化具体的lcd_controller，去控制具体型号的lcd。</li>
</ol>
<p>同理，也通过lcd.c去管理lcd_4.3.c,思路如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a. 有一个数组存放各类lcd的参数；</span><br><span class="line">b. 有一个register_lcd给下面的lcd程序来设置数组；</span><br><span class="line">c. 有一个select_lcd，供上层选择某款LCD；</span><br></pre></td></tr></table></figure>
<h3><span id="3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c">3.3.2 具体型号LCD管理-ldc.c</span><a href="#3-3-2-ju-ti-xing-hao-lcd-guan-li-ldc-c" class="header-anchor">#</a></h3><p>参考前面的lcd_controller.c编辑lcd.c如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_NUM 10</span></span><br><span class="line"><span class="type">static</span> p_lcd_params p_array_lcd[LCD_NUM];</span><br><span class="line"><span class="type">static</span> p_lcd_params g_p_lcd_selected;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">register_lcd</span><span class="params">(p_lcd_params plcd)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!p_array_lcd[i]) &#123;</span><br><span class="line">			p_array_lcd[i] = plcd;</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select_lcd</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LCD_NUM; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p_array_lcd[i] &amp;&amp; !<span class="built_in">strcmp</span>(p_array_lcd[i]-&gt;name, name)) &#123;</span><br><span class="line">			g_p_lcd_selected = p_array_lcd[i];</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="3-4-lcd-chu-shi-hua">3.4 LCD初始化</span><a href="#3-4-lcd-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="3-4-1-chu-shi-hua-lcd-kong-zhi-qi">3.4.1 初始化lcd控制器</span><a href="#3-4-1-chu-shi-hua-lcd-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="3-4-1-1-chu-shi-hua-yin-jiao">3.4.1.1 初始化引脚</span><a href="#3-4-1-1-chu-shi-hua-yin-jiao" class="header-anchor">#</a></h4><h5><span id="3-4-1-1-1-bei-guang-yin-jiao">3.4.1.1.1 背光引脚</span><a href="#3-4-1-1-1-bei-guang-yin-jiao" class="header-anchor">#</a></h5><p>我们配置LCD的背光引脚成输出模式：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/30.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPBCON &amp;= ~<span class="number">0x3</span>;</span><br><span class="line">GPBCON |= <span class="number">0x01</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao">3.4.1.1.2 控制引脚和数据引脚</span><a href="#3-4-1-1-2-kong-zhi-yin-jiao-he-shu-ju-yin-jiao" class="header-anchor">#</a></h5><p>然后再配置LCD的控制引脚和数据引脚，LCD控制引脚和数据引脚分别复用了GPC和GPD，如下图所示：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/31.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/32.png"></p>
<p>设置GPC, GPD均为0xaaaa,aaaa。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LCD专用引脚 */</span></span><br><span class="line">GPCCON = <span class="number">0xaaaaaaaa</span>;</span><br><span class="line">GPDCON = <span class="number">0xaaaaaaaa</span>;</span><br></pre></td></tr></table></figure>

<h5><span id="3-4-1-1-3-pwren-yin-jiao">3.4.1.1.3 PWREN引脚</span><a href="#3-4-1-1-3-pwren-yin-jiao" class="header-anchor">#</a></h5><p>设置GPG4成PWREN引脚</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/33.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/34.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GPGCON |= (<span class="number">3</span>&lt;&lt;<span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi">3.4.1.2 初始化LCD控制寄存器、地址寄存器</span><a href="#3-4-1-2-chu-shi-hua-lcd-kong-zhi-ji-cun-qi-di-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>前面介绍了LCDCON1，LCDCON2，LCDCON3…LCDSADDR1等寄存器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_init</span><span class="params">(p_lcd_params plcdparams)</span> &#123;</span><br><span class="line">	<span class="comment">/* [17:8]: CLKVAL, vclk = HCLK / [(CLKVAL+1) x 2]</span></span><br><span class="line"><span class="comment">	 *                   如：9   = 100M /[(CLKVAL+1) x 2], 所以CLKVAL = 4.5 = 5</span></span><br><span class="line"><span class="comment">	 *                 CLKVAL = 100/vclk/2-1</span></span><br><span class="line"><span class="comment">	 * [6:5]: 0b11, tft lcd</span></span><br><span class="line"><span class="comment">	 * [4:1]: bpp mode</span></span><br><span class="line"><span class="comment">	 * [0]  : LCD video output and the logic enable/disable</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> clkval = (<span class="type">double</span>)HCLK/plcdparams-&gt;time_seq.vclk/<span class="number">2</span><span class="number">-1</span>+<span class="number">0.5</span>;</span><br><span class="line">	<span class="type">int</span> bppmode = plcdparams-&gt;bpp == <span class="number">8</span>  ? <span class="number">0xb</span> :\</span><br><span class="line">				  plcdparams-&gt;bpp == <span class="number">16</span> ? <span class="number">0xc</span> :\</span><br><span class="line">				  <span class="number">0xd</span>;  <span class="comment">/* 0xd: 24bpp */</span></span><br><span class="line">	LCDCON1 = (clkval&lt;&lt;<span class="number">8</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">5</span>) | (bppmode&lt;&lt;<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [31:24] : VBPD    = tvb - 1</span></span><br><span class="line"><span class="comment">	 * [23:14] : LINEVAL = line - 1</span></span><br><span class="line"><span class="comment">	 * [13:6]  : VFPD    = tvf - 1</span></span><br><span class="line"><span class="comment">	 * [5:0]   : VSPW    = tvp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON2 = 	((plcdparams-&gt;time_seq.tvb - <span class="number">1</span>)&lt;&lt;<span class="number">24</span>) | \</span><br><span class="line">	            ((plcdparams-&gt;yres - <span class="number">1</span>)&lt;&lt;<span class="number">14</span>)         | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvf - <span class="number">1</span>)&lt;&lt;<span class="number">6</span>)  | \</span><br><span class="line">				((plcdparams-&gt;time_seq.tvp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* [25:19] : HBPD	 = thb - 1</span></span><br><span class="line"><span class="comment">	 * [18:8]  : HOZVAL  = 列 - 1</span></span><br><span class="line"><span class="comment">	 * [7:0]   : HFPD	 = thf - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON3 =	((plcdparams-&gt;time_seq.thb - <span class="number">1</span>)&lt;&lt;<span class="number">19</span>) | \</span><br><span class="line">				((plcdparams-&gt;xres - <span class="number">1</span>)&lt;&lt;<span class="number">8</span>)		      | \</span><br><span class="line">				((plcdparams-&gt;time_seq.thf - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [7:0]   : HSPW	 = thp - 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	LCDCON4 =	((plcdparams-&gt;time_seq.thp - <span class="number">1</span>)&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 用来设置引脚极性, 设置16bpp, 设置内存中象素存放的格式</span></span><br><span class="line"><span class="comment">     * [12] : BPP24BL</span></span><br><span class="line"><span class="comment">	 * [11] : FRM565, 1-565</span></span><br><span class="line"><span class="comment">	 * [10] : INVVCLK, 0 = The video data is fetched at VCLK falling edge</span></span><br><span class="line"><span class="comment">	 * [9]  : HSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [8]  : VSYNC是否反转</span></span><br><span class="line"><span class="comment">	 * [7]  : INVVD, rgb是否反转</span></span><br><span class="line"><span class="comment">	 * [6]  : INVVDEN</span></span><br><span class="line"><span class="comment">	 * [5]  : INVPWREN</span></span><br><span class="line"><span class="comment">	 * [4]  : INVLEND</span></span><br><span class="line"><span class="comment">	 * [3]  : PWREN, LCD_PWREN output signal enable/disable</span></span><br><span class="line"><span class="comment">	 * [2]  : ENLEND</span></span><br><span class="line"><span class="comment">	 * [1]  : BSWP</span></span><br><span class="line"><span class="comment">	 * [0]  : HWSWP</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	pixelplace = plcdparams-&gt;bpp == <span class="number">24</span> ? (<span class="number">0</span>) : |\</span><br><span class="line">	             plcdparams-&gt;bpp == <span class="number">16</span> ? (<span class="number">1</span>) : |\</span><br><span class="line">	             (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);  <span class="comment">/* 8bpp */</span></span><br><span class="line">	LCDCON5 = (plcdparams-&gt;pins_pol.vclk&lt;&lt;<span class="number">10</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.rgb&lt;&lt;<span class="number">7</span>)   |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.hsync&lt;&lt;<span class="number">9</span>) |\</span><br><span class="line">	          (plcdparams-&gt;pins_pol.vsync&lt;&lt;<span class="number">8</span>) |\</span><br><span class="line"> 			  (plcdparams-&gt;pins_pol.de&lt;&lt;<span class="number">6</span>)    |\</span><br><span class="line">			  (plcdparams-&gt;pins_pol.pwren&lt;&lt;<span class="number">5</span>) |\</span><br><span class="line">			  (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | pixelplace;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* framebuffer地址 */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * [29:21] : LCDBANK, A[30:22] of fb</span></span><br><span class="line"><span class="comment">	 * [20:0]  : LCDBASEU, A[21:1] of fb</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base &amp; ~(<span class="number">1</span>&lt;&lt;<span class="number">31</span>);</span><br><span class="line">	LCDSADDR1 = (addr &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * [20:0] : LCDBASEL, A[21:1] of end addr</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	addr = plcdparams-&gt;fb_base + plcdparams-&gt;xres*plcdparams-&gt;yres*plcdparams-&gt;bpp/<span class="number">8</span>;</span><br><span class="line">	addr &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	addr &amp;= <span class="number">0x1fffff</span>;</span><br><span class="line">	LCDSADDR2 = addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4><span id="3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao">3.4.1.3 使能、禁用背光引脚</span><a href="#3-4-1-3-shi-neng-jin-yong-bei-guang-yin-jiao" class="header-anchor">#</a></h4><p>根据背光电路背光引脚是GPB0，那么配置GPBDAT[0]置1，使能背光引脚，设置LCDCON5和<br>LCDCON1使能power enable和LCD输出，反之。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_enalbe</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren    : 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">s3c2440_lcd_controller_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 背光引脚 : GPB0 */</span></span><br><span class="line">	GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* pwren	: 给LCD提供AVDD  */</span></span><br><span class="line">	LCDCON5 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">	<span class="comment">/* LCDCON1&#x27;BIT 0 : 设置LCD控制器是否输出信号 */</span></span><br><span class="line">	LCDCON1 &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们的s3c2440的lcd控制器初始化就编写完了，那么用户只要调用s3c2440_lcd_controller_init去设置LCD的属性即可。下面开始介绍如何设置LCD属性，让LCD控制器能够适应具体型号的LCD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lcd_controller</span> <span class="title">s3c2440_lcd_controller</span> =</span> &#123;</span><br><span class="line">	.name    = <span class="string">&quot;s3c2440&quot;</span>,</span><br><span class="line">	.init    = s3c2440_lcd_controller_init,</span><br><span class="line">	.enable  = s3c2440_lcd_controller_enalbe,</span><br><span class="line">	.disable = s3c2440_lcd_controller_disable,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3><span id="3-4-2-chu-shi-hua-lcd-she-bei">3.4.2 初始化lcd设备</span><a href="#3-4-2-chu-shi-hua-lcd-she-bei" class="header-anchor">#</a></h3><p>参考AT043TN24 LCD数据手册上的参数性能，见下表：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/35.png"></p>
<p>配置lcd_params属性如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_FB_BASE 0x33c00000</span></span><br><span class="line">lcd_params lcd_4_3_params = &#123;</span><br><span class="line">	.name = <span class="string">&quot;lcd_4.3&quot;</span></span><br><span class="line">	.pins_polarity = &#123;</span><br><span class="line">		.de    = NORMAL,	<span class="comment">/* normal: 高电平时可以传输数据 */</span></span><br><span class="line">		.vclk  = NORMAL,	<span class="comment">/* normal: 在下降沿获取数据 */</span></span><br><span class="line">		.rgb   = NORMAL,	<span class="comment">/* normal: 高电平表示1 */</span></span><br><span class="line">		.hsync = INVERT,    <span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">		.vsync = INVERT, 	<span class="comment">/* normal: 高脉冲 */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.time_sequence = &#123;</span><br><span class="line">		<span class="comment">/* 垂直方向 */</span></span><br><span class="line">		.tvp=	<span class="number">10</span>, <span class="comment">/* vysnc脉冲宽度 */</span></span><br><span class="line">		.tvb=	<span class="number">2</span>,  <span class="comment">/* 上边黑框, Vertical Back porch */</span></span><br><span class="line">		.tvf=	<span class="number">2</span>,  <span class="comment">/* 下边黑框, Vertical Front porch */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 水平方向 */</span></span><br><span class="line">		.thp=	<span class="number">41</span>, <span class="comment">/* hsync脉冲宽度 */</span></span><br><span class="line">		.thb=	<span class="number">2</span>,  <span class="comment">/* 左边黑框, Horizontal Back porch */</span></span><br><span class="line">		.thf=	<span class="number">2</span>,  <span class="comment">/* 右边黑框, Horizontal Front porch */</span></span><br><span class="line"></span><br><span class="line">		.vclk=	<span class="number">9</span>,  <span class="comment">/* MHz */</span></span><br><span class="line">	&#125;,</span><br><span class="line">	.xres = <span class="number">480</span>,</span><br><span class="line">	.yres = <span class="number">272</span>,</span><br><span class="line">	.bpp  = <span class="number">16</span>,</span><br><span class="line">	.fb_base = LCD_FB_BASE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.de表示数据输出使能引脚，高电平有效，所以配置成NORMAL；</span><br><span class="line">.pwren表示LCD_PWREN引脚，高电平有效；</span><br><span class="line">.vclk表示LCD的时钟，从手册的LCD时序图中可以看到下降沿有效，所以配置NORMAL；</span><br><span class="line">.rgb表示颜色数据的引脚极性，高电平表示<span class="number">1</span>，配置成NORMAL；</span><br><span class="line">.hsync表示行同步信号，normal表示高脉冲，参考手册发现该信号低脉冲有效，所以配置成INVERT；</span><br></pre></td></tr></table></figure>

<p>什么是高低脉冲？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">高脉冲：即从逻辑<span class="number">0</span>变化bai到逻辑du1再变化到逻辑<span class="number">0</span>，如此便是一个高脉zhi冲。在单片机中定义高脉冲就是让某个I/O先输出逻辑<span class="number">0</span>，接着保持一定的时间（延时），再输出逻辑<span class="number">1</span>，同样保持一定的时间（延时），最后再转变输出为逻辑<span class="number">0</span>+延时。</span><br><span class="line">低脉冲：反之</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.vsync表示帧同步信号，同.hsync；</span><br><span class="line">.time_sequence时序设置参考上表配置。我们看到thf + thp + thb = <span class="number">2</span> + <span class="number">41</span> +<span class="number">2</span> = <span class="number">45</span> clk &gt; <span class="number">44</span> clk，满足上面的注意事项；</span><br><span class="line">.xres .yres表示分辨率</span><br><span class="line">.bpp表示像素点颜色模式</span><br><span class="line">.fb_base指定frame buffer的基地址</span><br></pre></td></tr></table></figure>

<p>那么最终LCD初始化函数封装如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 注册LCD,把具体的LCD属性配置下去 */</span></span><br><span class="line">	register_lcd(&amp;lcd_4_3_params);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 注册LCD控制器 */</span></span><br><span class="line">	register_lcd_controller(&amp;s3c2440_lcd_controller);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 选择某款LCD */</span></span><br><span class="line">	select_lcd(<span class="string">&quot;lcd_4.3&quot;</span>);</span><br><span class="line">	<span class="comment">/* 选择某款LCD控制器 */</span></span><br><span class="line">	select_lcd_controller(<span class="string">&quot;s3c2440&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 使用LCD的参数, 初始化LCD控制器 */</span></span><br><span class="line">	lcd_controller_init(g_p_lcd_selected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：我们可以看到，调用的函数都是一些通用型框架型接口，具体的实现本质还得根据硬件本身的特性来配置寄存器来驱动硬件工作。</p>
<h2><span id="3-5-shi-xian-xian-shi-gong-neng">3.5 实现显示功能</span><a href="#3-5-shi-xian-xian-shi-gong-neng" class="header-anchor">#</a></h2><h3><span id="3-5-1-lcd-xian-shi-man-ping-hong-se">3.5.1 LCD显示满屏红色</span><a href="#3-5-1-lcd-xian-shi-man-ping-hong-se" class="header-anchor">#</a></h3><p>想要在LCD上显示出数据，所需步骤如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a. 初始化LCD</span><br><span class="line">b. 使能LCD</span><br><span class="line">c. 获取LCD参数: fb_base, xres, yres, bpp</span><br><span class="line">d. 往framebuffer中写数据</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-1-chu-shi-hua-lcd">3.5.1.1 初始化LCD</span><a href="#3-5-1-1-chu-shi-hua-lcd" class="header-anchor">#</a></h4><p>前面已详细实现。</p>
<h4><span id="3-5-1-2-shi-neng-lcd">3.5.1.2 使能LCD</span><a href="#3-5-1-2-shi-neng-lcd" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lcd_enable</span><span class="params">()</span> &#123;</span><br><span class="line">	lcd_controller_enalbe(); <span class="comment">//会间接调用s3c2440_lcd_controller_enalbe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-3-huo-qu-lcd-can-shu">3.5.1.3 获取LCD参数</span><a href="#3-5-1-3-huo-qu-lcd-can-shu" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">get_lcd_params</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_base, <span class="type">int</span> *xres, <span class="type">int</span> *yres, <span class="type">int</span> *bpp)</span> &#123;</span><br><span class="line">	*fb_base = g_p_lcd_selected-&gt;fb_base;</span><br><span class="line">	*xres = g_p_lcd_selected-&gt;xres;</span><br><span class="line">	*yres = g_p_lcd_selected-&gt;yres;</span><br><span class="line">	*bpp = g_p_lcd_selected-&gt;bpp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-5-1-4-wang-framebuffer-zhong-xie-shu-ju">3.5.1.4 往framebuffer中写数据</span><a href="#3-5-1-4-wang-framebuffer-zhong-xie-shu-ju" class="header-anchor">#</a></h4><p>假设我们初始化配置了BPP&#x3D;16，那么如何让全屏显示红色？</p>
<p>就需要从framebuffer基地址开始的整个屏幕的像素点都填充红色值。 对于16BPP，RGB&#x3D;565，想显示红色，即[15:11]全为1表示红色，[10:5]全为0表示无绿色，[4:0]全为0表示无蓝色，0b1111100000000000&#x3D;0xF800。<br>以基地址为起点，分别以xres和yres为边界，依次填充颜色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">short</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xf800</span>;</span><br></pre></td></tr></table></figure>
<p>假设我们初始化配置了BPP&#x3D;24 或者BPP &#x3D;32，那么如何让全屏显示红色？</p>
<p>其实无论是24bpp还是32bpp，在frame buffer中每个像素点都占4 bytes，对于24BPP or 32 bpp，即RGB:888，每个颜色占8位，一共占据24位。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p = (<span class="type">unsigned</span> <span class="type">int</span> *)fb_base;</span><br><span class="line"><span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; xres; x++)</span><br><span class="line">	<span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; yres; y++)</span><br><span class="line">		*p++ = <span class="number">0xff0000</span>;</span><br></pre></td></tr></table></figure>
<p>当Frame buffer中填满颜色数据时，LCD控制器会参照我们之前的配置将数据填充到LCD显示器上。那前面的24BPP、32BPP是怎样在 只能接收16BPP(硬件上只有16根数据线)的LCD上显示的呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">这是因为在使用<span class="number">24B</span>PP时，发出的<span class="number">8</span>条红色，<span class="number">8</span>条绿色，<span class="number">8</span>条蓝色数据，只用了高<span class="number">5</span>条红色，高<span class="number">6</span>条绿色，高<span class="number">5</span>条蓝色与LCD相连。（前面LCD硬件原理的FrameBuffer和BPP概念有讲）</span><br></pre></td></tr></table></figure>

<h2><span id="3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu">3.6 实现绘制点线圆函数</span><a href="#3-6-shi-xian-hui-zhi-dian-xian-yuan-han-shu" class="header-anchor">#</a></h2><h3><span id="3-6-1-hua-dian">3.6.1 画点</span><a href="#3-6-1-hua-dian" class="header-anchor">#</a></h3><p>无论是何种图形，都是基于点来构成的，因此我们需要先实现画点，其他的都是上层的一些数据处理了，像各种图形、甚至色彩鲜艳的图片无非都是一些由点构造出的数据而已。</p>
<p>我们在在farmebuffer.c实现画点，在geomentry.c实现画线、画圆等几何图形，font.c实现画字。</p>
<p>那么一个像素点要显示到lcd上，我们要知道它的位置坐标，然后还要知道它的颜色值，假设该像素点的坐标为（x,y）,那么该像素的地址为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（x,y）= fb_base + (xres*(bpp/<span class="number">8</span>))*y +x*bpp/<span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>那么所以在画点前需要先获取lcd参数：fb_base、xres、yres、bpp;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_get_lcd_params</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后画点函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>  *pc;  <span class="comment">/* 8bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *pw;  <span class="comment">/* 16bpp */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>   *pdw; <span class="comment">/* 32bpp */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pixel_base = fb_base + (xres * bpp / <span class="number">8</span>) * y + x * bpp / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (bpp) &#123; <span class="comment">//根据像素不同bpp格式，在Frame buffer中存放方式不一样，但对用户来说，不关心颜色格式，通通当做32位色颜色处理，所以这里需要做格式转换</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			pc = (<span class="type">unsigned</span> <span class="type">char</span> *) pixel_base;</span><br><span class="line">			*pc = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			pw = (<span class="type">unsigned</span> <span class="type">short</span> *) pixel_base;</span><br><span class="line">			*pw = convert32bppto16bpp(color);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">32</span>:</span><br><span class="line">			pdw = (<span class="type">unsigned</span> <span class="type">int</span> *) pixel_base;</span><br><span class="line">			*pdw = color;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户传入的颜色数据一般都是32bit的，即格式为：0x00RRGGBB。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">对于<span class="number">8</span>PP，通过的是调色板索引实现的，这个后续再讲解，直接*pc = color即可（这样只取了高<span class="number">8</span>位，低精度的数据就丢了）。</span><br><span class="line">对于<span class="number">16</span>PP，那么需要进行颜色转换后再存放进frame buffer。</span><br><span class="line">对于<span class="number">32</span>PP，大小刚好对应，直接*pc = color即可。</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-2-32bppto16bpp-han-shu">3.6.2 32bppto16bpp函数</span><a href="#3-6-2-32bppto16bpp-han-shu" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先分别取出RGB，再相应的清除低位数据，实现将RGB888变为RGB565</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">convert32bppto16bpp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> rgb)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r = (rgb &gt;&gt; <span class="number">16</span>)&amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> g = (rgb &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="type">int</span> b = rgb &amp; <span class="number">0xff</span>;</span><br><span class="line">	<span class="comment">/* rgb565 */</span></span><br><span class="line">	r = r &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	g = g &gt;&gt; <span class="number">2</span>;<span class="comment">//取低6位</span></span><br><span class="line">	b = b &gt;&gt; <span class="number">3</span>;<span class="comment">//取低5位</span></span><br><span class="line">	<span class="keyword">return</span> ((r&lt;&lt;<span class="number">11</span>) | (g&lt;&lt;<span class="number">5</span>) | (b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-6-3-hua-xian-hua-yuan">3.6.3 画线画圆</span><a href="#3-6-3-hua-xian-hua-yuan" class="header-anchor">#</a></h3><p>画圆画线的具体原理不是本主题的重点，这些属于研究算法的范畴了，比如这里就有现成的算法可以用，如这篇博客：<a href="https://blog.csdn.net/p1126500468/article/details/50428613">https://blog.csdn.net/p1126500468/article/details/50428613</a>，里面有画圆画线的函数实现，直接使用就可以了，套用画点的”轮子”就可以了。</p>
<h3><span id="3-6-4-ce-shi">3.6.4 测试</span><a href="#3-6-4-ce-shi" class="header-anchor">#</a></h3><p>新建一个geometry.c，复制博客中代码，替换里面的描点显示函数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 画线 */</span></span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xff0000</span>); <span class="comment">//(0,0) 到（xres - 1, 0）两点间的线</span></span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xffff00</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, yres - <span class="number">1</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff00aa</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff00ef</span>);</span><br><span class="line">draw_line(<span class="number">0</span>, <span class="number">0</span>, xres - <span class="number">1</span>, yres - <span class="number">1</span>, <span class="number">0xff4500</span>);</span><br><span class="line">draw_line(xres - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, yres - <span class="number">1</span>, <span class="number">0xff0780</span>);</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 画圆 */</span></span><br><span class="line">draw_circle(xres/<span class="number">2</span>, yres/<span class="number">2</span>, yres/<span class="number">4</span>, <span class="number">0xff00</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/36.jpg"></p>
<h2><span id="3-7-zi-fu-ku-yi-zhi">3.7 字符库移植</span><a href="#3-7-zi-fu-ku-yi-zhi" class="header-anchor">#</a></h2><p>字符也是由点构成的，一个个点组成的点阵，其实本质上要显示文字就是把字库移植到对应的自己型号相匹配的board上，字库中的每一个字符都是一些点按照对应格式组合成的集合。</p>
<p>从linux内核源码中随便挑选一个字库文件，比如linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应的很多字库文件。在这里我挑选font_8x16.c，如下图：</p>
<p><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/37.png"></p>
<p>其中8x16表示每个字符所占的像素点的大小，表示每个字符占的大小为长*宽&#x3D;8*16个像素点。</p>
<p>我们来看下一个字符’A’是如何显示的？从font_8x16.c我们找到字符’A’的数据，如下图：<br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/38.png"><br><img src="/2024/04/19/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-LDC/39.png"><br>那么我们如何让font_8x16.c这个字库的数据显示到lcd上呢？font_8x16.c见附件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a. 根据要显示的字符的ascii码作为索引，在fontdata_8x16中得到点阵数据</span></span><br><span class="line"><span class="comment">b. 根据点阵来设置对应象素的颜色</span></span><br><span class="line"><span class="comment">c. 根据点阵的某位决定是否描颜色</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_char</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> c, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="comment">/* 根据c的ascii码作为索引在fontdata_8x16中得到点阵数据（fontdata_8x16是字库的数据集合）*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *dots = &amp;fontdata_8x16[c * <span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> bit;</span><br><span class="line">	<span class="comment">/* 根据点阵来设置对应象素的颜色 */</span></span><br><span class="line">	<span class="keyword">for</span> (j = y; j &lt; y+<span class="number">16</span>; j++) &#123;</span><br><span class="line">		data = *dots++;</span><br><span class="line">		bit = <span class="number">7</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = x; i &lt; x+<span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="comment">/* 根据点阵的某位决定是否描颜色 */</span></span><br><span class="line">			<span class="keyword">if</span> (data &amp; (<span class="number">1</span>&lt;&lt;bit))</span><br><span class="line">				fb_put_pixel(i, j, color);</span><br><span class="line">			bit--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在font_8x16.c里面，每个字符占据16字节，因此想要根据ascii码找到对应的点阵数据，需要对应的乘16，再取地址，得到该字符的首地址。</p>
<p>在显示之前，还需要获取LCD参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> fontdata_8x16[];</span><br><span class="line"><span class="comment">/* 获得LCD参数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> xres, yres, bpp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">font_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	get_lcd_params(&amp;fb_base, &amp;xres, &amp;yres, &amp;bpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-7-1-xian-shi-zi-fu-chuan">3.7.1 显示字符串</span><a href="#3-7-1-xian-shi-zi-fu-chuan" class="header-anchor">#</a></h3><p>如果想显示字符串，那就在每显示完一个字符后，x轴加8即可，同时考虑是否超出屏幕显示范围进行换行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &quot;abc\n\r123&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fb_print_string</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>* str, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">    	<span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (str[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            			y = y+<span class="number">16</span>;</span><br><span class="line">        		<span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            			x = <span class="number">0</span>;</span><br><span class="line">        		<span class="keyword">else</span> &#123;</span><br><span class="line">            			fb_print_char(x, y, str[i], color);</span><br><span class="line">            			x = x+<span class="number">8</span>;</span><br><span class="line">            			<span class="keyword">if</span> (x &gt;= xres) &#123;</span><br><span class="line">                				x = <span class="number">0</span>;</span><br><span class="line">                				y = y+<span class="number">16</span>;</span><br><span class="line">            			&#125;</span><br><span class="line">        		&#125;</span><br><span class="line">        		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-SPI</title>
    <url>/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-spi-yuan-li">1 SPI原理</a><ul>
<li><a href="#1-1-spi-gai-nian">1.1 spi概念</a></li>
<li><a href="#1-2-ying-ti-kuang-jia">1.2 硬体框架</a></li>
<li><a href="#1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</a></li>
<li><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</a></li>
<li><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</a></li>
</ul>
</li>
<li><a href="#2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</a><ul>
<li><a href="#2-1-sspsr">2.1 SSPSR</a></li>
<li><a href="#2-2-sspbuf">2.2 SSPBUF</a></li>
<li><a href="#2-3-controller">2.3 Controller</a></li>
</ul>
</li>
<li><a href="#3-spi-luo-ji-shi-li">3 SPI裸机示例</a><ul>
<li><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</a><ul>
<li><a href="#3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</a></li>
<li><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</a></li>
<li><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</a></li>
<li><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</a></li>
<li><a href="#3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</a></li>
</ul>
</li>
<li><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</a><ul>
<li><a href="#3-2-1-fa-song-di-zhi">3.2.1 发送地址</a><ul>
<li><a href="#3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</a><ul>
<li><a href="#3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</a></li>
<li><a href="#3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-2-2-fa-song-shu-ju">3.2.2 发送数据</a></li>
</ul>
</li>
<li><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</a><ul>
<li><a href="#3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</a></li>
<li><a href="#3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</a><ul>
<li><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</a></li>
<li><a href="#3-3-2-2-xie-ming-ling">3.3.2.2 写命令</a><ul>
<li><a href="#3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</a></li>
</ul>
</li>
<li><a href="#3-3-2-3-xie-shu-ju">3.3.2.3 写数据</a></li>
</ul>
</li>
<li><a href="#3-2-3-oled-c">3.2.3 oled.c</a><ul>
<li><a href="#3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</a></li>
<li><a href="#3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</a></li>
</ul>
</li>
<li><a href="#3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-spi-yuan-li">1 SPI原理</span><a href="#1-spi-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-spi-gai-nian">1.1 spi概念</span><a href="#1-1-spi-gai-nian" class="header-anchor">#</a></h2><p>SPI是串行外设接口(Serial Peripheral Interface)的缩写。是 Motorola 公司推出的一种同步串行接口技术，是一种高速的，全双工，同步的通信总线。</p>
<p>特点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">高速、同步、全双工、非差分、总线式</span><br><span class="line">主从机通信模式</span><br></pre></td></tr></table></figure>

<p>优点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">支持全双工通信（SPI的数据输入和输出线独立，所以允许同时完成数据的输入和输出）</span><br><span class="line">数据传输速率快（I2c一般只能到100-400Khz, SPI高达上百Mhz）</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没有指定的流控制，没有应答机制确认是否接收到数据，所以跟IIC总线协议比较在数据可靠性上有一定的缺陷</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ying-ti-kuang-jia">1.2 硬体框架</span><a href="#1-2-ying-ti-kuang-jia" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/1.png" alt="img"></p>
<p>SCK：提供时钟<br>DO:作为数据输出<br>DI:作为数据输入<br>CS0&#x2F;CS1:作为片选</p>
<p>同一时刻只能有一个SPI设备处于工作状态。因此cs选中谁，谁就和主控通信。</p>
<h2><span id="1-2-shu-ju-chuan-shu-shi-xu">1.2 数据传输时序</span><a href="#1-2-shu-ju-chuan-shu-shi-xu" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/2.png" alt="img"></p>
<p>这里是一款SPI flash在SCLK上升延采样数据（D7~D0）的示意图。设现在s3c2440传输一个0x56数据给SPI Flash，时序如下：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/3.png" alt="img"></p>
<p>CS0低选中SPI Flash，配置成模式0， 0x56的二进制就是0b0101 0110，因此在每个SCK时钟周期，DO输出对应的电平。会在<strong>每个时钟周期的上升沿采样DO上的电平</strong>。</p>
<h2><span id="1-3-spi-xiang-guan-de-ming-ci-suo-xie">1.3 SPI相关的名词缩写</span><a href="#1-3-spi-xiang-guan-de-ming-ci-suo-xie" class="header-anchor">#</a></h2><p><strong>KPOL</strong>： (Clock Polarity)（时钟）极性</p>
<p><strong>CKPHA</strong>： (Clock Phase)（时钟）相位</p>
<p><strong>SCK</strong>&#x3D;<strong>SCLK</strong>：SPI的时钟</p>
<p><strong>Leading edge</strong>：前一个边沿</p>
<p><strong>Trailing edge</strong>：后一个边沿</p>
<h2><span id="1-4-shi-zhong-ji-xing-xiang-wei-mo-shi">1.4 时钟极性相位模式</span><a href="#1-4-shi-zhong-ji-xing-xiang-wei-mo-shi" class="header-anchor">#</a></h2><p>CPOL:表示SPI CLK的初始电平（空闲状态时电平），0为低电平，1为高电平</p>
<p>CPHA:表示相位，即第一个还是第二个时钟沿采样数据，0为第一个时钟沿，1为第二个时钟沿</p>
<p>两者组合成4种模式：</p>
<table>
<thead>
<tr>
<th>SPI模式</th>
<th>CPOL</th>
<th>CPHA</th>
<th>空闲状态时钟极性</th>
<th>采样&#x2F;移位时钟相位</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>低电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>低电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>高电平</td>
<td>上升沿移位下降沿采样（锁存）</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>高电平</td>
<td>上升沿采样（锁存）下降沿移位</td>
</tr>
</tbody></table>
<p>4个模式波形对比：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/4.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/5.png" alt="img"></p>
<p>常用的是<strong>模式0和模式3</strong>，因为它们都是在<strong>上升沿采样数据</strong>.当配置成模式3时，<strong>对于主设备，数据采样在时钟上升沿，数据传送在时钟下降沿****。</strong></p>
<p><strong>主设备SPI时钟和极性的配置应该由外设来决定；二者的配置应该保持一致，即主设备的SDO同从设备的SDO配置一致，主设备的SDI同从设备的SDI配置一致。即因为主从设备是在SCLK的控制下，同时发送和接收数据，并通过2个双向移位寄存器来交换数据 。</strong></p>
<p>举个例子，以 CPOL&#x3D;0，CPHA&#x3D;0，模式0为例：空闲CLK为低电平，相位为0，也就是上升延采集数据。由于SPI的全双工可以同时读写，发送MOSI数据为0xD2,接收MISO数据为0x66。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/6.png" alt="img"></p>
<h1><span id="2-spi-kong-zhi-qi-jie-gou">2 SPI控制器结构</span><a href="#2-spi-kong-zhi-qi-jie-gou" class="header-anchor">#</a></h1><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/7.png" alt="img"></p>
<h2><span id="2-1-sspsr">2.1 SSPSR</span><a href="#2-1-sspsr" class="header-anchor">#</a></h2><p>SSPSR：移位寄存器(Shift Register). 根据 SPI 时钟同步信号, 将SSPBUF中的数据一位一位移出去或者收进来。</p>
<h2><span id="2-2-sspbuf">2.2 SSPBUF</span><a href="#2-2-sspbuf" class="header-anchor">#</a></h2><p>Master 与 Slave 之间交换的数据其实都是移位寄存器从 SSPBUF 里面拷贝的。通过往 SSPBUF 对应的寄存器 (Tx-Data &#x2F; Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF。</p>
<h2><span id="2-3-controller">2.3 Controller</span><a href="#2-3-controller" class="header-anchor">#</a></h2><p>用来发送控制信号的，像CS，SCK等控制信号。</p>
<h1><span id="3-spi-luo-ji-shi-li">3 SPI裸机示例</span><a href="#3-spi-luo-ji-shi-li" class="header-anchor">#</a></h1><h2><span id="3-1-spi-oled-xian-shi-mian-ban-jie-shao">3.1 SPI-OLED显示面板介绍</span><a href="#3-1-spi-oled-xian-shi-mian-ban-jie-shao" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/8.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款OLED为例，可见它支持Parallel&#x2F;i2c&#x2F;SPI这3种方式对它进行控制，这里仅对它进行SPI控制。它的product Specification见附件。</p>
<h3><span id="3-1-1-bing-xing-jie-kou-shi-xu">3.1.1 并行接口时序</span><a href="#3-1-1-bing-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/9.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/10.png" alt="img"></p>
<h3><span id="3-1-2-spi-chuan-xing-jie-kou-shi-xu">3.1.2 SPI串行接口时序</span><a href="#3-1-2-spi-chuan-xing-jie-kou-shi-xu" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/11.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tr/Tf: 表示spi clk上升/下降延不能超过<span class="number">40</span>ns</span><br><span class="line">Tclkl/Tclkh: 表示spi clk低/高电平持续至少<span class="number">20</span>ns</span><br><span class="line">Tcycle: 表示spi clk一个时钟周期至少<span class="number">100</span>ns</span><br><span class="line">Tdsw/Tdhw: 表示spi data的建立/持续时间至少<span class="number">15</span>ms</span><br><span class="line">Tcss:片选建立时间至少<span class="number">20</span>ns</span><br><span class="line">Tcsh:片选持续时间至少<span class="number">10</span>ns</span><br><span class="line">Tas/Tah:地址建立/持续时间至少<span class="number">15</span>ns</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-power-on-sequence-shang-dian-xu-lie">3.1.3 power on sequence-上电序列</span><a href="#3-1-3-power-on-sequence-shang-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/12.png" alt="img"></p>
<h3><span id="3-1-4-power-down-sequence-diao-dian-xu-lie">3.1.4 power down sequence-掉电序列</span><a href="#3-1-4-power-down-sequence-diao-dian-xu-lie" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/13.png" alt="img"></p>
<h3><span id="3-1-5-xiu-mian-huan-xing">3.1.5 休眠唤醒</span><a href="#3-1-5-xiu-mian-huan-xing" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/14.png" alt="img"></p>
<h2><span id="3-2-spi-oled-mian-ban-xian-shi-yuan-li">3.2 SPI-OLED面板显示原理</span><a href="#3-2-spi-oled-mian-ban-xian-shi-yuan-li" class="header-anchor">#</a></h2><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/15.png" alt="img"></p>
<p><strong>QG-2864TMBEG01</strong>这款为例，OLED长有128个像素，宽有64个像素，共128*64&#x3D;8,192 像素。每个像素用1bit来表示，为1则亮，为0则灭。所以每一个字节数据Data表示8个像素，Data0~Data1023,如上图。 那要怎么在显存里面存放Data数据。</p>
<h3><span id="3-2-1-fa-song-di-zhi">3.2.1 发送地址</span><a href="#3-2-1-fa-song-di-zhi" class="header-anchor">#</a></h3><h4><span id="3-2-1-1-ye-page-di-zhi-mo-shi">3.2.1.1 页(page)地址模式</span><a href="#3-2-1-1-ye-page-di-zhi-mo-shi" class="header-anchor">#</a></h4><p>QG-2864TMBEG01 OLED主控有三种地址模式，我们常用的是页地址模式，发送0x20命令，再发送0x02命令，进入页地址模式，如下图：</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/16.png" alt="img"></p>
<p>它把显存的64行分为8页，每页对应8行；选中某页后，再选择某列。因此共用页地址，也就是8行都共用同一个页地址，列地址独立，所以page0<del>page7，col0</del>col127。然后就可以往里面写数据了，每写一个数据，列地址就会加1，一直写到最右端的位置，页地址加1，会自动跳到最左端。通过命令来实现发送页地址和列地址，其中列地址分为两次发送，先发送低字节，再发送高字节。如下图，假设每个字符数据大小为8x16像素，假如第一个字符位置为(page,col)，相邻的右边就是(page,col+8)，写一个字符需要先发8字节，然后跳到下一页坐标就是(page+2,col)，发送8字节数据。一个字符需要2个page*8个col，由于一个像素占1个bit, 所以一个Data占1byte, 一个字符占16 byte。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/17.png" alt="img"></p>
<h5><span id="3-2-1-1-1-she-zhi-page-addr">3.2.1.1.1 设置page addr</span><a href="#3-2-1-1-1-she-zhi-page-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/18.png" alt="img"></p>
<p>一共就8页，因此X2<del>X0，有3bit足够了。比如选中page0，则x2</del>x0 &#x3D; 000。</p>
<h5><span id="3-2-1-1-2-she-zhi-col-addr">3.2.1.1.2 设置col addr</span><a href="#3-2-1-1-2-she-zhi-col-addr" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/19.png" alt="img"></p>
<p>分两次发送， 先发送列地址低4位，再发送列地址高4位；</p>
<h3><span id="3-2-2-fa-song-shu-ju">3.2.2 发送数据</span><a href="#3-2-2-fa-song-shu-ju" class="header-anchor">#</a></h3><p>如何发送一个字符‘A’，显示到OLED。</p>
<ol>
<li>取得字模</li>
</ol>
<p>这里从网上找了一份8x16的字库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __OLEDFONT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __OLEDFONT_H      </span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> oled_asc2_8x16[<span class="number">95</span>][<span class="number">16</span>]= &#123;</span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">// 0</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//!1</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x10</span>,<span class="number">0x0C</span>,<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&quot;2</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0xC0</span>,<span class="number">0x78</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x3F</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//#3</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0xFC</span>,<span class="number">0x08</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0xFF</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//$4</span></span><br><span class="line">    &#123;<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x1C</span>,<span class="number">0x03</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x1E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//%5</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1E</span>,<span class="number">0x21</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x27</span>,<span class="number">0x21</span>,<span class="number">0x10</span>&#125;,<span class="comment">//&amp;6</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x16</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#x27;7</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//(8</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x18</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//)9</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x0F</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//*10</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x1F</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//+11</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xB0</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//,12</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>&#125;,<span class="comment">//-13</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//.14</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x60</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">///15</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//016</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x10</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//117</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x28</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//218</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x48</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//319</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x04</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x00</span>&#125;,<span class="comment">//420</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//521</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//622</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//723</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//824</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x31</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x11</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//925</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x30</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//:26</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x60</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//;27</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x40</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&lt;28</span></span><br><span class="line">    &#123;<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>&#125;,<span class="comment">//=29</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x40</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&gt;30</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x48</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x30</span>,<span class="number">0x36</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//?31</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0xC8</span>,<span class="number">0x28</span>,<span class="number">0xE8</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x27</span>,<span class="number">0x24</span>,<span class="number">0x23</span>,<span class="number">0x14</span>,<span class="number">0x0B</span>,<span class="number">0x00</span>&#125;,<span class="comment">//@32</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x38</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3C</span>,<span class="number">0x23</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x27</span>,<span class="number">0x38</span>,<span class="number">0x20</span>&#125;,<span class="comment">//A33</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//B34</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x00</span>&#125;,<span class="comment">//C35</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//D36</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x23</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//E37</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0xE8</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//F38</span></span><br><span class="line">    &#123;<span class="number">0xC0</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x22</span>,<span class="number">0x1E</span>,<span class="number">0x02</span>,<span class="number">0x00</span>&#125;,<span class="comment">//G39</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x21</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//H40</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//I41</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//J42</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0xC0</span>,<span class="number">0x28</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x01</span>,<span class="number">0x26</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//K43</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//L44</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//M45</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x18</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//N46</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x10</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//O47</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF0</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//P48</span></span><br><span class="line">    &#123;<span class="number">0xE0</span>,<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x10</span>,<span class="number">0xE0</span>,<span class="number">0x00</span>,<span class="number">0x0F</span>,<span class="number">0x18</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x38</span>,<span class="number">0x50</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Q49</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x70</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//R50</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x70</span>,<span class="number">0x88</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x38</span>,<span class="number">0x20</span>,<span class="number">0x21</span>,<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x1C</span>,<span class="number">0x00</span>&#125;,<span class="comment">//S51</span></span><br><span class="line">    &#123;<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//T52</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//U53</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x78</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x38</span>,<span class="number">0x0E</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//V54</span></span><br><span class="line">    &#123;<span class="number">0xF8</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x03</span>,<span class="number">0x3C</span>,<span class="number">0x07</span>,<span class="number">0x00</span>,<span class="number">0x07</span>,<span class="number">0x3C</span>,<span class="number">0x03</span>,<span class="number">0x00</span>&#125;,<span class="comment">//W55</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x18</span>,<span class="number">0x68</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x68</span>,<span class="number">0x18</span>,<span class="number">0x08</span>,<span class="number">0x20</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x03</span>,<span class="number">0x03</span>,<span class="number">0x2C</span>,<span class="number">0x30</span>,<span class="number">0x20</span>&#125;,<span class="comment">//X56</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0x38</span>,<span class="number">0xC8</span>,<span class="number">0x00</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Y57</span></span><br><span class="line">    &#123;<span class="number">0x10</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xC8</span>,<span class="number">0x38</span>,<span class="number">0x08</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x38</span>,<span class="number">0x26</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x18</span>,<span class="number">0x00</span>&#125;,<span class="comment">//Z58</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFE</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x00</span>&#125;,<span class="comment">//[59</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x06</span>,<span class="number">0x38</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>&#125;,<span class="comment">//\60</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0xFE</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//]61</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x04</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//^62</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>&#125;,<span class="comment">//_63</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//`64</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x19</span>,<span class="number">0x24</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//a65</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//b66</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x00</span>&#125;,<span class="comment">//c67</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x88</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//d68</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x22</span>,<span class="number">0x13</span>,<span class="number">0x00</span>&#125;,<span class="comment">//e69</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xF0</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x88</span>,<span class="number">0x18</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//f70</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x6B</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x94</span>,<span class="number">0x93</span>,<span class="number">0x60</span>,<span class="number">0x00</span>&#125;,<span class="comment">//g71</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//h72</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//i73</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x98</span>,<span class="number">0x98</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xC0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x7F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//j74</span></span><br><span class="line">    &#123;<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x24</span>,<span class="number">0x02</span>,<span class="number">0x2D</span>,<span class="number">0x30</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//k75</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x08</span>,<span class="number">0x08</span>,<span class="number">0xF8</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//l76</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>&#125;,<span class="comment">//m77</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//n78</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x1F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//o79</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0xFF</span>,<span class="number">0xA1</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x11</span>,<span class="number">0x0E</span>,<span class="number">0x00</span>&#125;,<span class="comment">//p80</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x0E</span>,<span class="number">0x11</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0xA0</span>,<span class="number">0xFF</span>,<span class="number">0x80</span>&#125;,<span class="comment">//q81</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x3F</span>,<span class="number">0x21</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//r82</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x33</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x24</span>,<span class="number">0x19</span>,<span class="number">0x00</span>&#125;,<span class="comment">//s83</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0xE0</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//t84</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x1F</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x20</span>,<span class="number">0x10</span>,<span class="number">0x3F</span>,<span class="number">0x20</span>&#125;,<span class="comment">//u85</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x0E</span>,<span class="number">0x30</span>,<span class="number">0x08</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//v86</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x0F</span>,<span class="number">0x30</span>,<span class="number">0x0C</span>,<span class="number">0x03</span>,<span class="number">0x0C</span>,<span class="number">0x30</span>,<span class="number">0x0F</span>,<span class="number">0x00</span>&#125;,<span class="comment">//w87</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x20</span>,<span class="number">0x31</span>,<span class="number">0x2E</span>,<span class="number">0x0E</span>,<span class="number">0x31</span>,<span class="number">0x20</span>,<span class="number">0x00</span>&#125;,<span class="comment">//x88</span></span><br><span class="line">    &#123;<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x81</span>,<span class="number">0x8E</span>,<span class="number">0x70</span>,<span class="number">0x18</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x00</span>&#125;,<span class="comment">//y89</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x2C</span>,<span class="number">0x22</span>,<span class="number">0x21</span>,<span class="number">0x30</span>,<span class="number">0x00</span>&#125;,<span class="comment">//z90</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x80</span>,<span class="number">0x7C</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x40</span>&#125;,<span class="comment">//&#123;91</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0xFF</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//|92</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x7C</span>,<span class="number">0x80</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x40</span>,<span class="number">0x40</span>,<span class="number">0x3F</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//&#125;93</span></span><br><span class="line">    &#123;<span class="number">0x00</span>,<span class="number">0x06</span>,<span class="number">0x01</span>,<span class="number">0x01</span>,<span class="number">0x02</span>,<span class="number">0x02</span>,<span class="number">0x04</span>,<span class="number">0x04</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>&#125;,<span class="comment">//~94</span></span><br><span class="line">&#125;;     </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>发送页&#x2F;列地址</p>
</li>
<li><p>发送数据</p>
</li>
</ol>
<h2><span id="3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi">3.3 SPI-OLED驱动-GPIO模拟SPI方式</span><a href="#3-3-spi-oled-qu-dong-gpio-mo-ni-spi-fang-shi" class="header-anchor">#</a></h2><h3><span id="3-3-1-ruan-jian-ceng-ci">3.3.1 软件层次</span><a href="#3-3-1-ruan-jian-ceng-ci" class="header-anchor">#</a></h3><p>操作OLED，通过三条线(SCK、DO、CS)与OLED相连，这里没有DI是因为s3c2440只会向OLED传数据而不用接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpio_spi.c来实现gpio模拟spi，负责spi通讯。对于OLED，有专门的指令和数据格式，要传输的数据内容。</span><br><span class="line">oled.c这一层来实现，负责组织数据。</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-gpio-spi-c">3.3.2 gpio_spi.c</span><a href="#3-3-2-gpio-spi-c" class="header-anchor">#</a></h3><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/20.png" alt="img"></p>
<h4><span id="3-3-2-1-spi-yin-jiao-chu-shi-hua">3.3.2.1 spi引脚初始化</span><a href="#3-3-2-1-spi-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h4><p>上图J3为板子pin2pin到OLED的底座。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPF1作为OLED片选引脚，设置为输出；</span><br><span class="line">GPG4作为OLED的数据(Data)/命令(Command)选择引脚，设置为输出；</span><br><span class="line">GPG5作为SPI的MISO，设置为输入（实际用不到）；</span><br><span class="line">GPG6作为SPI的MOSI，设置为输出；</span><br><span class="line">GPG7作为SPI的时钟CLK，设置为输出；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/21.png" alt="img"></p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/22.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* GPF1 as OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);<span class="comment">//取消OLED_CSn片选，pull up</span></span><br><span class="line">   <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//取消FLASH_CSn 片选，pull up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-3-2-2-xie-ming-ling">3.3.2.2 写命令</span><a href="#3-3-2-2-xie-ming-ling" class="header-anchor">#</a></h4><p>D&#x2F;C即数据(Data)&#x2F;命令(Command)选择引脚，它为高电平时，OLED即认为收到的是数据；它为低电平时，OLED即认为收到的是命令。先设置为命令模式，再片选OLED，再传输命令，再恢复成原来的模式和取消片选。</p>
<p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/23.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  gpio output default is pull up*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>拉低DC引脚表示要发送是命令；</p>
</li>
<li><p>片选</p>
</li>
<li><p>发送1byte数据</p>
</li>
</ol>
<h5><span id="3-3-2-2-1-spisendbyte">3.3.2.2.1 SPISendByte</span><a href="#3-3-2-2-1-spisendbyte" class="header-anchor">#</a></h5><p><img src="/2024/04/18/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-SPI/24.png" alt="img"><br>SPISendByte是把一个byte数据从高位往低位依次发送到DO。spi配置模式0， 主控先设置CLK为低，由于是MSB, 先传送高位，然后CLK为高，在CLK这个上升沿,DO的数据被锁存，OLED就读取了一位数据。接着左移一位，传输下一位。通过SPI_Set_CLK()和SPI_Set_DO()配置SCK和DO的时序，用gpio模拟出了spi。至此，SPI初始化和OLED初始化就基本完成了，接下来就是OLED显示部分。</p>
<p>这里gpio模拟spi传送时主控没有加延时控制SCK的频率，那是由于s3c2440本身cpu运行就很慢，这里不延时也是能满足该款外设的spi传输时序，如果cpu很快，那么需要控制spi时序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每隔一个SPI时钟，发送1位数据，MSB-高位先出</span></span><br><span class="line"><span class="comment">//这里的SPI时钟并没有指定周期，这就取决于指令执行的速率，指令执行越快，gpio模拟的SPI时钟越快,如下：     </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">              SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">              SPI_Set_DO(val &amp; <span class="number">0x80</span>);<span class="comment">//MSB</span></span><br><span class="line">              SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">              val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>取消片选</li>
<li>DC拉高</li>
</ol>
<h4><span id="3-3-2-3-xie-shu-ju">3.3.2.3 写数据</span><a href="#3-3-2-3-xie-shu-ju" class="header-anchor">#</a></h4><p>与写命令同理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span>&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data*/</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line">    SPISendByte(data);</span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-3-oled-c">3.2.3 oled.c</span><a href="#3-2-3-oled-c" class="header-anchor">#</a></h3><h4><span id="3-2-3-1-chu-shi-hua-oled">3.2.3.1 初始化OLED</span><a href="#3-2-3-1-chu-shi-hua-oled" class="header-anchor">#</a></h4><p>找到<strong>QG-2864TMBEG01</strong> 的power on sequence-上电时序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="3-2-3-2-qu-dong-xian-shi-oled">3.2.3.2 驱动显示OLED</span><a href="#3-2-3-2-qu-dong-xian-shi-oled" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i]) &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>) &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++) &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-4-wan-zheng-dai-ma">3.3.4 完整代码</span><a href="#3-3-4-wan-zheng-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************** gpio_spi.c ****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="comment">/* 用GPIO模拟SPI */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_GPIO_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* GPF1 OLED_CSn output */</span></span><br><span class="line">    GPFCON &amp;= ~(<span class="number">3</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFCON |= (<span class="number">1</span>&lt;&lt;(<span class="number">1</span>*<span class="number">2</span>));</span><br><span class="line">    GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* GPG2 FLASH_CSn output</span></span><br><span class="line"><span class="comment">    * GPG4 OLED_DC   output</span></span><br><span class="line"><span class="comment">    * GPG5 SPIMISO   input</span></span><br><span class="line"><span class="comment">    * GPG6 SPIMOSI   output</span></span><br><span class="line"><span class="comment">    * GPG7 SPICLK    output</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    GPGCON &amp;= ~((<span class="number">3</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">5</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">3</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGCON |= ((<span class="number">1</span>&lt;&lt;(<span class="number">2</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">4</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">6</span>*<span class="number">2</span>)) | (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>*<span class="number">2</span>)));</span><br><span class="line">    GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_CLK</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">SPI_Set_DO</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPISendByte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI_Set_CLK(<span class="number">0</span>);</span><br><span class="line">        SPI_Set_DO(val &amp; <span class="number">0x80</span>);</span><br><span class="line">        SPI_Set_CLK(<span class="number">1</span>);</span><br><span class="line">        val &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">SPIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化引脚 */</span></span><br><span class="line">    SPI_GPIO_Init();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/******************* oled.c****************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;oledfont.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gpio_spi.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_DC</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLED_Set_CS</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val)</span><br><span class="line">        GPFDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        GPFDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteCmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">0</span>); <span class="comment">/* command */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(cmd);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDWriteDat</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/* data */</span></span><br><span class="line">    OLED_Set_CS(<span class="number">0</span>); <span class="comment">/* select OLED */</span></span><br><span class="line"> </span><br><span class="line">    SPISendByte(dat);</span><br><span class="line"> </span><br><span class="line">    OLED_Set_CS(<span class="number">1</span>); <span class="comment">/* de-select OLED */</span></span><br><span class="line">    OLED_Set_DC(<span class="number">1</span>); <span class="comment">/*  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPageAddrMode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x20</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x02</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDSetPos</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col)</span></span><br><span class="line">&#123;</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span> + page); <span class="comment">/* page address */</span></span><br><span class="line"> </span><br><span class="line">    OLEDWriteCmd(col &amp; <span class="number">0xf</span>);   <span class="comment">/* Lower Column Start Address */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span> + (col &gt;&gt; <span class="number">4</span>));   <span class="comment">/* Lower Higher Start Address */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">OLEDClear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> page, i;</span><br><span class="line">    <span class="keyword">for</span> (page = <span class="number">0</span>; page &lt; <span class="number">8</span>; page ++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDSetPos(page, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line">            OLEDWriteDat(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 向OLED发命令以初始化 */</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAE</span>); <span class="comment">/*display off*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>); <span class="comment">/*set lower column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x10</span>); <span class="comment">/*set higher column address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x40</span>); <span class="comment">/*set display start line*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xB0</span>); <span class="comment">/*set page address*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x81</span>); <span class="comment">/*contract control*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x66</span>); <span class="comment">/*128*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA1</span>); <span class="comment">/*set segment remap*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA6</span>); <span class="comment">/*normal / reverse*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xA8</span>); <span class="comment">/*multiplex ratio*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x3F</span>); <span class="comment">/*duty = 1/64*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xC8</span>); <span class="comment">/*Com scan direction*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD3</span>); <span class="comment">/*set display offset*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x00</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD5</span>); <span class="comment">/*set osc division*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x80</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xD9</span>); <span class="comment">/*set pre-charge period*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x1f</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xDA</span>); <span class="comment">/*set COM pins*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x12</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0xdb</span>); <span class="comment">/*set vcomh*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x30</span>);</span><br><span class="line">    OLEDWriteCmd(<span class="number">0x8d</span>); <span class="comment">/*set charge pump enable*/</span></span><br><span class="line">    OLEDWriteCmd(<span class="number">0x14</span>);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPageAddrMode();</span><br><span class="line"> </span><br><span class="line">    OLEDClear();</span><br><span class="line">     </span><br><span class="line">    OLEDWriteCmd(<span class="number">0xAF</span>); <span class="comment">/*display ON*/</span>   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPutChar</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 得到字模 */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *dots = oled_asc2_8x16[c - <span class="string">&#x27; &#x27;</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 发给OLED */</span></span><br><span class="line">    OLEDSetPos(page, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i]);</span><br><span class="line"> </span><br><span class="line">    OLEDSetPos(page+<span class="number">1</span>, col);</span><br><span class="line">    <span class="comment">/* 发出8字节数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        OLEDWriteDat(dots[i+<span class="number">8</span>]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* page: 0-7</span></span><br><span class="line"><span class="comment"> * col : 0-127</span></span><br><span class="line"><span class="comment"> * 字符: 8x16象素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLEDPrint</span><span class="params">(<span class="type">int</span> page, <span class="type">int</span> col, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (str[i])</span><br><span class="line">    &#123;</span><br><span class="line">        OLEDPutChar(page, col, str[i]);</span><br><span class="line">        col += <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">if</span> (col &gt; <span class="number">127</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            col = <span class="number">0</span>;</span><br><span class="line">            page += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-UART体系</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-uart-ying-jian-jie-shao">1 uart硬件介绍</a></li>
<li><a href="#2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</a></li>
<li><a href="#3-uart-chuan-shu-yuan-li">3 UART传输原理</a><ul>
<li><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</a><ul>
<li><a href="#3-1-1-rs232">3.1.1 RS232</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-uart-kong-zhi-qi">4 UART控制器</a></li>
<li><a href="#5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</a><ul>
<li><a href="#5-1-chu-shi-hua-uart">5.1 初始化UART</a><ul>
<li><a href="#5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</a></li>
<li><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</a><ul>
<li><a href="#5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</a></li>
<li><a href="#5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</a></li>
<li><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-putchar-getchar">5.2 putchar&#x2F;getchar</a></li>
<li><a href="#5-3-puts">5.3 puts</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-uart-ying-jian-jie-shao">1 uart硬件介绍</span><a href="#1-uart-ying-jian-jie-shao" class="header-anchor">#</a></h1><p>UART的全称是Universal Asynchronous Receiver and Transmitter（异步收发器)。 uart主要用于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.打印调试</span><br><span class="line">2.数据传输</span><br></pre></td></tr></table></figure>
<p>串口通过三根线即可，发送、接收、地线。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/1.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pc的TxD -&gt; arm的RxD (UART write)</span><br><span class="line">arm的TxD -&gt; pc的RxD  (UART <span class="built_in">read</span>)</span><br></pre></td></tr></table></figure>
<h1><span id="2-uart-de-can-shu-he-ge-shi">2 uart的参数和格式</span><a href="#2-uart-de-can-shu-he-ge-shi" class="header-anchor">#</a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">波特率：表示每秒传输多少bit，bits per second(bps).一般波特率都会有9600,19200,115200等选项。</span><br><span class="line">起始位: 先发出一个逻辑”0”的信号，表示传输数据的开始。</span><br><span class="line">数据位：可以是5~8位逻辑”0”或”1”。一般7位，刚好可以传输所有ASCII码。</span><br><span class="line">校验位：</span><br><span class="line">	奇校验：（校验位+数据位）使得“1”的位数为奇数</span><br><span class="line">	偶校验：（校验位+数据位）使得“1”的位数为偶数</span><br><span class="line">	举个栗子：</span><br><span class="line">	‘A’的ASCII值是0x41,二进制就是01000001,那么奇校验就在校验位写‘1’,偶校验就在校验位写‘0’	</span><br><span class="line">停止位：它是一个字符数据的结束标志。</span><br></pre></td></tr></table></figure>
<h1><span id="3-uart-chuan-shu-yuan-li">3 UART传输原理</span><a href="#3-uart-chuan-shu-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-ru-he-chuan-shu-yi-ge-zi-fu-a">3.1 如何传输一个字符A</span><a href="#3-1-ru-he-chuan-shu-yi-ge-zi-fu-a" class="header-anchor">#</a></h2><p>‘A’的ASCII值是0x41#,二进制就是01000001，怎样把这8位数据发送给PC机呢？</p>
<pre><code>1.双方约定好波特率（每一位占据的时间）
2.规定传输协议
</code></pre>
<p>现在处于这种模式：arm的TxD -&gt; pc的RxD  (UART read)</p>
<pre><code>1.arm拉低uart总线1bit的时间（起始位）
2.arm根据数据位依次驱动TxD的电平，同时PC依次读取uart总线，数据到达PC的RxD引脚，pc依次获得数据位
</code></pre>
<p>为了能够进行远距离的传输数据，我们的PC是使用的RS-232逻辑电平，而arm开发板使用的TTL&#x2F;CMOS逻辑电平。这里先讲解下什么是TTL逻辑电平，什么是RS-232逻辑电平。</p>
<p>TTL&#x2F;CMOS逻辑电平：</p>
<pre><code>0（低电平0-0.7v）表示逻辑&#39;0&#39;
1（高电平2-5v）  表示逻辑&#39;1&#39;
</code></pre>
<p>RS-232逻辑电平：</p>
<pre><code>(+3V ~ +12V) 表示逻辑&#39;0&#39;
(-12V ~ -3V) 表示逻辑&#39;1&#39;
</code></pre>
<p>TTL逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/2.jpg"><br>RS232逻辑电平的波形：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/3.jpg"></p>
<p>那么在起始信号开始后开始计时，arm每隔一个时钟往TxD放1bit数据，同时pc也从RxD get 1bit数据.</p>
<pre><code>    arm				pc
TxD=data[0:]，    data[0:]=RxD
TxD=data[1:]，    data[1:]=RxD
...	
TxD=data[7:]，    data[7:]=RxD
</code></pre>
<h3><span id="3-1-1-rs232">3.1.1 RS232</span><a href="#3-1-1-rs232" class="header-anchor">#</a></h3><p>我们知道RS232的逻辑’0’和逻辑’1’相差较大，比TTL&#x2F;CMOS差距大，那么逻辑电平不容易出现反转，能传输更远的距离，在工业上用得比较多。</p>
<p>所以我们上面PC拿到的数据是不对的,那么需要一个TTL转RS232的电平转换芯片。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/4.jpg"></p>
<h1><span id="4-uart-kong-zhi-qi">4 UART控制器</span><a href="#4-uart-kong-zhi-qi" class="header-anchor">#</a></h1><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/5.png"></p>
<p>发送数据：<br>    内存将数据放入发送FIFO（64byte），通过发送移位器将数据一位一位的依次发送到TXDn，这样PC就可以从总线上依次get到数据。</p>
<p>接收数据：<br>    当pc的TXDn端将数据发送到总线后，arm获取RXDn的引脚电平依次get到数据，逐位放进接收移位器，再放入FIFO，写入内存。</p>
<p>当然,也可不使用fifo,直接让内存与移位器交互，不过这样会造成浪费内存资源，内存的频率是很高滴，降低了内存的吞吐量。</p>
<h1><span id="5-uart-kong-zhi-qi-bian-cheng">5 UART控制器编程</span><a href="#5-uart-kong-zhi-qi-bian-cheng" class="header-anchor">#</a></h1><p>s3c2440支持3个UART串口，以uart0为例讲解。<br>那么我们需要实现以下这几个函数完成串口的最基本功能：	</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）uart0_init()用于初始化串口</span><br><span class="line">（<span class="number">2</span>）<span class="built_in">putchar</span>()用于发送一个字符</span><br><span class="line">（<span class="number">3</span>）getchar()用于接收一个字符</span><br><span class="line">（<span class="number">4</span>）<span class="built_in">puts</span>()用于发送一串字符</span><br></pre></td></tr></table></figure>

<h2><span id="5-1-chu-shi-hua-uart">5.1 初始化UART</span><a href="#5-1-chu-shi-hua-uart" class="header-anchor">#</a></h2><h3><span id="5-1-1-yin-jiao-chu-shi-hua">5.1.1 引脚初始化</span><a href="#5-1-1-yin-jiao-chu-shi-hua" class="header-anchor">#</a></h3><p>配置uart0引脚</p>
<ol>
<li>根据原理图GPH2,3用于TxD0, RxD0。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/6.png"></li>
<li>查看dataset,配置GPH控制寄存器，让GPH2,3配成uart模式；为了将其保持为高电平，先设置其为上拉。<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GPHCON &amp;= ~((<span class="number">3</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">3</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHCON |= ((<span class="number">2</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">2</span>&lt;&lt;<span class="number">6</span>));</span><br><span class="line">GPHUP &amp;= ~((<span class="number">1</span>&lt;&lt;<span class="number">2</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>));  <span class="comment">/* 使能内部上拉 */</span></span><br></pre></td></tr></table></figure>
<img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/7.png"></li>
</ol>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/8.png"></p>
<h3><span id="5-1-2-uart-kong-zhi-qi-chu-shi-hua">5.1.2 UART控制器初始化</span><a href="#5-1-2-uart-kong-zhi-qi-chu-shi-hua" class="header-anchor">#</a></h3><h4><span id="5-1-2-1-she-zhi-shi-zhong-yuan">5.1.2.1 设置时钟源</span><a href="#5-1-2-1-she-zhi-shi-zhong-yuan" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">UCON0 = <span class="number">0x00000005</span>; <span class="comment">/* 时钟源选择PCLK,中断/查询模式 */</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/9.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/10.png"></p>
<h4><span id="5-1-2-2-she-zhi-bo-te-lu">5.1.2.2 设置波特率</span><a href="#5-1-2-2-she-zhi-bo-te-lu" class="header-anchor">#</a></h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* uart clock=50M，假设我们想要波特率=115200，</span></span><br><span class="line"><span class="comment">** 根据公式UBRDIVn = (int)(UART clock/( buad rate x 16) ) –1</span></span><br><span class="line"><span class="comment">** 得到UBRDIVn = (int)( 50000000 / ( 115200 x 16) ) –1 = 26</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">UBRDIV0 = <span class="number">26</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/11.png"></p>
<h4><span id="5-1-2-3-she-zhi-shu-ju-ge-shi">5.1.2.3 设置数据格式</span><a href="#5-1-2-3-she-zhi-shu-ju-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/12.png"><br>数据格式设置为常用的8n1，表示8个数据位, 无较验位, 1个停止位</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ULCON0 = <span class="number">0x00000003</span>; <span class="comment">/* 8n1: 8个数据位（数据+校验）, 无较验位, 1个停止位 */</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-2-putchar-x2f-getchar">5.2 putchar&#x2F;getchar</span><a href="#5-2-putchar-x2f-getchar" class="header-anchor">#</a></h2><pre><code>putchar就是向发送寄存器(UTXH0)写入值进去。
getchar就是从接受寄存器(URXH0)取出值。
无论是getchar还是putchar都可以通过读取状态寄存器（UTRSTAT0）来作为传输结束判断标志。
</code></pre>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-UART%E4%BD%93%E7%B3%BB/13.png"></p>
<pre><code>查询其第2位判断发送buff是否为空，即上一次发送是否完成，如果完成即向UTXH0写入要发送的新数据；
查询其第0位判断接收buff是否有数据接受到，如果有数据接收到，返回接收buffer的值。
</code></pre>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">putchar</span>(<span class="params"><span class="built_in">int</span> c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)));</span><br><span class="line">	UTXH0 = (unsigned <span class="built_in">char</span>)c;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">getchar</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!(UTRSTAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)));</span><br><span class="line">	<span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-3-puts">5.3 puts</span><a href="#5-3-puts" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">puts</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s)&#123;</span><br><span class="line">		putchar(*s);</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>通信协议</tag>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
        <tag>boot启动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-nandflash</title>
    <url>/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nandflash-yuan-li">1 nandflash原理</a><ul>
<li><a href="#1-1-yuan-li-tu">1.1 原理图</a></li>
<li><a href="#1-2-yin-jiao-miao-shu">1.2 引脚描述</a></li>
<li><a href="#1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</a><ul>
<li><a href="#1-3-1-block-kuai">1.3.1 Block块</a></li>
<li><a href="#1-3-2-page-ye">1.3.2 Page页</a></li>
<li><a href="#1-3-3-oob-qu-yu">1.3.3 oob区域</a></li>
<li><a href="#1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</a></li>
</ul>
</li>
<li><a href="#1-4-feature-te-xing">1.4 Feature特性</a></li>
<li><a href="#1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</a></li>
</ul>
</li>
<li><a href="#2-nand-kong-zhi-qi">2 Nand控制器</a><ul>
<li><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</a></li>
<li><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</a></li>
</ul>
</li>
<li><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</a><ul>
<li><a href="#3-1-ming-ling-di-zhi-suo-cun-shi-xu-xie-ming-ling-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</a><ul>
<li><a href="#3-1-1-k9f2g08u0c-ming-ling-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</a></li>
</ul>
</li>
<li><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</a></li>
<li><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</a></li>
</ul>
</li>
<li><a href="#4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</a><ul>
<li><a href="#4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</a></li>
<li><a href="#4-2-du-id-shi-xu">4.2 读ID时序</a></li>
<li><a href="#4-3-chu-shi-hua">4.3 初始化</a><ul>
<li><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</a><ul>
<li><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</a></li>
<li><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-4-shi-bie-nandflash">4.4 识别nandflash</a><ul>
<li><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</a></li>
<li><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</a><ul>
<li><a href="#5-1-du-shu-ju">5.1 读数据</a><ul>
<li><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</a></li>
<li><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</a></li>
</ul>
</li>
<li><a href="#5-2-ca-shu-ju">5.2 擦数据</a></li>
<li><a href="#5-3-xie-shu-ju">5.3 写数据</a></li>
<li><a href="#5-4-ce-shi">5.4 测试</a></li>
<li><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nandflash-yuan-li">1 nandflash原理</span><a href="#1-nandflash-yuan-li" class="header-anchor">#</a></h1><h2><span id="1-1-yuan-li-tu">1.1 原理图</span><a href="#1-1-yuan-li-tu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/1.png"></p>
<h2><span id="1-2-yin-jiao-miao-shu">1.2 引脚描述</span><a href="#1-2-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/2.png"></p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>IO0~IO7</td>
<td>数据输入输出（命令、地址、数据共用数据总线）</td>
</tr>
<tr>
<td>CLE</td>
<td>命令使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址使能</td>
</tr>
<tr>
<td>&#x2F;CE</td>
<td>芯片使能（片选）</td>
</tr>
<tr>
<td>&#x2F;RE</td>
<td>读使能</td>
</tr>
<tr>
<td>&#x2F;WE</td>
<td>写使能</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号（低电平表示操作还在进行中，高电平表示操作完成）</td>
</tr>
</tbody></table>
<h2><span id="1-3-nand-cun-chu-jie-gou">1.3 nand存储结构</span><a href="#1-3-nand-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/3.png"></p>
<p>我们常见的Nand Flash，内部只有一个chip，每个chip只有一个plane。但也有些复杂的，容量更大的Nand Flash，内部有多个chip，每个chip有多个plane，这类的Nand Flash，其实就是多了一个主控将多块flash叠加在一起，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/4.png"></p>
<h3><span id="1-3-1-block-kuai">1.3.1 Block块</span><a href="#1-3-1-block-kuai" class="header-anchor">#</a></h3><p>一个Nand Flash由很多个块（Block）组成，块的大小一般有64K，128KB，256KB，512KB，<strong>Block是Nand Flash的擦除操作的基本&#x2F;最小单位</strong>。Nand Flash中，一个块中含有1个或多个位是坏的，就称为其为<strong>坏块Bad Block</strong>。</p>
<h3><span id="1-3-2-page-ye">1.3.2 Page页</span><a href="#1-3-2-page-ye" class="header-anchor">#</a></h3><p>每个块里面又包含了很多页（page）。每个页的大小，对于现在常见的Nand Flash多数是2KB，当然也有的nand flash的页大小为4KB、8KB等。<strong>页Page，是读写操作的基本单位</strong>。</p>
<h3><span id="1-3-3-oob-qu-yu">1.3.3 oob区域</span><a href="#1-3-3-oob-qu-yu" class="header-anchor">#</a></h3><p>每一个page页，对应还附加了一块区域，一般为64byte，叫做空闲区域（spare area）&#x2F;oob区域（Out Of Band），由于nandflash在操作过程中容易产生位反转，这是nandflash的物理特性决定的，所以必须要有对应的检测和纠错机制，这种机制被叫做Error Checking and Correcting，所以设计了多余的oob区域，<strong>用于放置数据的校验值</strong>。oob的读写操作，一般是随着页的操作一起完成的，即读写页的时候，对应地就读写了oob。</p>
<p>关于oob具体用途，总结起来有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标记是否是坏快</span><br><span class="line">存储ECC数据</span><br><span class="line">存储一些和文件系统相关的数据。如jffs2就会用到这些空间存储一些特定信息</span><br></pre></td></tr></table></figure>

<h3><span id="1-3-4-cun-chu-dan-wei-guan-xi">1.3.4 存储单位关系</span><a href="#1-3-4-cun-chu-dan-wei-guan-xi" class="header-anchor">#</a></h3><p>一般情况下：1block &#x3D; 64page &#x3D; 64 * (2K+64B) &#x3D; 128K + 4K， 一个page包含2K数据和64B的oob。</p>
<h2><span id="1-4-feature-te-xing">1.4 Feature特性</span><a href="#1-4-feature-te-xing" class="header-anchor">#</a></h2><p>以<strong>K9F2G08U0C</strong>这款nandflash为例：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/5.png"></p>
<p>可以看出此款nandflash特性如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 容量为<span class="number">256</span>M，外加<span class="number">8</span>M的冗余oob存储区。</span><br><span class="line"><span class="number">2.</span> page大小为<span class="number">2</span>K，block大小为<span class="number">128</span>K</span><br><span class="line"><span class="number">3.</span> 读一个page时顺序读取至少<span class="number">25</span>*<span class="number">2048</span>ns(数据可以每字节<span class="number">25</span>ns的循环时间读出)，随机读取不超过<span class="number">40u</span>s</span><br><span class="line"><span class="number">4.</span> 写一个page一般为<span class="number">250u</span>s</span><br><span class="line"><span class="number">5.</span> 擦除一个block一般为<span class="number">2</span>ms</span><br><span class="line"><span class="number">6.</span> 封装上分为TSOP分装和FBGA封装（TSOP是指引脚在侧面，FBGA是引脚封在芯片底部，更能保障数据安全，有些客户为了保障数据安全性，防止被飞线进行数据破解，会要求用FBGA封装的flash）</span><br></pre></td></tr></table></figure>

<h2><span id="1-5-chang-jian-de-flash-han-shang">1.5 常见的flash厂商</span><a href="#1-5-chang-jian-de-flash-han-shang" class="header-anchor">#</a></h2><p>常见的flash厂商有：Micron（镁光）、Toshiba（东芝）、Samsung（三星）、MXIC(旺宏)、dosilicon(东芯)，（Winbond）华邦、ESMT等。</p>
<h1><span id="2-nand-kong-zhi-qi">2 Nand控制器</span><a href="#2-nand-kong-zhi-qi" class="header-anchor">#</a></h1><p>前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>介绍讲到，我们知道nand没有独立地址线，cpu无法直接访问nand上的指令，所以nand不能片上执行。那么为何程序还能支持nand启动的呢？</p>
<p>为了支持NAND启动，S3C2440A配备了一个称为“ Steppingstone”的内部SRAM缓冲区,容量为4K。 开机时，Nandflash中的前4K数据将被加载到Steppingstone中，而引导代码将被加载到SRAM中将被执行，如下图所示：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/6.png"></p>
<h2><span id="2-1-om-qi-dong-jie-zhi-xuan-ze">2.1 OM启动介质选择</span><a href="#2-1-om-qi-dong-jie-zhi-xuan-ze" class="header-anchor">#</a></h2><p>我们知道s3c2440支持2种boot方式，nand或者nor，那么需要配置OM引脚来设置引导方式，如下图：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/7.png"></p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/8.png"></p>
<p>内存控制器的地址映射表如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/9.png"></p>
<p>当SW2闭合,OM0&#x3D;1, OM[1:0]&#x3D;01, 0地址对应nor，那么从nor启动。<br>当SW2断开,OM0&#x3D;0, OM[1:0]&#x3D;00, 0地址对应bootSRAM(4K)，那么0地址对应该SRAM, 那么从nand启动。</p>
<h2><span id="2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi">2.2 nand控制器引脚配置</span><a href="#2-2-nand-kong-zhi-qi-yin-jiao-pei-zhi" class="header-anchor">#</a></h2><p>当上电启动时，NAND Flash 控制器将通过下面的引脚配置来获取连接的 NAND Flash 的信息。</p>
<p><strong>NCON</strong>：NAND Flash 存储器选择（普通&#x2F;先进）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：普通 NAND Flash（<span class="number">256</span> 字或 <span class="number">512</span> 字节页大小，<span class="number">3</span> 或 <span class="number">4</span> 个地址周期）</span><br><span class="line"><span class="number">1</span>：先进 NAND Flash（<span class="number">1</span>K 字或 <span class="number">2</span>K 字节页大小，<span class="number">4</span> 或 <span class="number">5</span> 个地址周期）</span><br></pre></td></tr></table></figure>

<p><strong>GPG13</strong>：NAND Flash 存储器page size选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：页=<span class="number">256</span> 字（NCON=<span class="number">0</span>）或页=<span class="number">1</span>K 字（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：页=<span class="number">512</span> 字节（NCON=<span class="number">0</span>）或页=<span class="number">2</span>K 字节（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<p><strong>GPG14</strong>：NAND Flash 存储器地址周期选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">3</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">4</span> 个地址周期（NCON=<span class="number">1</span>）</span><br><span class="line"><span class="number">1</span>：<span class="number">4</span> 个地址周期（NCON=<span class="number">0</span>）或 <span class="number">5</span> 个地址周期（NCON=<span class="number">1</span>）</span><br></pre></td></tr></table></figure>
<p><strong>GPG15</strong>：NAND Flash 存储器总线宽度选择</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>：<span class="number">8</span> 位宽度</span><br><span class="line"><span class="number">1</span>：<span class="number">16</span> 位宽度</span><br></pre></td></tr></table></figure>
<p>如下表所示更直观:<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/10.png"></p>
<h1><span id="3-nand-kong-zhi-qi-fang-wen-shi-xu">3 Nand控制器访问时序</span><a href="#3-nand-kong-zhi-qi-fang-wen-shi-xu" class="header-anchor">#</a></h1><p>nandflash访问时需要遵循一定的时序才能完成命令、地址、数据的发送。nandflash有8bit位宽数据总线，那么没有地址线它是怎么和cpu通信的呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>nandflash是DATA0～DATA7上既传输数据，又传输地址，又传输命令；</span><br><span class="line">	①当ALE为高电平时传输的是地址；</span><br><span class="line">	②当CLE为高电平时传输的是命令；</span><br><span class="line">	③当ALE，CLE都为低电平表示传输的是数据</span><br><span class="line"></span><br><span class="line"> <span class="number">2.</span> 先发送片选CS和WE/RE信号</span><br><span class="line"> <span class="number">3.</span> 再发送CLE</span><br><span class="line"> <span class="number">4.</span> 再发送ALE</span><br><span class="line"> <span class="number">5.</span> 最后发送数据</span><br></pre></td></tr></table></figure>

<p>下面分别介绍命令、地址、数据的发送过程。</p>
<h2><span id="3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi">3.1 命令&#x2F;地址锁存时序(写命令&#x2F;地址)</span><a href="#3-1-ming-ling-x2f-di-zhi-suo-cun-shi-xu-xie-ming-ling-x2f-di-zhi" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/11.png"></p>
<ol>
<li>首先看时钟，nand控制器的时钟源采用的是HCLK, 也就是AHB高速总线模式，可以参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a>那么HCLK&#x3D;100Mhz, T&#x3D;1&#x2F;HCLK&#x3D;10ns。</li>
<li>从上图可知命令、地址锁存的时序是一样的，复用一个时序图，当到达①的位置时，CLE&#x2F;ALE&#x3D;0; </li>
<li>当到达位置②时，CLE&#x2F;ALE&#x3D;1,表示命令&#x2F;地址信号拉高，命令&#x2F;地址开始使能，然后往数据总线DATA上放入命令或地址;</li>
<li>经过TACLS时间，到达位置③时，拉低nWE引脚，这时数据总线DATA上的命令&#x2F;地址开始被锁存，锁存需要一定的时间，所以经过TWRPH0时间后，数据总线DATA上的命令&#x2F;地址锁存完成；</li>
<li>到达位置④，此时释放nWE信号，nWE&#x3D;1，这时还需要经过TWRPH1时间后，释放CLE&#x2F;ALE，此时一个完整的命令&#x2F;地址锁存过程完成。</li>
</ol>
<p>上面分析了命令&#x2F;地址的锁存时序过程，下面详细解释下上面几个时间参数的含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TACLS：CLE/ALE使能信号发送多久后才可以发送nWE信号</span><br><span class="line">TWRPH0:nWE信号发送多久后数据（commamd/addr）才会被锁存成功</span><br><span class="line">TWRPH1：nWE信号释放多久后才能释放CLE/ALE</span><br></pre></td></tr></table></figure>

<p>这些时间参数要根据我们实际使用的具体nandflash型号和性能来配置我们的nand控制器。</p>
<h3><span id="3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu">3.1.1 K9F2G08U0C命令&#x2F;地址锁存时序</span><a href="#3-1-1-k9f2g08u0c-ming-ling-x2f-di-zhi-suo-cun-shi-xu" class="header-anchor">#</a></h3><p>以K9F2G08U0C这款nandflash为例进行讲解，规格书上命令和地址锁存周期如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/12.png"></p>
<p>和nand控制器的命令&#x2F;地址锁存时序图对比发现:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TACLS = max(tCLS,tALS) - tWP;</span><br><span class="line">TWRPH0 = tWP;</span><br><span class="line">TWRPH0 = max(tCLH,tALH);</span><br></pre></td></tr></table></figure>

<p>nand控制器把命令、地址锁存时序复用成了一个时序图，其实命令和地址锁存时序参数基本一致，只不过发命令只需要一个周期就OK了，发地址需要5个时钟周期，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你想，命令多简单，无非就是读写擦，像我们这款nand数据位宽8bit，一个周期绰绰有余。但地址就不一样了，比如此款nandflash容量256M = 2^28，那么需要28根数据线来传输才能一个周期传输完，但这款nandflash的数据总线位宽只有8bit, 只有8根数据线，所以需要把地址拆分成多次发送，先发送col地址，再发送row地址，此款nandflash是用了5个周期发送地址。</span><br></pre></td></tr></table></figure>

<h2><span id="3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju">3.2 数据锁存时序(写数据)</span><a href="#3-2-shu-ju-suo-cun-shi-xu-xie-shu-ju" class="header-anchor">#</a></h2><p>从前面的命令地址锁存时序图中我们得知：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE信号拉高，ALE信号拉低时，表示发送的命令；</span><br><span class="line">CLE信号拉低，ALE信号拉高时，表示发送的地址；</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/13.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE信号拉低, ALE信号拉低时，表示发送的数据;</span><br></pre></td></tr></table></figure>

<ol>
<li>当到达①时，nWE还是高电平，写使能没有开启；</li>
<li>当到达②,③时，那么经过了tWP时间（TDS时间），数据开始被锁存；</li>
<li>到达④，经过tDH时间，数据锁存完成;</li>
<li>到达⑤，也就是数据开始锁存后再过了tWH时间后释放nWE信号；</li>
<li>重复②③④⑤过程,得到DIN0, DIN1, DIN final。</li>
</ol>
<p>根据上面这三个图（手册上的命令、地址、数据锁存时序图），下面详细解释各个时间参数的含义：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/14.png"></p>
<h2><span id="3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju">3.3 数据顺序读时序(读数据)</span><a href="#3-3-shu-ju-shun-xu-du-shi-xu-du-shu-ju" class="header-anchor">#</a></h2><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/15.png"></p>
<ol>
<li>①处，表示要过tRR后才能发送读使能信号nRE进行访问（上一次的访问结束后，需要等待ready状态稳定后才可以进行下一次访问）；</li>
<li>当到达②，需要经过rREA时间后nRE信号才有效（待nRE稳定）；</li>
<li>当到达③，DATA总线上的读取被读取；</li>
<li>当到达④，nRE释放tREH时间后才允许下一次读使能；</li>
</ol>
<p>我们看到连续顺序访问时，单次访问的时间为tRC，那么这些时间参数的值也可以从K9F2G08U0C datasheet中找到：为25ns</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/16.png"></p>
<h1><span id="4-nandflash-chu-shi-hua-he-shi-bie">4 nandFlash初始化和识别</span><a href="#4-nandflash-chu-shi-hua-he-shi-bie" class="header-anchor">#</a></h1><h2><span id="4-1-nandflash-ming-ling-biao">4.1 nandFlash命令表</span><a href="#4-1-nandflash-ming-ling-biao" class="header-anchor">#</a></h2><p>找到K9F2G08U0C datasheet，对NAND FLASH的操作需要发出命令，下面有个NAND FLASH的命令表格，用此表格上的命令来访问我们的nandflash：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/17.png"></p>
<h2><span id="4-2-du-id-shi-xu">4.2 读ID时序</span><a href="#4-2-du-id-shi-xu" class="header-anchor">#</a></h2><p>命令表中的读id还不太直观，下图是从nand芯片手册中截取出的读id时序图：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/18.png"></p>
<ol>
<li>第一条竖线位置，发送了nCE,CLE,nWE信号，所以90命令被锁存（readID命令）；</li>
<li>第二条竖线位置，发送了nCE,ALE,nWE信号，所以地址00被锁存；继续往后，命令、地址都发完了，要read数据了，所以释放nWE，ALE，这里tAR表示ALE释放多久后才可以发送nRE信号，tREA表示nRE信号的建立时间；</li>
<li>第三条竖线位置，发送了nCE,nRE信号，所以数据被锁存，第一个访问周期锁存的数据为marker code，值为0xEC，第二个访问周期的数据为device code，值为0xDA。读id时读5个周期含义对应如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/19.png"></li>
</ol>
<p>该款nandflash的5个周期读出来的值对应如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/20.png"></p>
<p>第四个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/21.png"></p>
<p>第五个访问周期含义如下表：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/22.png"></p>
<p>根据第4、5个访问周期的结果0x15、0x44我们得知该flash的block_size&#x3D;128K，page_size&#x3D;2k, 有2个plane，plane_size&#x3D;1Gb &#x3D; 128M, 共256M。</p>
<h2><span id="4-3-chu-shi-hua">4.3 初始化</span><a href="#4-3-chu-shi-hua" class="header-anchor">#</a></h2><h3><span id="4-3-1-chu-shi-hua-nand-kong-zhi-qi">4.3.1 初始化nand控制器</span><a href="#4-3-1-chu-shi-hua-nand-kong-zhi-qi" class="header-anchor">#</a></h3><h4><span id="4-3-1-1-nfconf-pei-zhi-ji-cun-qi">4.3.1.1 NFCONF-配置寄存器</span><a href="#4-3-1-1-nfconf-pei-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p>nand控制器要按照我们nandflash的实际型号和性能来设置初始值。NFCONF寄存器，也叫nand配置寄存器：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/23.png"></p>
<p>以K9F2G08U0C这款nandflash为例：</p>
<p>前面<strong>第3.1.1小节</strong>分析了TACLS &#x3D; max(tCLS,tALS) - tWP，我们得知tCLS、tALS、tWP最小都可以取到12ns, 所以我们可以取TACLS&#x3D;0；</p>
<p>TWRPH0 &#x3D; tWP，我们的nand手册上要求tWP最少12ns, 那么取TWRPH0 &#x3D;1， Duration &#x3D; HCLK*(TWRPH0+1)&#x3D;20ns&gt;12ns，满足要求；</p>
<p>TWRPH0 &#x3D; max(tCLH,tALH), 我们的nand手册上要求tCLH、tALH最少5ns， 那么取TWRPH1 &#x3D;0， Duration &#x3D; HCLK*(TWRPH1+1)&#x3D;10ns&gt;5ns，满足要求。</p>
<p>再配置BusWidth总线位宽为8bit；<br>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line"><span class="comment">/*设置NAND FLASH的时序*/</span></span><br><span class="line">NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h4><span id="4-3-1-2-nfcont-kong-zhi-ji-cun-qi">4.3.1.2 NFCONT-控制寄存器</span><a href="#4-3-1-2-nfcont-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/24.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MODE [<span class="number">0</span>]: 设置为<span class="number">1</span>，使能NAND控制器。</span><br><span class="line">Reg_nCE [<span class="number">1</span>]: 设置为<span class="number">1</span>，禁止片选（等要使用的时候再使能片选信号）</span><br></pre></td></tr></table></figure>

<p>所以NFCONF寄存器设置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*使能NAND FLASH控制器，禁止片选*/</span></span><br><span class="line">NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2><span id="4-4-shi-bie-nandflash">4.4 识别nandflash</span><a href="#4-4-shi-bie-nandflash" class="header-anchor">#</a></h2><h3><span id="4-4-1-nfcmmd-ming-ling-ji-cun-qi">4.4.1 NFCMMD-命令寄存器</span><a href="#4-4-1-nfcmmd-ming-ling-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/26.png"></p>
<p>我们可以使用2440上的NAND FLASH控制器简化操作，只需要往NFCMMD寄存器写入要传输的命令就可以了，NAND FLASH控制器默认把上面复杂的时序发出来。</p>
<p>NFADDR-地址寄存器<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/27.png"><br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/28.png"></p>
<p>发命令后，后面就需要发送地址了，当nWE和ALE有效的时候，表示锁存的是地址，往NFADDR寄存器中写值就可以了，比如：NFADDR&#x3D;0x00。<br>我们得知地址需要用5个周期来发送，前2个周期为col地址，后三个周期为row(page)地址。前面<strong>第3小节</strong>已详细分析过了命令、地址、数据锁存时序过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> column: 列地址A0~A10，就是页内地址，地址范围是从<span class="number">0</span>到<span class="number">2047</span>。（A11用来确定oob的地址，即<span class="number">2048</span><span class="number">-2111</span>这<span class="number">64</span>个字节的范围）</span><br><span class="line"><span class="number">2.</span> page：A12～A30，称作页号，page(row)编号。</span><br></pre></td></tr></table></figure>

<h3><span id="4-4-2-nfdata-shu-ju-ji-cun-qi">4.4.2 NFDATA-数据寄存器</span><a href="#4-4-2-nfdata-shu-ju-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/29.png"></p>
<p>当命令、地址都发送完后就可以从数据总线上DATA[7:0]获取数据或者写入数据。同样往NFDATA寄存器中写值或者读值就可以了，如unsigned char buf&#x3D;NFDATA,由于是数据位宽是8位的，所以访问时数据组织形式如下：</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/30.png"></p>
<p>从上图可以看出，当byte access时，只需一个时钟周期；当wold access的时候，需要4个时钟周期，小端模式下第一个时钟周期对应低字节，第四个时钟周期对应高字节。</p>
<p>识别nandflash代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*初始化nand控制器*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TACLS   0</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH0  1</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span>  TWRPH1  0</span></span><br><span class="line">	NFCONF = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	NFCONT = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使能片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_select</span><span class="params">(<span class="type">void</span>)</span> &#123;		</span><br><span class="line">	NFCONT &amp;=~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*禁止片选*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_deselect</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	NFCONT |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发命令*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> cmd)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFCCMD = cmd;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*发地址*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_addr_byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> addr)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> i;</span><br><span class="line">	NFADDR = addr;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*读数据*/</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">nand_data</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span>	NFDATA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*识别nandflash*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_chip_probe</span><span class="params">(<span class="type">void</span>)</span> &#123; </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	nand_select(); </span><br><span class="line">	nand_cmd(<span class="number">0x90</span>);</span><br><span class="line">	nand_addr_byte(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">	buf[<span class="number">0</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">1</span>] = nand_data();	</span><br><span class="line">	buf[<span class="number">2</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">3</span>] = nand_data();</span><br><span class="line">	buf[<span class="number">4</span>] = nand_data();	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;maker   id  = 0x%x\n\r&quot;</span>,buf[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;device  id  = 0x%x\n\r&quot;</span>,buf[<span class="number">1</span>]);	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;3rd byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">2</span>]);		</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;4th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">3</span>]);			</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;page  size  = %d kb\n\r&quot;</span>,<span class="number">1</span>  &lt;&lt;  (buf[<span class="number">3</span>] &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;block size  = %d kb\n\r&quot;</span>,<span class="number">64</span> &lt;&lt; ((buf[<span class="number">3</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x03</span>));	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;5th byte    = 0x%x\n\r&quot;</span>,buf[<span class="number">4</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="5-nandflash-shu-ju-cao-zuo">5 NandFlash数据操作</span><a href="#5-nandflash-shu-ju-cao-zuo" class="header-anchor">#</a></h1><h2><span id="5-1-du-shu-ju">5.1 读数据</span><a href="#5-1-du-shu-ju" class="header-anchor">#</a></h2><p>读数据以page为单位的。下图的表格，来说明NAND FLASH内部结构，前面2K(0<del>2047)表示页数据，后边64字节(2048</del>2111)表示oob。</p>
<p><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/31.png"></p>
<p>CPU想读取，第2048个数据，它是哪以一个？</p>
<pre><code>是Page1的第0个字节。CPU使用某个地址访问数据的时候，是在页数据空间来寻址的。
</code></pre>
<p>下图为读NAND FLASH的read时序操作：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/32.png"></p>
<ol>
<li>首先需要锁存00命令，nCE、CLE、nWE有效，0x00命令被锁存；</li>
<li>此时CLE无效，ALE开始有效,地址被锁存（从NAND FLASH的地址周期中可以看出来，先发出2个周期的col列地址，再发出3个周期的Row行地址）；</li>
<li>锁存0x30命令；</li>
<li>然后会有一个busy时间段，R&#x2F;nB为低电平。tRR表示busy状态的持续时间（手册上最小为20ns）。</li>
<li>开始锁存数据，nRE使能，nand上的数据被同步到数据nand控制器上。我们的nand是8bit数据位宽，所以每隔一个read时钟周期（tRC），传输1byte数据。每传输1byte数据，地址会自动往后偏移1byte，一般我们会连续读取1page数据。</li>
</ol>
<p>下面开始写代码：</p>
<h3><span id="5-1-1-nfstat-zhuang-tai-ji-cun-qi">5.1.1 NFSTAT-状态寄存器</span><a href="#5-1-1-nfstat-zhuang-tai-ji-cun-qi" class="header-anchor">#</a></h3><p>当发完命令、地址后再进行读数据前我们知道有一段时间tRR处于busy状态，我们可以通过查询NFSTAT寄存器来确定busy状态有没有结束，是不是已经ready了。<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/33.png"></p>
<p>wait_ready函数等待NAND FLASH空闲，从上图可以看出当NFSTAT寄存器[0]的值为1时NAND FLASH是空闲的，我们可以通过该位来判断NAND FLASH是否繁忙。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	 <span class="keyword">while</span> (!(NFSTAT &amp; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nand_read函数为NAND FLASH的读函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">		<span class="comment">/* 发出00h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">00</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 发出30h命令 */</span></span><br><span class="line">		nand_cmd(<span class="number">0x30</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 等待就绪 */</span></span><br><span class="line">		wait_ready();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 读数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)</span><br><span class="line">			buf[i++] = nand_data();			</span><br><span class="line">		</span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到每read一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h3><span id="5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong">5.1.2 自动识别是nor还是nand启动</span><a href="#5-1-2-zi-dong-shi-bie-shi-nor-huan-shi-nand-qi-dong" class="header-anchor">#</a></h3><p>在init.c文件中，加上如下代码，用来判断所使用的FLASH是NOR FLASH还是NAND FLASH。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*我们知道nand启动0地址对应片内SRAM，可以像内存一样的写0地址；nor启动，0地址对应nor,nor不能像内存一样的写地址，</span></span><br><span class="line"><span class="comment">**所以往0地址写入数据成功表示nand启动，写不成功表示nor启动</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isBootFromNorFlash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val = *p;</span><br><span class="line"></span><br><span class="line">	*p = <span class="number">0x12345678</span>;</span><br><span class="line">	<span class="keyword">if</span> (*p == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">		<span class="comment">/* 写成功, 对应nand启动 */</span></span><br><span class="line">		*p = val;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是代码重定位时可以自动区分nand和nor启动，无论是nand启动还是nor启动，都能将程序重定位到sdram中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">            <span class="comment">/* 要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line"><span class="comment">            * 然后从0地址把数据复制到__code_start</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> len = (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__bss_start) - (<span class="type">unsigned</span> <span class="type">int</span>)(&amp;__code_start);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (isBootFromNorFlash()) &#123;</span><br><span class="line">              <span class="keyword">while</span> (dest &lt; end)</span><br><span class="line">                    *dest++ = *src++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	    nand_init();</span><br><span class="line">    	    nand_read((<span class="type">unsigned</span> <span class="type">int</span>)src, dest, len);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="5-2-ca-shu-ju">5.2 擦数据</span><a href="#5-2-ca-shu-ju" class="header-anchor">#</a></h2><p>擦除数据以block为单位的。block erase时序图的过程大致如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/34.png"></p>
<pre><code>1.首先发送0x60命令
2.发送row地址（由于擦除是以block为单位的，所以无需知道页内地址，只需要知道要擦除哪个page、哪个block即可）
3.发送0xd0,执行擦除动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否擦除成功
</code></pre>
<p>代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_erase</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">		<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (addr &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, addr is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (len &amp; (<span class="number">0x1FFFF</span>)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, len is not block align\n\r&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_select(); </span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			page = addr / <span class="number">2048</span>;</span><br><span class="line">			</span><br><span class="line">			nand_cmd(<span class="number">0x60</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">/* page addr */</span></span><br><span class="line">			nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">			nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0xD0</span>);</span><br><span class="line">	</span><br><span class="line">			wait_ready();</span><br><span class="line">	</span><br><span class="line">			nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">			<span class="keyword">if</span> (nand_data()&amp;<span class="number">0x1</span>) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;nand_erase err, at addr:0x%x\n\r&quot;</span>, addr);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	</span><br><span class="line">			len -= (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">			<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			addr += (<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		nand_deselect(); 	</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-xie-shu-ju">5.3 写数据</span><a href="#5-3-xie-shu-ju" class="header-anchor">#</a></h2><p>写数据以page为单位。往NAND FLASH写数据时，只需要把要写的数据复制给NFDATA寄存器即可。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_w_data</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> val)</span> &#123;</span><br><span class="line">	NFDATA = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>page write的写时序图如下：<br><img src="/2024/04/17/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-nandflash/35.png"></p>
<pre><code>1.首先发送0x80命令
2.发送地址（5个周期）
3.发送数据
4.发送0x10命令，执行烧写动作
4.然后会有一个busy时间段，R/nB为低电平
5.发送0x70命令，用来读取状态
6.判断NFDATA寄存器的第0位是否烧写成功
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr, <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">	<span class="type">int</span> page = addr / <span class="number">2048</span>;</span><br><span class="line">	<span class="type">int</span> col  = addr &amp; (<span class="number">2048</span> - <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	nand_select(); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		nand_cmd(<span class="number">0x80</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出地址 */</span></span><br><span class="line">		<span class="comment">/* col addr */</span></span><br><span class="line">		nand_addr_byte(col &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((col&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* row/page addr */</span></span><br><span class="line">		nand_addr_byte(page &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">		nand_addr_byte((page&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 发出数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (; (col &lt; <span class="number">2048</span>) &amp;&amp; (i &lt; len); col++)  <span class="comment">//还需确认</span></span><br><span class="line">			nand_w_data(buf[i++]);</span><br><span class="line">		</span><br><span class="line">		nand_cmd(<span class="number">0x10</span>);</span><br><span class="line">		wait_ready();</span><br><span class="line">        </span><br><span class="line">		nand_cmd(<span class="number">0x70</span>);</span><br><span class="line">		<span class="keyword">if</span> (nand_data() &amp; <span class="number">0x1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;nand_write err, at page:0x%x, addr:0x%x\n\r&quot;</span>, page, page&lt;&lt;<span class="number">11</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i == len)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 开始下一个循环page */</span></span><br><span class="line">		col = <span class="number">0</span>;</span><br><span class="line">		page++;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	nand_deselect(); 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到每写一个page，都要重新发送命令地址，因为这里是顺序访问，flash的读写都是以page为单位的。</p>
<h2><span id="5-4-ce-shi">5.4 测试</span><a href="#5-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nand_erase(addr, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_read_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	nand_read(addr, buf, <span class="number">64</span>);</span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)buf;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 长度固定为64 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="comment">/* 每行打印16个数据 */</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 先打印数值 */</span></span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">			<span class="comment">/* 后打印字符 */</span></span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_write_nand_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line">	nand_write(addr, str, <span class="built_in">strlen</span>(str)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：本节的读、写、擦都只涉及到页数据区，不涉及到oob区的操作。</strong></p>
<h2><span id="5-5-pi-kuai-de-biao-ji-he-jie-chu">5.5 坏快的标记和解除</span><a href="#5-5-pi-kuai-de-biao-ji-he-jie-chu" class="header-anchor">#</a></h2><p>Nand Flash怎么标记某一个BLOCK是坏的? 如何识别一个flash中的坏快？ </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">它使用该BLOCK中第<span class="number">1</span>个扇区的OOB数据中某一个字节来标记: 其值为<span class="number">0xff</span>表示该BLOCK是好的， 其值为非<span class="number">0xff</span>表示该BLOCK是坏的。</span><br><span class="line">在uboot中直接输入“nand bad ”命令即可识别某一个块是否为坏快，在linux用户态的情况下，需要用ioctl(MEMGETBADBLOCK)来获取该block是否为坏快。</span><br><span class="line">有时候我们会误写这个OOB区的值导致有些BLOCK被误认为是<span class="string">&quot;坏块&quot;</span>,可以在u-boot中执行<span class="string">&quot;nand scrub&quot;</span>后, 根据提示信息输入小写字母<span class="string">&#x27;y&#x27;</span>并回车, 它会强制擦除整个Nand <span class="title function_">Flash</span><span class="params">(包括把OOB擦除为<span class="number">0xff</span>)</span>, 这样就可以恢复被误标为坏块的区域了。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
        <tag>存储驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-代码重定位和清bss</title>
    <url>/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</a><ul>
<li><a href="#1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</a></li>
<li><a href="#1-2-lian-jie-jiao-ben">1.2 链接脚本</a><ul>
<li><a href="#1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</a><ul>
<li><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</a></li>
<li><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</a></li>
</ul>
</li>
<li><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</a></li>
<li><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</a><ul>
<li><a href="#1-2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-qing-chu-bss">2 清除bss</a><ul>
<li><a href="#2-1-bss-duan-jie-shao">2.1 bss段介绍</a></li>
<li><a href="#2-2-qing-bss">2.2 清bss</a></li>
<li><a href="#2-3-qing-bss-you-hua">2.3 清bss优化</a><ul>
<li><a href="#2-3-1-strb-ldrb-ti-huan-cheng-str-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</a></li>
<li><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</a></li>
<li><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-wei-zhi-wu-guan-ma">3 位置无关码</a><ul>
<li><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</a><ul>
<li><a href="#3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</a></li>
<li><a href="#3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</a></li>
<li><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-yin-ru-dai-ma-chong-ding-wei">1 引入代码重定位</span><a href="#1-yin-ru-dai-ma-chong-ding-wei" class="header-anchor">#</a></h1><p>s3c2440的cpu默认是从0地址开始取指令执行，当从nor启动时,0地址对应nor, nor可以像内存一样读，但不能像内存一样写，前面<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a> 讲过，写入norflash要进行按照spec进行命令表写入。因此我们能够从nor上取指令执行。</p>
<p>当nand启动的时候，我们nand中的前4K指令会变自动加载到sram中去，这时的0地址对应sram。那么我们的程序如果大于4K,要从nand启动，sram只拷贝了nand中的前4K代码，那么如何解决这个问题呢？</p>
<p>就需要重定位代码到dram(ddr)中去，dram的容量较大，又可以直接被cpu访问。</p>
<h2><span id="1-1-cheng-xu-di-zhi-kong-jian">1.1 程序地址空间</span><a href="#1-1-cheng-xu-di-zhi-kong-jian" class="header-anchor">#</a></h2><p>我们知道，程序包含：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">代码段（.text）</span><br><span class="line">数据段(.data):存放初始值不为<span class="number">0</span>的全局变量/静态变量</span><br><span class="line">rodata段(.rodata)：<span class="type">const</span>修饰的全局变量或静态变量</span><br><span class="line">bss段(.bss)：存放初始值为<span class="number">0</span>或者未初始化的全局变量/静态变量</span><br><span class="line">commen段(.commen):注释</span><br></pre></td></tr></table></figure>

<p>下面展开一个实验引入为什么要代码重定位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharB = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharC = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">int</span> g_CharD = <span class="string">&#x27;D&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g_roval = <span class="string">&#x27;C&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效，由于nor启动，nor上不可写 */</span></span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将上面的代码编译出的裸机程序分别烧录到nand和nor flash，看看结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 烧录到nor flash, 程序一直输出`AAAA`。</span><br><span class="line">2. 烧录到nand flash,程序无任何输出。</span><br></pre></td></tr></table></figure>

<p>我们发现nor启动时, 对全局变量g_char++无效, nand启动程序无任何输出。我们对程序进行反汇编处理：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/1.png"></p>
<p>可以看到.text段是从0地址开始的，证明cpu的确从0地址取指令进行译码、执行。<br>当从nor启动时，0地址对应nor；当从nand启动时，0地址对应sram，所以无论从nand还是从nor启动cpu都能取指令执行。</p>
<p>再进一步分析反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/2.png"></p>
<p>可以看到.data段的起始地址是0x8474(即g_Char变量的地址为0x8474）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 当把程序烧录进nor,  .data段在nor上的某一段区域, 由于nor能像内存一样读，但不能像内存一样直接写，因此对<span class="string">&#x27;g_Char&#x27;</span>修改无效。</span><br><span class="line"><span class="number">2.</span> 当把程序烧录进nand, .data段在nand的某一区域，nand启动时硬件会自动把nand上的前<span class="number">4</span>K数据copy到SRAM,然后cpu从sram取指令执行。但是.data段的起始地址<span class="number">0x8474</span>&gt;<span class="number">0x1000</span>，超过了<span class="number">4</span>K, cpu没法把.data段也copy到SRAM,所以当访问<span class="string">&#x27;g_Char&#x27;</span>时，发生了异常（abt数据访问终止，这个异常后面有在下一节“异常与中断”里面专门讲解)，因此程序卡死。</span><br></pre></td></tr></table></figure>

<p>再仔细看看反汇编，发现.rodata段和.text段是连续的,但是.rodata段和.data段中间有一段”空洞”。用图形表示更形象，bin文件的内容分布如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/3.png"><br>那么我们怎么去掉空洞，让.data段了紧接着.rodata段呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 链接脚本(后面1.2有专门讲)</span><br><span class="line">2. 直接在编译的时候用 &quot;-Tdata 0x800&quot;，这样指定.data段基地址为0x800,这样nand启动时.data就能自动copy到SRAM了。</span><br></pre></td></tr></table></figure>

<p>我们现在使用<code>-Tdata 0x800</code>编译出裸机程序，对应反汇编如下：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/4.png"></p>
<p>这时我们烧录程序到nand，从nand启动，发现能输出<code>ABCDEFG</code>了，这就对了，因为.data段数据从nand自动拷贝到了sram。</p>
<p>有人说为什么不吧.data段指向到dram呢，这样无论时nor启动还是nand启动不就都能对全局变量写了？<br>当然这个没错，我做了这个尝试，编译时用<code>-Tdata 0x30000000</code>, 发现编译出来的bin文件有800多M,为什么有这么大呢？由于我们指定.data段存放在0x30000000(sdram的基地址)，这时bin文件的内部结构如下所示：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/5.png"></p>
<p>这么大的bin文件根本无法烧录。通过上面的例子，现在总结下为什么要代码重定位:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.nand启动，前4K代码被自动copy到sram，当程序大于4K的时候需要重定位代码到sdram。</span><br><span class="line">2.nor启动， 全局变量在nor上，不能像内存一样直接写该全局变量，那么也需要重定位到sdram。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-lian-jie-jiao-ben">1.2 链接脚本</span><a href="#1-2-lian-jie-jiao-ben" class="header-anchor">#</a></h2><h3><span id="1-2-1-chong-ding-wei-data-duan">1.2.1 重定位data段</span><a href="#1-2-1-chong-ding-wei-data-duan" class="header-anchor">#</a></h3><p>我们发现<code>arm-linux-ld -Ttext 0 -Tdata 0x30000000</code>这种方式编译出来的bin文件有800多M,这肯定是不行的。可以通过AT参数指定.data段在编译时的存放位置，我们发现这样指定太不方便了，而且不好确定要放在bin文件的哪个位置。这里就要引入链接脚本，它可以帮我们解决这个不必要的麻烦。</p>
<h4><span id="1-2-1-1-lian-jie-jiao-ben-ge-shi">1.2.1.1 链接脚本格式</span><a href="#1-2-1-1-lian-jie-jiao-ben-ge-shi" class="header-anchor">#</a></h4><p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/6.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x00000000</span>; <span class="comment">//表示当前地址为0</span></span><br><span class="line">	. = ALIGN(<span class="number">4</span>);  <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.text  :   </span><br><span class="line">	&#123;</span><br><span class="line">	  cpu/arm920t/start.o	(.text)</span><br><span class="line">	  board/lyb2440/boot_init.o (.text)</span><br><span class="line">	  *(.text)</span><br><span class="line">	&#125;	<span class="comment">//表示.text段从0x4开始存放,其中可以手动调整代码段的位置，</span></span><br><span class="line">	    <span class="comment">//比如让start.o，boot_init.o中的函数放在最前面,然后存放剩余的代码段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.rodata : &#123; *(.rodata) &#125; <span class="comment">//从该位置开始存放所有的.rodata段</span></span><br><span class="line"></span><br><span class="line">	. = ALIGN(<span class="number">4</span>); <span class="comment">//设置当前位置让4字节对齐</span></span><br><span class="line">	.data : <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//从该位置开始存放所有的.data段 设置运行</span></span><br><span class="line"></span><br><span class="line">	__bss_start = .; <span class="comment">//设置.bss段的起始位置</span></span><br><span class="line">	.bss : &#123; *(.bss) &#125; <span class="comment">//从该位置开始存放所有的.bss段</span></span><br><span class="line">	_end = .;<span class="comment">//设置.bss段的结束位置（也就是整个链接脚本的结束为止）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是从uboot中裁剪过来的链接脚本，注释已经链接脚本的结构讲解的差不多了。这里.data段指定了程序的<strong>运行（链接）地址为sdram的base_addr（0x30000000）</strong>，通过<strong>AT指定加载（在bin文件的存放）地址0x800</strong>。</p>
<h4><span id="1-2-1-2-chong-ding-wei-data-duan-li-zi">1.2.1.2 重定位data段例子</span><a href="#1-2-1-2-chong-ding-wei-data-duan-li-zi" class="header-anchor">#</a></h4><p>对于nor启动时，我们可以直接从nor上取指令执行，所以可以只进行数据段的重定位（数据段需要写入），我们编写链接脚本sdram.lds如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    .text   <span class="number">0</span>  : &#123; *(.text) &#125;<span class="comment">//所有文件的.text</span></span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125; <span class="comment">//只读数据段</span></span><br><span class="line">    .data <span class="number">0x30000000</span> : AT(<span class="number">0x800</span>) &#123; *(.data) &#125; <span class="comment">//放在0x800,但运行时在0x3000000</span></span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;<span class="comment">//所有文件的bss段，所有文件的.COMMON段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将程序烧录进nor flash，程序运行时会将.data拷贝到0x0x30000000也就是sdram中去。只重定位数据段的过程用下图更直观:</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/7.png"></p>
<p>因此就可以对g_char进行写入了。Makefile如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line">       arm-linux-gcc -c -o led.o led.c</span><br><span class="line">       arm-linux-gcc -c -o uart.o uart.c</span><br><span class="line">       arm-linux-gcc -c -o init.o init.c</span><br><span class="line">       arm-linux-gcc -c -o main.o main.c</span><br><span class="line">       arm-linux-gcc -c -o start.o start.S</span><br><span class="line">       <span class="comment">#arm-linux-ld -Ttext 0 -Tdata 0x30000000  start.o led.o uart.o init.o main.o -o sdram.elf</span></span><br><span class="line">       arm-linux-ld -T sdram.lds start.o led.o uart.o init.o main.o -o sdram.elf</span><br><span class="line">       arm-linux-objcopy -O binary -S sdram.elf sdram.bin</span><br><span class="line">       arm-linux-objdump -D sdram.elf &gt; sdram.dis</span><br></pre></td></tr></table></figure>

<p>修改start.s进行.data段的重定位。我们需要将以0x800为.data段基地址的整个数据段copy到0x30000000处:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		/* 关闭看门狗 */</span><br><span class="line">		/* 初始化时钟 */</span><br><span class="line">		/* 设置栈 */</span><br><span class="line">		/*初始化sdram*/</span><br><span class="line">	...</span><br><span class="line">		/* 重定位data段，把加载地址0x800（bin文件中在nor中）的数据段的内容重定位到sdram的baseaddr */</span><br><span class="line">		mov r1, #0x800</span><br><span class="line">		ldr r0, [r1]</span><br><span class="line">		mov r1, #0x30000000</span><br><span class="line">		str r0, [r1]</span><br><span class="line">	</span><br><span class="line">		bl main</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>用几行简单的数据加载存储指令即可实现数据段的重定位，这里是用的相对跳转指令bl main，因为还没有重定位整个完整的代码，所以不能用ldr绝对跳转。前面的初始化时钟、sdram我就不写了，参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> , <a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/">s3c2440裸机编程-内存控制器</a>。</p>
<p>缺点：<br>这里只是人为的对.data段写死了,那么当我有多个全局变量时，还要计算重定位的次数,而且我们也不知道有多少个全局变量，所以这重定位方式有缺陷。那么我们对这种重定位.data断的方法做一个改进，将链接脚本修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    .text   0  : &#123; *(.text) &#125;</span><br><span class="line">    .rodata  : &#123; *(.rodata) &#125;</span><br><span class="line">    .data 0x30000000 : AT(0x800) </span><br><span class="line">    &#123; </span><br><span class="line">    data_load_addr = LOADADDR(.data);	/* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    data_start = . ;			/* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    *(.data) 				</span><br><span class="line">    data_end = . ;			/* data段结束地址 */</span><br><span class="line">    &#125;</span><br><span class="line">    .bss  : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本用一个变量data_load_addr指定了加载地址(data段在bin文件中的地址，即0x800），用变量data_start指定了运行地址（即为0x30000000），那么用data_end - data_start就是我们数据段的总长度。</p>
<p>对start.s重定位过程做出如下修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 重定位data段 */</span><br><span class="line">    ldr r1, =data_load_addr  /* data段在bin文件中的地址, 加载地址 */</span><br><span class="line">    ldr r2, =data_start 	 /* data段在重定位地址, 运行时的地址 */</span><br><span class="line">    ldr r3, =data_end 	     /* data段结束地址 */</span><br><span class="line">cpy:</span><br><span class="line">    ldrb r4, [r1]</span><br><span class="line">    strb r4, [r2] /*r2存入data_load_addr 0x400, 然后，r2,r1依次自加*/</span><br><span class="line">    add r1, r1, #1</span><br><span class="line">    add r2, r2, #1</span><br><span class="line">    cmp r2, r3</span><br><span class="line">    ble cpy</span><br><span class="line"></span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">    b halt</span><br></pre></td></tr></table></figure>

<p>这里start.s中用到了链接脚本中的label地址。</p>
<h3><span id="1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan">1.2.2 重定位整个程序段</span><a href="#1-2-2-chong-ding-wei-zheng-ge-cheng-xu-duan" class="header-anchor">#</a></h3><p>由于我们的程序可能会大于SRAM或者nor的容量，那么就必须连代码段也一起进行重定位，这种重定位方式更好，在实际应用中也是用的这种方式去做的重定位。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/8.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = <span class="built_in">ALIGN</span>(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将代码段的地址设置为0x3000_0004，然后紧接着放.rodata段，然后再紧接着放.data段。这样我们的bin文件就不再有“空洞”了。再来看重定位代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">	.global _start</span><br><span class="line">	_start:</span><br><span class="line">		...</span><br><span class="line">		/* 重定位text, rodata, data段整个程序 */</span><br><span class="line">		mov r1, #0</span><br><span class="line">		ldr r2, =_start 	    /* 第1条指令运行时的地址，也就是.text段的runtime addr，在这里是0x3000_0004*/</span><br><span class="line">		ldr r3, =__bss_start    /* bss段的起始地址,也就是整个程序的结束地址  */</span><br><span class="line">	cpy:</span><br><span class="line">		ldrb r4, [r1]</span><br><span class="line">		strb r4, [r2]</span><br><span class="line">		add r1, r1, #1</span><br><span class="line">		add r2, r2, #1</span><br><span class="line">		cmp r2, r3</span><br><span class="line">		ble cpy</span><br><span class="line">	</span><br><span class="line">		bl main  	</span><br><span class="line">	halt:</span><br><span class="line">		b halt</span><br></pre></td></tr></table></figure>

<p>整个bin文件程序的长度（.text + .rodata + .data）为__bss_start - _start,那么我们是把bin文件从存储介质的0地址copy到程序的运行地址0x3000_0004，这样我们访问.data段时就是访问sdram中重定位后的数据段了。</p>
<h3><span id="1-2-3-chong-ding-wei-dai-ma-you-hua">1.2.3 重定位代码优化</span><a href="#1-2-3-chong-ding-wei-dai-ma-you-hua" class="header-anchor">#</a></h3><h4><span id="1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">1.2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#1-2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h4><p>前面重定位时，我们使用的是ldrb命令从的Nor Flash读取1字节数据，再用strb命令将1字节数据写到SDRAM里面。<br>我们开发板的Nor Flash是16位，SDRAM是32位。 假设现在需要复制16byte数据。</p>
<table>
<thead>
<tr>
<th>不同的读写指令</th>
<th>cpu读取nor的次数</th>
<th>cpu写入sdram的次数</th>
</tr>
</thead>
<tbody><tr>
<td>ldrb、strb</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>ldr、str</td>
<td>8</td>
<td>4</td>
</tr>
</tbody></table>
<p>可以看出我们更换读写指令后读写次数变少了，提升了cpu的访问效率。修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">cpy:</span><br><span class="line">    ldr r4, [r1]</span><br><span class="line">    str r4, [r2]</span><br><span class="line">    add r1, r1, #4 //r1加4</span><br><span class="line">    add r2, r2, #4 //r2加4</span><br><span class="line">    cmp r2, r3 //如果r2 =&lt; r3继续拷贝</span><br><span class="line">    ble cpy</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4><span id="1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei">1.2.3.2 改成c代码重定位</span><a href="#1-2-3-2-gai-cheng-c-dai-ma-chong-ding-wei" class="header-anchor">#</a></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	. = <span class="number">0x30000000</span>;</span><br><span class="line">    __code_start = .;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text : &#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">copy2sdram</span><span class="params">(<span class="type">void</span>)</span> 	&#123;</span><br><span class="line">    <span class="comment">//要从lds文件中获得 __code_start, __bss_start</span></span><br><span class="line">    <span class="comment">//然后从0地址把数据复制到__code_start</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="type">int</span> __code_start, __bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *dest = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__code_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *src = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dest &lt; end) &#123;</span><br><span class="line">        *dest++ = *src++; <span class="comment">//从0地址依次copy到__code_start(代码段的运行地址)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start.s中设置栈指针sp后，即可执行bl copy2sdram进行重定位代码。如何设置栈指针参考<a href="https://fuzidage.github.io/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/">s3c2440裸机编程-时钟体系</a> 有实现，重复代码我就不贴上来了。</p>
<h1><span id="2-qing-chu-bss">2 清除bss</span><a href="#2-qing-chu-bss" class="header-anchor">#</a></h1><h2><span id="2-1-bss-duan-jie-shao">2.1 bss段介绍</span><a href="#2-1-bss-duan-jie-shao" class="header-anchor">#</a></h2><p>bss段是什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">		g_Char++;         <span class="comment">/* nor启动时, 此代码无效 ，重定位到sdram的baseaddr后有效*/</span></span><br><span class="line">		<span class="built_in">putchar</span>(g_Char3);</span><br><span class="line">		g_Char3++;</span><br><span class="line">		delay(<span class="number">1000000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把程序烧进去，然后打印g_A，但是发现g_A这个值并不是0，而是一个随机值。我们学习linux时知道全局变量g_A, g_B输出肯定是0，裸机输出不是0，为什么呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">原因：程序执行汇编过程做完了重定位后把代码copy到了sdram上，然后sdram上紧接着的地址就是.bss的基地址了，这时候bss段的这块内存没有经过任何处理，所以是随机的。</span><br><span class="line">那么我们重定位完代码后需要进行清除sdram上.bss段的数据，因为我们知道bss是未初始化和初始值为<span class="number">0</span>的全局变量。</span><br></pre></td></tr></table></figure>

<h2><span id="2-2-qing-bss">2.2 清bss</span><a href="#2-2-qing-bss" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x30000000;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .text      :&#123; *(.text) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line">    . = ALIGN(4);</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss : &#123; *(.bss) *(.COMMON) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清除bss段的代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 清除BSS段 */</span><br><span class="line">	ldr r1, =__bss_start</span><br><span class="line">	ldr r2, =_end</span><br><span class="line">	mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">	strb r3, [r1]</span><br><span class="line">	add r1, r1, #1</span><br><span class="line">	cmp r1, r2</span><br><span class="line">	ble clean</span><br><span class="line"></span><br><span class="line">	bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>

<p>我们把程序再烧进去，然后打印g_A，但是发现g_A的值是0了。本质上就是对重定位后的bss段数据清0。</p>
<h2><span id="2-3-qing-bss-you-hua">2.3 清bss优化</span><a href="#2-3-qing-bss-you-hua" class="header-anchor">#</a></h2><h3><span id="2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr">2.3.1 strb&#x2F;ldrb替换成str&#x2F;ldr</span><a href="#2-3-1-strb-x2f-ldrb-ti-huan-cheng-str-x2f-ldr" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ldr r1, =__bss_start</span><br><span class="line">    ldr r2, =_end</span><br><span class="line">    mov r3, #0</span><br><span class="line">clean:</span><br><span class="line">    str r3, [r1]</span><br><span class="line">    add r1, r1, #4</span><br><span class="line">    cmp r1, r2</span><br><span class="line">    ble clean</span><br><span class="line">    bl main</span><br><span class="line">halt:</span><br><span class="line">	b halt</span><br></pre></td></tr></table></figure>
<h3><span id="2-3-2-gai-cheng-c-dai-ma-qing-bss">2.3.2 改成c代码清bss</span><a href="#2-3-2-gai-cheng-c-dai-ma-qing-bss" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_bss</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* 从lds文件中获得 __bss_start, _end*/</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">int</span> _end, __bss_start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *start = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;__bss_start;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *end = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)&amp;_end;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">		*start++ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：汇编代码获取的是链接脚本中的变量的地址，而C语言代码中获取的是链接脚本中的变量的值</strong>，所以这里的用C语言改进重定位还是清bss都是要加取址符。</p>
<h3><span id="2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi">2.3.3 每个段地址4字节对齐</span><a href="#2-3-3-mei-ge-duan-di-zhi-4-zi-jie-dui-qi" class="header-anchor">#</a></h3><p>前面为了加快重定位和清bss的速度,用到了ldr,str这样以4字节为单位进行读写，但是还可能导致一个问题，假设现在链接脚本没有进行用ALIGN(4)让不同的段以4字节对齐，那么就会出现访问错乱的情况。举个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c2440_soc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;init.h&quot;</span></span></span><br><span class="line"><span class="type">char</span> g_Char = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//.data</span></span><br><span class="line"><span class="type">char</span> g_Char3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> g_Char2 = <span class="string">&#x27;B&#x27;</span>; <span class="comment">//.rodata</span></span><br><span class="line"><span class="type">int</span> g_A = <span class="number">0</span>; <span class="comment">//bss</span></span><br><span class="line"><span class="type">int</span> g_B; <span class="comment">//bss</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\rg_A = &quot;</span>);</span><br><span class="line">	printHex(g_A);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(g_Char);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将链接脚本中.data段和.bss之间的**ALIGN(4)**去掉。那么我们会发现程序执行的时候输出的g_A&#x3D;0，为什么呢，我们明明初始化g_A&#x3D;‘A’呀？</p>
<p>打开反汇编分析：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/9.png"></p>
<p>我们的.bss段紧接着.data段后面，可知在对bss段进行清除的时候，由于我们是以4字节为单位操作的，所以我们清除g_A的时候，连带g_Char,g_Char的值也一起清除了。</p>
<p>所以data段和数据段之间添加ALIGN(4)。修改后就会发现bss段的地址以0x30000248开始了，如下图：</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/10.png"></p>
<h1><span id="3-wei-zhi-wu-guan-ma">3 位置无关码</span><a href="#3-wei-zhi-wu-guan-ma" class="header-anchor">#</a></h1><h2><span id="3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling">3.1 绝对跳转与相对跳转指令</span><a href="#3-1-jue-dui-tiao-zhuan-yu-xiang-dui-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="3-1-1-xiang-dui-tiao-zhuan">3.1.1 相对跳转</span><a href="#3-1-1-xiang-dui-tiao-zhuan" class="header-anchor">#</a></h3><p>使用b, bl跳转指令。</p>
<p>对<code>bl sdram_test</code>指令进行分析，查看反汇编, 代码段的链接地址为0x3000,0000。</p>
<p><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/11.png"><br><code>这里的bl 3000036c不是跳转到3000036c，这个时候sdram并未初始化,那么这个物理地址是无法访问的.</code></p>
<p>为了验证，我们做另一个实验，修改连接脚本sdram.lds, 链接地址改为0x3000,0800，编译查看反汇编：<br><img src="/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/12.png"><br><code>可以看到现在变成了bl 300003ec,但两个的机器码e1a0c00d都是一样的，机器码一样，执行的内容肯定都是一样的。 因此这里并不是跳转到显示的地址，而是跳转到: pc + offset，这个由链接器决定。</code></p>
<p>假设程序从0x30000000执行，当前指令地址：0x3000005c ,那么就是跳到0x3000036c；如果程序从0运行，当前指令地址:0x5c 跳到：0x000003ec。<br>因此：跳转到某个地址并不是由bl指令所决定，而是由当前pc值和offset偏移量决定。反汇编显示这个值只是为了方便读代码。</p>
<p>结论： 反汇编文件里， B或BL 某个值，只是起到方便查看的作用，并不是真的跳转。</p>
<h3><span id="3-1-2-jue-dui-tiao-zhuan">3.1.2 绝对跳转</span><a href="#3-1-2-jue-dui-tiao-zhuan" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

<h3><span id="3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao">3.1.3 相对跳转与决定跳转比较</span><a href="#3-1-3-xiang-dui-tiao-zhuan-yu-jue-ding-tiao-zhuan-bi-jiao" class="header-anchor">#</a></h3><p>怎么写位置无关码？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用相对跳转命令 b或bl;</span><br><span class="line">重定位之前，不可使用绝对地址(因为你sdram还没初始化，没有重定位代码过去，跳转过去不就死机了)，也不可访问有初始值的数组(因为初始值放在rodata里，使用绝对地址来访问)；</span><br><span class="line">重定位之后，使用ldr pc = xxx，跳转到/runtime地址；</span><br><span class="line">写位置无关码，其实就是不使用绝对地址</span><br></pre></td></tr></table></figure>

<p>因此，前面的重定位和清bss例子，程序使用bl命令相对跳转，程序仍在NOR&#x2F;sram执行，要想让main函数在SDRAM执行，需要修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//bl main  /*bl相对跳转，程序仍在NOR/sram执行*/</span><br><span class="line">ldr pc, =main/*绝对跳转，跳到SDRAM*/</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile-常用函数和通用模板</title>
    <url>/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-makefile-gui-ze">1 Makefile规则</a></li>
<li><a href="#2-yi-bu-yi-bu-wan-shan-makefile">2 一步一步完善 Makefile</a><ul>
<li><a href="#2-1-mo-shi-gui-ze">2.1 模式规则</a></li>
<li><a href="#2-2-zi-dong-bian-liang">2.2 自动变量</a><ul>
<li><a href="#2-2-1-han-shu-chuan-can">2.2.1 函数传参</a></li>
</ul>
</li>
<li><a href="#2-3-li-ji-bian-liang-he-yan-shi-bian-liang">2.3 立即变量和延时变量</a></li>
<li><a href="#2-3-bian-liang-dao-chu">2.3 变量导出</a></li>
<li><a href="#2-4-makefile-zhong-shi-yong-shell-ming-ling">2.4 Makefile 中使用 shell 命令</a></li>
<li><a href="#2-5-wei-mu-biao">2.5 伪目标</a></li>
<li><a href="#2-6-chan-sheng-yi-lai-wen-jian">2.6 产生依赖文件</a></li>
</ul>
</li>
<li><a href="#3-chang-yong-han-shu">3 常用函数</a><ul>
<li><a href="#3-1-zi-fu-chuan-xiang-guan">3.1 字符串相关</a><ul>
<li><a href="#3-1-1-subst">3.1.1 <code>subst</code></a></li>
<li><a href="#3-1-2-patsubst">3.1.2 <code>patsubst</code></a></li>
<li><a href="#3-1-3-strip">3.1.3 <code>strip</code></a></li>
<li><a href="#3-1-4-findstring">3.1.4 <code>findstring</code></a></li>
<li><a href="#3-1-6-filter-out">3.1.6 <code>filter-out</code></a></li>
<li><a href="#3-1-7-sort">3.1.7 <code>sort</code></a></li>
</ul>
</li>
<li><a href="#3-2-wen-jian-ming-xiang-guan">3.2 文件名相关</a><ul>
<li><a href="#3-2-1-dir">3.2.1 <code>dir</code></a></li>
<li><a href="#3-2-2-notdir">3.2.2 <code>notdir</code></a></li>
<li><a href="#3-2-3-suffix">3.2.3 <code>suffix</code></a></li>
<li><a href="#3-2-4-basename">3.2.4 <code>basename</code></a></li>
<li><a href="#3-2-5-addsuffix">3.2.5 <code>addsuffix</code></a></li>
<li><a href="#3-2-6-addprefix">3.2.6 <code>addprefix</code></a></li>
<li><a href="#3-2-7-wildcard">3.2.7 <code>wildcard</code></a></li>
<li><a href="#3-2-8-join">3.2.8<code> join</code></a></li>
<li><a href="#3-2-9-realpath">3.2.9<code>realpath</code></a></li>
<li><a href="#3-2-10-abspath">3.2.10 <code>abspath</code></a></li>
<li><a href="#3-2-11-file">3.2.11 <code>file</code></a></li>
</ul>
</li>
<li><a href="#3-3-qi-ta-han-shu">3.3 其他函数</a><ul>
<li><a href="#3-3-1-foreach">3.3.1 <code>foreach</code></a></li>
<li><a href="#3-3-2-origin">3.3.2 <code>origin</code></a></li>
<li><a href="#3-3-3-word">3.3.3 <code>word</code></a></li>
<li><a href="#3-3-4-wordlist">3.3.4<code>wordlist</code></a></li>
<li><a href="#3-3-5-words">3.3.5 <code>words</code></a></li>
<li><a href="#3-3-6-firstword-lastword">3.3.6 <code>firstword/lastword </code></a></li>
<li><a href="#3-3-7-call">3.3.7 <code>call</code></a></li>
</ul>
</li>
<li><a href="#3-4-vpath-xuan-xiang">3.4 VPATH选项</a></li>
<li><a href="#3-5-make-huan-jing-bian-liang">3.5 make环境变量</a></li>
<li><a href="#3-6-make-bian-yi-xuan-xiang">3.6 make编译选项</a></li>
</ul>
</li>
<li><a href="#4-tong-yong-xing-makefile">4 通用型<code>makefile</code></a><ul>
<li><a href="#4-1-ding-ceng-makefile">4.1 顶层<code>Makefile</code></a></li>
<li><a href="#4-2-makefile-build">4.2 <code>Makefile.build</code></a></li>
<li><a href="#4-3-make-guo-cheng-ju-li">4.3 Make过程举例</a><ul>
<li><a href="#4-3-1-zi-mu-lu-makefile-display-wei-li">4.3.1 子目录<code>MakeFIle-display</code>为例</a></li>
<li><a href="#4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi">4.3.2 编译详细输出日志</a></li>
<li><a href="#4-3-3-bian-yi-ru-kou">4.3.3 编译入口</a></li>
<li><a href="#4-3-4-bian-yi-build">4.3.4 编译<code>__build</code></a><ul>
<li><a href="#4-3-4-1-bian-yi-subdir-y">4.3.4.1 编译<code>$(subdir-y)</code></a></li>
<li><a href="#4-3-4-2-da-bao-cheng-zong-de-built-in-o">4.3.4.2 打包成总的<code>built-in.o</code></a></li>
</ul>
</li>
<li><a href="#4-3-5-bian-yi-chu-kou">4.3.5 编译出口</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-tong-yong-xing-makefile2-luo-ji-ban">5 通用型<code>makefile2</code>-裸机版</a><ul>
<li><a href="#5-1-wen-jian-gong-cheng-mu-lu">5.1 文件工程目录</a></li>
<li><a href="#5-2-lds-lian-jie-jiao-ben">5.2 lds链接脚本</a></li>
<li><a href="#5-3-makefile">5.3 <code>Makefile</code></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-makefile-gui-ze">1 Makefile规则</span><a href="#1-makefile-gui-ze" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">目标(target)…: 依赖(prerequiries)…</span><br><span class="line">&lt;tab&gt;命令(command)</span><br></pre></td></tr></table></figure>

<p>如果<code>“依赖文件”</code>比<code>“目标文件”</code>更加新，那么执行<code>“命令”</code>来重新生成<code>“目标文件”</code>。</p>
<p>命令被执行的 2 个条件：依赖文件比目标文件新，或是 目标文件还没生成。</p>
<h1><span id="2-yi-bu-yi-bu-wan-shan-makefile">2 一步一步完善 Makefile</span><a href="#2-yi-bu-yi-bu-wan-shan-makefile" class="header-anchor">#</a></h1><p>第 1 个 Makefile，简单粗暴，效率低：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.c sub.c sub.h</span><br><span class="line">　　gcc -o test main.c sub.c</span><br></pre></td></tr></table></figure>

<p>第 2 个 Makefile，效率高，相似规则太多太啰嗦，不支持检测头文件:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">main.o : main.c</span><br><span class="line">　　gcc -c -o main.o main.c</span><br><span class="line">sub.o : sub.c</span><br><span class="line">　　gcc -c -o sub.o sub.c</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<p>第 3 个 Makefile，效率高，精炼，不支持检测头文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c</span><br><span class="line">　　gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<p>第 4 个 Makefile，效率高，精炼，支持检测头文件(但是需要手工添加头文件规则)：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">test : main.o sub.o</span><br><span class="line">　　gcc -o test main.o sub.o</span><br><span class="line">%.o : %.c</span><br><span class="line">　　gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">sub.o : sub.h</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm *.o test -f</span><br></pre></td></tr></table></figure>

<h2><span id="2-1-mo-shi-gui-ze">2.1 模式规则</span><a href="#2-1-mo-shi-gui-ze" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -c  <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>前面第3第4个Makefile都用到了模式规则。</p>
<h2><span id="2-2-zi-dong-bian-liang">2.2 自动变量</span><a href="#2-2-zi-dong-bian-liang" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>--目标文件</span><br><span class="line"><span class="variable">$^</span>--所有的依赖文件</span><br><span class="line"><span class="variable">$&lt;</span>--第一个依赖文件</span><br><span class="line"><span class="variable">$?</span>--所有的比目标新的依赖文件</span><br></pre></td></tr></table></figure>

<h3><span id="2-2-1-han-shu-chuan-can">2.2.1 函数传参</span><a href="#2-2-1-han-shu-chuan-can" class="header-anchor">#</a></h3><p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/1.png" alt="img"></p>
<p>函数传参也属于自动变量。上图的make结果为：</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/2.png" alt="img"></p>
<h2><span id="2-3-li-ji-bian-liang-he-yan-shi-bian-liang">2.3 立即变量和延时变量</span><a href="#2-3-li-ji-bian-liang-he-yan-shi-bian-liang" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A := <span class="variable">$(C)</span> //立即变量</span><br><span class="line">B = <span class="variable">$(C)</span>  // 延时变量</span><br><span class="line">C = abc  // 延时变量</span><br><span class="line"><span class="comment">#D = 100ask</span></span><br><span class="line">D ?= weidongshan//延时变量，只有第一次定义时赋值才成功；如果曾定义过，此赋值无效</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        @echo A = <span class="variable">$(A)</span></span><br><span class="line">        @echo B = <span class="variable">$(B)</span></span><br><span class="line">        @echo D = <span class="variable">$(D)</span></span><br><span class="line">C += 123</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/3.png" alt="img"></p>
<h2><span id="2-3-bian-liang-dao-chu">2.3 变量导出</span><a href="#2-3-bian-liang-dao-chu" class="header-anchor">#</a></h2><p><code>A makefile</code>中的变量无法在<code>B makefile</code>识别，因此要用<code>export</code>导出如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> CC = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line"><span class="keyword">export</span> BUILD_DIR=/home/book/100ask_imx6ull-sdk</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-makefile-zhong-shi-yong-shell-ming-ling">2.4 Makefile 中使用 shell 命令</span><a href="#2-4-makefile-zhong-shi-yong-shell-ming-ling" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PWD=<span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">CP=<span class="variable">$(<span class="built_in">shell</span> cp)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-wei-mu-biao">2.5 伪目标</span><a href="#2-5-wei-mu-biao" class="header-anchor">#</a></h2><p><code>.PHONY</code>表示伪目标。表示无条件执行目标。makefile将不会判断该目标是否存在或者该目标是否需要更新。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">　　rm -f <span class="variable">$(TARGET)</span></span><br><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>

<h2><span id="2-6-chan-sheng-yi-lai-wen-jian">2.6 产生依赖文件</span><a href="#2-6-chan-sheng-yi-lai-wen-jian" class="header-anchor">#</a></h2><p>第5个Makefile。效率高，精炼，支持自动检测头文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objs := main.o sub.o</span><br><span class="line">test : <span class="variable">$(objs)</span></span><br><span class="line">　　gcc -o test <span class="variable">$^</span></span><br><span class="line"><span class="comment"># 需要判断是否存在依赖文件</span></span><br><span class="line"><span class="comment"># .main.o.d .sub.o.d</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span></span><br><span class="line"><span class="comment">#dep_files := $(patsubst %,.%.d, $(objs))</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"><span class="comment"># 把依赖文件包含进来</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">%.o : %.c</span><br><span class="line">gcc -Wp,-MD,.<span class="variable">$@</span>.d -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o test -f</span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">rm <span class="variable">$(dep_files)</span> *.o test -f</span><br></pre></td></tr></table></figure>

<h1><span id="3-chang-yong-han-shu">3 常用函数</span><a href="#3-chang-yong-han-shu" class="header-anchor">#</a></h1><h2><span id="3-1-zi-fu-chuan-xiang-guan">3.1 字符串相关</span><a href="#3-1-zi-fu-chuan-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-1-1-subst">3.1.1 <code>subst</code></span><a href="#3-1-1-subst" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> from,to,text)</span></span><br></pre></td></tr></table></figure>

<p>在文本<code>text</code>中使用<code>to</code>替换每一处<code>from</code>。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> ee,EE,feet on the street)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>fEEt on the strEEt</code></p>
<h3><span id="3-1-2-patsubst">3.1.2 <code>patsubst</code></span><a href="#3-1-2-patsubst" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> pattern,replacement,text)</span></span><br></pre></td></tr></table></figure>

<p>寻找<code>text</code>中符合格式<code>pattern</code>的字，用<code>replacement</code>替换它们。</p>
<p><code>pattern</code>和<code>replacement</code> 中可以使用通配符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span></span><br></pre></td></tr></table></figure>

<p>结果为： <code>x.c.o bar.o</code></p>
<h3><span id="3-1-3-strip">3.1.3  <code>strip</code></span><a href="#3-1-3-strip" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> string)</span></span><br></pre></td></tr></table></figure>

<p>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> a      b c )</span></span><br></pre></td></tr></table></figure>

<p>结果为：<code>foo.c bar.c baz.s</code></p>
<h3><span id="3-1-4-findstring">3.1.4 <code>findstring</code></span><a href="#3-1-4-findstring" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> find,in)</span></span><br></pre></td></tr></table></figure>

<p>在字符串<code>in</code>中搜寻<code>find</code>，如果找到，则返回值是<code>find</code>，否则返回值为空。</p>
<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,a b c)</span></span><br><span class="line"><span class="variable">$(<span class="built_in">findstring</span> a,b c)</span></span><br></pre></td></tr></table></figure>

<p>将分别产生值<code>a</code>和(空字符串)</p>
<p>3.1.5 <code>filter</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> pattern...,text)</span></span><br></pre></td></tr></table></figure>

<p>返回在<code>text</code>中由空格隔开且匹配格式<code>pattern...</code>的字，去除不符合格式<code>pattern...</code>的字。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c bar.c baz.s</code>。</p>
<h3><span id="3-1-6-filter-out">3.1.6 <code>filter-out</code></span><a href="#3-1-6-filter-out" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out pattern...,text)</span></span><br></pre></td></tr></table></figure>

<p>返回在<code>text</code>中由空格隔开且不匹配格式<code>pattern...</code>的字，去除符合格式<code>pattern...</code>的字。它是函数 filter 的反函数。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.c %.s,foo.c bar.c baz.s ugh.h)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>ugh.h</code>。</p>
<h3><span id="3-1-7-sort">3.1.7 <code>sort</code></span><a href="#3-1-7-sort" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> list)</span></span><br></pre></td></tr></table></figure>

<p>将<code>list</code>中的字按字母顺序排序，并去掉重复的字。输出由单个空格隔开的字的列表。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> foo bar lose)</span></span><br></pre></td></tr></table></figure>

<p>返回值是<code>bar foo lose</code></p>
<h2><span id="3-2-wen-jian-ming-xiang-guan">3.2 文件名相关</span><a href="#3-2-wen-jian-ming-xiang-guan" class="header-anchor">#</a></h2><h3><span id="3-2-1-dir">3.2.1 <code>dir</code></span><a href="#3-2-1-dir" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠(含斜杠)之前的一切字符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/ ./</code>。</p>
<h3><span id="3-2-2-notdir">3.2.2 <code>notdir</code></span><a href="#3-2-2-notdir" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名中除路径部分外一切字符（真正的文件名）。</p>
<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> src/foo.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c hacks</code>。</p>
<h3><span id="3-2-3-suffix">3.2.3 <code>suffix</code></span><a href="#3-2-3-suffix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> names...)</span></span><br></pre></td></tr></table></figure>

<p>抽取<code>names...</code>中每一个文件名的后缀。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> src/foo.c src-1.0/bar.c hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>.c .c</code>。</p>
<h3><span id="3-2-4-basename">3.2.4 <code>basename</code></span><a href="#3-2-4-basename" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> names...)</span></span><br></pre></td></tr></table></figure>
<p>抽取<code>names...</code>中每一个文件名中除后缀外一切字符。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> src/foo.c src-1.0/bar hacks)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/foo src-1.0/bar hacks</code>。</p>
<h3><span id="3-2-5-addsuffix">3.2.5 <code>addsuffix</code></span><a href="#3-2-5-addsuffix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> <span class="built_in">suffix</span>,names...)</span></span><br></pre></td></tr></table></figure>

<p>参数<code> names...</code>是一系列的文件名，文件名之间用空格隔开； suffix 是一个后缀名。将 suffix(后缀)的值附加在每一个独立文件名的后面，完成后将文件名串联起来，它们之间用单个空格隔开。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> .c,foo bar)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>foo.c bar.c</code>。</p>
<h3><span id="3-2-6-addprefix">3.2.6 <code>addprefix</code></span><a href="#3-2-6-addprefix" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> prefix,names...)</span></span><br></pre></td></tr></table></figure>

<p>参数<code> names</code>是一系列的文件名，文件名之间用空格隔开； prefix 是一个前缀名。将 preffix(前缀)的值附加在每一个独立文件名的前面，完成后将文件名串联起来，它们之间用单个空格隔开。</p>
<p>比如： </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> src/,foo bar)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>src/foo src/bar</code>。</p>
<h3><span id="3-2-7-wildcard">3.2.7 <code>wildcard</code></span><a href="#3-2-7-wildcard" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wildcard</span> pattern)</span></span><br></pre></td></tr></table></figure>

<p>参数<code>pattern</code>是一个文件名格式，包含有通配符(通配符和 shell 中的用法一样)。函数 wildcard 的结果是一列和格式匹配的且真实存在的文件的名称，文件名之间用一个空格隔开。</p>
<p>比如若当前目录下有文件 1.c、 2.c、 1.h、 2.h，则：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">c_src := <span class="variable">$(<span class="built_in">wildcard</span> \*.c)</span></span><br></pre></td></tr></table></figure>

<p>结果为<code>1.c 2.c</code></p>
<h3><span id="3-2-8-join">3.2.8<code> join</code></span><a href="#3-2-8-join" class="header-anchor">#</a></h3><p><code>$(join list1,list2)</code></p>
<p>逐个地将list2中的元素链接到list1。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">LIST1 := foo bar</span><br><span class="line">LIST2 := .c  .p</span><br><span class="line">RESULT := $&#123;join $&#123;LIST1&#125; , $&#123;LIST2&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：<code>foo.c bar.p</code></p>
<h3><span id="3-2-9realpath">3.2.9<code>realpath</code></span><a href="#3-2-9realpath" class="header-anchor">#</a></h3><p><code>$(realpath names…)</code></p>
<p>对<code>names中</code>的每个文件，求其绝对路径，当目标为链接时，将解析链接。</p>
<h3><span id="3-2-10-abspath">3.2.10 <code>abspath</code></span><a href="#3-2-10-abspath" class="header-anchor">#</a></h3><p><code>$(abspath names…)</code></p>
<p>对<code>names中</code>的每个文件，求其绝对路径。不解析链接。</p>
<h3><span id="3-2-11-file">3.2.11 <code>file</code></span><a href="#3-2-11-file" class="header-anchor">#</a></h3><p><code>$(file op filename[,text])</code></p>
<p>向文件执行文本的输入输出.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEXT := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">RESULT := \$&#123;file &gt; test,$&#123;TEXT&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>前目录下存在test文件时，<code>&quot;hello world&quot;</code>被写入到test中，当不存在test文件时，文件被创建且同时写入<code>&quot;hello world&quot;</code>.</p>
<h2><span id="3-3-qi-ta-han-shu">3.3 其他函数</span><a href="#3-3-qi-ta-han-shu" class="header-anchor">#</a></h2><h3><span id="3-3-1-foreach">3.3.1 <code>foreach</code></span><a href="#3-3-1-foreach" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> var,list,text)</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span>)</span><br></pre></td></tr></table></figure>

<p>这里<code>text</code>是<code>$(wildcard $(dir)/*)</code>，它的扩展过程如下：</p>
<p>第一个赋给变量<code>dir</code>的值是<code>a</code>， 扩展结果为<code>$(wildcard a/*)</code>；<br>第二个赋给变量<code>dir</code>的值是<code>b</code>， 扩展结果为<code>$(wildcard b/*)</code>；<br>第三个赋给变量<code>dir</code>的值是<code>c</code>， 扩展结果为<code>$(wildcard c/*)</code>；</p>
<p>如此继续扩展。</p>
<p>这个例子和下面的例有共同的结果：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">files := <span class="variable">$(<span class="built_in">wildcard</span> a/* b/* c/* d/*)</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-origin">3.3.2 <code>origin</code></span><a href="#3-3-2-origin" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> variable)</span></span><br></pre></td></tr></table></figure>

<p>变量<code>variable</code>是一个查询变量的名称，不是对该变量的引用。所以，不能采用<code>$</code>和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。</p>
<p>函数<code>origin</code>的结果是一个字符串，该字符串变量是这样定义的：</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/4.png" alt="img"></p>
<p>例如定义编译时用<code>verbose</code>还是<code>quiet</code>打印，<code>verbose</code>表示输出详细过程，<code>quiet</code>输出简略信息。</p>
<p><img src="/2024/06/24/Makefile-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF/5.png" alt="img"></p>
<p>将所有的信息都输出到同一个文件中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make xxx &gt; build_output_all.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-3-word">3.3.3 <code>word</code></span><a href="#3-3-3-word" class="header-anchor">#</a></h3><p><code>$(word n,text)</code></p>
<p>返回text列表中第n个元素.</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TEXT := foo.c foo.h bar.c</span><br><span class="line">RESULT := $&#123;word 2,$&#123;TEXT&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>foo.h</code></p>
<h3><span id="3-3-4wordlist">3.3.4<code>wordlist</code></span><a href="#3-3-4wordlist" class="header-anchor">#</a></h3><p><code>$(wordlist s,e,text)</code></p>
<p>返回text列表中指定的由s(start)开始由e(end)结尾的元素集合.</p>
<h3><span id="3-3-5-words">3.3.5 <code>words</code></span><a href="#3-3-5-words" class="header-anchor">#</a></h3><p><code>$(words text)</code></p>
<p>返回text列表中的元素数量。</p>
<h3><span id="3-3-6-firstword-lastword">3.3.6 <code>firstword/lastword </code></span><a href="#3-3-6-firstword-lastword" class="header-anchor">#</a></h3><p><code>$(firstword names…) \$(lastword names…)</code></p>
<p>返回names列表中的第一个、最后一个元素.</p>
<h3><span id="3-3-7-call">3.3.7  <code>call</code></span><a href="#3-3-7-call" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">func = $1.$2</span><br><span class="line">foo = <span class="variable">$(<span class="built_in">call</span> func,a,b)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>

<p>结果：<code>a.b</code>, 子函数调用，数的参数会被赋值给临时参数·&#x3D;<code>\$1,\$2,\$0</code>则代表函数名本身.</p>
<h2><span id="3-4-vpath-xuan-xiang">3.4 VPATH选项</span><a href="#3-4-vpath-xuan-xiang" class="header-anchor">#</a></h2><p>VPATH中添加的目录，即使是文件处于其他目录，我们也可以像操作当前目录一样操作其他目录的文件，例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH += src</span><br><span class="line"><span class="section">all:foo.c</span></span><br><span class="line">cc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">all:src/foo.c</span></span><br><span class="line">cc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>但是写成下面这样是不行的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VPATH += src</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">cc foo.c -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>这是因为：<code>VPATH</code>是<code>makefile中</code>的语法规则，而命令部分是由<code>shell</code>解析，所以<code>shell</code>并不会解析<code>VPATH</code>。</p>
<h2><span id="3-5-make-huan-jing-bian-liang">3.5 make环境变量</span><a href="#3-5-make-huan-jing-bian-liang" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AR 打包程序，默认值为ar，对目标文件进行打包，封装静态库</span><br><span class="line">AS 汇编程序，默认值为as，将汇编指令编译成机器指令</span><br><span class="line">CC c编译器，默认值为cc，通常情况下，cc是一个指向gcc的链接，负责将c程序编译成汇编程序。</span><br><span class="line">CXX c++编译器，默认值为g++</span><br><span class="line">CPP 预处理器，默认值为 &quot;$(CC) -E&quot;，注意这里的CPP不是C++，而是预处理器。</span><br><span class="line">RM 删除文件，默认值为 &quot;rm -f&quot;，-f表示强制删除</span><br></pre></td></tr></table></figure>

<h2><span id="3-6-make-bian-yi-xuan-xiang">3.6 make编译选项</span><a href="#3-6-make-bian-yi-xuan-xiang" class="header-anchor">#</a></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARFLAGS 指定$(AR)运行时的参数，默认值为&quot;ar&quot;</span><br><span class="line">ASFLAGS 指定$(AS)运行时的参数，无默认值</span><br><span class="line">CFLAGS 指定$(CC)运行时的参数，无默认值</span><br><span class="line">CXXFLAGS 指定$(CXX)运行时的参数，无默认值</span><br><span class="line">CPPFLAGS 指定$(CPP)运行时的参数，无默认值，注意这里的CPP不是C++，而是预处理器</span><br><span class="line">LDFLAGS 指定ld链接器运行时的参数，无默认值</span><br><span class="line">LDLIBS 指定ld链接器运行时的链接库参数，无默认值。</span><br><span class="line"></span><br><span class="line">make --debug</span><br><span class="line">	输出每一步输出的详细流程，对于调试时非常方便。</span><br></pre></td></tr></table></figure>

<h1><span id="4-tong-yong-xing-makefile">4 通用型<code>makefile</code></span><a href="#4-tong-yong-xing-makefile" class="header-anchor">#</a></h1><p>本<code>makefile</code>是参考linux内核的<code>makefile</code>框架改编简化，大家可以参考Linux内核中<code>built-in.o</code>的产生过程来进一步了解该流程。</p>
<p>顶层目录下，存在<code>Makefile</code>和<code>Makefile.build</code>两个文件。这两个文件非常重要，make命令能递归查找每个子目录，就是这2个<code>Makefile</code>文件的功劳。</p>
<h2><span id="4-1-ding-ceng-makefile">4.1 顶层<code>Makefile</code></span><a href="#4-1-ding-ceng-makefile" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 延时变量, 只有第一次定义赋值才成功.而该变量在/etc/profile中. 已定义为arm-linux-gnueabihf-</span></span><br><span class="line">CROSS_COMPILE ?=</span><br><span class="line"><span class="comment"># 定义延时变量</span></span><br><span class="line">AS                = <span class="variable">$(CROSS_COMPILE)</span>as</span><br><span class="line">LD                = <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">CC                = <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">CPP                = <span class="variable">$(CC)</span> -E</span><br><span class="line">AR                = <span class="variable">$(CROSS_COMPILE)</span>ar</span><br><span class="line">NM                = <span class="variable">$(CROSS_COMPILE)</span>nm</span><br><span class="line">STRIP                = <span class="variable">$(CROSS_COMPILE)</span>strip</span><br><span class="line">OBJCOPY                = <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP                = <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"><span class="comment"># export全局变量, 可供其他Makefile使用</span></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line">CFLAGS := -Wall -O2 -g</span><br><span class="line">CFLAGS += -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line">LDFLAGS := -lpthread -lfreetype -lm</span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line">obj-y += display/</span><br><span class="line"><span class="comment"># obj-y += unittest/</span></span><br><span class="line"><span class="comment">#obj-y += input/</span></span><br><span class="line"><span class="comment">#obj-y += font/</span></span><br><span class="line">obj-y += ui/</span><br><span class="line">obj-y += page/</span><br><span class="line">obj-y += config/</span><br><span class="line">obj-y += business/</span><br><span class="line"></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">        @echo <span class="variable">$(TARGET)</span> has been built!</span><br><span class="line"></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">        @echo <span class="variable">$@</span></span><br><span class="line">        @echo obj-y = $(obj-y)</span><br><span class="line">        make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span> : built-in.o</span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.d&quot;)</span></span><br><span class="line">        rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>顶层<code>Makefile</code>的作用：</p>
<ol>
<li>提供项目make命令的执行入口，提供所有编译target目标。</li>
<li>定义全局变量，编译选项，链接选项等。</li>
<li>通过<code>obj-y</code>指定要搜索的子目录。</li>
<li>切换目录，递归执行make命令，并执行根目录的<code>Makefile.build</code>文件</li>
</ol>
<h2><span id="4-2-makefile-build">4.2 <code>Makefile.build</code></span><a href="#4-2-makefile-build" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">PHONY := __build echo_obj</span><br><span class="line"><span class="section">__build:</span></span><br><span class="line">obj-y :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="comment">#包含当前执行目录的Makefile</span></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># obj-y := a.o b.o c/ d/</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y))   : c/ d/</span></span><br><span class="line"><span class="comment"># __subdir-y  : c d</span></span><br><span class="line"><span class="comment"># subdir-y    : c d</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y)) 从变量obj-y中过滤出以&quot;/&quot;结尾的目录名</span></span><br><span class="line"><span class="comment"># $(patsubst %/,%,$(filter %/, $(obj-y))) 去掉obj-y中以&quot;/&quot;结尾的目录名中的&quot;/&quot;</span></span><br><span class="line">__subdir-y        := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y        += $(__subdir-y)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># c/built-in.o d/built-in.o</span></span><br><span class="line"><span class="comment"># foreach(var,list,text), 意为foreach var in list, change it to text</span></span><br><span class="line"><span class="comment"># 将子目录列表subdir-y中, 每一项(每个文件名)f, 都修改为f/built-in.o</span></span><br><span class="line"><span class="comment"># 也就是说, 每个子目录, 都会对应生成一个名为 &quot;子目录名/built-in.o&quot;的文件 (.o文件是链接文件)</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.o b.o</span></span><br><span class="line"><span class="comment"># 从obj-y中过滤掉目录名(名称以&quot;/&quot;结尾), 只剩下普通文件(.o文件)</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-y)</span>)</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果依赖文件存在, 就列出来重新赋值给dep_files</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果依赖文件列表不为空, 就直接包含(include)依赖文件列表</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子目录名(不含&quot;/&quot;)追加到伪目标</span></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="section">echo_obj:</span></span><br><span class="line">        @echo <span class="string">&quot;********************  echo_obj  *************************&quot;</span></span><br><span class="line">        @echo obj-y:$(obj-y)</span><br><span class="line">        @echo __subdir-y:$(__subdir-y)</span><br><span class="line">        @echo subdir-y:$(subdir-y)</span><br><span class="line">        @echo subdir_objs:<span class="variable">$(subdir_objs)</span></span><br><span class="line">        @echo cur_objs:<span class="variable">$(cur_objs)</span></span><br><span class="line">        @echo <span class="string">&quot;**********************************************************&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">__build: echo_obj $(subdir-y) built-in.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用顶层Makefile.build的规则去子目录去编译</span></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">        @echo subdir-y = <span class="variable">$@</span></span><br><span class="line">        make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义built-in.o依赖规则，当subdir-y为空了才开始执行</span></span><br><span class="line"><span class="comment"># cur_objs 从obj-y过滤出的普通文件(.o文件)</span></span><br><span class="line"><span class="comment"># subdir_objs 子目录下的built-in.o</span></span><br><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#延时变量, generate dep_file</span></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">        <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>

<p><code>Makefile.build</code>作用：</p>
<ol>
<li>包含引用顶层Makefile。</li>
<li>取出每个子Makefile中定义的<code>.o</code>文件，再根据<code>%.o:%.c</code>模式规则，自动寻找<code>.c</code>源码文件。</li>
<li>取出每个子Makefile中定义的子目录，再用<code>make -C</code>切换到子目录，从而实现递归目录编译。</li>
<li>为每个<code>.o</code>文件生成依赖文件<code>(.d)</code>,并包含进Makefile.build。</li>
<li>为每个子目录(含有Makefile)生成一个<code>built-in.o</code>文件，便于根目录下的Makefile文件编译、链接。</li>
<li>设置伪目标。</li>
</ol>
<h2><span id="4-3-make-guo-cheng-ju-li">4.3 Make过程举例</span><a href="#4-3-make-guo-cheng-ju-li" class="header-anchor">#</a></h2><p>项目目录展开如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── led.sh</span><br><span class="line">├── business</span><br><span class="line">│   ├── main.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── config</span><br><span class="line">│   ├── config.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── display</span><br><span class="line">│   ├── disp_manager.c</span><br><span class="line">│   ├── framebuffer.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── font</span><br><span class="line">│   ├── font_manager.c</span><br><span class="line">│   ├── freetype.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">├── include</span><br><span class="line">│   ├── <span class="keyword">common</span>.h</span><br><span class="line">│   ├── config.h</span><br><span class="line">│   ├── disp_manager.h</span><br><span class="line">│   ├── font_manager.h</span><br><span class="line">│   ├── input_manager.h</span><br><span class="line">│   ├── page_manager.h</span><br><span class="line">│   ├── tslib.h</span><br><span class="line">│   └── ui.h</span><br><span class="line">├── <span class="keyword">input</span></span><br><span class="line">│   ├── input_manager.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── netinput.c</span><br><span class="line">│   └── touchscreen.c</span><br><span class="line">├── Makefile</span><br><span class="line">├── Makefile.build</span><br><span class="line">├── page</span><br><span class="line">│   ├── main_page.c</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   └── page_manager.c</span><br><span class="line">├── ui</span><br><span class="line">│   ├── button.c</span><br><span class="line">│   └── Makefile</span><br><span class="line">└── unittest</span><br><span class="line">    ├── client.c</span><br><span class="line">    ├── disp_test.c</span><br><span class="line">    ├── font_test.c</span><br><span class="line">    ├── input_manager_test.c</span><br><span class="line">    ├── Makefile</span><br><span class="line">    ├── page_test.c</span><br><span class="line">    └── ui_test.c</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-1-zi-mu-lu-makefile-display-wei-li">4.3.1 子目录<code>MakeFIle-display</code>为例</span><a href="#4-3-1-zi-mu-lu-makefile-display-wei-li" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS :=</span><br><span class="line">CFLAGS_file.o :=</span><br><span class="line">obj-y += disp_manager.o</span><br><span class="line">obj-y += framebuffer.o</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi">4.3.2 编译详细输出日志</span><a href="#4-3-2-bian-yi-xiang-xi-shu-chu-ri-zhi" class="header-anchor">#</a></h3><p>顶层目录输入<code>make all V=1</code>来看详细的编译过程：</p>
<details>
<summary>点击查看代码</summary>
<pre><code>
start_recursive_build
obj-y = display/ ui/ page/ config/ business/
make -C ./ -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[1]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command'
********************  echo_obj  *************************
obj-y: display/ ui/ page/ config/ business/
__subdir-y:display ui page config business
subdir-y: display ui page config business
subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o
cur_objs:
**********************************************************
subdir-y = display
make -C display -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display'
********************  echo_obj  *************************
obj-y: disp_manager.o framebuffer.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:disp_manager.o framebuffer.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.disp_manager.o.d -c -o disp_manager.o disp_manager.c
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.framebuffer.o.d -c -o framebuffer.o framebuffer.c
ld -r -o built-in.o disp_manager.o framebuffer.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display'
subdir-y = ui
make -C ui -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui'
********************  echo_obj  *************************
obj-y: button.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:button.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.button.o.d -c -o button.o button.c
ld -r -o built-in.o button.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui'
subdir-y = page
make -C page -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page'
********************  echo_obj  *************************
obj-y: main_page.o page_manager.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:main_page.o page_manager.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.main_page.o.d -c -o main_page.o main_page.c
main_page.c:198:16: warning: ‘GetButtonByInputEvent’ defined but not used [-Wunused-function]
  198 | static Button* GetButtonByInputEvent(InputEvent *pInputEvent)
      |                ^~~~~~~~~~~~~~~~~~~~~
main_page.c:103:13: warning: ‘GenerateButtons’ defined but not used [-Wunused-function]
  103 | static void GenerateButtons(void)
      |             ^~~~~~~~~~~~~~~
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.page_manager.o.d -c -o page_manager.o page_manager.c
ld -r -o built-in.o main_page.o page_manager.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page'
subdir-y = config
make -C config -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config'
********************  echo_obj  *************************
obj-y: config.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:config.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.config.o.d -c -o config.o config.c
ld -r -o built-in.o config.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config'
subdir-y = business
make -C business -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build
make[2]: Entering directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business'
********************  echo_obj  *************************
obj-y: main.o
__subdir-y:
subdir-y:
subdir_objs:
cur_objs:main.o
**********************************************************
gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/include   -Wp,-MD,.main.o.d -c -o main.o main.c
main.c: In function ‘main’:
main.c:12:9: warning: unused variable ‘err’ [-Wunused-variable]
   12 |     int err;
      |         ^~~
ld -r -o built-in.o main.o
make[2]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business'
ld -r -o built-in.o display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o
make[1]: Leaving directory '/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command'
gcc -o test built-in.o -lpthread -lfreetype -lm
test has been built!
</code></pre></details>


<h3><span id="4-3-3-bian-yi-ru-kou">4.3.3 编译入口</span><a href="#4-3-3-bian-yi-ru-kou" class="header-anchor">#</a></h3><p>首先编译目标<code>start_recursive_build</code>， 列出目标、要进行编译的子目录模块，进入当前Makefile所在目录，按照顶层<code>Makefile.build</code>的规则编译，打印如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">start_recursive_build</span><br><span class="line">obj-y = display/ ui/ page/ config/ business/</span><br></pre></td></tr></table></figure>

<h3><span id="4-3-4-bian-yi-build">4.3.4 编译<code>__build</code></span><a href="#4-3-4-bian-yi-build" class="header-anchor">#</a></h3><p>执行顶层<code>Makefile.build</code>，执行目标<code>__build</code>，执行<code>echo_obj</code>， 打印:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -C ./ -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/</span><br><span class="line">31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[1]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: display/ ui/ page/ config/ business/</span></span><br><span class="line"><span class="section">__subdir-y:display ui page config business</span></span><br><span class="line"><span class="section">subdir-y: display ui page config business</span></span><br><span class="line"><span class="section">subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span></span><br><span class="line"><span class="section">cur_objs:</span></span><br><span class="line">**********************************************************</span><br></pre></td></tr></table></figure>

<h4><span id="4-3-4-1-bian-yi-subdir-y">4.3.4.1 编译<code>$(subdir-y)</code></span><a href="#4-3-4-1-bian-yi-subdir-y" class="header-anchor">#</a></h4><p>在每个子目录产生<code>build-in.o</code>：</p>
<p>执行<code>$(subdir-y)</code>， 又<code>$(subdir-y)=display ui page config business</code>，因此目标编译规则展开如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">display ui page config business:</span><br><span class="line">        @echo subdir-y = <span class="variable">$@</span></span><br><span class="line">        make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br></pre></td></tr></table></figure>

<p>打印如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = display</span><br><span class="line">make -C display -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: disp_manager.o framebuffer.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:disp_manager.o framebuffer.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.disp_manager.o.d -c -o disp_manager.o disp_manager.c</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.framebuffer.o.d -c -o framebuffer.o framebuffer.c</span><br><span class="line">ld -r -o built-in.o disp_manager.o framebuffer.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/display&#x27;</span></span><br></pre></td></tr></table></figure>

<p>分析：目标是<code>display</code>，进入<code>display</code>目录，按照顶层<code>Makefile.build</code>的规则编译，再次递归调用<code>__build</code>，可以看到只有当子目录<code>subdir-y</code>为空了，才不会递归进去，那么此时会执行<code>built-in.o</code>目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<p>此时按照推导规则进行<code>disp_manager.o， framebuffer.o</code>的编译，在<code>dispaly</code>目录下打包成<code>build-in.o</code>。</p>
<p>同理，<code>ui</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = ui</span><br><span class="line">make -C ui -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: button.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:button.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.button.o.d -c -o button.o button.c</span><br><span class="line">ld -r -o built-in.o button.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/ui&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>page</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = page</span><br><span class="line">make -C page -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: main_page.o page_manager.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:main_page.o page_manager.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.main_page.o.d -c -o main_page.o main_page.c</span><br><span class="line"><span class="section">main_page.c:198:16: warning: ‘GetButtonByInputEvent’ defined but not used [-Wunused-function]</span></span><br><span class="line">  198 | static Button* GetButtonByInputEvent(InputEvent *pInputEvent)</span><br><span class="line">      |                ^~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"><span class="section">main_page.c:103:13: warning: ‘GenerateButtons’ defined but not used [-Wunused-function]</span></span><br><span class="line">  103 | static void GenerateButtons(void)</span><br><span class="line">      |             ^~~~~~~~~~~~~~~</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.page_manager.o.d -c -o page_manager.o page_manager.c</span><br><span class="line">ld -r -o built-in.o main_page.o page_manager.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/page&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>config</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = config</span><br><span class="line">make -C config -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: config.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:config.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.config.o.d -c -o config.o config.c</span><br><span class="line">ld -r -o built-in.o config.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/config&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同理，<code>business</code>目录编译：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">subdir-y = business</span><br><span class="line">make -C business -f /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/Makefile.build</span><br><span class="line"><span class="section">make[2]: Entering directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business&#x27;</span></span><br><span class="line">********************  echo_obj  *************************</span><br><span class="line"><span class="section">obj-y: main.o</span></span><br><span class="line"><span class="section">__subdir-y:</span></span><br><span class="line"><span class="section">subdir-y:</span></span><br><span class="line"><span class="section">subdir_objs:</span></span><br><span class="line"><span class="section">cur_objs:main.o</span></span><br><span class="line">**********************************************************</span><br><span class="line">gcc -Wall -O2 -g -I /media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/<span class="keyword">include</span>   -Wp,-MD,.main.o.d -c -o main.o main.c</span><br><span class="line"><span class="section">main.c: In function ‘main’:</span></span><br><span class="line"><span class="section">main.c:12:9: warning: unused variable ‘err’ [-Wunused-variable]</span></span><br><span class="line">   12 |     int err;</span><br><span class="line">      |         ^~~</span><br><span class="line">ld -r -o built-in.o main.o</span><br><span class="line"><span class="section">make[2]: Leaving directory &#x27;/media/cvitek/robin.lee/my_test/study/weidongshan/imx6study/project/electronic_test_tools/31_improve_command/business&#x27;</span></span><br></pre></td></tr></table></figure>

<h4><span id="4-3-4-2-da-bao-cheng-zong-de-built-in-o">4.3.4.2 打包成总的<code>built-in.o</code></span><a href="#4-3-4-2-da-bao-cheng-zong-de-built-in-o" class="header-anchor">#</a></h4><p>最后子目录的<code>built-in.o</code>都生成了，再来返回顶层<code>Makefile</code>，此时<code>subdir_objs和cur_objs</code>如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">subdir_objs:display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span></span><br><span class="line"><span class="section">cur_objs:</span></span><br></pre></td></tr></table></figure>

<p>那么继续：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">        <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ld -r -o built-in.o display/built-in.o ui/built-in.o page/built-in.o config/built-in.o business/built-in.o</span><br></pre></td></tr></table></figure>

<p>至此，<code>__build</code>目标执行完毕。</p>
<h3><span id="4-3-5-bian-yi-chu-kou">4.3.5 编译出口</span><a href="#4-3-5-bian-yi-chu-kou" class="header-anchor">#</a></h3><p>回到顶层<code>makefile</code>的<code>start_recursive_build</code>，回到<code>all</code>目标，执行<code>$(TARGET)</code>目标。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">gcc -o test built-in.o -lpthread -lfreetype -lm</span><br></pre></td></tr></table></figure>

<p>最终回到<code>all</code>目标,打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test has been built!</span><br></pre></td></tr></table></figure>

<h1><span id="5-tong-yong-xing-makefile2-luo-ji-ban">5 通用型<code>makefile2</code>-裸机版</span><a href="#5-tong-yong-xing-makefile2-luo-ji-ban" class="header-anchor">#</a></h1><h2><span id="5-1-wen-jian-gong-cheng-mu-lu">5.1 文件工程目录</span><a href="#5-1-wen-jian-gong-cheng-mu-lu" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ tree</span></span><br><span class="line">├── bsp</span><br><span class="line">│   ├── clk</span><br><span class="line">│   │   ├── bsp_clk.c</span><br><span class="line">│   │   └── bsp_clk.h</span><br><span class="line">│   ├── delay</span><br><span class="line">│   │   ├── bsp_delay.c</span><br><span class="line">│   │   └── bsp_delay.h</span><br><span class="line">│   └── led</span><br><span class="line">│       ├── bsp_led.c</span><br><span class="line">│       └── bsp_led.h</span><br><span class="line">├── imx6ul</span><br><span class="line">│   ├── cc.h</span><br><span class="line">│   ├── fsl_common.h</span><br><span class="line">│   ├── fsl_iomuxc.h</span><br><span class="line">│   ├── imx6ul.h</span><br><span class="line">│   └── MCIMX6Y2.h</span><br><span class="line">├── imx6ul.lds</span><br><span class="line">├── imxdownload</span><br><span class="line">├── Makefile</span><br><span class="line">├── obj</span><br><span class="line">└── project</span><br><span class="line">    ├── main.c</span><br><span class="line">    └── start.S</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-lds-lian-jie-jiao-ben">5.2 lds链接脚本</span><a href="#5-2-lds-lian-jie-jiao-ben" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    . = <span class="number">0X87800000</span>;</span><br><span class="line">    .text :</span><br><span class="line">    &#123;</span><br><span class="line">        obj/start.o </span><br><span class="line">        *(.text)</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : &#123;*(.rodata*)&#125;     </span><br><span class="line">    .data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123; *(.data) &#125;    </span><br><span class="line">    __bss_start = .;    </span><br><span class="line">    .bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : &#123; *(.bss)  *(COMMON) &#125;    </span><br><span class="line">    __bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-makefile">5.3 <code>Makefile</code></span><a href="#5-3-makefile" class="header-anchor">#</a></h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE ?= arm-linux-gnueabihf-</span><br><span class="line">TARGET ?= bsp</span><br><span class="line">CC := <span class="variable">$(CROSS_COMPILE)</span>gcc</span><br><span class="line">LD := <span class="variable">$(CROSS_COMPILE)</span>ld</span><br><span class="line">OBJCOPY := <span class="variable">$(CROSS_COMPILE)</span>objcopy</span><br><span class="line">OBJDUMP := <span class="variable">$(CROSS_COMPILE)</span>objdump</span><br><span class="line"></span><br><span class="line">INCDIRS := imx6ul \</span><br><span class="line">　　　　　　bsp/clk \</span><br><span class="line">　　　　　　bsp/led \</span><br><span class="line">　　　　　　bsp/delay</span><br><span class="line"></span><br><span class="line">SRCDIRS := project \</span><br><span class="line">　　　　　　bsp/clk \</span><br><span class="line">　　　　　　bsp/led \</span><br><span class="line">　　　　　　bsp/delay</span><br><span class="line"></span><br><span class="line">INCLUDE := <span class="variable">$(<span class="built_in">patsubst</span> %, -I %, <span class="variable">$(INCDIRS)</span>)</span></span><br><span class="line"></span><br><span class="line">SFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.S)</span>)</span><br><span class="line">CFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(SRCDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line">SFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SFILES)</span>)</span></span><br><span class="line">CFILENDIR := <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(CFILES)</span>)</span></span><br><span class="line"></span><br><span class="line">SOBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(SFILENDIR:.S=.o)</span>)</span><br><span class="line">COBJS := <span class="variable">$(<span class="built_in">patsubst</span> %, obj/%, $(CFILENDIR:.c=.o)</span>)</span><br><span class="line">OBJS := <span class="variable">$(SOBJS)</span> <span class="variable">$(COBJS)</span></span><br><span class="line"></span><br><span class="line">VPATH := <span class="variable">$(SRCDIRS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.bin : <span class="variable">$(OBJS)</span></span><br><span class="line">　　<span class="variable">$(LD)</span> -Timx6ul.lds -o <span class="variable">$(TARGET)</span>.elf <span class="variable">$^</span></span><br><span class="line">　　<span class="variable">$(OBJCOPY)</span> -O binary -S <span class="variable">$(TARGET)</span>.elf <span class="variable">$@</span></span><br><span class="line">　　<span class="variable">$(OBJDUMP)</span> -D -m arm <span class="variable">$(TARGET)</span>.elf &gt; <span class="variable">$(TARGET)</span>.dis</span><br><span class="line"></span><br><span class="line"><span class="variable">$(SOBJS)</span> : obj/%.o : %.S</span><br><span class="line">　　<span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line">　　<span class="variable">$(CC)</span> -Wall -nostdlib -c -O2 <span class="variable">$(INCLUDE)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">print:</span></span><br><span class="line">　　@echo INCDIRS=<span class="variable">$(INCDIRS)</span></span><br><span class="line">　　@echo SRCDIRS=<span class="variable">$(SRCDIRS)</span></span><br><span class="line">　　@echo INCLUDE=<span class="variable">$(INCLUDE)</span></span><br><span class="line">　　@echo SFILES=<span class="variable">$(SFILES)</span></span><br><span class="line">　　@echo CFILES=<span class="variable">$(CFILES)</span></span><br><span class="line">　　@echo SFILENDIR=<span class="variable">$(SFILENDIR)</span></span><br><span class="line">　　@echo CFILENDIR=<span class="variable">$(CFILENDIR)</span></span><br><span class="line">　　@echo SOBJS=<span class="variable">$(SOBJS)</span></span><br><span class="line">　　@echo COBJS=<span class="variable">$(COBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">　　rm -rf <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.dis <span class="variable">$(TARGET)</span>.bin <span class="variable">$(COBJS)</span> <span class="variable">$(SOBJS)</span></span><br></pre></td></tr></table></figure>

<p>打印出目标和依赖文件:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ make print</span></span><br><span class="line">INCDIRS=imx6ul bsp/clk bsp/led bsp/delay</span><br><span class="line">SRCDIRS=project bsp/clk bsp/led bsp/delay</span><br><span class="line">INCLUDE= -I imx6ul -I bsp/clk -I bsp/led -I bsp/delay</span><br><span class="line">SFILES= project/start.S</span><br><span class="line">CFILES= project/main.c bsp/clk/bsp_clk.c bsp/led/bsp_led.c bsp/delay/bsp_delay.c</span><br><span class="line">SFILENDIR=start.S</span><br><span class="line">CFILENDIR=main.c bsp_clk.c bsp_led.c bsp_delay.c</span><br><span class="line">SOBJS= obj/start.o</span><br><span class="line">COBJS= obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br></pre></td></tr></table></figure>

<p>编译结果如下:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">book@100ask:~/ftp/openedv/bak_drv_prj/05_ledc_bsp$ make</span></span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/start.o project/start.S</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/main.o project/main.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_clk.o bsp/clk/bsp_clk.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_led.o bsp/led/bsp_led.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -Wall -nostdlib -c -O2   -I imx6ul  -I bsp/clk  -I bsp/led  -I bsp/delay -o obj/bsp_delay.o bsp/delay/bsp_delay.c</span><br><span class="line">arm-buildroot-linux-gnueabihf-ld -Timx6ul.lds -o bsp.elf obj/start.o obj/main.o obj/bsp_clk.o obj/bsp_led.o obj/bsp_delay.o</span><br><span class="line">arm-buildroot-linux-gnueabihf-objcopy -O binary -S bsp.elf bsp.bin</span><br><span class="line">arm-buildroot-linux-gnueabihf-objdump -D -m arm bsp.elf &gt; bsp.dis</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
        <tag>linux系统构建</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-内存控制器</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-nei-cun-jie-kou-gai-nian">1 内存接口概念</a><ul>
<li><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</a></li>
<li><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</a><ul>
<li><a href="#1-2-1-men-dian-lu-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</a></li>
<li><a href="#1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</a><ul>
<li><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</a></li>
<li><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</a></li>
<li><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</a></li>
<li><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</a></li>
<li><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</a></li>
</ul>
</li>
<li><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</a><ul>
<li><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</a></li>
</ul>
</li>
<li><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</a></li>
<li><a href="#5-sdram-fang-wen-shi-li">5 SDRAM访问实例</a><ul>
<li><a href="#5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</a></li>
<li><a href="#5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</a></li>
<li><a href="#5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</a></li>
<li><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</a></li>
<li><a href="#5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</a><ul>
<li><a href="#5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</a></li>
<li><a href="#5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</a></li>
<li><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</a></li>
<li><a href="#5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</a></li>
<li><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</a></li>
<li><a href="#5-5-6-ce-shi-dai-ma">5.5.6 测试代码</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-norflash-fang-wen-shi-li">6 NorFlash访问实例</a><ul>
<li><a href="#6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</a></li>
<li><a href="#6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</a></li>
<li><a href="#6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</a></li>
<li><a href="#6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</a></li>
<li><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</a></li>
<li><a href="#6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</a><ul>
<li><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</a><ul>
<li><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</a><ul>
<li><a href="#6-6-1-1-1-tacc">6.6.1.1.1 Tacc</a></li>
<li><a href="#6-6-1-1-2-tacs-tcos-tcoh-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-6-2-ce-shi-dai-ma">6.6.2 测试代码</a><ul>
<li><a href="#6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</a><ul>
<li><a href="#7-1-cao-zuo-norflash">7.1 操作NorFlash</a><ul>
<li><a href="#7-1-1-reset">7.1.1 reset</a></li>
<li><a href="#7-1-2-du-id">7.1.2 读ID</a></li>
<li><a href="#7-1-3-du-shu-ju">7.1.3 读数据</a></li>
<li><a href="#7-1-4-du-shu-xing">7.1.4 读属性</a></li>
<li><a href="#7-1-5-xie-shu-ju">7.1.5 写数据</a><ul>
<li><a href="#7-1-5-1-ca-chu">7.1.5.1 擦除</a></li>
<li><a href="#7-1-5-2-xie-ru">7.1.5.2 写入</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</a><ul>
<li><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</a></li>
<li><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</a></li>
<li><a href="#7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</a><ul>
<li><a href="#8-1-shi-bie-norflash">8.1 识别NorFlash</a><ul>
<li><a href="#8-1-1-fa-ming-ling">8.1.1 发命令</a></li>
<li><a href="#8-1-2-du-yi-ci-shu-ju">8.1.2 读一次数据</a></li>
<li><a href="#8-1-3-shi-bie-han-shu">8.1.3 识别函数</a></li>
</ul>
</li>
<li><a href="#8-2-du-shu-ju">8.2 读数据</a></li>
<li><a href="#8-3-ca-shu-ju">8.3 擦数据</a></li>
<li><a href="#8-3-xie-shu-ju">8.3 写数据</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-nei-cun-jie-kou-gai-nian">1 内存接口概念</span><a href="#1-nei-cun-jie-kou-gai-nian" class="header-anchor">#</a></h1><h2><span id="1-1-bu-tong-lei-xing-de-kong-zhi-qi">1.1 不同类型的控制器</span><a href="#1-1-bu-tong-lei-xing-de-kong-zhi-qi" class="header-anchor">#</a></h2><p>S3C2440是个片上系统，有GPIO控制器（接有GPIO管脚(GPA-GPH)）,有串口控制器 (接有TXD RXD引脚),有memory controller内存控制器，有Nand控制器等…</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/1.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">（<span class="number">1</span>）GPIO控制器属于门电路，不涉及到时序，相对简单。</span><br><span class="line">（<span class="number">2</span>）串口控制器属于协议类接口，类似的协议类接口还有iic、iis、spi等。 </span><br><span class="line">（<span class="number">3</span>）前面的GPIO/门电路接口、协议类接口，都不会把地址输出到外部设备，仅仅只是将地址写入到相应的控制器。</span><br><span class="line">接下来的内存类接口，会把地址输出到外部，cpu将地址写入内存控制器，内存控制器还需访问外部设备，比如NorFlash、网卡、SDRAM。</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi">1.2 如何访问控制器地址</span><a href="#1-2-ru-he-fang-wen-kong-zhi-qi-di-zhi" class="header-anchor">#</a></h2><p>GPIO&#x2F;门电路接口、协议类接口、内存类接口都属于CPU的统一编址。但对于Nand Flash，它没有独立的地址线和cpu的地址总线相连接，因此它不参与CPU的统一编址。</p>
<h3><span id="1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi">1.2.1 门电路&#x2F;协议类控制器</span><a href="#1-2-1-men-dian-lu-x2f-xie-yi-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于门电路接口、协议类接口，直接访问寄存器即可。</p>
<h3><span id="1-2-2-nei-cun-lei-kong-zhi-qi">1.2.2 内存类控制器</span><a href="#1-2-2-nei-cun-lei-kong-zhi-qi" class="header-anchor">#</a></h3><p>对于内存类接口，交给内存控制器去处理。下面详细分析：</p>
<p>CPU只管发出一个地址，内存控制器根据该地址范围选择不同的模块，然后从模块中得到数据或者发送数据到模块中。<br>如下图，SDRAM、DM9000网卡、Nor Flash都接在s3c2440的数据总线和地址总线上，CPU把数据和地址发送出去，然后内存控制器根据地址范围确定要拉低选中哪个片选信号（nCS），再根据片选信号（nCS）选择相应的设备，进行收发地址和数据，互不干扰。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpg"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="image-20240411202307277"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)当CPU发出的指令的地址范围处于<span class="number">0x00000000</span> - <span class="number">0x08000000</span>，</span><br><span class="line">内存控制器就会使nGCS0处于低电平（片选引脚被选中），NorFlash被选中。(NorFlash启动时才行，nand启动时nGCS0这块对应SRAM)</span><br><span class="line">(<span class="number">2</span>)当CPU发出的指令的地址范围处于<span class="number">0x20000000</span> - <span class="number">0x28000000</span>，</span><br><span class="line">内存控制器就会使nGCS4处于低电平（片选引脚被选中），网卡DM9000被选中。</span><br><span class="line">(<span class="number">3</span>)当CPU发出的指令的地址范围处于<span class="number">0x30000000</span> - <span class="number">0x38000000</span>，</span><br><span class="line">内存控制器就会使nGCS6处于低电平（片选引脚被选中），SDRAM被选中</span><br></pre></td></tr></table></figure>

<p>内存控制器根据不同的地址地址范围，发出不同的片选引脚，只有被片选引脚选中的芯片才能正常工作，不被选中的芯片就像不存在一样，不工作。</p>
<p>从s3c2440 datasheet中我们得知内存控制器可访问的地址范围有1G(0x0000,0000-0x4000,0000)，8个bank,每个bank_size为128M。理论上需要2^30（30条地址线）来确定是哪个bank,哪个地址。但是实际上只用到了27条,那么是怎么确定是哪个bank被选中了呢？</p>
<p>cpu每次发给内存控制器的地址都是Addr[31:0],但是内存控制器发给外设（sdram，nor,dm9000）却只用到了A[26:0]。第[29:27]被用来确定要拉低哪个nGCS，即要选中哪个bank:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">bit[<span class="number">29</span>:<span class="number">27</span>]		bit[<span class="number">26</span>:<span class="number">0</span>]</span><br><span class="line"><span class="number">0b000</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank0被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b001</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  (bank1被选中 （<span class="number">128</span>M）)</span><br><span class="line">...				...</span><br><span class="line"><span class="number">0b110</span>		-&gt;    <span class="number">0x000</span>,<span class="number">0000</span><span class="number">-0x7ff</span>,ffff  （bank6被选中 （<span class="number">128</span>M））</span><br><span class="line"><span class="number">0b111</span>		-&gt;    <span class="number">0x800</span>,<span class="number">0000</span><span class="number">-0xfff</span>,ffff  （bank7被选中 （<span class="number">128</span>M））</span><br></pre></td></tr></table></figure>

<p>那么对于大容量的nandflash，理论上需要更多的地址线来确认访问地址，那既然没有地址线，cpu是如何访问nand的呢？当然是通过nand控制器，nand是地址、命令、数据都共用数据总线。这里只是引入一个话题，具体见<a href="https://www.cnblogs.com/fuzidage/p/13020052.html">s3c2440裸机-nand控制器</a>。</p>
<h1><span id="2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi">2 不同位宽内存与CPU地址连接关系</span><a href="#2-bu-tong-wei-kuan-nei-cun-yu-cpu-di-zhi-lian-jie-guan-xi" class="header-anchor">#</a></h1><p>s3c2440芯片手册上外设rom与CPU地址总线连接如下：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/4.png"></p>
<h2><span id="2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.1 8bit x1 rom与CPU地址线连接</span><a href="#2-1-8bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/5.png"></p>
<h2><span id="2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.2 8bit x2 rom与CPU地址线连接</span><a href="#2-2-8bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/6.png"></p>
<h2><span id="2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie">2.3 8bit x4 rom与CPU地址线连接</span><a href="#2-3-8bit-x4-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/7.png"></p>
<h2><span id="2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie">2.4 16bit  x1 rom与CPU地址线连接</span><a href="#2-4-16bit-x1-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/8.png"></p>
<h2><span id="2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie">2.5 16bit  x2 rom与CPU地址线连接</span><a href="#2-5-16bit-x2-rom-yu-cpu-di-zhi-xian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/9.png"><br>从上面的图中，我们知道可以对2片位宽为8bit的内存扩展级联成1个16bit的内存，同理可用4片位宽为8bit的内存进行级联成1个32bit的内存。</p>
<h1><span id="3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian">3 不同位宽内存与CPU为什么要错位相连</span><a href="#3-bu-tong-wei-kuan-nei-cun-yu-cpu-wei-shi-me-yao-cuo-wei-xiang-lian" class="header-anchor">#</a></h1><p>从上面的图中，我们还看见一个规律:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">当外设总线位宽为<span class="number">8b</span>it时， 外设A0接CPU的地址总线ADDR[<span class="number">0</span>],</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">1</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">16b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">1</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">2</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">16</span>]</span><br><span class="line"></span><br><span class="line">当外设总线位宽为<span class="number">32b</span>it时，外设A0接CPU的地址总线ADDR[<span class="number">2</span>]，</span><br><span class="line">A[<span class="number">1</span>]-&gt;ADDR[<span class="number">3</span>] ...A[<span class="number">15</span>]-&gt;ADDR[<span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>为什么要这样设计呢？先看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0， #3</span><br><span class="line">LDRB R1, [R0]  @ 从内存地址为3的地方，读出一个字节到R1</span><br></pre></td></tr></table></figure>

<p>如图有8bitROM、16bitROM、32bitROM:<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）对于8bitROM ，8bit是一次读写的最小单位，即0地址是第一个8bit，1地址是第二个8bit;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，8bitROM的A0和A1收到的也都是1，</span><br><span class="line">于是找到了ROM上地址为3的8bit数据,包含了我们需要的数据。</span><br><span class="line"></span><br><span class="line">（2）对于16bitROM ，16bit是一次读写的最小单位，即0地址是第一个16bit，里面有两个8bit数据;</span><br><span class="line">CPU发出地址3，即A0和A1都为1，16bitROM的A0和A1分别收到的是1和0，</span><br><span class="line">于是找到了ROM上地址为1的16bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br><span class="line"></span><br><span class="line">（3）对于32bitROM ，32bit是一次读写的最小单位，即0地址是第一个32bit，里面有四个8bit数据;</span><br><span class="line">CPU发出的地址3，即A0和A1都为0，32bitROM的A0和A1收到的都是0，</span><br><span class="line">于是找到了ROM上地址为0的32bit数据，包含了我们需要的数据，最后内存控制器再帮我们挑选出所需的8bit数据。</span><br></pre></td></tr></table></figure>

<p>用表格更好理解：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址</th>
<th>ROM返回数据</th>
<th>内存控制器挑选出数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000011</td>
<td>0b000011</td>
<td>编号3的存储单元中的8数据</td>
<td>编号3的存储单元中的8数据</td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000011</td>
<td>0b000001</td>
<td>编号1的存储单元中的16数据</td>
<td>根据”A0&#x3D;1”,挑出低8bit数据</td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000011</td>
<td>0b000000</td>
<td>编号0的存储单元中的32数据</td>
<td>根据”A1A0&#x3D;11”,挑出最低8bit数据</td>
</tr>
</tbody></table>
<p>对上图的数据再次整理：</p>
<table>
<thead>
<tr>
<th>ROM&#x2F;bit</th>
<th>CPU发出地址</th>
<th>ROM收到地址（内存控制器转发给rom）</th>
<th>ROM返回数据</th>
<th>内存控制器组装数据给CPU</th>
</tr>
</thead>
<tbody><tr>
<td>8bit(ROM)</td>
<td>0b000100</td>
<td>0b000100</td>
<td>地址4的一个1byte数据</td>
<td>组装地址7、6、5、4数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000101</td>
<td>地址5的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000110</td>
<td>地址6的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b000111</td>
<td>地址7的一个1byte数据</td>
<td></td>
</tr>
<tr>
<td>16bit(ROM)</td>
<td>0b000100</td>
<td>0b00010</td>
<td>地址2的一个2byte数据</td>
<td>组装地址3、2的数据成4字节数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0b00011</td>
<td>地址3的一个2byte数据</td>
<td></td>
</tr>
<tr>
<td>32bit(ROM)</td>
<td>0b000100</td>
<td>0b00001</td>
<td>地址1的一个4byte数据</td>
<td>直接返回4字节数据</td>
</tr>
</tbody></table>
<p>这里牵扯到地址、内存中数据的排列存储，有点深入，如果实在无法理解，记住怎么去错位相连就好了。<br><strong>结论：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>和cpu地址总线相连的外设地址线确定了要访问外设的地址，即哪个存储单元；</span><br><span class="line"><span class="number">2.</span>然后内存控制器拿到外设存储单元中的数据后，再根据那几个错开的引脚[A1-A0]的值（CPU地址总线没接的那几个引脚的值），来挑出相应的数据给CPU。</span><br></pre></td></tr></table></figure>

<p>再举一个例子， 假如读取一个32位的数据时，前面读的是8位数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0,   #4</span><br><span class="line">LDR  R1,  [R0]  @去地址4，读取4字节数据</span><br></pre></td></tr></table></figure>

<p>我们知道CPU发出的是32bit地址,那么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于32bit Rom，内存控制器会给它发1次，rom也会相应的接收1次;</span><br><span class="line">对于16bit Rom，内存控制器会给它发2次，rom也会相应的接收2次;</span><br><span class="line">对于8bit  Rom，内存控制器给它发4次， rom接收4次，</span><br></pre></td></tr></table></figure>

<h2><span id="3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan">3.1 配置内存控制器位宽</span><a href="#3-1-pei-zhi-nei-cun-kong-zhi-qi-wei-kuan" class="header-anchor">#</a></h2><p>接不同的rom外设，s3c2440内存控制器总线位宽要配置成不一样。位宽和等待控制寄存器如下：<br>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER):</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/11.png" alt="img"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000</code></p>
<h1><span id="4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei">4 内存控制器地址映射范围</span><a href="#4-nei-cun-kong-zhi-qi-di-zhi-ying-she-fan-wei" class="header-anchor">#</a></h1><p>怎样确定芯片的访问地址？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 根据片选信号确定基地址</span><br><span class="line">2. 根据芯片所接地址线确定范围</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/12.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/13.png"></p>
<table>
<thead>
<tr>
<th>外设类型</th>
<th>接内存控制器的哪个片选</th>
<th>基地址</th>
<th>占用CPU的地址总线</th>
<th>地址范围(offset + size)</th>
</tr>
</thead>
<tbody><tr>
<td>nor</td>
<td>nGCS0</td>
<td>0x0000,0000</td>
<td>ADDR0-ADDR20</td>
<td>0x0000,0000 ~ 0x001f,ffff(2M)</td>
</tr>
<tr>
<td>dm9000网卡</td>
<td>nGCS4</td>
<td>0x2000,0000</td>
<td>ADDR0和ADDR2</td>
<td>0x2000,0000 ~ 0x2000,0005(5byte)</td>
</tr>
<tr>
<td>sdram</td>
<td>nGCS6</td>
<td>0x3000,0000</td>
<td>ADDR0-ADDR25</td>
<td>0x3000,0000 ~ 0x3000,0000 + RAM_SIZE</td>
</tr>
</tbody></table>
<p>这里再次提醒一下: 有人发现上图中nor没有和CPU的ADDR0相连接，sdram没有和CPU的ADDR0、ADDR1相连接。不要觉得ADDR0、ADDR1没用到，由于nor数据位宽是16bit，ADDR0是给内存控制器拆分数据用的，同样sdram数据位宽32bit，ADDR0、ADDR1也是给内存控制器拆分数据用的。这个上面已分析过，这也是什么要错位连接的原因。</p>
<h1><span id="5-sdram-fang-wen-shi-li">5 SDRAM访问实例</span><a href="#5-sdram-fang-wen-shi-li" class="header-anchor">#</a></h1><p>以EM63A165TS-6G这款外接SRAM存储来展开介绍。</p>
<h2><span id="5-1-sdram-cun-chu-jie-gou">5.1 SDRAM存储结构</span><a href="#5-1-sdram-cun-chu-jie-gou" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpg"></p>
<h2><span id="5-2-sdram-yin-jiao-jie-xian">5.2 SDRAM引脚接线</span><a href="#5-2-sdram-yin-jiao-jie-xian" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/15.png"></p>
<p>这里采用2片 EM63A165TS-6G 级联作为外接内存，关于EM63A165TS-6G的规则描述参考datasheet。可以看到该sdram是16bit 的，从接线可以看出第一片存储低16位数据，第二片存储高16位数据。</p>
<p>引脚说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A0-A12：地址总线</span><br><span class="line">D0-D15:数据总线（位宽<span class="number">16</span>,<span class="number">2</span>片级联成位宽<span class="number">32</span>）</span><br><span class="line">BA0-BA1:bank选择</span><br><span class="line">nSCS：片选</span><br><span class="line">nSRAS:行地址选择</span><br><span class="line">nSCAS:列地址选择</span><br><span class="line">nWE:写使能</span><br><span class="line">SCLK:时钟</span><br><span class="line">SCKE:时钟使能</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-sdram-di-zhi-fan-wei">5.3 SDRAM地址范围</span><a href="#5-3-sdram-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面提到片选接了nGCS6，地址映射的base_addr&#x3D;0x3000,0000,那么size是多大呢？</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/16.png"></p>
<p>容量为：4M word x 16-bit x 4-bank &#x3D; 32M，再看原理图我们是两片级联，所以容量为4M word x 32-bit x 4-bank&#x3D;64M。所以地址范围是**[0x3000_0000 ~ 0x33ff_ffff]**</p>
<p>在对比另一款W9825G6KH SDRAM为例，地址总线A0-A12,数据总线D0-D15,因此内存大小：2^13 * 2^9 &#x3D;  &#x3D; 4194304,等于4M,加上有4个bank，数据为宽16位，因此内存大小4Mx4x2字节。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/17.png" alt="image"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/18.png" alt="image"></p>
<p>框图翻译成中文形式：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/19.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLK：时钟线，SDRAM 是同步动态随机存储器，“同步”的意思就是时钟，因此需要一根额外的时钟线，这是和 SRAM 最大的不同，SRAM 没有时钟线。</span><br><span class="line">CKE：时钟使能信号线，SRAM 没有 CKE 信号。</span><br><span class="line">CS：片选信号，这个和 SRAM 一样，都有片选信号。</span><br><span class="line">RAS：行选通信号，低电平有效，SDRAM 和 SRAM 的寻址方式不同，SDRAM 按照行、列来确定某个具体的存储区域。因此就有行地址和列地址之分，行地址和列地址共同复用同一组地址线，要访问某一个地址区域，必须要先后发送行地址和列地址</span><br><span class="line">CAS：列选通信号，和 RAS 类似，低电平有效，选中以后就可以发送列地址了。</span><br><span class="line">WE：写使能信号，低电平有效</span><br><span class="line">A0-A12: 地址线</span><br><span class="line">DQ0-DQ15: 16位数据线</span><br><span class="line">BS0-BS1: BANK 选择线</span><br><span class="line">LDQM,UDQM: 高低字节数据选择线</span><br></pre></td></tr></table></figure>

<h2><span id="5-4-sdram-shu-ju-fang-wen-guo-cheng">5.4 SDRAM数据访问过程</span><a href="#5-4-sdram-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>我们知道64M&#x3D;2^20*2^6&#x3D;2^26，那么需要26条地址线，再看看原理图，我们发现SDRAM的地址线A[12:0]只有13条，那么最多只能访问2^13&#x3D;8K的数据，地址线明显配不上这么大的容量,那么它是如何解决的呢？</p>
<p>答：当然是<strong>拆分地址了，多次传输</strong>。</p>
<p>我们从SDRAM的内部存储结构得知要确定SDRAM的一个存储单元，先确定是哪个bank,然后再确定在哪一行、哪一列即可。SDRAM有4个bank,由BA0、BA1决定选中哪个bank,查看SDRAM手册见下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/20.png"></p>
<p>通过选中nSRAS选中行地址,从而发送行地址；最后通过选中nSCAS选中列地址，从而发送列地址。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr	r0, =0x30000000;</span><br><span class="line">ldr r1, [r0]; 从SDRAM基地址读取4byte数据</span><br></pre></td></tr></table></figure>

<p>过程如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>发出片选信号nGCS6，选中SDRAM</span><br><span class="line"><span class="number">2.</span>发出bank选中信号(BA0，BA1),确定是SDRAM上的哪个bank，从原理图得知CPU的ADDR24、ADDR25对应SDRAM上的BA0，BA1,所以让BA0、BA1=<span class="number">00</span>,选中bankA。</span><br></pre></td></tr></table></figure>

<p>然后从sdram规格书确定行列地址的数目：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/21.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span>发出行地址信号nSRAS,使能行地址传输。传输行地址，确定是哪一行（看SDRAM手册确定行地址数(A12-A0)<span class="number">13</span>条）</span><br><span class="line"><span class="number">4.</span>发出列地址信号nnSCAS,使能列地址传输。传输列地址，确定是哪一列(看SDRAM手册确定列地址(A8-A0)<span class="number">9</span>条)</span><br></pre></td></tr></table></figure>

<p>从而发送完整的0x30000000地址到了SDRAM,SDRAM返回4byte数据给CPU。</p>
<h2><span id="5-5-sdram-qu-dong-shi-li">5.5 SDRAM驱动实例</span><a href="#5-5-sdram-qu-dong-shi-li" class="header-anchor">#</a></h2><p>s3c2440内存控制器共有13个寄存器。我们要设置内存控制器参数，适配外接SDRAM。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BANK0--BANK5只需要设置BWSCON和BANKCONx(x为0～5）两个寄存器；</span><br><span class="line">BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-1-wei-kuan-ji-cun-qi">5.5.1 位宽寄存器</span><a href="#5-5-1-wei-kuan-ji-cun-qi" class="header-anchor">#</a></h3><p>BWSCON(BUSWIDTH&amp;WAITCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/22.png"></p>
<p><code>我们SDRAM的位宽为32,DW6[25:24]设置成10， 没有使用等待信号，所以WS6[26]=0。 bank7跟随bank6的配置， 因此BWSCON寄存器的值为：0x22000000。</code></p>
<h3><span id="5-5-2-bank-kong-zhi-ji-cun-qi">5.5.2 BANK控制寄存器</span><a href="#5-5-2-bank-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKCONTROLREGISTER:</p>
<p>在8个BANK中，只有BANK6和BANK7可以外接SRAM或SDRAM。BANKCON6设置参数如下：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/23.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MT[<span class="number">16</span>:<span class="number">15</span>]：设置BANK是ROM/SRAM还是DRAM，我们用的SDRAM，属于DRAM。</span><br><span class="line">Trcd[<span class="number">3</span>:<span class="number">2</span>]：行地址和列地址间隔多长时间，看SDRAM芯片手册时间间隔Trcd&gt;<span class="number">18</span>ns，我们HCLK=<span class="number">100</span>MHZ,clocks为<span class="number">10</span>ns,所以设置为<span class="number">2</span>clocks即可。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-3-shua-xin-kong-zhi-ji-cun-qi">5.5.3 刷新控制寄存器</span><a href="#5-5-3-shua-xin-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>REFRESH(REFRESHCONTROLREGISTER)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/24.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">REFEN[<span class="number">23</span>]：设置开启SDRAM的刷新功能。</span><br><span class="line">TREFMD[<span class="number">22</span>]：SDRAM的刷新模式，<span class="number">0</span>=CBR/AutoRefresh，选择自动刷新。</span><br><span class="line"></span><br><span class="line">Trp[<span class="number">21</span>：<span class="number">20</span>]：根据sdram手册Trp&gt;<span class="number">18</span>ns, 设为<span class="number">0</span>(<span class="number">2</span> clocks)即可。</span><br><span class="line">Tsrc[<span class="number">19</span>：<span class="number">18</span>]: Tsrc = Trc - Trp = Trc<span class="number">-20</span>, 根据sdram手册Trc&gt;=<span class="number">60</span>,我们取Trc =<span class="number">70</span>, 则Tsrc= <span class="number">50</span>ns(<span class="number">5</span>clocks)即可。</span><br><span class="line">RefreshCounter[<span class="number">10</span>:<span class="number">0</span>]：Refresh period = (<span class="number">211</span>-refresh_count+<span class="number">1</span>)/HCLK，</span><br><span class="line">RefreshCount = <span class="number">211</span> + <span class="number">1</span> - <span class="number">100</span>*Refresh period，看SDRAM手册“<span class="number">8192</span> refresh cycles/<span class="number">64</span>ms”， Refresh period= <span class="number">64000u</span>s/<span class="number">8192</span> = <span class="number">7.8u</span>s，</span><br><span class="line">RefreshCount取推荐值<span class="number">1269</span>= <span class="number">0x4f5</span>.</span><br><span class="line">综上，REFRESH寄存器设为<span class="number">0x8404F5</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-4-banksize-ji-cun-qi">5.5.4 BANKSIZE寄存器</span><a href="#5-5-4-banksize-ji-cun-qi" class="header-anchor">#</a></h3><p>BANKSIZEREG ISTER</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/25.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BURST_EN[<span class="number">7</span>]：<span class="number">0</span>=ARM核禁上突发传输，<span class="number">1</span>=ARM核支持突发传输(推荐)；</span><br><span class="line">SCKEEN[<span class="number">5</span>]：<span class="number">0</span>=不使用SCKE信号令SDRAM进入省电模式，<span class="number">1</span>=使用SCKE信号令SDRAM进入省电模式(推荐)；</span><br><span class="line">SCLK-EN[<span class="number">4</span>]：<span class="number">0</span>=时刻发出SCLK信号，<span class="number">1</span>=仅在访问SDRAM期间发出SCLK信号（推荐）；</span><br><span class="line">BK76MAP[<span class="number">2</span>:<span class="number">0</span>]：配置banksize成<span class="number">64</span>M</span><br><span class="line">因此，BANKSIZE寄存器设为<span class="number">0xB1</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-5-mo-shi-she-zhi-ji-cun-qi">5.5.5 模式设置寄存器</span><a href="#5-5-5-mo-shi-she-zhi-ji-cun-qi" class="header-anchor">#</a></h3><p>SDRAM MODE REGISTER SET REGISTER(MRSR)</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/26.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CL[<span class="number">6</span>:<span class="number">4</span>]:表示发出行、列地址后，等多久才返回收到数据， 看SDRAM手册发现Tcas &gt;=<span class="number">18</span>ns,所以配置成<span class="number">2</span> clocks即可。</span><br><span class="line">MRSRB6寄存器设置为<span class="number">0x20</span>。</span><br></pre></td></tr></table></figure>

<h3><span id="5-5-6-ce-shi-dai-ma">5.5.6 测试代码</span><a href="#5-5-6-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdram_init</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	BWSCON = <span class="number">0x22000000</span>;</span><br><span class="line">	BANKCON6 = <span class="number">0x18001</span>;</span><br><span class="line">	BANKCON7 = <span class="number">0x18001</span>;</span><br><span class="line">	REFRESH  = <span class="number">0x8404f5</span>;</span><br><span class="line">	BANKSIZE = <span class="number">0xb1</span>;</span><br><span class="line">	MRSRB6   = <span class="number">0x20</span>;</span><br><span class="line">	MRSRB7   = <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">sdram_test</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *p = (<span class="keyword">volatile</span> unsigned <span class="built_in">char</span> *)<span class="number">0x30000000</span>;<span class="comment">//sdram base addr</span></span><br><span class="line">	<span class="built_in">int</span> i;</span><br><span class="line">	<span class="comment">// write sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		p[i] = <span class="number">0x55</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read sdram</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] != <span class="number">0x55</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	uart0_init();</span><br><span class="line">	sdram_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sdram_test() == <span class="number">0</span>)</span><br><span class="line">		led_test();	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进行sdram_init后可已访问0x3000_0000地址的内容，led流水灯闪烁。<br>不初始化sdram_init，sdram_test执行会导致程序卡死。</p>
<h1><span id="6-norflash-fang-wen-shi-li">6 NorFlash访问实例</span><a href="#6-norflash-fang-wen-shi-li" class="header-anchor">#</a></h1><h2><span id="6-1-flash-chong-lei-te-xing-jie-shao">6.1 Flash种类特性介绍</span><a href="#6-1-flash-chong-lei-te-xing-jie-shao" class="header-anchor">#</a></h2><p>flash一般分为nand flash和nor flash，各自特性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Nor</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>XIP(片上执行)</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>性能(擦除)</td>
<td>非常慢(5s,块太大)</td>
<td>快(3ms)</td>
</tr>
<tr>
<td>性能(写)</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>性能(读)</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>高</td>
<td>一般（容易出现位反转）</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000 ~ 100000</td>
<td>100000 ~ 1000000</td>
</tr>
<tr>
<td>接口</td>
<td>与ram类似，可直接访问任意地址</td>
<td>I&#x2F;O接口（无地址线,必须串行访问，命令、地址、数据共用8位IO）</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>常用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>容量</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>常用文件系统类型</td>
<td>jffs</td>
<td>yaffs</td>
</tr>
</tbody></table>
<p>nor有以下优缺点相对nand：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">    操作简单（可以像内存一样随机访问）</span><br><span class="line">    读取速度快</span><br><span class="line">    可靠性高，不易出现位反转</span><br><span class="line">缺点：</span><br><span class="line">    容量小，价格贵</span><br><span class="line">    擦写慢</span><br><span class="line">    寿命短</span><br></pre></td></tr></table></figure>

<h2><span id="6-2-norflash-di-zhi-fan-wei">6.2 NorFlash地址范围</span><a href="#6-2-norflash-di-zhi-fan-wei" class="header-anchor">#</a></h2><p>前面介绍内存控制器地址映射范围说了，得知nor接了bank 0,地址范围是0x0000,0000 ~ 0x001f,ffff。</p>
<h2><span id="6-3-norflash-yin-jiao-miao-shu">6.3 NorFlash引脚描述</span><a href="#6-3-norflash-yin-jiao-miao-shu" class="header-anchor">#</a></h2><p>下面是一款典型的nor flash原理图<strong>MX29LV800BBTC</strong>。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/27.png"></p>
<p>引脚信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">地址线（A0-A20）</span><br><span class="line">数据线(DQ0-DQ15)</span><br><span class="line">片选信号（nCE）</span><br><span class="line">读写使能信号(LnOE/LnWE)</span><br></pre></td></tr></table></figure>

<p>Nor Flash可以像内存一样读，但是不能像内存一样写，需要做一些特殊的操作才能进行写操作，这是因为nor是属于rom（只读存储器），不能像ram一样可以任意的写0写1，只能将存储介质中的电平由1变成0，不能将0变成1，所以要向nor中写入数据，必须先进行擦除动作。</p>
<h2><span id="6-4-norflash-ying-jian-lian-jie">6.4 NorFlash硬件连接</span><a href="#6-4-norflash-ying-jian-lian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/28.jpg"></p>
<h2><span id="6-5-norflash-shu-ju-fang-wen-guo-cheng">6.5 NorFlash数据访问过程</span><a href="#6-5-norflash-shu-ju-fang-wen-guo-cheng" class="header-anchor">#</a></h2><p>下图是S3C2440的内存控制器的可编程访问周期读写时序，里面的时间参数要根据外部norflash的性能进行配置。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/29.png"></p>
<p>时序含义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tacs: Address <span class="built_in">set</span>-up time before nGCSn（表示地址信号A发出多久后才能发出nGCS片选）</span><br><span class="line">Tcos: Chip selection <span class="built_in">set</span>-up time before nOE（表示片选信号nGCS发出多久后才能发出读使能信号）</span><br><span class="line">Tacc: access cycle（数据访问周期）</span><br><span class="line">Tacp: page模式下的访问周期</span><br><span class="line">Tcoh: Chip selection hold time after <span class="title function_">nOE</span> <span class="params">(nOE信号释放多久后才能释放片选nGCS)</span></span><br><span class="line">Tcah: Address hold time after <span class="title function_">nGCSn</span> <span class="params">(片选nGCS释放多久后才能释放地址信号A)</span></span><br></pre></td></tr></table></figure>
<p>下面我们根据此款norflash <strong>MX29LV160D</strong>手册中的访问时序图来分析，如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/30.png"><br>从上面<strong>MX29LV160D</strong>手册的时序图中我们看见：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)先发送地址信号A</span><br><span class="line">(2)发送片选CE</span><br><span class="line">(3)发送读使能OE</span><br><span class="line">(4)从数据总线上读出数据</span><br><span class="line">(5)释放信号...</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发出地址数据(Addresses)后，要等待Taa(要求大于等于70ns)时间，地址数据才有效;</span><br><span class="line">发出片选信号(CE#)后，要等待Tce(要求大于等于70ns)时间，片选信号才有效;</span><br><span class="line">发出读信号(OE#)后要等待Toe(要求大于等于30ns)时间，读信号才有效;</span><br></pre></td></tr></table></figure>

<p>Tas（地址建立时间，也就是地址发送多久后才能继续发后面的片选信号）最小可以为0，那么说明地址信号（A）、片选(CE)、读(OE)使能信号可以一起发出。</p>
<p>为了简单我们把地址(Addresses)，片选信号(CE#)，读信号(OE#)，同时发出，然后让它们都等待70ns即可(等待地址信号，片选信号，读写使能信号有效)。</p>
<p>我们再看看上面的nor访问时序图，释放地址、片选、读使能信号都没有时间差值dt要求，那么说明地址、片选、读使能信号可以同时释放。</p>
<h2><span id="6-6-norflash-shi-xu-chu-shi-hua">6.6 NorFlash时序初始化</span><a href="#6-6-norflash-shi-xu-chu-shi-hua" class="header-anchor">#</a></h2><p>打开s3c2440内存控制器。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/31.png"></p>
<h3><span id="6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi">6.6.1 BANK控制寄存器设置</span><a href="#6-6-1-bank-kong-zhi-ji-cun-qi-she-zhi" class="header-anchor">#</a></h3><h4><span id="6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi">6.6.1.1 内存控制器时序设置</span><a href="#6-6-1-1-nei-cun-kong-zhi-qi-shi-xu-she-zhi" class="header-anchor">#</a></h4><h5><span id="6-6-1-1-1-tacc">6.6.1.1.1 Tacc</span><a href="#6-6-1-1-1-tacc" class="header-anchor">#</a></h5><p>Tacc表示数据访问周期：</p>
<p>从上图可以看到Tacc的默认值是111，对应14个clocks。s3c2440系统上电采用12MHz的晶振，HCLK&#x3D;OSC&#x3D;12MHz，那么Tacc&#x3D;(1&#x2F;(12*10^6)) * 14≈1166 ns，这个值很大，远超过了我们的nor手册上的Trc&#x3D;70ns，几乎可以满足所有NorFlash的要求,这也是为什么我们不做初始化也能访问norflash的原因。</p>
<p>启动后，由于我们的时钟HCLK设置成了100MHz，T&#x3D;1000&#x2F;100&#x3D;10ns，Tacc&#x3D; 10ns*14 &gt;70ns, 所以内存控制器不配置Tacc也是能访问该flash的。为了让访问速率加快，因此设置Tacc&gt;70ns即可，配置成101，8个clocks即可。</p>
<h5><span id="6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah">6.6.1.1.2 Tacs&#x2F;Tcos&#x2F;Tcoh&#x2F;Tcah</span><a href="#6-6-1-1-2-tacs-x2f-tcos-x2f-tcoh-x2f-tcah" class="header-anchor">#</a></h5><p>从nor的分析中，我们得知地址、片选、读使能同时发出和同时释放，所以配置Tacs,Tcos,Tcoh,Tcah皆为0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BANKCON0 = (*(<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)(<span class="number">0x48000004</span>));</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bank0_tacc_set</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	BANKCON0 = val &lt;&lt; <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bank0_tacc_set</span>(<span class="number">0x5</span>);</span><br></pre></td></tr></table></figure>

<h3><span id="6-6-2-ce-shi-dai-ma">6.6.2 测试代码</span><a href="#6-6-2-ce-shi-dai-ma" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span> &#123;</span><br><span class="line">	unsigned <span class="built_in">char</span> c;</span><br><span class="line">	uart0_init();<span class="comment">//参考前面的uart编程</span></span><br><span class="line">	puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		c = getchar();</span><br><span class="line">		putchar(c);</span><br><span class="line">		<span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;7&#x27;</span>) &#123;</span><br><span class="line">			bank0_tacc_set(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">			led_test();<span class="comment">//跑马灯代码我就不贴了，谁都会</span></span><br><span class="line">		&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">			puts(<span class="string">&quot;Error, val should between 0~7\n\r&quot;</span>);</span><br><span class="line">			puts(<span class="string">&quot;Enter the Tacc val: \n\r&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="6-6-2-1-ce-shi-jie-guo">6.6.2.1 测试结果</span><a href="#6-6-2-1-ce-shi-jie-guo" class="header-anchor">#</a></h4><p>输入0~4,Tacc小于70ns,无法读取Nor Flash上数据，LED不能闪烁。</p>
<p>输入5~7，Tacc大于70ns,可以读取Nor Flash上数据，LED不断闪烁，且值越小越快。</p>
<p>结论：我们的内存控制器默认配置的tacc一般都能兼容大多数市面上的norflash，一般都是可以访问的，无需进行对内存控制器进行多余的配置。</p>
<h1><span id="7-u-boot-ming-ling-fang-wen-norflash">7 u-boot命令访问NorFlash</span><a href="#7-u-boot-ming-ling-fang-wen-norflash" class="header-anchor">#</a></h1><p><strong>前提</strong>：<br>    norflash初始化正常，能够正常从nor上执行。</p>
<p>对s3c2440而言，cpu总是从0地址读取指令执行程序。当cpu设置成nor启动时，0地址对应nor。cpu从nand启动时，0地址对应sram。</p>
<h2><span id="7-1-cao-zuo-norflash">7.1 操作NorFlash</span><a href="#7-1-cao-zuo-norflash" class="header-anchor">#</a></h2><p>将板子设为nor启动，那么0地址对应nor，我们先将uboot烧写到nor中,启动uboot。</p>
<p>打开这款<strong>MX29LV800BBTC</strong> norflash手册，找到操作flash的命令表：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/32.png"></p>
<h3><span id="7-1-1-reset">7.1.1 reset</span><a href="#7-1-1-reset" class="header-anchor">#</a></h3><p>往任何一个地址写入F0即可。</p>
<h3><span id="7-1-2-du-id">7.1.2 读ID</span><a href="#7-1-2-du-id" class="header-anchor">#</a></h3><p>很多的Nor Flash可以配置成位宽16bit(Word)，位宽8bit(Byte)，我们这款norflash数据位宽为16bit。下面我们按照nor手册上的命令表尝试一下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">往地址<span class="number">555</span>H写入AAH(解锁)	</span><br><span class="line">往地址<span class="number">2</span>AAH写入<span class="number">55</span>H(解锁)</span><br><span class="line">往地址<span class="number">555</span>H写入<span class="number">90</span>H（命令）</span><br><span class="line">读<span class="number">0</span>地址得到厂家ID(C2H)</span><br><span class="line">读<span class="number">1</span>地址得到设备ID(<span class="number">22</span>DAH或<span class="number">225B</span>H)</span><br><span class="line">退出读ID状态(给任意地址写F0H就可以了)</span><br></pre></td></tr></table></figure>

<p>上面的地址是对于norflash的，那么我们CPU要怎么发送地址呢？从原理图接线我们知道CPU和nor的地址是错位相连的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/33.png"></p>
<table>
<thead>
<tr>
<th>cpu地址</th>
<th>nor地址</th>
</tr>
</thead>
<tbody><tr>
<td>A15~A1</td>
<td>A14~A0</td>
</tr>
</tbody></table>
<p>那么可以看到cpu的地址实际相当于是nor地址左移了一位，那么比如要想给nor上的555H地址写入AAH,那么CPU要发出的地址应该为0x555&lt;&lt;1,也就是nor地址的2倍。</p>
<p>下面对在Nor Flash的操作，cpu的操作，U-BOOT上的操作进行比较，如下表：</p>
<table>
<thead>
<tr>
<th>Nor Flash的操作</th>
<th>cpu的操作</th>
<th>U-BOOT上的操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写入AAH(解锁)</td>
<td>往地址AAAH写入AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写入55H(解锁)</td>
<td>往地址554H写入55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写入90H(命令)</td>
<td>往地址AAAH写入90H(命令)</td>
<td>mw.w aaa 90</td>
</tr>
<tr>
<td>读0地址得到厂家ID(C2H)</td>
<td>读0地址得到厂家ID(C2H)</td>
<td>md.w 0 1 (1:表示读一次)</td>
</tr>
<tr>
<td>读1地址得到设备ID(22DAH或225BH)</td>
<td>读2地址得到设备ID(22DAH或225BH)</td>
<td>md.w 2 1</td>
</tr>
<tr>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>退出读ID状态（给任意地址写F0H）</td>
<td>mw.w 0 f0</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/34.png"></p>
<p>我们读出厂家id为c2，设备id为2249，和我们的nor手册上是一致的。我们发出f0命令，进行复位，这时读取的数据就不再是厂家id和设备id了，而是我们norflash中的实际的数据17 00 00 ea。</p>
<h3><span id="7-1-3-du-shu-ju">7.1.3 读数据</span><a href="#7-1-3-du-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，只要做好内存控制器的初始化工作就可以直接读了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/35.png"></p>
<p>我们再用二进制编辑器打开我们烧进去的uboot.bin，发现内容一样，说明我们从norflash中读出来的数据是正确的。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/36.png"></p>
<h3><span id="7-1-4-du-shu-xing">7.1.4 读属性</span><a href="#7-1-4-du-shu-xing" class="header-anchor">#</a></h3><p>通常Linux内核里面要识别一个 Nor Flash 有两种方法：</p>
<p>一种是 jedec 探测，就是在内核里面事先定义一个数组，该数组里面放有不同厂家各个芯片的一些参数，探测的时候将 flash 的 ID 和数组里面的 ID 一一比较，如果发现相同的，就使用该数组的参数。 jedec 探测的优点就是简单，只要通过flash的数组编号，即可访问该款flash属性，缺点是如果内核要支持的 flash 种类很多，这个数组就会很庞大。</p>
<p>一种是 CFI(common flash interface)探测，就是直接发各种命令来读取芯片的信息，比如 ID、容量等，芯片本身就包含了电压有多大，容量有有多少等信息。</p>
<p>我们的这款norflash属于cfi探测，下面对在Nor Flash上操作，s3c2440上操作，U-BOOT上进行cfi 探测（读取芯片信息）。</p>
<p>下图是从datasheet中检索出进入cfi模式后的一些flash属性查找表，可以按照表格命令查询norflash的一些属性(容量、电压、block信息等)：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/37.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/38.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>根据命令表往<span class="number">55</span>H地址写入<span class="number">98</span>H进入cfi模式</span><br><span class="line"><span class="number">2.</span>读取`qry`字符</span><br><span class="line"><span class="number">3.</span>获取属性</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Nor Flash上操作cfi</th>
<th>2440上操作cfi</th>
<th>U-BOOT上操作cfi</th>
</tr>
</thead>
<tbody><tr>
<td>往55H地址写入98H（进入cfi模式）</td>
<td>往AAH地址写入98H</td>
<td>mw.w aa 98</td>
</tr>
<tr>
<td>读地址10H得到0051（’q’）</td>
<td>读地址20H得到0051</td>
<td>md.w 20 1</td>
</tr>
<tr>
<td>读地址11H得到0052(‘r’)</td>
<td>读地址22H得到0052</td>
<td>md.w 22 1</td>
</tr>
<tr>
<td>读地址12H得到0059(‘y’)</td>
<td>读地址24H得到0059</td>
<td>md.w 24 1</td>
</tr>
<tr>
<td>读地址27H得到容量</td>
<td>读地址4EH得到容量</td>
<td>md.w 4e 1</td>
</tr>
<tr>
<td>读地址1BH得到VCCmin</td>
<td>读地址36H得到VCCmin</td>
<td>md.w 36 1</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/39.png"></p>
<p>从测试结果我们看到容量为2^21&#x3D;2M，Vcc最小提供电压是2.7v。</p>
<h3><span id="7-1-5-xie-shu-ju">7.1.5 写数据</span><a href="#7-1-5-xie-shu-ju" class="header-anchor">#</a></h3><p>前面说了，nor属于rom, 有独立地址线，可以像ram一样的读，用md命令直接读取，不能像内存一样直接写，不信我们试试：</p>
<ol>
<li><p>我们在Nor Flash地址0x10000读数据</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/40.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">由于我们的uboot只有162k,烧录到norflash后，norflash上的的0x100000地址还没有被写入数据，norflash的容量为2M(0~0x200000),所以读取NorFlash的0x10000的地址数据是0xffff...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Nor flash的0x10000地址写数据0x1234，然后在这个地址读出数据：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/41.png"></p>
<p>可以看到0x1234无法写进去，读出来还是0xfffff。为什么呢？要怎么才能将0x1234写进去。找到命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash上写操作</th>
<th>2440上写操作</th>
<th>U-BOOT上写操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH(解锁)</td>
<td>往地址AAAH写AAH(解锁)</td>
<td>mw.w aaa aa</td>
</tr>
<tr>
<td>往地址2AAH写55H(解锁)</td>
<td>往地址554H写55H(解锁)</td>
<td>mw.w 554 55</td>
</tr>
<tr>
<td>往地址555H写A0H</td>
<td>往地址AAAH写A0H</td>
<td>mw.w aaa a0</td>
</tr>
<tr>
<td>往地址PA写PD</td>
<td>往地址0x100000写1234h</td>
<td>mw.w 100000 1234</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/42.png"></p>
</li>
</ol>
<p>可以看到0x1234已被写入到地址0x100000。再次往0x100000地址处，写入0x5678：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/43.png"></p>
<p>这时我们发现0x100000地址处的数据不是0x5678，而是0x1230，为什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原因：flash有无法位反转的特性。</span><br><span class="line">具体分析：</span><br><span class="line">由于原来的数据已经是0x1234不是全0xffff，flash存储介质中只能1变成0，不能将0变成1。所以在0x1234的基础上不去擦出直接继续去写0x5678是会有问题的。</span><br><span class="line">如果将0x1234不擦就去写成0x5678,过程如下：</span><br><span class="line">0001 0010 0011 0100(0x1234)</span><br><span class="line">0101 0110 0111 1000(0x5678)</span><br><span class="line">----------------------------</span><br><span class="line">0001 0010 0011 0000(0x1230)</span><br></pre></td></tr></table></figure>

<p>所以得到就是0x1230, 因此flash写入前一定要先擦除。</p>
<h4><span id="7-1-5-1-ca-chu">7.1.5.1 擦除</span><a href="#7-1-5-1-ca-chu" class="header-anchor">#</a></h4><p>从datasheet找到擦除命令表：</p>
<table>
<thead>
<tr>
<th>Nor Flash擦操作</th>
<th>u-boot擦操作</th>
</tr>
</thead>
<tbody><tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址555H写80H</td>
<td>mw.w    aaa   80</td>
</tr>
<tr>
<td>往地址555H写AAH</td>
<td>mw.w   aaa    aa</td>
</tr>
<tr>
<td>往地址2AAH写55H</td>
<td>mw.w   554    55</td>
</tr>
<tr>
<td>往地址PA写30H</td>
<td>mw.w  100000  30</td>
</tr>
</tbody></table>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/44.png"></p>
<p>擦除后再读取发现数据就已经变成了0xffff,后面就可以进行写操作了。</p>
<h4><span id="7-1-5-2-xie-ru">7.1.5.2 写入</span><a href="#7-1-5-2-xie-ru" class="header-anchor">#</a></h4><p>找到写入命令表，进行写入：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/45.png"></p>
<p>现在数据就变成我们的0x5678了。</p>
<p>注意：在写norflash时，要注意不要写0地址或者是uboot所在的地址，这样写入后norflash上的uboot程序就被破坏了。比如本测试就是写了0x100000地址,这个地址在uboot之外。</p>
<h2><span id="7-2-cao-zuo-norflash-tuo-zhan">7.2 操作NorFlash-拓展</span><a href="#7-2-cao-zuo-norflash-tuo-zhan" class="header-anchor">#</a></h2><h3><span id="7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi">7.2.1 地址位宽不对齐导致死机分析</span><a href="#7-2-1-di-zhi-wei-kuan-bu-dui-qi-dao-zhi-si-ji-fen-xi" class="header-anchor">#</a></h3><p>uboot发送md.w 0, md.w 2, md.w 4等偶地址命令能够读取norflash，但使用md.w 1, md.w 3,md.w 5就会出现死机，为什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">由于我们的norflash是<span class="number">16b</span>it数据位宽的，访问时要<span class="number">2b</span>yte对齐。如果不想以<span class="number">2b</span>yte为单位进行访问，那么要用uboot中用md.b <span class="number">1</span>,md.b <span class="number">3</span>这种单字节读取命令。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/46.png"></p>
<h3><span id="7-2-2-mei-ci-xie-du-yao-xian-ca-chu">7.2.2 每次写都要先擦除</span><a href="#7-2-2-mei-ci-xie-du-yao-xian-ca-chu" class="header-anchor">#</a></h3><p>操作norflash进行擦写的时候能够解锁一次，擦写多次吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不能，每次擦写都要进行解锁动作。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/47.png" alt="image-20240412144608560"></p>
<h3><span id="7-2-3-ca-chu-dan-wei-kuai">7.2.3 擦除单位-块</span><a href="#7-2-3-ca-chu-dan-wei-kuai" class="header-anchor">#</a></h3><p>擦除那么是以块（block）为单位的，那么当进行擦除时发送的地址并不是以块对齐的，会有什么结果？</p>
<p><code>也能擦除成功，会根据地址范围确定在哪一个块中。</code></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/48.png"></p>
<p>填入的地址是0x100009,也是擦除0x100000地址对应的块。</p>
<h1><span id="8-norflash-qu-dong-shi-li">8 NorFlash驱动实例</span><a href="#8-norflash-qu-dong-shi-li" class="header-anchor">#</a></h1><h2><span id="8-1-shi-bie-norflash">8.1 识别NorFlash</span><a href="#8-1-shi-bie-norflash" class="header-anchor">#</a></h2><p>我们知道要识别norflash属性，要让norflash进入cfi模式，然后按照手册上的表格发送一系列的命令就能获取norflash属性。</p>
<h3><span id="8-1-1-fa-ming-ling">8.1.1 发命令</span><a href="#8-1-1-fa-ming-ling" class="header-anchor">#</a></h3><p>实现一个cpu向nor发命令的一个函数nor_cmd()。我们的norflash是16bit位宽的，所以访问nor是以16位为单位访问的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NOR_FLASH_BASE  0  <span class="comment">/* s3c2440, nor--&gt;cs0, base addr = 0 */</span></span></span><br><span class="line"><span class="comment">/* 比如:   55H 98 </span></span><br><span class="line"><span class="comment">** 本意是: 往(0 + (0x55)&lt;&lt;1)写入0x98</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_write_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	*p = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nor_cmd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset, <span class="type">unsigned</span> <span class="type">int</span> cmd)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">nor_write_word</span>(NOR_FLASH_BASE, offset, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>nor_cmd(0x55, 0x90);</code>即可往norflash的0x55写入了0x98。</p>
<h3><span id="8-1-2-du-yi-ci-shu-ju">8.1.2  读一次数据</span><a href="#8-1-2-du-yi-ci-shu-ju" class="header-anchor">#</a></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_read_word</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> base, <span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">short</span> *)(base + (offset &lt;&lt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">nor_dat</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">nor_read_word</span>(NOR_FLASH_BASE, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>nor_dat(0x100000)</code>即可得到该地址的数据。</p>
<h3><span id="8-1-3-shi-bie-han-shu">8.1.3 识别函数</span><a href="#8-1-3-shi-bie-han-shu" class="header-anchor">#</a></h3><p>有了发命令函数nor_cmd和读一次数据函数nor_dat,那么就就可以参考nor芯片手册的命令表进行操作norflash了。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/49.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入NOR FLASH的CFI模式</span></span><br><span class="line"><span class="comment"> * 读取flash属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_scan_nor_flash</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> str[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">	<span class="type">int</span> regions, i;</span><br><span class="line">	<span class="type">int</span> region_info_base = <span class="number">0x2d</span>; <span class="comment">//第0块region的基地址2d，第1块region的基地址31,第2块region的基地址35......（参考手册表4-3）</span></span><br><span class="line">	<span class="type">int</span> block_addr=<span class="number">0</span>, blocks, block_size, j;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> vendor, device;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 打印厂家ID、设备ID */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x555</span>, <span class="number">0x90</span>);    <span class="comment">/* read id */</span></span><br><span class="line">	vendor = <span class="built_in">nor_dat</span>(<span class="number">0</span>);</span><br><span class="line">	device = <span class="built_in">nor_dat</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);        <span class="comment">/* reset */</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0x55</span>, <span class="number">0x98</span>);  <span class="comment">/* 进入cfi模式 */</span></span><br><span class="line">	str[<span class="number">0</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x10</span>);	<span class="comment">//读地址10H得到0051（&#x27;q&#x27;）</span></span><br><span class="line">	str[<span class="number">1</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x11</span>);	<span class="comment">//读地址11H得到0052(&#x27;r&#x27;)</span></span><br><span class="line">	str[<span class="number">2</span>] = <span class="built_in">nor_dat</span>(<span class="number">0x12</span>);	<span class="comment">//读地址12H得到0059(&#x27;y&#x27;)</span></span><br><span class="line">	str[<span class="number">3</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;str = %s\n\r&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印容量 */</span></span><br><span class="line">	size = <span class="number">1</span>&lt;&lt;(<span class="built_in">nor_dat</span>(<span class="number">0x27</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;vendor id = 0x%x, device id = 0x%x, nor size = 0x%x = %dM\n\r&quot;</span>, vendor, device, size, size/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 打印各个扇区的起始地址 */</span></span><br><span class="line">	<span class="comment">/* 名词解释:</span></span><br><span class="line"><span class="comment">	 * region : 一个nor flash含有1个或多个region, 一个region含有1个或多个block(扇区).</span></span><br><span class="line"><span class="comment">	 * Erase block region[i] information:</span></span><br><span class="line"><span class="comment">	 *    前2字节+1    : 表示该region有多少个block </span></span><br><span class="line"><span class="comment">	 *    后2字节*256  : 表示block的大小</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Block/Sector start Address:\n\r&quot;</span>);</span><br><span class="line">	regions = <span class="built_in">nor_dat</span>(<span class="number">0x2c</span>);  <span class="comment">//读出region数量</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; regions; i++) &#123;</span><br><span class="line">		blocks = <span class="number">1</span> + <span class="built_in">nor_dat</span>(region_info_base) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		block_size = <span class="number">256</span> * (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">2</span>) + (<span class="built_in">nor_dat</span>(region_info_base+<span class="number">3</span>)&lt;&lt;<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\rregion %d, blocks = %d, block_size = 0x%x, block_addr = 0x%x\n\r&quot;</span>, i, blocks, block_size, block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; blocks; j++) &#123;</span><br><span class="line">			<span class="comment">/* 打印每个block的起始地址 */</span></span><br><span class="line">			<span class="built_in">printHex</span>(block_addr);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">			cnt++;</span><br><span class="line">			<span class="keyword">if</span> (cnt % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">				</span><br><span class="line">			block_addr += block_size;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		region_info_base += <span class="number">4</span>;	<span class="comment">/*得到region[i]的基地址*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	<span class="comment">/* 退出CFI模式 */</span></span><br><span class="line">	<span class="built_in">nor_cmd</span>(<span class="number">0</span>, <span class="number">0xf0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/50.png"></p>
<p>从测试结果来看每个region的block个数和block_size不一定一样，像region[0]只有一个block，block_size为4*64K；<br>region[1]有2个block，block_size&#x3D;2*64K。</p>
<h2><span id="8-2-du-shu-ju">8.2 读数据</span><a href="#8-2-du-shu-ju" class="header-anchor">#</a></h2><p>由于NOR Flash是内存类接口，可以像内存一样读取，那么do_read_nor_flash函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_read_nor_flash</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">16</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address to read: &quot;</span>);</span><br><span class="line">	addr = <span class="built_in">get_uint</span>();</span><br><span class="line"></span><br><span class="line">	p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">char</span> *)addr;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Data : \n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			c = *p++;</span><br><span class="line">			str[j] = c;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%02x &quot;</span>, c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;   ; &quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[j] &lt; <span class="number">0x20</span> || str[j] &gt; <span class="number">0x7e</span>)  <span class="comment">/* 不可视字符 */</span></span><br><span class="line">				<span class="built_in">putchar</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">putchar</span>(str[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n\r&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="8-3-ca-shu-ju">8.3 擦数据</span><a href="#8-3-ca-shu-ju" class="header-anchor">#</a></h2><p>norflash擦写都是需要一定时间的，那么当我执行擦除或者写入动作后什么时候代表一次擦写动作已经完成了呢？</p>
<p>芯片手册提供了一个方法，每次擦除或者烧写过程中都可以查询数据总线上的第6位（Q6）,当它保持稳定的时候表示一次擦除或者烧写动作完成，如下图：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/51.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait_ready</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> addr)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> pre;</span><br><span class="line"></span><br><span class="line">	pre = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	val = nor_dat(addr&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span> ((val &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != (pre &amp; (<span class="number">1</span>&lt;&lt;<span class="number">6</span>))) &#123;</span><br><span class="line">		pre = val;</span><br><span class="line">		val = nor_dat(addr&gt;&gt;<span class="number">1</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">do_erase_nor_flash</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to erase: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;erasing ...\n\r&quot;</span>);</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0x80</span>);	 <span class="comment">/* erase sector */</span></span><br><span class="line">	</span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);    <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, <span class="number">0x30</span>);	 <span class="comment">/* 发出扇区地址 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/52.png"></p>
<p>可以看到擦除后这个block就是全0xffff了。</p>
<h2><span id="8-3-xie-shu-ju">8.3 写数据</span><a href="#8-3-xie-shu-ju" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_write_nor_flash</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 获得地址 */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the address of sector to write: &quot;</span>);</span><br><span class="line">	addr = get_uint();</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter the string to write: &quot;</span>);</span><br><span class="line">	gets(str);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;writing ...\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* str[0],str[1]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 * str[2],str[3]==&gt;16bit </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	j = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (str[i] &amp;&amp; str[j]) &#123;</span><br><span class="line">		val = str[i] + (str[j]&lt;&lt;<span class="number">8</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* 烧写 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">		nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">		nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">		nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">		<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">		wait_ready(addr);</span><br><span class="line"></span><br><span class="line">		i += <span class="number">2</span>;</span><br><span class="line">		j += <span class="number">2</span>;</span><br><span class="line">		addr += <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val = str[i];</span><br><span class="line">	<span class="comment">/* 烧写 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xaa</span>);	 <span class="comment">/* 解锁 */</span></span><br><span class="line">	nor_cmd(<span class="number">0x2aa</span>, <span class="number">0x55</span>); </span><br><span class="line">	nor_cmd(<span class="number">0x555</span>, <span class="number">0xa0</span>);	 <span class="comment">/* program */</span></span><br><span class="line">	nor_cmd(addr&gt;&gt;<span class="number">1</span>, val);</span><br><span class="line">	<span class="comment">/* 等待烧写完成 : 读数据, Q6无变化时表示结束 */</span></span><br><span class="line">	wait_ready(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E5%86%85%E5%AD%98%E6%8E%A7%E5%88%B6%E5%99%A8/53.png"></p>
<p>由于我的norflash是位宽为16bit的，所以我们上面代码do_write_nor_flash进行写入时是以2byte（wold）为单位进行写入的。</p>
<p>总结：只要从spec中拿到了命令操作表，读写擦，识别就可以很轻松应对实现。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
        <tag>存储驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-时钟体系</title>
    <url>/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zong-xian-kuang-jia">1 总线框架</a></li>
<li><a href="#2-shi-zhong-kuang-jia">2 时钟框架</a><ul>
<li><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</a></li>
<li><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</a></li>
</ul>
</li>
<li><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</a><ul>
<li><a href="#3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</a></li>
<li><a href="#3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</a><ul>
<li><a href="#3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</a></li>
<li><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</a></li>
<li><a href="#3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-zong-xian-kuang-jia">1 总线框架</span><a href="#1-zong-xian-kuang-jia" class="header-anchor">#</a></h1><p>下图是s3c2440的总线框架，其中有AHB(Advanced High performance Bus)高速总线,APB(Advanced Peripheral Bus)外围总线。</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/1.jpg"></p>
<p>不同总线对应不同的时钟。</p>
<pre><code>SOC &lt;-&gt; FCLK
AHB &lt;-&gt; HCLK	
APB &lt;-&gt; PCLK 
</code></pre>
<p>其中：</p>
<p>1.使用AHB总线的有：LCD控制器、usb控制器、中断控制器、内存控制器等…<br>2.使用APB总线的有：i2c、spi、timer、gpio、adc等…具体上图。</p>
<h1><span id="2-shi-zhong-kuang-jia">2 时钟框架</span><a href="#2-shi-zhong-kuang-jia" class="header-anchor">#</a></h1><p>下图表示s3c2440 Soc的时钟框图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/2.png"></p>
<p>下面从细节上讲解时钟体系：</p>
<h2><span id="2-1-ru-he-xuan-ze-shi-zhong-yuan">2.1 如何选择时钟源</span><a href="#2-1-ru-he-xuan-ze-shi-zhong-yuan" class="header-anchor">#</a></h2><p>s3c2440时钟源有2个，一个是OSC，一个是外部时钟EXTCLK,上面的时钟框图有标记，当然大家也可以查看手册“Figure 7-1. Clock Generator Block Diagram”。</p>
<p>那么如何选择是OSC还是EXTCLK呢？</p>
<p>打开原理图，OM3,OM2的引脚接地，那么OM[3,2]&#x3D;00.所以根据手册“Table 7-1. Clock Source Selection at Boot-Up”可知时钟源为OSC晶振。<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/3.png"><br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/4.png"></p>
<h2><span id="2-2-ru-he-de-dao-hclk-pclk-uclk">2.2 如何得到HCLK,PCLK，UCLK</span><a href="#2-2-ru-he-de-dao-hclk-pclk-uclk" class="header-anchor">#</a></h2><p>先了解下PLL, DIV</p>
<pre><code>PLL:用锁相环进行倍频
DIV:用分频器进行分频
</code></pre>
<p>如下图：<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/5.png"></p>
<p>生成的MPLL(Main PLL)和UPLL(USB PLL)，MPLL直接提供给FCLK，通过HDIVN分频给HCLK，通过PDIVN分频给PCLK，再传给下面的各个设备。<br>osc经过UPLL(USB PLL)得到UCLK。</p>
<h1><span id="3-pei-zhi-shi-zhong-kong-zhi-qi">3 配置时钟控制器</span><a href="#3-pei-zhi-shi-zhong-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="3-1-s3c2440-shi-zhong-shi-xu">3.1 s3c2440时钟时序</span><a href="#3-1-s3c2440-shi-zhong-shi-xu" class="header-anchor">#</a></h2><p>下图是2440时钟配置时序：</p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/6.jpg"></p>
<p>1.上电后，nRESET复位信号拉低，此时cpu还无法取指令工作。<br>2.nRESET复位信号结束后变为高电平，此时cpu开始工作。此时cpu主频FCLK&#x3D;osc。<br>3.此时可以配置PLL，经过lock time后，FCLK倍频成新的时钟。</p>
<h2><span id="3-2-ru-he-pei-zhi-shi-zhong">3.2 如何配置时钟</span><a href="#3-2-ru-he-pei-zhi-shi-zhong" class="header-anchor">#</a></h2><p>在参考手册的特性里介绍了S3C2440的工作频率，Fclk最高400MHz，Hclk最高136MHz，Pclk最高68MHz。那么 我们干脆配置FCLK：HCLK:PCLK&#x3D; 400：100：50 (MHz).</p>
<h3><span id="3-2-1-pei-zhi-lock-time">3.2.1 配置lock time</span><a href="#3-2-1-pei-zhi-lock-time" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/7.png"></p>
<pre><code>我们取芯片手册上的推荐值。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>
<h3><span id="3-2-2-pei-zhi-mpll-de-dao-fclk">3.2.2 配置MPLL得到FCLK</span><a href="#3-2-2-pei-zhi-mpll-de-dao-fclk" class="header-anchor">#</a></h3><p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/8.png"></p>
<p><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/9.png"></p>
<p>也可参考配置表取值<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/10.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">** MPLL(FCLK) = 2*m*Fin/(p*2^s)</span><br><span class="line">** 不妨取：</span><br><span class="line">** m = MDIV+8 = 92+8=100</span><br><span class="line">** p = PDIV+2 = 1+2 = 3</span><br><span class="line">** s = SDIV = 1</span><br><span class="line">** 则：</span><br><span class="line">** FCLK= 2*100*12/(3*2^1)=400M</span><br><span class="line">*/</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果也要配置了UPLL,那么先配置UPLL,要个7个NOP后才能再配置MPLL.</p>
<p>###3,配置CLKDIVN得到HCLK,PCLK<br><img src="/2024/04/11/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E6%97%B6%E9%92%9F%E4%BD%93%E7%B3%BB/11.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure>

<p>注意：如果HDIV设置为非0，CPU的总线模式要进行改变，默认情况下FCLK &#x3D; HCLK，CPU工作在fast bus mode快速总线模式下，HDIV设置为非0后， FCLK与HCLK不再相等，要将CPU改为asynchronous bus mod异步总线模式.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15, 0, r1, c1, c0, 0         /* 读取CP15 C1寄存器 */ </span><br><span class="line">orr r1, r1, #0xc0000000           /* 设置CPU总线模式 */ </span><br><span class="line">mcr p15, 0, r1, c1, c0, 0         /* 写回CP15 C1寄存器 */</span><br></pre></td></tr></table></figure>

<h3><span id="3-2-2-wan-zheng-hui-bian-dai-ma">3.2.2 完整汇编代码</span><a href="#3-2-2-wan-zheng-hui-bian-dai-ma" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">/* 关闭看门狗 */</span><br><span class="line">ldr r0, =0x53000000</span><br><span class="line">ldr r1, =0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置MPLL, FCLK : HCLK : PCLK = 400m : 100m : 50m */</span><br><span class="line">/* LOCKTIME(0x4C000000) = 0xFFFFFFFF */</span><br><span class="line">ldr r0, =0x4C000000</span><br><span class="line">ldr r1, =0xFFFFFFFF</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* CLKDIVN(0x4C000014) = 0X5, tFCLK:tHCLK:tPCLK = 1:4:8  */</span><br><span class="line">ldr r0, =0x4C000014</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 设置CPU工作于异步模式 */</span><br><span class="line">mrc p15,0,r0,c1,c0,0</span><br><span class="line">orr r0,r0,#0xc0000000   //R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,0,r0,c1,c0,0</span><br><span class="line"></span><br><span class="line">/* 设置MPLLCON(0x4C000004) = (92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0) </span><br><span class="line"> *  m = MDIV+8 = 92+8=100</span><br><span class="line"> *  p = PDIV+2 = 1+2 = 3</span><br><span class="line"> *  s = SDIV = 1</span><br><span class="line"> *  FCLK = 2*m*Fin/(p*2^s) = 2*100*12/(3*2^1)=400M</span><br><span class="line"> */</span><br><span class="line">ldr r0, =0x4C000004</span><br><span class="line">ldr r1, =(92&lt;&lt;12)|(1&lt;&lt;4)|(1&lt;&lt;0)</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">/* 一旦设置PLL, 就会锁定lock time直到PLL输出稳定</span><br><span class="line"> * 然后CPU工作于新的频率FCLK</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/* 设置内存: sp 栈 */</span><br><span class="line">/* 分辨是nor/nand启动</span><br><span class="line"> * 写0到0地址, 再读出来</span><br><span class="line"> * 如果得到0, 表示0地址上的内容被修改了, 它对应ram, 这就是nand启动</span><br><span class="line"> * 否则就是nor启动</span><br><span class="line"> */</span><br><span class="line">mov r1, #0</span><br><span class="line">ldr r0, [r1] /* 读出原来的值备份 */</span><br><span class="line">str r1, [r1] /* 0-&gt;[0] */ </span><br><span class="line">ldr r2, [r1] /* r2=[0] */</span><br><span class="line">cmp r1, r2</span><br><span class="line">ldr sp, =0x40000000+4096</span><br><span class="line">moveq sp, #4096  /* r1=r2， nand启动，修改栈指针=4096（此时sram对应0地址） */</span><br><span class="line">streq r0, [r1]   /* 恢复原来的值 */</span><br><span class="line"></span><br><span class="line">bl main</span><br><span class="line"></span><br><span class="line">halt:</span><br><span class="line">b halt</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>boot启动</tag>
        <tag>时钟体系</tag>
      </tags>
  </entry>
  <entry>
    <title>s3c2440裸机编程-电阻触摸屏</title>
    <url>/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</a><ul>
<li><a href="#1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</a></li>
<li><a href="#1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</a></li>
</ul>
</li>
<li><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</a><ul>
<li><a href="#2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</a></li>
<li><a href="#2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</a></li>
<li><a href="#2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</a></li>
<li><a href="#2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</a><ul>
<li><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</a></li>
<li><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</a><ul>
<li><a href="#3-1-normal-conversion-mode">3.1 Normal Conversion Mode</a></li>
<li><a href="#3-2-separate-x-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</a></li>
<li><a href="#3-3-auto-sequential-x-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</a></li>
<li><a href="#3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</a></li>
</ul>
</li>
<li><a href="#4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</a><ul>
<li><a href="#4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</a></li>
<li><a href="#4-2-data-ji-cun-qi">4.2 DATA寄存器</a><ul>
<li><a href="#4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</a></li>
<li><a href="#4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</a></li>
</ul>
</li>
<li><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</a></li>
</ul>
</li>
<li><a href="#5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</a><ul>
<li><a href="#5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</a><ul>
<li><a href="#5-1-1-zhong-duan-yuan">5.1.1 中断源</a></li>
<li><a href="#5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</a></li>
<li><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</a></li>
<li><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</a><ul>
<li><a href="#5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</a></li>
<li><a href="#5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</a><ul>
<li><a href="#5-2-1-chu-shi-hua">5.2.1 初始化</a><ul>
<li><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</a></li>
<li><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</a></li>
<li><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</a></li>
</ul>
</li>
<li><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</a><ul>
<li><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</a><ul>
<li><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</a></li>
<li><a href="#5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</a></li>
</ul>
</li>
<li><a href="#5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</a></li>
<li><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</a><ul>
<li><a href="#5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</a></li>
<li><a href="#5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</a><ul>
<li><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</a><ul>
<li><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<h1><span id="1-dian-zu-hong-mo-ping-yuan-li">1 电阻触摸屏原理</span><a href="#1-dian-zu-hong-mo-ping-yuan-li" class="header-anchor">#</a></h1><p>触摸屏包含上下叠合的两个透明层，一般覆盖在lcd表面，两个透明层是由均匀的电阻介质组成，如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/1.png"></p>
<p>当触摸屏表面受到的压力（如通过笔尖或手指进行按压）足够大时，顶层与底层之间的薄膜会产生接触，此时会形成x方向和y方向的坐标。那么x，y坐标的值是怎么得来的呢？本质上就是通过ADC转换得来的。</p>
<p>触摸屏的等效电路可以看成如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/2.jpg"></p>
<p>计算触点的X，Y坐标分为如下两步： </p>
<h2><span id="1-1-ji-suan-y-zuo-biao">1.1 计算Y坐标</span><a href="#1-1-ji-suan-y-zuo-biao" class="header-anchor">#</a></h2><p>在Y+电极施加驱动电压Vdrive， Y-电极接地，由于上下两层膜形成触点，X+做为触点的引出端，测量得到接触点的电压，触点电压与Vdrive电压之比等于触点Y坐标与屏高度之比。如下图：</p>
<h2><span id="1-2-ji-suan-x-zuo-biao">1.2 计算X坐标</span><a href="#1-2-ji-suan-x-zuo-biao" class="header-anchor">#</a></h2><p>在X+电极施加驱动电压Vdrive， X-电极接地，由于上下两层膜形成触点，Y+做为触点的引出端，测量得到接触点的电压，Y+做为引出端测量得到接触点的电压，触点电压与Vdrive电压之比等于触点X坐标与屏宽度之比。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/3.jpg"></p>
<h1><span id="2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi">2 电阻触摸屏的几种模式</span><a href="#2-dian-zu-hong-mo-ping-de-ji-chong-mo-shi" class="header-anchor">#</a></h1><h2><span id="2-1-deng-dai-zhong-duan-mo-shi">2.1 等待中断模式</span><a href="#2-1-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h2><p>平时的时候上下两层膜并不粘在一起，我们把这种状态称为<strong>“等待中断模式”</strong>， 等效电路如下图的右边那幅图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/4.png"></p>
<p>s5、s4闭合，s1、s2、s3断开，这个时候Y_ADC&#x2F;XP通过S5接上拉电阻，处于高电平状态,X_ADC&#x2F;YP接地。没法读取x,y坐标。</p>
<h2><span id="2-2-du-qu-x-zuo-biao-mo-shi">2.2 读取x坐标模式</span><a href="#2-2-du-qu-x-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给X方向通电，也就是让S1、S3开关闭合，s2、s4断开，那么当屏幕按下，触点YP的电平就对应x坐标。（XP到XM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/5.png"></p>
<pre><code>x_adc电压/vcc = x坐标/width, 所以x坐标= width * x_adc电压/vcc
</code></pre>
<h2><span id="2-3-du-qu-y-zuo-biao-mo-shi">2.3 读取y坐标模式</span><a href="#2-3-du-qu-y-zuo-biao-mo-shi" class="header-anchor">#</a></h2><p>给Y方向通电，也就是让S2、S4开关闭合，s1、s3断开，那么当屏幕按下，触点XP的电平就对应y坐标。（YP到YM之间是均匀的电阻介质）<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/6.png"></p>
<pre><code>y_adc电压/vcc = Y坐标/height, 所以y坐标= height * y_adc电压/vcc
</code></pre>
<h2><span id="2-4-ts-zhong-duan-liu-cheng">2.4 TS中断流程</span><a href="#2-4-ts-zhong-duan-liu-cheng" class="header-anchor">#</a></h2><p>总结一下单次触发TS中断，使用触摸屏的流程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 按下触摸屏，产生TS中断</span><br><span class="line"><span class="number">2.</span> 启动ADC(目的是获取x,y方向上的坐标值)</span><br><span class="line"><span class="number">3.</span> ADC转换完成，产生adc中断（adc转换需要一定的时间）</span><br><span class="line"><span class="number">4.</span> ADC中断中来读取x y坐标</span><br><span class="line"><span class="number">5.</span> 松开，结束</span><br></pre></td></tr></table></figure>

<p>我们知道，现在的手机都是支持屏幕滑动翻页和长按的功能。那么这些功能是如何做到的呢？</p>
<h3><span id="2-4-1-zhong-duan-jia-ru-ding-shi-qi">2.4.1 中断加入定时器</span><a href="#2-4-1-zhong-duan-jia-ru-ding-shi-qi" class="header-anchor">#</a></h3><p>如何让触摸屏支持长按或者滑动操作（多次触发TS中断）？</p>
<p>答案:<strong>定时器</strong>，当长按屏幕，会产生多次TS中断，因此我们需要用定时器来判断，当定时一段时间后，还有TS中断产生，那么我们认为是长按操作，进行中断响应。滑动也是类似的道理，当定时时间到后，如果还有TS中断产生，且坐标发生了改变，就认为是滑动操作。</p>
<pre><code>&lt;5&gt; 启动定时器
&lt;6&gt; 一段时间后，定时器中断发生，判断触摸屏是否仍被按下(是否有定时器中断产生)，如果有就循环上述过程&lt;2&gt;&lt;3&gt;&lt;4&gt;&lt;5&gt;
</code></pre>
<p>可以用如下流程图概括TSC的整个SW flow.</p>
<h3><span id="2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng">2.4.2 带定时器的TS中断处理流程</span><a href="#2-4-2-dai-ding-shi-qi-de-ts-zhong-duan-chu-li-liu-cheng" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/7.png" alt="image"></p>
<h1><span id="3-hong-mo-ping-jie-kou-mo-shi">3 触摸屏接口模式</span><a href="#3-hong-mo-ping-jie-kou-mo-shi" class="header-anchor">#</a></h1><h2><span id="3-1-normal-conversion-mode">3.1 Normal Conversion Mode</span><a href="#3-1-normal-conversion-mode" class="header-anchor">#</a></h2><p>正常转换模式，一般情况下可以配置ADCCON和ADCDAT0来读取数据。</p>
<h2><span id="3-2-separate-x-x2f-y-position-conversion-mode">3.2 Separate X&#x2F;Y position conversion Mode</span><a href="#3-2-separate-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/8.png"><br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/9.png"></p>
<p>x,y坐标分离转换格式，x坐标会写入ADCDAT0, y坐标会写入ADCDAT1,所以会产生2次中断开分开完成x,y的坐标转换。</p>
<h2><span id="3-3-auto-sequential-x-x2f-y-position-conversion-mode">3.3 Auto(Sequential) X&#x2F;Y Position Conversion Mode</span><a href="#3-3-auto-sequential-x-x2f-y-position-conversion-mode" class="header-anchor">#</a></h2><p>自动转换模式，当触摸屏按下后，会一次性对x,y方向的坐标进行转换，x坐标会写入ADCDAT0, x坐标会写入ADCDAT1。会产生一次中断进行x,y坐标的自动转换。 </p>
<h2><span id="3-4-waiting-for-interrupt-mode">3.4 Waiting for Interrupt Mode</span><a href="#3-4-waiting-for-interrupt-mode" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/10.jpg"></p>
<p> 等待中断模式 。可以设置rADCTSC&#x3D;0xd3;也就是对应下图寄存器 &#x2F;&#x2F; XP_PU, XP_Dis, XM_Dis, YP_Dis, YM_En.当产生中断信号(INT_TC)后，等待中断模式必须清除.(即XY_PST sets to the No operation Mode).</p>
<h1><span id="4-hong-mo-ping-kong-zhi-qi">4 触摸屏控制器</span><a href="#4-hong-mo-ping-kong-zhi-qi" class="header-anchor">#</a></h1><h2><span id="4-1-ts-kong-zhi-ji-cun-qi">4.1 TS控制寄存器</span><a href="#4-1-ts-kong-zhi-ji-cun-qi" class="header-anchor">#</a></h2><p>电阻触摸屏的原理本质上就是ADC，ADC相关寄存器介绍详见<a href="https://www.cnblogs.com/fuzidage/p/13396987.html">s3c2440裸机-ADC编程</a>或者<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-ADC/">s3c2440裸机编程-ADC | Hexo (fuzidage.github.io)</a><br>TSC相比ADC多了一个ADCTSC寄存器，如下图：<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/11.jpg" alt="image"><br>当bit[2]&#x3D;0，normal mode时，那么bit[1:0]需要配置成01或者10进行手工测量x,y.<br>当bit[2]&#x3D;1，auto mode时，那么bit[1:0]需要配置成0,进行自动测量。</p>
<h2><span id="4-2-data-ji-cun-qi">4.2 DATA寄存器</span><a href="#4-2-data-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-x-zuo-biao-adcdata0">4.2.1 x坐标ADCDATA0</span><a href="#4-2-1-x-zuo-biao-adcdata0" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/12.png" alt="image"></p>
<h3><span id="4-2-2-y-zuo-biao-adcdata1">4.2.2 y坐标ADCDATA1</span><a href="#4-2-2-y-zuo-biao-adcdata1" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/13.png" alt="image"></p>
<h2><span id="4-3-song-kai-an-xia-jian-ce-ji-cun-qi">4.3 松开按下检测寄存器</span><a href="#4-3-song-kai-an-xia-jian-ce-ji-cun-qi" class="header-anchor">#</a></h2><p>这个寄存器可以检测是否有触摸中断产生，是按下触摸屏了，还是松开触摸屏了。<br><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/14.png" alt="image"></p>
<h1><span id="5-hong-mo-ping-bian-cheng-shi-li">5 触摸屏编程示例</span><a href="#5-hong-mo-ping-bian-cheng-shi-li" class="header-anchor">#</a></h1><h2><span id="5-1-adc-zhong-duan-chan-sheng">5.1 ADC中断产生</span><a href="#5-1-adc-zhong-duan-chan-sheng" class="header-anchor">#</a></h2><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/15.png" alt="img"></p>
<h3><span id="5-1-1-zhong-duan-yuan">5.1.1 中断源</span><a href="#5-1-1-zhong-duan-yuan" class="header-anchor">#</a></h3><p>ADC和TSC共用一个中断源，如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/16.png" alt="img"></p>
<p>SRCPND表示哪个中断源产生了中断请求。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/17.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/18.png" alt="img"></p>
<h3><span id="5-1-2-zhong-duan-mo-shi">5.1.2 中断模式</span><a href="#5-1-2-zhong-duan-mo-shi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/19.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/20.png" alt="img"></p>
<h3><span id="5-1-3-zhong-duan-ping-bi-ji-cun-qi">5.1.3 中断屏蔽寄存器</span><a href="#5-1-3-zhong-duan-ping-bi-ji-cun-qi" class="header-anchor">#</a></h3><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/21.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/22.png" alt="img"></p>
<h3><span id="5-1-4-zhong-duan-gua-qi-ji-cun-qi">5.1.4 中断挂起寄存器</span><a href="#5-1-4-zhong-duan-gua-qi-ji-cun-qi" class="header-anchor">#</a></h3><p>用来显示当前优先级最高的、正在发生的中断, 需要清除对应位。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/23.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/24.png" alt="img"></p>
<p>从SRCPND寄存器可以读到ADC和TSC复用的同一个中断源，那么如何区分呢？</p>
<p>可以从SUBSRCPND寄存器配置，如下：</p>
<h4><span id="5-1-4-1-subsrcpnd-ji-cun-qi">5.1.4.1 SUBSRCPND寄存器</span><a href="#5-1-4-1-subsrcpnd-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/25.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/26.png" alt="img"></p>
<p> 当bit 9被置1时，表示TSC中断。那么我们需要打开subsrcmask寄存器：</p>
<h4><span id="5-1-4-2-intsubmsk-ji-cun-qi">5.1.4.2 INTSUBMSK寄存器</span><a href="#5-1-4-2-intsubmsk-ji-cun-qi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/27.png" alt="img"></p>
<p>所以TSC中断的产生流程如下：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/28.png" alt="img"></p>
<h2><span id="5-2-ts-hong-mo-ping-bian-cheng-liu-cheng">5.2 TS触摸屏编程流程</span><a href="#5-2-ts-hong-mo-ping-bian-cheng-liu-cheng" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 初始化TSC，ADCTSC寄存器</span><br><span class="line"><span class="number">2.</span> 设定TSC处于“等待中断模式”</span><br><span class="line"><span class="number">3.</span> 使能TSC中断</span><br><span class="line">　　　　　　INTSUBMSK</span><br><span class="line">　　　　　　MSK/MODE</span><br><span class="line"><span class="number">4.</span> 按下，进入TSC中断</span><br><span class="line">　　　　　　进入自动采集转换模式</span><br><span class="line">　　　　　　启动ADC</span><br><span class="line"><span class="number">5.</span> ADC中断</span><br><span class="line">　　　　　　读数据</span><br><span class="line">　　　　　　再次进入”等待中断模式“</span><br><span class="line">　　　　　　启动定时器（为了处理长按或者滑动操作）</span><br><span class="line"><span class="number">6.</span> 定时器中断</span><br><span class="line">　　　　　　若松开，结束</span><br><span class="line">　　　　　　如任然按下，进入步骤<span class="number">4</span>的启动ADC流程</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/29.png" alt="img"></p>
<h3><span id="5-2-1-chu-shi-hua">5.2.1 初始化</span><a href="#5-2-1-chu-shi-hua" class="header-anchor">#</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 设置触摸屏接口:寄存器 */</span></span><br><span class="line">    adc_ts_reg_init();</span><br><span class="line">    <span class="comment">/* 设置中断 */</span></span><br><span class="line">    adc_ts_int_init();</span><br><span class="line">    <span class="comment">/* 让触摸屏控制器进入&quot;等待中断模式&quot; */</span></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-1-ts-ji-cun-qi-chu-shi-hua">5.2.1.1 ts寄存器初始化</span><a href="#5-2-1-1-ts-ji-cun-qi-chu-shi-hua" class="header-anchor">#</a></h4><p>主要是设置预分频，产生ADC clk &#x3D; 1MHz。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">     * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">     * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">     * [2]   : STDBM</span></span><br><span class="line"><span class="comment">     * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">    ADCDLY = <span class="number">0xff</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-2-ts-zhong-duan-chu-shi-hua">5.2.1.2 ts 中断初始化</span><a href="#5-2-1-2-ts-zhong-duan-chu-shi-hua" class="header-anchor">#</a></h4><p>为了将中断源开启，这里设置SUBSRCPND 和INTSUBMSK让中断源开启。通过register_irq（）注册中断号和中断服务程AdcTsIntHandle，查表得出中断号为31，这样当硬件产生中断后可以从INTOFFSET区分是哪个中断号。如下图：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/30.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_int_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    register_irq(<span class="number">31</span>, AdcTsIntHandle);    <span class="comment">/*31号中断*/</span></span><br><span class="line">    <span class="comment">/* 使能中断 */</span></span><br><span class="line">    INTSUBMSK &amp;= ~((<span class="number">1</span>&lt;&lt;ADC_INT_BIT) | (<span class="number">1</span>&lt;&lt;TC_INT_BIT));<span class="comment">//防止屏蔽（SUBMSK）</span></span><br><span class="line">    <span class="comment">//INTMSK    &amp;= ~(1&lt;&lt;INT_ADC_TC);//reg_irq已经使能了31中断号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi">5.2.1.3 进入”等待中断模式”</span><a href="#5-2-1-3-jin-ru-deng-dai-zhong-duan-mo-shi" class="header-anchor">#</a></h4><p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/31.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/32.png" alt="img"></p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/33.png" alt="img"></p>
<p>进入等待中断模式，YM闭合， YP， XP， XM断开，需要pull up，WAIT_PEN_DOWN表示要等待的是按下中断，当触摸屏按下时就会产生一个TSC irq,反之WAIT_PEN_UP表示要等待的是松开中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADC_INT_BIT (10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TC_INT_BIT  (9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT_ADC_TC   (31)</span></span><br><span class="line"><span class="comment">/* ADCTSC&#x27;s bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_DOWN    (0&lt;&lt;8) <span class="comment">/*触摸笔按下*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_PEN_UP      (1&lt;&lt;8) <span class="comment">/*触摸笔松开*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_ENABLE        (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YM_DISABLE       (0&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_ENABLE        (0&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YP_DISABLE       (1&lt;&lt;6)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_ENABLE        (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XM_DISABLE       (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_ENABLE        (0&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XP_DISABLE       (1&lt;&lt;4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_ENABLE    (0&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PULLUP_DISABLE   (1&lt;&lt;3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)    <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)    <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_down_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待按下模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_DOWN | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | 	WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_wait_pen_up_mode</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*等待松开模式*/</span> &#123;</span><br><span class="line">	ADCTSC = WAIT_PEN_UP | PULLUP_ENABLE | YM_ENABLE | YP_DISABLE | XP_DISABLE | XM_DISABLE | WAIT_INT_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3><span id="5-2-2-ts-zhong-duan-fu-wu-cheng-xu">5.2.2 ts中断服务程序</span><a href="#5-2-2-ts-zhong-duan-fu-wu-cheng-xu" class="header-anchor">#</a></h3><p>SUBSRCPND的bit9, bit10可以区分是TC中断还是ADC中断。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/34.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span><span class="comment">/*触摸屏中断服务程序*/</span> &#123;</span><br><span class="line">　　	<span class="built_in">printf</span>(<span class="string">&quot;ADCUPDN = 0x%x, ADCDAT0 = 0x%x, ADCDAT1 = 0x%x, ADCTSC = 0x%x\n\r&quot;</span>, ADCUPDN, ADCDAT0, ADCDAT1, ADCTSC);</span><br><span class="line">　　	<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">//dat寄存器的第15位判断按下还是松开</span></span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">　　　　	enter_wait_pen_down_mode();</span><br><span class="line">　　	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　	<span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">　　　　	<span class="comment">/* 进入&quot;等待触摸笔松开的模式&quot; */</span></span><br><span class="line">　　　　	enter_wait_pen_up_mode();</span><br><span class="line">　　	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　	<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT)) <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　	Isr_Tc();</span><br><span class="line">　　	<span class="comment">// if (SUBSRCPND &amp; (1&lt;&lt;ADC_INT_BIT)) /* ADC中断 */</span></span><br><span class="line">　　	<span class="comment">// Isr_Adc();</span></span><br><span class="line">　　	SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">　　	<span class="comment">//SRCPND = 1&lt;&lt;31;/*在interrupt.c已经清中断了*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdcTsIntHandle函数： 这里先注解掉ADC中断，只检测单独的按下松开触摸屏操作。那当isr处理完后为了能够正常响应下一次中断，需要清中断，否则会一直触发interrupt。</span><br><span class="line">Isr_Tc函数：ADCDAT0 寄存器的第15位判断按下还是松开。那么当按下后，要将控制器进入”等待松开模式“，当松开后，要将控制器配置进入”等待按下模式“。</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/35.png" alt="img"></p>
<h4><span id="5-2-2-1-huo-qu-hong-mo-ping-zuo-biao">5.2.2.1 获取触摸屏坐标</span><a href="#5-2-2-1-huo-qu-hong-mo-ping-zuo-biao" class="header-anchor">#</a></h4><h5><span id="5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi">5.2.2.1.1 进入自动测量模式</span><a href="#5-2-2-1-1-jin-ru-zi-dong-ce-liang-mo-shi" class="header-anchor">#</a></h5><p>Auto(Sequential) X&#x2F;Y Position Conversion Mode。打开TS控制寄存器，也就是ADCTSC寄存器：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/36.png" alt="img"></p>
<p>让bit[2] &#x3D;1, bit[1:0]&#x3D;00，则会进入auto measurement。如果bit[2]&#x3D;0，则需配置bit[1::0]&#x3D;01 or 10是手动测量x,y坐标。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AUTO_PST         (1&lt;&lt;2) <span class="comment">/*自动转换*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WAIT_INT_MODE    (3)        <span class="comment">/*等待中断模式*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_OPR_MODE      (0)        <span class="comment">/*禁止模式*/</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_auto_measure_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　ADCTSC = AUTO_PST | NO_OPR_MODE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="5-2-2-1-2-qi-dong-adc">5.2.2.1.2 启动ADC</span><a href="#5-2-2-1-2-qi-dong-adc" class="header-anchor">#</a></h5><p>触摸屏坐标就是通过ADC获取的。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/37.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>所以TSC isr程序如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">/*触摸屏中断服务程序*/</span></span><br><span class="line">      <span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen up\n\r&quot;</span>);</span><br><span class="line">            enter_wait_pen_down_mode();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pen down\n\r&quot;</span>);</span><br><span class="line">            <span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">            enter_auto_measure_mode();</span><br><span class="line">            <span class="comment">/* 启动ADC */</span></span><br><span class="line">            ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么当检测到按下后，需要进入auto measure mode，启动adc，然后就会进行自动坐标转换，转换结束后又会触发ADC中断，再次进入<code>AdcTsIntHandle</code>函数，进而进入<code>Isr_Adc</code>，SUBSRCPND可以区分中断源 。如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">int</span> irq)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;TC_INT_BIT))  <span class="comment">/* 如果是触摸屏中断 */</span></span><br><span class="line">　　　　Isr_Tc();</span><br><span class="line">　　<span class="keyword">if</span> (SUBSRCPND &amp; (<span class="number">1</span>&lt;&lt;ADC_INT_BIT))  <span class="comment">/* ADC中断 */</span></span><br><span class="line">　　　　Isr_Adc();</span><br><span class="line">　　SUBSRCPND = (<span class="number">1</span>&lt;&lt;TC_INT_BIT) | (<span class="number">1</span>&lt;&lt;ADC_INT_BIT);<span class="comment">/*清中断*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道ADC进行坐标转换结束后，那么会产生ADC中断，在<code>Isr_Adc</code>中即可获取我们的x,y坐标数据。由于我们按下后是进入了 “自动测量” 模式，因此那当数据获取完后我们得进入 “等待松开” 模式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="type">int</span> x = ADCDAT0;</span><br><span class="line">      <span class="type">int</span> y = ADCDAT1;</span><br><span class="line">      <span class="keyword">if</span> (!(ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))) &#123; <span class="comment">/* 在isr_Tc按下后，如果仍然按下才打印 */</span></span><br><span class="line">            x &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            y &amp;= <span class="number">0x3ff</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %08d, y = %08d\n\r&quot;</span>, x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      enter_wait_pen_up_mode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有可能触摸屏的测量过程非常长，那当ADC转换结束后，它已经松开了，这时不应该进行打印出坐标，所以这里在isr_Tc按下后，如果仍然按下才打印。</p>
<h4><span id="5-2-2-2-adcdly-ji-cun-qi">5.2.2.2 ADCDLY寄存器</span><a href="#5-2-2-2-adcdly-ji-cun-qi" class="header-anchor">#</a></h4><p>由于触摸屏采样的转换速率问题，按下后需要过一段电压才能稳定下来，那么数据才能稳定可能需要一定的延迟，所以需要配置ADC delay，让ADC慢一点产生中断，也就是等坐标稳定后在通知用户。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/38.png" alt="img"></p>
<p>ADCDLY就是用来延时ADC启动的时间，让数据稳定后再进行转换。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/39.png" alt="img"></p>
<p><code>可以看到，进行auto or manual measure 坐标转换的时序要满足：A = Dx,D表示ADCDLY的值。 现在晶振的频率是12Mhz, 那么根据触摸屏规格书我们取A= 5ms，那么D= 0.005s *12*1000000 = 60000，所以ADCDLY配置成60000.</code></p>
<p>修改前面的<code>adc_ts_reg_init</code>函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">adc_ts_reg_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">      <span class="comment">/* [15] : ECFLG,  1 = End of A/D conversion</span></span><br><span class="line"><span class="comment">       * [14] : PRSCEN, 1 = A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">       * [13:6]: PRSCVL, adc clk = PCLK / (PRSCVL + 1)</span></span><br><span class="line"><span class="comment">       * [5:3] : SEL_MUX, 000 = AIN 0</span></span><br><span class="line"><span class="comment">       * [2]   : STDBM</span></span><br><span class="line"><span class="comment">       * [0]   : 1 = A/D conversion starts and this bit is cleared after the startup.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCCON = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>) | (<span class="number">49</span>&lt;&lt;<span class="number">6</span>) | (<span class="number">0</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">      <span class="comment">/*  按下触摸屏, 延时一会再发出TC中断</span></span><br><span class="line"><span class="comment">       *  延时时间 = ADCDLY * 晶振周期 = ADCDLY * 1 / 12000000 = 5ms</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      ADCDLY = <span class="number">60000</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="5-3-ts-hong-mo-ping-ce-shi">5.3 TS触摸屏测试</span><a href="#5-3-ts-hong-mo-ping-ce-shi" class="header-anchor">#</a></h2><p>从左往右依次点击触摸屏，可以看到x坐标没有明显变化，y坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/40.png" alt="img"></p>
<p>同理，从上往下依次按下触摸屏，可以看到y坐标没有明显变化，x坐标反而线性变大。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/41.png" alt="img"></p>
<p>这里是由于硬件上xp与yp接反了，ym与xm接反了，如下图：但这里并不影响我们的时候，这里我们软件上可以进行x,y坐标的转换：</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/42.png" alt="img"></p>
<p>我们软件上可以对x,y轴进行flip， mirror, rotaion旋转等一系列操作即可。比如：</p>
<p>Case1：ts与lcd吻合</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/43.png" alt="img"></p>
<p>Case2：ts与lcd相反</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/44.png" alt="img"></p>
<h2><span id="5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong">5.4 利用定时器支持屏幕长按和滑动</span><a href="#5-4-li-yong-ding-shi-qi-zhi-chi-ping-mu-chang-an-he-hua-dong" class="header-anchor">#</a></h2><h3><span id="5-4-1-gai-jin-ding-shi-qi">5.4.1 改进定时器</span><a href="#5-4-1-gai-jin-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有讲到在<code>handle_irq_c()</code>中去区分中断源，执行不同的<code>isr</code>。</p>
<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/45.png" alt="image-20240501173712329"></p>
<p>那现在通过<code>register_timer</code>注册对应的定时器中断服务程序，<code>timer_irq</code>进行执行不同的定时器中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER_NUM  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL  ((void *)0)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*timer_func)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_desc</span> &#123;</span></span><br><span class="line">　　<span class="type">char</span> *name;</span><br><span class="line">　　timer_func fp;</span><br><span class="line">&#125;timer_desc, *p_timer_desc;</span><br><span class="line"></span><br><span class="line">timer_desc timer_array[TIMER_NUM];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">register_timer</span><span class="params">(<span class="type">char</span> *name, timer_func fp)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = name;</span><br><span class="line">　　　　　　timer_array[i].fp   = fp;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_timer</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(timer_array[i].name, name)) &#123;</span><br><span class="line">　　　　　　timer_array[i].name = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　timer_array[i].fp   = <span class="literal">NULL</span>;</span><br><span class="line">　　　　　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="type">int</span> i;</span><br><span class="line">　　<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TIMER_NUM; i++) &#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (timer_array[i].fp) &#123;</span><br><span class="line">　　　　　　timer_array[i].fp();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要用timer来进行进行流水灯实验，那么假如点灯函数为:<br><code>Isr_timer_led()&#123;&#125;</code></p>
<p>那么则只需要在<code>led init</code>的时候进行调用<code>register_timer(“led”, Isr_timer_led)</code>, 那么当时间到后触发定时器中断，便会执行<code>timer_irq</code>.进入<code>Isr_timer_led</code>。</p>
<h3><span id="5-4-2-chu-shi-hua-ding-shi-qi">5.4.2 初始化定时器</span><a href="#5-4-2-chu-shi-hua-ding-shi-qi" class="header-anchor">#</a></h3><p>前面<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>有具体讲解，这里采用PWM定时器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">timer_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="comment">/* 设置TIMER0的时钟 */</span></span><br><span class="line">　　<span class="comment">/* Timer clk = PCLK / &#123;prescaler value+1&#125; / &#123;divider value&#125;</span></span><br><span class="line"><span class="comment">             = 50000000/(49+1)/16</span></span><br><span class="line"><span class="comment">             = 62500</span></span><br><span class="line"><span class="comment"> 　　*/</span></span><br><span class="line">　　TCFG0 = <span class="number">49</span>;  <span class="comment">/* Prescaler 0 = 49, 用于timer0,1 */</span></span><br><span class="line">　　TCFG1 &amp;= ~<span class="number">0xf</span>;</span><br><span class="line">　　TCFG1 |= <span class="number">3</span>;  <span class="comment">/* MUX0 : 1/16 */</span></span><br><span class="line">　　<span class="comment">/* 设置TIMER0的初值 */</span></span><br><span class="line">　　TCNTB0 = <span class="number">625</span>;  <span class="comment">/* 10Ms中断一次 */</span></span><br><span class="line">　　<span class="comment">/* 加载初值, 启动timer0 */</span></span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);   <span class="comment">/* Update from TCNTB0 &amp; TCMPB0 */</span></span><br><span class="line">　　<span class="comment">/* 设置为自动加载并启动 */</span></span><br><span class="line">　　TCON &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">　　TCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);  <span class="comment">/* bit0: start, bit3: auto reload */</span></span><br><span class="line">　　<span class="comment">/* 设置中断 */</span></span><br><span class="line">　　register_irq(<span class="number">10</span>, timer_irq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4><span id="5-4-2-1-zhi-chi-chang-an-he-hua-dong">5.4.2.1 支持长按和滑动</span><a href="#5-4-2-1-zhi-chi-chang-an-he-hua-dong" class="header-anchor">#</a></h4><p>我们之前是2s timer触发一次中断，那如果是要支持触摸屏，我们必须让定时器10ms就触发一次中断。因此需要修改timer_init中的寄存器参数。</p>
<p>当按下触摸屏会产生TSC中断，然后启动ADC进而产生<code>adc</code>中断的时候，在<code>Isr_Adc</code>函数中进行定时器的设置，检测长按和滑动操作。</p>
<h5><span id="5-4-2-1-1-ding-yi-touchscreen-timer-irq">5.4.2.1.1 定义touchscreen_timer_irq</span><a href="#5-4-2-1-1-ding-yi-touchscreen-timer-irq" class="header-anchor">#</a></h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_enable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ts_timer_disable</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　g_ts_timer_enable = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_status_of_ts_timer</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">return</span> g_ts_timer_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 每10ms该函数被调用一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">touchscreen_timer_irq</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">　　<span class="keyword">if</span> (get_status_of_ts_timer() == <span class="number">0</span>)</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> (ADCDAT0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>)) &#123; <span class="comment">/* 如果松开 */</span></span><br><span class="line">　　　　ts_timer_disable();</span><br><span class="line">　　　　enter_wait_pen_down_mode();</span><br><span class="line">　　　　<span class="keyword">return</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/* 如果触摸屏仍被按下, 进入&quot;自动测量模式&quot;, 启动ADC */</span></span><br><span class="line">　　<span class="keyword">else</span> &#123;  <span class="comment">/* 按下状态 */</span></span><br><span class="line">　　　　<span class="comment">/* 进入&quot;自动测量&quot;模式 */</span></span><br><span class="line">　　　　enter_auto_measure_mode();</span><br><span class="line">　　　　<span class="comment">/* 启动ADC */</span></span><br><span class="line">　　　　ADCCON |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/01/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E7%94%B5%E9%98%BB%E8%A7%A6%E6%91%B8%E5%B1%8F/46.png" alt="image-20240501174908562"></p>
<p>来分析一下这个程序的过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 在touchscreen_init的时候我们先注册了一个timer，然后修改了定时器的产生中断的时间间隔为<span class="number">10</span>ms中断一次，所以touchscreen_timer_irq会每间隔<span class="number">10</span>ms调用一次。没有按下，则touchscreen_timer_irq虽然也有走，但是就直接<span class="keyword">return</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 然后如果按下触摸屏，产生tsc中断，启动adc，产生adc中断。</span><br><span class="line"></span><br><span class="line">如果产生了adc中断，但是读取状态发现已经松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效。那么要是状态是被按下，则开启ts_timer_enable。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 当使能touchscreen_timer_irq这个定时器中断服务程序后，并且<span class="number">10</span>ms到了touchscreen_timer_irq函数执行生效。</span><br><span class="line"></span><br><span class="line">如果松开了，则进入”等待按下状态“，并且让touchscreen_timer_irq失效，表示没有长按或者滑动。</span><br><span class="line"></span><br><span class="line">如果任然按下，输出长按或者滑动后的坐标结果。</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>tailq队列</title>
    <url>/2024/04/11/tailq%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-tailq-dui-lie-jie-shao">1 tailq队列介绍</a><ul>
<li><a href="#1-1-queue-jian-jie">1.1 queue 简介</a></li>
<li><a href="#1-2-slist">1.2 SLIST</a></li>
<li><a href="#1-3-stailq">1.3 STAILQ</a></li>
<li><a href="#1-4-list">1.4 LIST</a></li>
<li><a href="#1-5-tailq">1.5 TAILQ</a></li>
<li><a href="#1-6-circleq">1.6 CIRCLEQ</a></li>
</ul>
</li>
<li><a href="#2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</a><ul>
<li><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</a></li>
<li><a href="#2-2-dui-lie-tou">2.2 队列头</a></li>
<li><a href="#2-3-chu-shi-hua">2.3 初始化</a></li>
<li><a href="#2-4-cha-ru-yuan-su">2.4 插入元素</a><ul>
<li><a href="#2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</a></li>
<li><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</a></li>
</ul>
</li>
<li><a href="#2-5-shan-chu-yuan-su">2.5 删除元素</a></li>
<li><a href="#2-6-di-yi-ge-yuan-su">2.6 第一个元素</a></li>
<li><a href="#2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</a></li>
<li><a href="#2-8-xia-yi-ge-yuan-su">2.8 下一个元素</a></li>
<li><a href="#2-9-qian-yi-ge-yuan-su">2.9 前一个元素</a></li>
<li><a href="#2-10-pan-kong">2.10 判空</a></li>
<li><a href="#2-11-pan-man">2.11 判满</a></li>
<li><a href="#2-12-bian-li">2.12 遍历</a></li>
<li><a href="#2-13-dao-bian-li">2.13 倒遍历</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-tailq-dui-lie-jie-shao">1 tailq队列介绍</span><a href="#1-tailq-dui-lie-jie-shao" class="header-anchor">#</a></h1><p>TAILQ队列是FreeBSD内核中的一种队列数据结构，主要是把队列头抽象成一个单独的结构体。它实现在Linux queue中。</p>
<h2><span id="1-1-queue-jian-jie">1.1 queue 简介</span><a href="#1-1-queue-jian-jie" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/1.png" alt="img"></p>
<p>可以include &lt;sys&#x2F;queue.h&gt;后直接使用。queue 分为 SLIST、LIST、STAILQ、TAILQ、CIRCLEQ 。queue 的所有源码都是宏定义，因此完全包含于queue.h当中，无需编译为库文件。</p>
<p>可以从toolchains或者系统路径&#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;sys&#x2F;queue.h找到实现。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/2.png" alt="img"></p>
<h2><span id="1-2-slist">1.2 SLIST</span><a href="#1-2-slist" class="header-anchor">#</a></h2><p>SLIST 是Singly-linked List 的缩写，意为单向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/3.png" alt="img"></p>
<h2><span id="1-3-stailq">1.3 STAILQ</span><a href="#1-3-stailq" class="header-anchor">#</a></h2><p>单向有尾链表，节点n为尾节点。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/4.png" alt="img"></p>
<h2><span id="1-4-list">1.4 LIST</span><a href="#1-4-list" class="header-anchor">#</a></h2><p>双向无尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/5.png" alt="img"></p>
<h2><span id="1-5-tailq">1.5 TAILQ</span><a href="#1-5-tailq" class="header-anchor">#</a></h2><p>双向有尾链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/6.png" alt="img"></p>
<h2><span id="1-6-circleq">1.6 CIRCLEQ</span><a href="#1-6-circleq" class="header-anchor">#</a></h2><p>双向循环链表。</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/7.png" alt="img"></p>
<h1><span id="2-tailq-shi-xian-yuan-li-tu-jie">2 TAILQ实现原理图解</span><a href="#2-tailq-shi-xian-yuan-li-tu-jie" class="header-anchor">#</a></h1><p>双向有尾链表,也就是有一个表头和表尾，表头指向节点1和尾节点。</p>
<h2><span id="2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou">2.1 描述前一个和下一个元素的结构</span><a href="#2-1-miao-shu-qian-yi-ge-he-xia-yi-ge-yuan-su-de-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_ENTRY(type)                                                   \</span></span><br><span class="line"><span class="keyword">struct</span> &#123;                                                                    \</span><br><span class="line">    <span class="keyword">struct</span> type *tqe_next;      <span class="comment">/* next element */</span>                          \</span><br><span class="line">    <span class="keyword">struct</span> type **tqe_prev;     <span class="comment">/* address of previous next element */</span>      \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*tqe_next是指向下一个元素的指针，tqe_prev是指向前一个元素的tqe_next地址，对它解引用后</span></span><br><span class="line"><span class="comment">（*tqe_priv）指向当前元素的地址。*/</span></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">struct</span> item&#123;</span><br><span class="line">　　<span class="built_in">int</span> val;</span><br><span class="line">　　TAILQ_ENTRY(item) entries;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/8.png" alt="img"></p>
<h2><span id="2-2-dui-lie-tou">2.2 队列头</span><a href="#2-2-dui-lie-tou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    TAILQ_HEAD(name, type)                        \</span></span><br><span class="line"><span class="keyword">struct</span> name &#123;                                \</span><br><span class="line">    <span class="keyword">struct</span> type *tqh_first;    <span class="comment">/* first element */</span>            \</span><br><span class="line">    <span class="keyword">struct</span> type **tqh_last;    <span class="comment">/* addr of last next element */</span>        \</span><br><span class="line">&#125;</span><br><span class="line">STAILQ_HEAD(my_tailq,  tailq_entry) queue_head;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/9.png" alt="img"></p>
<p>先看TAILQ_HEAD:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tqh_first为队列第一个元素的地址；</span><br><span class="line">tqh_last为最后一个元素tqe_next的地址；</span><br><span class="line">tqh_last指向的指针为<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>再看TAILQ_ENTRY:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tqe_next为队列下一个元素的地址；</span><br><span class="line">tqe_prev为队列上一个元素tqe_next的地址；</span><br><span class="line">tqe_prev指向的指针为当前元素的地址；</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-chu-shi-hua">2.3 初始化</span><a href="#2-3-chu-shi-hua" class="header-anchor">#</a></h2><p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/10.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INIT(head) do &#123;                                               \</span></span><br><span class="line">    (head)-&gt;tqh_first = NULL;                                               \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;                                  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="2-4-cha-ru-yuan-su">2.4 插入元素</span><a href="#2-4-cha-ru-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_INSERT_TAIL(head, elm, field) do &#123;                  \</span></span><br><span class="line">    (elm)-&gt;field.tqe_next = NULL;                                 \</span><br><span class="line">    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;                     \</span><br><span class="line">    *(head)-&gt;tqh_last = (elm);                                    \</span><br><span class="line">    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-1-cha-ru-1-ge-yuan-su">2.4.1 插入1个元素</span><a href="#2-4-1-cha-ru-1-ge-yuan-su" class="header-anchor">#</a></h3><ol>
<li><p>将要插入的node加入到尾部：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/11.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next = NULL;                         </span><br><span class="line">(elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;<span class="comment">//将要插入的节点prev指向最后一个node </span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>更新头节点:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/12.png" alt="img"></p>
</li>
</ol>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);          </span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<h3><span id="2-4-2-tong-li-cha-ru-duo-ge-yuan-su">2.4.2 同理插入多个元素</span><a href="#2-4-2-tong-li-cha-ru-duo-ge-yuan-su" class="header-anchor">#</a></h3><p>同理多个元素时尾插。</p>
<ol>
<li><p>将要插入的node加入到尾部:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/13.png" alt="img"></p>
</li>
<li><p>更新头节点:</p>
</li>
</ol>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/14.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">*(head)-&gt;tqh_last = (elm);           <span class="comment">//尾节点指向新的尾巴</span></span><br><span class="line">(head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next; <span class="comment">//head的last指向新的尾巴</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-5-shan-chu-yuan-su">2.5 删除元素</span><a href="#2-5-shan-chu-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TAILQ_REMOVE(head, elm, field) do &#123;                       \</span></span><br><span class="line">    <span class="keyword">if</span> (((elm)-&gt;field.tqe_next) != NULL)                          \</span><br><span class="line">        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;      \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;                           \</span><br><span class="line">    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;                         \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>



<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/15.png"></p>
<p>我们现在要把val&#x3D;3的elm删除：<br>elm中的tqe_next不为空，表示elm不是尾节点。那么</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(elm)-&gt;field.tqe_next-&gt;field.tqe_prev = (elm)-&gt;field.tqe_prev;</span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;</span><br></pre></td></tr></table></figure>

<p>这2句执行完后:</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/16.png" alt="img"></p>
<p>然后free掉该elm,</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/17.png" alt="img"></p>
<p>同理再删除val&#x3D;2的elm：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/18.png" alt="img"></p>
<p>然后free掉该elm，</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/19.png" alt="img"></p>
<p>最后如果要把val&#x3D;4的elm删除：</p>
<p>elm中的tqe_next为空，表示elm是尾节点。那么，</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;               <span class="comment">//让head的last指向新的尾巴        </span></span><br><span class="line">*(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;    <span class="comment">//让elm的前一个node的next指向该elm的后一个node</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/20.png" alt="img"></p>
<h2><span id="2-6-di-yi-ge-yuan-su">2.6 第一个元素</span><a href="#2-6-di-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-7-zui-hou-yi-ge-yuan-su">2.7 最后一个元素</span><a href="#2-7-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_LAST(head, headname) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这个实现看起来有点绕，我们先做一个实验:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> _QUEUE_ITEM &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line">    TAILQ_ENTRY(QUEUE_ITEM) entries;</span><br><span class="line">&#125;QUEUE_ITEM;</span><br><span class="line"></span><br><span class="line">TAILQ_HEAD(TAIL_QUEUE, QUEUE_ITEM) queue_head;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="built_in">int</span> argc, <span class="built_in">char</span> **argv</span>)</span> &#123;</span><br><span class="line">    QUEUE_ITEM *item[<span class="number">5</span>];</span><br><span class="line">    TAILQ_INIT(&amp;queue_head);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">        item[i] = (<span class="keyword">struct</span> QUEUE_ITEM*)malloc(<span class="keyword">sizeof</span>(QUEUE_ITEM));</span><br><span class="line">        item[i]-&gt;<span class="keyword">value</span> = i;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;queue_head, item[i], entries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            printf(<span class="string">&quot;item[%d]: item:%#x, next:%#x,&amp;next:%#x, prev:%#x, *prev:%#x\n&quot;</span>,</span><br><span class="line">　　　　　　　　i, item[i], item[i]-&gt;entries.tqe_next, &amp;(item[i]-&gt;entries.tqe_next), item[i]-&gt;entries.tqe_prev, *(item[i]-&gt;entries.tqe_prev));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;queue_head:%#x, first:%#x, last:%#x\n&quot;</span>, &amp;queue_head, queue_head.tqh_first, queue_head.tqh_last);</span><br><span class="line">    printf(<span class="string">&quot;last item:%p\n&quot;</span>, TAILQ_LAST(&amp;queue_head, TAIL_QUEUE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/21.png" alt="img"></p>
<p>可以用图形来描述:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/22.png" alt="img"></p>
<p><code>TAILQ_LAST(&amp;queue_head, TAIL_QUEUE);</code>这句话展开:<br><code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code></p>
<p><code>((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))</code>这句话,我们把地址0x601060代入进去得0x602098，即为：</p>
<p><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/23.png" alt="img"></p>
<p>然后<code>(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last)</code>得到0x602078,<br>认真的同学此时已经发现，此时对应倒数第二元素的next地址，</p>
<p>最后取<code>(*(((struct TAIL_QUEUE*)((&amp;queue_head)-&gt;tqh_last))-&gt;tqh_last))</code>得到0x602090,这就是最后一个元素的地址。</p>
<p><strong>总结：这里核心其实就是把最后一个元素的entries成员当成head指针来使用</strong>。因为本质上最后一个节点的TAILQ_ENTRY域和TAILQ_HEAD是同样的结构。</p>
<h2><span id="2-8-xia-yi-ge-yuan-su">2.8 下一个元素</span><a href="#2-8-xia-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_NEXT(elm, field)                ((elm)-&gt;field.tqe_next)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-9-qian-yi-ge-yuan-su">2.9 前一个元素</span><a href="#2-9-qian-yi-ge-yuan-su" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_PREV(elm, headname, field) \</span></span><br><span class="line">(*(((<span class="keyword">struct</span> headname *)((elm)-&gt;field.tqe_prev))-&gt;tqh_last))</span><br></pre></td></tr></table></figure>

<p>这里和TAILQ_LAST原理一样，将0x602090代入进去得:<br><img src="/2024/04/11/tailq%E9%98%9F%E5%88%97/24.png" alt="img"><br>然后对*(0x602058)得0x602070,即得到了前一个node的地址。</p>
<h2><span id="2-10-pan-kong">2.10 判空</span><a href="#2-10-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_EMPTY(head)                ((head)-&gt;tqh_first == NULL)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-11-pan-man">2.11 判满</span><a href="#2-11-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FIRST(head)                ((head)-&gt;tqh_first)</span></span><br></pre></td></tr></table></figure>

<h2><span id="2-12-bian-li">2.12 遍历</span><a href="#2-12-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH(var, head, field)                                        \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = ((head)-&gt;tqh_first);                                \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = ((<span class="keyword">var</span>)-&gt;field.tqe_next))</span><br></pre></td></tr></table></figure>

<h2><span id="2-13-dao-bian-li">2.13 倒遍历</span><a href="#2-13-dao-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>        TAILQ_FOREACH_REVERSE(var, head, headname, field)                \</span></span><br><span class="line"><span class="keyword">for</span> ((<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((head)-&gt;tqh_last))-&gt;tqh_last));        \</span><br><span class="line">(<span class="keyword">var</span>);                                                        \</span><br><span class="line">(<span class="keyword">var</span>) = (*(((<span class="keyword">struct</span> headname *)((<span class="keyword">var</span>)-&gt;field.tqe_prev))-&gt;tqh_last)))</span><br></pre></td></tr></table></figure>

<p>当看懂之前的<strong>最后一个元素</strong>原理时，倒遍历的实现是不是超级简单。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-bootm和bootz启动内核</title>
    <url>/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-images-quan-ju-bian-liang">1 images 全局变量</a><ul>
<li><a href="#1-1-bootm-tou-bu-jie-gou">1.1 bootm头部结构</a><ul>
<li><a href="#1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou">1.1.1 系统镜像头部结构</a></li>
<li><a href="#1-1-2-xi-tong-jing-xiang-jie-gou">1.1.2 系统镜像结构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-do-bootz-han-shu">2 do_bootz 函数</a><ul>
<li><a href="#2-1-bootz-start">2.1 bootz_start</a><ul>
<li><a href="#2-1-1-bootm-start">2.1.1 bootm_start</a></li>
<li><a href="#2-1-2-bootz-setup">2.1.2 bootz_setup</a></li>
<li><a href="#2-1-3-bootm-find-images">2.1.3 bootm_find_images</a></li>
</ul>
</li>
<li><a href="#2-2-do-bootm-states">2.2 do_bootm_states</a><ul>
<li><a href="#2-2-1-bootm-os-get-boot-func">2.2.1 bootm_os_get_boot_func</a></li>
<li><a href="#2-2-2-boot-pre-linux">2.2.2 boot_pre_linux</a></li>
<li><a href="#2-2-3-boot-jump-linux">2.2.3 boot_jump_linux</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-zong-jie-bootz-qi-dong-guo-cheng">3 总结bootz启动过程</a></li>
<li><a href="#4-uboot-qi-dong-linux-ce-shi">4 uboot 启动 Linux 测试</a><ul>
<li><a href="#4-1-emmc-qi-dong-linux">4.1 EMMC 启动 Linux</a></li>
<li><a href="#4-2-wang-luo-qi-dong-linux">4.2 网络启动 Linux</a></li>
</ul>
</li>
<li><a href="#5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao">5 附录：比特与十六进制转换快查表</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-images-quan-ju-bian-liang">1 images 全局变量</span><a href="#1-images-quan-ju-bian-liang" class="header-anchor">#</a></h1><p>不管是<code>bootz</code>还是<code>bootm</code>命令,启动kernel都会用到<code>images</code>全局变量。<code>images 定义在文件 cmd/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/1.png" alt="image"><br><code>include/image.h </code>中的定义了<code>bootm_headers_t</code>结构：该结构描述的是<code>bootm</code>启动时的头部信息。该结构又包含了系统镜像头部和系统镜像。</p>
<h2><span id="1-1-bootm-tou-bu-jie-gou">1.1 bootm头部结构</span><a href="#1-1-bootm-tou-bu-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">304</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bootm_headers</span> &#123;</span></span><br><span class="line"><span class="number">305</span> 	<span class="comment">/*</span></span><br><span class="line"><span class="comment">306 	* Legacy os image header, if it is a multi component image</span></span><br><span class="line"><span class="comment">307 	* then boot_get_ramdisk() and get_fdt() will attempt to get</span></span><br><span class="line"><span class="comment">308 	* data from second and third component accordingly.</span></span><br><span class="line"><span class="comment">309 	*/</span></span><br><span class="line"><span class="number">310</span> 	<span class="type">image_header_t</span> *legacy_hdr_os; <span class="comment">/* image header pointer */</span></span><br><span class="line"><span class="number">311</span> 	<span class="type">image_header_t</span> legacy_hdr_os_copy; <span class="comment">/* header copy */</span></span><br><span class="line"><span class="number">312</span> 	ulong legacy_hdr_valid;</span><br><span class="line"><span class="number">313</span></span><br><span class="line">......</span><br><span class="line"><span class="number">333</span></span><br><span class="line"><span class="number">334</span> 	<span class="meta">#<span class="keyword">ifndef</span> USE_HOSTCC</span></span><br><span class="line"><span class="number">335</span> 	<span class="type">image_info_t</span> os; <span class="comment">/* OS 镜像信息 */</span></span><br><span class="line"><span class="number">336</span> 	ulong ep; <span class="comment">/* OS 入口点 */</span></span><br><span class="line"><span class="number">337</span></span><br><span class="line"><span class="number">338</span> 	ulong rd_start, rd_end; <span class="comment">/* ramdisk 开始和结束位置 */</span></span><br><span class="line"><span class="number">339</span></span><br><span class="line"><span class="number">340</span> 	<span class="type">char</span> *ft_addr; <span class="comment">/* 设备树地址 */</span></span><br><span class="line"><span class="number">341</span> 	ulong ft_len; <span class="comment">/* 设备树长度 */</span></span><br><span class="line"><span class="number">342</span></span><br><span class="line"><span class="number">343</span> 	ulong initrd_start; <span class="comment">/* initrd 开始位置 */</span> </span><br><span class="line"><span class="number">344</span> 	ulong initrd_end; <span class="comment">/* initrd 结束位置 */</span></span><br><span class="line"><span class="number">345</span> 	ulong cmdline_start; <span class="comment">/* cmdline 开始位置 */</span></span><br><span class="line"><span class="number">346</span> 	ulong cmdline_end; <span class="comment">/* cmdline 结束位置 */</span></span><br><span class="line"><span class="number">347</span> 	<span class="type">bd_t</span> *kbd;</span><br><span class="line"><span class="number">348</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">349</span></span><br><span class="line"><span class="number">350</span> 	<span class="type">int</span> verify; <span class="comment">/* getenv(&quot;verify&quot;)[0] != &#x27;n&#x27; */</span></span><br><span class="line"><span class="number">351</span></span><br><span class="line"><span class="number">352</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_START (0x00000001)</span></span><br><span class="line"><span class="number">353</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOS (0x00000002)</span></span><br><span class="line"><span class="number">354</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FINDOTHER (0x00000004)</span></span><br><span class="line"><span class="number">355</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_LOADOS (0x00000008)</span></span><br><span class="line"><span class="number">356</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_RAMDISK (0x00000010)</span></span><br><span class="line"><span class="number">357</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_FDT (0x00000020)</span></span><br><span class="line"><span class="number">358</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_CMDLINE (0x00000040)</span></span><br><span class="line"><span class="number">359</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_BD_T (0x00000080)</span></span><br><span class="line"><span class="number">360</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_PREP (0x00000100)</span></span><br><span class="line"><span class="number">361</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_FAKE_GO (0x00000200)<span class="comment">/*&#x27;Almost&#x27; run the OS*/</span></span></span><br><span class="line"><span class="number">362</span> 	<span class="meta">#<span class="keyword">define</span> BOOTM_STATE_OS_GO (0x00000400)</span></span><br><span class="line"><span class="number">363</span> 	<span class="type">int</span> state;</span><br><span class="line"><span class="number">364</span></span><br><span class="line"><span class="number">365</span> 	<span class="meta">#<span class="keyword">ifdef</span> CONFIG_LMB</span></span><br><span class="line"><span class="number">366</span> 	<span class="class"><span class="keyword">struct</span> <span class="title">lmb</span> <span class="title">lmb</span>;</span> <span class="comment">/* 内存管理相关，不深入研究 */</span></span><br><span class="line"><span class="number">367</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">368</span> &#125; <span class="type">bootm_headers_t</span>;</span><br></pre></td></tr></table></figure>

<p>第 352~362 行这 11 个宏定义表示 BOOT 的不同阶段。</p>
<h3><span id="1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou">1.1.1 系统镜像头部结构</span><a href="#1-1-1-xi-tong-jing-xiang-tou-bu-jie-gou" class="header-anchor">#</a></h3><p>先来看下<code>image_header_t</code>结构，也就是系统镜像头部信息：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/2.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_header</span> &#123;</span></span><br><span class="line">	__be32		ih_magic;	<span class="comment">/* Image Header Magic Number	*/</span></span><br><span class="line">	__be32		ih_hcrc;	<span class="comment">/* Image Header CRC Checksum	*/</span></span><br><span class="line">	__be32		ih_time;	<span class="comment">/* Image Creation Timestamp	*/</span></span><br><span class="line">	__be32		ih_size;	<span class="comment">/* Image Data Size		*/</span></span><br><span class="line">	__be32		ih_load;	<span class="comment">/* Data	 Load  Address		*/</span></span><br><span class="line">	__be32		ih_ep;		<span class="comment">/* Entry Point Address		*/</span></span><br><span class="line">	__be32		ih_dcrc;	<span class="comment">/* Image Data CRC Checksum	*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_os;		<span class="comment">/* Operating System		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_arch;	<span class="comment">/* CPU architecture		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_type;	<span class="comment">/* Image Type			*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_comp;	<span class="comment">/* Compression Type		*/</span></span><br><span class="line">	<span class="type">uint8_t</span>		ih_name[IH_NMLEN];	<span class="comment">/* Image Name		*/</span></span><br><span class="line">&#125; <span class="type">image_header_t</span>;</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-2-xi-tong-jing-xiang-jie-gou">1.1.2 系统镜像结构</span><a href="#1-1-2-xi-tong-jing-xiang-jie-gou" class="header-anchor">#</a></h3><p>再来看下<code>image_info_t</code>结构，也就是系统镜像信息结构：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/3.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">image_info</span> &#123;</span></span><br><span class="line">	ulong		start, end;		<span class="comment">/* start/end of blob */</span></span><br><span class="line">	ulong		image_start, image_len; <span class="comment">/* start of image within blob, len of image */</span></span><br><span class="line">	ulong		load;			<span class="comment">/* load addr for the image */</span></span><br><span class="line">	<span class="type">uint8_t</span>		comp, type, os;		<span class="comment">/* compression, type of image, os type */</span></span><br><span class="line">	<span class="type">uint8_t</span>		arch;			<span class="comment">/* CPU architecture */</span></span><br><span class="line">&#125; <span class="type">image_info_t</span>;</span><br></pre></td></tr></table></figure>

<h1><span id="2-do-bootz-han-shu">2 do_bootz 函数</span><a href="#2-do-bootz-han-shu" class="header-anchor">#</a></h1><p><code>do_bootz </code>函数定义在<code>cmd/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/4.png" alt="image"><br>先执行<code>bootz_start</code>。先执行<code>BOOTM_STATE_START </code>阶段。<br>第 638 行，设置<code>images.os.os</code>为<code> IH_OS_LINUX</code>，也就是设置系统镜像为 Linux，表示我们要启动的是 Linux 系统！后面会用到 <code>images.os.os </code>来挑选具体的启动函数。<br>第 639 行，调用函数<code>do_bootm_states</code>来执行不同的 BOOT 阶段，这里要执行的 BOOT 阶段有：<code>BOOTM_STATE_OS_PREP 、BOOTM_STATE_OS_FAKE_GO 和BOOTM_STATE_OS_GO</code>。</p>
<h2><span id="2-1-bootz-start">2.1 bootz_start</span><a href="#2-1-bootz-start" class="header-anchor">#</a></h2><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/5.png" alt="image"></p>
<ol>
<li><p>调用函数<code> do_bootm_states</code>，执行 <code>BOOTM_STATE_START </code>阶段。</p>
</li>
<li><p>593 行，设置<code> images 的 ep</code>，也就是系统镜像的入口点，使用<code>bootz</code>命令启动系统的时候就会设置系统在 DRAM 中的存储位置，这个存储位置就是系统镜像的入口点，因此<code> images-&gt;ep=0X80800000</code>。镜像加载地址定义在<code>include/configs/mx6ullevk.h</code><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/6.png" alt="image"></p>
</li>
<li><p>调用<code>bootz_setup</code>函数，此函数会判断当前的系统镜像文件是否为 Linux 的镜像文件，并且会打印出镜像相关信息，<code>bootz_setup </code>函数稍后会讲解。</p>
</li>
<li><p>调用<code>bootm_find_images</code>查找<code>ramdisk</code>和<code>设备树(dtb)</code>文件，但是我们没有用到 <code>ramdisk</code>，因此此函数在这里仅仅用于查找<code>设备树(dtb)</code>文件，此函数稍后也会讲解。</p>
</li>
</ol>
<h3><span id="2-1-1-bootm-start">2.1.1 bootm_start</span><a href="#2-1-1-bootm-start" class="header-anchor">#</a></h3><p>执行<code>BOOTM_STATE_START</code>阶段时，执行<code>bootm_start</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/7.png" alt="image"><br>初始化<code>verfify </code>成员， 设置<code>images</code>状态为 <code>BOOTM_STATE_START</code>。</p>
<h3><span id="2-1-2-bootz-setup">2.1.2 bootz_setup</span><a href="#2-1-2-bootz-setup" class="header-anchor">#</a></h3><p>定义在文件 <code>arch/arm/lib/bootm.c</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/8.png" alt="image"></p>
<ol>
<li>宏<code>LINUX_ARM_ZIMAGE_MAGIC</code>就是 ARM Linux 系统<code>魔术数</code>。</li>
<li>从传递进来的参数<code> image(也就是系统镜像首地址)</code>中获取<code>zimage</code>头。</li>
<li>判断<code>image</code>是否为 ARM 的 Linux 系统镜像，如果不是的话就直接返回，并且打印出<code>“Bad Linux ARM zImage magic!”</code>，比如我们输入一个错误的启动命令：<br><code>bootz 80000000 – 900000000</code><br>因为我们并没有在<code>0X80000000</code>处存放 <code>Linux 镜像文件(zImage)</code>，因此上面的命令肯定会执行出错如下:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/9.png" alt="image"></li>
<li>初始化函数<code>bootz_setup</code>的参数<code> start 和 end</code>。</li>
<li>打印启动信息，如果 Linux 系统镜像正常的话打印如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/10.png" alt="image"></li>
</ol>
<h3><span id="2-1-3-bootm-find-images">2.1.3 bootm_find_images</span><a href="#2-1-3-bootm-find-images" class="header-anchor">#</a></h3><p>定义在文件<code> common/bootm.c</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/11.png" alt="image"></p>
<ol>
<li>查找<code> ramdisk</code>，但是我们没有用到 <code>ramdisk</code>，因此这部分代码不用管。</li>
<li>查找<code>设备树(dtb)</code>文件，找到以后就将设备树的起始地址和长度分别写到<code>images </code>的<code>ft_addr</code>和 <code>ft_len </code>成员变量中。我们使用 <code>bootz </code>启动 Linux 的时候已经指明了设备树在DRAM 中的存储地址，因此<code> images.ft_addr=0X83000000</code>，长度根据具体的设备树文件而定，比如我现在使用的设备树文件长度为<code> 0X8C81</code>，因此<code> images.ft_len=0X8C81</code>。</li>
</ol>
<h2><span id="2-2-do-bootm-states">2.2 do_bootm_states</span><a href="#2-2-do-bootm-states" class="header-anchor">#</a></h2><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/12.png" alt="image"><br>前面将<code>state</code>先处理了<code>BOOTM_STATE_START</code>阶段，接下来处里下面三个状态：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-1-bootm-os-get-boot-func">2.2.1 bootm_os_get_boot_func</span><a href="#2-2-1-bootm-os-get-boot-func" class="header-anchor">#</a></h3><p>进入第658行，通过<code>bootm_os_get_boot_func</code>来查找系统启动函数。由于前面提到<code>images-&gt;os.os </code>就是系统类型设置 为 <code>IH_OS_LINUX</code>，根据这个<code>os</code>类型来选择对应的启动函数名为<code>do_bootm_linux</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/13.png" alt="image"></p>
<h3><span id="2-2-2-boot-pre-linux">2.2.2 boot_pre_linux</span><a href="#2-2-2-boot-pre-linux" class="header-anchor">#</a></h3><p>第 676-677 行，处理<code>BOOTM_STATE_OS_PREP</code>状态，调用函数<code> do_bootm_linux，do_bootm_linux</code>调用<code>boot_prep_linux</code>来完成具体的处理过程。<code>boot_prep_linux </code>主要用于处理环境变量<code>bootargs，bootargs </code>保存着传递给<code>Linux kernel</code>的参数：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/14.png" alt="image"></p>
<pre><code>设备树的chosen节点下存放了子节点bootargs，bootargs子节点存放bootargs环境变量
</code></pre>
<h3><span id="2-2-3-boot-jump-linux">2.2.3 boot_jump_linux</span><a href="#2-2-3-boot-jump-linux" class="header-anchor">#</a></h3><p>第699行，调用函数<code>boot_selected_os</code>启动 Linux 内核，此函数第 4 个参数为 Linux 系统镜像头，第 5 个参数就是 Linux 系统启动函数<code> do_bootm_linux</code>。<code>boot_selected_os </code>函数定义在文件<code>common/bootm_os.c</code>如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/15.png" alt="image"><br>最终调用<code> boot_selected_os-&gt;boot_fn(即do_bootm_linux)-&gt;boot_jump_linux</code>来启动 Linux 内核：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/16.png" alt="image"><br><code>boot_jump_linux</code>：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/17.png" alt="image"></p>
<ol>
<li><p>我们的板子IMX6ULL是armv7 32位架构，因此从else开始，第293 行，变量 <code>machid </code>保存机器 ID，如果不使用设备树的话这个机器 ID 会被传递给 Linux内核，Linux 内核会在自己的机器 ID 列表里面查找是否存在与<code>uboot</code>传递进来的<code>machid</code>匹配的项目，如果存在就说明 Linux 内核支持这个机器，那么 Linux 就会启动！如果使用设备树的话这个<code>machid</code>就无效了，设备树存有一个“兼容性”这个属性，Linux 内核会比较“兼容性”属性的值(字符串)来查看是否支持这个机器。</p>
</li>
<li><p>第 295 行，函数<code> kernel_entry</code>，看名字“内核_进入”，说明此函数是进入 Linux 内核的，也就是最终的大boss！此函数有三个参数：<code>zero，arch，params</code>，第一个参数<code>zero</code>同样为 0；第二个参数为<code>机器 ID</code>；第三个参数<code> ATAGS 或者设备树(DTB)首地址</code>，<code>ATAGS </code>是传统的方法，用于传递一些命令行信息啥的，如果使用设备树的话就要传递<code>设备树(DTB)</code>。</p>
</li>
<li><p>第 299 行，获取 <code>kernel_entry </code>函数，函数<code>kernel_entry</code>并不是 <code>uboot </code>定义的，而是 Linux 内核定义的，Linux 内核镜像文件的第一行代码就是函数<code> kernel_entry</code>，而 <code>images-&gt;ep </code>保存着 Linux内核镜像的起始地址，起始地址保存的正是 Linux 内核第一行代码！</p>
</li>
<li><p>第 313 行，调用函数<code>announce_and_cleanup</code>来打印一些信息并做一些清理工作：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/18.png" alt="image"><br>因此每次启动 Linux 之前输出<code>“Starting kernel ...”</code>信息如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/19.png" alt="image"></p>
</li>
<li><p>继续回到函数<code> boot_jump_linux</code>,第 315~318 行是设置寄存器<code> r2</code> 的值。为什么要设置<code>r2</code>的值呢？Linux 内核一开始是汇编代码，因此函数<code>kernel_entry</code>就是个汇编函数。向汇编函数传递参数要使用<code> r0、r1 和 r2</code>(参数数量不超过 3 个的时候)，所以<code> r2</code> 寄存器就是函数<code>kernel_entry</code>的第三个参数。</p>
</li>
<li><p>第 316 行，如果使用设备树的话，<code>r2 </code>应该是设备树的起始地址，而设备树地址保存在<code> images</code>的<code>ftd_addr</code>成员变量中。</p>
</li>
<li><p>第 317 行，如果不使用设备树的话，<code>r2</code> 应该是<code>uboot</code>传递给 Linux 的参数起始地址，也就是环境变量<code>bootargs</code>的值，</p>
</li>
<li><p>最后调用调用<code>kernel_entry</code>函数进入 Linux 内核，至此<code>Uboot</code>的整个运行流程结束，<code>uboot </code>的使命也就完成了。</p>
</li>
</ol>
<h1><span id="3-zong-jie-bootz-qi-dong-guo-cheng">3 总结bootz启动过程</span><a href="#3-zong-jie-bootz-qi-dong-guo-cheng" class="header-anchor">#</a></h1><p><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/20.png" alt="image"></p>
<h1><span id="4-uboot-qi-dong-linux-ce-shi">4 uboot 启动 Linux 测试</span><a href="#4-uboot-qi-dong-linux-ce-shi" class="header-anchor">#</a></h1><h2><span id="4-1-emmc-qi-dong-linux">4.1 EMMC 启动 Linux</span><a href="#4-1-emmc-qi-dong-linux" class="header-anchor">#</a></h2><p>编译出来的 Linux 镜像文件 <code>zImage </code>和设备树文件保存在 EMMC中，<code>uboot </code>从 EMMC 中读取这两个文件并启动，这个是我们产品最终的启动方式。但是我们目前还没有讲解如何移植linux 和设备树文件，以及如何将 <code>zImage </code>和设备树文件保存到 EMMC中。不过大家拿到手的 I.MX6U-ALPHA 开发板(EMMC 版本)已经将<code> zImage</code> 文件和设备树文件烧写到了 EMMC 中，所以我们可以直接读取来测试。先检查一下 EMMC 的分区 1 中有没有<code>zImage </code>文件和设备树文件，输入命令<code>ls mmc 1:1</code>:<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/21.png" alt="image"><br>EMMC 分区 1 中存在<code>zimage</code>和 <code>imx6ull-alientek-emmc.dtb</code>这两个文件，所以我们可以测试新移植的 uboot能不能启动 linux 内核。设置 <code>bootargs </code>和<code> bootcmd</code>这两个环境变量:<br><code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code><br><code>setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;&#39;</code><br><code>saveenv</code><br>直接输入<code> boot</code>，或者<code>run bootcmd</code>即可启动 Linux 内核，如果 Linux 内核启动成功的话就会输出如下：<br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/22.png" alt="image"></p>
<h2><span id="4-2-wang-luo-qi-dong-linux">4.2 网络启动 Linux</span><a href="#4-2-wang-luo-qi-dong-linux" class="header-anchor">#</a></h2><p>调试过程中由于我们不断更改kernel, 那么如果每次都烧录进emmc，从emmc启动就很繁琐，直接从网络启动。<br>先将<code>zImage</code>和<code>dtb</code>文件放在tftp共享目录下，通过<code>nfs 或者 tftp</code>从 Ubuntu 中下载<code>zImage</code>和设备树文件：</p>
<p><code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code><br><code>setenv bootcmd &#39;tftp 80800000 zImage; tftp 83000000 imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000&#39;</code><br><code>saveenv</code><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/23.png" alt="image"><br><img src="/2024/06/23/uboot-bootm%E5%92%8Cbootz%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/24.png" alt="image"></p>
<h1><span id="5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao">5 附录：比特与十六进制转换快查表</span><a href="#5-fu-lu-bi-te-yu-shi-liu-jin-zhi-zhuan-huan-kuai-cha-biao" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * include/linux/sizes.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This program is free software; you can redistribute it and/or modify</span></span><br><span class="line"><span class="comment"> * it under the terms of the GNU General Public License version 2 as</span></span><br><span class="line"><span class="comment"> * published by the Free Software Foundation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LINUX_SIZES_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LINUX_SIZES_H__</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1				0x00000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2				0x00000002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4				0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8				0x00000008</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16				0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32				0x00000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64				0x00000040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128				0x00000080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256				0x00000100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512				0x00000200</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1K				0x00000400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2K				0x00000800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4K				0x00001000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8K				0x00002000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16K				0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32K				0x00008000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64K				0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128K				0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256K				0x00040000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512K				0x00080000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1M				0x00100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2M				0x00200000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_4M				0x00400000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_8M				0x00800000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_16M				0x01000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_32M				0x02000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_64M				0x04000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_128M				0x08000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_256M				0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_512M				0x20000000</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_1G				0x40000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SZ_2G				0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __LINUX_SIZES_H__ */</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-menuconfig和Kconfig图像化配置</title>
    <url>/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ncurses-ku-an-zhuang">1 ncurses 库安装</a></li>
<li><a href="#2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li">2 menuconfig菜单使用说明和举例</a></li>
<li><a href="#3-menuconfig-tu-xing-hua-pei-zhi-yuan-li">3 menuconfig 图形化配置原理</a><ul>
<li><a href="#3-1-make-menuconfig-guo-cheng">3.1 make menuconfig 过程</a><ul>
<li><a href="#3-1-1-kconfig-yu-fa-jian-jie">3.1.1 Kconfig 语法简介</a><ul>
<li><a href="#3-1-1-1-mainmenu">3.1.1.1 mainmenu</a></li>
<li><a href="#3-1-1-2-zi-kconfig">3.1.1.2 子Kconfig</a></li>
<li><a href="#3-1-1-3-menu-endmenu-cai-dan">3.1.1.3 menu&#x2F;endmenu 菜单</a></li>
<li><a href="#3-1-1-4-config-tiao-mu">3.1.1.4 config条目</a></li>
<li><a href="#3-1-1-5-depends-on-he-select">3.1.1.5 depends on 和 select</a></li>
<li><a href="#3-1-1-6-choice-endchoice">3.1.1.6 choice&#x2F;endchoice</a></li>
<li><a href="#3-1-1-7-menuconfig">3.1.1.7 menuconfig</a></li>
<li><a href="#3-1-1-8-comment">3.1.1.8 comment</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-menuconfig-cai-dan-shi-zhan-lian-xi">4 menuconfig菜单实战练习</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-ncurses-ku-an-zhuang">1 ncurses 库安装</span><a href="#1-ncurses-ku-an-zhuang" class="header-anchor">#</a></h1><p>uboot 或 Linux 内核可以通过输入<code>make menuconfig</code>来打开图形化配置界面，<code>menuconfig</code>是一套图形化的配置工具，需要<code>ncurses</code>库支持。<br><code>sudo apt-get install build-essential</code><br><code>sudo apt-get install libncurses5-dev</code></p>
<h1><span id="2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li">2 menuconfig菜单使用说明和举例</span><a href="#2-menuconfig-cai-dan-shi-yong-shuo-ming-he-ju-li" class="header-anchor">#</a></h1><p><code>menuconfig </code>重点会用到两个文件：<code>.config </code>和 <code>Kconfig</code>，<code>.config </code>文件前面已经说了，这个文件保存着 uboot 的配置项，使用 <code>menuconfig </code>配置完 uboot 以后会更新<code>.config </code>文件。<code>Kconfig</code>文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有<code>Kconfig</code>文件。<br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_alientek_emmc_defconfig</code><br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code><br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/1.png" alt="image"><br>通过键盘上的<code>“↑”</code>和<code>“↓”</code>键来选择要配置的菜单，按下<code>“Enter”</code>键进入子菜单。菜单中高亮的字母就是此菜单的热键，在键盘上按下此高亮字母对应的键可以快速选中对应的菜单。选中子菜单以后按下<code>“Y”</code>键就会将相应的代码编译进 Uboot 中，菜单前面变为<code>“&lt; * &gt;”</code>。按下<code>“N”</code>键不编译相应的代码，按下<code>“M”</code>键就会将相应的代码编译为模块，菜单前面变为<code>“&lt; M &gt;”</code>。按两下<code>“Esc”</code>键退出，也就是返回到上一级，按下<code>“?”</code>键查看此菜单的帮助信息，按下<code>“/”</code>键打开搜索框，可以在搜索框输入要搜索的内容。<br>在配置界面下方会有五个按钮，这五个按钮的功能如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">&lt;Select&gt;：选中按钮，和“Enter”键的功能相同，负责选中并进入某个菜单。</span><br><span class="line">&lt;Exit&gt;：退出按钮，和按两下“Esc”键功能相同，退出当前菜单，返回到上一级。</span><br><span class="line">&lt;Help&gt;：帮助按钮，查看选中菜单的帮助信息。</span><br><span class="line">&lt;Save&gt;：保存按钮，保存修改后的配置文件。</span><br><span class="line">&lt;Load&gt;：加载按钮，加载指定的配置文件。</span><br></pre></td></tr></table></figure>
<p>就以如何使能<code>dns</code>命令为例，讲解一下如何通过图形化界面来配置 uboot。进入<code>“Command line interface ---&gt;”</code>这个配置项:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/2.png" alt="image"><br>选择<code>“Network commands ---&gt;”</code>，进入网络相关命令配置项:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/3.png" alt="image"><br>可以看出，uboot 中有很多和网络有关的命令，比如<code>bootp、tftpboot、dhcp</code>等等。选中<code> dns</code>，然后按下键盘上的<code>“Y”</code>键，此时<code>dns</code>前面的<code>“[ ]”</code>变成了<code>“[ * ]” </code>:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/4.png" alt="image"><br>细心的朋友应该会发现，在<code>mx6ull_alientek_emmc.h</code>里面我们配置使能了<code> dhcp</code> 和<code>ping</code>命令，但是在上图中的<code>“[ ]”</code>并不是<code>“[ * ]”</code>，也就是说不编译<code>dhcp</code>和 <code>ping</code>命令，这不是冲突了吗？实际情况是<code> dhcp</code> 和<code> ping</code> 命令是会编译的。之所以在上图中没有体现出来时因为我们是直接在<code>mx6ull_alientek_emmc.h</code>中定义的宏<code>CONFIG_CMD_PING</code>和<code>CONFIG_CMD_DHCP</code>，而<code> menuconfig</code> 是通过读取<code>.config </code>文件来判断使能了哪些功能，<code>.config</code>里面并没有宏<code>CONFIG_CMD_PING</code>和<code>CONFIG_CMD_DHCP</code>,因此<code>menuconfig</code>不会选中这两项。<br>总结下：配置选项来自2个地方，一个是<code>mx6ull_alientek_emmc.h</code>，一个是<code>.config</code><br>选中<code> dns</code>，然后按下<code>“H”</code>或者<code>“?”</code>键可以打开<code>dns</code>命令的帮助提示信息：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/5.png" alt="image"><br>选择<code>dns</code>命令以后，按两下 <code>ESC </code>键（按两下<code>ESC</code>键相当于返回上一层），退出当前配置项，进入到上一层配置项，输入<code>Y</code>保存修改后的配置到<code>.config</code>。<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/6.png" alt="image"><br>再打开<code>.config</code>，会发现多了<code>“CONFIG_CMD_DNS=y”</code>这一行：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/7.png" alt="image"><br>再次编译：<br><code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j16</code><br>烧录uboot进sd卡，开机从sd卡启动,进入uboot命令行后，输入<code>help或者?</code>就可以看到uboot支持了dns命令。<br>测试：先将板子连接能上外网的路由器，要先设置一下<code>dns</code>服务器的 IP 地址，也就是设置环境变量 <code>dnsip </code>的值：<br><code>setenv dnsip 114.114.114.114</code><br><code>saveenv</code><br>设置好以后就可以使用 dns 命令查看百度官网的 IP 地址了:<br><code>dns www.baidu.com</code><br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/8.png" alt="image"><br>可以看到dns解析命令功能正常。</p>
<h1><span id="3-menuconfig-tu-xing-hua-pei-zhi-yuan-li">3 menuconfig 图形化配置原理</span><a href="#3-menuconfig-tu-xing-hua-pei-zhi-yuan-li" class="header-anchor">#</a></h1><h2><span id="3-1-make-menuconfig-guo-cheng">3.1 make menuconfig 过程</span><a href="#3-1-make-menuconfig-guo-cheng" class="header-anchor">#</a></h2><p>同<code>defconfig</code>一样，<code>make menuconfig</code> 也会匹配到顶层<code> Makefile。</code> </p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17859528.html">Uboot顶层Makefile解析-1. defconfig过程分析 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/">uboot-编译defconfig分析 | Hexo (fuzidage.github.io)</a></p>
<p><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/9.png" alt="image"><br>其中 <code>build=-f ./scripts/Makefile.build obj</code>, 展开后：<br><code>make -f ./scripts/Makefile.build obj=scripts/kconfig menuconfig</code><br><code>Makefile.build </code>会读取<code>scripts/kconfig/Makefile</code>中的内容，在<code>scripts/kconfig/Makefile</code>中可以找到如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/10.png" alt="image"><br>其中<code>obj= scripts/kconfig</code>，<code>silent</code>是设置静默编译的，在这里可以忽略不计，<code>Kconfig=Kconfig</code>，因此扩展以后就是：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/11.png" alt="image"><br><code>scripts/kconfig/mconf.c </code>这个文件会被编译，生成 <code>mconf </code>这个可执行文件。<code>mconf </code>会调用 uboot 根目录下的 <code>Kconfig </code>文件开始构建图形配置界面。</p>
<h3><span id="3-1-1-kconfig-yu-fa-jian-jie">3.1.1 Kconfig 语法简介</span><a href="#3-1-1-kconfig-yu-fa-jian-jie" class="header-anchor">#</a></h3><h4><span id="3-1-1-1-mainmenu">3.1.1.1 mainmenu</span><a href="#3-1-1-1-mainmenu" class="header-anchor">#</a></h4><p>输入<code>make menuconfig</code>以后打开的默认界面就是<code>mainmenu</code>，在顶层<code> Kconfig</code> 中有如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/12.png" alt="image"><br>我们的uboot是<code>UBOOTVERSION=2016.03</code>，如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/13.png" alt="image"></p>
<h4><span id="3-1-1-2-zi-kconfig">3.1.1.2 子Kconfig</span><a href="#3-1-1-2-zi-kconfig" class="header-anchor">#</a></h4><p><code>Kconfig </code>也可以调用其他子目录中的<code>Kconfig</code>文件，调用方法如下:<br><code>source &quot;xxx/Kconfig&quot;</code><br>顶层<code>Kconfig</code>中，调用了很多子<code>Kconfig</code>:<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/14.png" alt="image"></p>
<h4><span id="3-1-1-3-menu-x2f-endmenu-cai-dan">3.1.1.3 menu&#x2F;endmenu 菜单</span><a href="#3-1-1-3-menu-x2f-endmenu-cai-dan" class="header-anchor">#</a></h4><p><code>menu </code>用于生成菜单，<code>endmenu </code>就是菜单结束标志。在顶层<code>Kconfig </code>中有如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/15.png" alt="image"><br>体现在主菜单界面如下所示：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/16.png" alt="image"><br>在<code>“General setup”</code>菜单上面还有 <code>“Architecture select (ARM architecture)”</code>和<code>“ARM architecture”</code>这两个子菜单，但是在顶层 <code>Kconfig </code>中并没有看到这两个子菜单对应的<code>menu/endmenu </code>代码块，那这两个子菜单是怎么来的呢？这两个子菜单就是<code>arch/Kconfig</code>文件生成的。包括主界面中的<code>“Boot timing”、“Console recording”</code>等等这些子菜单，都是分别由顶层<code>Kconfig </code>所调用的 <code>common/Kconfig、cmd/Kconfig</code> 等这些子<code>Kconfig</code>文件来创建的。</p>
<h4><span id="3-1-1-4-config-tiao-mu">3.1.1.4 config条目</span><a href="#3-1-1-4-config-tiao-mu" class="header-anchor">#</a></h4><p>顶层<code>Kconfig</code>中的<code>“General setup”</code>子菜单内容如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">14 menu <span class="string">&quot;General setup&quot;</span></span><br><span class="line">15</span><br><span class="line">16 config LOCALVERSION</span><br><span class="line">17 string <span class="string">&quot;Local version - append to U-Boot release&quot;</span></span><br><span class="line">18 help</span><br><span class="line">19 Append an extra string to the end of your U-Boot version.</span><br><span class="line">20 This will show up on your boot log, for example.</span><br><span class="line">21 The string you set here will be appended after the contents of</span><br><span class="line">22 any files with a filename matching localversion* in your</span><br><span class="line">23 object and source tree, in that order. Your total string can</span><br><span class="line">24 be a maximum of 64 characters.</span><br><span class="line">25 </span><br><span class="line">26 config LOCALVERSION_AUTO</span><br><span class="line">27 bool <span class="string">&quot;Automatically append version information to the version </span></span><br><span class="line"><span class="string">string&quot;</span></span><br><span class="line">28 default y</span><br><span class="line">29 help</span><br><span class="line">......</span><br><span class="line">45 </span><br><span class="line">46 config CC_OPTIMIZE_FOR_SIZE</span><br><span class="line">47 bool <span class="string">&quot;Optimize for size&quot;</span></span><br><span class="line">48 default y</span><br><span class="line">49 help</span><br><span class="line">......</span><br><span class="line">54 </span><br><span class="line">55 config SYS_MALLOC_F</span><br><span class="line">56 bool <span class="string">&quot;Enable malloc() pool before relocation&quot;</span></span><br><span class="line">57 default y if DM</span><br><span class="line">58 help</span><br><span class="line">......</span><br><span class="line">63 </span><br><span class="line">64 config SYS_MALLOC_F_LEN</span><br><span class="line">65 hex <span class="string">&quot;Size of malloc() pool before relocation&quot;</span></span><br><span class="line">66 depends on SYS_MALLOC_F</span><br><span class="line">67 default 0x400</span><br><span class="line">68 help</span><br><span class="line">......</span><br><span class="line">73 </span><br><span class="line">74 menuconfig EXPERT</span><br><span class="line">75 bool <span class="string">&quot;Configure standard U-Boot features (expert users)&quot;</span></span><br><span class="line">76 default y</span><br><span class="line">77 help</span><br><span class="line">......</span><br><span class="line">82 </span><br><span class="line">83 if EXPERT</span><br><span class="line">84 config SYS_MALLOC_CLEAR_ON_INIT</span><br><span class="line">85 bool <span class="string">&quot;Init with zeros the memory reserved for malloc (slow)&quot;</span></span><br><span class="line">86 default y</span><br><span class="line">87 help</span><br><span class="line">......</span><br><span class="line">99 <span class="keyword">endif</span></span><br><span class="line">100 endmenu <span class="comment"># General setup</span></span><br></pre></td></tr></table></figure>
<p>可以看到有大量的<code>“config xxxx”</code>的代码块，也就是<code>config</code>条目。<code>“General setup”</code>菜单的<code>config</code>条目具体配置项如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/17.png" alt="image"><br><code>“config LOCALVERSION”</code>对应着第一个配置项，<code>“config LOCALVERSION_AUTO”</code>对应着 第 二 个 配 置 项。</p>
<p>① 第 16 和 26 行，这两行都以 <code>config </code>关键字开头，后面跟着 <code>LOCALVERSION </code>和<code>LOCALVERSION_AUTO</code>，这两个就是配置项名字。假如我们使能了<code> LOCALVERSION_AUTO</code>这个功能，那么就会下<code>.config</code> 文件中生成 <code>CONFIG_LOCALVERSION_AUTO</code>。</p>
<p>②<code>config</code>关键字下面的这几行是配置项属性，17<del>24 行是<code> LOCALVERSION</code> 的属性，27</del>44 行是<code> LOCALVERSION_AUTO</code> 的属性。</p>
<p>③ 属性里面描述了配置项的类型、输入提示、依赖关系、帮助信息和默认值等。第 17 行的<code>string</code>是变量类型，也就<code>“CONFIG_ LOCALVERSION”</code>的变量类型。可以为：<code>bool、tristate、string、hex 和 int</code>，一共 5 种。最常用的是 <code>bool、tristate 和 string </code>这三种，<code>bool </code>类型有两种值：<code>y 和 n</code>，当为 y 的时候表示使能这个配置项，当为 n 的时候就禁止这个配置项。<code>tristate </code>类型有三种值：<code>y、m 和 n</code>，其中 y 和 n 的涵义与 bool 类型一样，m 表示将这个配置项编译为模块。<code>string </code>为字符串类型，所以 <code>LOCALVERSION </code>是个字符串变量，用来存储本地字符串，选中以后即可输入用户定义的本地版本号，如下图：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/18.png" alt="image"></p>
<p><code>string </code>后面的<code>“Local version - append to U-Boot release”</code>就是这个配置项在图形界面上的显示出来的标题。<br>④ 第 18 行，<code>help </code>表示帮助信息，告诉我们配置项的含义，当我们按下<code>“h”或“?”</code>弹出来的帮助界面就是 <code>help </code>的内容。<br>⑤ 第 27 行，说明<code>“CONFIG_LOCALVERSION_AUTO”</code>是个<code>bool </code>类型，可以通过按下 Y 或N 键来使能或者禁止 <code>CONFIG_LOCALVERSION_AUTO</code>。<br>⑥ 第 28 行，<code>“default y”</code>表示 <code>CONFIG_LOCALVERSION_AUTO </code>的默认值就是 y，所以这一行默认会被选中。</p>
<h4><span id="3-1-1-5-depends-on-he-select">3.1.1.5 depends on 和 select</span><a href="#3-1-1-5-depends-on-he-select" class="header-anchor">#</a></h4><p>打开 <code>arch/Kconfig </code>文件，在里面有这如下代码：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/19.png" alt="image"><br>第 9 行，<code>“depends on”</code>说明<code>“SYS_GENERIC_BOARD”</code>项依赖于<code>“HAVE_GENERIC_BOARD”</code>,也就是说<code>“HAVE_GENERIC_BOARD”</code>被选中以后<code>“SYS_GENERIC_BOARD”</code>才能被选中。<br>第 17~20 行，<code>“select”</code>表示方向依赖，当选中<code>“ARC”</code>以后，<code>“HAVE_PRIVATE_LIBGCC”、“HAVE_GENERIC_BOARD”、“SYS_GENERIC_BOARD”和“SUPPORT_OF_CONTROL”</code>这四个也会被选中。</p>
<h4><span id="3-1-1-6-choice-x2f-endchoice">3.1.1.6 choice&#x2F;endchoice</span><a href="#3-1-1-6-choice-x2f-endchoice" class="header-anchor">#</a></h4><p>在<code>arch/Kconfig</code>文件中有如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">11 choice</span><br><span class="line">12 prompt <span class="string">&quot;Architecture select&quot;</span></span><br><span class="line">13 default SANDBOX</span><br><span class="line">14 </span><br><span class="line">15 config ARC</span><br><span class="line">16 bool <span class="string">&quot;ARC architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">21 </span><br><span class="line">22 config ARM</span><br><span class="line">23 bool <span class="string">&quot;ARM architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">29 </span><br><span class="line">30 config AVR32</span><br><span class="line">31 bool <span class="string">&quot;AVR32 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">35 </span><br><span class="line">36 config BLACKFIN</span><br><span class="line">37 bool <span class="string">&quot;Blackfin architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">40 </span><br><span class="line">41 config M68K</span><br><span class="line">42 bool <span class="string">&quot;M68000 architecture&quot;</span></span><br><span class="line">......</span><br><span class="line">117</span><br><span class="line">118 endchoice</span><br></pre></td></tr></table></figure>

<p><code>choice/endchoice </code>代码段定义了一组可选择项，将多个类似的配置项组合在一起，供用户单选或者多选。该示例就是选择处理器架构，可以从<code>ARC、ARM、AVR32</code>等这些架构中选择，这里是单选。在 uboot 图形配置界面上选择<code>“Architecture select”</code>，进入以后如下图：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/20.png" alt="image"><br>第 12 行的<code>prompt</code>给出这个<code>choice/endchoice </code>段的提示信息为<code>“Architecture select”</code>。</p>
<h4><span id="3-1-1-7-menuconfig">3.1.1.7 menuconfig</span><a href="#3-1-1-7-menuconfig" class="header-anchor">#</a></h4><p><code>menuconfig 和 menu </code>很类似，但是 <code>menuconfig </code>是个<strong>带选项的菜单</strong>,如顶层<code>Kconfig</code>中的<code>“General setup”</code>中的列表中有一项<code>menuconfig EXPERT</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/21.png" alt="image"><br>结果如下：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/22.png" alt="image"><br>可以看到，前面有<code>“[ ]”</code>说明这个<strong>菜单是可选的</strong>，当选中这个菜单以后就可以进入到子选项中：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/23.png" alt="image"><br>如果不选择<code>“Configure standard U-Boot features (expert users)”</code>，那么所描述的菜单就不会显示出来，进去以后是空白的。</p>
<h4><span id="3-1-1-8-comment">3.1.1.8 comment</span><a href="#3-1-1-8-comment" class="header-anchor">#</a></h4><p><code>comment</code>用于注释， 也就是在图形化界面中显示一行注释。例如<code>drivers/mtd/nand/Kconfig</code>中：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">74 config NAND_ARASAN</span><br><span class="line">75 bool <span class="string">&quot;Configure Arasan Nand&quot;</span></span><br><span class="line">76 help</span><br><span class="line">......</span><br><span class="line">80</span><br><span class="line">81 comment <span class="string">&quot;Generic NAND options&quot;</span></span><br></pre></td></tr></table></figure>
<p>第 81 行使用<code>comment</code>标注了一行注释，注释内容为：<code>“Generic NAND options”</code>，这行注释在配置项<code> NAND_ARASAN</code> 的下面。<br>在配置项<code>“Configure Arasan Nand”</code>下面有一行注释，注释内容为<code>“*** Generic NAND options ***”</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/24.png" alt="image"></p>
<h1><span id="4-menuconfig-cai-dan-shi-zhan-lian-xi">4 menuconfig菜单实战练习</span><a href="#4-menuconfig-cai-dan-shi-zhan-lian-xi" class="header-anchor">#</a></h1><p>接下来自定义一个菜单进行练习，自定义菜单要求如下：<br>①、在主界面中添加一个名为<code>“My test menu”</code>，此菜单内部有一个配置项。<br>②、配置项为<code>“MY_TESTCONFIG”</code>，此配置项处于菜单<code>“My test menu”</code>中。<br>③、配置项的为变量类型为<code> bool</code>，默认值为 <code>y</code>。<br>④、配置项菜单名字为<code>“This is my test config”</code><br>⑤、配置项的帮助内容为<code>“This is a empty config, just for tset!”</code>。<br>在顶层 <code>Kconfig</code>，在最后面加入如下代码：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1 menu <span class="string">&quot;My test menu&quot;</span></span><br><span class="line">2</span><br><span class="line">3 config MY_TESTCONFIG</span><br><span class="line">4 bool <span class="string">&quot;This is my test config&quot;</span></span><br><span class="line">5 default y</span><br><span class="line">6 help</span><br><span class="line">7 This is a empty config, just for test!</span><br><span class="line">8</span><br><span class="line">9 endmenu <span class="comment"># my test menu</span></span><br></pre></td></tr></table></figure>
<p>再次执行<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</code>：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/25.png" alt="image"><br>可以看出，主菜单最后面出现了一个名为<code>“My test menu”</code>的子菜单，这个就是上面添加进来的子菜单。进入此子菜单：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/26.png" alt="image"><br>可以看出，配置项也添加成功，按H查看帮助信息：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/27.png" alt="image"><br>保存退出，打开.config文件：<br><img src="/2024/06/23/uboot-menuconfig%E5%92%8CKconfig%E5%9B%BE%E5%83%8F%E5%8C%96%E9%85%8D%E7%BD%AE/28.png" alt="image"><br>配置项<code>MY_TESTCONFIG</code>默认也是被选中的，因此在<code>.config </code>文件中肯定会有<code>“CONFIG_MY_TESTCONFIG=y”</code>这一行。</p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-启动流程</title>
    <url>/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-reset-han-shu">1 reset 函数</a><ul>
<li><a href="#1-1-chu-shi-hua-yi-chang-xiang-liang-biao">1.1 初始化异常向量表</a></li>
<li><a href="#1-2-save-boot-params-ret">1.2 save_boot_params_ret</a><ul>
<li><a href="#1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi">1.2.1 关中断，进入SVC模式</a></li>
<li><a href="#1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar">1.2.2 cp15配置，设置中断向量表偏移VBAR</a></li>
<li><a href="#1-2-3-cp15-pei-zhi-guan-mmu-icache">1.2.3 cp15配置，关<code>MMU，ICACHE</code></a></li>
</ul>
</li>
<li><a href="#1-3-lowlevel-init-dui-sram-nei-cun-bu-ju">1.3 lowlevel_init对sram内存布局</a></li>
<li><a href="#1-4-s-init-han-shu">1.4 s_init函数</a></li>
</ul>
</li>
<li><a href="#2-main-han-shu">2 <code>_main</code>函数</a><ul>
<li><a href="#2-1-sram-zhong-zhi-ding-sp">2.1 sram中指定SP</a></li>
<li><a href="#2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen">2.2 board_init_f_alloc_reserve（指定<code>malloc/gd</code>指针）</a></li>
<li><a href="#2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0">2.3 <code>board_init_f_init_reserve</code>（<code>初始化gd，gd内存清0</code>）</a></li>
<li><a href="#2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen">2.4 board_init_f(外设初始化和DRAM划分)</a></li>
<li><a href="#2-5-relocate-code-dai-ma-chong-ding-wei">2.5 relocate_code(代码重定位)</a><ul>
<li><a href="#2-5-1-chong-ding-wei-hou-de-lr-she-zhi">2.5.1 重定位后的LR设置</a></li>
<li><a href="#2-5-2-dai-ma-duan-chong-ding-wei">2.5.2 代码段重定位</a></li>
<li><a href="#2-5-3-rel-dyn-duan-chong-ding-wei">2.5.3 <code>rel.dyn</code>段重定位</a></li>
</ul>
</li>
<li><a href="#2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei">2.6 relocate_vectors(向量表重定位)</a></li>
<li><a href="#2-7-board-init-r">2.7 board_init_r</a><ul>
<li><a href="#2-7-1-wai-she-chu-shi-hua">2.7.1 外设初始化</a></li>
<li><a href="#2-7-2-run-main-loop-han-shu">2.7.2 run_main_loop 函数</a><ul>
<li><a href="#2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi">2.7.2.1 Uboot version环境变量设置</a></li>
<li><a href="#2-7-2-2-bootdelay-he-bootcmd-huo-qu">2.7.2.2 bootdelay和bootcmd获取</a></li>
<li><a href="#2-7-2-3-autoboot-command-zhi-xing-bootcmd">2.7.2.3 autoboot_command(执行bootcmd)</a><ul>
<li><a href="#2-7-2-3-1-bootdelay-dao-ji-shi">2.7.2.3.1 bootdelay倒计时</a></li>
</ul>
</li>
<li><a href="#2-7-2-4-cli-loop-uboot-ming-ling-xing">2.7.2.4 cli_loop(uboot命令行)</a><ul>
<li><a href="#2-7-2-4-1-cmd-process-han-shu-fen-xi">2.7.2.4.1 cmd_process 函数分析</a></li>
<li><a href="#2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li">2.7.2.4.2 uboot命令定义(dhcp为例)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>



<p>下面以<code>u-boot 2016</code>为例，一行一行分析<code>armv7</code>架构cpu的uboot启动流程，用到的soc是<code>imx6ull</code>为例。总体流程如下：分为2部分：<br>①arch级初始化(架构)<br>②板级初始化<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/1.png" alt="image"></p>
<h1><span id="1-reset-han-shu">1 reset 函数</span><a href="#1-reset-han-shu" class="header-anchor">#</a></h1><h2><span id="1-1-chu-shi-hua-yi-chang-xiang-liang-biao">1.1 初始化异常向量表</span><a href="#1-1-chu-shi-hua-yi-chang-xiang-liang-biao" class="header-anchor">#</a></h2><p>我们知道启动入口是<code>arch/arm/lib/vectors.S</code>文件中的<code>_start</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/2.png" alt="image"><br>从函数入口<code>_start</code>可以看到，入口的指令存放的就是中断向量表，<code>0地址偏移存放reset</code>, <code>0x4地址存放_undefined_instruction</code>，<code>0x8地址存放_software_interrupt...</code><br>CPU上电最开始进入<code>_start</code>,进而进入<code>reset</code>函数，该函数定义在<code>arch/arm/cpu/armv7/start.S </code>里面。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/3.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/4.png" alt="image"><br>函数调用关系如下：<code>reset-&gt;save_boot_params-&gt;save_boot_params_ret</code>。</p>
<h2><span id="1-2-save-boot-params-ret">1.2 save_boot_params_ret</span><a href="#1-2-save-boot-params-ret" class="header-anchor">#</a></h2><h3><span id="1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi">1.2.1 关中断，进入SVC模式</span><a href="#1-2-1-guan-zhong-duan-jin-ru-svc-mo-shi" class="header-anchor">#</a></h3><p><code>save_boot_params_ret </code>函数代码如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/5.png" alt="image"><br>该函数功能如注释所写主要是关闭<code>IRQ和FIQ</code>, 进入<code>SVC</code>模式，都是控制<code>cpsr</code>寄存器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一行读取 cpsr寄存器</span></span><br><span class="line"><span class="comment">//第二行对r0和0x1a进行与运算，目的是取出cpu模式。</span></span><br><span class="line"><span class="comment">//第三行如果 r1 和 0X1A 不相等，也就是 CPU 不处于 Hyp 模式的话就将 r0 寄存器的低5位清零，清除模式位</span></span><br><span class="line"><span class="comment">//第4行如果处理器不处于 Hyp 模式的话就将 r0 的寄存器的值与 0x13 进行或运算， 0x13=0b10011，也就是设置处理器进入 SVC 模式、</span></span><br><span class="line"><span class="comment">//第5行与 0xC0或运算，那么 r0 寄存器此时的值就是 0xD3，cpsr 的 I 为和 F 位分别控制 IRQ 和 FIQ 这两个中断的开关，设置为 1 就关闭了 FIQ 和 IRQ。</span></span><br><span class="line"><span class="comment">//第6行r0写入cpsr</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/6.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/7.png" alt="image"></p>
<h3><span id="1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar">1.2.2 cp15配置，设置中断向量表偏移VBAR</span><a href="#1-2-2-cp15-pei-zhi-she-zhi-zhong-duan-xiang-liang-biao-pian-yi-vbar" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/8.png" alt="image"><br>这里一般2个宏都没有定义，进入，这段作用是设置中断向量表偏移<code>VBAR</code>。<br>这里是把<code>CP15 SCTLR Register</code>读出来，<code>bic</code>是位清0，<code>CR_V </code>在 <code>arch/arm/include/asm/system.h </code>中定义了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">define <span class="title function_">CR_V</span> <span class="params">(<span class="number">1</span> &lt;&lt; <span class="number">13</span>)</span> <span class="comment">/* Vectors relocated to 0xffff0000 */</span></span><br></pre></td></tr></table></figure>
<p>那么就是把<code>CP15 SCTLR Register</code>读出来,对<code>bit13清0</code>，再写进去<code>SCTLR Register</code>。</p>
<p>如下图是<code>SCTLR 寄存器</code>：<code>bit13 为 V 位</code>，此位是<code>向量表控制位</code>，当为 0 的时候向量表基地址 为 <code>0X00000000</code>，软件可以重定位向量表。为 1 的时候向量表基地址为<code> 0XFFFF0000</code>，软件不能 重定位向量表。<br>这里将 V 清零，目的就是为了接下来的向量表重定位。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/9.png" alt="image"><br>最后将<code>_start</code>给到<code>r0, r0写入到 CP15 的 c12 寄存器中</code>，也就是<code>VBAR</code>寄存器，完成中断向量表偏移的设定。<br>中断向量表的初始定义在<code>_start</code>入口位置，<code>0x87800000 </code>就是向量表的起始地址。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/10.png" alt="image"></p>
<h3><span id="1-2-3-cp15-pei-zhi-guan-mmu-icache">1.2.3 cp15配置，关<code>MMU，ICACHE</code></span><a href="#1-2-3-cp15-pei-zhi-guan-mmu-icache" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/11.png" alt="image"><br><code>bl cpu_init_cp15</code>一看就是初始化协处理器寄存器<code>CP15</code>, 比如关闭<code>MMU, ICACHE</code>等。<code>cpu_init_cp15</code>函数如下：都是一些<code>CP15</code>协寄存器操作指令，就不再一一解释。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/12.png" alt="image"><br><strong>总结</strong>：<code>save_boot_params_ret</code>做的事情：<br>    ①初始化中断向量表<br>    ②关<code>FIQ,IRQ</code><br>    ③进入<code>SVC</code>模式<br>    ④设置中断向量表偏移<code>VBAR</code><br>    ⑤初始化<code>CP15</code>,关<code>MMU,ICACHE</code>等。</p>
<h2><span id="1-3-lowlevel-init-dui-sram-nei-cun-bu-ju">1.3 lowlevel_init对sram内存布局</span><a href="#1-3-lowlevel-init-dui-sram-nei-cun-bu-ju" class="header-anchor">#</a></h2><p>初始化<code>CP15</code>,关<code>MMU,ICACHE</code>后，会继续执行进入<code>cpu_init_crit</code>：<code>cpu_init_crit</code>也是直接跳到<code>lowlevel_init</code>函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/13.png" alt="image"><br><code>lowlevel_init </code>在文件<code>arch/arm/cpu/armv7/lowlevel_init.S</code>中定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/14.png" alt="image"><br>前面2行定义<code>sp </code>指向 <code>CONFIG_SYS_INIT_SP_ADDR</code>设置<code>SP</code>指针，<code>CONFIG_SYS_INIT_SP_ADDR </code>在 <code>include/configs/mx6ullevk.h</code><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/15.png" alt="image"><br><code>IRAM_BASE_ADDR </code>和<code>IRAM_SIZE</code>在 文 件<code>arch/arm/include/asm/arch-mx6/imx-regs.h</code>中有定义，imx6ull这颗芯片内部有一个sram叫做<code>ocram</code>,基地址就是<code>0x00900000</code>，size为<code>128k(0x20000)</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/16.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/17.png" alt="image"><br>再来看<code>GENERATED_GBL_DATA_SIZE</code>的值：该定义是编译生成的<code>include/generated/generic-asm-offsets.h</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/18.png" alt="image"><br>这里提一句，<code>GENERATED_GBL_DATA_SIZE </code>的含义为<code> (sizeof(struct global_data) + 15) &amp; ~15</code>，该结构体后面会讲到。<br>综上所述，<code>CONFIG_SYS_INIT_SP_ADDR </code>值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_SYS_INIT_SP_OFFSET = <span class="number">0x00020000</span> – <span class="number">256</span> = <span class="number">0x1FF00</span></span><br><span class="line">CONFIG_SYS_INIT_SP_ADDR = <span class="number">0x00900000</span> + <span class="number">0X1FF00</span> = <span class="number">0X0091FF00</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/19.png" alt="image"><br>从图可知：<br>内部<code>sram</code>的地址范围：<code>0x00900000~0x0091ffff (128k)</code><br><code>SP</code>指向：<code>0x0091ff00</code><br>继续分析汇编代码，<code>sp</code>又继续减了一个<code>GD_SIZE</code>,然后8字节对齐，赋值给<code>r9</code>。<br><code>GD_SIZE</code> 同样在 <code>generic-asm-offsets.h </code>中定义了，大小为 248。最后<code>SP</code>指针位置就定义好了，将<code>ip,lr</code>入栈，进入函数<code>s_init</code>函数，<code>s_init</code>函数返回后，<code>ip和lr</code>出栈，并将<code>lr赋给pc</code>。最终内存指向如下：<code>SP指向：0x0091fe08</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/20.png" alt="image"><br>总结：<code>lowlevel_init</code>函数就是在内部<code>sram下设置SP</code>指针，来为c语言的运行配置环境。</p>
<h2><span id="1-4-s-init-han-shu">1.4 s_init函数</span><a href="#1-4-s-init-han-shu" class="header-anchor">#</a></h2><p><code>s_init </code>函数定义在文件<code> arch/arm/cpu/armv7/mx6/soc.c</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/21.png" alt="image"><br>由于我们的<code>cpu是mx6ull</code>,那么满足最开始的<code>if</code>判断，那么<code>s_init</code>函数直接返回，什么也没做。<br>总结<code>_reset</code>过程:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s_init返回了，lowlevel_init也返回了，cpu_init_crit也返回了，回到 save_boot_params_ret。</span><br></pre></td></tr></table></figure>
<p>总结下整个系统上电的reset过程：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/22.png" alt="image"></p>
<h1><span id="2-main-han-shu">2 <code>_main</code>函数</span><a href="#2-main-han-shu" class="header-anchor">#</a></h1><p><code>_main </code>函数定义在文件<code>arch/arm/lib/crt0.S</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/23.png" alt="image"></p>
<h2><span id="2-1-sram-zhong-zhi-ding-sp">2.1 sram中指定SP</span><a href="#2-1-sram-zhong-zhi-ding-sp" class="header-anchor">#</a></h2><p>如注释写的，第<code>76行</code>，初始化c语言运行环境，<code>SP设置到CONFIG_SYS_INIT_SP_ADDR，也就是0x0091ff00</code>。第<code>83行</code>，8字节对齐。</p>
<h2><span id="2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen">2.2 board_init_f_alloc_reserve（指定<code>malloc/gd</code>指针）</span><a href="#2-2-board-init-f-alloc-reserve-zhi-ding-malloc-gd-zhi-zhen" class="header-anchor">#</a></h2><p>第<code> 86 行</code>，调用数<code> board_init_f_alloc_reserve，r0</code>作为形参传给该函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/24.png" alt="image"><br>该函数主要是留出早期的<code>malloc</code>内存区域和 <code>gd </code>内存区域，其中<code>CONFIG_SYS_MALLOC_F_LEN=0X400</code>( 在 文 件 <code>include/generated/autoconf.h </code>中定义， <code>CONFIG_SYS_MALLOC_F</code>也同样定义成1) ，<code> sizeof(struct global_data)=248</code>(<code>GD_SIZE </code>值)。<code>rounddown</code>是一个向下对齐的函数。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/25.png" alt="image"><br>因此最终的内存分布如下图：最终<code>top=0X0091FA00</code>。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/26.png" alt="image"><br>回到<code>87行</code>，<code>r0</code>存储了函数的返回值，进入<code>89行</code>，把<code>top的值继续存到r9</code>。记住<code>r9</code>寄存器，对uboot很重要，它是记录了全局变量<code>gd</code>的地址。<br>在文件<code>arch/arm/include/asm/global_data.h</code>中有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/27.png" alt="image"><br>可以看到<code>gd</code>是一个全局的指针变量，<code>gd_t</code>结构体类型，在<code>include/asm-generic/global_data.h</code>里面有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/28.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/29.png" alt="image"></p>
<h2><span id="2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0">2.3 <code>board_init_f_init_reserve</code>（<code>初始化gd，gd内存清0</code>）</span><a href="#2-3-board-init-f-init-reserve-chu-shi-hua-gd-gd-nei-cun-qing-0" class="header-anchor">#</a></h2><p>回到<code>_main</code>函数继续执行<code>board_init_f_init_reserve</code>，在文件<code>common/init/board_init.c</code>中有定义：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/30.png" alt="image"><br>此函数用于初始化<code> gd</code>，其实就是清零处理。再设置了 <code>gd-&gt;malloc_base</code> 为<code> gd 基地址+gd 大小=0X0091FA00+248=0X0091FAF8</code>，在做 16 字节对齐，最 终<code> gd-&gt;malloc_base=0X0091FB00</code>，这个也就是<code>early malloc</code>的起始地址。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/31.png" alt="image"></p>
<h2><span id="2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen">2.4 board_init_f(外设初始化和DRAM划分)</span><a href="#2-4-board-init-f-wai-she-chu-shi-hua-he-dram-hua-fen" class="header-anchor">#</a></h2><p>此函数定义在文件<code> common/board_f.c</code>，该函数非常重要，主要功能如下：<br>①、初始化一系列外设，比如串口、定时器，或者打印一些消息等。<br>②、初始化 <code>gd </code>的各个成员变量，uboot 会将自己重定位到 DRAM 最后面的地址区域，也就是将自己拷贝到 DRAM 最后面的内存区域中。这么做的目的是给 Linux 腾出空间，防止 Linux kernel 覆盖掉 uboot，将 DRAM 前面的区域完整的空出来。在拷贝之前肯定要给 uboot 各部分 分配好内存位置和大小，比如<code> gd</code> 应该存放到哪个位置，malloc 内存池应该存放到哪个位置等等。这些信息都保存在<code>gd</code>的成员变量中，因此要对<code>gd</code>的这些成员变量做初始化。最终形成一个完整的内存“分配图”，在后面重定位 uboot 的时候就会用到这个内存“分配图”。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/32.png" alt="image"><br>所有外设模块初始化详见<code>initcall_run_list</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/33.png" alt="image"><br><code>init_sequence_f </code>也是定义在文件<code>common/board_f.c</code>中，<code>init_sequence_f </code>的内容比较长，简要概括如下：实际list里面函数更多。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/34.png" alt="image"></p>
<ol>
<li><code>setup_mon_len </code>函数设置 <code>gd </code>的<code> mon_len</code> 成员变量，此处为<code>__bss_end -_start</code>，也就 是整个代码的长度。<code>0X878A8E74-0x87800000=0XA8E74</code>，这个就是代码长度。</li>
<li><code>initf_malloc </code>函数初始化<code>gd</code>中跟 malloc 有关的成员变量，比如 <code>malloc_limit</code>，此函 数会设置 <code>gd-&gt;malloc_limit = CONFIG_SYS_MALLOC_F_LEN=0X400</code>。<code>malloc_limit </code>表示 malloc 内存池大小。</li>
<li><code>initf_console_record</code> ，如果定义了宏<code>CONFIG_CONSOLE_RECORD</code>和 宏 <code>CONFIG_SYS_MALLOC_F_LEN </code>的话此函数就会调用函数 <code>console_record_init</code>，但是 IMX6ULL 的 uboot 没有定义宏<code> CONFIG_CONSOLE_RECORD</code>，所以此函数直接返回 0。</li>
<li><code>arch_cpu_init</code></li>
<li><code>initf_dm </code>函数，驱动模型的一些初始化。</li>
<li><code>arch_cpu_init_dm </code>函数未实现</li>
<li><code>board_early_init_f </code>函数，板子相关的早期的一些初始化设置，I.MX6ULL 用来初始 化串口的 IOMUX 配置</li>
<li><code>timer_init</code>，初始化定时器</li>
<li><code>board_postclk_init</code>，对于 I.MX6ULL 来说是设置 VDDSOC 电压</li>
<li><code>env_init </code>函数是和环境变量有关的，设置<code>gd</code>的成员变量 env_addr&#96;，也就是环境变量的保存地址。</li>
<li><code>init_baud_rate </code>函数用于初始化波特率，根据环境变量<code>baudrate</code>来初始化 <code>gd-&gt;baudrate</code>。</li>
<li><code>serial_init</code>，初始化串口。</li>
<li><code>console_init_f</code>初始化控制台。</li>
<li><code>display_options</code>，通过串口输出一些信息：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/35.png" alt="image"></li>
<li><code>display_text_info</code>，打印一些文本信息，如果开启 UBOOT 的 <code>DEBUG </code>功能的话就 会输出<code> text_base、bss_start、bss_end</code>，形式如下：<br><code>debug(&quot;U-Boot code: %08lX -&gt; %08lX BSS: -&gt; %08lX\n&quot;,text_base, bss_start, bss_end)；</code><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/36.png" alt="image"></li>
<li><code>print_cpuinfo </code>函数用于打印 CPU 信息。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/37.png" alt="image"></li>
<li><code>show_board_info </code>函数用于打印板子信息。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/38.png" alt="image"></li>
<li><code>INIT_FUNC_WATCHDOG_INIT, INIT_FUNC_WATCHDOG_RESET</code>表示初始化，复位看门狗。对于 I.MX6ULL 来说是空函数。</li>
<li><code>init_func_i2c </code>函数用于初始化 I2C。<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/39.png" alt="image"></li>
<li><code>announce_dram_init,dram_init</code>初始化DDR,其实只是设置<code>gd-&gt;ram_size</code>,I.MX6ULL 开发板 EMMC 版本核心板来说就是 512MB。</li>
<li><code>post_init_f</code>，此函数用来完成一些测试，初始化<code> gd-&gt;post_init_f_time</code>。</li>
<li><code>setup_dest_addr</code>,设置目的地址。主要设置<code>gd-&gt;ram_size，gd-&gt;ram_top，gd-&gt;relocaddr </code>这三个的值。修改 uboot 代码，直接将这些值通过串口打印出来，比如这里我们修改文件<code>common/board_f.c的setup_dest_addr</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/40.png" alt="image"><br>烧录运行打印出来如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/41.png" alt="image"><br>可以看出：<br><code>gd-&gt;ram_size = 0X20000000 //ram 大小为 0X20000000=512MB</code><br><code>gd-&gt;ram_top = 0XA0000000 //ram 最高地址为 0X80000000+0X20000000=0XA0000000</code><br><code>gd-&gt;relocaddr = 0XA0000000 //重定位后最高地址为 0XA0000000</code></li>
<li><code>reserve_round_4k</code>， 对 <code>gd-&gt;relocaddr </code>做 4KB 对齐，因为<code> gd-&gt;relocaddr=0XA0000000</code>，已经是 4K 对齐了，所以调整后不变。</li>
<li><code>reserve_mmu</code>，留出 MMU 的 TLB 表的位置，分配 MMU 的 TLB 表内存以后会 对<code>gd-&gt;relocaddr</code>做 64K 字节对齐。完成以后 <code>gd-&gt;arch.tlb_size、gd-&gt;arch.tlb_addr 和 gd-&gt;relocaddr</code>如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/42.png" alt="image"><br>可以看出：<br><code>gd-&gt;arch.tlb_size= 0X4000 //MMU 的 TLB 表大小</code><br><code>gd-&gt;arch.tlb_addr=0X9FFF0000 //MMU 的 TLB 表起始地址，64KB 对齐以后</code><br><code>gd-&gt;relocaddr=0X9FFF0000 //relocaddr 地址</code></li>
<li><code>reserve_trace </code>函数，留出跟踪调试的内存。</li>
<li><code>reserve_uboot</code>，留出重定位后的 uboot 所占用的内存区域，uboot 所占用大小由<code>gd-&gt;mon_len</code>所指定，留出 uboot 的空间以后还要对<code>gd-&gt;relocaddr</code>做 4K 字节对齐，并且重新设 置 <code>gd-&gt;start_addr_sp</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/43.png" alt="image"><br>可以看出, <code>relocaddr</code>一直再减：<br><code>gd-&gt;mon_len = 0XA8EF4</code><br><code>gd-&gt;start_addr_sp = 0X9FF47000//0X9FFF0000 -0XA8EF4=9FF4710C,4k再对齐一下就是0X9FF47000</code><br><code>gd-&gt;relocaddr = 0X9FF47000</code></li>
<li><code>reserve_malloc</code>，留出 malloc 区域，调整 <code>gd-&gt;start_addr_sp </code>位置。malloc 区域由宏<code>TOTAL_MALLOC_LEN</code>定义：<br><code>#define TOTAL_MALLOC_LEN (CONFIG_SYS_MALLOC_LEN + CONFIG_ENV_SIZE)</code><br><code>mx6ull_alientek_emmc.h </code>文件中定义宏 <code>CONFIG_SYS_MALLOC_LEN 为16MB=0X1000000</code>， 宏 <code>CONFIG_ENV_SIZE=8KB=0X2000</code>，因此 <code>TOTAL_MALLOC_LEN=0X1002000</code>。调整以后<code>gd-&gt;start_addr_sp</code>如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/44.png" alt="image"><br>可以看出：<br><code>TOTAL_MALLOC_LEN=0X1002000</code><br><code>gd-&gt;start_addr_sp=0X9EF45000 //0X9FF47000-16MB-8KB=0X9EF45000</code></li>
<li><code>reserve_board</code>， 预留<code>bd 内存</code>，<code>bd </code>是结构体<code> bd_t，bd_t 大小为 80 字节</code>:<br><code>gd-&gt;start_addr_sp=0X9EF44FB0//0X9EF45000 -80</code><br><code>gd-&gt;bd=0X9EF44FB0</code></li>
<li><code>setup_machine</code>，设置机器 ID，linux 启动的时候会和这个机器 ID 匹配，如果匹 配的话 linux 就会启动正常。以前老版本的 uboot 和 linux 使用的，新版本使用设备树了，因此此函数无效。</li>
<li><code>reserve_global_data</code>，保留出<code> gd</code>，<code>gd_t 结构体大小为 248B</code>：<br><code>gd-&gt;start_addr_sp=0X9EF44EB8 //0X9EF44FB0-248=0X9EF44EB8</code><br><code>gd-&gt;new_gd=0X9EF44EB8</code></li>
<li><code>reserve_fdt</code>，留出设备树相关的内存。</li>
<li><code>reserve_arch </code>是个空函数。</li>
<li><code>reserve_stacks</code>，留出栈空间，先对 <code>gd-&gt;start_addr_sp </code>减去 16，然后做 16 字节对齐。如果使能 IRQ 的话还要留出 IRQ 相应的内存，具体工作是由<code>arch/arm/lib/stack.c </code>文件中的 函数<code>arch_reserve_stacks</code>完成。这里uboot启动没有enable IRQ,因此不会留出 IRQ 相应的内存：<br><code>gd-&gt;start_addr_sp=0X9EF44E90</code></li>
<li><code>setup_dram_config</code>，设置 <code>dram bank</code>信息,后面会传递给 linux 内核，告诉 linux DRAM 的起始地址和大小:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/45.png" alt="image"></li>
<li><code>show_dram_config</code>，打印<code>dram</code>信息:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/46.png" alt="image"></li>
<li><code>display_new_sp</code>，显示新的<code>sp</code>位置，也就是<code> gd-&gt;start_addr_sp</code>，要开启宏 <code>DEBUG</code>才能看到:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/47.png" alt="image"></li>
<li><code>reloc_fdt</code>，数用于重定位<code> fdt</code>，没有用到。</li>
<li><code>setup_reloc</code>，设置 <code>gd </code>的其他一些成员变量，供后面重定位的时候使用，并且将以 前的 <code>gd </code>拷贝到 <code>gd-&gt;new_gd </code>处。需要使能 <code>DEBUG </code>才能看到相应的信息输出:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/48.png" alt="image"><br>可以看出，uboot 重定位后的偏移为<code> 0X18747000</code>，重定位后的新地址为<code> 0X9FF4700</code>，新的<code> gd</code> 首地址为 <code>0X9EF44EB8</code>，最终的<code>sp</code>为<code> 0X9EF44E90</code>。<br>至此，<code>board_init_f </code>函数就执行完成了，最终的内存分配如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/49.png" alt="image"></li>
</ol>
<h2><span id="2-5-relocate-code-dai-ma-chong-ding-wei">2.5 relocate_code(代码重定位)</span><a href="#2-5-relocate-code-dai-ma-chong-ding-wei" class="header-anchor">#</a></h2><p>既然dram划分好了，那么就开始需要对代码重定位了。</p>
<h3><span id="2-5-1-chong-ding-wei-hou-de-lr-she-zhi">2.5.1 重定位后的LR设置</span><a href="#2-5-1-chong-ding-wei-hou-de-lr-she-zhi" class="header-anchor">#</a></h3><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/50.png" alt="image"><br>回到<code>_main</code>第 103 行，获取<code>gd-&gt;start_addr_sp</code>的值赋给<code> sp</code>， <code>board_init_f</code> 中会初始化<code>gd</code>的所有成员进行内存预留，其中<br><code>gd-&gt;start_addr_sp=0X9EF44E90</code><br>所以这里<code>sp=0X9EF44E90</code>。<br>第 109 行，<code>sp</code> 做 8 字节对齐。<br>第 111 行，获取<code>gd-&gt;bd</code>的地址赋给 <code>r9</code>，之前<code>r9</code>存放的是老的<code> gd</code>，<code>GD_BD=0</code>来自<code>include\generated\generic-asm-offsets.h</code>，<code>bd</code>就是<code>gd</code>结构体的首个成员，因此<code>offset是0</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/51.png" alt="image"><br>那么新<code>gd</code>地址（<code>board_init_f</code>时确定了<code>gd-&gt;bd</code>的地址为<code>0X9EF44FB0</code>)也是它。<br>第 112 行，<code>r9</code>再减一个<code>GD_SIZE</code>,得到<code>gd-&gt;new_gd</code>,也就是<code>0X9EF44EB8</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/52.png" alt="image"><br><strong>重点来了：</strong><br>第 114 行，设置<code>lr</code>寄存器为<code> here</code>，这样后面执行其他函数返回的时候就返回到了第 122 行 的<code>here</code>位置处(比如执行完<code>relocate_code</code>就直接返回到<code>here</code>)。<br>后面第115行~116行用来让lr指向重定位后的<code>here</code>位置。<br>第 115，读取<code>gd-&gt;reloc_off</code>的值复制给<code>r0</code>寄存器，<code>GD_RELOC_OFF=64</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/53.png" alt="image"><br>第 116 行，lr 寄存器的值加上<code>r0</code>寄存器的值，重新赋值给<code>lr</code>寄存器。 此时<code>lr </code>就存放了重定位后的<code>here</code>位置，因为重定位完就去重定位后的DDR去执行了，无需返回sram了。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/12038514.html">s3c2440裸机-代码重定位(1.重定位的引入,为什么要代码重定位) - fuzidage - 博客园 (cnblogs.com)</a><br><a href="https://www.cnblogs.com/fuzidage/p/12043586.html">s3c2440裸机-代码重定位（2.编程实现代码重定位） - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss | Hexo (fuzidage.github.io)</a></p>
<p>关键词：<strong>位置无关码、相对跳转指令，相对寻址</strong></p>
<p>第 120 行，读取<code>gd-&gt;relocaddr</code>的值赋给 <code>r0 </code>寄存器，此时<code>r0</code>寄存器就保存着 uboot 要拷贝的目的地址，我们打印出来为<code>0X9FF47000</code>。<code>r0</code>作为形参给<code>relocate_code</code>函数。</p>
<h3><span id="2-5-2-dai-ma-duan-chong-ding-wei">2.5.2 代码段重定位</span><a href="#2-5-2-dai-ma-duan-chong-ding-wei" class="header-anchor">#</a></h3><p>重定位的具体实现在<code>arch/arm/lib/relocate.S</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/54.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/55.png" alt="image"></p>
<ol>
<li>80-83行是设置重定位<code>r4</code>偏移量，源拷贝地址，判断是否要拷贝。<code>u-boot.map</code>获取符号的地址：</li>
</ol>
<table>
<thead>
<tr>
<th><code>__image_copy_start</code></th>
<th>0x87800000</th>
<th>uboot拷贝的首地址</th>
</tr>
</thead>
<tbody><tr>
<td><code>__image_copy_end</code></td>
<td>0x8785dd54</td>
<td>uboot拷贝的结束地址</td>
</tr>
</tbody></table>
<p>如果<code>r4等于0</code>（也就是目标地址<code>r0</code>就是<code>uboot.map</code>中的地址），那么无需拷贝，跳转到<code>relocate_done</code>即可。<br>2. 85-89是循环拷贝，多寄存器加载存储指令<code>LDMIA，STMIA</code>。</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17703733.html">arm汇编和cpu运行模式 - fuzidage - 博客园 (cnblogs.com)</a><br><a href="https://fuzidage.github.io/tags/arm%E6%B1%87%E7%BC%96/">Tag: arm汇编 | Hexo (fuzidage.github.io)</a> </p>
<p>88行判断是否拷贝结束，<code>r1</code>会每次加4，当<code>r1</code>等于<code>r2</code>表示拷贝完成了，否则继续执行<code>copy_loop</code>。</p>
<h3><span id="2-5-3-rel-dyn-duan-chong-ding-wei">2.5.3 <code>rel.dyn</code>段重定位</span><a href="#2-5-3-rel-dyn-duan-chong-ding-wei" class="header-anchor">#</a></h3><p>编译uboot使用<code>-pie选项</code>以后会生成一个<code>.rel.dyn 段</code>，需要对这个段进行重定位和拷贝：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/56.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">94-97行，从.rel.dyn 段开始，每次读取两个 4 字节的数据存放到 r0 和 r1 寄存器中，r0 存放低 4 字节的数据，也就是 Label 地址；r1 存放高 4 字节的数据，也就是 Label 标志。</span><br><span class="line">第 98 行，取 r1 的低 8 位。</span><br><span class="line">第 99 行，判断 r1 中的值是否等于 23(0X17)。</span><br><span class="line">第 100 行，如果 r1 不等于 23 的话就说明不是描述 Label 的，执行函数 fixnext，否则的话继续执行下面的代码。</span><br><span class="line">103-104行，r0 保存着 Label 值，r4 保存着重定位的偏移量，r0+r4 就得到了重定位后的Label 值。</span><br><span class="line">105-106行，重定位后的变量地址写入到重定位后的 Label 中。</span><br><span class="line">第 108 行，比较 r2 和 r3，查看.rel.dyn 段重定位是否完成。</span><br><span class="line">第 109 行，如果 r2 和 r3 不相等，说明.rel.dyn 重定位还未完成，因此跳到 fixloop 继续重定位.rel.dyn 段。</span><br></pre></td></tr></table></figure>

<h2><span id="2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei">2.6 relocate_vectors(向量表重定位)</span><a href="#2-6-relocate-vectors-xiang-liang-biao-chong-ding-wei" class="header-anchor">#</a></h2><p><code>relocate.S </code>中同时也定义了中断向量表的重定位:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/57.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">第 <span class="number">29</span> 行，如果定义了 CONFIG_CPU_V7M 的话就执行第 <span class="number">30</span>~<span class="number">36</span> 行的代码，对于 I.MX6ULL 来说不是ARMv7-M,不执行。</span><br><span class="line">由于在.config 里面定义了 CONFIG_HAS_VBAR，因此执行下面的代码。</span><br><span class="line"><span class="number">43</span> 行，r0=gd-&gt;relocaddr，重定位后 uboot 的首地址，也就是向量表地址，因为异常向量表就在uboot代码段最开始的地方。</span><br><span class="line"><span class="number">44</span>行，CP15 的 VBAR寄存器写入r0。这样重定位后的向量表就设置好了。</span><br></pre></td></tr></table></figure>

<h2><span id="2-7-board-init-r">2.7 board_init_r</span><a href="#2-7-board-init-r" class="header-anchor">#</a></h2><h3><span id="2-7-1-wai-she-chu-shi-hua">2.7.1 外设初始化</span><a href="#2-7-1-wai-she-chu-shi-hua" class="header-anchor">#</a></h3><p>前面<code>board_init_f</code>初始化了芯片级外设（<code>uart,Timer,console</code>等）并且进行了DRAM划分，为代码重定位做准备。接下来<code>board_init_r</code>进行板级的外设初始化。<br><code>init_sequence_r </code>定义在文件<code> common/board_r.c</code>，负责初始化各个硬件外设，比如<code>flash,网卡，i2c，sdio</code>等等：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/58.png" alt="image"></p>
<p><strong><code>initr_trace</code></strong> 函数，如果定义了宏<code>CONFIG_TRACE</code>的话就会调用函数<code> trace_init</code>， 初始化和调试跟踪有关的内容。<br><strong><code>initr_reloc</code></strong> 函数用于设置<code> gd-&gt;flags</code>，标记重定位完成。<br><strong><code>initr_caches</code></strong> 函数用于初始化 cache，使能 cache。<br><strong><code>initr_reloc_global_data</code></strong> 函数，初始化重定位后<code>gd</code>的一些成员变量。<br><strong><code>initr_barrier</code></strong> 函数，I.MX6ULL 未用到。<br><strong><code>initr_malloc</code></strong> 函数，初始化 malloc。<br><strong><code>initr_console_record</code></strong> 函数，初始化控制台相关的内容，I.MX6ULL 未用到，空函数。<br><strong><code>bootstage_relocate</code></strong> 函数，启动状态重定位。<br><strong><code>initr_bootstage</code></strong> 函数，初始化<code>bootstage</code>什么的。<br><strong><code>board_init</code></strong> 函数，板级初始化，包括<code>FEC、USB 和 QSPI </code>等。 这里执行的是 <code>mx6ull_alientek_emmc.c </code>文件中的 <code>board_init </code>函数。<br><strong><code>stdio_init_tables</code></strong> 函数，<code>stdio </code>相关初始化。<br><strong><code>initr_serial</code></strong> 函数，初始化串口。<br><strong><code>power_init_board</code></strong> 函数，初始化电源芯片，正点原子的 I.MX6ULL 开发板没有用到。<br><strong><code>initr_flash</code></strong> 函数，对于 I.MX6ULL 而言，没有定义宏 <code>CONFIG_SYS_NO_FLASH </code>的话函数<code>initr_flash</code>才有效。但是 <code>mx6_common.h </code>中定义了宏 <code>CONFIG_SYS_NO_FLASH</code>，所以 此函数无效。<br><strong><code>initr_nand</code></strong> 函数，初始化 NAND，如果使用 NAND 版本核心板的话就会初始化 NAND。<br><strong><code>initr_mmc</code></strong> 函数，初始化 EMMC，如果使用 EMMC 版本核心板的话就会初始化 EMMC：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/59.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/60.png" alt="image"><br><strong><code>initr_env</code></strong> 函数，初始化环境变量。<br><strong><code>initr_secondary_cpu</code></strong> 函数，初始化其他 CPU 核，I.MX6ULL 只有一个核，因此此函数没用。<br><strong><code>stdio_add_devices</code></strong> 函数，各种输入输出设备的初始化，如 LCD driver，I.MX6ULL 使用 <code>drv_video_init </code>函数初始化 LCD：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/61.png" alt="image"><br><strong><code>initr_jumptable</code></strong> 函数，初始化跳转表。<br><strong><code>console_init_r</code></strong> 函数 ， 控制台初始化， 初始化完成以后此函数会调用<code>stdio_print_current_devices</code>函数来打印出当前的控制台设备：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/62.png" alt="image"><br><strong><code>interrupt_init</code></strong> 函数，初始化中断。<br><strong><code>initr_enable_interrupts</code></strong> 函数，使能中断。<br><strong><code>initr_ethaddr</code></strong> 函数，初始化网络地址，也就是获取 MAC 地址。读取环境变量 <code>ethaddr</code>的值。<br><strong><code>board_late_init</code></strong> 函数，板子后续初始化，此函数定义在文件<code>mx6ull_alientek_emmc.c</code>中，如果环境变量存储在 EMMC 或者 SD 卡中的话此函数会调用 <code>board_late_mmc_env_init </code>函数 初始化 <code>EMMC/SD</code>。会切换到正在时候用的 emmc 设备，如下图所示：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/63.png" alt="image"><br><code>cmd</code>构造成<code>mmc dev 1</code>,切换到正在使用的 EMMC 设备。因为dev0为sd卡，dev1为emmc：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/64.png" alt="image"><br><strong><code>initr_net</code></strong> 函数，初始化网络设备，调用关系<code>initr_net-&gt;eth_initialize-&gt;board_eth_init()</code>。<br>最后**<code>run_main_loop</code>**，主循环，处理命令。</p>
<h3><span id="2-7-2-run-main-loop-han-shu">2.7.2 run_main_loop 函数</span><a href="#2-7-2-run-main-loop-han-shu" class="header-anchor">#</a></h3><h4><span id="2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi">2.7.2.1 Uboot version环境变量设置</span><a href="#2-7-2-1-uboot-version-huan-jing-bian-liang-she-zhi" class="header-anchor">#</a></h4><p><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/65.png" alt="image"><br>第 48 行，调用 <code>bootstage_mark_name </code>函数，打印出启动进度。<br>第 57 行，如果定义了宏 <code>CONFIG_VERSION_VARIABLE</code>,设置版本号环境变量，<code>cmd/version.c </code>中定义了<code>version_string</code>字符串，<code>version.h</code>定义了<code>U_BOOT_VERSION_STRING</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/66.png" alt="image"><br><code>U_BOOT_VERSION </code>定义在文件<code>include/generated/version_autogenerated.h</code>中：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/67.png" alt="image"><br>比如我的板子uboot命令行输入<code>version</code>打印版本信息：打印uboot版本，编译日期时间，<code>CONFIG_IDENT_STRING</code>为板子<code>identity</code>信息，我这里是<code>cvitek_athena2</code>，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/68.png" alt="image"><br>最后打印出<code>toolchain</code>信息是因为编译生成<code>version_autogenerated.h</code>，输入<code>version</code>命令打印如下<code>do_version</code>函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/69.png" alt="image"><br>Uboot中的命令都是调用<code>cmd_process</code>函数来解析执行。（会面有具体分析<code>cmd_process</code>)</p>
<h4><span id="2-7-2-2-bootdelay-he-bootcmd-huo-qu">2.7.2.2 bootdelay和bootcmd获取</span><a href="#2-7-2-2-bootdelay-he-bootcmd-huo-qu" class="header-anchor">#</a></h4><p>第 60 行，<code>cli_init()</code>，<code>cli</code>是一个命令行接口，一般裸机开发都喜欢移植<code>cli</code>，来注册各种命令参数。<br>第 62 行，<code>run_preboot_environment_command()</code>获取系统环境变量<code>preboot</code>的值，我们没有定义该环境变量。<br>第 68 行,<code>bootdelay_process()</code>设置倒计时全局变量。我的板子<code>bootdelay</code>环境变量是1，<code>.config</code>也配置的1。<br>该函数是获取<code>bootcmd</code>环境变量，返回<code>bootcmd</code>环境变量，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/70.png" alt="image"></p>
<h4><span id="2-7-2-3-autoboot-command-zhi-xing-bootcmd">2.7.2.3 autoboot_command(执行bootcmd)</span><a href="#2-7-2-3-autoboot-command-zhi-xing-bootcmd" class="header-anchor">#</a></h4><p><code>main_loop</code>的第72行，自动执行<code>bootcmd</code>。当然我们在命令行输入<code>run bootcmd</code>也会执行<code>bootcmd</code>里面指令，如下图：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/71.png" alt="image"><br><code>autoboot_command</code>函数定义在<code>common/autoboot.c</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/72.png" alt="image"><br>我这里<code>stored_bootdelay</code>全局变量等于1，<code>s</code>字符串是<code>bootcmd</code>环境变量不为空。最后<code>abortboot</code>函数的返回值也为0，因此执行<code>run_command_list</code>，执行<code>bootcmd</code>里面的命令，启动kernel rootfs。</p>
<h5><span id="2-7-2-3-1-bootdelay-dao-ji-shi">2.7.2.3.1 bootdelay倒计时</span><a href="#2-7-2-3-1-bootdelay-dao-ji-shi" class="header-anchor">#</a></h5><p>分析<code>abortboot()</code>函数：<br><code>abortboot</code>调用<code>abortboot_normal</code>，该函数就是判断<code>bootdelay</code>倒计时内是否有按键按下，倒计时结束没有按键按下，那么执行<code>bootcmd</code>，否则uboot命令行等待用户输入,代码逻辑如下：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/73.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/74.png" alt="image"><br>总结：有按键输入，<code>abortboot()</code>函数返回1，否则返回0, 这样<code>autoboot_command</code>才会执行<code>bootcmd</code>。</p>
<h4><span id="2-7-2-4-cli-loop-uboot-ming-ling-xing">2.7.2.4 cli_loop(uboot命令行)</span><a href="#2-7-2-4-cli-loop-uboot-ming-ling-xing" class="header-anchor">#</a></h4><p>再来回到<code>main_loop</code>，如果倒计时结束有按键按下，<code>abortboot</code>返回1，那么<code>autoboot_command</code>函数什么都不干直接返回，执行<code>cli_loop()</code>：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/75.png" alt="image"><br><code>cli_loop</code> 函数是 uboot 的命令行处理函数，我们在 uboot 中输入各种命令，就是<code>cli_loop </code>来处理的，此函数定义在文件 <code>common/cli.c</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/76.png" alt="image"><br>这里我们有定义<code>CONFIG_SYS_HUSH_PARSER</code>，因此执行<code>parse_file_outer-&gt;parse_stream_outer</code>，<code>common/cli_hush.c</code>定义了该函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/77.png" alt="image"><br>该函数调用<code>parse_stream </code>进行命令解析。然后调用<code>run_list </code>函数来执行解析出来的命令。</p>
<h5><span id="2-7-2-4-1-cmd-process-han-shu-fen-xi">2.7.2.4.1 cmd_process 函数分析</span><a href="#2-7-2-4-1-cmd-process-han-shu-fen-xi" class="header-anchor">#</a></h5><p>当命令行有用户输入命令，并且解析到匹配的uboot命令，执行<code>run_list-&gt;run_list_real-&gt;run_pipe_real-&gt;cmd_process</code>。<br>前面提到Uboot中的命令都是调用<code>cmd_process</code>函数来解析执行，如<code>version</code>命令：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/78.png" alt="image"><br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/79.png" alt="image"><br>①先调用<code>find_cmd</code>，返回<code>cmd_tbl_t</code>指针：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/80.png" alt="image"><br>传入的<code>cmd </code>字符串就是所查找的命令名字，uboot 中的命令表其实就是<code>cmd_tbl_t</code>结构体数组。<br><code>ll_entry_start </code>得到数组的第一个元素，也就是命令表起始地址。通过函数<code>ll_entry_count</code>得到数组长度，也就是命令表的长度。<br><code>find_cmd_tbl</code> 在命令表中找到所需的命令，每个命令都有一个<code> name 成员</code>，如下图根据字符串名字去匹配对应的命令：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/81.png" alt="image"><br>②调用<code>cmd_call</code>，执行<code>cmd_tbl_t </code>结构里面对应的处理函数：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/82.png" alt="image"></p>
<h5><span id="2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li">2.7.2.4.2 uboot命令定义(dhcp为例)</span><a href="#2-7-2-4-2-uboot-ming-ling-ding-yi-dhcp-wei-li" class="header-anchor">#</a></h5><p>uboot 使用宏 <code>U_BOOT_CMD </code>来定义命令，宏<code> U_BOOT_CMD</code> 定义在 <code>include/command.h</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/83.png" alt="image"><br>①**<code>ll_entry_declar</code>**<br>定义在文件<code> include/linker_lists.h</code>:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/84.png" alt="image"><br><code>_type</code> 为<code> cmd_tbl_t</code>，因此<code>ll_entry_declare</code>就是定义了一个<code>cmd_tbl_t</code>变量，这里用到了 C 语 言中的<code>##</code>连接符。其中的<code>##_list</code>表示用<code>_list </code>的值来替换，<code>##_name</code>就是用<code>_name </code>的值来替换。<br>比如<code>dhcp</code>命令代入进去：</p>
<p><code>ll_entry_declare(cmd_tbl_t, dhcp, cmd)展开后</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_#<span class="meta">#cmd##_2_##dhcp __aligned(4)		\</span></span><br><span class="line"><span class="meta">	__attribute__((unused,section(<span class="string">&quot;.u_boot_list_2_cmd_2_dhcp)))</span></span></span><br></pre></td></tr></table></figure>

<p>②**<code>U_BOOT_CMD_MKENT_COMPLETE</code>**<br><code># </code>表示将<code> _name</code> 传 递 过 来 的 值 字 符 串 化。<br>继续以<code>dhcp</code>命令代入：<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/85.png" alt="image"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD_MKENT_COMPLETE(dhcp, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"> <span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"><span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>, \</span><br><span class="line">NULL);</span><br></pre></td></tr></table></figure>
<p>继续代入：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">&quot;dhcp&quot;</span>, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"> <span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"> <span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>,\ </span><br><span class="line"><span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>

<p>最后宏<code> U_BOOT_CMD</code>对<code>dhcp</code>命令展开如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> _u_boot_list_2_cmd_2_dhcp __aligned(<span class="number">4</span>) \</span><br><span class="line">__attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) = \</span><br><span class="line">&#123; <span class="string">&quot;dhcp&quot;</span>, <span class="number">3</span>, <span class="number">1</span>, do_dhcp, \</span><br><span class="line"><span class="string">&quot;boot image via network using DHCP/TFTP protocol&quot;</span>, \</span><br><span class="line"><span class="string">&quot;[loadAddress] [[hostIPaddr:]bootfilename]&quot;</span>,\</span><br><span class="line"><span class="literal">NULL</span> &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到就是定义了一个<code>cmd_tbl_t</code>结构体变量，对它进行初始化。这个变量名为<code>_u_boot_list_2_cmd_2_dhcp</code>，此变量 4 字节对齐。<br>使 用 <code>__attribute__ </code>关 键 字 设 置 变 量<code>_u_boot_list_2_cmd_2_dhcp</code>存 储 在<code>.u_boot_list_2_cmd_2_dhcp </code>段中。<code>u-boot.lds </code>链接脚本中有一个名为<code>.u_boot_list</code>的段专门存放uboot命令表:<br><img src="/2024/06/23/uboot-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/86.png" alt="image"></p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-命令和环境变量</title>
    <url>/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-1-help-huo-zhe">1.1 help或者？</a><ul>
<li><a href="#1-1-1-help-ju-ti-ming-ling">1.1.1 help+具体命令</a></li>
</ul>
</li>
<li><a href="#1-2-xin-xi-cha-xun">1.2 信息查询</a><ul>
<li><a href="#1-2-1-bdinfo">1.2.1 bdinfo</a></li>
<li><a href="#1-2-2-printenv">1.2.2 printenv</a></li>
<li><a href="#1-2-3-version">1.2.3 version</a></li>
</ul>
</li>
<li><a href="#1-3-huan-jing-bian-liang">1.3 环境变量</a><ul>
<li><a href="#1-3-1-setenv-she-ding-huan-jing-bian-liang">1.3.1 setenv设定环境变量</a></li>
<li><a href="#1-3-2-saveenv-bao-cun-huan-jing-bian-liang">1.3.2 saveenv保存环境变量</a></li>
<li><a href="#1-3-3-setenv-shan-chu-huan-jing-bian-liang">1.3.3 setenv删除环境变量</a></li>
<li><a href="#1-3-4-huan-jing-bian-liang-yuan-li">1.3.4 环境变量原理</a><ul>
<li><a href="#1-3-4-1-bootcmd-zhan-kai">1.3.4.1 bootcmd展开</a></li>
<li><a href="#1-3-4-2-bootargs-zhan-kai">1.3.4.2 bootargs展开</a></li>
<li><a href="#1-3-4-3-bootdlelay">1.3.4.3 bootdlelay</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#1-4-nei-cun-cao-zuo">1.4 内存操作</a><ul>
<li><a href="#1-4-1-md">1.4.1 md</a></li>
<li><a href="#1-4-2-nm-ming-ling">1.4.2 nm命令</a></li>
<li><a href="#1-4-3-mm-ming-ling">1.4.3 mm命令</a></li>
<li><a href="#1-4-4-mw-ming-ling">1.4.4 mw命令</a></li>
<li><a href="#1-4-5-cp-ming-ling">1.4.5 cp命令</a></li>
<li><a href="#1-4-6-cmp-ming-ling">1.4.6 cmp命令</a></li>
</ul>
</li>
<li><a href="#1-5-wang-luo-cao-zuo-ming-ling">1.5 网络操作命令</a><ul>
<li><a href="#1-5-1-ping-ming-ling">1.5.1 ping命令</a></li>
<li><a href="#1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu">1.5.2 dhcp命令（自动ip获取）</a></li>
<li><a href="#1-5-3-nfs-ming-ling">1.5.3 nfs命令</a></li>
<li><a href="#1-5-4-tftp-ming-ling">1.5.4 tftp命令</a></li>
</ul>
</li>
<li><a href="#1-6-emmc-he-sd-qia-zhi-ling">1.6 emmc和sd卡指令</a><ul>
<li><a href="#1-6-1-mmc-info">1.6.1 mmc info</a></li>
<li><a href="#1-6-2-mmc-rescan">1.6.2 mmc rescan</a></li>
<li><a href="#1-6-3-mmc-list">1.6.3 mmc list</a></li>
<li><a href="#1-6-4-mmc-dev">1.6.4 mmc dev</a></li>
<li><a href="#1-6-5-mmc-part">1.6.5 mmc part</a></li>
<li><a href="#1-6-6-mmc-read">1.6.6 mmc read</a></li>
<li><a href="#1-6-7-mmc-write">1.6.7 mmc write</a></li>
<li><a href="#1-6-7-mmc-erase">1.6.7 mmc erase</a></li>
</ul>
</li>
<li><a href="#1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong">1.7 文件操作命令（fat文件系统）</a><ul>
<li><a href="#1-7-1-fatinfo">1.7.1 fatinfo</a></li>
<li><a href="#1-7-1-fatls">1.7.1 fatls</a></li>
<li><a href="#1-7-3-fstype">1.7.3 fstype</a></li>
<li><a href="#1-7-4-fatload">1.7.4 fatload</a></li>
<li><a href="#1-7-5-fatwrite">1.7.5 fatwrite</a></li>
</ul>
</li>
<li><a href="#1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong">1.8 文件操作命令（ext文件系统）</a></li>
<li><a href="#1-9-nandflash-cao-zuo-ming-ling">1.9 nandflash操作命令</a><ul>
<li><a href="#1-9-1-nand-info">1.9.1 nand info</a></li>
<li><a href="#1-9-2-nand-device">1.9.2 nand device</a></li>
<li><a href="#1-9-3-nand-erase">1.9.3 nand erase</a></li>
<li><a href="#1-9-3-nand-write">1.9.3 nand write</a></li>
<li><a href="#1-9-4-nand-read">1.9.4 nand read</a></li>
</ul>
</li>
<li><a href="#1-10-she-bei-shu-xiang-guan">1.10 设备树相关</a><ul>
<li><a href="#1-10-1-fdt-addr">1.10.1 fdt addr</a></li>
<li><a href="#1-10-2-fdt-header">1.10.2 fdt header</a></li>
<li><a href="#1-10-3-fdt-print">1.10.3 fdt print</a></li>
</ul>
</li>
<li><a href="#1-11-qi-dong-xiang-guan">1.11 启动相关</a><ul>
<li><a href="#1-11-1-bootz-qi-dong-zimage">1.11.1 bootz (启动zImage)</a></li>
<li><a href="#1-11-1-bootm-qi-dong-uimage">1.11.1 bootm (启动uImage)</a></li>
<li><a href="#1-11-3-boot">1.11.3 boot</a></li>
<li><a href="#1-11-4-go-ming-ling">1.11.4 go命令</a></li>
<li><a href="#1-11-5-run">1.11.5 run</a></li>
</ul>
</li>
<li><a href="#1-12-nei-cun-ce-shi-mtest">1.12 内存测试mtest</a></li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="1-1-help-huo-zhe">1.1 help或者？</span><a href="#1-1-help-huo-zhe" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/1.png" alt="image"></p>
<h3><span id="1-1-1-help-ju-ti-ming-ling">1.1.1 help+具体命令</span><a href="#1-1-1-help-ju-ti-ming-ling" class="header-anchor">#</a></h3><p><code>? bootz 或 help bootz</code><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/2.png" alt="image"></p>
<h2><span id="1-2-xin-xi-cha-xun">1.2 信息查询</span><a href="#1-2-xin-xi-cha-xun" class="header-anchor">#</a></h2><h3><span id="1-2-1-bdinfo">1.2.1 bdinfo</span><a href="#1-2-1-bdinfo" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/3.png" alt="image"></p>
<h3><span id="1-2-2-printenv">1.2.2 printenv</span><a href="#1-2-2-printenv" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/4.png" alt="image"><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/5.png" alt="image"><br>前确保 uboot 中的环境变量 bootargs 内容如下:<br><code>console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/zImage /home/zuozhongkai/linux/tftpboot/ -f</span><br><span class="line"><span class="built_in">cp</span> <span class="built_in">arch</span>/arm/boot/dts/imx6ull-14x14-evk.dtb /home/zuozhongkai/linux/tftpboot/ -f</span><br><span class="line">tftp 80800000 zImage </span><br><span class="line">tftp 83000000 imx6ull-14x14-evk.dtb</span><br><span class="line">bootz 80800000 - 83000000</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-3-version">1.2.3 version</span><a href="#1-2-3-version" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/6.png" alt="image"></p>
<h2><span id="1-3-huan-jing-bian-liang">1.3 环境变量</span><a href="#1-3-huan-jing-bian-liang" class="header-anchor">#</a></h2><h3><span id="1-3-1-setenv-she-ding-huan-jing-bian-liang">1.3.1 setenv设定环境变量</span><a href="#1-3-1-setenv-she-ding-huan-jing-bian-liang" class="header-anchor">#</a></h3><p>设置<code>bootdelay</code>时间为5s.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv bootdelay 5</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/7.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv author zuozhongkai</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>新建环境变量也是用setenv。</p>
<h3><span id="1-3-2-saveenv-bao-cun-huan-jing-bian-liang">1.3.2 saveenv保存环境变量</span><a href="#1-3-2-saveenv-bao-cun-huan-jing-bian-liang" class="header-anchor">#</a></h3><h3><span id="1-3-3-setenv-shan-chu-huan-jing-bian-liang">1.3.3 setenv删除环境变量</span><a href="#1-3-3-setenv-shan-chu-huan-jing-bian-liang" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setenv author</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>设置变量为空表示删除掉该环境变量，重启该环境变量就不会存在了。</p>
<h3><span id="1-3-4-huan-jing-bian-liang-yuan-li">1.3.4 环境变量原理</span><a href="#1-3-4-huan-jing-bian-liang-yuan-li" class="header-anchor">#</a></h3><p><code>include/env_default.h</code>定义了很多环境变量，如<code>bootargs,bootdelay,bootcmd等</code>：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/8.png" alt="image"><br>由 于 没 有 定 义<code>DEFAULT_ENV_INSTANCE_EMBEDDED和CONFIG_SYS_REDUNDAND_ENVIRONMENT</code>，因此 <code>uchar default_environment[]</code>数组保存环境变量。</p>
<h4><span id="1-3-4-1-bootcmd-zhan-kai">1.3.4.1 bootcmd展开</span><a href="#1-3-4-1-bootcmd-zhan-kai" class="header-anchor">#</a></h4><p>如<code>CONFIG_BOOTCOMMAND</code>等一系列宏都是定义在<code>include/configs/mx6ull_alientek_emmc.h</code>:<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/9.png" alt="image"><br> uboot 使用了类似 shell 脚本语言的方式来编写的,首先<code>run findfdt</code>， findfdt 是用来查找开发板对应的设备树文件(.dtb)，IMX6ULL EVK 的设备树文件为<code>imx6ull-14x14-evk.dtb，findfdt</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;findfdt=&quot;</span>\</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 9X9; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-9x9-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $board_name = EVK &amp;&amp; test $board_rev = 14X14; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;setenv fdt_file imx6ull-14x14-evk.dtb; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;if test $fdt_file = undefined; then &quot;</span> \</span><br><span class="line"><span class="string">&quot;echo WARNING: Could not determine dtb to use; fi; &quot;</span> \</span><br><span class="line"><span class="string">&quot;fi;\0&quot;</span> \</span><br></pre></td></tr></table></figure>

<p>那么<code>run findfdt</code>就等同于执行<code>setenv fdt_file imx6ull-14x14-evk.dtb</code>。设置fdt_file环境变量等于imx6ull-14x14-evk.dtb。<br><code>mmc dev $&#123;mmcdev&#125;</code>用于切换 mmc 设备，mmcdev 为 1，因此这行代码就是：mmc dev 1，也就是切换到 EMMC 上。<br>先执行<code> mmc dev $&#123;mmcdev&#125;</code>切换到 EMMC 上，然后使用命令<code> mmc rescan</code> 扫描看有没有 SD 卡或者 EMMC 存在，如果没有的话就直接跳到else，执行<code> run netboot</code>，netboot也是一个自定义的环境变量，这个变量是从网络启动 Linux 的。<br>扫描到EMMC后，<code>run loadbootscript</code>：<br>    <code>loadbootscript=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;script&#125;;</code><br>其中 mmcdev&#x3D;1，mmcpart&#x3D;1，loadaddr&#x3D;0x80800000，script&#x3D; boot.scr，因此展开以后就是：<br>    <code>loadbootscript=fatload mmc 1:1 0x80800000 boot.scr;</code><br>loadbootscript 就是从 mmc1 的分区 1 中读取文件 boot.src 到 DRAM 的 0X80800000 处。但是 mmc1 的分区 1 中没有 boot.src 这个文件，可以使用命令<code>ls mmc 1:1</code>查看一下 mmc1 分区1 中的所有文件，看看有没有 boot.src 这个文件。再展开bootscript：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bootscript=<span class="built_in">echo</span> Running bootscript from mmc ...;</span><br><span class="line"><span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>由于boot.src 文件不存在，所以 bootscript 也就不会运行。就运行环境变量 loadimage:<br><code>loadimage=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;loadaddr&#125; $&#123;image&#125;</code><br>loadimage展开：<br><code>loadimage=fatload mmc 1:1 0x80800000 zImage</code><br>fatload就是从 mmc1 的分区中读取 zImage 到内存的 0X80800000 处，而 mmc1的分区 1 中存在 zImage。<br>loadimage执行完，执行mmcboot环境变量，run mmcboot：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/10.png" alt="image"><br>①打印Booting from mmc …<br>②运行环境变量 mmcargs，mmcargs 用来设置 bootargs，后面分析 bootargs 的时候在学习。<br>③判断boot_fdt是否为yes或者try，根据uboot输出的环境变量信息可知boot_fdt&#x3D;try。因此执行loadfdt。<br>④执行loadfdt环境变量,如下：<br><code>loadfdt=fatload mmc $&#123;mmcdev&#125;:$&#123;mmcpart&#125; $&#123;fdt_addr&#125; $&#123;fdt_file&#125;</code><br>展开以后就是:<br><code>loadfdt=fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb</code><br>因此 loadfdt 的作用就是从 mmc1 的分区 1 中读取 imx6ull-14x14-evk.dtb 文件并放到 0x83000000处。<br>⑤loadfdt加载dtb成功后，调用命令 bootz 启动 linux：<br>    <code>bootz $&#123;loadaddr&#125; - $&#123;fdt_addr&#125;;</code><br>展开：<br>    <code>bootz 0x80800000 - 0x83000000 (注意‘-’前后要有空格)</code></p>
<p>总结一下bootcmd展开：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="comment">//切换到 EMMC</span></span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x80800000</span> zImage <span class="comment">//读取 zImage 到 0x80800000 处</span></span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">0x83000000</span> imx6ull<span class="number">-14</span>x14-evk.dtb <span class="comment">//读取设备树到 0x83000000 处</span></span><br><span class="line">bootz <span class="number">0x80800000</span> - <span class="number">0x83000000</span> <span class="comment">//启动 Linux</span></span><br></pre></td></tr></table></figure>

<p>我们可以将bootcmd环境变量进行简化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define CONFIG_BOOTCOMMAND \</span></span><br><span class="line"> <span class="string">&quot;mmc dev 1;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;fatload mmc 1:1 0x80800000 zImage;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;fatload mmc 1:1 0x83000000 imx6ull-alientek-emmc.dtb;&quot;</span> \</span><br><span class="line"> <span class="string">&quot;bootz 0x80800000 - 0x83000000;&quot;</span></span><br></pre></td></tr></table></figure>
<p>或者：<br><code>setenv bootcmd &#39;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ullalientek-emmc.dtb; bootz 80800000 - 83000000;&#39;</code></p>
<h4><span id="1-3-4-2-bootargs-zhan-kai">1.3.4.2 bootargs展开</span><a href="#1-3-4-2-bootargs-zhan-kai" class="header-anchor">#</a></h4><p>bootargs 保存着 uboot 传递给 Linux 内核的参数。从emmc启动时，bootargs 环境变量是由 mmcargs 设置的：<br><code>mmcargs=setenv bootargs console=$&#123;console&#125;,$&#123;baudrate&#125; root=$&#123;mmcroot&#125;</code><br>其中：<br><code>console=ttymxc0，baudrate=115200，mmcroot=/dev/mmcblk1p2 rootwait rw</code><br>mmcargs展开以后就是:<br><code>mmcargs=setenv bootargs console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code></p>
<p>可以看出环境变量 mmcargs 就是设置 bootargs 的值为<code>console= ttymxc0, 115200 root= /dev/mmcblk1p2 rootwait rw</code>。<br>①<code>console=ttymxc0,115200 </code>综合起来就是设置 ttymxc0（也就是串口 1）作为 Linux 的终端，并且串口波特率设置为 115200。<br>②<code>root=/dev/mmcblk1p2 </code>用于指明根文件系统存放在mmcblk1 设备的分区 2 中。在 I.MX6U-ALPHA 开发板中&#x2F;dev&#x2F;mmcblk1 表示 EMMC，而&#x2F;dev&#x2F;mmcblk1p2 表示EMMC 的分区 2。<br>③root 后面有<code>rootwait rw</code>，rootwait 表示等待 mmc 设备初始化完成以后再挂载，否则的话mmc 设备还没初始化完成就挂载根文件系统会出错的。rw 表示根文件系统是可以读写的，不加rw 的话可能无法在根文件系统中进行写操作，只能进行读操作。</p>
<h4><span id="1-3-4-3-bootdlelay">1.3.4.3 bootdlelay</span><a href="#1-3-4-3-bootdlelay" class="header-anchor">#</a></h4><p>uboot命令行倒计时</p>
<h2><span id="1-4-nei-cun-cao-zuo">1.4 内存操作</span><a href="#1-4-nei-cun-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-4-1-md">1.4.1 md</span><a href="#1-4-1-md" class="header-anchor">#</a></h3><pre><code>md[.b, .w, .l] address [# of objects]
</code></pre>
<p>注意：uboot 命令中的数字都是十六进制的</p>
<ol>
<li>命令中的<code>[.b .w .l]对应 byte、word 和 long</code>，也就是分别以 1 个字节、2 个字节、4 个字节来显示内存值.</li>
<li>address 就是要查看的内存起始地址.</li>
<li><code>[# of objects]</code>表示要查看的数据长度:</li>
</ol>
<p>这个数据长度单位不是字节，而是跟你所选择的显示格式有关。比如你设置要查看的内存长度为20(十六进制为 0x14)，如果显示格式为.b 的话那就表示 20 个字节；如果显示格式为.w 的话就表示 20 个 word，也就是<code> 20*2=40 个字节</code>；如果显示格式为.l 的话就表示 20 个 long，也就是<code>20*4=80 </code>个字节</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">md.b <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读16字节</span></span><br><span class="line">md.w <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读32字节</span></span><br><span class="line">md.l <span class="number">80000000</span> <span class="number">10</span> <span class="comment">//读64字节</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/11.png" alt="image"></p>
<h3><span id="1-4-2-nm-ming-ling">1.4.2 nm命令</span><a href="#1-4-2-nm-ming-ling" class="header-anchor">#</a></h3><p>写内存，写成功后地址不会自增。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm [.b, .w, .l] address</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/12.png" alt="image"><br>0500e031 表示地址 0x80000000 现在的数据，<code>？</code>后面就可以输入要修改后的数据 0x12345678，输入完成以后按下回车，然后再输入‘q’即可退出。<br>退出后输入md.l查看。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/13.png" alt="image"></p>
<h3><span id="1-4-3-mm-ming-ling">1.4.3 mm命令</span><a href="#1-4-3-mm-ming-ling" class="header-anchor">#</a></h3><p>写内存，写成功后地址会自增。<br>比如以.l 格式修改从地址 0x80000000 开始的连续 3 个内存块<code>(3*4=12个字节)</code>的数据为 0X05050505.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/14.png" alt="image"><br>输入md命令查看一下：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/15.png" alt="image"></p>
<h3><span id="1-4-4-mw-ming-ling">1.4.4 mw命令</span><a href="#1-4-4-mw-ming-ling" class="header-anchor">#</a></h3><p>写一段连续的内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mw [.b, .w, .l] address value [count]</span><br></pre></td></tr></table></figure>

<p>比如使用.l 格式将以 0X80000000 为起始地址的 0x10 个内存块<code>(0x10 * 4=64 字节)</code>填充为 0X0A0A0A0A</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mw.l 80000000 0A0A0A0A 10</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/16.png" alt="image"></p>
<h3><span id="1-4-5-cp-ming-ling">1.4.5 cp命令</span><a href="#1-4-5-cp-ming-ling" class="header-anchor">#</a></h3><p>数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中。</p>
<pre><code>cp [.b, .w, .l] source target count
</code></pre>
<p>我们使用.l 格式将 0x80000000 处的地址拷贝到 0X80000100 处，长度为 0x10 个内存块<code>(0x10 * 4=64 个字节).</code></p>
<pre><code>cp.l 80000000 80000100 10
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/17.png" alt="image"></p>
<h3><span id="1-4-6-cmp-ming-ling">1.4.6 cmp命令</span><a href="#1-4-6-cmp-ming-ling" class="header-anchor">#</a></h3><p>比较两段内存的数据是否相等。</p>
<pre><code>cmp [.b, .w, .l] addr1 addr2 count
</code></pre>
<p>比较 0x80000000 和 0X80000100 这两个地址数据是否相等，比较长度为 0x10 个内存块<code>(16 * 4=64 个字节)</code></p>
<pre><code>cmp.l 80000000 80000100 10
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/18.png" alt="image"><br>我们再随便挑两段内存比较一下，比如地址0x80002000 和 0x800003000，长度为 0X10.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/19.png" alt="image"><br>可以看出，0x80002000 处的数据和 0x80003000 处的数据就不一样.</p>
<h2><span id="1-5-wang-luo-cao-zuo-ming-ling">1.5 网络操作命令</span><a href="#1-5-wang-luo-cao-zuo-ming-ling" class="header-anchor">#</a></h2><table>
<thead>
<tr>
<th>环境变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ipaddr</td>
<td>开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址</td>
</tr>
<tr>
<td>ethaddr</td>
<td>开发板的 MAC 地址，一定要设置</td>
</tr>
<tr>
<td>gatewayip</td>
<td>网关地址</td>
</tr>
<tr>
<td>netmask</td>
<td>子网掩码</td>
</tr>
<tr>
<td>serverip</td>
<td>服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码</td>
</tr>
</tbody></table>
<p>预先设置号网络相关环境变量：</p>
<pre><code>setenv ipaddr 192.168.1.50
setenv ethaddr b8:ae:1d:01:00:00
setenv gatewayip 192.168.1.1
setenv netmask 255.255.255.0
setenv serverip 192.168.1.253
saveenv
</code></pre>
<h3><span id="1-5-1-ping-ming-ling">1.5.1 ping命令</span><a href="#1-5-1-ping-ming-ling" class="header-anchor">#</a></h3><pre><code>ping 192.168.1.100
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/20.png" alt="image"></p>
<h3><span id="1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu">1.5.2 dhcp命令（自动ip获取）</span><a href="#1-5-2-dhcp-ming-ling-zi-dong-ip-huo-qu" class="header-anchor">#</a></h3><p>dhcp 用于从路由器获取 IP 地址，前提得开发板连接到路由器上的，如果开发板是和电脑<br>直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址。</p>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/21.png" alt="image"><br>DHCP 不单单是获取 IP 地址，其还会通过 TFTP 来启动 linux 内核，输入<code>? dhcp</code>即<br>可查看 dhcp 命令详细的信息：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/22.png" alt="image"></p>
<h3><span id="1-5-3-nfs-ming-ling">1.5.3 nfs命令</span><a href="#1-5-3-nfs-ming-ling" class="header-anchor">#</a></h3><p>nfs(Network File System)网络文件系统,通过网络将编译好的 linux 镜像和设备树文件下载<br>到 DRAM 中，然后就可以直接运行。<br>虚拟机Ubuntu先搭建好nfs服务，详见：<a href="https://www.cnblogs.com/fuzidage/p/16694496.html" title="nfs服务搭建">nfs服务搭建</a> <a href="https://fuzidage.github.io/2024/03/26/linux%E6%90%AD%E5%BB%BAnfs%E6%9C%8D%E5%8A%A1/">linux搭建nfs服务 | Hexo (fuzidage.github.io)</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfs [loadAddress] [[hostIPaddr:]bootfilename]</span><br></pre></td></tr></table></figure>

<p>loadAddress 是要保存的 DRAM 地址，<code>[[hostIPaddr:]bootfilename]</code>是要下载的文件地址,<br>我们将正点原子官方编译出来的 Linux 镜像文件 zImage 下载到开发板 DRAM 的 0x80800000这个地址处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nfs 80800000 192.168.1.253:/home/zuozhongkai/linux/nfs/zImage</span><br></pre></td></tr></table></figure>
<p>下载过程如图下：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/23.png" alt="image"></p>
<p>下载完成以后查看 0x80800000 地址处的数据，使用命令 md.b 来查看前 0x100 个字节的数据。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/24.png" alt="image"><br>我们再用UE打开编译出的zImage，对比一下说明 nfs 命令下载到的zImage 是正确的。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/25.png" alt="image"></p>
<h3><span id="1-5-4-tftp-ming-ling">1.5.4 tftp命令</span><a href="#1-5-4-tftp-ming-ling" class="header-anchor">#</a></h3><p>tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中。tftp服务搭建参考：<a href="https://www.cnblogs.com/fuzidage/p/11997775.html" title="tftp服务搭建">tftp服务搭建</a> <a href="https://fuzidage.github.io/2024/03/24/linux%E6%90%AD%E5%BB%BAtftp%E5%92%8Cftp%E6%9C%8D%E5%8A%A1/">linux搭建tftp和ftp服务 | Hexo (fuzidage.github.io)</a></p>
<pre><code>tftpboot [loadAddress] [[hostIPaddr:]bootfilename]
</code></pre>
<p> loadAddress 是文 件在 DRAM 中的 存放 地址 ，<br><code>[[hostIPaddr:]bootfilename]</code>是要从 Ubuntu 中下载的文件。但是和 nfs 命令的区别在于，tftp 命令不需要输入文件在 Ubuntu 中的完整路径，只需要输入文件名即可。比如我们现在将 tftpboot 文件夹里面的 zImage 文件下载到开发板 DRAM 的 0X80800000 地址处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tftp 80800000 zImage</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/26.png" alt="image"></p>
<h2><span id="1-6-emmc-he-sd-qia-zhi-ling">1.6 emmc和sd卡指令</span><a href="#1-6-emmc-he-sd-qia-zhi-ling" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/27.png" alt="image"></p>
<p>mmc相关命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mmc info</td>
<td>输出 MMC 设备信息</td>
</tr>
<tr>
<td>mmc read</td>
<td>读取 MMC 中的数据</td>
</tr>
<tr>
<td>mmc wirte</td>
<td>向 MMC 设备写入数据</td>
</tr>
<tr>
<td>mmc rescan</td>
<td>扫描 MMC 设备</td>
</tr>
<tr>
<td>mmc part</td>
<td>列出 MMC 设备的分区</td>
</tr>
<tr>
<td>mmc dev</td>
<td>切换 MMC 设备</td>
</tr>
<tr>
<td>mmc list</td>
<td>列出当前有效的所有 MMC 设备</td>
</tr>
<tr>
<td>mmc hwpartition</td>
<td>设置 MMC 设备的分区</td>
</tr>
<tr>
<td>mmc bootbus……</td>
<td>设置指定 MMC 设备的 BOOT_BUS_WIDTH 域的值</td>
</tr>
<tr>
<td>mmc bootpart……</td>
<td>设置指定 MMC 设备的 boot 和 RPMB 分区的大小</td>
</tr>
<tr>
<td>mmc partconf……</td>
<td>设置指定 MMC 设备的 PARTITION_CONFG 域的值</td>
</tr>
<tr>
<td>mmc rst</td>
<td>复位 MMC 设备</td>
</tr>
<tr>
<td>mmc setdsr</td>
<td>设置 DSR 寄存器的值</td>
</tr>
</tbody></table>
<h3><span id="1-6-1-mmc-info">1.6.1 mmc info</span><a href="#1-6-1-mmc-info" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/28.png" alt="image"></p>
<p>当前选中的 MMC 设备是EMMC，版本为 5.0，容量为 7.1GiB(EMMC为 8GB)，速度为 52000000Hz&#x3D;52MHz，8 位宽的总线。还有一个与 mmc info 命令相同功能的命令：mmcinfo，“mmc”和“info”之间没有空格。</p>
<h3><span id="1-6-2-mmc-rescan">1.6.2 mmc rescan</span><a href="#1-6-2-mmc-rescan" class="header-anchor">#</a></h3><p>mmc rescan 命令用于扫描当前开发板上所有的 MMC 设备，包括 EMMC 和 SD 卡。</p>
<h3><span id="1-6-3-mmc-list">1.6.3 mmc list</span><a href="#1-6-3-mmc-list" class="header-anchor">#</a></h3><p>查看当前开发板一共有几个 MMC 设备.<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/29.png" alt="image"></p>
<p>可以看出当前开发板有两个 MMC 设备：<code>FSL_SDHC:0 和 FSL_SDHC:1 (eMMC)</code>，这是因为我现在用的是 EMMC 版本的核心板，加上 SD 卡一共有两个 MMC 设备，<code>FSL_SDHC:0 是 SD卡，FSL_SDHC:1(eMMC)是 EMMC</code>。默认会将 EMMC 设置为当前 MMC 设备，这就是为什么输入<code>mmc info</code>查询到的是 EMMC 设备信息，而不是 SD 卡。要想查看 SD 卡信息，就要使用命令<code>mmc dev</code>来将 SD 卡设置为当前的 MMC 设备。</p>
<h3><span id="1-6-4-mmc-dev">1.6.4 mmc dev</span><a href="#1-6-4-mmc-dev" class="header-anchor">#</a></h3><p>选择切换当前emmc设备。</p>
<pre><code>mmc dev [dev] [part]
</code></pre>
<p>[dev]用来设置要切换的 MMC 设备号，[part]是分区号。如果不写分区号的话默认为分区 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="comment">//切换到 SD 卡，0 为 SD 卡，1 为 eMMC</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/30.png" alt="image"><br>切换到sd这个mmc后，输入mmc info命令既可以查看sd信息：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/31.png" alt="image"></p>
<p>可以看到当前 SD 卡为 3.0 版本的，容量为 14.8GiB(16GB 的 SD 卡)，4 位宽的总线。</p>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/32.png" alt="image"></p>
<h3><span id="1-6-5-mmc-part">1.6.5 mmc part</span><a href="#1-6-5-mmc-part" class="header-anchor">#</a></h3><p>查看mmc分区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="comment">//切换到 EMMC</span></span><br><span class="line">mmc part <span class="comment">//查看 EMMC 分区</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/33.png" alt="image"></p>
<p>切到核心板的emmc后，<code>mmc part</code>显示分区信息，此时 EMMC 有两个分区，第一个分区起始扇区为 20480，长度为 262144 个扇区；第二个分区起始扇区为 282624，长度为 14594048 个扇区。<br>如果 EMMC 里面烧写了 Linux 系统的话，EMMC 是有 3 个分区的，第 0 个分区存放 uboot，第 1 个分区存放Linux 镜像文件和设备树，第 2 个分区存放根文件系统。但是在上图中只有两个分区，那是因为第 0 个分区没有格式化，所以识别不出来，实际上第 0 个分区是存在的。一个新的 SD卡默认只有一个分区，那就是分区 0，所以前面讲解的 uboot 烧写到 SD 卡，其实就是将 u-boot.bin烧写到了 SD 卡的分区 0 里面.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">2</span> <span class="comment">//将 EMMC 的分区 2 设置为当前 MMC 设备</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/34.png" alt="image"></p>
<h3><span id="1-6-6-mmc-read">1.6.6 mmc read</span><a href="#1-6-6-mmc-read" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc <span class="built_in">read</span> addr blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>读mmc设备中的数据。addr 是数据读取到 DRAM 中的地址，blk 是要读取的块起始地址(十六进制)，一个块是 512字节，这里的块和扇区是一个意思，在 MMC 设备中我们通常说扇区，cnt 是要读取的块数量(十六进制)。比如从 EMMC 的第 1536(0x600)个块开始，读取 16(0x10)个块的数据到 DRAM 的0X80800000 地址处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">0</span> <span class="comment">//切换到 MMC 分区 0</span></span><br><span class="line">mmc read <span class="number">80800000</span> <span class="number">600</span> <span class="number">10</span> <span class="comment">//读取数据</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/35.png" alt="image"><br>这里我们还看不出来读取是否正确，通过 md.b 命令查看 0x80800000 处的数据就行了，查看<code> 16*512=8192(0x2000)</code>个字节的数据。<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/36.png" alt="image"></p>
<p>可以看到<code>baudrate=115200.board_name=EVK.board_rev=14X14</code>等字样，<br>这个就是 uboot 中的环境变量。EMMC 核心板 uboot 环境变量的存储起始地址就是<code>1536*512=786432</code>。</p>
<h3><span id="1-6-7-mmc-write">1.6.7 mmc write</span><a href="#1-6-7-mmc-write" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc write addr blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>从DRAM写数据到mmc设备。<br>比如通过 nfs 或者 tftp 命令将新的 u-boot.bin 下载到开发板的 DRAM 中，然后再使用命令<code>mmc write</code>将其写入到 MMC设备中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="comment">//切换到 SD 卡</span></span><br><span class="line">version <span class="comment">//查看uboot版本号</span></span><br><span class="line">tftp <span class="number">80800000</span> u-boot.imx</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/37.png" alt="image"><br>可以看出，u-boot.imx 大小为 <code>379904 字节，379904/512=742</code>，所以我们要向 SD 卡中写入742 个块，如果有小数的话就要加 1 个块。使用命令<code>mmc write</code>从 SD 卡分区 0 第 2 个块(扇区)开始烧写，一共烧写 742(0x2E6)个块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">0</span> <span class="number">0</span></span><br><span class="line">mmc write <span class="number">80800000</span> <span class="number">2</span> <span class="number">2E6</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/38.png" alt="image"></p>
<p>烧写成功，重启开发板(从 SD 卡启动)，重启以后再输入 version 来查看版本号：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/39.png" alt="image"><br>这样就给mmc0也就是sd卡烧录了uboot, 同理要烧录emmc也是同理，切到mmc1即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc dev <span class="number">1</span> <span class="number">0</span> <span class="comment">//切换到 EMMC 分区 0</span></span><br><span class="line">tftp <span class="number">80800000</span> u-boot.imx <span class="comment">//下载 u-boot.imx 到 DRAM</span></span><br><span class="line">mmc write <span class="number">80800000</span> <span class="number">2</span> <span class="number">32</span>E <span class="comment">//烧写 u-boot.imx 到 EMMC 中</span></span><br><span class="line">mmc partconf <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">//分区配置，EMMC 需要这一步！</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：千万不要写 SD 卡或者 EMMC 的前两个块(扇区)，里面保存着分区表！</strong></p>
<h3><span id="1-6-7-mmc-erase">1.6.7 mmc erase</span><a href="#1-6-7-mmc-erase" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mmc erase blk<span class="comment"># cnt</span></span><br></pre></td></tr></table></figure>
<p>擦除 MMC 设备的指定块, blk 为要擦除的起始块，cnt 是要擦除的数量。</p>
<h2><span id="1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong">1.7 文件操作命令（fat文件系统）</span><a href="#1-7-wen-jian-cao-zuo-ming-ling-fat-wen-jian-xi-tong" class="header-anchor">#</a></h2><h3><span id="1-7-1-fatinfo">1.7.1 fatinfo</span><a href="#1-7-1-fatinfo" class="header-anchor">#</a></h3><pre><code>fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]
</code></pre>
<p>于查询指定 MMC 设备分区的文件系统信息，interface 表示接口，比如 mmc，dev 是查询的设备号，part 是要查询的分区。比如我们要查询 EMMC 分区 1 的文件系统信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatinfo mmc <span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/40.png" alt="image"><br>上图显示mmc1也就是emmc设备的分区1的文件系统为fat32格式。</p>
<h3><span id="1-7-1-fatls">1.7.1 fatls</span><a href="#1-7-1-fatls" class="header-anchor">#</a></h3><pre><code>fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]
</code></pre>
<p>查询设备分区的目录和文件信息。interface 是要查询的接口，比如 mmc，dev 是要查询的设备号，part 是要查询的分区，directory是要查询的目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatls mmc <span class="number">1</span>:<span class="number">1</span>   <span class="comment">//查询 mmc1设备（EMMC 设备）中分区 1 中的所有的目录和文件</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/41.png" alt="image"></p>
<h3><span id="1-7-3-fstype">1.7.3 fstype</span><a href="#1-7-3-fstype" class="header-anchor">#</a></h3><pre><code>fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;
</code></pre>
<p>查看 MMC 设备某个分区的文件系统格式.正点原子 EMMC 核心板上的 EMMC 默认有 3 个分区, 分区 0 格式未知，因为分区 0 存放的 uboot，并且分区 0 没有格式化，所以文件系统格式未知。分区 1 的格式为 fat，分区 1 用于存放 linux 镜像和设备树。分区 2 的格式为 ext4，用于存放 Linux 的根文件系统(rootfs)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fstype mmc <span class="number">1</span>:<span class="number">0</span></span><br><span class="line">fstype mmc <span class="number">1</span>:<span class="number">1</span></span><br><span class="line">fstype mmc <span class="number">1</span>:<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/42.png" alt="image"></p>
<h3><span id="1-7-4-fatload">1.7.4 fatload</span><a href="#1-7-4-fatload" class="header-anchor">#</a></h3><pre><code>fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]
</code></pre>
<p>将指定的文件读取到 DRAM.<br>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是保存在 DRAM 中的起始地址，filename 是要读取的文件名字。bytes 表示读取多少字节的数据，如果 bytes 为 0 或者省略的话表示读取整个文件。pos 是要读的文件相对于文件首地址的偏移，如果为 0 或者省略的话表示从文件首地址开始读取.</p>
<pre><code>fatload mmc 1:1 80800000 zImage  //将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的0X80800000 地址处
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/43.png" alt="image"></p>
<p> 225ms 内读取了 6785272 个字节的数据，速度为 28.8MiB&#x2F;s，速度是非常快的，因为这是从 EMMC 里面读取的，而 EMMC 是 8 位的，速度肯定会很快的。</p>
<h3><span id="1-7-5-fatwrite">1.7.5 fatwrite</span><a href="#1-7-5-fatwrite" class="header-anchor">#</a></h3><p>将 DRAM 中的数据写入到 MMC 设备。<br>uboot 默认没有使能<code> fatwrite</code> 命令，需要修改板子配置头文件，比如 <code>mx6ullevk.h、 mx6ull_alientek_emmc.h </code>等,需要开启宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FAT_WRITE <span class="comment">/* 使能 fatwrite 命令 */</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/44.png" alt="image"></p>
<pre><code>fatwrite &lt;interface&gt; &lt;dev[:part]&gt; &lt;addr&gt; &lt;filename&gt; &lt;bytes&gt;
</code></pre>
<p>interface 为接口，比如 mmc，dev 是设备号，part 是分区，addr 是要写入的数据在 DRAM中的起始地址，filename 是写入的数据文件名字，bytes 表示要写入多少字节的数据。</p>
<p>比如我们通过nfs or tftp命令下载镜像到DRAM后，通过fatwrite去烧写image：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/45.png" alt="image"><br>zImage 大小为<code>6785272(0X6788f8)</code>个字节(注意，由于开发板系统在不断的更新中，因此zImage 大小不是固定的，一切以实际大小为准)，接下来使用命令<code>fatwrite</code>将其写入到 EMMC 的分区 1 中，文件名字为 zImage：</p>
<pre><code>fatwrite mmc 1:1 80800000 zImage 6788f8
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/46.png" alt="image"></p>
<p>完成以后使用<code>fatls</code>命令查看一下 EMMC 分区 1 里面的文件：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/47.png" alt="image"></p>
<h2><span id="1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong">1.8 文件操作命令（ext文件系统）</span><a href="#1-8-wen-jian-cao-zuo-ming-ling-ext-wen-jian-xi-tong" class="header-anchor">#</a></h2><p>ext文件系统是linux常用的文件系统，一般rootfs就是典型的ext2文件系统。<br><code>ext2load、ext2ls、ext4load、ext4ls 和 ext4write</code>。这些命令的含义和使用与<code> fatload、fatls 和 fatwrite</code>一样，只是 ext2 和 ext4 都是针对 ext 文件系统的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ext4ls mmc <span class="number">1</span>:<span class="number">2</span>	<span class="comment">//emmc设备分区2就是ext4文件系统，存放了rootfs</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/48.png" alt="image"></p>
<h2><span id="1-9-nandflash-cao-zuo-ming-ling">1.9 nandflash操作命令</span><a href="#1-9-nandflash-cao-zuo-ming-ling" class="header-anchor">#</a></h2><p>输入<code>? nand</code>即可查看NAND 相关命令：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/49.png" alt="image"></p>
<h3><span id="1-9-1-nand-info">1.9.1 nand info</span><a href="#1-9-1-nand-info" class="header-anchor">#</a></h3><p>打印 NAND Flash 信息:<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/50.png" alt="image"></p>
<h3><span id="1-9-2-nand-device">1.9.2 nand device</span><a href="#1-9-2-nand-device" class="header-anchor">#</a></h3><p>用于切换 NAND Flash，如果你的板子支持多片 NAND 的话就可以使用此命令来设置当前所使用的 NAND。</p>
<h3><span id="1-9-3-nand-erase">1.9.3 nand erase</span><a href="#1-9-3-nand-erase" class="header-anchor">#</a></h3><p><code>nand erase </code>命令用于擦除 NAND Flash，NAND Flash 的特性(位翻转，只能由1变成0,而不能由0变成1)决定了在向 NAND Flash 写数据之前一定要先对要写入的区域进行擦除.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand erase[.spread] [clean] off size <span class="comment">//从指定地址开始(off)开始，擦除指定大小(size)的区域。</span></span><br><span class="line">nand erase.part [clean] partition <span class="comment">//擦除指定的分区</span></span><br><span class="line">nand erase.chip [clean] <span class="comment">//全篇擦除</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-9-3-nand-write">1.9.3 nand write</span><a href="#1-9-3-nand-write" class="header-anchor">#</a></h3><pre><code>nand write addr off size
</code></pre>
<p>addr 是要写入的数据首地址，off 是 NAND 中的目的地址，size 是要写入的数据大小。</p>
<p>编译出来 NAND版本的 kernel 和 dtb 文件，在烧写之前要先对 NAND 进行分区，也就是规划好 uboot、linux kernel、设备树和根文件系统的存储区域，I.MX6U-ALPHA 开发板出厂系统 NAND 分区如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x000000000000</span><span class="number">-0x0000003FFFFF</span> : <span class="string">&quot;boot&quot;</span></span><br><span class="line"><span class="number">0x000000400000</span><span class="number">-0x00000041FFFF</span> : <span class="string">&quot;env&quot;</span></span><br><span class="line"><span class="number">0x000000420000</span><span class="number">-0x00000051FFFF</span> : <span class="string">&quot;logo&quot;</span></span><br><span class="line"><span class="number">0x000000520000</span><span class="number">-0x00000061FFFF</span> : <span class="string">&quot;dtb&quot;</span></span><br><span class="line"><span class="number">0x000000620000</span><span class="number">-0x000000E1FFFF</span> : <span class="string">&quot;kernel&quot;</span></span><br><span class="line"><span class="number">0x000000E20000</span><span class="number">-0x000020000000</span> : <span class="string">&quot;rootfs&quot;</span></span><br></pre></td></tr></table></figure>

<p>一共有六个分区，第一个分区存放 uboot，地址范围为<code> 0x0~0x3FFFFF(共 4MB)</code>；第二个分区存放 env（环境变量），地址范围为 <code>0x400000~0x420000(共 128KB)</code>；第三个分区存放 logo(启动图标)，地址范围为<code> 0x420000~0x51FFFF(共 1MB)</code>；第四个分区存放 dtb(设备树)，地址范围为<code>0x520000~0x61FFFF(共 1MB)</code>；第五个分区存放 kernel(也就是 linux kernel)，地址范围为<code>0x620000~0xE1FFFF(共 8MB)</code>；剩下的所有存储空间全部作为最后一个分区，存放 rootfs(根文件系统)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x87800000</span> zImage <span class="comment">//下载 zImage 到 DRAM 中</span></span><br><span class="line">nand erase <span class="number">0x620000</span> <span class="number">0x800000</span> <span class="comment">//从地址 0x620000 开始擦除 8MB 的空间</span></span><br><span class="line">nand write <span class="number">0x87800000</span> <span class="number">0x620000</span> <span class="number">0x800000</span> <span class="comment">//将接收到的 zImage 写到 NAND 中</span></span><br></pre></td></tr></table></figure>

<p>这里我们擦除了 8MB 的空间，因为一般 zImage 就是 6,7MB 左右，8MB 肯定够了，如果不够的话就再多擦除一点就行了。同理烧录dtb:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x87800000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb <span class="comment">//下载 dtb 到 DRAM 中</span></span><br><span class="line">nand erase <span class="number">0x520000</span> <span class="number">0x100000</span> <span class="comment">//从地址 0x520000 开始擦除 1MB 的空间</span></span><br><span class="line">nand write <span class="number">0x87800000</span> <span class="number">0x520000</span> <span class="number">0x100000</span> <span class="comment">//将接收到的 dtb 写到 NAND 中</span></span><br></pre></td></tr></table></figure>

<h3><span id="1-9-4-nand-read">1.9.4 nand read</span><a href="#1-9-4-nand-read" class="header-anchor">#</a></h3><pre><code>nand read addr off size
</code></pre>
<p>从 NAND 中的指定地址读取指定大小的数据到 DRAM.<br>addr 是目的地址，off 是要读取的 NAND 中的数据源地址，size 是要读取的数据大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand read <span class="number">0x83000000</span> <span class="number">0x520000</span> <span class="number">0x19000</span>  <span class="comment">//读取设备树(dtb)文件到 0x83000000 地址处</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/51.png" alt="image"></p>
<h2><span id="1-10-she-bei-shu-xiang-guan">1.10 设备树相关</span><a href="#1-10-she-bei-shu-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-10-1-fdt-addr">1.10.1 fdt addr</span><a href="#1-10-1-fdt-addr" class="header-anchor">#</a></h3><p>设置设备树起始地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand read <span class="number">0x83000000</span> <span class="number">0x520000</span> <span class="number">0x19000</span> <span class="comment">//比如把nand中dtb分区数据读到dram</span></span><br><span class="line">fdt addr <span class="number">83000000</span>	<span class="comment">//设置好设备树起始地址</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-fdt-header">1.10.2 fdt header</span><a href="#1-10-2-fdt-header" class="header-anchor">#</a></h3><p>查看设备树头部信息：</p>
<pre><code>fdt header
</code></pre>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/52.png" alt="image"></p>
<h3><span id="1-10-3-fdt-print">1.10.3 fdt print</span><a href="#1-10-3-fdt-print" class="header-anchor">#</a></h3><p>解析出dts内容：<br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/53.png" alt="image"></p>
<h2><span id="1-11-qi-dong-xiang-guan">1.11 启动相关</span><a href="#1-11-qi-dong-xiang-guan" class="header-anchor">#</a></h2><h3><span id="1-11-1-bootz-qi-dong-zimage">1.11.1 bootz (启动zImage)</span><a href="#1-11-1-bootz-qi-dong-zimage" class="header-anchor">#</a></h3><pre><code>bootz [addr [initrd[:size]] [fdt]]
</code></pre>
<p>addr 是 Linux 镜像文件在 DRAM 中的位置，initrd 是 initrd 文件在DRAM 中的地址，如果不使用 initrd 的话使用‘-’代替即可，fdt 就是设备树文件在 DRAM 中的地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">80800000</span> zImage</span><br><span class="line">tftp <span class="number">83000000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb</span><br><span class="line">bootz <span class="number">80800000</span> - <span class="number">83000000</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/54.png" alt="image"><br>换一张启动方式：从mmc1也就是emmc启动：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">80800000</span> zImage</span><br><span class="line">fatload mmc <span class="number">1</span>:<span class="number">1</span> <span class="number">83000000</span> imx6ull<span class="number">-14</span>x14-emmc<span class="number">-7</span><span class="number">-1024</span>x600-c.dtb</span><br><span class="line">bootz <span class="number">80800000</span> - <span class="number">83000000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/55.png" alt="image"></p>
<h3><span id="1-11-1-bootm-qi-dong-uimage">1.11.1 bootm (启动uImage)</span><a href="#1-11-1-bootm-qi-dong-uimage" class="header-anchor">#</a></h3><pre><code>bootm [addr [initrd[:size]] [fdt]]
</code></pre>
<p>bootm 命令和 bootz 类似，它是启动 uImage 镜像。uImage是U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的“头”，说明这个映像文件的类型、加载位置、生成时间、大小等信息。<br>bootm如果不需要启动设备树：</p>
<pre><code>bootm addr
</code></pre>
<h3><span id="1-11-3-boot">1.11.3 boot</span><a href="#1-11-3-boot" class="header-anchor">#</a></h3><p>boot 会读取环境变量 bootcmd 来启动 Linux 系统：<br>比如设置bootcmd如下，从网络启动linux：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&#x27;tftp 80800000 zImage; tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">saveenv</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>

<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/56.png" alt="image"></p>
<p>同理，如果想从emmc启动linux,设置bootcmd如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv bootcmd <span class="string">&#x27;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb; bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">savenev</span><br><span class="line">boot</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/57.png" alt="image"></p>
<h3><span id="1-11-4-go-ming-ling">1.11.4 go命令</span><a href="#1-11-4-go-ming-ling" class="header-anchor">#</a></h3><pre><code>go addr
</code></pre>
<p>跳到指定的地址处执行, addr表示DRAM地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">87800000</span> <span class="built_in">printf</span>.bin	<span class="comment">//一个裸机程序，打印输入的按键，将两个整数相加</span></span><br><span class="line">go <span class="number">87800000</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/58.png" alt="image"></p>
<h3><span id="1-11-5-run">1.11.5 run</span><a href="#1-11-5-run" class="header-anchor">#</a></h3><p>run 命令用于运行环境变量中定义的命令，比如可以通过<code>run bootcmd</code>来运行 bootcmd 中的启动命令:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv mybootemmc <span class="string">&#x27;fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb;bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">setenv mybootnand <span class="string">&#x27;nand read 80800000 4000000 800000;nand read 83000000 6000000 100000;bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">setenv mybootnet <span class="string">&#x27;tftp 80800000 zImage; tftp 83000000imx6ull-14x14-emmc-7-1024x600-c.dtb;</span></span><br><span class="line"><span class="string">bootz 80800000 - 83000000&#x27;</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<p>设置了3个环境变量，可以<code>run mybootemmc或者run mybootnand或者run mybootnet</code>来分别从emmc启动，从nand启动，从网络启动。</p>
<h2><span id="1-12-nei-cun-ce-shi-mtest">1.12 内存测试mtest</span><a href="#1-12-nei-cun-ce-shi-mtest" class="header-anchor">#</a></h2><pre><code>mtest [start [end [pattern [iterations]]]]
</code></pre>
<p>start 是要测试的 DRAM 开始地址，end 是结束地址，比如我们测试<code> 0X80000000~0X80001000</code>这段内存，输入<code>mtest 80000000 80001000</code><br><img src="/2024/06/22/uboot-%E5%91%BD%E4%BB%A4%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/59.png" alt="image"><br> 可以看出，测试范围为<code> 0X80000000~0X80001000</code>，已经测试了 486 次，如果要结束测试就按下键盘上的“Ctrl+C”键。</p>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-编译defconfig分析</title>
    <url>/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-ban-ben-hao">1 版本号</a></li>
<li><a href="#2-makeflags">2 <code>MAKEFLAGS</code></a></li>
<li><a href="#3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du">3 设置命令输出详细程度</a></li>
<li><a href="#4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi">4 设置编译结果输出位置</a></li>
<li><a href="#5-dai-ma-jian-cha">5 代码检查</a></li>
<li><a href="#6-zi-mo-kuai-bian-yi">6 子模块编译</a></li>
<li><a href="#7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi">7 获取主机架构系统信息</a></li>
<li><a href="#8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian">8 设置目标架构、工具链和配置文件</a></li>
<li><a href="#9-diao-yong-scripts-kbuild-include">9 调用 <code>scripts/Kbuild.include</code></a><ul>
<li><a href="#9-1-build-bian-liang">9.1 <code>build变量</code></a><ul>
<li><a href="#9-1-1-diao-yong-scripts-makefile-build">9.1.1 调用scripts&#x2F;Makefile.build</a></li>
</ul>
</li>
<li><a href="#9-2-filechk-bian-liang">9.2 <code>filechk</code>变量</a></li>
<li><a href="#9-3-if-changed-bian-liang">9.3 if_changed变量</a></li>
<li><a href="#9-4-scripts-makefile-lib-wen-jian-zuo-yong">9.4 <code>scripts/Makefile.lib</code>文件作用</a><ul>
<li><a href="#9-4-1-ding-yi-bian-yi-xuan-xiang">9.4.1 定义编译选项</a></li>
<li><a href="#9-4-2-qu-chong">9.4.2 去重</a></li>
<li><a href="#9-4-3-modules-order">9.4.3 <code>modules.order</code></a></li>
<li><a href="#9-4-4-mu-lu-de-chu-li">9.4.4 目录的处理</a></li>
<li><a href="#9-4-5-she-bei-shu-xiang-guan">9.4.5 设备树相关</a></li>
<li><a href="#9-4-6-tian-jia-lu-jing">9.4.6 添加路径</a></li>
</ul>
</li>
<li><a href="#9-5-scripts-makefile-build-wen-jian-zuo-yong">9.5 <code>scripts/Makefile.build</code>文件作用</a><ul>
<li><a href="#9-5-1-bao-han-include-config-auto-conf">9.5.1 包含<code> include/config/auto.conf</code></a></li>
<li><a href="#9-5-2-bao-han-scripts-kbuild-include">9.5.2 包含<code> scripts/Kbuild.include</code></a></li>
<li><a href="#9-5-3-chu-li-bian-yi-mu-biao">9.5.3 处理编译目标</a></li>
<li><a href="#9-5-4-mo-ren-bian-yi-mu-biao-build">9.5.4 默认编译目标<code>_build</code></a><ul>
<li><a href="#9-5-4-1-builtin-target">9.5.4.1<code>builtin-target</code></a></li>
<li><a href="#9-5-4-2-lib-target">9.5.4.2 <code>lib-target</code></a></li>
<li><a href="#9-5-4-3-extra-y">9.5.4.3 <code>extra-y</code></a></li>
<li><a href="#9-5-4-4-obj-m">9.5.4.4 <code>obj-m</code></a></li>
<li><a href="#9-5-4-5-modorder-target">9.5.4.5 modorder-target</a></li>
<li><a href="#9-5-4-6-subdir-ym">9.5.4.6 subdir-ym</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#10-she-zhi-jiao-cha-bian-yi-qi">10 设置交叉编译器</a></li>
<li><a href="#11-he-xin-bian-liang-dao-chu">11 核心变量导出</a></li>
<li><a href="#12-make-xxx-defconfig-pei-zhi-guo-cheng">12 <code>make xxx_defconfig</code> 配置过程</a><ul>
<li><a href="#12-1-chan-sheng-ban-ben-ri-qi-xin-xi">12.1 产生版本日期信息</a></li>
<li><a href="#12-2-pei-zhi-bian-liang">12.2 配置变量</a></li>
<li><a href="#12-3-zhi-xing-3-ge-yi-lai">12.3 执行3个依赖</a><ul>
<li><a href="#12-3-1-scripts-basic">12.3.1 <code>scripts_basic</code></a><ul>
<li><a href="#12-3-1-1-scripts-makefile-build">12.3.1.1 <code>scripts/Makefile.build</code></a><ul>
<li><a href="#12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build">12.3.1.1.1 找到默认目标<code>_build</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#12-3-2-outputmakefile">12.3.2 <code>outputmakefile</code></a></li>
<li><a href="#12-3-3-force">12.3.3 <code>FORCE</code></a></li>
</ul>
</li>
<li><a href="#12-4-chan-sheng-config">12.4 产生<code>.config</code></a></li>
<li><a href="#12-5-zhi-zuo-defconfig">12.5 制作<code>defconfig</code></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="1-ban-ben-hao">1 版本号</span><a href="#1-ban-ben-hao" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/1.png" alt="image"><br>Top Makefile的开头会有版本描述，<code>VERSION </code>是主版本号，<code>PATCHLEVEL </code>是补丁版本号，<code>SUBLEVEL </code>是次版本号，这三个一 起构成了 uboot 的版本号，比如当前的 uboot 版本号就是<code>2016.03</code>。<code>EXTRAVERSION </code>是附加 版本信息，NAME 是和名字有关的，一般不使用这两个。</p>
<h2><span id="2-makeflags">2 <code>MAKEFLAGS</code></span><a href="#2-makeflags" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/2.png" alt="image"><br>有两个特殊的变量：<code>SHELL</code>和<code>MAKEFLAGS</code>，这两个变量除非使用<code>unexport</code>声明， 否则的话在整个make的执行过程中，它们的值始终自动的传递给子make。<br><code>MAKEFLAGS</code> 追加了一些值，<code>-rR</code>表示禁止使用内置的隐 含规则和变量定义，<code>--include-dir</code>指明搜索路径，<code>$(CURDIR)</code>表示当前目录。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/3.png" alt="image"></p>
<h2><span id="3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du">3 设置命令输出详细程度</span><a href="#3-she-zhi-ming-ling-shu-chu-xiang-xi-cheng-du" class="header-anchor">#</a></h2><p>①uboot 默认编译使用短命令。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/4.png" alt="image"><br>②设置变量<code>V=1</code>来实现完整的命令输出。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/5.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/6.png" alt="image"><br>③<code>make -s</code>设置成静默输出，将会<code>silent_输出</code>,不打印任何提示信息。如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/7.png" alt="image"><br><code>MAKE_VERSION</code>就是make版本号，我这里是<code>4.2.1</code>。因此<code>filter 4.%,$(MAKE_VERSION)</code>得到的过滤结果不为空。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/8.png" alt="image"></p>
<p>当使用<code>make -s</code>编译的时候，<code>-s</code>会作为 <code>MAKEFLAGS </code>变量的一部分传递给 Makefile。因此<code>$(firstword x$(MAKEFLAGS))得到xrRs</code>，最后<code>quiet=silent</code>_,否则不使用<code>silent_</code>输出。最后使用 <code>export 导出变量 quiet、Q 和 KBUILD_VERBOSE</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/9.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/10.png" alt="image"></p>
<h2><span id="4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi">4 设置编译结果输出位置</span><a href="#4-she-zhi-bian-yi-jie-guo-shu-chu-wei-zhi" class="header-anchor">#</a></h2><p>在 make 的时候使用<code>O</code>来指定 输出目录，这么做是为了将源文件 和编译产生的文件分开，当然也可以不指定 O 参数，不指定的话源文件和编译产生的文件都在 同一个目录内。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/11.png" alt="image"><br>判断<code>O</code>是否来自于命令行，如果来自命令行的话，<code>KBUILD_OUTPUT 就为$(O)</code>，也就是输出目录。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/12.png" alt="image"><br>一开始判断<code>KBUILD_OUTPUT </code>是否为空。 如果指定了输出目录就调用 <code>mkdir </code>命令创建目录。</p>
<h2><span id="5-dai-ma-jian-cha">5 代码检查</span><a href="#5-dai-ma-jian-cha" class="header-anchor">#</a></h2><p>命令<code>make C=1</code>使能代码检查，检查那些需要重新编译的文 件。<code>make C=2</code>用于检查所有的源码文件。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/13.png" alt="image"></p>
<h2><span id="6-zi-mo-kuai-bian-yi">6 子模块编译</span><a href="#6-zi-mo-kuai-bian-yi" class="header-anchor">#</a></h2><p>使用命令<code>make M=dir</code>即可，旧语法<code>make SUBDIRS=dir</code>也是支持的。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/14.png" alt="image"><br>如果定 义 了 SUBDIRS或者M,那么<code>KBUILD_EXTMOD</code>就会被赋值。然后进入目标<code>_all 依赖 modules</code>，要先编译出<code> modules</code>，也就是编译模块。<br>否则<code>KBUILD_EXTMOD</code>为空，进入<code>all</code>编译。<br>判断<code>KBUILD_SRC</code>是否为空，如果为空的话就设置变量<code>srctree</code>为当前目录，否则<code>srctree</code>就是<code>KBUILD_SRC</code>。一般不设置 <code>KBUILD_SRC</code>。<br>设置变量<code>src</code>和<code> obj</code>，都为当前目录，设置<code>VPATH</code>，导出量<code> scrtree、objtree 和 VPATH</code>。</p>
<h2><span id="7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi">7 获取主机架构系统信息</span><a href="#7-huo-qu-zhu-ji-jia-gou-xi-tong-xin-xi" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/15.png" alt="image"><br>最终开发服务器主机架构和操作系统信息如下:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/16.png" alt="image"></p>
<h2><span id="8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian">8 设置目标架构、工具链和配置文件</span><a href="#8-she-zhi-mu-biao-jia-gou-gong-ju-lian-he-pei-zhi-wen-jian" class="header-anchor">#</a></h2><p><code>HOSTARCH是x86_64</code>,我们编译<code>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-</code>就是用于设置目标<code> ARCH 和 CROSS_COMPILE</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/17.png" alt="image"><br><code>KCONFIG_CONFIG</code>，这里设置配置文件为<code>.config，.config </code>默认是没有的，需要使用命令<code>make xxx_defconfig</code> 对 uboot 进行配置，配置完成以后就会在 uboot 根目录下生成<code>.config</code>。<br>设置主机编译器<code>HOSTCC，HOSTCXX</code>等。</p>
<h2><span id="9-diao-yong-scripts-kbuild-include">9 调用 <code>scripts/Kbuild.include</code></span><a href="#9-diao-yong-scripts-kbuild-include" class="header-anchor">#</a></h2><p>在整个<code>Kbuild</code>系统中，<code>scripts/Kbuild.include </code>提供了大量通用函数以及变量的定义，这些定义将被 <code>Makefile.build 、Makefile.lib 和 top Makefile</code>频繁调用，以实现相应的功能,<code>scripts/Kbuild.include </code>参与整个内核编译的过程，是编译的核心脚本之一。</p>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/18.png" alt="image"><br><code>Kbuild.include</code>定义了很多变量:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/19.png" alt="image"><br>里面定了build变量，后面产生配置文件时会用到：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/20.png" alt="image"></p>
<h3><span id="9-1-build-bian-liang">9.1 <code>build变量</code></span><a href="#9-1-build-bian-liang" class="header-anchor">#</a></h3><p><code>build := -f $(srctree)/scripts/Makefile.build obj</code></p>
<p>例如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>当我们执行<code>make menuconfig</code>时:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">menuconfig: scripts_basic outputmakefile FORCE</span></span><br><span class="line">    make -f <span class="variable">$(srctree)</span>/scripts/Makefile.build obj=scripts/kconfig menuconfig</span><br></pre></td></tr></table></figure>

<h4><span id="9-1-1-diao-yong-scripts-x2f-makefile-build">9.1.1 调用scripts&#x2F;Makefile.build</span><a href="#9-1-1-diao-yong-scripts-x2f-makefile-build" class="header-anchor">#</a></h4><p>参见后面<code>12.3.1.1节</code>再详细介绍。</p>
<p>与<code>build变量</code>相类似的，还有以下的编译指令:</p>
<p><code>$(modbuiltin)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">modbuiltin := -f <span class="variable">$(srctree)</span>/scripts/Makefile.modbuiltin obj</span><br></pre></td></tr></table></figure>

<p><code>$(dtbinst)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">dtbinst := -f <span class="variable">$(srctree)</span>/scripts/Makefile.dtbinst obj</span><br></pre></td></tr></table></figure>

<p><code>$(clean)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">clean := -f <span class="variable">$(srctree)</span>/scripts/Makefile.clean obj</span><br></pre></td></tr></table></figure>

<p><code>$(hdr-inst)</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">hdr-inst := -f <span class="variable">$(srctree)</span>/scripts/Makefile.headersinst obj</span><br></pre></td></tr></table></figure>

<p>这四条指令，分别对应 <code>內建模块编译</code>、<code>dtb文件安装</code>、<code>目标清除</code>和<code>头文件安装</code>.</p>
<p>9.2 </p>
<h3><span id="9-2-filechk-bian-liang">9.2 <code>filechk</code>变量</span><a href="#9-2-filechk-bian-liang" class="header-anchor">#</a></h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> filechk</span><br><span class="line">    <span class="variable">$(Q)</span>set -e;             \</span><br><span class="line">    mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span>;         \</span><br><span class="line">    &#123; $(filechk_$(1)); &#125; &gt; <span class="variable">$@</span>.tmp;      \</span><br><span class="line">    if [ -r <span class="variable">$@</span> ] &amp;&amp; cmp -s <span class="variable">$@</span> <span class="variable">$@</span>.tmp; then  \</span><br><span class="line">        rm -f <span class="variable">$@</span>.tmp;           \</span><br><span class="line">    <span class="keyword">else</span>                    \</span><br><span class="line">        <span class="variable">$(kecho)</span> &#x27;  UPD     <span class="variable">$@</span>&#x27;;    \</span><br><span class="line">        mv -f <span class="variable">$@</span>.tmp <span class="variable">$@</span>;        \</span><br><span class="line">    fi</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>mkdir -p $(dir $@)</code>：如果<code>$@</code>目录不存在，就创建目录，<code>$@</code>是编译规则中的目标部分。($@ 在 Makefile 表目标文件)</li>
<li>执行<code>filechk_$(1)</code>,然后将执行结果保存到 <code>$@.tmp</code>中</li>
<li>对比<code>$@.tmp</code>和<code>$@</code>是否有更新，有更新就使用 <code>$@.tmp</code>，否则删除<code> $@.tmp</code>。</li>
</ol>
<h3><span id="9-3-if-changed-bian-liang">9.3 if_changed变量</span><a href="#9-3-if-changed-bian-liang" class="header-anchor">#</a></h3><p>下一节有详细解析介绍：</p>
<p><a href="https://www.cnblogs.com/fuzidage/p/17901135.html">uboot顶层makefile-2编译过程 - fuzidage - 博客园 (cnblogs.com)</a></p>
<p><a href="https://fuzidage.github.io/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/#1-2-2-if-changed-jie-shi">uboot-编译过程Make分析 | Hexo (fuzidage.github.io)</a></p>
<h3><span id="9-4-scripts-makefile-lib-wen-jian-zuo-yong">9.4 <code>scripts/Makefile.lib</code>文件作用</span><a href="#9-4-scripts-makefile-lib-wen-jian-zuo-yong" class="header-anchor">#</a></h3><h4><span id="9-4-1-ding-yi-bian-yi-xuan-xiang">9.4.1 定义编译选项</span><a href="#9-4-1-ding-yi-bian-yi-xuan-xiang" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">asflags-y  += <span class="variable">$(EXTRA_AFLAGS)</span></span><br><span class="line">ccflags-y  += <span class="variable">$(EXTRA_CFLAGS)</span></span><br><span class="line">cppflags-y += <span class="variable">$(EXTRA_CPPFLAGS)</span></span><br><span class="line">ldflags-y  += <span class="variable">$(EXTRA_LDFLAGS)</span></span><br><span class="line"></span><br><span class="line">KBUILD_AFLAGS += $(subdir-asflags-y)</span><br><span class="line">KBUILD_CFLAGS += $(subdir-ccflags-y</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-2-qu-chong">9.4.2 去重</span><a href="#9-4-2-qu-chong" class="header-anchor">#</a></h4><p>如果某个模块已经被定义在obj-y中，就没必要再编译了。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除obj-m中已经定义在obj-y中的部分</span></span><br><span class="line">obj-m := <span class="variable">$(<span class="built_in">filter</span>-out $(obj-y)</span>,$(obj-m))</span><br><span class="line"><span class="comment"># 去除lib-y中已经定义在obj-y中的部分</span></span><br><span class="line">lib-y := <span class="variable">$(<span class="built_in">filter</span>-out $(obj-y)</span>, <span class="variable">$(<span class="built_in">sort</span> $(lib-y)</span> $(lib-m)))</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-3-modules-order">9.4.3 <code>modules.order</code></span><a href="#9-4-3-modules-order" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将obj-y中的目录 dir 修改为 dir/modules.order赋值给modorder，</span></span><br><span class="line"><span class="comment">#将obj-m中的.o修改为.ko赋值给modorder。 </span></span><br><span class="line">modorder    := <span class="variable">$(<span class="built_in">patsubst</span> %/,%/modules.order,\</span></span><br><span class="line"><span class="variable">                 $(<span class="built_in">filter</span> %/, $(obj-y)</span>) $(obj-m:.o=.ko))</span><br></pre></td></tr></table></figure>

<p>内核将编译的外部模块全部记录在<code> modules.order</code> 文件中，以便 <code>modprobe </code>命令在加载卸载时查询使用。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">kernel/drivers/input/mouse/psmouse.ko</span><br><span class="line">kernel/drivers/input/misc/100ask_adxl345-spi.ko</span><br><span class="line">kernel/drivers/input/evbug.ko</span><br></pre></td></tr></table></figure>

<h4><span id="9-4-4-mu-lu-de-chu-li">9.4.4 目录的处理</span><a href="#9-4-4-mu-lu-de-chu-li" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#挑选出obj-y 和 obj-m 中的纯目录部分，然后添加到subdir-y和subdir-m中。  </span></span><br><span class="line">__subdir-y  := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-y)</span>))</span><br><span class="line">subdir-y    += $(__subdir-y)</span><br><span class="line"></span><br><span class="line">__subdir-m  := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, $(obj-m)</span>))</span><br><span class="line">subdir-m    += $(__subdir-m)</span><br><span class="line"></span><br><span class="line"><span class="comment">#需要被递归搜寻的子路径，带有可编译内部和外部模块的子目录。  </span></span><br><span class="line">subdir-ym   := <span class="variable">$(<span class="built_in">sort</span> $(subdir-y)</span> $(subdir-m))</span><br><span class="line"></span><br><span class="line"><span class="comment">#obj-y 中纯目录部分则将其改名为dir/build-in.a,obj-y的其他部分则不变。  </span></span><br><span class="line">obj-y       := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.a, $(obj-y)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将obj-m中的纯目录部分剔除掉(因为已经在上面加入到subdir-m中了)。</span></span><br><span class="line">obj-m       := <span class="variable">$(<span class="built_in">filter</span>-out %/, $(obj-m)</span>)</span><br></pre></td></tr></table></figure>

<p>   <code>obj-y 和 obj-m </code>的定义中同时夹杂着目标文件和目标文件夹，文件夹当然是不能直接参与编译的，所以需要将文件夹提取出来。</p>
<p>将 <code>obj-y or obj-m</code>中以<code>&quot;/&quot;</code>结尾的纯目录部分提取出来，并赋值给 <code>subdir-ym</code>.</p>
<h4><span id="9-4-5-she-bei-shu-xiang-guan">9.4.5 设备树相关</span><a href="#9-4-5-she-bei-shu-xiang-guan" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y             += $(dtb-y)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += $(dtb-)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CHECK_DTBS)</span>,)</span><br><span class="line">extra-y += <span class="variable">$(<span class="built_in">patsubst</span> %.dtb,%.dt.yaml, $(dtb-y)</span>)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += <span class="variable">$(<span class="built_in">patsubst</span> %.dtb,%.dt.yaml, $(dtb-)</span>)</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>将所有的<code>dtb-y</code>赋值给<code>extra-y</code>。</p>
<h4><span id="9-4-6-tian-jia-lu-jing">9.4.6 添加路径</span><a href="#9-4-6-tian-jia-lu-jing" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(extra-y)</span>)</span><br><span class="line">always      := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(always)</span>)</span></span><br><span class="line">targets     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(targets)</span>)</span></span><br><span class="line">modorder    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,<span class="variable">$(modorder)</span>)</span></span><br><span class="line">obj-m       := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(obj-m)</span>)</span><br><span class="line">lib-y       := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(lib-y)</span>)</span><br><span class="line">subdir-obj-y    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(subdir-obj-y)</span>)</span><br><span class="line">real-obj-y  := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(real-obj-y)</span>)</span><br><span class="line">real-obj-m  := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(real-obj-m)</span>)</span><br><span class="line">single-used-m   := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(single-used-m)</span>)</span><br><span class="line">multi-used-m    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(multi-used-m)</span>)</span><br><span class="line">subdir-ym   := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(obj)</span>/,$(subdir-ym)</span>)</span><br></pre></td></tr></table></figure>

<p>文件的处理最后，给所有的变量加上相应的路径，以便编译的时候进行索引。</p>
<p><code>Makefile.lib </code>通常都被包含在于<code> Makefile.build</code>中，这个变量继承了<code>Makefile.build</code>的 <code>obj </code>变量。而 <code>Makefile.build </code>的<code>obj</code>变量则是通过调用 <code>$(build) </code>时进行赋值的。</p>
<h3><span id="9-5-scripts-makefile-build-wen-jian-zuo-yong">9.5 <code>scripts/Makefile.build</code>文件作用</span><a href="#9-5-scripts-makefile-build-wen-jian-zuo-yong" class="header-anchor">#</a></h3><h4><span id="9-5-1-bao-han-include-config-auto-conf">9.5.1 包含<code> include/config/auto.conf</code></span><a href="#9-5-1-bao-han-include-config-auto-conf" class="header-anchor">#</a></h4><p>包含<code>include/config/auto.conf</code>文件，这个文件的内容是这样的：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CONFIG_RING_BUFFER=y</span><br><span class="line">CONFIG_HAVE_ARCH_SECCOMP_FILTER=y</span><br><span class="line">CONFIG_SND_PROC_FS=y</span><br><span class="line">CONFIG_SCSI_DMA=y</span><br><span class="line">CONFIG_TCP_MD5SIG=y</span><br><span class="line">CONFIG_KERNEL_GZIP=y</span><br></pre></td></tr></table></figure>

<h4><span id="9-5-2-bao-han-scripts-kbuild-include">9.5.2 包含<code> scripts/Kbuild.include</code></span><a href="#9-5-2-bao-han-scripts-kbuild-include" class="header-anchor">#</a></h4><h4><span id="9-5-3-chu-li-bian-yi-mu-biao">9.5.3 处理编译目标</span><a href="#9-5-3-chu-li-bian-yi-mu-biao" class="header-anchor">#</a></h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#主机程序，在前期的准备过程中可能需要用到，比如make menuconfig时需要准备命令行的图形配置。</span></span><br><span class="line"><span class="keyword">ifneq</span> ($(hostprogs-y)$(hostprogs-m)$(hostlibs-y)$(hostlibs-m)$(hostcxxlibs-y)$(hostcxxlibs-m),)</span><br><span class="line"><span class="keyword">include</span> scripts/Makefile.host</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断obj，如果obj没有指定则给出警告 </span></span><br><span class="line"><span class="keyword">ifndef</span> obj</span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> kbuild: Makefile.build is included improperly)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果有编译库的需求，则给lib-target赋值，并将 $(obj)/lib-ksyms.o 追加到 real-obj-y 中。 </span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> $(lib-y)</span> $(lib-m) $(lib-)),)</span><br><span class="line">lib-target := <span class="variable">$(obj)</span>/lib.a</span><br><span class="line">real-obj-y += <span class="variable">$(obj)</span>/lib-ksyms.o</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要编译 将要编译进内核(也就是obj-y指定的文件) 的模块，则赋值 builtin-target </span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(<span class="built_in">strip</span> $(real-obj-y)</span> $(need-builtin)),)</span><br><span class="line">builtin-target := <span class="variable">$(obj)</span>/built-in.a</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果定义了 CONFIG_MODULES，则赋值 modorder-target。</span></span><br><span class="line"><span class="keyword">ifdef</span> CONFIG_MODULES</span><br><span class="line">modorder-target := <span class="variable">$(obj)</span>/modules.order</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p><code>modorder-target</code>将被赋值为<code>$(obj)/modules.order</code>，<code> module.order</code>这个文件记录了可加载模块在<code>Makefile</code>中出现的顺序，主要是提供给modprobe程序在匹配时使用。</p>
<h4><span id="9-5-4-mo-ren-bian-yi-mu-biao-build">9.5.4 默认编译目标<code>_build</code></span><a href="#9-5-4-mo-ren-bian-yi-mu-biao-build" class="header-anchor">#</a></h4><p>例子见<code>12.3.1.1.1</code>。</p>
<h5><span id="9-5-4-1builtin-target">9.5.4.1<code>builtin-target</code></span><a href="#9-5-4-1builtin-target" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(builtin-target): $(real-obj-y) FORCE</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,ar_builtin)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">real-prereqs = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>, <span class="variable">$^</span>)</span></span><br><span class="line">cmd_ar_builtin = rm -f <span class="variable">$@</span>; <span class="variable">$(AR)</span> rcSTP<span class="variable">$(KBUILD_ARFLAGS)</span> <span class="variable">$@</span> $(real-prereqs)</span><br></pre></td></tr></table></figure>

<p><code>ar_builtin</code>就是执行<code>cmd_ar_builtin</code>, 就是使用<code>ar</code>指令打包成<code> $(builtin-target)</code>,也就是<code>$(obj)/built-in.a</code>。它的依赖文件被保存在 <code>$(real-obj-y) </code>中。</p>
<p><code>$(real-obj-y) </code>在<code>scritps/Makefile.lib</code>被处理出来的变量, 对应目录下的所有目标文件，不包含文件夹。</p>
<h5><span id="9-5-4-2-lib-target">9.5.4.2 <code>lib-target</code></span><a href="#9-5-4-2-lib-target" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(lib-target): $(lib-y) FORCE</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed,ar)</span></span><br></pre></td></tr></table></figure>

<p>同理，最终将调用<code>cmd_ar</code>命令:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">real-prereqs = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>, <span class="variable">$^</span>)</span></span><br><span class="line">cmd_ar = rm -f <span class="variable">$@</span>; <span class="variable">$(AR)</span> rcsTP<span class="variable">$(KBUILD_ARFLAGS)</span> <span class="variable">$@</span> $(real-prereqs)</span><br></pre></td></tr></table></figure>

<p>将本模块中的目标全部打包成<code>$(lib-target)</code>,也就是 <code>$(obj)/lib.a</code></p>
<h5><span id="9-5-4-3-extra-y">9.5.4.3 <code>extra-y</code></span><a href="#9-5-4-3-extra-y" class="header-anchor">#</a></h5><p><code>$(extra-y) </code>在<code>Makefile.lib</code>中被确定，主要负责<code>dtb</code>相关的编译:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">extra-y             += $(dtb-y)</span><br><span class="line">extra-<span class="variable">$(CONFIG_OF_ALL_DTBS)</span> += $(dtb-)</span><br></pre></td></tr></table></figure>

<p><code>Makefile.lib</code> 中可以找到对应的实现:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>/%.dtb: <span class="variable">$(src)</span>/%.dts <span class="variable">$(DTC)</span> FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed_dep,dtc,dtb)</span></span><br></pre></td></tr></table></figure>

<p>调用了<code> cmd_dtc</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_dtc = mkdir -p <span class="variable">$(<span class="built_in">dir</span> $&#123;dtc-tmp&#125;)</span> ; \</span><br><span class="line">    <span class="variable">$(HOSTCC)</span> -E <span class="variable">$(dtc_cpp_flags)</span> -x assembler-with-cpp -o $(dtc-tmp) <span class="variable">$&lt;</span> ; \</span><br><span class="line"></span><br><span class="line">    <span class="variable">$(DTC)</span> -O $(2) -o <span class="variable">$@</span> -b 0 \</span><br><span class="line">        <span class="variable">$(<span class="built_in">addprefix</span> -i,$(<span class="built_in">dir</span> <span class="variable">$&lt;</span>)</span> <span class="variable">$(DTC_INCLUDE)</span>) <span class="variable">$(DTC_FLAGS)</span> \</span><br><span class="line">        -d <span class="variable">$(depfile)</span>.dtc.tmp $(dtc-tmp) ; \</span><br><span class="line"></span><br><span class="line">    cat <span class="variable">$(depfile)</span>.pre.tmp <span class="variable">$(depfile)</span>.dtc.tmp &gt; <span class="variable">$(depfile)</span></span><br></pre></td></tr></table></figure>

<p><code>$(2) </code>为 dtb，<code>-O dtb </code>表示输出文件格式为 dtb 。<code> -o $@</code>, <code>$@ </code>为目标文件，表示输出目标文件，输入文件则是对应的<code> $&lt;</code>。</p>
<h5><span id="9-5-4-4-obj-m">9.5.4.4 <code>obj-m</code></span><a href="#9-5-4-4-obj-m" class="header-anchor">#</a></h5><p>由于它是一系列的 .o 文件，所以它的编译是通过模式规则的匹配完成的。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(obj)</span>/%.o: <span class="variable">$(src)</span>/%.c <span class="variable">$(recordmcount_source)</span> <span class="variable">$(objtool_dep)</span> FORCE</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,force_checksrc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> if_changed_rule,cc_o_c)</span></span><br></pre></td></tr></table></figure>

<p>执行<code>rule_cc_o_c</code>:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> rule_cc_o_c</span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,checksrc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd_and_fixdep,cc_o_c)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,gen_ksymdeps)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,checkdoc)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,objtool)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,modversions_c)</span></span><br><span class="line">    <span class="variable">$(<span class="built_in">call</span> cmd,record_mcount)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>cmd 函数其实就是执行 <code>cmd_$1</code>,那么也就是上述命令中分别执行 <code>cmd_checksrc,cmd_gen_ksymdeps</code>等等。</p>
<p>其中最重要的指令就是 ： <code>$(call cmd_and_fixdep,cc_o_c)</code>，它对目标文件执行了 <code>fixdep</code>，生成依赖文件，然后执行了<code> cmd_cc_o_c</code>, 这个命令就是真正的编译指令:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cmd_cc_o_c = <span class="variable">$(CC)</span> <span class="variable">$(c_flags)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>

<h5><span id="9-5-4-5-modorder-target">9.5.4.5 modorder-target</span><a href="#9-5-4-5-modorder-target" class="header-anchor">#</a></h5><p><code>modorder-target值为</code> $(obj)&#x2F;modules.order<code>，也就是大多数目录下都存在这么一个 </code>modules.orders &#96;文件，来提供一个该目录下编译模块的列表。 </p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(modorder-target): $(subdir-ym) FORCE</span></span><br><span class="line">    <span class="variable">$(Q)</span>(cat /dev/null; $(modorder-cmds)) &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">modorder-cmds =                     \</span><br><span class="line">    <span class="variable">$(<span class="built_in">foreach</span> m, <span class="variable">$(modorder)</span>,           \</span></span><br><span class="line"><span class="variable">        $(<span class="built_in">if</span> $(<span class="built_in">filter</span> %/modules.order, $m)</span>, \</span><br><span class="line">            cat $m;, echo kernel/$m;))</span><br></pre></td></tr></table></figure>

<p>该操作的目的就是将需要编译的<code>.ko</code>的模块以<code>kernel/$(dir)/*.ko</code>为名记录到 <code>obj-m </code>指定的目录下。</p>
<h5><span id="9-5-4-6-subdir-ym">9.5.4.6 subdir-ym</span><a href="#9-5-4-6-subdir-ym" class="header-anchor">#</a></h5><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$(subdir-ym):</span></span><br><span class="line">    <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span> need-builtin=<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">findstring</span> <span class="variable">$@</span>,$(subdir-obj-y)</span>),1)</span><br></pre></td></tr></table></figure>

<p>这就是Kbuild递归遍历子目录编译的策略，对于每个需要递归进入编译的目录，都调用：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=<span class="variable">$@</span> need-builtin=<span class="variable">$(<span class="built_in">if</span> $(<span class="built_in">findstring</span> <span class="variable">$@</span>,$(subdir-obj-y)</span>),1)</span><br></pre></td></tr></table></figure>

<h2><span id="10-she-zhi-jiao-cha-bian-yi-qi">10 设置交叉编译器</span><a href="#10-she-zhi-jiao-cha-bian-yi-qi" class="header-anchor">#</a></h2><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/21.png" alt="image"></p>
<h2><span id="11-he-xin-bian-liang-dao-chu">11 核心变量导出</span><a href="#11-he-xin-bian-liang-dao-chu" class="header-anchor">#</a></h2><p>在顶层 Makefile 会导出很多变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> VERSION PATCHLEVEL SUBLEVEL UBOOTRELEASE UBOOTVERSION</span><br><span class="line"><span class="built_in">export</span> ARCH CPU BOARD VENDOR SOC CPUDIR BOARDDIR</span><br><span class="line"><span class="built_in">export</span> CONFIG_SHELL HOSTCC HOSTCFLAGS HOSTLDFLAGS CROSS_COMPILE AS LD CC</span><br><span class="line"><span class="built_in">export</span> CPP AR NM LDR STRIP OBJCOPY OBJDUMP</span><br><span class="line"><span class="built_in">export</span> MAKE AWK PERL PYTHON</span><br><span class="line"><span class="built_in">export</span> HOSTCXX HOSTCXXFLAGS DTC CHECK CHECKFLAGS</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> KBUILD_CPPFLAGS NOSTDINC_FLAGS UBOOTINCLUDE OBJCOPYFLAGS LDFLAGS</span><br><span class="line"><span class="built_in">export</span> KBUILD_CFLAGS KBUILD_AFLAGS</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/22.png" alt="image"><br>打印出export的这些变量：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/23.png" alt="image"><br>①这些变量来自<code>config.mk</code>，里面定义了<code>ARCH,CPU,BOARD,VENDOR,SOC，BOARDDIR</code>等变量。变 量 <code>ARCH </code>， 值 为 <code>$(CONFIG_SYS_ARCH:&quot;%&quot;=%)</code> ， 也 就 是 提 取<code> CONFIG_SYS_ARCH</code> 里面双引号“”之间的内容。比如 <code>CONFIG_SYS_ARCH=“arm”</code>的话， <code>ARCH=arm</code>。经过展开确定了<code>CPUDIR=arch/arm/cpu/armv7</code>。<br>②这里有一个<code>sinclude</code>指令，<code>sinclude 和 include </code>的功能类似，在 Makefile 中都是读取指定文件内容，这里读取 文件<code>$(srctree)/arch/$(ARCH)/config.mk </code>的内容。<code>sinclude </code>读取的文件如果不存在的话不会报错。<br>③依次包含<code>arch,cpu,soc，vendor,board</code>相关的<code>config.mk</code><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/24.png" alt="image"><br><code>.config</code>如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/25.png" alt="image"></p>
<h2><span id="12-make-xxx-defconfig-pei-zhi-guo-cheng">12 <code>make xxx_defconfig</code> 配置过程</span><a href="#12-make-xxx-defconfig-pei-zhi-guo-cheng" class="header-anchor">#</a></h2><p>输入命令进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig</span><br></pre></td></tr></table></figure>
<p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/26.png" alt="image"></p>
<h3><span id="12-1-chan-sheng-ban-ben-ri-qi-xin-xi">12.1 产生版本日期信息</span><a href="#12-1-chan-sheng-ban-ben-ri-qi-xin-xi" class="header-anchor">#</a></h3><p>先产生<code>version_h和timestamp_h</code>。<code>version_h</code>记录uboot版本和编译器版本。<code>timestamp_h</code>记录uboot的日期时间戳信息。打开这两个头文件：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/27.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/28.png" alt="image"></p>
<h3><span id="12-2-pei-zhi-bian-liang">12.2 配置变量</span><a href="#12-2-pei-zhi-bian-liang" class="header-anchor">#</a></h3><p><code>MAKECMDGOALS </code>是 make 的一个环境变量，这个变量会保存你所指 定的终极目标列表，比如执行<code>make mx6ull_alientek_emmc_defconfig</code>，那么 <code>MAKECMDGOALS </code>就为 <code>mx6ull_alientek_emmc_defconfig</code>。<code>filter</code>函数将 <code>MAKECMDGOALS</code> 中符合<code>no-dot-config-targets</code>的部分过滤出来，可以看到为空，所以<code>dot-config</code>还是等于1.</p>
<p><code>KBUILD_EXTMOD</code>前面提到没有编译子模块，<code>KBUILD_EXTMOD</code>为空，进入，在判断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifneq ($(filter config %config,$(MAKECMDGOALS),)</span><br></pre></td></tr></table></figure>
<p>当<code>make mx6ull_alientek_emmc_defconfig</code>, 明显过滤出来不为空，因此<code>config-targets=1</code>.</p>
<p><code>words $(MAKECMDGOALS)</code>等于1，最后得到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config-targets = 1</span><br><span class="line">mixed-targets = 0</span><br><span class="line">dot-config = 1</span><br></pre></td></tr></table></figure>

<h3><span id="12-3-zhi-xing-3-ge-yi-lai">12.3 执行3个依赖</span><a href="#12-3-zhi-xing-3-ge-yi-lai" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/29.png" alt="image"><br><code>KBUILD_DEFCONFIG</code>等于<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，<code> KBUILD_KCONFIG</code>等于空，导出。<br>匹配到<code>%config</code>， 执行<code>scripts_basic、outputmakefile 和 FORCE </code>3个依赖.<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/30.png" alt="image"></p>
<h4><span id="12-3-1-scripts-basic">12.3.1 <code>scripts_basic</code></span><a href="#12-3-1-scripts-basic" class="header-anchor">#</a></h4><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/31.png" alt="image"></p>
<p><code>scripts/Kbuild.include</code>定义了<code>build</code>变量。<code>$Q$(MAKE) $(build)=scripts/basic</code>展开<code>build</code>变量后得：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/basic</span><br></pre></td></tr></table></figure>

<h5><span id="12-3-1-1-scripts-makefile-build">12.3.1.1 <code>scripts/Makefile.build</code></span><a href="#12-3-1-1-scripts-makefile-build" class="header-anchor">#</a></h5><p><code>scripts_basic </code>会调用文件<code>./scripts/Makefile.build</code>,打开这个文件：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/32.png" alt="image"></p>
<p>这里<code>$(obj)=scripts/basic, patsubst </code>是替换函数在<code>scripts/basic</code>中查找符合<code>tpl/%</code>的部分，然后将<code>tpl/</code>取消掉，但是 <code>scripts/basic</code>没有<code>tpl/</code>，所以<code> src= scripts/basic</code>。两个<code>ifeq ($(obj),$(src))</code>都满足条件，最终<code>prefix等于.</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/33.png" alt="image"><br><code>kbuild-dir </code>展开后为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> $(filter /%, scripts/basic), scripts/basic, ./scripts/basic)</span><br></pre></td></tr></table></figure>
<p>因为没有以<code>/</code>为开头的单词，所以<code>$(filter /%, scripts/basic)</code>的结果为空，<code>kbuilddir=./scripts/basic</code>。<br><code>kbuild-file </code>展开后为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> $(wildcard ./scripts/basic/Kbuild), ./scripts/basic/Kbuild, ./scripts/basic/Makefile)</span><br></pre></td></tr></table></figure>
<p><code>scrpts/basic </code>目录中没有<code>Kbuild</code>这个文件，所以<code> kbuild-file= ./scripts/basic/Makefile</code>.<br><code>scripts/Makefile.build</code>文件包含<code>/scripts/basic/Makefile</code></p>
<h6><span id="12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build">12.3.1.1.1 找到默认目标<code>_build</code></span><a href="#12-3-1-1-1-zhao-dao-mo-ren-mu-biao-build" class="header-anchor">#</a></h6><p>再继续分析<code>scripts/Makefile.build</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/34.png" alt="image"></p>
<p><code>__build </code>是默认目标，因为命令<code>@make -f ./scripts/Makefile.build obj=scripts/basic</code>没有指定目标，所以会使用到默认目标：<code>__build</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/35.png" alt="image"></p>
<p>顶层 Makefile 中，<code>KBUILD_BUILTIN 为 1</code>， <code>KBUILD_MODULES 为 0</code>，因此展开后目标<code>__build </code>为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)</span><br><span class="line">@:</span><br></pre></td></tr></table></figure>
<p>直接打印出这5个目标：所以最终只有一个依赖<code>scripts/basic/fixdep</code>要执行，产生<code>fixdep</code>.<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/36.png" alt="image"></p>
<p>执行打印如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/37.png" alt="image"><br>至此第一个依赖<code>scripts_basic</code>就结束了。<br>总结：<code>scripts_basic</code>就是利用<code>scripts/Makefile.build</code>去找到<code>_build</code>目标，然后去<code>scripts/basic</code>目录编译出<code>fixdep</code>.</p>
<h4><span id="12-3-2-outputmakefile">12.3.2 <code>outputmakefile</code></span><a href="#12-3-2-outputmakefile" class="header-anchor">#</a></h4><p>由于<code>KBUILD_SRC</code>为空，不执行。否则会为源码路径创建<code>source</code>这个符号链接，执行<code>mkmakefile</code>。</p>
<h4><span id="12-3-3-force">12.3.3 <code>FORCE</code></span><a href="#12-3-3-force" class="header-anchor">#</a></h4><p>Makefile最底下定了<code>FORCE</code>目标，可以看到什么都不执行。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/38.png" alt="image"></p>
<p>FORCE的作用：</p>
<p>可以看到它也是一个目标，没有依赖文件且没有命令部分，由于它没有命令生成FORCE，所以每次都会被更新。</p>
<p>所以它的作用就是：FORCE作为依赖时，就导致依赖列表中每次都有FORCE依赖被更新，导致目标每次被重新编译生成。</p>
<h3><span id="12-4-chan-sheng-config">12.4 产生<code>.config</code></span><a href="#12-4-chan-sheng-config" class="header-anchor">#</a></h3><p>回到<code>%config </code>处：<br><code>$(Q)$(MAKE) $(build)=scripts/kconfig $@</code>展开后</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make -f ./scripts/Makefile.build obj=scripts/kconfig mx6ull_14x14_ddr512_emmc_defconfig</span><br></pre></td></tr></table></figure>

<p>再次进入<code>scripts/Makefile.build， 用echo</code>得到一些变量值:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kbuild-dir = ./scripts/kconfig</span><br><span class="line">kbuild-file = ./scripts/kconfig/Makefile</span><br><span class="line">include ./scripts/kconfig/Makefile</span><br></pre></td></tr></table></figure>
<p>打开<code>./scripts/kconfig/Makefile</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/39.png" alt="image"><br><code>%_defconfig: $(obj)/conf</code>匹配到我们的<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，先编译依赖<code>scripts/kconfig/conf</code>,编译生成<code>scripts/kconfig/conf</code>如下：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/40.png" alt="image"><br>最终利用<code>conf</code>工具从<code>configs</code>目录找到<code>mx6ull_14x14_ddr512_emmc_defconfig</code>，将配置写成<code>.config</code>文件。<br>总结<code>defconfig</code>配置过程：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91defconfig%E5%88%86%E6%9E%90/41.png" alt="image"></p>
<h3><span id="12-5-zhi-zuo-defconfig">12.5 制作<code>defconfig</code></span><a href="#12-5-zhi-zuo-defconfig" class="header-anchor">#</a></h3><p>如果没有对应的<code>defconfig</code>可以找一个与自己板级信息类似的defconfig生成一个<code>.config</code>，再通过<code>menuconfig</code>来完成自己board的配置，并最后通过<code>savedefconfig</code>保存为自己<code>board的defconfig</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">make CROSS_COMPILE=aarch64-linux-gnu- evb-rk3399_defconfig</span><br><span class="line">make menuconfig</span><br><span class="line">make savedefconfig</span><br><span class="line">cp defconfig configs/my_defconfig</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-编译过程Make分析</title>
    <url>/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-make-guo-cheng">1 Make过程</a><ul>
<li><a href="#1-1-zhao-dao-all-y-yi-lai">1.1 找到<code>$(ALL-y)</code>依赖</a></li>
<li><a href="#1-2-bian-yi-u-boot-bin">1.2 编译<code>u-boot.bin</code></a><ul>
<li><a href="#1-2-1-config-of-separate-de-zuo-yong">1.2.1 <code>CONFIG_OF_SEPARATE</code>的作用</a></li>
<li><a href="#1-2-2-if-changed-jie-shi">1.2.2 <code>if_changed</code>解释</a></li>
<li><a href="#1-2-3-head-y-yin-ru">1.2.3 <code>head-y</code>引入</a></li>
<li><a href="#1-2-3-libs-y-yin-ru">1.2.3 <code>libs-y</code>引入</a></li>
<li><a href="#1-2-4-u-boot-lds-yin-ru">1.2.4 <code>u-boot.lds</code>引入</a></li>
<li><a href="#1-2-4-zong-jie">1.2.4 总结</a></li>
<li><a href="#1-2-5-make-wan-zheng-log">1.2.5 make完整log</a><ul>
<li><a href="#1-2-5-1-distclean">1.2.5.1 distclean</a></li>
<li><a href="#1-2-5-2-xxx-defconfig">1.2.5.2 xxx_defconfig</a></li>
<li><a href="#1-2-5-3-make">1.2.5.3 make</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-make-guo-cheng">1 Make过程</span><a href="#1-make-guo-cheng" class="header-anchor">#</a></h1><h2><span id="1-1-zhao-dao-all-y-yi-lai">1.1 找到<code>$(ALL-y)</code>依赖</span><a href="#1-1-zhao-dao-all-y-yi-lai" class="header-anchor">#</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1</span><br></pre></td></tr></table></figure>
<p>没有指定编译目标，使用第一个目标：<code>_all</code>。这 里 不 编 译 模 块 ， 所 以 <code>KBUILD_EXTMOD </code>肯定为空，<code>_all </code>的依赖就是<code> all</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/1.png" alt="image"><br>首先编译<code>all</code>目标，<code>$(ALL-y)</code>展开为<code>u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check</code> 。<br>因此先编译所有依赖，<code>$(ALL-y)</code><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/2.png" alt="image"><br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/3.png" alt="image"><br>根据 uboot 的配置情况也可能包含其他的文件，比如：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-<span class="variable">$(CONFIG_ONENAND_U_BOOT)</span> += u-boot-onenand.bin</span><br></pre></td></tr></table></figure>
<p><code>CONFIG_ONENAND_U_BOOT</code> 就是 uboot 中跟<code>ONENAND</code>配置有关的，如果我们使能了<code> ONENAND</code>，那么在<code>.config </code>配置文件中就会有<code>CONFIG_ONENAND_U_BOOT=y</code>这一句。因此展开以后就是：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-y += u-boot-onenand.bin</span><br></pre></td></tr></table></figure>
<p>同理，只要是.config配置了CONFIG_XXXX&#x3D;y,那么就会有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-<span class="variable">$(CONFIG_XXXX)</span> += xxxx.bin</span><br></pre></td></tr></table></figure>
<p>因此展开以后就有：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ALL-y += xxxx.bin</span><br></pre></td></tr></table></figure>
<h2><span id="1-2-bian-yi-u-boot-bin">1.2 编译<code>u-boot.bin</code></span><a href="#1-2-bian-yi-u-boot-bin" class="header-anchor">#</a></h2><p><code>ALL-y </code>里面有个<code> u-boot.bin</code>，这个就是我们最终需要的 uboot 二进制可执行文件。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/4.png" alt="image"><br>由于我们没配置<code>CONFIG_OF_SEPARATE</code>，因此走else流程。<br><code>u-boot.bin </code>依赖于<code> u-boot-nodtb.bin</code>，命令为<code>$(call if_changed,copy) </code>，<code>if_changed </code>是 一 个 函 数 ， 这 个 函 数 在 <code>scripts/Kbuild.include </code>中有定义，顶层 Makefile 中会包含 <code>scripts/Kbuild.include </code>文件。</p>
<h3><span id="1-2-1-config-of-separate-de-zuo-yong">1.2.1 <code>CONFIG_OF_SEPARATE</code>的作用</span><a href="#1-2-1-config-of-separate-de-zuo-yong" class="header-anchor">#</a></h3><p>uboot与dtb可以有以下几种打包组合方式：<br>（1）若定义了<code>CONFIG_OF_EMBED</code>选项，则在链接时会为dtb指定一个以<code>__dtb_dt_begin</code>开头的单独的段，dtb的内容将被直接链接到<code>uboot.bin</code>镜像中。官方建议这种方式只在开发和调试阶段使用，而不要用于生产阶段。<br>（2）若定义了<code>CONFIG_OF_SEPARATE</code>选项，dtb将会被编译为<code>u-boot.dtb</code>文件，而uboot原始镜像被编译为<code>u-boot-nodtb.bin</code>文件，并通过以下命令将它们连接为最终的<code>uboot.bin</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">cat u-boot-nodtb.bin u-boot.dtb &gt;uboot.bin</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-2-if-changed-jie-shi">1.2.2 <code>if_changed</code>解释</span><a href="#1-2-2-if-changed-jie-shi" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/5.png" alt="image"><br>判断<code>if $(strip $(any-prereq) $(arg-check))</code>条件，如果不为空，则<code>if_changed</code>等于：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">@set -e;                                                             		\</span><br><span class="line">	$(echo-cmd) $(cmd_$(1));                                             \</span><br><span class="line">	printf &#x27;%s\n&#x27; &#x27;cmd_<span class="variable">$@</span> := $(make-cmd)&#x27; &gt; $(dot-target).cmd)</span><br></pre></td></tr></table></figure>
<p>利用<code>strip</code>函数将首尾空格去掉，也把字符串中间的空格整理一下。最后输出的值，是以空格为间隔的一个个字符串。<br><code>set -e</code>指的是当其后的shell命令若返回值为非0，则直接错误退出，不再往下执行了。<br><code>dot-target</code>定义如下:<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/6.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">any-prereq = <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>,<span class="variable">$?</span>)</span> <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span> $(<span class="built_in">wildcard</span> <span class="variable">$^</span>)</span>,<span class="variable">$^</span>)</span><br></pre></td></tr></table></figure>
<p>来分析下这个<code>any-prereq</code>：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">1. <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span>,<span class="variable">$?</span>)</span></span><br><span class="line">2. <span class="variable">$(<span class="built_in">filter</span>-out <span class="variable">$(PHONY)</span> $(<span class="built_in">wildcard</span> <span class="variable">$^</span>)</span>,<span class="variable">$^</span>)</span><br></pre></td></tr></table></figure>
<p><code>filter-out</code>函数，是将第一组参数里面的值，从第二组排除掉。<br><code>$?</code>变量表示所有比目标文件更新的依赖文件列表，<code>$(PHONY)</code>伪目标声明的所有变量。<br>因此第一条结果就是：所有比目标新的依赖并且不包含伪目标。<br><code>$^</code>表示所有依赖，因此第二条结果表示：从依赖列表种排除所有伪依赖和已经生成的依赖，也就是新依赖。</p>
<p>来分析下这个<code>arg-check</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/7.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span>：是Makefile目标, $(1)表示函数的第一个参数。</span><br></pre></td></tr></table></figure>
<p>总结：当依赖比目标新的时候，或者命令有改变的时候，<code>if_changed </code>就会执行一些命令。</p>
<p>比如下图：当最后链接的时候：<code>cmd_u-boot</code>这条命令就会给到<code>if_changed</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/8.png" alt="image"><br>执行<code>if_changed</code>得到<code>u-boot</code>后再调用<code>obj-copy</code>得到<code>u-boot-nodtb.bin</code>。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/9.png" alt="image"></p>
<h3><span id="1-2-3-head-y-yin-ru">1.2.3 <code>head-y</code>引入</span><a href="#1-2-3-head-y-yin-ru" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/10.png" alt="image"><br>从下图看到<code>uboot.bin</code>其实就是等于<code>uboot-nodtb.bin</code>,只是一个拷贝：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/11.png" alt="image"><br>下图可以看到编译u-boot又依赖<code>$(u-boot-init) $(u-boot-main) u-boot.lds</code>：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/12.png" alt="image"><br><code>u-boot_init </code>和 <code>u-boot-main </code>是两个 变量，在顶层 Makefile 中有定义：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/13.png" alt="image"></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">head-y 在 arch/arm/Makefile 中 被指定为：</span><br><span class="line">head-y := arch/arm/cpu/armv7/start.o</span><br><span class="line">因此u-boot-init= arch/arm/cpu/armv7/start.o</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-3-libs-y-yin-ru">1.2.3 <code>libs-y</code>引入</span><a href="#1-2-3-libs-y-yin-ru" class="header-anchor">#</a></h3><p><code>$(libs-y)</code>在顶层 Makefile 中被定义为 uboot 所有子目录下<code>build-in.o</code>的集合。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/14.png" alt="image"><br>从上面的代码可以看出，<code>libs-y </code>都是 uboot 各子目录的集合，最后：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">libs-y := <span class="variable">$(<span class="built_in">patsubst</span> %/, %/built-in.o, $(libs-y)</span>)</span><br><span class="line">函数 patsubst，将 libs-y 中的“/”替换为”/built-in.o，那么最终libs-y就是所有目录的built-in.o集合。</span><br></pre></td></tr></table></figure>

<p>举个例子：<br>以 <code>drivers/gpio/built-in.o </code>为例，在<code> drivers/gpio/</code>目录下会有个名为<code>.built-in.o.cmd </code>的文件，里面存放了要得到<code>built-in.o</code>需要执行的命令：<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/15.png" alt="image"><br><code>drivers/gpio/built-in.o </code>这个文件是使用<code>ld</code>命 令由文件<code> drivers/gpio/mxc_gpio.o</code>生成而来的，<code>mxc_gpio.o </code>是 <code>mxc_gpio.c </code>编译生成的<code>.o </code>文件， 这个是 NXP 的 I.MX 系列的 GPIO 驱动文件。<br>这里用到了<code>ld</code>的<code>“-r”</code>参数，参数含义如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-r –relocateable: 产生可重定向的输出.</span><br><span class="line">比如，产生一个输出文件它可再次作为‘ld’的输入，这经常被叫做“部分链接”，</span><br><span class="line">当我们需要将几个小的.o 文件链接成为一个.o 文件的时候，需要使用此选项。</span><br></pre></td></tr></table></figure>
<h3><span id="1-2-4-u-boot-lds-yin-ru">1.2.4 <code>u-boot.lds</code>引入</span><a href="#1-2-4-u-boot-lds-yin-ru" class="header-anchor">#</a></h3><p>前面编译得到<code>u-boot-init 和u-boot-main</code>是为了得到<code>arch/arm/cpu/armv7/start.o</code>和各个子目录 下的 <code>built-in.o</code>，最后通过<code>-T u-boot.lds</code>来链接成一个u-boot。<br><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/16.png" alt="image"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/armv7/start.o --start-group</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/cpu/armv7/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/imx-common/built-in.o</span><br><span class="line"><span class="built_in">arch</span>/arm/lib/built-in.o</span><br><span class="line">board/freescale/common/built-in.o</span><br><span class="line">board/freescale/mx6ullevk/built-in.o  cmd/built-in.o  common/built-in.o  disk/built-in.o  drivers/built-in.o  drivers/dma/built-in.o  drivers/gpio/built-in.o  drivers/i2c/built-in.o  drivers/mmc/built-in.o  drivers/mtd/built-in.o  drivers/mtd/onenand/built-in.o  drivers/mtd/spi/built-in.o  drivers/net/built-in.o  drivers/net/phy/built-in.o  drivers/pci/built-in.o  drivers/power/built-in.o  drivers/power/battery/built-in.o  drivers/power/fuel_gauge/built-in.o  drivers/power/mfd/built-in.o  drivers/power/pmic/built-in.o  drivers/power/regulator/built-in.o  drivers/serial/built-in.o  drivers/spi/built-in.o  drivers/usb/dwc3/built-in.o  drivers/usb/emul/built-in.o  drivers/usb/eth/built-in.o  drivers/usb/gadget/built-in.o  drivers/usb/gadget/udc/built-in.o  drivers/usb/host/built-in.o  drivers/usb/musb-new/built-in.o  drivers/usb/musb/built-in.o  drivers/usb/phy/built-in.o  drivers/usb/ulpi/built-in.o  fs/built-in.o  lib/built-in.o  net/built-in.o  <span class="built_in">test</span>/built-in.o  <span class="built_in">test</span>/dm/built-in.o</span><br><span class="line">--end-group <span class="built_in">arch</span>/arm/lib/eabi_compat.o</span><br><span class="line">-L /home/book/ftp/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0</span><br><span class="line">-lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>可以看出最终是用 <code>arm-linux-gnueabihf-ld.bfd 命令将 </code>arch&#x2F;arm&#x2F;cpu&#x2F;armv7&#x2F;start.o <code>和其他众多 的</code> built_in.o &#96;链接在一起，形成 u-boot。</p>
<h3><span id="1-2-4-zong-jie">1.2.4 总结</span><a href="#1-2-4-zong-jie" class="header-anchor">#</a></h3><p><img src="/2024/06/22/uboot-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8BMake%E5%88%86%E6%9E%90/17.png" alt="image"><br>首先要找到<code>_all</code>目标，找到<code>ALL-y</code>依赖，最终会发现要编译<code>u-boot.bin</code>，又依赖要先编译<code>u-boot</code>。<br>然后<code>u-boot</code>又会依赖<code>u-boot-init</code>和<code> u-boot-main</code>，等得到<code>start.o</code>和所有依赖的<code>built-in.o</code>后，结合<code>u-boot.lds</code>链接成u-boot。</p>
<h3><span id="1-2-5-make-wan-zheng-log">1.2.5 make完整log</span><a href="#1-2-5-make-wan-zheng-log" class="header-anchor">#</a></h3><h4><span id="1-2-5-1-distclean">1.2.5.1 distclean</span><a href="#1-2-5-1-distclean" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make distclean V=1
make -f ./scripts/Makefile.clean obj=api
make -f ./scripts/Makefile.clean obj=cmd
make -f ./scripts/Makefile.clean obj=common
make -f ./scripts/Makefile.clean obj=common/init
make -f ./scripts/Makefile.clean obj=disk
make -f ./scripts/Makefile.clean obj=drivers
make -f ./scripts/Makefile.clean obj=drivers/adc
make -f ./scripts/Makefile.clean obj=drivers/bios_emulator
make -f ./scripts/Makefile.clean obj=drivers/block
make -f ./scripts/Makefile.clean obj=drivers/bootcount
make -f ./scripts/Makefile.clean obj=drivers/clk
make -f ./scripts/Makefile.clean obj=drivers/clk/uniphier
make -f ./scripts/Makefile.clean obj=drivers/core
make -f ./scripts/Makefile.clean obj=drivers/cpu
make -f ./scripts/Makefile.clean obj=drivers/crypto
make -f ./scripts/Makefile.clean obj=drivers/crypto/fsl
make -f ./scripts/Makefile.clean obj=drivers/crypto/rsa_mod_exp
make -f ./scripts/Makefile.clean obj=drivers/ddr/microchip
make -f ./scripts/Makefile.clean obj=drivers/demo
make -f ./scripts/Makefile.clean obj=drivers/dfu
make -f ./scripts/Makefile.clean obj=drivers/fpga
make -f ./scripts/Makefile.clean obj=drivers/hwmon
make -f ./scripts/Makefile.clean obj=drivers/input
make -f ./scripts/Makefile.clean obj=drivers/led
make -f ./scripts/Makefile.clean obj=drivers/memory
make -f ./scripts/Makefile.clean obj=drivers/misc
make -f ./scripts/Makefile.clean obj=drivers/pch
make -f ./scripts/Makefile.clean obj=drivers/pcmcia
make -f ./scripts/Makefile.clean obj=drivers/pinctrl
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/nxp
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/rockchip
make -f ./scripts/Makefile.clean obj=drivers/pinctrl/uniphier
make -f ./scripts/Makefile.clean obj=drivers/pwm
make -f ./scripts/Makefile.clean obj=drivers/qe
make -f ./scripts/Makefile.clean obj=drivers/ram
make -f ./scripts/Makefile.clean obj=drivers/remoteproc
make -f ./scripts/Makefile.clean obj=drivers/rtc
make -f ./scripts/Makefile.clean obj=drivers/soc
make -f ./scripts/Makefile.clean obj=drivers/soc/keystone
make -f ./scripts/Makefile.clean obj=drivers/sound
make -f ./scripts/Makefile.clean obj=drivers/thermal
make -f ./scripts/Makefile.clean obj=drivers/timer
make -f ./scripts/Makefile.clean obj=drivers/tpm
make -f ./scripts/Makefile.clean obj=drivers/twserial
make -f ./scripts/Makefile.clean obj=drivers/video
make -f ./scripts/Makefile.clean obj=drivers/video/bridge
make -f ./scripts/Makefile.clean obj=drivers/video/rockchip
make -f ./scripts/Makefile.clean obj=drivers/video/tegra124
make -f ./scripts/Makefile.clean obj=drivers/watchdog
make -f ./scripts/Makefile.clean obj=drivers/ddr/altera
make -f ./scripts/Makefile.clean obj=drivers/ddr/fsl
make -f ./scripts/Makefile.clean obj=drivers/dma
make -f ./scripts/Makefile.clean obj=drivers/gpio
make -f ./scripts/Makefile.clean obj=drivers/i2c
make -f ./scripts/Makefile.clean obj=drivers/i2c/muxes
make -f ./scripts/Makefile.clean obj=drivers/mmc
make -f ./scripts/Makefile.clean obj=drivers/mtd
make -f ./scripts/Makefile.clean obj=drivers/mtd/nand
make -f ./scripts/Makefile.clean obj=drivers/mtd/onenand
make -f ./scripts/Makefile.clean obj=drivers/mtd/spi
make -f ./scripts/Makefile.clean obj=drivers/mtd/ubi
make -f ./scripts/Makefile.clean obj=drivers/net
make -f ./scripts/Makefile.clean obj=drivers/net/fsl-mc
make -f ./scripts/Makefile.clean obj=drivers/net/fsl-mc/dpio
make -f ./scripts/Makefile.clean obj=drivers/net/ldpaa_eth
make -f ./scripts/Makefile.clean obj=drivers/net/fm
make -f ./scripts/Makefile.clean obj=drivers/net/phy
make -f ./scripts/Makefile.clean obj=drivers/pci
make -f ./scripts/Makefile.clean obj=drivers/power
make -f ./scripts/Makefile.clean obj=drivers/power/battery
make -f ./scripts/Makefile.clean obj=drivers/power/fuel_gauge
make -f ./scripts/Makefile.clean obj=drivers/power/mfd
make -f ./scripts/Makefile.clean obj=drivers/power/pmic
make -f ./scripts/Makefile.clean obj=drivers/power/regulator
make -f ./scripts/Makefile.clean obj=drivers/serial
make -f ./scripts/Makefile.clean obj=drivers/spi
make -f ./scripts/Makefile.clean obj=drivers/usb/dwc3
make -f ./scripts/Makefile.clean obj=drivers/usb/emul
make -f ./scripts/Makefile.clean obj=drivers/usb/eth
make -f ./scripts/Makefile.clean obj=drivers/usb/gadget
make -f ./scripts/Makefile.clean obj=drivers/usb/gadget/udc
make -f ./scripts/Makefile.clean obj=drivers/usb/host
make -f ./scripts/Makefile.clean obj=drivers/usb/musb
make -f ./scripts/Makefile.clean obj=drivers/usb/musb-new
make -f ./scripts/Makefile.clean obj=drivers/usb/phy
make -f ./scripts/Makefile.clean obj=drivers/usb/ulpi
make -f ./scripts/Makefile.clean obj=dts
make -f ./scripts/Makefile.clean obj=dts/../arch/arm/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/microblaze/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/mips/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/sandbox/dts
make -f ./scripts/Makefile.clean obj=dts/../arch/x86/dts
make -f ./scripts/Makefile.clean obj=examples
make -f ./scripts/Makefile.clean obj=examples/api
make -f ./scripts/Makefile.clean obj=examples/standalone
  rm -f examples/standalone/hello_world examples/standalone/hello_world.srec examples/standalone/hello_world.bin examples/standalone/libstubs.o examples/standalone/hello_world.o examples/standalone/stubs.o examples/standalone/hello_world.srec examples/standalone/hello_world.bin
make -f ./scripts/Makefile.clean obj=fs
make -f ./scripts/Makefile.clean obj=fs/cbfs
make -f ./scripts/Makefile.clean obj=fs/cramfs
make -f ./scripts/Makefile.clean obj=fs/ext4
make -f ./scripts/Makefile.clean obj=fs/fat
make -f ./scripts/Makefile.clean obj=fs/jffs2
make -f ./scripts/Makefile.clean obj=fs/reiserfs
make -f ./scripts/Makefile.clean obj=fs/sandbox
make -f ./scripts/Makefile.clean obj=fs/ubifs
make -f ./scripts/Makefile.clean obj=fs/yaffs2
make -f ./scripts/Makefile.clean obj=fs/zfs
make -f ./scripts/Makefile.clean obj=lib
make -f ./scripts/Makefile.clean obj=lib/bzip2
make -f ./scripts/Makefile.clean obj=lib/dhry
make -f ./scripts/Makefile.clean obj=lib/efi
make -f ./scripts/Makefile.clean obj=lib/libfdt
make -f ./scripts/Makefile.clean obj=lib/lzma
make -f ./scripts/Makefile.clean obj=lib/lzo
make -f ./scripts/Makefile.clean obj=lib/rsa
make -f ./scripts/Makefile.clean obj=lib/tizen
make -f ./scripts/Makefile.clean obj=lib/zlib
make -f ./scripts/Makefile.clean obj=net
make -f ./scripts/Makefile.clean obj=post
make -f ./scripts/Makefile.clean obj=post/cpu/mpc83xx
make -f ./scripts/Makefile.clean obj=post/cpu/mpc8xx
make -f ./scripts/Makefile.clean obj=post/cpu/ppc4xx
make -f ./scripts/Makefile.clean obj=post/drivers
make -f ./scripts/Makefile.clean obj=post/lib_powerpc
make -f ./scripts/Makefile.clean obj=post/lib_powerpc/fpu
make -f ./scripts/Makefile.clean obj=test
make -f ./scripts/Makefile.clean obj=test/dm
make -f ./scripts/Makefile.clean obj=test/env
make -f ./scripts/Makefile.clean obj=tools
make -f ./scripts/Makefile.clean obj=tools/easylogo
make -f ./scripts/Makefile.clean obj=tools/env
make -f ./scripts/Makefile.clean obj=tools/gdb
  rm -f tools/mkenvimage tools/dumpimage tools/mkimage tools/proftool tools/fdtgrep tools/mkenvimage tools/dumpimage tools/mkimage tools/proftool tools/fdtgrep tools/gen_eth_addr tools/img2srec
  rm -rf tools/lib tools/common
make -f ./scripts/Makefile.clean obj=doc/DocBook
  rm -rf .tmp_versions
  rm -f lpc32xx-* include/bmp_logo.h include/bmp_logo_data.h boot* u-boot* MLO* SPL System.map
make -f ./scripts/Makefile.clean obj=scripts
make -f ./scripts/Makefile.clean obj=scripts/basic
  rm -f scripts/basic/fixdep scripts/basic/fixdep
make -f ./scripts/Makefile.clean obj=scripts/kconfig
  rm -f scripts/kconfig/zconf.tab.c scripts/kconfig/zconf.lex.c scripts/kconfig/zconf.hash.c scripts/kconfig/conf
  rm -rf include/config include/generated
  rm -f .config include/autoconf.mk.dep include/autoconf.mk include/config.h
</code></pre></details>

<h4><span id="1-2-5-2-xxx-defconfig">1.2.5.2 xxx_defconfig</span><a href="#1-2-5-2-xxx-defconfig" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig V=1
make -f ./scripts/Makefile.build obj=scripts/basic
  cc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c
rm -f .tmp_quiet_recordmcount
echo "srctree ."
srctree .
KBUILD_KCONFIG
make -f ./scripts/Makefile.build obj=scripts/kconfig mx6ull_14x14_ddr512_emmc_defconfig
  cc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC="<ncurses.h>" -DNCURSES_WIDECHAR=1 -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
  cat scripts/kconfig/zconf.tab.c_shipped > scripts/kconfig/zconf.tab.c
  cat scripts/kconfig/zconf.lex.c_shipped > scripts/kconfig/zconf.lex.c
  cat scripts/kconfig/zconf.hash.c_shipped > scripts/kconfig/zconf.hash.c
  cc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -D_DEFAULT_SOURCE -D_XOPEN_SOURCE=600 -DCURSES_LOC="<ncurses.h>" -DNCURSES_WIDECHAR=1 -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
In file included from scripts/kconfig/zconf.tab.c:2534:
scripts/kconfig/confdata.c: In function ‘conf_write’:
scripts/kconfig/confdata.c:771:19: warning: ‘%s’ directive writing likely 7 or more bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
  771 |  sprintf(newname, "%s%s", dirname, basename);
      |                   ^~~~~~
scripts/kconfig/confdata.c:771:19: note: assuming directive output of 7 bytes
In file included from /usr/include/stdio.h:867,
                 from scripts/kconfig/zconf.tab.c:84:
/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output 1 or more bytes (assuming 4104) into a destination of size 4097
   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   37 |       __bos (__s), __fmt, __va_arg_pack ());
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from scripts/kconfig/zconf.tab.c:2534:
scripts/kconfig/confdata.c:774:20: warning: ‘.tmpconfig.’ directive writing 11 bytes into a region of size between 1 and 4097 [-Wformat-overflow=]
  774 |   sprintf(tmpname, "%s.tmpconfig.%d", dirname, (int)getpid());
      |                    ^~~~~~~~~~~~~~~~~
In file included from /usr/include/stdio.h:867,
                 from scripts/kconfig/zconf.tab.c:84:
/usr/include/x86_64-linux-gnu/bits/stdio2.h:36:10: note: ‘__builtin___sprintf_chk’ output between 13 and 4119 bytes into a destination of size 4097
   36 |   return __builtin___sprintf_chk (__s, __USE_FORTIFY_LEVEL - 1,
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   37 |       __bos (__s), __fmt, __va_arg_pack ());
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  cc  -o scripts/kconfig/conf scripts/kconfig/conf.o scripts/kconfig/zconf.tab.o
scripts/kconfig/conf  --defconfig=arch/../configs/mx6ull_14x14_ddr512_emmc_defconfig Kconfig
#
configuration written to .config
#
</ncurses.h></ncurses.h></code></pre></details>

<h4><span id="1-2-5-3-make">1.2.5.3 make</span><a href="#1-2-5-3-make" class="header-anchor">#</a></h4><details>
<summary>点击查看代码</summary>
<pre><code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- V=1
make -f ./Makefile silentoldconfig
make -f ./scripts/Makefile.build obj=scripts/basic
rm -f .tmp_quiet_recordmcount
echo "srctree ."
srctree .
KBUILD_KCONFIG
make -f ./scripts/Makefile.build obj=scripts/kconfig silentoldconfig
mkdir -p include/config include/generated
scripts/kconfig/conf  --silentoldconfig Kconfig
make -f ./scripts/Makefile.autoconf || \
        { rm -f include/config/auto.conf; false; }
if [ -d arch/arm/mach-mx6/include/mach ]; then  \
        dest=../../mach-mx6/include/mach;                       \
else                                                            \
        dest=arch-mx6;                  \
fi;                                                             \
ln -fsn $dest arch/arm/include/asm/arch
set -e; : '  CHK     include/config.h'; mkdir -p include/;      (echo "/* Automatically generated - do not edit */"; for i in $(echo "IMX_CONFIG=board/freescale/mx6ullevk/imximage-ddr512.cfg,MX6ULL_EVK_EMMC_REWORK" | sed 's/,/ /g'); do echo \#define CONFIG_$i | sed '/=/ {s/=/      /;q; } ; { s/$/ 1/; }'; done; echo \#define CONFIG_BOARDDIR board/freescale/mx6ullevk; echo \#include \<config_defaults.h\>; echo \#include \<config_uncmd_spl.h\>; echo \#include \<configs "mx6ullevk".h\>; echo \#include \<asm config.h\>; echo \#include \<config_fallbacks.h\>;) < scripts/Makefile.autoconf > include/config.h.tmp; if [ -r include/config.h ] && cmp -s include/config.h include/config.h.tmp; then rm -f include/config.h.tmp; else : '  UPD     include/config.h'; mv -f include/config.h.tmp include/config.h; fi
  arm-linux-gnueabihf-gcc -E -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -O2 -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time  -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe -Iinclude  -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include  -DDO_DEPS_ONLY -dM ./include/common.h > include/autoconf.mk.tmp && { sed -n -f ./tools/scripts/define2mk.sed include/autoconf.mk.tmp | while read line; do if [ -n "" ] || ! grep -q "${line%=*}=" include/config/auto.conf; then echo "$line"; fi done > include/autoconf.mk; rm include/autoconf.mk.tmp; } || { rm include/autoconf.mk.tmp; false; }
  arm-linux-gnueabihf-gcc -x c -DDO_DEPS_ONLY -M -MP -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -O2 -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time  -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe -Iinclude  -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -MQ include/config/auto.conf ./include/common.h > include/autoconf.mk.dep || { rm include/autoconf.mk.dep; false; }
touch include/config/auto.conf
set -e; : '  CHK     include/config/uboot.release'; mkdir -p include/config/;   echo "2016.03$(/bin/bash ./scripts/setlocalversion .)" < include/config/auto.conf > include/config/uboot.release.tmp; if [ -r include/config/uboot.release ] && cmp -s include/config/uboot.release include/config/uboot.release.tmp; then rm -f include/config/uboot.release.tmp; else : '  UPD     include/config/uboot.release'; mv -f include/config/uboot.release.tmp include/config/uboot.release; fi
echo "srctree ."
srctree .
set -e; : '  CHK     include/generated/version_autogenerated.h'; mkdir -p include/generated/;   (echo \#define PLAIN_VERSION \"2016.03\"; echo \#define U_BOOT_VERSION \"U-Boot \" PLAIN_VERSION; echo \#define CC_VERSION_STRING \"$(arm-linux-gnueabihf-gcc --version | head -n 1)\"; echo \#define LD_VERSION_STRING \"$(arm-linux-gnueabihf-ld.bfd --version | head -n 1)\"; ) < include/config/uboot.release > include/generated/version_autogenerated.h.tmp; if [ -r include/generated/version_autogenerated.h ] && cmp -s include/generated/version_autogenerated.h include/generated/version_autogenerated.h.tmp; then rm -f include/generated/version_autogenerated.h.tmp; else : '  UPD     include/generated/version_autogenerated.h'; mv -f include/generated/version_autogenerated.h.tmp include/generated/version_autogenerated.h; fi
set -e; : '  CHK     include/generated/timestamp_autogenerated.h'; mkdir -p include/generated/;         (if test -n "${SOURCE_DATE_EPOCH}"; then SOURCE_DATE="@${SOURCE_DATE_EPOCH}"; DATE=""; for date in gdate date.gnu date; do ${date} -u -d "${SOURCE_DATE}" >/dev/null 2>&1 && DATE="${date}"; done; if test -n "${DATE}"; then LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_DATE "%b %d %C%y"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_TIME "%T"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_TZ "%z"'; LC_ALL=C ${DATE} -u -d "${SOURCE_DATE}" +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; else return 42; fi; else LC_ALL=C date +'#define U_BOOT_DATE "%b %d %C%y"'; LC_ALL=C date +'#define U_BOOT_TIME "%T"'; LC_ALL=C date +'#define U_BOOT_TZ "%z"'; LC_ALL=C date +'#define U_BOOT_DMI_DATE "%m/%d/%Y"'; fi) < Makefile > include/generated/timestamp_autogenerated.h.tmp; if [ -r include/generated/timestamp_autogenerated.h ] && cmp -s include/generated/timestamp_autogenerated.h include/generated/timestamp_autogenerated.h.tmp; then rm -f include/generated/timestamp_autogenerated.h.tmp; else : '  UPD     include/generated/timestamp_autogenerated.h'; mv -f include/generated/timestamp_autogenerated.h.tmp include/generated/timestamp_autogenerated.h; fi
make -f ./scripts/Makefile.build obj=scripts/basic
rm -f .tmp_quiet_recordmcount
make -f ./scripts/Makefile.build obj=.
mkdir -p lib/
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.asm-offsets.s.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a -DDO_DEPS_ONLY    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asm_offsets)"  -D"KBUILD_MODNAME=KBUILD_STR(asm_offsets)"  -fverbose-asm -S -o lib/asm-offsets.s lib/asm-offsets.c
set -e; : '  CHK     include/generated/generic-asm-offsets.h'; mkdir -p include/generated/;     (set -e; echo "#ifndef __GENERIC_ASM_OFFSETS_H__"; echo "#define __GENERIC_ASM_OFFSETS_H__"; echo "/*"; echo " * DO NOT MODIFY."; echo " *"; echo " * This file was generated by Kbuild"; echo " */"; echo ""; sed -ne    "s:[[:space:]]*\.ascii[[:space:]]*\"\(.*\)\":\1:; /^->/{s:->#\(.*\):/* \1 */:; s:^->\([^ ]*\) [\$#]*\([-0-9]*\) \(.*\):#define \1 \2 /* \3 */:; s:^->\([^ ]*\) [\$#]*\([^ ]*\) \(.*\):#define \1 \2 /* \3 */:; s:->::; p;}"; echo ""; echo "#endif" ) < lib/asm-offsets.s > include/generated/generic-asm-offsets.h.tmp; if [ -r include/generated/generic-asm-offsets.h ] && cmp -s include/generated/generic-asm-offsets.h include/generated/generic-asm-offsets.h.tmp; then rm -f include/generated/generic-asm-offsets.h.tmp; else : '  UPD     include/generated/generic-asm-offsets.h'; mv -f include/generated/generic-asm-offsets.h.tmp include/generated/generic-asm-offsets.h; fi
mkdir -p arch/arm/lib/
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.asm-offsets.s.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a -DDO_DEPS_ONLY    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asm_offsets)"  -D"KBUILD_MODNAME=KBUILD_STR(asm_offsets)"  -fverbose-asm -S -o arch/arm/lib/asm-offsets.s arch/arm/lib/asm-offsets.c
set -e; : '  CHK     include/generated/asm-offsets.h'; mkdir -p include/generated/;     (set -e; echo "#ifndef __ASM_OFFSETS_H__"; echo "#define __ASM_OFFSETS_H__"; echo "/*"; echo " * DO NOT MODIFY."; echo " *"; echo " * This file was generated by Kbuild"; echo " */"; echo ""; sed -ne    "s:[[:space:]]*\.ascii[[:space:]]*\"\(.*\)\":\1:; /^->/{s:->#\(.*\):/* \1 */:; s:^->\([^ ]*\) [\$#]*\([-0-9]*\) \(.*\):#define \1 \2 /* \3 */:; s:^->\([^ ]*\) [\$#]*\([^ ]*\) \(.*\):#define \1 \2 /* \3 */:; s:->::; p;}"; echo ""; echo "#endif" ) < arch/arm/lib/asm-offsets.s > include/generated/asm-offsets.h.tmp; if [ -r include/generated/asm-offsets.h ] && cmp -s include/generated/asm-offsets.h include/generated/asm-offsets.h.tmp; then rm -f include/generated/asm-offsets.h.tmp; else : '  UPD     include/generated/asm-offsets.h'; mv -f include/generated/asm-offsets.h.tmp include/generated/asm-offsets.h; fi
make -f ./scripts/Makefile.build obj=tools
  cc -Wp,-MD,tools/.gen_eth_addr.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -o tools/gen_eth_addr tools/gen_eth_addr.c
  cc -Wp,-MD,tools/.img2srec.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -o tools/img2srec tools/img2srec.c
  cc -Wp,-MD,tools/.mkenvimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mkenvimage.o tools/mkenvimage.c
  cc -Wp,-MD,tools/.os_support.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/os_support.o tools/os_support.c
  echo "#include <.. lib crc32.c>" >tools/lib/crc32.c
  cc -Wp,-MD,tools/lib/.crc32.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/crc32.o tools/lib/crc32.c
  cc  -o tools/mkenvimage tools/mkenvimage.o tools/os_support.o tools/lib/crc32.o
  cc -Wp,-MD,tools/.aisimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/aisimage.o tools/aisimage.c
  cc -Wp,-MD,tools/.atmelimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/atmelimage.o tools/atmelimage.c
  echo "#include <.. common bootm.c>" >tools/common/bootm.c
  cc -Wp,-MD,tools/common/.bootm.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/bootm.o tools/common/bootm.c
  cc -Wp,-MD,tools/.default_image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/default_image.o tools/default_image.c
  echo "#include <.. lib fdtdec_common.c>" >tools/lib/fdtdec_common.c
  cc -Wp,-MD,tools/lib/.fdtdec_common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/fdtdec_common.o tools/lib/fdtdec_common.c
  echo "#include <.. lib fdtdec.c>" >tools/lib/fdtdec.c
  cc -Wp,-MD,tools/lib/.fdtdec.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/fdtdec.o tools/lib/fdtdec.c
  cc -Wp,-MD,tools/.fit_common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fit_common.o tools/fit_common.c
  cc -Wp,-MD,tools/.fit_image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fit_image.o tools/fit_image.c
  cc -Wp,-MD,tools/.gpimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/gpimage.o tools/gpimage.c
  cc -Wp,-MD,tools/.gpimage-common.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/gpimage-common.o tools/gpimage-common.c
  echo "#include <.. common image-fit.c>" >tools/common/image-fit.c
  cc -Wp,-MD,tools/common/.image-fit.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/image-fit.o tools/common/image-fit.c
  cc -Wp,-MD,tools/.image-host.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/image-host.o tools/image-host.c
  echo "#include <.. common image.c>" >tools/common/image.c
  cc -Wp,-MD,tools/common/.image.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/image.o tools/common/image.c
  cc -Wp,-MD,tools/.imagetool.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/imagetool.o tools/imagetool.c
  cc -Wp,-MD,tools/.imximage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/imximage.o tools/imximage.c
  cc -Wp,-MD,tools/.kwbimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/kwbimage.o tools/kwbimage.c
  echo "#include <.. lib md5.c>" >tools/lib/md5.c
  cc -Wp,-MD,tools/lib/.md5.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/md5.o tools/lib/md5.c
  cc -Wp,-MD,tools/.lpc32xximage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lpc32xximage.o tools/lpc32xximage.c
  cc -Wp,-MD,tools/.mxsimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mxsimage.o tools/mxsimage.c
  cc -Wp,-MD,tools/.omapimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/omapimage.o tools/omapimage.c
  cc -Wp,-MD,tools/.pblimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/pblimage.o tools/pblimage.c
  cc -Wp,-MD,tools/.pbl_crc32.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/pbl_crc32.o tools/pbl_crc32.c
  echo "#include <.. lib rc4.c>" >tools/lib/rc4.c
  cc -Wp,-MD,tools/lib/.rc4.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/rc4.o tools/lib/rc4.c
  cc -Wp,-MD,tools/.rkcommon.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkcommon.o tools/rkcommon.c
  cc -Wp,-MD,tools/.rkimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkimage.o tools/rkimage.c
  cc -Wp,-MD,tools/.rksd.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rksd.o tools/rksd.c
  cc -Wp,-MD,tools/.rkspi.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/rkspi.o tools/rkspi.c
  cc -Wp,-MD,tools/.socfpgaimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/socfpgaimage.o tools/socfpgaimage.c
  echo "#include <.. lib sha1.c>" >tools/lib/sha1.c
  cc -Wp,-MD,tools/lib/.sha1.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/sha1.o tools/lib/sha1.c
  echo "#include <.. lib sha256.c>" >tools/lib/sha256.c
  cc -Wp,-MD,tools/lib/.sha256.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE -pedantic -c -o tools/lib/sha256.o tools/lib/sha256.c
  echo "#include <.. common hash.c>" >tools/common/hash.c
  cc -Wp,-MD,tools/common/.hash.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/common/hash.o tools/common/hash.c
  cc -Wp,-MD,tools/.ublimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/ublimage.o tools/ublimage.c
  cc -Wp,-MD,tools/.zynqimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/zynqimage.o tools/zynqimage.c
  echo "#include <.. lib libfdt fdt.c>" >tools/lib/libfdt/fdt.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt.c
  echo "#include <.. lib libfdt fdt_ro.c>" >tools/lib/libfdt/fdt_ro.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_ro.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_ro.c
  echo "#include <.. lib libfdt fdt_rw.c>" >tools/lib/libfdt/fdt_rw.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_rw.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_rw.c
  echo "#include <.. lib libfdt fdt_strerror.c>" >tools/lib/libfdt/fdt_strerror.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_strerror.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_strerror.c
  echo "#include <.. lib libfdt fdt_wip.c>" >tools/lib/libfdt/fdt_wip.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_wip.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_wip.c
  echo "#include <.. lib libfdt fdt_region.c>" >tools/lib/libfdt/fdt_region.c
  cc -Wp,-MD,tools/lib/libfdt/.fdt_region.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/lib/libfdt/fdt_region.o tools/lib/libfdt/fdt_region.c
  cc -Wp,-MD,tools/.dumpimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/dumpimage.o tools/dumpimage.c
  cc  -o tools/dumpimage tools/aisimage.o tools/atmelimage.o tools/common/bootm.o tools/lib/crc32.o tools/default_image.o tools/lib/fdtdec_common.o tools/lib/fdtdec.o tools/fit_common.o tools/fit_image.o tools/gpimage.o tools/gpimage-common.o tools/common/image-fit.o tools/image-host.o tools/common/image.o tools/imagetool.o tools/imximage.o tools/kwbimage.o tools/lib/md5.o tools/lpc32xximage.o tools/mxsimage.o tools/omapimage.o tools/os_support.o tools/pblimage.o tools/pbl_crc32.o tools/lib/rc4.o tools/rkcommon.o tools/rkimage.o tools/rksd.o tools/rkspi.o tools/socfpgaimage.o tools/lib/sha1.o tools/lib/sha256.o tools/common/hash.o tools/ublimage.o tools/zynqimage.o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/dumpimage.o
  cc -Wp,-MD,tools/.mkimage.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/mkimage.o tools/mkimage.c
  cc  -o tools/mkimage tools/aisimage.o tools/atmelimage.o tools/common/bootm.o tools/lib/crc32.o tools/default_image.o tools/lib/fdtdec_common.o tools/lib/fdtdec.o tools/fit_common.o tools/fit_image.o tools/gpimage.o tools/gpimage-common.o tools/common/image-fit.o tools/image-host.o tools/common/image.o tools/imagetool.o tools/imximage.o tools/kwbimage.o tools/lib/md5.o tools/lpc32xximage.o tools/mxsimage.o tools/omapimage.o tools/os_support.o tools/pblimage.o tools/pbl_crc32.o tools/lib/rc4.o tools/rkcommon.o tools/rkimage.o tools/rksd.o tools/rkspi.o tools/socfpgaimage.o tools/lib/sha1.o tools/lib/sha256.o tools/common/hash.o tools/ublimage.o tools/zynqimage.o tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/mkimage.o
  cc -Wp,-MD,tools/.proftool.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -o tools/proftool tools/proftool.c
  cc -Wp,-MD,tools/.fdtgrep.o.d -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer   -include ./include/libfdt_env.h -idirafterinclude -idirafter./arch/arm/include -I./lib/libfdt -I./tools -DCONFIG_SYS_TEXT_BASE=0x87800000 -DUSE_HOSTCC -D__KERNEL_STRICT_NAMES -D_GNU_SOURCE  -c -o tools/fdtgrep.o tools/fdtgrep.c
  cc  -o tools/fdtgrep tools/lib/libfdt/fdt.o tools/lib/libfdt/fdt_ro.o tools/lib/libfdt/fdt_rw.o tools/lib/libfdt/fdt_strerror.o tools/lib/libfdt/fdt_wip.o tools/lib/libfdt/fdt_region.o tools/fdtgrep.o
make -f ./scripts/Makefile.build obj=arch/arm/cpu
   rm -f arch/arm/cpu/built-in.o; arm-linux-gnueabihf-ar rcs arch/arm/cpu/built-in.o
make -f ./scripts/Makefile.build obj=arch/arm/cpu/armv7
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cache_v7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache_v7)"  -D"KBUILD_MODNAME=KBUILD_STR(cache_v7)" -c -o arch/arm/cpu/armv7/cache_v7.o arch/arm/cpu/armv7/cache_v7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cpu.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cpu)"  -D"KBUILD_MODNAME=KBUILD_STR(cpu)" -c -o arch/arm/cpu/armv7/cpu.o arch/arm/cpu/armv7/cpu.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.cp15.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cp15)"  -D"KBUILD_MODNAME=KBUILD_STR(cp15)" -c -o arch/arm/cpu/armv7/cp15.o arch/arm/cpu/armv7/cp15.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.syslib.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(syslib)"  -D"KBUILD_MODNAME=KBUILD_STR(syslib)" -c -o arch/arm/cpu/armv7/syslib.o arch/arm/cpu/armv7/syslib.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.lowlevel_init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/cpu/armv7/lowlevel_init.o arch/arm/cpu/armv7/lowlevel_init.S
make -f ./scripts/Makefile.build obj=arch/arm/cpu/armv7/mx6
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/mx6/.soc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(soc)"  -D"KBUILD_MODNAME=KBUILD_STR(soc)" -c -o arch/arm/cpu/armv7/mx6/soc.o arch/arm/cpu/armv7/mx6/soc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/mx6/.clock.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(clock)"  -D"KBUILD_MODNAME=KBUILD_STR(clock)" -c -o arch/arm/cpu/armv7/mx6/clock.o arch/arm/cpu/armv7/mx6/clock.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/cpu/armv7/mx6/built-in.o arch/arm/cpu/armv7/mx6/soc.o arch/arm/cpu/armv7/mx6/clock.o
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/cpu/armv7/built-in.o arch/arm/cpu/armv7/cache_v7.o arch/arm/cpu/armv7/cpu.o arch/arm/cpu/armv7/cp15.o arch/arm/cpu/armv7/syslib.o arch/arm/cpu/armv7/lowlevel_init.o arch/arm/cpu/armv7/mx6/built-in.o
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/cpu/armv7/.start.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/cpu/armv7/start.o arch/arm/cpu/armv7/start.S
make -f ./scripts/Makefile.build obj=arch/arm/imx-common
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.iomux-v3.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(iomux_v3)"  -D"KBUILD_MODNAME=KBUILD_STR(iomux_v3)" -c -o arch/arm/imx-common/iomux-v3.o arch/arm/imx-common/iomux-v3.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cpu.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cpu)"  -D"KBUILD_MODNAME=KBUILD_STR(cpu)" -c -o arch/arm/imx-common/cpu.o arch/arm/imx-common/cpu.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.speed.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(speed)"  -D"KBUILD_MODNAME=KBUILD_STR(speed)" -c -o arch/arm/imx-common/speed.o arch/arm/imx-common/speed.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.i2c-mxv7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c_mxv7)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c_mxv7)" -c -o arch/arm/imx-common/i2c-mxv7.o arch/arm/imx-common/i2c-mxv7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.misc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(misc)"  -D"KBUILD_MODNAME=KBUILD_STR(misc)" -c -o arch/arm/imx-common/misc.o arch/arm/imx-common/misc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o arch/arm/imx-common/cache.o arch/arm/imx-common/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(init)"  -D"KBUILD_MODNAME=KBUILD_STR(init)" -c -o arch/arm/imx-common/init.o arch/arm/imx-common/init.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.syscounter.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(syscounter)"  -D"KBUILD_MODNAME=KBUILD_STR(syscounter)" -c -o arch/arm/imx-common/syscounter.o arch/arm/imx-common/syscounter.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/imx-common/.cmd_bmode.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cmd_bmode)"  -D"KBUILD_MODNAME=KBUILD_STR(cmd_bmode)" -c -o arch/arm/imx-common/cmd_bmode.o arch/arm/imx-common/cmd_bmode.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/imx-common/built-in.o arch/arm/imx-common/iomux-v3.o arch/arm/imx-common/cpu.o arch/arm/imx-common/speed.o arch/arm/imx-common/i2c-mxv7.o arch/arm/imx-common/misc.o arch/arm/imx-common/cache.o arch/arm/imx-common/init.o arch/arm/imx-common/syscounter.o arch/arm/imx-common/cmd_bmode.o
make -f ./scripts/Makefile.build obj=arch/arm/lib
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.vectors.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/vectors.o arch/arm/lib/vectors.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.crt0.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/crt0.o arch/arm/lib/crt0.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.relocate.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -D__ASSEMBLY__ -g -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a   -c -o arch/arm/lib/relocate.o arch/arm/lib/relocate.S
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.bootm-fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm_fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm_fdt)" -c -o arch/arm/lib/bootm-fdt.o arch/arm/lib/bootm-fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o arch/arm/lib/bootm.o arch/arm/lib/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.sections.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sections)"  -D"KBUILD_MODNAME=KBUILD_STR(sections)" -c -o arch/arm/lib/sections.o arch/arm/lib/sections.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.stack.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stack)"  -D"KBUILD_MODNAME=KBUILD_STR(stack)" -c -o arch/arm/lib/stack.o arch/arm/lib/stack.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.interrupts.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(interrupts)"  -D"KBUILD_MODNAME=KBUILD_STR(interrupts)" -c -o arch/arm/lib/interrupts.o arch/arm/lib/interrupts.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.reset.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(reset)"  -D"KBUILD_MODNAME=KBUILD_STR(reset)" -c -o arch/arm/lib/reset.o arch/arm/lib/reset.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o arch/arm/lib/cache.o arch/arm/lib/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.cache-cp15.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache_cp15)"  -D"KBUILD_MODNAME=KBUILD_STR(cache_cp15)" -c -o arch/arm/lib/cache-cp15.o arch/arm/lib/cache-cp15.c
   arm-linux-gnueabihf-ld.bfd     -r -o arch/arm/lib/built-in.o arch/arm/lib/vectors.o arch/arm/lib/crt0.o arch/arm/lib/relocate.o arch/arm/lib/bootm-fdt.o arch/arm/lib/bootm.o arch/arm/lib/sections.o arch/arm/lib/stack.o arch/arm/lib/interrupts.o arch/arm/lib/reset.o arch/arm/lib/cache.o arch/arm/lib/cache-cp15.o
  rm -f arch/arm/lib/lib.a; arm-linux-gnueabihf-ar rcs arch/arm/lib/lib.a
  arm-linux-gnueabihf-gcc -Wp,-MD,arch/arm/lib/.eabi_compat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eabi_compat)"  -D"KBUILD_MODNAME=KBUILD_STR(eabi_compat)" -c -o arch/arm/lib/eabi_compat.o arch/arm/lib/eabi_compat.c
make -f ./scripts/Makefile.build obj=board/freescale/common
  arm-linux-gnueabihf-gcc -Wp,-MD,board/freescale/common/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o board/freescale/common/mmc.o board/freescale/common/mmc.c
   arm-linux-gnueabihf-ld.bfd     -r -o board/freescale/common/built-in.o board/freescale/common/mmc.o
make -f ./scripts/Makefile.build obj=board/freescale/mx6ullevk
  arm-linux-gnueabihf-gcc -Wp,-MD,board/freescale/mx6ullevk/.mx6ullevk.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mx6ullevk)"  -D"KBUILD_MODNAME=KBUILD_STR(mx6ullevk)" -c -o board/freescale/mx6ullevk/mx6ullevk.o board/freescale/mx6ullevk/mx6ullevk.c
   arm-linux-gnueabihf-ld.bfd     -r -o board/freescale/mx6ullevk/built-in.o board/freescale/mx6ullevk/mx6ullevk.o
make -f ./scripts/Makefile.build obj=cmd
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.boot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(boot)"  -D"KBUILD_MODNAME=KBUILD_STR(boot)" -c -o cmd/boot.o cmd/boot.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o cmd/bootm.o cmd/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.help.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(help)"  -D"KBUILD_MODNAME=KBUILD_STR(help)" -c -o cmd/help.o cmd/help.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.version.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(version)"  -D"KBUILD_MODNAME=KBUILD_STR(version)" -c -o cmd/version.o cmd/version.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.source.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(source)"  -D"KBUILD_MODNAME=KBUILD_STR(source)" -c -o cmd/source.o cmd/source.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.bdinfo.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bdinfo)"  -D"KBUILD_MODNAME=KBUILD_STR(bdinfo)" -c -o cmd/bdinfo.o cmd/bdinfo.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.cache.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cache)"  -D"KBUILD_MODNAME=KBUILD_STR(cache)" -c -o cmd/cache.o cmd/cache.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.console.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(console)"  -D"KBUILD_MODNAME=KBUILD_STR(console)" -c -o cmd/console.o cmd/console.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.echo.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(echo)"  -D"KBUILD_MODNAME=KBUILD_STR(echo)" -c -o cmd/echo.o cmd/echo.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.elf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(elf)"  -D"KBUILD_MODNAME=KBUILD_STR(elf)" -c -o cmd/elf.o cmd/elf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.exit.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(exit)"  -D"KBUILD_MODNAME=KBUILD_STR(exit)" -c -o cmd/exit.o cmd/exit.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ext4.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4)" -c -o cmd/ext4.o cmd/ext4.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ext2.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext2)"  -D"KBUILD_MODNAME=KBUILD_STR(ext2)" -c -o cmd/ext2.o cmd/ext2.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fat)"  -D"KBUILD_MODNAME=KBUILD_STR(fat)" -c -o cmd/fat.o cmd/fat.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt)" -c -o cmd/fdt.o cmd/fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(flash)"  -D"KBUILD_MODNAME=KBUILD_STR(flash)" -c -o cmd/flash.o cmd/flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fs)"  -D"KBUILD_MODNAME=KBUILD_STR(fs)" -c -o cmd/fs.o cmd/fs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.fuse.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fuse)"  -D"KBUILD_MODNAME=KBUILD_STR(fuse)" -c -o cmd/fuse.o cmd/fuse.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.gpio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(gpio)"  -D"KBUILD_MODNAME=KBUILD_STR(gpio)" -c -o cmd/gpio.o cmd/gpio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c)" -c -o cmd/i2c.o cmd/i2c.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.itest.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(itest)"  -D"KBUILD_MODNAME=KBUILD_STR(itest)" -c -o cmd/itest.o cmd/itest.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.load.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(load)"  -D"KBUILD_MODNAME=KBUILD_STR(load)" -c -o cmd/load.o cmd/load.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mem.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mem)"  -D"KBUILD_MODNAME=KBUILD_STR(mem)" -c -o cmd/mem.o cmd/mem.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mii.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mii)"  -D"KBUILD_MODNAME=KBUILD_STR(mii)" -c -o cmd/mii.o cmd/mii.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mdio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mdio)"  -D"KBUILD_MODNAME=KBUILD_STR(mdio)" -c -o cmd/mdio.o cmd/mdio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.misc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(misc)"  -D"KBUILD_MODNAME=KBUILD_STR(misc)" -c -o cmd/misc.o cmd/misc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o cmd/mmc.o cmd/mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.net.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net)"  -D"KBUILD_MODNAME=KBUILD_STR(net)" -c -o cmd/net.o cmd/net.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.pcmcia.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(pcmcia)"  -D"KBUILD_MODNAME=KBUILD_STR(pcmcia)" -c -o cmd/pcmcia.o cmd/pcmcia.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.sf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf)"  -D"KBUILD_MODNAME=KBUILD_STR(sf)" -c -o cmd/sf.o cmd/sf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.setexpr.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(setexpr)"  -D"KBUILD_MODNAME=KBUILD_STR(setexpr)" -c -o cmd/setexpr.o cmd/setexpr.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.test.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(test)"  -D"KBUILD_MODNAME=KBUILD_STR(test)" -c -o cmd/test.o cmd/test.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.usb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb)"  -D"KBUILD_MODNAME=KBUILD_STR(usb)" -c -o cmd/usb.o cmd/usb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.ximg.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ximg)"  -D"KBUILD_MODNAME=KBUILD_STR(ximg)" -c -o cmd/ximg.o cmd/ximg.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.nvedit.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(nvedit)"  -D"KBUILD_MODNAME=KBUILD_STR(nvedit)" -c -o cmd/nvedit.o cmd/nvedit.c
  arm-linux-gnueabihf-gcc -Wp,-MD,cmd/.disk.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(disk)"  -D"KBUILD_MODNAME=KBUILD_STR(disk)" -c -o cmd/disk.o cmd/disk.c
   arm-linux-gnueabihf-ld.bfd     -r -o cmd/built-in.o cmd/boot.o cmd/bootm.o cmd/help.o cmd/version.o cmd/source.o cmd/bdinfo.o cmd/cache.o cmd/console.o cmd/echo.o cmd/elf.o cmd/exit.o cmd/ext4.o cmd/ext2.o cmd/fat.o cmd/fdt.o cmd/flash.o cmd/fs.o cmd/fuse.o cmd/gpio.o cmd/i2c.o cmd/itest.o cmd/load.o cmd/mem.o cmd/mii.o cmd/mdio.o cmd/misc.o cmd/mmc.o cmd/net.o cmd/pcmcia.o cmd/sf.o cmd/setexpr.o cmd/test.o cmd/usb.o cmd/ximg.o cmd/nvedit.o cmd/disk.o
make -f ./scripts/Makefile.build obj=common
make -f ./scripts/Makefile.build obj=common/init
  arm-linux-gnueabihf-gcc -Wp,-MD,common/init/.board_init.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_init)"  -D"KBUILD_MODNAME=KBUILD_STR(board_init)" -c -o common/init/board_init.o common/init/board_init.c
   arm-linux-gnueabihf-ld.bfd     -r -o common/init/built-in.o common/init/board_init.o
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.main.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(main)"  -D"KBUILD_MODNAME=KBUILD_STR(main)" -c -o common/main.o common/main.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.exports.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(exports)"  -D"KBUILD_MODNAME=KBUILD_STR(exports)" -c -o common/exports.o common/exports.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.hash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hash)"  -D"KBUILD_MODNAME=KBUILD_STR(hash)" -c -o common/hash.o common/hash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_hush.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_hush)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_hush)" -c -o common/cli_hush.o common/cli_hush.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.autoboot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(autoboot)"  -D"KBUILD_MODNAME=KBUILD_STR(autoboot)" -c -o common/autoboot.o common/autoboot.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_f.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_f)"  -D"KBUILD_MODNAME=KBUILD_STR(board_f)" -c -o common/board_f.o common/board_f.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_r.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_r)"  -D"KBUILD_MODNAME=KBUILD_STR(board_r)" -c -o common/board_r.o common/board_r.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.board_info.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(board_info)"  -D"KBUILD_MODNAME=KBUILD_STR(board_info)" -c -o common/board_info.o common/board_info.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bootm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm)" -c -o common/bootm.o common/bootm.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bootm_os.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootm_os)"  -D"KBUILD_MODNAME=KBUILD_STR(bootm_os)" -c -o common/bootm_os.o common/bootm_os.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_attr.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_attr)"  -D"KBUILD_MODNAME=KBUILD_STR(env_attr)" -c -o common/env_attr.o common/env_attr.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_callback.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_callback)"  -D"KBUILD_MODNAME=KBUILD_STR(env_callback)" -c -o common/env_callback.o common/env_callback.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_flags.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_flags)"  -D"KBUILD_MODNAME=KBUILD_STR(env_flags)" -c -o common/env_flags.o common/env_flags.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(env_mmc)" -c -o common/env_mmc.o common/env_mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.fdt_support.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_support)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_support)" -c -o common/fdt_support.o common/fdt_support.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.miiphyutil.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(miiphyutil)"  -D"KBUILD_MODNAME=KBUILD_STR(miiphyutil)" -c -o common/miiphyutil.o common/miiphyutil.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb)"  -D"KBUILD_MODNAME=KBUILD_STR(usb)" -c -o common/usb.o common/usb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb_hub.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_hub)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_hub)" -c -o common/usb_hub.o common/usb_hub.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.usb_storage.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_storage)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_storage)" -c -o common/usb_storage.o common/usb_storage.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(flash)"  -D"KBUILD_MODNAME=KBUILD_STR(flash)" -c -o common/flash.o common/flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.splash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(splash)"  -D"KBUILD_MODNAME=KBUILD_STR(splash)" -c -o common/splash.o common/splash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.env_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(env_common)"  -D"KBUILD_MODNAME=KBUILD_STR(env_common)" -c -o common/env_common.o common/env_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.bouncebuf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bouncebuf)"  -D"KBUILD_MODNAME=KBUILD_STR(bouncebuf)" -c -o common/bouncebuf.o common/bouncebuf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.console.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(console)"  -D"KBUILD_MODNAME=KBUILD_STR(console)" -c -o common/console.o common/console.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.dlmalloc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dlmalloc)"  -D"KBUILD_MODNAME=KBUILD_STR(dlmalloc)" -c -o common/dlmalloc.o common/dlmalloc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.malloc_simple.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(malloc_simple)"  -D"KBUILD_MODNAME=KBUILD_STR(malloc_simple)" -c -o common/malloc_simple.o common/malloc_simple.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.image.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(image)"  -D"KBUILD_MODNAME=KBUILD_STR(image)" -c -o common/image.o common/image.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.image-fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(image_fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(image_fdt)" -c -o common/image-fdt.o common/image-fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.memsize.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(memsize)"  -D"KBUILD_MODNAME=KBUILD_STR(memsize)" -c -o common/memsize.o common/memsize.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.stdio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stdio)"  -D"KBUILD_MODNAME=KBUILD_STR(stdio)" -c -o common/stdio.o common/stdio.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_simple.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_simple)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_simple)" -c -o common/cli_simple.o common/cli_simple.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli)"  -D"KBUILD_MODNAME=KBUILD_STR(cli)" -c -o common/cli.o common/cli.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.cli_readline.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cli_readline)"  -D"KBUILD_MODNAME=KBUILD_STR(cli_readline)" -c -o common/cli_readline.o common/cli_readline.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.command.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(command)"  -D"KBUILD_MODNAME=KBUILD_STR(command)" -c -o common/command.o common/command.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.s_record.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(s_record)"  -D"KBUILD_MODNAME=KBUILD_STR(s_record)" -c -o common/s_record.o common/s_record.c
  arm-linux-gnueabihf-gcc -Wp,-MD,common/.xyzModem.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(xyzModem)"  -D"KBUILD_MODNAME=KBUILD_STR(xyzModem)" -c -o common/xyzModem.o common/xyzModem.c
   arm-linux-gnueabihf-ld.bfd     -r -o common/built-in.o common/init/built-in.o common/main.o common/exports.o common/hash.o common/cli_hush.o common/autoboot.o common/board_f.o common/board_r.o common/board_info.o common/bootm.o common/bootm_os.o common/env_attr.o common/env_callback.o common/env_flags.o common/env_mmc.o common/fdt_support.o common/miiphyutil.o common/usb.o common/usb_hub.o common/usb_storage.o common/flash.o common/splash.o common/env_common.o common/bouncebuf.o common/console.o common/dlmalloc.o common/malloc_simple.o common/image.o common/image-fdt.o common/memsize.o common/stdio.o common/cli_simple.o common/cli.o common/cli_readline.o common/command.o common/s_record.o common/xyzModem.o
make -f ./scripts/Makefile.build obj=disk
  arm-linux-gnueabihf-gcc -Wp,-MD,disk/.part.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(part)"  -D"KBUILD_MODNAME=KBUILD_STR(part)" -c -o disk/part.o disk/part.c
  arm-linux-gnueabihf-gcc -Wp,-MD,disk/.part_dos.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(part_dos)"  -D"KBUILD_MODNAME=KBUILD_STR(part_dos)" -c -o disk/part_dos.o disk/part_dos.c
   arm-linux-gnueabihf-ld.bfd     -r -o disk/built-in.o disk/part.o disk/part_dos.o
make -f ./scripts/Makefile.build obj=drivers
make -f ./scripts/Makefile.build obj=drivers/adc
   rm -f drivers/adc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/adc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/block
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/block/.disk-uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(disk_uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(disk_uclass)" -c -o drivers/block/disk-uclass.o drivers/block/disk-uclass.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/block/built-in.o drivers/block/disk-uclass.o
make -f ./scripts/Makefile.build obj=drivers/core
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.device.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(device)"  -D"KBUILD_MODNAME=KBUILD_STR(device)" -c -o drivers/core/device.o drivers/core/device.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.lists.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(lists)"  -D"KBUILD_MODNAME=KBUILD_STR(lists)" -c -o drivers/core/lists.o drivers/core/lists.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.root.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(root)"  -D"KBUILD_MODNAME=KBUILD_STR(root)" -c -o drivers/core/root.o drivers/core/root.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(uclass)" -c -o drivers/core/uclass.o drivers/core/uclass.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.util.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(util)"  -D"KBUILD_MODNAME=KBUILD_STR(util)" -c -o drivers/core/util.o drivers/core/util.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.device-remove.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(device_remove)"  -D"KBUILD_MODNAME=KBUILD_STR(device_remove)" -c -o drivers/core/device-remove.o drivers/core/device-remove.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/core/.dump.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dump)"  -D"KBUILD_MODNAME=KBUILD_STR(dump)" -c -o drivers/core/dump.o drivers/core/dump.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/core/built-in.o drivers/core/device.o drivers/core/lists.o drivers/core/root.o drivers/core/uclass.o drivers/core/util.o drivers/core/device-remove.o drivers/core/dump.o
make -f ./scripts/Makefile.build obj=drivers/crypto
make -f ./scripts/Makefile.build obj=drivers/crypto/fsl
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/crypto/fsl/.sec.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sec)"  -D"KBUILD_MODNAME=KBUILD_STR(sec)" -c -o drivers/crypto/fsl/sec.o drivers/crypto/fsl/sec.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/crypto/fsl/built-in.o drivers/crypto/fsl/sec.o
make -f ./scripts/Makefile.build obj=drivers/crypto/rsa_mod_exp
   rm -f drivers/crypto/rsa_mod_exp/built-in.o; arm-linux-gnueabihf-ar rcs drivers/crypto/rsa_mod_exp/built-in.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/crypto/built-in.o drivers/crypto/rsa_mod_exp/built-in.o drivers/crypto/fsl/built-in.o
make -f ./scripts/Makefile.build obj=drivers/dfu
   rm -f drivers/dfu/built-in.o; arm-linux-gnueabihf-ar rcs drivers/dfu/built-in.o
make -f ./scripts/Makefile.build obj=drivers/hwmon
   rm -f drivers/hwmon/built-in.o; arm-linux-gnueabihf-ar rcs drivers/hwmon/built-in.o
make -f ./scripts/Makefile.build obj=drivers/input
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/input/.input.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(input)"  -D"KBUILD_MODNAME=KBUILD_STR(input)" -c -o drivers/input/input.o drivers/input/input.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/input/built-in.o drivers/input/input.o
make -f ./scripts/Makefile.build obj=drivers/memory
   rm -f drivers/memory/built-in.o; arm-linux-gnueabihf-ar rcs drivers/memory/built-in.o
make -f ./scripts/Makefile.build obj=drivers/misc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/misc/.mxc_ocotp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_ocotp)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_ocotp)" -c -o drivers/misc/mxc_ocotp.o drivers/misc/mxc_ocotp.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/misc/built-in.o drivers/misc/mxc_ocotp.o
make -f ./scripts/Makefile.build obj=drivers/pcmcia
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/pcmcia/.tqm8xx_pcmcia.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(tqm8xx_pcmcia)"  -D"KBUILD_MODNAME=KBUILD_STR(tqm8xx_pcmcia)" -c -o drivers/pcmcia/tqm8xx_pcmcia.o drivers/pcmcia/tqm8xx_pcmcia.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/pcmcia/built-in.o drivers/pcmcia/tqm8xx_pcmcia.o
make -f ./scripts/Makefile.build obj=drivers/pwm
   rm -f drivers/pwm/built-in.o; arm-linux-gnueabihf-ar rcs drivers/pwm/built-in.o
make -f ./scripts/Makefile.build obj=drivers/rtc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/rtc/.date.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(date)"  -D"KBUILD_MODNAME=KBUILD_STR(date)" -c -o drivers/rtc/date.o drivers/rtc/date.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/rtc/built-in.o drivers/rtc/date.o
make -f ./scripts/Makefile.build obj=drivers/soc
   rm -f drivers/soc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/soc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/sound
   rm -f drivers/sound/built-in.o; arm-linux-gnueabihf-ar rcs drivers/sound/built-in.o
make -f ./scripts/Makefile.build obj=drivers/thermal
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/thermal/.thermal-uclass.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(thermal_uclass)"  -D"KBUILD_MODNAME=KBUILD_STR(thermal_uclass)" -c -o drivers/thermal/thermal-uclass.o drivers/thermal/thermal-uclass.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/thermal/.imx_thermal.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(imx_thermal)"  -D"KBUILD_MODNAME=KBUILD_STR(imx_thermal)" -c -o drivers/thermal/imx_thermal.o drivers/thermal/imx_thermal.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/thermal/built-in.o drivers/thermal/thermal-uclass.o drivers/thermal/imx_thermal.o
make -f ./scripts/Makefile.build obj=drivers/timer
   rm -f drivers/timer/built-in.o; arm-linux-gnueabihf-ar rcs drivers/timer/built-in.o
make -f ./scripts/Makefile.build obj=drivers/tpm
   rm -f drivers/tpm/built-in.o; arm-linux-gnueabihf-ar rcs drivers/tpm/built-in.o
make -f ./scripts/Makefile.build obj=drivers/twserial
   rm -f drivers/twserial/built-in.o; arm-linux-gnueabihf-ar rcs drivers/twserial/built-in.o
make -f ./scripts/Makefile.build obj=drivers/video
make -f ./scripts/Makefile.build obj=drivers/video/bridge
   rm -f drivers/video/bridge/built-in.o; arm-linux-gnueabihf-ar rcs drivers/video/bridge/built-in.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/video/built-in.o drivers/video/bridge/built-in.o
make -f ./scripts/Makefile.build obj=drivers/watchdog
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/watchdog/.imx_watchdog.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(imx_watchdog)"  -D"KBUILD_MODNAME=KBUILD_STR(imx_watchdog)" -c -o drivers/watchdog/imx_watchdog.o drivers/watchdog/imx_watchdog.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/watchdog/built-in.o drivers/watchdog/imx_watchdog.o
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/built-in.o drivers/core/built-in.o drivers/adc/built-in.o drivers/block/built-in.o drivers/crypto/built-in.o drivers/hwmon/built-in.o drivers/misc/built-in.o drivers/pcmcia/built-in.o drivers/dfu/built-in.o drivers/rtc/built-in.o drivers/sound/built-in.o drivers/timer/built-in.o drivers/tpm/built-in.o drivers/twserial/built-in.o drivers/video/built-in.o drivers/watchdog/built-in.o drivers/memory/built-in.o drivers/pwm/built-in.o drivers/input/built-in.o drivers/soc/built-in.o drivers/thermal/built-in.o
make -f ./scripts/Makefile.build obj=drivers/dma
   rm -f drivers/dma/built-in.o; arm-linux-gnueabihf-ar rcs drivers/dma/built-in.o
make -f ./scripts/Makefile.build obj=drivers/gpio
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/gpio/.mxc_gpio.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_gpio)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_gpio)" -c -o drivers/gpio/mxc_gpio.o drivers/gpio/mxc_gpio.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/gpio/built-in.o drivers/gpio/mxc_gpio.o
make -f ./scripts/Makefile.build obj=drivers/i2c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/i2c/.i2c_core.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(i2c_core)"  -D"KBUILD_MODNAME=KBUILD_STR(i2c_core)" -c -o drivers/i2c/i2c_core.o drivers/i2c/i2c_core.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/i2c/.mxc_i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mxc_i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(mxc_i2c)" -c -o drivers/i2c/mxc_i2c.o drivers/i2c/mxc_i2c.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/i2c/built-in.o drivers/i2c/i2c_core.o drivers/i2c/mxc_i2c.o
make -f ./scripts/Makefile.build obj=drivers/mmc
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.fsl_esdhc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fsl_esdhc)"  -D"KBUILD_MODNAME=KBUILD_STR(fsl_esdhc)" -c -o drivers/mmc/fsl_esdhc.o drivers/mmc/fsl_esdhc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.mmc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc)" -c -o drivers/mmc/mmc.o drivers/mmc/mmc.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mmc/.mmc_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mmc_write)"  -D"KBUILD_MODNAME=KBUILD_STR(mmc_write)" -c -o drivers/mmc/mmc_write.o drivers/mmc/mmc_write.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mmc/built-in.o drivers/mmc/fsl_esdhc.o drivers/mmc/mmc.o drivers/mmc/mmc_write.o
make -f ./scripts/Makefile.build obj=drivers/mtd
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/.mtdcore.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mtdcore)"  -D"KBUILD_MODNAME=KBUILD_STR(mtdcore)" -c -o drivers/mtd/mtdcore.o drivers/mtd/mtdcore.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/.mtd_uboot.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(mtd_uboot)"  -D"KBUILD_MODNAME=KBUILD_STR(mtd_uboot)" -c -o drivers/mtd/mtd_uboot.o drivers/mtd/mtd_uboot.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mtd/built-in.o drivers/mtd/mtdcore.o drivers/mtd/mtd_uboot.o
make -f ./scripts/Makefile.build obj=drivers/mtd/onenand
   rm -f drivers/mtd/onenand/built-in.o; arm-linux-gnueabihf-ar rcs drivers/mtd/onenand/built-in.o
make -f ./scripts/Makefile.build obj=drivers/mtd/spi
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf_probe.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf_probe)"  -D"KBUILD_MODNAME=KBUILD_STR(sf_probe)" -c -o drivers/mtd/spi/sf_probe.o drivers/mtd/spi/sf_probe.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.spi_flash.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(spi_flash)"  -D"KBUILD_MODNAME=KBUILD_STR(spi_flash)" -c -o drivers/mtd/spi/spi_flash.o drivers/mtd/spi/spi_flash.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf_params.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf_params)"  -D"KBUILD_MODNAME=KBUILD_STR(sf_params)" -c -o drivers/mtd/spi/sf_params.o drivers/mtd/spi/sf_params.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/mtd/spi/.sf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(sf)"  -D"KBUILD_MODNAME=KBUILD_STR(sf)" -c -o drivers/mtd/spi/sf.o drivers/mtd/spi/sf.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/mtd/spi/built-in.o drivers/mtd/spi/sf_probe.o drivers/mtd/spi/spi_flash.o drivers/mtd/spi/sf_params.o drivers/mtd/spi/sf.o
make -f ./scripts/Makefile.build obj=drivers/net
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/.fec_mxc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fec_mxc)"  -D"KBUILD_MODNAME=KBUILD_STR(fec_mxc)" -c -o drivers/net/fec_mxc.o drivers/net/fec_mxc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/net/built-in.o drivers/net/fec_mxc.o
make -f ./scripts/Makefile.build obj=drivers/net/phy
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.phy.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(phy)"  -D"KBUILD_MODNAME=KBUILD_STR(phy)" -c -o drivers/net/phy/phy.o drivers/net/phy/phy.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.realtek.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(realtek)"  -D"KBUILD_MODNAME=KBUILD_STR(realtek)" -c -o drivers/net/phy/realtek.o drivers/net/phy/realtek.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/net/phy/.smsc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(smsc)"  -D"KBUILD_MODNAME=KBUILD_STR(smsc)" -c -o drivers/net/phy/smsc.o drivers/net/phy/smsc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/net/phy/built-in.o drivers/net/phy/phy.o drivers/net/phy/realtek.o drivers/net/phy/smsc.o
make -f ./scripts/Makefile.build obj=drivers/pci
   rm -f drivers/pci/built-in.o; arm-linux-gnueabihf-ar rcs drivers/pci/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/.power_core.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(power_core)"  -D"KBUILD_MODNAME=KBUILD_STR(power_core)" -c -o drivers/power/power_core.o drivers/power/power_core.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/.power_i2c.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(power_i2c)"  -D"KBUILD_MODNAME=KBUILD_STR(power_i2c)" -c -o drivers/power/power_i2c.o drivers/power/power_i2c.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/power/built-in.o drivers/power/power_core.o drivers/power/power_i2c.o
make -f ./scripts/Makefile.build obj=drivers/power/battery
   rm -f drivers/power/battery/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/battery/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/fuel_gauge
   rm -f drivers/power/fuel_gauge/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/fuel_gauge/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/mfd
   rm -f drivers/power/mfd/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/mfd/built-in.o
make -f ./scripts/Makefile.build obj=drivers/power/pmic
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/power/pmic/.pmic_pfuze3000.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(pmic_pfuze3000)"  -D"KBUILD_MODNAME=KBUILD_STR(pmic_pfuze3000)" -c -o drivers/power/pmic/pmic_pfuze3000.o drivers/power/pmic/pmic_pfuze3000.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/power/pmic/built-in.o drivers/power/pmic/pmic_pfuze3000.o
make -f ./scripts/Makefile.build obj=drivers/power/regulator
   rm -f drivers/power/regulator/built-in.o; arm-linux-gnueabihf-ar rcs drivers/power/regulator/built-in.o
make -f ./scripts/Makefile.build obj=drivers/serial
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/serial/.serial.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(serial)"  -D"KBUILD_MODNAME=KBUILD_STR(serial)" -c -o drivers/serial/serial.o drivers/serial/serial.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/serial/.serial_mxc.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(serial_mxc)"  -D"KBUILD_MODNAME=KBUILD_STR(serial_mxc)" -c -o drivers/serial/serial_mxc.o drivers/serial/serial_mxc.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/serial/built-in.o drivers/serial/serial.o drivers/serial/serial_mxc.o
make -f ./scripts/Makefile.build obj=drivers/spi
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/spi/.spi.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(spi)"  -D"KBUILD_MODNAME=KBUILD_STR(spi)" -c -o drivers/spi/spi.o drivers/spi/spi.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/spi/.fsl_qspi.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fsl_qspi)"  -D"KBUILD_MODNAME=KBUILD_STR(fsl_qspi)" -c -o drivers/spi/fsl_qspi.o drivers/spi/fsl_qspi.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/spi/built-in.o drivers/spi/spi.o drivers/spi/fsl_qspi.o
make -f ./scripts/Makefile.build obj=drivers/usb/dwc3
   rm -f drivers/usb/dwc3/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/dwc3/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/emul
   rm -f drivers/usb/emul/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/emul/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/eth
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/eth/.usb_ether.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(usb_ether)"  -D"KBUILD_MODNAME=KBUILD_STR(usb_ether)" -c -o drivers/usb/eth/usb_ether.o drivers/usb/eth/usb_ether.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/eth/.asix.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(asix)"  -D"KBUILD_MODNAME=KBUILD_STR(asix)" -c -o drivers/usb/eth/asix.o drivers/usb/eth/asix.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/usb/eth/built-in.o drivers/usb/eth/usb_ether.o drivers/usb/eth/asix.o
make -f ./scripts/Makefile.build obj=drivers/usb/gadget
   rm -f drivers/usb/gadget/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/gadget/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/gadget/udc
   rm -f drivers/usb/gadget/udc/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/gadget/udc/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/host
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/host/.ehci-hcd.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ehci_hcd)"  -D"KBUILD_MODNAME=KBUILD_STR(ehci_hcd)" -c -o drivers/usb/host/ehci-hcd.o drivers/usb/host/ehci-hcd.c
  arm-linux-gnueabihf-gcc -Wp,-MD,drivers/usb/host/.ehci-mx6.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ehci_mx6)"  -D"KBUILD_MODNAME=KBUILD_STR(ehci_mx6)" -c -o drivers/usb/host/ehci-mx6.o drivers/usb/host/ehci-mx6.c
   arm-linux-gnueabihf-ld.bfd     -r -o drivers/usb/host/built-in.o drivers/usb/host/ehci-hcd.o drivers/usb/host/ehci-mx6.o
make -f ./scripts/Makefile.build obj=drivers/usb/musb-new
   rm -f drivers/usb/musb-new/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/musb-new/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/musb
   rm -f drivers/usb/musb/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/musb/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/phy
   rm -f drivers/usb/phy/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/phy/built-in.o
make -f ./scripts/Makefile.build obj=drivers/usb/ulpi
   rm -f drivers/usb/ulpi/built-in.o; arm-linux-gnueabihf-ar rcs drivers/usb/ulpi/built-in.o
make -f ./scripts/Makefile.build obj=fs
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/.fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fs)"  -D"KBUILD_MODNAME=KBUILD_STR(fs)" -c -o fs/fs.o fs/fs.c
make -f ./scripts/Makefile.build obj=fs/ext4
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4fs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4fs)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4fs)" -c -o fs/ext4/ext4fs.o fs/ext4/ext4fs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_common)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_common)" -c -o fs/ext4/ext4_common.o fs/ext4/ext4_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.dev.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(dev)"  -D"KBUILD_MODNAME=KBUILD_STR(dev)" -c -o fs/ext4/dev.o fs/ext4/dev.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_write)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_write)" -c -o fs/ext4/ext4_write.o fs/ext4/ext4_write.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.ext4_journal.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ext4_journal)"  -D"KBUILD_MODNAME=KBUILD_STR(ext4_journal)" -c -o fs/ext4/ext4_journal.o fs/ext4/ext4_journal.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/ext4/.crc16.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc16)"  -D"KBUILD_MODNAME=KBUILD_STR(crc16)" -c -o fs/ext4/crc16.o fs/ext4/crc16.c
   arm-linux-gnueabihf-ld.bfd     -r -o fs/ext4/built-in.o fs/ext4/ext4fs.o fs/ext4/ext4_common.o fs/ext4/dev.o fs/ext4/ext4_write.o fs/ext4/ext4_journal.o fs/ext4/crc16.o
make -f ./scripts/Makefile.build obj=fs/fat
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/fat/.fat_write.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fat_write)"  -D"KBUILD_MODNAME=KBUILD_STR(fat_write)" -c -o fs/fat/fat_write.o fs/fat/fat_write.c
  arm-linux-gnueabihf-gcc -Wp,-MD,fs/fat/.file.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(file)"  -D"KBUILD_MODNAME=KBUILD_STR(file)" -c -o fs/fat/file.o fs/fat/file.c
   arm-linux-gnueabihf-ld.bfd     -r -o fs/fat/built-in.o fs/fat/fat_write.o fs/fat/file.o
   arm-linux-gnueabihf-ld.bfd     -r -o fs/built-in.o fs/fs.o fs/ext4/built-in.o fs/fat/built-in.o
make -f ./scripts/Makefile.build obj=lib
make -f ./scripts/Makefile.build obj=lib/libfdt
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt)" -c -o lib/libfdt/fdt.o lib/libfdt/fdt.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_ro.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_ro)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_ro)" -c -o lib/libfdt/fdt_ro.o lib/libfdt/fdt_ro.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_rw.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_rw)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_rw)" -c -o lib/libfdt/fdt_rw.o lib/libfdt/fdt_rw.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_strerror.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_strerror)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_strerror)" -c -o lib/libfdt/fdt_strerror.o lib/libfdt/fdt_strerror.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_sw.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_sw)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_sw)" -c -o lib/libfdt/fdt_sw.o lib/libfdt/fdt_sw.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_wip.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_wip)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_wip)" -c -o lib/libfdt/fdt_wip.o lib/libfdt/fdt_wip.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_empty_tree.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_empty_tree)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_empty_tree)" -c -o lib/libfdt/fdt_empty_tree.o lib/libfdt/fdt_empty_tree.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_addresses.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_addresses)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_addresses)" -c -o lib/libfdt/fdt_addresses.o lib/libfdt/fdt_addresses.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/libfdt/.fdt_region.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(fdt_region)"  -D"KBUILD_MODNAME=KBUILD_STR(fdt_region)" -c -o lib/libfdt/fdt_region.o lib/libfdt/fdt_region.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/libfdt/built-in.o lib/libfdt/fdt.o lib/libfdt/fdt_ro.o lib/libfdt/fdt_rw.o lib/libfdt/fdt_strerror.o lib/libfdt/fdt_sw.o lib/libfdt/fdt_wip.o lib/libfdt/fdt_empty_tree.o lib/libfdt/fdt_addresses.o lib/libfdt/fdt_region.o
make -f ./scripts/Makefile.build obj=lib/zlib
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/zlib/.zlib.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(zlib)"  -D"KBUILD_MODNAME=KBUILD_STR(zlib)" -c -o lib/zlib/zlib.o lib/zlib/zlib.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/zlib/built-in.o lib/zlib/zlib.o
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc7.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc7)"  -D"KBUILD_MODNAME=KBUILD_STR(crc7)" -c -o lib/crc7.o lib/crc7.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc8.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc8)"  -D"KBUILD_MODNAME=KBUILD_STR(crc8)" -c -o lib/crc8.o lib/crc8.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc16.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc16)"  -D"KBUILD_MODNAME=KBUILD_STR(crc16)" -c -o lib/crc16.o lib/crc16.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.gunzip.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(gunzip)"  -D"KBUILD_MODNAME=KBUILD_STR(gunzip)" -c -o lib/gunzip.o lib/gunzip.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.initcall.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(initcall)"  -D"KBUILD_MODNAME=KBUILD_STR(initcall)" -c -o lib/initcall.o lib/initcall.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.lmb.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(lmb)"  -D"KBUILD_MODNAME=KBUILD_STR(lmb)" -c -o lib/lmb.o lib/lmb.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.ldiv.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ldiv)"  -D"KBUILD_MODNAME=KBUILD_STR(ldiv)" -c -o lib/ldiv.o lib/ldiv.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.net_utils.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net_utils)"  -D"KBUILD_MODNAME=KBUILD_STR(net_utils)" -c -o lib/net_utils.o lib/net_utils.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.qsort.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(qsort)"  -D"KBUILD_MODNAME=KBUILD_STR(qsort)" -c -o lib/qsort.o lib/qsort.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.rc4.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(rc4)"  -D"KBUILD_MODNAME=KBUILD_STR(rc4)" -c -o lib/rc4.o lib/rc4.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.strmhz.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(strmhz)"  -D"KBUILD_MODNAME=KBUILD_STR(strmhz)" -c -o lib/strmhz.o lib/strmhz.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.list_sort.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(list_sort)"  -D"KBUILD_MODNAME=KBUILD_STR(list_sort)" -c -o lib/list_sort.o lib/list_sort.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.hashtable.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hashtable)"  -D"KBUILD_MODNAME=KBUILD_STR(hashtable)" -c -o lib/hashtable.o lib/hashtable.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.errno.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(errno)"  -D"KBUILD_MODNAME=KBUILD_STR(errno)" -c -o lib/errno.o lib/errno.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.display_options.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(display_options)"  -D"KBUILD_MODNAME=KBUILD_STR(display_options)" -c -o lib/display_options.o lib/display_options.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.crc32.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(crc32)"  -D"KBUILD_MODNAME=KBUILD_STR(crc32)" -c -o lib/crc32.o lib/crc32.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.ctype.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ctype)"  -D"KBUILD_MODNAME=KBUILD_STR(ctype)" -c -o lib/ctype.o lib/ctype.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.div64.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(div64)"  -D"KBUILD_MODNAME=KBUILD_STR(div64)" -c -o lib/div64.o lib/div64.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.hang.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hang)"  -D"KBUILD_MODNAME=KBUILD_STR(hang)" -c -o lib/hang.o lib/hang.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.linux_compat.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(linux_compat)"  -D"KBUILD_MODNAME=KBUILD_STR(linux_compat)" -c -o lib/linux_compat.o lib/linux_compat.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.linux_string.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(linux_string)"  -D"KBUILD_MODNAME=KBUILD_STR(linux_string)" -c -o lib/linux_string.o lib/linux_string.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.membuff.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(membuff)"  -D"KBUILD_MODNAME=KBUILD_STR(membuff)" -c -o lib/membuff.o lib/membuff.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.slre.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(slre)"  -D"KBUILD_MODNAME=KBUILD_STR(slre)" -c -o lib/slre.o lib/slre.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.string.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(string)"  -D"KBUILD_MODNAME=KBUILD_STR(string)" -c -o lib/string.o lib/string.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.time.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(time)"  -D"KBUILD_MODNAME=KBUILD_STR(time)" -c -o lib/time.o lib/time.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.vsprintf.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(vsprintf)"  -D"KBUILD_MODNAME=KBUILD_STR(vsprintf)" -c -o lib/vsprintf.o lib/vsprintf.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.panic.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(panic)"  -D"KBUILD_MODNAME=KBUILD_STR(panic)" -c -o lib/panic.o lib/panic.c
  arm-linux-gnueabihf-gcc -Wp,-MD,lib/.strto.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(strto)"  -D"KBUILD_MODNAME=KBUILD_STR(strto)" -c -o lib/strto.o lib/strto.c
   arm-linux-gnueabihf-ld.bfd     -r -o lib/built-in.o lib/zlib/built-in.o lib/libfdt/built-in.o lib/crc7.o lib/crc8.o lib/crc16.o lib/gunzip.o lib/initcall.o lib/lmb.o lib/ldiv.o lib/net_utils.o lib/qsort.o lib/rc4.o lib/strmhz.o lib/list_sort.o lib/hashtable.o lib/errno.o lib/display_options.o lib/crc32.o lib/ctype.o lib/div64.o lib/hang.o lib/linux_compat.o lib/linux_string.o lib/membuff.o lib/slre.o lib/string.o lib/time.o lib/vsprintf.o lib/panic.o lib/strto.o
make -f ./scripts/Makefile.build obj=net
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.checksum.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(checksum)"  -D"KBUILD_MODNAME=KBUILD_STR(checksum)" -c -o net/checksum.o net/checksum.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.arp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(arp)"  -D"KBUILD_MODNAME=KBUILD_STR(arp)" -c -o net/arp.o net/arp.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.bootp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(bootp)"  -D"KBUILD_MODNAME=KBUILD_STR(bootp)" -c -o net/bootp.o net/bootp.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.eth_legacy.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eth_legacy)"  -D"KBUILD_MODNAME=KBUILD_STR(eth_legacy)" -c -o net/eth_legacy.o net/eth_legacy.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.eth_common.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(eth_common)"  -D"KBUILD_MODNAME=KBUILD_STR(eth_common)" -c -o net/eth_common.o net/eth_common.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.net.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(net)"  -D"KBUILD_MODNAME=KBUILD_STR(net)" -c -o net/net.o net/net.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.nfs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(nfs)"  -D"KBUILD_MODNAME=KBUILD_STR(nfs)" -c -o net/nfs.o net/nfs.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.ping.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(ping)"  -D"KBUILD_MODNAME=KBUILD_STR(ping)" -c -o net/ping.o net/ping.c
  arm-linux-gnueabihf-gcc -Wp,-MD,net/.tftp.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(tftp)"  -D"KBUILD_MODNAME=KBUILD_STR(tftp)" -c -o net/tftp.o net/tftp.c
   arm-linux-gnueabihf-ld.bfd     -r -o net/built-in.o net/checksum.o net/arp.o net/bootp.o net/eth_legacy.o net/eth_common.o net/net.o net/nfs.o net/ping.o net/tftp.o
make -f ./scripts/Makefile.build obj=test
   rm -f test/built-in.o; arm-linux-gnueabihf-ar rcs test/built-in.o
make -f ./scripts/Makefile.build obj=test/dm
  arm-linux-gnueabihf-gcc -Wp,-MD,test/dm/.cmd_dm.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(cmd_dm)"  -D"KBUILD_MODNAME=KBUILD_STR(cmd_dm)" -c -o test/dm/cmd_dm.o test/dm/cmd_dm.c
   arm-linux-gnueabihf-ld.bfd     -r -o test/dm/built-in.o test/dm/cmd_dm.o
make -f ./scripts/Makefile.build obj=examples
make -f ./scripts/Makefile.build obj=examples/standalone
  arm-linux-gnueabihf-gcc -Wp,-MD,examples/standalone/.stubs.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -fno-toplevel-reorder -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(stubs)"  -D"KBUILD_MODNAME=KBUILD_STR(stubs)" -c -o examples/standalone/stubs.o examples/standalone/stubs.c
  arm-linux-gnueabihf-ld.bfd     -r -o examples/standalone/libstubs.o examples/standalone/stubs.o
  arm-linux-gnueabihf-gcc -Wp,-MD,examples/standalone/.hello_world.o.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__ -Wall -Wstrict-prototypes -Wno-format-security -fno-builtin -ffreestanding -Os -fno-stack-protector -fno-delete-null-pointer-checks -g -fstack-usage -Wno-format-nonliteral -Werror=date-time -fno-toplevel-reorder -D__ARM__ -marm -mno-thumb-interwork -mabi=aapcs-linux -mword-relocations -fno-pic -mno-unaligned-access -ffunction-sections -fdata-sections -fno-common -ffixed-r9 -msoft-float -pipe -march=armv7-a    -D"KBUILD_STR(s)=#s" -D"KBUILD_BASENAME=KBUILD_STR(hello_world)"  -D"KBUILD_MODNAME=KBUILD_STR(hello_world)" -c -o examples/standalone/hello_world.o examples/standalone/hello_world.c
  arm-linux-gnueabihf-ld.bfd   -g -Ttext 0xc100000 -o examples/standalone/hello_world -e hello_world examples/standalone/hello_world.o examples/standalone/libstubs.o -L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4 -lgcc
  arm-linux-gnueabihf-objcopy -O srec  examples/standalone/hello_world examples/standalone/hello_world.srec
  arm-linux-gnueabihf-objcopy -O binary  examples/standalone/hello_world examples/standalone/hello_world.bin
  arm-linux-gnueabihf-gcc -E -Wp,-MD,./.u-boot.lds.d -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a   -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -include ./include/u-boot/u-boot.lds.h -DCPUDIR=arch/arm/cpu/armv7  -ansi -D__ASSEMBLY__ -x assembler-with-cpp -P -o u-boot.lds arch/arm/cpu/u-boot.lds
  arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o --start-group  arch/arm/cpu/built-in.o  arch/arm/cpu/armv7/built-in.o  arch/arm/imx-common/built-in.o  arch/arm/lib/built-in.o  board/freescale/common/built-in.o  board/freescale/mx6ullevk/built-in.o  cmd/built-in.o  common/built-in.o  disk/built-in.o  drivers/built-in.o  drivers/dma/built-in.o  drivers/gpio/built-in.o  drivers/i2c/built-in.o  drivers/mmc/built-in.o  drivers/mtd/built-in.o  drivers/mtd/onenand/built-in.o  drivers/mtd/spi/built-in.o  drivers/net/built-in.o  drivers/net/phy/built-in.o  drivers/pci/built-in.o  drivers/power/built-in.o  drivers/power/battery/built-in.o  drivers/power/fuel_gauge/built-in.o  drivers/power/mfd/built-in.o  drivers/power/pmic/built-in.o  drivers/power/regulator/built-in.o  drivers/serial/built-in.o  drivers/spi/built-in.o  drivers/usb/dwc3/built-in.o  drivers/usb/emul/built-in.o  drivers/usb/eth/built-in.o  drivers/usb/gadget/built-in.o  drivers/usb/gadget/udc/built-in.o  drivers/usb/host/built-in.o  drivers/usb/musb-new/built-in.o  drivers/usb/musb/built-in.o  drivers/usb/phy/built-in.o  drivers/usb/ulpi/built-in.o  fs/built-in.o  lib/built-in.o  net/built-in.o  test/built-in.o  test/dm/built-in.o --end-group arch/arm/lib/eabi_compat.o  -L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4 -lgcc -Map u-boot.map
  arm-linux-gnueabihf-objcopy --gap-fill=0xff  -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O binary  u-boot u-boot-nodtb.bin
  cp u-boot-nodtb.bin u-boot.bin
make -f ./scripts/Makefile.build obj=arch/arm/imx-common u-boot.imx
mkdir -p board/freescale/mx6ullevk/
  arm-linux-gnueabihf-gcc -E -Wp,-MD,board/freescale/mx6ullevk/.imximage-ddr512.cfg.cfgtmp.d  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h -D__KERNEL__ -D__UBOOT__    -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a     -x c -o board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp board/freescale/mx6ullevk/imximage-ddr512.cfg
  ./tools/mkimage -n board/freescale/mx6ullevk/imximage-ddr512.cfg.cfgtmp -T imximage -e 0x87800000 -d u-boot.bin u-boot.imx
Image Type:   Freescale IMX Boot Image
Image Ver:    2 (i.MX53/6/7 compatible)
Mode:         DCD
Data Size:    364544 Bytes = 356.00 kB = 0.35 MB
Load Address: 877ff420
Entry Point:  87800000
  arm-linux-gnueabihf-objcopy --gap-fill=0xff  -j .text -j .secure_text -j .rodata -j .hash -j .data -j .got -j .got.plt -j .u_boot_list -j .rel.dyn -O srec u-boot u-boot.srec
  arm-linux-gnueabihf-objdump -t u-boot > u-boot.sym
  arm-linux-gnueabihf-gcc -E -Wp,-MD,./.u-boot.cfg.d -D__KERNEL__ -D__UBOOT__   -D__ARM__ -marm -mno-thumb-interwork  -mabi=aapcs-linux  -mword-relocations  -fno-pic  -mno-unaligned-access  -ffunction-sections -fdata-sections -fno-common -ffixed-r9  -msoft-float  -pipe  -march=armv7-a   -Iinclude   -I./arch/arm/include -include ./include/linux/kconfig.h  -nostdinc -isystem /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4/include -include ./include/u-boot/u-boot.lds.h -DCPUDIR=arch/arm/cpu/armv7  -ansi -DDO_DEPS_ONLY -D__ASSEMBLY__ -x assembler-with-cpp -P -dM -E -o u-boot.cfg include/config.h
</..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></..></config_fallbacks.h\></asm></configs></config_uncmd_spl.h\></config_defaults.h\></code></pre></details>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>uboot-链接脚本lds分析</title>
    <url>/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-u-boot-lds-jie-du-armv8">1 <code>u-boot.lds</code>解读（armv8）</a></li>
<li><a href="#2-u-boot-spl-lds-jie-du-armv8">2 <code>u-boot-spl.lds</code>解读（armv8）</a></li>
<li><a href="#3-u-boot-lds-armv7">3 <code>u-boot.lds</code> (armv7)</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-u-boot-lds-jie-du-armv8">1 <code>u-boot.lds</code>解读（armv8）</span><a href="#1-u-boot-lds-jie-du-armv8" class="header-anchor">#</a></h1><p>文件位于<code>u-boot-2021.10\arch\arm\cpu\armv8\u-boot.lds</code>。分析过程已在<code>lds</code>内部注释了.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2013</span></span><br><span class="line"><span class="comment"> * David Feng &lt;fenghua@phytium.com.cn&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2002</span></span><br><span class="line"><span class="comment"> * Gary Jennejohn, DENX Software Engineering, &lt;garyj@denx.de&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;config.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/psci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start) -------------------------------------------------------------------- (<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（1）首先定义了二进制程序的输出格式为&quot;elf64-littleaarch64&quot;，</span></span><br><span class="line"><span class="comment"> *    架构是&quot;aarch64&quot;，程序入口为&quot;_start&quot;符号；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_SECURE_BASE -------------------------------------------------- (2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（2）ARMV8_SECURE_BASE是u-boot对PSCI的支持，在定义时可以将PSCI的文本段，</span></span><br><span class="line"><span class="comment"> *    数据段，堆栈段重定向到指定的内存，而不是内嵌到u-boot中。</span></span><br><span class="line"><span class="comment"> *    不过一般厂商实现会使用atf方式使其与bootloader分离，这个功能不常用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> /DISCARD/ : &#123; *(.rela._secure*) &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> . = <span class="number">0x00000000</span>; -------------------------------------------------------------- (<span class="number">3</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（3）定义了程序链接的基地址，默认是0，通过配置CONFIG_SYS_TEXT_BASE可修改</span></span><br><span class="line"><span class="comment"> *    这个默认值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start) --------------------------------------------------- (<span class="number">4</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（4）__image_copy_start和__image_copy_end用于定义需要重定向的段，</span></span><br><span class="line"><span class="comment"> *    u-boot将启动初始化分为了两个部分，重定向前初始化board_f和</span></span><br><span class="line"><span class="comment"> *    重定向后初始化  board_r，在重定向之前完成一些必要初始化，</span></span><br><span class="line"><span class="comment"> *    包括可能的ddr初始化，然后通过__image_copy_start和__image_copy_end</span></span><br><span class="line"><span class="comment"> *    将u-boot搬运到ddr中，并在ddr中进行重定向后初始化。</span></span><br><span class="line"><span class="comment">  CPUDIR/start.o (.text*) -------------------------------------------------- (5)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（5）定义了链接程序的头部文本段，armv8就是</span></span><br><span class="line"><span class="comment"> *    arch/arm/cpu/armv8/start.S，</span></span><br><span class="line"><span class="comment"> *    start.S中所有文本段将会链接到此段中并且段入口符号就是_start；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* This needs to come before *(.text*) */</span></span><br><span class="line"> .efi_runtime : &#123; ------------------------------------------------------------ (<span class="number">6</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（6）在定义了efi运行时相关支持时才会出现使用的段，一般不用关心；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">		__efi_runtime_start = .;</span><br><span class="line">  *(.text.efi_runtime*)</span><br><span class="line">  *(.rodata.efi_runtime*)</span><br><span class="line">  *(.data.efi_runtime*)</span><br><span class="line">		__efi_runtime_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .text_rest : ---------------------------------------------------------------- (<span class="number">7</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（7）除了start.o，其他的所有文本段将会链接到此段中；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#123;</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARMV8_PSCI -------------------------------------------------------- (8)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（8）同（2），是PSCI相关功能的支持，一般不会使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> .__secure_start :</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line">  ALIGN(CONSTANT(COMMONPAGESIZE))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#123;</span><br><span class="line">  KEEP(*(.__secure_start))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ARMV8_SECURE_BASE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> .secure_text CONFIG_ARMV8_SECURE_BASE :</span><br><span class="line">  AT(ADDR(.__secure_start) + SIZEOF(.__secure_start))</span><br><span class="line"> &#123;</span><br><span class="line">  *(._secure.text)</span><br><span class="line">  . = ALIGN(<span class="number">8</span>);</span><br><span class="line">  __secure_svc_tbl_start = .;</span><br><span class="line">  KEEP(*(._secure_svc_tbl_entries))</span><br><span class="line">  __secure_svc_tbl_end = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .secure_data : AT(LOADADDR(.secure_text) + SIZEOF(.secure_text))</span><br><span class="line"> &#123;</span><br><span class="line">  *(._secure.data)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .secure_stack <span class="title function_">ALIGN</span><span class="params">(ADDR(.secure_data) + SIZEOF(.secure_data),</span></span><br><span class="line"><span class="params">	   CONSTANT(COMMONPAGESIZE))</span> <span class="params">(NOLOAD)</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line">  <span class="title function_">AT</span><span class="params">(ADDR(.secure_stack))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="title function_">AT</span><span class="params">(LOADADDR(.secure_data) + SIZEOF(.secure_data))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> &#123;</span><br><span class="line">  KEEP(*(.__secure_stack_start))</span><br><span class="line"></span><br><span class="line">  . = . + CONFIG_ARMV8_PSCI_NR_CPUS * ARM_PSCI_STACK_SIZE;</span><br><span class="line"></span><br><span class="line">  . = ALIGN(CONSTANT(COMMONPAGESIZE));</span><br><span class="line"></span><br><span class="line">  KEEP(*(.__secure_stack_end))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ARMV8_PSCI_STACK_IN_RAM</span></span><br><span class="line"> . = LOADADDR(.secure_stack);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> .__secure_end : AT(ADDR(.__secure_end)) &#123;</span><br><span class="line">  KEEP(*(.__secure_end))</span><br><span class="line">  LONG(<span class="number">0x1d1071c</span>); <span class="comment">/* Must output something to reset LMA */</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125; ------------------- (<span class="number">9</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（9）所有仅读数据将会在这个段中对齐排序存放好；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .data : &#123; -------------------------------------------------------------------- (<span class="number">10</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（10）所有数据段将会链接到此段中；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> . = .;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> .u_boot_list : &#123; ------------------------------------------------------------- (<span class="number">11</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（11）u_boot_list段定义了系统中当前支持的所有命令和设备驱动，此段把散落在各个文件中</span></span><br><span class="line"><span class="comment"> *     通过U_BOOT_CMD的一系列拓展宏定义的命令和U_BOOT_DRIVER的拓展宏定义的设备驱动收集到一起，</span></span><br><span class="line"><span class="comment"> *     并按照名字排序存放，以便后续在命令行快速检索到命令并执行和检测注册的设备和设备树匹配</span></span><br><span class="line"><span class="comment"> *     probe设备驱动初始化；（设备驱动的probe只在定义了dm模块化驱动时有效）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .efi_runtime_rel : &#123;</span><br><span class="line">				__efi_runtime_rel_start = .;</span><br><span class="line">  *(.rel*.efi_runtime)</span><br><span class="line">  *(.rel*.efi_runtime.*)</span><br><span class="line">				__efi_runtime_rel_stop = .;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .image_copy_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .rel_dyn_start : -------------------------------------------------------- (<span class="number">12</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（12）一般u-boot运行时是根据定义的基地址开始执行，如果加载地址和链接地址</span></span><br><span class="line"><span class="comment"> *     不一致则会出现不能执行u-boot的问题。通过一个</span></span><br><span class="line"><span class="comment"> *     配置CONFIG_POSITION_INDEPENDENT即可打开地址无关功能，</span></span><br><span class="line"><span class="comment"> *     此选项会在链接u-boot时添加-PIE参数。此参数会在u-boot ELF文件中</span></span><br><span class="line"><span class="comment"> *     生成rela*段，u-boot通过读取此段中表的相对地址值与实际运行时地址值</span></span><br><span class="line"><span class="comment"> *     依次遍历进行修复当前所有需要重定向地址，使其可以实现地址无关运行；</span></span><br><span class="line"><span class="comment"> *     即无论链接基地址如何定义，u-boot也可以在任意ram地址</span></span><br><span class="line"><span class="comment"> *     运行（一般需要满足最低4K或者64K地址对齐）；</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *     注意此功能只能在sram上实现，因为此功能会在运行时修改文本段数据段中的地址，</span></span><br><span class="line"><span class="comment"> *     如果此时运行在片上flash，则不能写flash，导致功能失效无法实现地址无关；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .rela.dyn : &#123;</span><br><span class="line">  *(.rela*)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> _end = .;</span><br><span class="line"></span><br><span class="line"> . = ALIGN(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"> .bss_start : &#123; -------------------------------------------------------- (<span class="number">13</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（13）众所周知的bbs段；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">8</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .bss_end : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> /DISCARD/ : &#123; *(.dynsym) &#125; -------------------------------------------- (<span class="number">14</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（14）一些在链接时无用需要丢弃的段；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> /DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line"> /DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LINUX_KERNEL_IMAGE_HEADER ----------------------------------- (15)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *（15）在efi加载时会很有用，主要在u-boot的二进制头部添加了一些头部信息，</span></span><br><span class="line"><span class="comment"> *     包括大小端，数据段文本段大小等，以便于efi相关的加载器读取信息，</span></span><br><span class="line"><span class="comment"> *     此头部信息来自于Linux arm64的Image的头部信息；该头部也不属于u-boot的</span></span><br><span class="line"><span class="comment"> *     一部分只是被附加上去的；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;linux-kernel-image-header-vars.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="2-u-boot-spl-lds-jie-du-armv8">2 <code>u-boot-spl.lds</code>解读（armv8）</span><a href="#2-u-boot-spl-lds-jie-du-armv8" class="header-anchor">#</a></h1><p>文件位于<code>u-boot-2021.10\arch\arm\cpu\armv8\u-boot-spl.lds</code>。一般<code>u-boot-spl</code>只有很小的可运行内存块，所以spl中会舍去大量不需要用的段只保留关键的文本段数据段等，并且通过<code>&gt;.sram</code>的形式将不在ddr初始化前用到的段定义到sdram中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0+ */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2013</span></span><br><span class="line"><span class="comment"> * David Feng &lt;fenghua@phytium.com.cn&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2002</span></span><br><span class="line"><span class="comment"> * Gary Jennejohn, DENX Software Engineering, &lt;garyj@denx.de&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (C) Copyright 2010</span></span><br><span class="line"><span class="comment"> * Texas Instruments, &lt;www.ti.com&gt;</span></span><br><span class="line"><span class="comment"> *	Aneesh V &lt;aneesh@ti.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">MEMORY &#123; .sram : ORIGIN = IMAGE_TEXT_BASE,</span><br><span class="line">		LENGTH = IMAGE_MAX_SIZE &#125;</span><br><span class="line">MEMORY &#123; .sdram : ORIGIN = CONFIG_SPL_BSS_START_ADDR,</span><br><span class="line">		LENGTH = CONFIG_SPL_BSS_MAX_SIZE &#125;</span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>, <span class="string">&quot;elf64-littleaarch64&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(aarch64)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__image_copy_start)</span><br><span class="line">		CPUDIR/start.o (.text*)</span><br><span class="line">		*(.text*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.rodata : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.data : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.data*)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPL_RECOVER_DATA_SECTION</span></span><br><span class="line">	.data_save : &#123;</span><br><span class="line">		*(.__data_save_start)</span><br><span class="line">		. = SIZEOF(.data);</span><br><span class="line">		*(.__data_save_end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	.u_boot_list : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.image_copy_end : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__image_copy_end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	.end : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		*(.__end)</span><br><span class="line">	&#125; &gt;.sram</span><br><span class="line"></span><br><span class="line">	_image_binary_end = .;</span><br><span class="line"></span><br><span class="line">	.bss_start (NOLOAD) : &#123;</span><br><span class="line">		. = ALIGN(<span class="number">8</span>);</span><br><span class="line">		KEEP(*(.__bss_start));</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	.bss (NOLOAD) : &#123;</span><br><span class="line">		*(.bss*)</span><br><span class="line">		 . = ALIGN(<span class="number">8</span>);</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	.bss_end (NOLOAD) : &#123;</span><br><span class="line">		KEEP(*(.__bss_end));</span><br><span class="line">	&#125; &gt;.sdram</span><br><span class="line"></span><br><span class="line">	/DISCARD/ : &#123; *(.rela*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynsym) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynstr*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.dynamic*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.plt*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.interp*) &#125;</span><br><span class="line">	/DISCARD/ : &#123; *(.gnu*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本的开头定义了两段内存空间，分别定义了sram和sdram的起始地址和长度。在i.MX8中，<code>include/config/imx8mp_evk.h</code>, 这两段定义对应于CPU内部的sram和外部的ddr。<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/1.png" alt="image"></p>
<p>这里定义了<code>spl-uboot</code>两段空间，一段是从<code>0x920000</code>开始的152K空间，这段空间是内部RAM中的一段。<br>而<code>0x96e000</code>开始的8K空间则是用来存放未初始化的全局变量和未初始化的静态局部变量的BSS数据段，位于外部存储即SDRAM如DDR上，如下图：<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/2.png" alt="image"><br><code>bss段</code>存放的是未初始化的全局变量和局部静态变量，<code>.bss</code>不占据实际的文件大小，只在段表中记录大小，在符号表中记录符号。当文件加载运行时，才分配空间以及初始化。所以实际<code>.bss</code>段只会在运行时才分配空间，分配的空间起始地址也就是从<code>.sdram</code>定义的空间里面。此外，一般重定向也是将boot拷贝搬移到外部<code>sdram</code>中去运行，而对于cpu来说这里bss指定的地址本身就已经在sdram中了。这样也说明了，对于 cpu来说，要使用<code>bss</code>的数据，需要将外部sdram初始化后才能使用。<a href="https://www.cnblogs.com/fuzidage/p/12044558.html" title="s3c2440裸机-清bss原理及实现">s3c2440裸机-清bss原理及实现</a>  <a href="https://fuzidage.github.io/2024/04/15/s3c2440%E8%A3%B8%E6%9C%BA%E7%BC%96%E7%A8%8B-%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%92%8C%E6%B8%85bss/">s3c2440裸机编程-代码重定位和清bss | Hexo (fuzidage.github.io)</a></p>
<h1><span id="3-u-boot-lds-armv7">3 <code>u-boot.lds</code> (armv7)</span><a href="#3-u-boot-lds-armv7" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OUTPUT_FORMAT(<span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>, <span class="string">&quot;elf32-littlearm&quot;</span>)</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line"> . = <span class="number">0x00000000</span>;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .text :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_start)</span><br><span class="line">  *(.vectors)</span><br><span class="line">  arch/arm/cpu/armv7/start.o (.text*)</span><br><span class="line">  *(.text*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .data : &#123;</span><br><span class="line">  *(.data*)</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> . = .;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .u_boot_list : &#123;</span><br><span class="line">  KEEP(*(SORT(.u_boot_list*)));</span><br><span class="line"> &#125;</span><br><span class="line"> . = ALIGN(<span class="number">4</span>);</span><br><span class="line"> .image_copy_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__image_copy_end)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel_dyn_start :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_start)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel.dyn : &#123;</span><br><span class="line">  *(.rel*)</span><br><span class="line"> &#125;</span><br><span class="line"> .rel_dyn_end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__rel_dyn_end)</span><br><span class="line"> &#125;</span><br><span class="line"> .end :</span><br><span class="line"> &#123;</span><br><span class="line">  *(.__end)</span><br><span class="line"> &#125;</span><br><span class="line"> _image_binary_end = .;</span><br><span class="line"> . = ALIGN(<span class="number">4096</span>);</span><br><span class="line"> .mmutable : &#123;</span><br><span class="line">  *(.mmutable)</span><br><span class="line"> &#125;</span><br><span class="line"> .bss_start __rel_dyn_start (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_start));</span><br><span class="line">  __bss_base = .;</span><br><span class="line"> &#125;</span><br><span class="line"> .bss __bss_base (OVERLAY) : &#123;</span><br><span class="line">  *(.bss*)</span><br><span class="line">   . = ALIGN(<span class="number">4</span>);</span><br><span class="line">   __bss_limit = .;</span><br><span class="line"> &#125;</span><br><span class="line"> .bss_end __bss_limit (OVERLAY) : &#123;</span><br><span class="line">  KEEP(*(.__bss_end));</span><br><span class="line"> &#125;</span><br><span class="line"> .dynsym _image_binary_end : &#123; *(.dynsym) &#125;</span><br><span class="line"> .dynbss : &#123; *(.dynbss) &#125;</span><br><span class="line"> .dynstr : &#123; *(.dynstr*) &#125;</span><br><span class="line"> .dynamic : &#123; *(.dynamic*) &#125;</span><br><span class="line"> .plt : &#123; *(.plt*) &#125;</span><br><span class="line"> .interp : &#123; *(.interp*) &#125;</span><br><span class="line"> .gnu.hash : &#123; *(.gnu.hash) &#125;</span><br><span class="line"> .gnu : &#123; *(.gnu*) &#125;</span><br><span class="line"> .ARM.exidx : &#123; *(.ARM.exidx*) &#125;</span><br><span class="line"> .gnu.linkonce.armexidx : &#123; *(.gnu.linkonce.armexidx.*) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_start </code>在文件<code>arch/arm/lib/vectors.S</code>中有定义,表示代码执行入口，也就是第一条指令要放的位置。注意<code>armv7</code>的入口在<code>vectors.S（armv8在start.s）</code>，中断向量表放在指令入口最开始的位置：可以看到—<code>_start</code>后面就是中断向量表，从图中的:<br><code>.section &quot;.vectors&quot;, &quot;ax”</code><br>可以得到，此代码存放在<code>.vectors </code>段里面。</p>
<p><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/3.png" alt="image"><br>打开<code>u-boot.map</code>如下图：因此代码段的排列顺序为：先放中断向量表，也就是<code>vectors.s</code>，然后再放<code>start.s</code>相关内容，最后放其他的<code>.text段（一大堆built-in.o）</code>。<br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/4.png" alt="image"><br><img src="/2024/06/23/uboot-%E9%93%BE%E6%8E%A5%E8%84%9A%E6%9C%AClds%E5%88%86%E6%9E%90/5.png" alt="image"><br>注意这里为什么<code>uboot.map</code>中<code>_start</code>入口地址为什么是<code>0x8780,0000</code>。   链接脚本指定了程序的运行（链接）地址：<br>程序链接时会指定程序的运行（链接)地址：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabihf-ld.bfd   -pie  --gc-sections -Bstatic -Ttext 0x87800000 -o u-boot -T u-boot.lds arch/arm/cpu/armv7/start.o</span><br><span class="line">--start-group  arch/arm/cpu/built-in.o</span><br><span class="line">arch/arm/cpu/armv7/built-in.o</span><br><span class="line">arch/arm/imx-common/built-in.o</span><br><span class="line">arch/arm/lib/built-in.o</span><br><span class="line">board/freescale/common/built-in.o</span><br><span class="line">......</span><br><span class="line">-L /media/cvitek/robin.lee/my_test/study/openedv/toolchain/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin/../lib/gcc/arm-linux-gnueabihf/4.9.4</span><br><span class="line">-lgcc -Map u-boot.map</span><br></pre></td></tr></table></figure>

<p>运行地址<code>0x87800000</code>定义在：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">include/configs/mx6_common.h:86:#define CONFIG_SYS_TEXT_BASE    0x87800000</span></span><br></pre></td></tr></table></figure>

<p>可以从<code>u-boot.map</code>获取下面符号的地址：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>__image_copy_start</code></td>
<td>0x87800000</td>
<td>uboot拷贝的首地址</td>
</tr>
<tr>
<td><code>__image_copy_end</code></td>
<td>0x8785dd54</td>
<td>uboot拷贝的结束地址</td>
</tr>
<tr>
<td><code>__rel_dyn_start</code></td>
<td>0x8785dd54</td>
<td><code>.rel.dyn</code>段起始地址</td>
</tr>
<tr>
<td><code>__rel_dyn_end</code></td>
<td>0x878668f4</td>
<td><code>.rel.dyn</code>段结束地址</td>
</tr>
<tr>
<td><code>_image_binary_end</code></td>
<td>0x878668f4</td>
<td>镜像结束地址</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>linux系统构建</tag>
        <tag>boot启动</tag>
        <tag>uboot</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualbox配置实现PC-虚拟机-开发板互ping</title>
    <url>/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</a><ul>
<li><a href="#1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</a></li>
<li><a href="#1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</a><ul>
<li><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</a></li>
<li><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</a><ul>
<li><a href="#2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</a></li>
<li><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</a></li>
</ul>
</li>
<li><a href="#3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</a></li>
<li><a href="#4-gai-jin-he-you-hua">4 改进和优化</a><ul>
<li><a href="#4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</a></li>
<li><a href="#4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</a></li>
<li><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>


<h1><span id="1-she-zhi-virtualbox-wang-qia">1 设置virtualbox网卡</span><a href="#1-she-zhi-virtualbox-wang-qia" class="header-anchor">#</a></h1><h2><span id="1-1-guan-bi-xu-ni-ji">1.1 关闭虚拟机</span><a href="#1-1-guan-bi-xu-ni-ji" class="header-anchor">#</a></h2><h2><span id="1-2-she-zhi-tian-jia-wang-qia">1.2 设置添加网卡</span><a href="#1-2-she-zhi-tian-jia-wang-qia" class="header-anchor">#</a></h2><p>进入设置-网络</p>
<h3><span id="1-2-1-tian-jia-wang-qia-1-nat-wang-luo">1.2.1 添加网卡1(NAT网络)</span><a href="#1-2-1-tian-jia-wang-qia-1-nat-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过网络地址转换到虚拟机，比如主机用无线网卡WLAN上网，用NAT转换比较合适，这样虚拟机也可以访问外网。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/1.png"></p>
<h3><span id="1-2-2-tian-jia-wang-qia-2-host-only-wang-luo">1.2.2 添加网卡2(host only网络)</span><a href="#1-2-2-tian-jia-wang-qia-2-host-only-wang-luo" class="header-anchor">#</a></h3><p>这个网络是主机通过无线网卡WLAN上外网，但是虚拟机想通过有线网卡和主机、甚至与开发板互相ping通，传输文件。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/2.png"></p>
<p>当然开启host only模式前先确保windows下的virtual host only网卡有开启，如下图：<br><img src="https://img2020.cnblogs.com/blog/1876680/202009/1876680-20200923151634434-1218500133.png"></p>
<p>如果没有请按照下图操作：（这里是添加host only网卡）<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/3.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/4.png"></p>
<h1><span id="2-pei-zhi-windows-he-xu-ni-ji">2 配置windows和虚拟机</span><a href="#2-pei-zhi-windows-he-xu-ni-ji" class="header-anchor">#</a></h1><h2><span id="2-1-pei-zhi-window-yi-tai-wang-qia">2.1 配置window以太网卡</span><a href="#2-1-pei-zhi-window-yi-tai-wang-qia" class="header-anchor">#</a></h2><p>刚添加了虚拟机虚拟virtual host only网卡, 那么我们反正用的WLAN上的外网，为了方便，设置windows下的以太网卡网段和virtual host only网卡保持一致。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/5.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/6.png"></p>
<h2><span id="2-2-pei-zhi-xu-ni-ji-wang-luo">2.2 配置虚拟机网络</span><a href="#2-2-pei-zhi-xu-ni-ji-wang-luo" class="header-anchor">#</a></h2><p>一般默认情况下，虚拟机是通过NAT共享网络给虚拟机用的，那么此时虚拟机也是可以上网的，只是不能和外界开发板进行互相ping, 同时windows主机也不能ping虚拟机。 如下图：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/7.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/8.png"><br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/9.png"><br>图中可以看到两块网卡，enp0s3是Ubuntu默认的网卡（NAT），enp0s8是新增的网卡(host only)，可以看到enp0s8还没有分配IP地址，我们需要手工指定一下。sudo vim &#x2F;etc&#x2F;network&#x2F;interfaces将文件内容修改为如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto enp0s8</span><br><span class="line">iface enp0s8 inet static</span><br><span class="line">address 192.168.56.101</span><br><span class="line">netmask 255.255.255.0</span><br></pre></td></tr></table></figure>
<p>再来看下网卡ip信息：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/10.png"></p>
<h1><span id="3-ce-shi-shang-wang-zhuang-tai">3 测试上网状态</span><a href="#3-ce-shi-shang-wang-zhuang-tai" class="header-anchor">#</a></h1><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/11.png"><br>从测试结果上可以看到虚拟机上外网和ping windows主机都是ok的。</p>
<pre><code>  10.80.0.75时无线网卡的ip，
  192.168.56.100是以太网卡的ip,
  192.168.56.101是host only网卡的ip。 
</code></pre>
<p>同理用Windows ping虚拟机也是ok的。<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/12.png"></p>
<p>用开发板ping主机和虚拟机发现，只能ping通windows主机，无法ping通虚拟机，如下图。这是为什么呢？<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/13.png"></p>
<p>这是由于我们windows主机和开发板用的网线直连，两个以太网卡在同一网段下，当然能够ping通。但是虚拟机和windows主机用的确是host only网卡（NAT方式用来上外网），这样只能保证虚拟机和Windows主机是互通的，但是却无法被开发板访问，我们的开发板是没有无线网卡的，所以不能用WLAN，因此我们要想让开发板访问到虚拟机还得经过windows的以太网卡。</p>
<p>那么我们虚拟机和windows主机是host only方式，所以我们无法用到以太网卡进行虚拟机和windows主机的交互。所以我们可以采取将host only网卡桥接到以太网卡，进入 网络-更改适配器-同时选中host only网卡和以太网卡，点击右键-选择桥接，如下图所示：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/14.png"></p>
<p>这样我们的虚拟机的host only网卡就可以透过以太网卡和开发板交互了，效果如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/15.png"><br>开发板能够ping windows主机和虚拟机。</p>
<h1><span id="4-gai-jin-he-you-hua">4 改进和优化</span><a href="#4-gai-jin-he-you-hua" class="header-anchor">#</a></h1><p>如果不想在windows下进行host only网卡和以太网卡桥接，也可直接把virtualbox的第2路网卡由原来的host only修改成以太网卡桥接模式，如下：<br><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/16.png"></p>
<p>这样需要配置虚拟机的enp0s8网卡和windows主机的以太网卡网段保持一致的。（和前面2.2操作一样）</p>
<h2><span id="4-1-windows-ping-xu-ni-ji">4.1 windows ping 虚拟机</span><a href="#4-1-windows-ping-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/17.png"></p>
<h2><span id="4-2-xu-ni-ji-ping-windows">4.2 虚拟机 ping windows</span><a href="#4-2-xu-ni-ji-ping-windows" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/18.png"></p>
<h2><span id="4-3-kai-fa-ban-ping-windows-he-xu-ni-ji">4.3 开发板 ping windows和虚拟机</span><a href="#4-3-kai-fa-ban-ping-windows-he-xu-ni-ji" class="header-anchor">#</a></h2><p><img src="/2024/03/30/virtualbox%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0PC-%E8%99%9A%E6%8B%9F%E6%9C%BA-%E5%BC%80%E5%8F%91%E6%9D%BF%E4%BA%92ping/19.png"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>union和bit_field巧妙进行寄存器位操作</title>
    <url>/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</a></li>
<li><a href="#2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</a><ul>
<li><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</a></li>
<li><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</a></li>
<li><a href="#2-3-du-qu-ji-cun-qi">2.3 读取寄存器</a></li>
<li><a href="#2-4-xie-ji-cun-qi">2.4 写寄存器</a></li>
<li><a href="#2-5-wei-du-qu">2.5 位读取</a></li>
<li><a href="#2-6-wei-xie-ru">2.6 位写入</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-union-jie-gou-qu-fen-da-xiao-duan">1 union结构区分大小端</span><a href="#1-union-jie-gou-qu-fen-da-xiao-duan" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> read_bits(stc, field)(&#123;stc.raw = 0x12345678; stc.bits.field;&#125;)</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">a</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> raw;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_a : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_b : <span class="number">8</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_c : <span class="number">5</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_d : <span class="number">3</span>;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> bit_e : <span class="number">1</span>;</span><br><span class="line">        &#125;bits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> <span class="title">a</span> <span class="title">num</span>;</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%#x, %#x, %#x, %#x, %#x\n&quot;</span>,</span><br><span class="line">        read_bits(num, bit_a),</span><br><span class="line">        read_bits(num, bit_b),</span><br><span class="line">        read_bits(num, bit_c),</span><br><span class="line">        read_bits(num, bit_d),</span><br><span class="line">        read_bits(num, bit_e));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1-1.png" alt="img"></p>
<p>这样的结果，原理如下图:</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png" alt="img"><br>那么从这里可以看出，低地址对应低字节， 因此我们的运行机器是Little Endian。</p>
<p>那么bit_a&#x3D;0x78; bit_b&#x3D;0x56; bit_c等于0x34取低5位，也就是0x14; bit_d 等于0x34取高3位，也就是0x1； bit_e等于0x12取最低位，也就是0。</p>
<p>由于这里的num是union结构，因此对.raw进行操作，那么也就等于对.bits也进行了操作，那么返回bit field是不是和寄存器的位操作很类似。下面详细介绍如何用union和bit field巧妙进行寄存器位操作。</p>
<h1><span id="2-ji-cun-qi-de-wei-cao-zuo">2 寄存器的位操作</span><a href="#2-ji-cun-qi-de-wei-cao-zuo" class="header-anchor">#</a></h1><p>举个例子，这是mipi-rx DPHY的寄存器的部分截取：</p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/2.png" alt="img"></p>
<p>那么我们可以对该module进行结构定义如下：(当然如果觉得手动去定义麻烦，网上有专门的python工具可以对excel到寄存器定义的转换)<br><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/3.png" alt="img"></p>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/4.png" alt="img"></p>
<p>这里对该module的每个寄存器都定义成union。</p>
<h2><span id="2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang">2.1 offsetof获取结构体成员的偏移量</span><a href="#2-1-offsetof-huo-qu-jie-gou-ti-cheng-yuan-de-pian-yi-liang" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">＃define <span class="title function_">offsetof</span><span class="params">(<span class="type">struct_t</span>,member)</span> <span class="params">( (<span class="type">int</span>)&amp;((<span class="type">struct_t</span> *)<span class="number">0</span>)-&gt;member )</span></span><br></pre></td></tr></table></figure>

<p>(struct_t <em>)0)，可以看到这里*<em>把一个0地址转换成一个指针，它表示一个结构体指针变量，并且是值&#x3D;0的指针</em></em>, 那么访问它的成员，成员的地址自然就会往后递增，因此该成员的地址那么就等于该成员的偏移量。</p>
<p>eg:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么offsetof(struct student, id)就为100 + 4&#x3D;104，同理.name的offsetof为0，.age的offsetof为100，.sex的offsetof为108。</p>
<h2><span id="2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti">2.2 container_of根据结构体成员找到该结构体</span><a href="#2-2-container-of-gen-ju-jie-gou-ti-cheng-yuan-zhao-dao-gai-jie-gou-ti" class="header-anchor">#</a></h2><p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/5.png" alt="img"></p>
<p>该函数实现位于include&#x2F;linux&#x2F;kernel.h， 源码如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;            \</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">typeof</span>(<span class="params"> ((type *</span>)0)-&gt;member ) *__mptr</span> = (ptr);    \</span><br><span class="line">    (type *)( (<span class="built_in">char</span> *)__mptr - offsetof(type,member) );&#125;)</span><br></pre></td></tr></table></figure>

<ol>
<li>定义一个结构体成员指针mptr指向该成员，</li>
<li>用该成员指针减去该成员在结构体中的偏移量，不就是该结构体的起始地址</li>
</ol>
<p><img src="/2024/04/04/union%E5%92%8Cbit-field%E5%B7%A7%E5%A6%99%E8%BF%9B%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%8D%E6%93%8D%E4%BD%9C/6.png" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>=</span>&#123;.name=<span class="string">&quot;robin&quot;</span>, .age=<span class="number">18</span>, .id=<span class="number">123456</span>, .sex=<span class="string">&#x27;M&#x27;</span>&#125;, *pstu;</span><br><span class="line">pstu = container_of(&amp;stu.sex, <span class="keyword">struct</span> student, sex);</span><br></pre></td></tr></table></figure>

<h2><span id="2-3-du-qu-ji-cun-qi">2.3 读取寄存器</span><a href="#2-3-du-qu-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_read(addr) readl((void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPHY_BA_ADDR (0x0300b000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _OFST(_BLK_T, _REG)       ((uint64_t)&amp;(((struct _BLK_T *)0)-&gt;_REG))//this is same with offsetof</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RD_REG(_BA, _BLK_T, _REG) \</span></span><br><span class="line">(_reg_read(_BA+_OFST(_BLK_T, _REG)))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RD_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了read。</p>
<h2><span id="2-4-xie-ji-cun-qi">2.4 写寄存器</span><a href="#2-4-xie-ji-cun-qi" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _reg_write(addr, data) writel(data, (void __iomem *)addr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WR_REG(_BA, _BLK_T, _REG, _V) \</span></span><br><span class="line">                (_reg_write((_BA+_OFST(_BLK_T, _REG)), _V))</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WR_REG(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, <span class="number">0x3333ffff</span>);</span><br></pre></td></tr></table></figure>

<p>这样就表示对该module的REG_08的寄存器进行了write, write的数据为0x3333ffff。</p>
<h2><span id="2-5-wei-du-qu">2.5 位读取</span><a href="#2-5-wei-du-qu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RD_BITS(_BA, _BLK_T, _REG, _FLD) \</span></span><br><span class="line">        (&#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD;\</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>用如下函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">RD_BITS</span>(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，typeof表示对该成员取数据结构类型，然后把该寄存器里的值读出来，最后返回bit[31:16]。</p>
<h2><span id="2-6-wei-xie-ru">2.6 位写入</span><a href="#2-6-wei-xie-ru" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WR_BITS(_BA, _BLK_T, _REG, _FLD, _V) \</span></span><br><span class="line">        <span class="keyword">do</span> &#123;\</span><br><span class="line">                <span class="keyword">typeof</span>(((<span class="keyword">struct</span> _BLK_T *)<span class="number">0</span>)-&gt;_REG) _r;\</span><br><span class="line">                _r.raw = RD_REG(_BA, _BLK_T, _REG);\</span><br><span class="line">                _r.bits._FLD = _V;\</span><br><span class="line">                _reg_write((_BA+_OFST(_BLK_T, _REG)), _r.raw);\</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">WR_BITS(DPHY_BA_ADDR, REG_CSI_DPHY_4LANE_WRAP_T, REG_08, MIPIRX_TEST_BIST1, <span class="number">0x1111</span>);</span><br></pre></td></tr></table></figure>

<p>这里首先是定义了一个module的REG_08的寄存器结构，然后把该寄存器里的值读出来, 再把该寄存器的bit[31:16]写入0x1111。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware双网卡_NAT_桥接</title>
    <url>/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</a></li>
<li><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</a><ul>
<li><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</a></li>
<li><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</a><ul>
<li><a href="#2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</a></li>
<li><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</a></li>
<li><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</a></li>
<li><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</a></li>
<li><a href="#2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-pei-zhi-xu-ni-ji-net-mo-shi">1 配置虚拟机NET模式</span><a href="#1-pei-zhi-xu-ni-ji-net-mo-shi" class="header-anchor">#</a></h1><p>vmware安装后默认就会用NAT方式和pc主机共享网络，虚拟机是通过pc主机的网卡数据转换进行上网的，只要windows主机有网，虚拟机就会对应有网络。<br>NAT模式在这里主要目的就是提供给虚拟机进行上网。<br>如果没有可以进行如下配置，打开虚拟机-&gt;编辑虚拟机设置-&gt;网络适配器,网络连接选择NAT模式如下图：</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/1.png" alt="img"></p>
 <span id="more"></span>

<p>启动进入虚拟机，console输入ifconfig</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/2.png" alt="img"></p>
<p> windows进入cmd,输入ipconfig</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/3.png" alt="img"></p>
<p> VMware Network Adapter VMnet8是虚拟机启用NAT模式后多出来的虚拟网卡，可以看到ip为192.168.70.1，和虚拟机的192.168.70.128同一网段。下图可以看到都可以ping通，且都能访问外网。</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/4.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/5.png" alt="img"></p>
<p> windows搜索框输入vmnet,进入虚拟网络编辑器，可以看到虚拟网络信息，有这个VMnet8，模式为NAT</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/6.png" alt="img"></p>
<h1><span id="2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo">2 配置虚拟机桥接网络</span><a href="#2-pei-zhi-xu-ni-ji-qiao-jie-wang-luo" class="header-anchor">#</a></h1><h2><span id="2-1-fang-fa-1-shi-yong-usb-wang-qia">2.1 方法1：使用usb网卡</span><a href="#2-1-fang-fa-1-shi-yong-usb-wang-qia" class="header-anchor">#</a></h2><p>需要买一个usb网卡，连接板子和windows主机。双网卡配置参考如下视频： <a href="https://www.bilibili.com/video/BV1zV411U7H9?p=3">https://www.bilibili.com/video/BV1zV411U7H9?p=3</a></p>
<h2><span id="2-1-fang-fa-2-shi-yong-lu-you-qi">2.1 方法2：使用路由器</span><a href="#2-1-fang-fa-2-shi-yong-lu-you-qi" class="header-anchor">#</a></h2><h3><span id="2-1-1-tian-jia-qiao-jie-wang-qia">2.1.1 添加桥接网卡</span><a href="#2-1-1-tian-jia-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>桥接网络使用实际的物理网卡进行数据交换，因此需要借助实际的物理网卡，可以是有线网卡，也可以是无线网卡。桥接的目的是为了让虚拟机和主机以及板子能够互相进行收据收发传送。打开虚拟机，配置如下：</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/7.png" alt="img"></p>
<h3><span id="2-1-2-pei-zhi-qiao-jie-wang-qia">2.1.2 配置桥接网卡</span><a href="#2-1-2-pei-zhi-qiao-jie-wang-qia" class="header-anchor">#</a></h3><p>打开vmnet,进入虚拟网络编辑器,在这个里面要把桥接网卡选择成具体的网卡型号，不能设置为自动桥接。注意：这里根据你电脑主机接路由器的网卡，如果你用的无线网卡与路由器通信，那么就要桥接到无线网卡，如果是接网线到路由器，那就要用有线网卡。具体的网卡名字可以进入入网络共享中心-&gt;更改适配器选项或者进入设备管理器来确认清楚。</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/8.png" alt="img"></p>
<p>配置完桥接网卡后，需要配置桥接网卡对应到window主机&#x2F;虚拟机&#x2F;板子的ip.</p>
<h3><span id="2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip">2.1.3 配置虚拟机桥接网卡静态ip</span><a href="#2-1-3-pei-zhi-xu-ni-ji-qiao-jie-wang-qia-jing-tai-ip" class="header-anchor">#</a></h3><p>ifconfig查看，发现桥接的网卡在虚拟机中还没有分配ip.</p>
<p> <img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/9.png" alt="img"></p>
<p>进入ubuntu setting-&gt; network， 设置成和路由器同一网段即可。配置ens36 ip为192.168.2.100</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/10.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/11.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/12.png" alt="img"></p>
<h3><span id="2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip">2.1.4 配置windows主机桥接网卡ip</span><a href="#2-1-4-pei-zhi-windows-zhu-ji-qiao-jie-wang-qia-ip" class="header-anchor">#</a></h3><p>桥接网卡为intel Ethernet Connection I219-V ,ip 192.168.2.6</p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/13.png" alt="img"></p>
<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/14.png" alt="img"></p>
<h3><span id="2-1-5-pei-zhi-kai-fa-ban-ip">2.1.5 配置开发板IP</span><a href="#2-1-5-pei-zhi-kai-fa-ban-ip" class="header-anchor">#</a></h3><p><strong>三者互 ping 验证:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows ip: 192.168.2.6</span><br><span class="line">ubuntu ip:  192.168.2.100</span><br><span class="line">开发板 ip:   192.168.2.xxx</span><br></pre></td></tr></table></figure>

<p><img src="/2024/03/29/vmware%E5%8F%8C%E7%BD%91%E5%8D%A1-NAT-%E6%A1%A5%E6%8E%A5/15.png" alt="img"></p>
]]></content>
      <tags>
        <tag>linux嵌入式环境搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>卷帘快门RollingShutter与全局快门GlobalShutter</title>
    <url>/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-global-shutter">1 Global Shutter</a></li>
<li><a href="#2-rolling-shutter">2 Rolling Shutter</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-global-shutter">1 Global Shutter</span><a href="#1-global-shutter" class="header-anchor">#</a></h1><p>通过整幅场景在同一时间曝光实现的。Sensor所有像素点同时收集光线，同时曝光。即在曝光开始的时候，Sensor开始收集光线；在曝光结束的时候，光线收集电路被切断。CCD就是Global shutter工作方式。所有像元同时曝光</p>
<h1><span id="2-rolling-shutter">2 Rolling Shutter</span><a href="#2-rolling-shutter" class="header-anchor">#</a></h1><p>与Global shutter不同，它是通过Sensor逐行曝光的方式实现的。在曝光开始的时候，Sensor逐行扫描逐行进行曝光，直至所有像素点都被曝光。</p>
<p>对比优缺点:</p>
<p>Global shutter： 曝光时间更短，但会增加读出噪声；</p>
<p>Rolling shutter：可以达到更高的帧速，噪声小，但是运动场景会产生果冻效应。</p>
<p>卷帘快门与全局快门大致原理如下图：</p>
<p align="left">&nbsp;<img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/1.gif" alt width="292" height="165" loading="lazy"></p>

<p>卷帘快门：</p>
<p><img src="/2024/04/03/%E5%8D%B7%E5%B8%98%E5%BF%AB%E9%97%A8RollingShutter%E4%B8%8E%E5%85%A8%E5%B1%80%E5%BF%AB%E9%97%A8GlobalShutter/2.gif" alt width="409" height="187" loading="lazy"></p>

<p><strong>适用性：</strong></p>
<table>
<thead>
<tr>
<th><strong>Global shutter</strong></th>
<th><strong>rolling shutter</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>曝光时间短的应用（如</strong><strong>&lt;500μs****）</strong></td>
<td><strong>曝光时间长（如大于<strong><strong>500μs</strong></strong>）的应用可以有更低的噪声和帧速</strong></td>
</tr>
<tr>
<td><strong>快速移动物体拍适合</strong></td>
<td><strong>静止的物体适合</strong></td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>mipi图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>字符编码与freetype移植</title>
    <url>/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-zi-fu-bian-ma">1 字符编码</a><ul>
<li><a href="#1-1-ascii-bian-ma">1.1 ASCII编码</a></li>
<li><a href="#1-2-ansi">1.2 ANSI</a></li>
<li><a href="#1-3-unicode">1.3 UNICODE</a><ul>
<li><a href="#1-3-1-utf-16-le">1.3.1 UTF-16 LE</a></li>
<li><a href="#1-3-2-utf-16-be">1.3.2 UTF-16 BE</a></li>
</ul>
</li>
<li><a href="#1-4-utf8">1.4 UTF8</a></li>
</ul>
</li>
<li><a href="#2-zhong-wen-zi-ku-yi-zhi">2 中文字库移植</a><ul>
<li><a href="#2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang">2.1 -finput-charset -fexec-charset编译选项</a></li>
<li><a href="#2-2-gb2312-zhuan-wei-utf-8">2.2 GB2312 转为 UTF-8</a></li>
<li><a href="#2-3-utf-8-zhuan-wei-gb2312">2.3 UTF-8 转为 GB2312</a></li>
<li><a href="#2-4-hzk16-zhong-wen-zi-ku">2.4 HZK16中文字库</a></li>
</ul>
</li>
<li><a href="#3-freetype-yi-zhi">3 freetype移植</a><ul>
<li><a href="#3-1-shi-liang-zi-ti">3.1 矢量字体</a></li>
<li><a href="#3-2-xia-zai-freetype">3.2 下载freetype</a></li>
<li><a href="#3-3-bian-yi-freetype">3.3 编译freetype</a><ul>
<li><a href="#3-3-1-she-zhi-gong-ju-lian">3.3.1 设置工具链</a></li>
<li><a href="#3-3-2-bian-yi-zlib">3.3.2 编译zlib</a></li>
<li><a href="#3-3-3-bian-yi-libpng">3.3.3 编译libpng</a></li>
<li><a href="#3-3-4-bian-yi-freetype">3.3.4 编译freetype</a></li>
</ul>
</li>
<li><a href="#3-4-ce-shi">3.4 测试</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-zi-fu-bian-ma">1 字符编码</span><a href="#1-zi-fu-bian-ma" class="header-anchor">#</a></h1><h2><span id="1-1-ascii-bian-ma">1.1 ASCII编码</span><a href="#1-1-ascii-bian-ma" class="header-anchor">#</a></h2><p>ascii是“American Standard Code for Information Interchange”的缩写， 美国信息交换标准代码。</p>
<p>电脑毕竟是西方人发明的，他们常用字母就 26 个，区分大小写、加上标点符号也没超过 127 个，每个字符用一个字节来表示就足够了。一个字节的 7 位就可以表示 128 个数值，在 ASCII 码中最高位永远是 0。</p>
<p>linux-4.18.16&#x2F;lib&#x2F;fonts这个目录下就有对应文件。在这里我挑选font_8x16.c</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/1.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/2.png" alt="img"></p>
<h2><span id="1-2-ansi">1.2 ANSI</span><a href="#1-2-ansi" class="header-anchor">#</a></h2><p>ASNI 是 ASCII 的扩展，向下包含 ASCII。对于 ASCII 字符仍以一个字节来表示。</p>
<p>对于非 ASCII 字符则使用 2 字节来表示。并没有固定的 ASNI 编码。</p>
<p>比如在中国大陆地区， ANSI 的默认编码是 GB2312；</p>
<p>在港澳台地区默认编码是 BIG5。以数值“ 0xd0d6”为例，对于 GB2312 编码它表示“中”；对于 BIG5 编码它表示“ 笢”。</p>
<p>用ANSI编码字符’aa中’的16进制数据</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/3.png" alt="img"></p>
<h2><span id="1-3-unicode">1.3 UNICODE</span><a href="#1-3-unicode" class="header-anchor">#</a></h2><p>在 ANSI 标准中，很多种文字都有自己的编码标准，汉字简体字有 GB2312、繁体字有 BIG5，这难免同一个数值对应不同字符。比如数值“ 0xd0d6”，对于GB2312 编码它表示“中”；对于 BIG5 编码它表示“ 笢”。这造成了使用 ANSI 编码保存的文件，不适合跨地区交流。</p>
<p>UNICODE 编码就是解决这类问题：对于地球上任意一个字符，都给它一个唯一的数值。</p>
<ol>
<li>ASCII 编码中使用一个字节来表示一个字符，只用到其中的 7 位，最高位恒为 0；</li>
<li>ANSI 编码中，对于 ASCII 字符仍使用一个字节来表示(BIT7 是 0)，对于非ASCII 字符一般使用 2 个字节来表示，非 ASCII 字符的数值 BIT7 都是 1</li>
</ol>
<h3><span id="1-3-1-utf-16-le">1.3.1 UTF-16 LE</span><a href="#1-3-1-utf-16-le" class="header-anchor">#</a></h3><p>每个 UNICODE 值用 3 字节来表示有点浪费，那只用 2 字节呢？它可以表示2^16&#x3D;65536 个字符，全世界常用的字符都可以表示了。Little endian 表示小字节序，数值中权重低的字节放在前面，比如字符“ A 中”在 TXT 文件中的数值如下，其中的“ A”使用“0x41 0x00”两字节表示；“中”使用“ 0x2d 0x4e”两字节表示。文件开头的“ 0xff 0xfe”表示“UTF-16 LE”。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/4.png" alt="img"></p>
<h3><span id="1-3-2-utf-16-be">1.3.2 UTF-16 BE</span><a href="#1-3-2-utf-16-be" class="header-anchor">#</a></h3><p>Big endian 表示大字节序，数值中权重低的字节放在后面，比如字符“ ab中”在 TXT 文件中的数值如下，其中的“ A”使用“ 0x00 0x41”两字节表示；“中”使用“ 0x4e 0x2d”两字节表示。文件开头的“ 0xfe 0xff”表示“UTF-16 BE”。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/5.png" alt="img"></p>
<h2><span id="1-4-utf8">1.4 UTF8</span><a href="#1-4-utf8" class="header-anchor">#</a></h2><p>UTF8 是一种变长的编码方法，有 2 种 UTF8格式的文件：带有头部、不带头部。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/6.png" alt="img"></p>
<p>对于 ASCII 字符用UTF-16有空间浪费、而且文件中有某个字节丢失，这会使得后面所有字符都因为错位而无法显示。UTF8则不会有这样的问题。0x41表示大写字母’A’，只用了一个字节。上图中的 3 个字节“ 0xe4 0xb8 0xad”表示的数值是 0x4e2d，对应“中”的 UNICODE 码.</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/7.png" alt="img"></p>
<p>上图中， 0xe4 的二进制是“ 11100100”，高位有 3 个 1，表示从当前字节起有 3 字节参与表示 UNICODE；<br>0xb8 的二进制是“10111000”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；<br>0xad 的二进制是“10101101”，高位有 1 个 1，表示从当前字节起有 1 字节参与表示 UNICODE；<br>除去高位的“ 1110”、“ 10”、“ 10”后，剩下的二进制数组合起来得到“ 01001110001101”，它就是 0x4e2d，即“中”的 UNICODE 值。</p>
<p>使用 UTF8 编码时，即使 TXT 文件中丢失了某些数据，也只会影响到当前字符的显示，后面的字符不受影响。</p>
<h1><span id="2-zhong-wen-zi-ku-yi-zhi">2 中文字库移植</span><a href="#2-zhong-wen-zi-ku-yi-zhi" class="header-anchor">#</a></h1><h2><span id="2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang">2.1 -finput-charset -fexec-charset编译选项</span><a href="#2-1-finput-charset-fexec-charset-bian-yi-xuan-xiang" class="header-anchor">#</a></h2><p>我们编写 C 程序时，可以使用 ANSI 编码，或是 UTF-8 编码；在编译程序时，可以使用以下的选项告诉编译器用什么方式编码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-finput-charset=GB2312</span><br><span class="line">-finput-charset=UTF<span class="number">-8</span></span><br></pre></td></tr></table></figure>

<p>如果不指定<code>-finput-charset</code>， GCC 就会默认 C 程序的编码方式为 UTF8。</p>
<ol>
<li><p>用ANSI格式编写编码，vim浏览显示会乱码，用notepad++采用ANSI编码格式浏览。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/8.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/9.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/10.png" alt="img"></p>
<p>由于编译器默认用utf8编码，所以看到最终打印是乱码的。可以看到“中”的ANSI码是d6 d0。</p>
<ol start="2">
<li><p>用utf8编写代码</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/11.png" alt="img"></p>
</li>
</ol>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/12.png" alt="img"></p>
<p>最终打印是OK的。可以看到“中”的utf8码是e4 b8 ad。</p>
<h2><span id="2-2-gb2312-zhuan-wei-utf-8">2.2 GB2312 转为 UTF-8</span><a href="#2-2-gb2312-zhuan-wei-utf-8" class="header-anchor">#</a></h2><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/13.png" alt="img"></p>
<p>从上面的输出信息可以看出来， GB2312 的”0xd6 0xd0”可以转换为 UTF-8的“ 0xe4 0xb8 0xad”。而如果把原本就是 UTF-8 格式的 test_charset_utf8.c当作 GB2312 格式，会引起错误.</p>
<h2><span id="2-3-utf-8-zhuan-wei-gb2312">2.3 UTF-8 转为 GB2312</span><a href="#2-3-utf-8-zhuan-wei-gb2312" class="header-anchor">#</a></h2><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/14.png" alt="img"></p>
<p>从 上 面 的 输 出 信 息 可 以 看 出 来 ， 如 果 把 原 本 就 是 GB2312 格 式 test_charset_ansi.c 当成UTF-8 格式，会引起错误。而 UTF-8 格式的“中”编码值为“ 0xe4 0xb8 0xad”，可以转换为 GB2312 的“0xd6 0xd0”</p>
<h2><span id="2-4-hzk16-zhong-wen-zi-ku">2.4 HZK16中文字库</span><a href="#2-4-hzk16-zhong-wen-zi-ku" class="header-anchor">#</a></h2><p>HZK16字库里的16×16汉字一共需要256个点来显示，也就是说需要32个字节才能达到显示一个普通汉字的目的。符合GB2312标准。</p>
<p>一个GB2312汉字是由两个字节编码的，范围为A1A1~FEFE。A1-A9为符号区，B0到F7为汉字区。每一个区有94个字符。</p>
<p>HZK16 中是以 GB2312 编码值来查找点阵的，以“中”字为例，它的编码值是“ 0xd6 0xd0”，其中的 0xd6 表示“区码”，表示在哪一个区；其中的 0xd0 表示“位码”，表示它是这个区里的哪一个字符。每一个区有 94 个汉字。区位码从 0xa1 而不是从 0 开始，是为了兼容 ASCII码。</p>
<p>要显示“中”字， 它的 GB2312 编码是 d6d0，它是 HZK16 里第“ (0xd6-0xa1)*94+(0xd0-0xa1)”个字符。(0xd6-0xa1)表示是哪个区，(0xd0-0xa1)表示是哪个位。</p>
<p>如何获取和显示汉字”中“?</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fd_hzk16 = open(<span class="string">&quot;HZK16&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span> (fd_hzk16 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open HZK16\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fstat(fd_hzk16, &amp;hzk_stat))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get fstat\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">hzkmem = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span> , hzk_stat.st_size, PROT_READ, MAP_SHARED, fd_hzk16, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hzkmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap for hzk16\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载HZK16字库，读取并且mmap字库：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/15.png" alt="img"></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/16.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该函数在 LCD 的(x,y)位置处显示汉字字符 str， str[0]中保存区码、 str[1]中保存位码。</span><br><span class="line">第 4734 行确定该汉字属于哪个区；第 4735 行确实它是该区中哪一个汉字。</span><br><span class="line">第 4736 行确实它的字库地址（第多少个字节）：每个区中有 94 个汉字，每个汉字在字库中占据 32 字节。</span><br></pre></td></tr></table></figure>

<p>根据下图来理解字库中每个像素点是如何显示的:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/17.png" alt="img"></p>
<p>总共有十六行，因此需要一个循环 16次的大循环(第 4740 行)。</p>
<p>考虑到一行有两个字节， 在大循环中加入一个 2 次的循环用于区分是哪个字节(第 4741 行)。</p>
<p>最后使用第 3 个循环来处理一个字节中的 8 位(第 4744 行)。对于每一位，它等于 1 时对应的像素被设置为白色，它等于 0 时对应的像素被设置为黑色。需要注意的是根据 x、 y、 i、 j、 b 来计算像素坐标。</p>
<p>测试：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/18.png" alt="img"></p>
<p>注意：使用上述命令时 show_chinese.c 的编码格式必须是 ANSI(GB2312)，因为HZK16字库是按照GB2312编码的，否则编译时需要指定“ -fexec-charset&#x3D;GB2312”。</p>
<h1><span id="3-freetype-yi-zhi">3 freetype移植</span><a href="#3-freetype-yi-zhi" class="header-anchor">#</a></h1><p>FreeType库是一个完全免费（开源）的、高质量的且可移植的字体引擎。Freetype 是开源的字体引擎库， 它提供统一的接口来访问多种字体格式文件，从而实现矢量字体显示。我们只需要移植这个字体引擎，调用对应的 API 接口，提供字体文件，就可以让 freetype 库帮我们取出关键点、实现闭合曲线， 填充颜色， 达到显示矢量字体的目的。</p>
<p>这里仅移植freetype库，freetype的使用不做具体展开。可以从 <a href="https://www.freetype.org/">https://www.freetype.org/</a> 可 以 下 载 到 “ freetype-doc-2.10.2.tar.xz”。</p>
<h2><span id="3-1-shi-liang-zi-ti">3.1 矢量字体</span><a href="#3-1-shi-liang-zi-ti" class="header-anchor">#</a></h2><p>使用点阵字库显示英文字母、汉字时， 大小固定， 如果放大缩小则会模糊甚至有锯齿出现，为了解决这个问题，引用矢量字体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第1步 确定关键点，</span><br><span class="line">第2步 使用数学曲线（ 贝塞尔曲线） 连接头键点，</span><br><span class="line">第3步 填充闭合区线内部空间。</span><br></pre></td></tr></table></figure>

<p>什么是关键点？以字母“ A”为例:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/19.png" alt="img"></p>
<p>再用数学曲线(比如贝塞尔曲线)将关键点都连接起来， 得到一系列的封闭的曲线:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/20.png" alt="img"></p>
<p>最后把封闭空间填满颜色，就显示出一个 A 字母:</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/21.png" alt="img"></p>
<p>如果需要放大或者缩小字体，关键点的相对位置是不变的， 只要数学曲线平滑，字体就不会变形。</p>
<h2><span id="3-2-xia-zai-freetype">3.2 下载freetype</span><a href="#3-2-xia-zai-freetype" class="header-anchor">#</a></h2><p><a href="https://freetype.org/download.html">https://freetype.org/download.html</a></p>
<p><a href="https://download.savannah.gnu.org/releases/freetype/">https://download.savannah.gnu.org/releases/freetype/</a></p>
<p>freetype 依赖于 libpng， libpng 又依赖于 zlib，所以我们应该：先编译安装 zlib，再编译安装 libpng，最后编译安装 freetype。 但是，有些工具链里有 zlib, 那就不用编译安装 zlib.</p>
<p>下载安装libpng: <a href="https://www.linuxfromscratch.org/blfs/view/svn/general/libpng.html">https://www.linuxfromscratch.org/blfs/view/svn/general/libpng.html</a></p>
<p>下载安装zlib: <a href="https://www.zlib.net/fossils/">https://www.zlib.net/fossils/</a></p>
<h2><span id="3-3-bian-yi-freetype">3.3 编译freetype</span><a href="#3-3-bian-yi-freetype" class="header-anchor">#</a></h2><h3><span id="3-3-1-she-zhi-gong-ju-lian">3.3.1 设置工具链</span><a href="#3-3-1-she-zhi-gong-ju-lian" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;main()&#123;&#125;&#x27;</span>| arm-buildroot-linux-gnueabihf-gcc -E -v -</span><br></pre></td></tr></table></figure>

<p>得到头文件的系统目录为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include</span><br><span class="line"></span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include-fixed</span><br><span class="line"> </span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/include</span><br><span class="line"></span><br><span class="line">/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/include</span><br></pre></td></tr></table></figure>

<p>库文件系统目录为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">COMPILER_PATH=/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../libexec/gcc/arm-buildroot-linux-gnueabihf/7.5.0/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../libexec/gcc/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/bin/</span><br><span class="line"></span><br><span class="line">LIBRARY_PATH=/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/lib/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/lib/:/media/cvitek/robin.lee/my_test/study/weidongshan/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib/</span><br></pre></td></tr></table></figure>

<h3><span id="3-3-2-bian-yi-zlib">3.3.2 编译zlib</span><a href="#3-3-2-bian-yi-zlib" class="header-anchor">#</a></h3><p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/22.png" alt="img"></p>
<p>编译zlib库时，.&#x2F;configure不允许传入–host参数；不支持的话需要export CC设置为你的arm工具链</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=arm-buildroot-linux-gnueabihf-gcc</span><br><span class="line">./configure --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">make;make install</span><br><span class="line"><span class="built_in">cd</span> tmp/lib;<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>将lib和头文件拷贝到工具链目录(或者不拷贝，到时候编译用-L, -I指定即可，运行时指定LIBRARY_PATH)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cp include<span class="comment">/* -rf /home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/include</span></span><br><span class="line"><span class="comment">cp lib/* -rfd /home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/bin/../lib/gcc/arm-buildroot-linux-gnueabihf/7.5.0/../../../../arm-buildroot-linux-gnueabihf/lib</span></span><br></pre></td></tr></table></figure>

<h3><span id="3-3-3-bian-yi-libpng">3.3.3 编译libpng</span><a href="#3-3-3-bian-yi-libpng" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host= arm-buildroot-linux-gnueabihf --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">cd</span> tmp/lib;<span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/23.png" alt="img"></p>
<p>将lib和头文件拷贝到工具链目录。</p>
<h3><span id="3-3-4-bian-yi-freetype">3.3.4 编译freetype</span><a href="#3-3-4-bian-yi-freetype" class="header-anchor">#</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --host= arm-buildroot-linux-gnueabihf --prefix=<span class="variable">$PWD</span>/tmp</span><br><span class="line">Make</span><br><span class="line">Make  install</span><br></pre></td></tr></table></figure>

<p>注意：如果你的工具链路径不是 <code>/home/book/100ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot</code>，那么make时会出现类似如下错误。</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/24.png" alt="img"></p>
<p>修改自己工具链下的$(TOOLCHAIN)&#x2F;arm-buildroot-linux-gnueabihf&#x2F;sysroot&#x2F;usr&#x2F;lib目录下编辑libfreetype.la, 替换dependency_libs和libdir的路径。来自 &lt; <a href="http://bbs.100ask.net/question/15908%3E">http://bbs.100ask.net/question/15908&gt;</a></p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/25.png" alt="img"></p>
<p>libfreetype库如下：</p>
<p><img src="/2024/05/25/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E4%B8%8Efreetype%E7%A7%BB%E6%A4%8D/26.png" alt="img"></p>
<p>将lib和头文件拷贝到工具链目录。</p>
<h2><span id="3-4-ce-shi">3.4 测试</span><a href="#3-4-ce-shi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc freetype_show_font.c -I /media/cvitek/robin.lee/my_test/study/weidongshan/<span class="number">100</span>ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/include/freetype2/ -L /media/cvitek/robin.lee/my_test/study/weidongshan/<span class="number">100</span>ask_imx6ull-sdk/ToolChain/arm-buildroot-linux-gnueabihf_sdk-buildroot/arm-buildroot-linux-gnueabihf/sysroot/usr/lib -lfreetype</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ft2build.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_FREETYPE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> FT_GLYPH_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd_fb;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span>        <span class="comment">/* Current var */</span></span><br><span class="line"><span class="type">int</span> screen_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *fbmem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> line_width;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pixel_width;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * 函数名称： lcd_put_pixel</span></span><br><span class="line"><span class="comment"> * 功能描述： 在LCD指定位置上输出指定颜色（描点）</span></span><br><span class="line"><span class="comment"> * 输入参数： x坐标，y坐标，颜色</span></span><br><span class="line"><span class="comment"> * 输出参数： 无</span></span><br><span class="line"><span class="comment"> * 返 回 值： 会</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_put_pixel</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">unsigned</span> <span class="type">int</span> color)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *pen_8 = fbmem+y*line_width+x*pixel_width;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *pen_16;        </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *pen_32;        </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> red, green, blue;        </span><br><span class="line"></span><br><span class="line">    pen_16 = (<span class="type">unsigned</span> <span class="type">short</span> *)pen_8;</span><br><span class="line">    pen_32 = (<span class="type">unsigned</span> <span class="type">int</span> *)pen_8;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (var.bits_per_pixel) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line">            *pen_8 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>: &#123;</span><br><span class="line">            <span class="comment">/* 565 */</span></span><br><span class="line">            red   = (color &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            green = (color &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            blue  = (color &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            color = ((red &gt;&gt; <span class="number">3</span>) &lt;&lt; <span class="number">11</span>) | ((green &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">5</span>) | (blue &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            *pen_16 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">32</span>: &#123;</span><br><span class="line">            *pen_32 = color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t surport %dbpp\n&quot;</span>, var.bits_per_pixel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**********************************************************************</span></span><br><span class="line"><span class="comment"> * 函数名称： draw_bitmap</span></span><br><span class="line"><span class="comment"> * 功能描述： 根据bitmap位图，在LCD指定位置显示汉字</span></span><br><span class="line"><span class="comment"> * 输入参数： x坐标，y坐标，位图指针</span></span><br><span class="line"><span class="comment"> * 输出参数： 无</span></span><br><span class="line"><span class="comment"> * 返 回 值： 无</span></span><br><span class="line"><span class="comment"> ***********************************************************************/</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">draw_bitmap</span><span class="params">( FT_Bitmap* bitmap, FT_Int x, FT_Int y)</span> &#123;</span><br><span class="line">    FT_Int  i, j, p, q;</span><br><span class="line">    FT_Int  x_max = x + bitmap-&gt;width;</span><br><span class="line">    FT_Int  y_max = y + bitmap-&gt;rows;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;x = %d, y = %d\n&quot;, x, y);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = y, q = <span class="number">0</span>; j &lt; y_max; j++, q++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = x, p = <span class="number">0</span>; i &lt; x_max; i++, p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= var.xres || j &gt;= var.yres)</span><br><span class="line">            	<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    		<span class="comment">//image[j][i] |= bitmap-&gt;buffer[q * bitmap-&gt;width + p];</span></span><br><span class="line">    		lcd_put_pixel(i, j, bitmap-&gt;buffer[q * bitmap-&gt;width + p]);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">wchar_t</span> *chinese_str = <span class="string">L&quot;繁&quot;</span>;</span><br><span class="line">    FT_Library          library;</span><br><span class="line">    FT_Face           face;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    FT_Vector     pen;</span><br><span class="line">    FT_GlyphSlot  slot;</span><br><span class="line">    <span class="type">int</span> font_size = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;font_file&gt; [font_size]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">        font_size = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    fd_fb = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd_fb &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/fb0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd_fb, FBIOGET_VSCREENINFO, &amp;var)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t get var\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    line_width  = var.xres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    pixel_width = var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    screen_size = var.xres * var.yres * var.bits_per_pixel / <span class="number">8</span>;</span><br><span class="line">    fbmem = (<span class="type">unsigned</span> <span class="type">char</span> *)mmap(<span class="literal">NULL</span> , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fbmem == (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t mmap\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清屏: 全部设为黑色 */</span></span><br><span class="line">    <span class="built_in">memset</span>(fbmem, <span class="number">0</span>, screen_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 显示矢量字体 */</span></span><br><span class="line">    error = FT_Init_FreeType( &amp;library );                           <span class="comment">/* initialize library */</span></span><br><span class="line">    <span class="comment">/* error handling omitted */</span></span><br><span class="line">    </span><br><span class="line">    error = FT_New_Face( library, argv[<span class="number">1</span>], <span class="number">0</span>, &amp;face ); <span class="comment">/* create face object */</span></span><br><span class="line">    <span class="comment">/* error handling omitted */</span>        </span><br><span class="line">    slot = face-&gt;glyph;</span><br><span class="line"></span><br><span class="line">    FT_Set_Pixel_Sizes(face, font_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 确定座标:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//pen.x = 0;</span></span><br><span class="line">    <span class="comment">//pen.y = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set transformation */</span></span><br><span class="line">    <span class="comment">//FT_Set_Transform( face, 0, &amp;pen);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load glyph image into the slot (erase previous one) */</span></span><br><span class="line">    error = FT_Load_Char( face, chinese_str[<span class="number">0</span>], FT_LOAD_RENDER );</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;FT_Load_Char error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    draw_bitmap( &amp;slot-&gt;bitmap,</span><br><span class="line">                 var.xres/<span class="number">2</span>,</span><br><span class="line">                 var.yres/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>开源插件</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>循环队列FIFO原理图解</title>
    <url>/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</a><ul>
<li><a href="#1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</a></li>
<li><a href="#1-2-fifo-chu-shi-hua">1.2 FIFO初始化</a></li>
<li><a href="#1-3-fifo-xiao-hui">1.3 FIFO销毁</a></li>
<li><a href="#1-4-ru-dui-lie">1.4 入队列</a></li>
<li><a href="#1-5-chu-dui-lie">1.5 出队列</a></li>
<li><a href="#1-6-fifo-pan-kong">1.6 FIFO判空</a></li>
<li><a href="#1-6-fifo-pan-man">1.6 FIFO判满</a></li>
<li><a href="#1-7-fifo-rong-liang">1.7 FIFO容量</a></li>
<li><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</a></li>
<li><a href="#1-9-fifo-bian-li">1.9 FIFO遍历</a></li>
<li><a href="#1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</a><ul>
<li><a href="#1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</a></li>
<li><a href="#1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-ce-shi-yong-li">2 测试用例</a></li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-xun-huan-dui-lie-fifo-jie-shao">1 循环队列FIFO介绍</span><a href="#1-xun-huan-dui-lie-fifo-jie-shao" class="header-anchor">#</a></h1><p>循环队列是把<a href="https://baike.baidu.com/item/%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97/20832734">顺序队列</a>首尾相连，把存储队列元素的表从逻辑上看成一个环，成为循环队列。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/1.png" alt="img"></p>
<p>入队时尾指针向前追赶头指针；出队时头指针向前追赶尾指针。</p>
<h2><span id="1-1-xun-huan-dui-lie-jie-gou">1.1 循环队列结构</span><a href="#1-1-xun-huan-dui-lie-jie-gou" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_HEAD(name, type)                                          \</span></span><br><span class="line">        <span class="keyword">struct</span> name &#123;                                                  \</span><br><span class="line">                <span class="keyword">struct</span> type *fifo;                                     \</span><br><span class="line">                <span class="built_in">int</span> front, tail, capacity;                             \</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">front表示首元素索引</span><br><span class="line">tail表示最后一个元素索引</span><br><span class="line">capacity表示队列的长度</span><br><span class="line">struct type fifo表示该队列中的元素指针，可以指向任意结构体指针</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">struct</span> person_q &#123;                                                        \</span><br><span class="line">    <span class="keyword">struct</span> person* *fifo;                                        \</span><br><span class="line">        <span class="built_in">int</span> front, tail, capacity;                                \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="1-2-fifo-chu-shi-hua">1.2 FIFO初始化</span><a href="#1-2-fifo-chu-shi-hua" class="header-anchor">#</a></h2><p>分配一个连续的空间存储队列元素。用户自定义队列容量。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/2.png" alt="img"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_INIT(head, _capacity) do &#123;                                  \</span></span><br><span class="line">        (head)-&gt;fifo = malloc(<span class="keyword">sizeof</span>(*(head)-&gt;fifo) * _capacity);        \</span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                               \</span><br><span class="line">        (head)-&gt;capacity = _capacity;                                    \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="1-3-fifo-xiao-hui">1.3 FIFO销毁</span><a href="#1-3-fifo-xiao-hui" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EXIT(head) do &#123;                                                \</span></span><br><span class="line">        (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                                \</span><br><span class="line">        (head)-&gt;capacity = <span class="number">0</span>;                                                \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;fifo)                                                \</span><br><span class="line">                free((head)-&gt;fifo);                                        \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2><span id="1-4-ru-dui-lie">1.4 入队列</span><a href="#1-4-ru-dui-lie" class="header-anchor">#</a></h2><p>入队列就是尾元素的索引++，也就是tail++，让新元素放进队列的尾部。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_PUSH(head, elm) do &#123;                                      \</span></span><br><span class="line">        <span class="keyword">if</span> (FIFO_EMPTY(head))                                          \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">0</span>;                      \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;tail = ((head)-&gt;tail == (head)-&gt;capacity - <span class="number">1</span>)  \</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;tail + <span class="number">1</span>;                        \</span><br><span class="line">        (head)-&gt;fifo[(head)-&gt;tail] = elm;                              \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>如果队列是空的，则第一个元素入队列，front和tail索引都指向第一个元素，front &#x3D; tail &#x3D; 0;<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/3.png" alt="img"></p>
<p>其他情况入队，让tail++<br><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/4.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/5.png" alt="img"></p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/6.png" alt="img"></p>
<h2><span id="1-5-chu-dui-lie">1.5 出队列</span><a href="#1-5-chu-dui-lie" class="header-anchor">#</a></h2><p>出队列就是让font对应的元素丢出去，font++。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_POP(head, pelm) do &#123;                                      \</span></span><br><span class="line">        *(pelm) = (head)-&gt;fifo[(head)-&gt;front];                         \</span><br><span class="line">        <span class="keyword">if</span> ((head)-&gt;front == (head)-&gt;tail)                             \</span><br><span class="line">                (head)-&gt;front = (head)-&gt;tail = <span class="number">-1</span>;                     \</span><br><span class="line">        <span class="keyword">else</span>                                                           \</span><br><span class="line">                (head)-&gt;front = ((head)-&gt;front == (head)-&gt;capacity - <span class="number">1</span>)\</span><br><span class="line">                        ? <span class="number">0</span> : (head)-&gt;front + <span class="number">1</span>;                \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当front追上tail后，表示队列空了，重新设置起始点，需要将front &#x3D; tail &#x3D; -1 。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/7.png" alt="img"></p>
<p>其他情况出队，丢出front元素，让front++</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/8.png" alt="img"></p>
<h2><span id="1-6-fifo-pan-kong">1.6 FIFO判空</span><a href="#1-6-fifo-pan-kong" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_EMPTY(head)    ((head)-&gt;front == -1)</span></span><br></pre></td></tr></table></figure>

<p>①队列初始化时，队列是空的，会让front为-1<br>②出队列时，font++, 当font追上tail表示空了，则可以重新设置起始点，令front &#x3D; tail &#x3D; -1<br>综合①②所以可以用-1判断</p>
<h2><span id="1-6-fifo-pan-man">1.6 FIFO判满</span><a href="#1-6-fifo-pan-man" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FULL(head)     (((head)-&gt;front == ((head)-&gt;tail + 1)%(head)-&gt;capacity))</span></span><br></pre></td></tr></table></figure>

<p>①当front&#x3D;0时，那么tail到达capacity-1表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/9.png" alt="img"></p>
<p>②否则，tail追上front后(front &#x3D; tail + 1)表示FIFO full。</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/10.png" alt="img"></p>
<h2><span id="1-7-fifo-rong-liang">1.7 FIFO容量</span><a href="#1-7-fifo-rong-liang" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_CAPACITY(head) ((head)-&gt;capacity)</span></span><br></pre></td></tr></table></figure>

<h2><span id="1-8-fifo-zhong-you-xiao-yuan-su-ge-shu">1.8 FIFO中有效元素个数</span><a href="#1-8-fifo-zhong-you-xiao-yuan-su-ge-shu" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_SIZE(head)     (FIFO_EMPTY(head) ? \</span></span><br><span class="line">        <span class="number">0</span> : ((((head)-&gt;tail + (head)-&gt;capacity - (head)-&gt;front) % (head)-&gt;capacity) + <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>用tail - front就表示有效元素个数，不过由于循环FIFO,可能tail&lt;front,这个时候就需要取余运算，如下图:</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/11.png" alt="img"></p>
<h2><span id="1-9-fifo-bian-li">1.9 FIFO遍历</span><a href="#1-9-fifo-bian-li" class="header-anchor">#</a></h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FOREACH(var, head, idx) \</span></span><br><span class="line">　　<span class="keyword">for</span> (idx = (head)-&gt;front, <span class="keyword">var</span> = (head)-&gt;fifo[idx]; \</span><br><span class="line">　　　　idx &lt; (head)-&gt;front + FIFO_SIZE(head); \</span><br><span class="line">　　　　<span class="keyword">var</span> = (head)-&gt;fifo[++idx % (head)-&gt;capacity])</span><br></pre></td></tr></table></figure>

<h2><span id="1-10-dui-lie-yuan-su-huo-qu">1.10 队列元素获取</span><a href="#1-10-dui-lie-yuan-su-huo-qu" class="header-anchor">#</a></h2><h3><span id="1-10-1-di-yi-ge-yuan-su">1.10.1 第一个元素</span><a href="#1-10-1-di-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_FRONT(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;front])</span></span><br></pre></td></tr></table></figure>
<h3><span id="1-10-2-zui-hou-yi-ge-yuan-su">1.10.2 最后一个元素</span><a href="#1-10-2-zui-hou-yi-ge-yuan-su" class="header-anchor">#</a></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_GET_TAIL(head, pelm) (*(pelm) = (head)-&gt;fifo[(head)-&gt;tail])</span></span><br></pre></td></tr></table></figure>
<h1><span id="2-ce-shi-yong-li">2 测试用例</span><a href="#2-ce-shi-yong-li" class="header-anchor">#</a></h1><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &quot;fifo.h&quot;</span></span><br><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">struct</span> person&#123;</span><br><span class="line">        <span class="built_in">int</span> age;</span><br><span class="line">        <span class="built_in">int</span> id;</span><br><span class="line">        <span class="built_in">char</span> name[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">FIFO_HEAD(person_q, person*);</span><br><span class="line"><span class="keyword">struct</span> person_q person1_queue;</span><br><span class="line"><span class="keyword">struct</span> person_q person2_queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>(<span class="params"><span class="keyword">void</span></span>)</span>&#123;</span><br><span class="line">        FIFO_INIT(&amp;person1_queue, <span class="number">1</span>);</span><br><span class="line">        FIFO_INIT(&amp;person2_queue, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_CAPACITY(&amp;person2_queue) != <span class="number">5</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_CAPACITY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_EMPTY(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_EMPTY 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">20</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1001</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person1_queue, person_a);<span class="comment">//把person_a这个结构体指针元素丢进FIFO,</span></span><br><span class="line">        <span class="comment">//后面对它pop出来又能拿到它，所以不用担心地址弄丢导致无法释放.</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!FIFO_FULL(&amp;person1_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 1 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">30</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1002</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_FULL 2 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 3 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 4 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person1_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">20</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person1_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 5 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        person_a = malloc(<span class="keyword">sizeof</span>(*person_a));</span><br><span class="line">        person_a-&gt;age = <span class="number">40</span>;</span><br><span class="line">        person_a-&gt;id = <span class="number">1003</span>;</span><br><span class="line">        FIFO_PUSH(&amp;person2_queue, person_a);</span><br><span class="line"></span><br><span class="line">        FIFO_GET_FRONT(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_FRONT NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_GET_TAIL(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_GET_TAIL NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">30</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">1</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 6 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">        <span class="keyword">if</span> (person_a-&gt;age != <span class="number">40</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_POP content NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        free(person_a);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (FIFO_SIZE(&amp;person2_queue) != <span class="number">0</span>) &#123;</span><br><span class="line">                printf( <span class="string">&quot;FIFO_SIZE 7 NG.\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">struct</span> person *person_arr[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_FULL(&amp;person2_queue)) &#123;</span><br><span class="line">                person_arr[i] = malloc(<span class="keyword">sizeof</span>(*person_arr[<span class="number">0</span>]));</span><br><span class="line">                person_arr[i]-&gt;age = i;</span><br><span class="line">                person_arr[i]-&gt;id = <span class="number">1000</span> + i;</span><br><span class="line">                FIFO_PUSH(&amp;person2_queue, person_arr[i]);</span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!FIFO_EMPTY(&amp;person2_queue) &#123;</span><br><span class="line">                FIFO_POP(&amp;person2_queue, &amp;person_a);</span><br><span class="line">                printf( <span class="string">&quot;age:%d, id:%d.\n&quot;</span>, person_a-&gt;age, person_a-&gt;id);</span><br><span class="line">                free(person_a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        FIFO_EXIT(&amp;person1_queue);</span><br><span class="line">        FIFO_EXIT(&amp;person2_queue);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="/2024/04/11/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97FIFO%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3/12.png" alt="img"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>通用裸机-arm汇编</title>
    <url>/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-gnu-hui-bian-ge-shi">1 GNU 汇编格式</a><ul>
<li><a href="#1-1-wei-cao-zuo">1.1伪操作</a><ul>
<li><a href="#1-1-1-section">1.1.1 .section</a></li>
<li><a href="#1-1-2-global">1.1.2 .global</a></li>
<li><a href="#1-1-3-comm">1.1.3 .comm</a></li>
<li><a href="#1-1-4-byte-word">1.1.4 .byte ， .word</a></li>
<li><a href="#1-1-5-set-eqv-equ-equiv">1.1.5 .set， .eqv， .equ， .equiv</a></li>
<li><a href="#1-1-6-weak">1.1.6 .weak</a></li>
</ul>
</li>
<li><a href="#1-2-han-shu-ding-yi">1.2 函数定义</a></li>
</ul>
</li>
<li><a href="#2-armv7-hui-bian-zhi-ling">2 ARMv7汇编指令</a><ul>
<li><a href="#2-1-shu-ju-yi-dong-zhi-ling">2.1 数据移动指令</a><ul>
<li><a href="#2-1-1-mov">2.1.1 MOV</a></li>
<li><a href="#2-1-2-mrs">2.1.2 MRS</a></li>
<li><a href="#2-1-3-msr">2.1.3 MSR</a></li>
<li><a href="#2-1-4-cps">2.1.4 CPS</a></li>
</ul>
</li>
<li><a href="#2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram">2.2 数据存取指令（访问存储器RAM）</a><ul>
<li><a href="#2-2-1-ldr">2.2.1 LDR</a></li>
<li><a href="#2-2-2-str">2.2.2 STR</a></li>
<li><a href="#2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng">2.2.3 多寄存器加载存储指令LDMIA，STMIA等</a></li>
</ul>
</li>
<li><a href="#2-3-ru-zhan-chu-zhan-zhi-ling">2.3 入栈出栈指令</a><ul>
<li><a href="#2-3-1-push">2.3.1 PUSH</a></li>
<li><a href="#2-3-2-pop">2.3.2 POP</a></li>
</ul>
<ul>
<li><a href="#2-3-3-stmfd-he-ldmfd">2.3.3 STMFD和LDMFD</a></li>
</ul>
</li>
<li><a href="#2-4-tiao-zhuan-zhi-ling">2.4 跳转指令</a><ul>
<li><a href="#2-4-1-b-zhi-ling">2.4.1 B 指令</a></li>
<li><a href="#2-4-2-bl-zhi-ling">2.4.2 BL 指令</a></li>
</ul>
</li>
<li><a href="#2-5-suan-shu-yun-suan-zhi-ling">2.5 算数运算指令</a></li>
<li><a href="#2-6-luo-ji-yun-suan-zhi-ling">2.6 逻辑运算指令</a></li>
<li><a href="#2-7-nei-cun-ping-zhang-zhi-ling">2.7 内存屏障指令</a><ul>
<li><a href="#2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang">2.7.1 Data Memory Barrier(DMB)：数据内存屏障</a></li>
<li><a href="#2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang">2.7.2 Data Synchronization Barrier(DSB)：数据同步屏障</a></li>
<li><a href="#2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang">2.7.3 Instruction Synchronization Barrier(ISB)：指令同步屏障</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-arm-v7-cpu-yun-xing-mo-shi">3 arm-v7 cpu运行模式</a></li>
<li><a href="#4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi">4 arm-v7 cpu通用和特殊寄存器</a><ul>
<li><a href="#4-1-tong-yong-ji-cun-qi">4.1 通用寄存器</a><ul>
<li><a href="#4-1-1-tong-yong-ji-cun-qi-fen-lei">4.1.1 通用寄存器分类</a></li>
<li><a href="#4-1-2-wei-bei-fen-ji-cun-qi-r0-r7">4.1.2 未备份寄存器R0-R7</a></li>
<li><a href="#4-1-3-bei-fen-ji-cun-qi">4.1.3 备份寄存器</a><ul>
<li><a href="#4-1-3-1-r8-r12">4.1.3.1 R8~R12</a></li>
<li><a href="#4-1-3-2-r13-sp">4.1.3.2 R13 (SP)</a></li>
<li><a href="#4-1-3-2-r14-lr">4.1.3.2 R14 (LR)</a></li>
<li><a href="#4-1-3-2-r15-pc">4.1.3.2 R15 (PC)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-2-te-shu-ji-cun-qi">4.2 特殊寄存器</a><ul>
<li><a href="#4-2-1-cpsr">4.2.1 CPSR</a></li>
<li><a href="#4-2-2-spsr">4.2.2 SPSR</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-cp15-xie-chu-li-qi">5 CP15协处理器</a><ul>
<li><a href="#5-1-xie-chu-li-qi-zhi-ling">5.1 协处理器指令</a></li>
<li><a href="#5-2-c0-ji-cun-qi-midr">5.2 c0寄存器（MIDR）</a></li>
<li><a href="#5-3-c1-ji-cun-qi-sctlr">5.3 c1寄存器（SCTLR）</a></li>
<li><a href="#5-4-c12-ji-cun-qi-vbar">5.4 c12寄存器（VBAR）</a></li>
<li><a href="#5-5-c15-ji-cun-qi-cbar">5.5 c15寄存器（CBAR）</a></li>
</ul>
</li>
<li><a href="#6-arm-guan-fang-can-kao-lian-jie">6 arm官方参考链接</a><ul>
<li><a href="#6-1-armv7-yu-armv8-jia-gou">6.1 armv7与armv8架构</a></li>
<li><a href="#6-2-armv7-can-kao-shou-ce">6.2 armv7参考手册</a></li>
<li><a href="#6-3-armv7-bian-cheng-shou-ce">6.3 armv7 编程手册</a></li>
<li><a href="#6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce">6.4 Cortex-A7 <code>MPCore</code> 技术参考手册</a></li>
</ul>
</li>
<li><a href="#7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li">7 附件1：armv7裸机启动汇编示例：</a></li>
<li><a href="#8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi">8 附件2：GIC指令和寄存器定义（内联汇编方式）</a><ul>
<li><a href="#8-1-nei-lian-hui-bian-yuan-li">8.1 内联汇编原理</a><ul>
<li><a href="#8-1-1-cao-zuo-shu-shu-xing">8.1.1 操作数属性</a></li>
<li><a href="#8-1-2-clobber-list">8.1.2 clobber list</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-gnu-hui-bian-ge-shi">1 GNU 汇编格式</span><a href="#1-gnu-hui-bian-ge-shi" class="header-anchor">#</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label：instruction @ comment</span><br></pre></td></tr></table></figure>
<p><strong>label</strong> 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到指令的地址，标号也可以用来表示数据地址。注意 label 后面的“：”，任何以“：”结尾的标识符都会被识别为一个标号。<br><strong>instruction</strong> 即指令，也就是汇编指令或伪指令。<br><strong>@符号</strong>，表示后面的是注释，就跟 C 语言里面的<code>/*</code>和<code>*/</code>一样，其实在 GNU 汇编文件中我们也可以使用<code>\*</code>和<code>*/</code>来注释。<br><strong>comment</strong> 就是注释内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add:</span><br><span class="line">MOVS R0, #0X12 @设置 R0=0X12</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> ARM 中的指令、伪指令、伪操作、寄存器名等可以全部使用大写，也可以全部使用小写，但是不能大小写混用</p>
<h2><span id="1-1-wei-cao-zuo">1.1伪操作</span><a href="#1-1-wei-cao-zuo" class="header-anchor">#</a></h2><h3><span id="1-1-1-section">1.1.1 .section</span><a href="#1-1-1-section" class="header-anchor">#</a></h3><p>来定义一个段，汇编系统预定义了一些段名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text 表示代码段。</span><br><span class="line">.data 初始化的数据段。</span><br><span class="line">.bss 未初始化的数据段。</span><br><span class="line">.rodata 只读数据段。</span><br></pre></td></tr></table></figure>

<p>定义一个 testsetcion 段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .testsection</span><br></pre></td></tr></table></figure>
<p>同时，还可以指定该段的属性，对应的属性见下表:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a section is allocatable</span><br><span class="line">d section is a GNU_MBIND section</span><br><span class="line">e section is excluded from executable and shared library.</span><br><span class="line">w section is writable</span><br><span class="line">x section is executable</span><br><span class="line">M section is mergeable</span><br><span class="line">S section contains zero terminated strings</span><br><span class="line">G section is a member of a section group</span><br><span class="line">T section is used <span class="keyword">for</span> thread-local-storage</span><br></pre></td></tr></table></figure>

<p>属性可以组合， 比如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .foo，<span class="string">&quot;aex&quot;</span></span><br><span class="line">    text...</span><br></pre></td></tr></table></figure>

<p>汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用 <code>ENTRY</code> 来指明其它的入口点。</p>
<h3><span id="1-1-2-global">1.1.2 .global</span><a href="#1-1-2-global" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">ldr r0, =0x12 @r0=0x12</span><br></pre></td></tr></table></figure>

<p><code>.global</code> 是伪操作，表示<code>_start</code> 是一个全局标号，类似 C 语言里面的全局变量一样，常见的伪操作有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.byte 定义单字节数据，比如.byte <span class="number">0x12</span>。</span><br><span class="line">.<span class="type">short</span> 定义双字节数据，比如.<span class="type">short</span> <span class="number">0x1234</span>。</span><br><span class="line">.<span class="type">long</span> 定义一个 <span class="number">4</span> 字节数据，比如.<span class="type">long</span> <span class="number">0x12345678</span>。</span><br><span class="line">.equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, <span class="number">0x12</span>，表示 num=<span class="number">0x12</span>。</span><br><span class="line">.align 数据字节对齐，比如：.align <span class="number">4</span> 表示 <span class="number">4</span> 字节对齐。</span><br><span class="line">.end 表示源文件结束。</span><br><span class="line">.global 定义一个全局符号，格式为：.global symbol，比如：.global _start。</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-3-comm">1.1.3 .comm</span><a href="#1-1-3-comm" class="header-anchor">#</a></h3><p><code>.comm </code>表示目标文件中的<code> common symbol</code>，表示公共的符号:<br><code>.comm symbol，length</code></p>
<p>这和 GNU 中的强弱符号机制相关，未初始化的变量表示为弱符号，初始化的变量为强符号，当不同源文件中存在多个同名变量时，强符号会覆盖弱符号而不会报错，这是 <code>gcc </code>的扩展语法，所以实际上未初始化的全局变量是作为公共符号保存的，当多个文件中的<code>comm</code>符号出现冲突时，需要将其以一定规则融合. 实际上，C 语言中未定义的全局变量(也就是 <code>comm </code>符号)并非是存放到 <code>bss </code>段中的，而是保存在 COMMON 段.</p>
<h3><span id="1-1-4-byte-word">1.1.4 .byte ， .word</span><a href="#1-1-4-byte-word" class="header-anchor">#</a></h3><p>伪汇编中有一系列的数据放置指令，表示在当前位置放置某些数据，相对应的有:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.byte : 放置一个字节</span><br><span class="line">.hword:放置半字，在 <span class="number">32</span> 位平台中对应两个字节，<span class="number">64</span> 位对应四字节</span><br><span class="line">.<span class="type">short</span>:放置一个 <span class="type">short</span> 类型数据，两个字节.word:放置一个字，在 <span class="number">32</span> 位平台中对应四个字节，<span class="number">64</span> 位对应八字节</span><br><span class="line">.<span class="type">int</span> : 放置一个 <span class="type">int</span> 类型的数据，数据长度根据平台而定，<span class="number">16</span>位平台为两字节，<span class="number">32</span>位和<span class="number">64</span>位平台为四字节</span><br><span class="line">.<span class="type">long</span>:放置一个 <span class="type">long</span> 类型的数据，数据长度根据平台而定，<span class="number">32</span>位平台为四字节，<span class="number">64</span>位平台为八字节</span><br><span class="line">.<span class="type">float</span>:放置一个 <span class="type">float</span> 类型数据，四字节</span><br><span class="line">.<span class="type">double</span>:放置一个 <span class="type">double</span> 类型数据，八字节</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-5-set-eqv-equ-equiv">1.1.5 .set， .eqv， .equ， .equiv</span><a href="#1-1-5-set-eqv-equ-equiv" class="header-anchor">#</a></h3><p>set:设置一个符号的值, C 中的宏。通过设置一个符号的值，在后续的代码中可以重复使用该符号的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">set</span> sym_set，<span class="number">0x100</span></span><br><span class="line">mov r0，#sym_set</span><br></pre></td></tr></table></figure>

<h3><span id="1-1-6-weak">1.1.6 .weak</span><a href="#1-1-6-weak" class="header-anchor">#</a></h3><p>定义一个 weak 类型的符号，当这个符号在相同作用域的地方存在定义，当前符号会被忽略，如果这个符号之前不存在，这个符号就会被使用. 这和 C 语言中的 weak 机制是一样的.</p>
<h2><span id="1-2-han-shu-ding-yi">1.2 函数定义</span><a href="#1-2-han-shu-ding-yi" class="header-anchor">#</a></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">函数名:</span><br><span class="line">	函数体</span><br><span class="line">	返回语句</span><br></pre></td></tr></table></figure>

<p>GNU 汇编函数返回语句不是必须的，如下代码就是用汇编写的Cortex-A7 中断服务函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* SVC 中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler </span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>

<p>以函数 <code>Undefined_Handler</code> 为例我们来看一下汇编函数组成，<code>Undefined_Handler</code>就是函数名，<code>ldr r0, =Undefined_Handler</code>是函数体，<code>bx r0</code>是函数返回语句，<code>bx</code>指令是返回指令，函数返回语句不是必须的.</p>
<h1><span id="2-armv7-hui-bian-zhi-ling">2 ARMv7汇编指令</span><a href="#2-armv7-hui-bian-zhi-ling" class="header-anchor">#</a></h1><h2><span id="2-1-shu-ju-yi-dong-zhi-ling">2.1 数据移动指令</span><a href="#2-1-shu-ju-yi-dong-zhi-ling" class="header-anchor">#</a></h2><p>数据移动指令都是cpu内部寄存器之间的数据拷贝。</p>
<h3><span id="2-1-1-mov">2.1.1 MOV</span><a href="#2-1-1-mov" class="header-anchor">#</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV R0，R1 @将寄存器 R1 中的数据传递给 R0，即 R0=R1</span><br><span class="line">MOV R0, #0X12 @将立即数 0X12 传递给 R0 寄存器，即 R0=0X12</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-2-mrs">2.1.2 MRS</span><a href="#2-1-2-mrs" class="header-anchor">#</a></h3><p>读取特殊寄存器的数据只能使用 MRS 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRS R0, CPSR @将 CPSR 里面的数据传递给 R0，即 R0=CPSR</span><br></pre></td></tr></table></figure>
<h3><span id="2-1-3-msr">2.1.3 MSR</span><a href="#2-1-3-msr" class="header-anchor">#</a></h3><p>和 MRS 刚好相反，通用寄存器写入到特殊寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MSR CPSR, R0 @将 R0 中的数据复制到 CPSR 中，即 CPSR=R0</span><br></pre></td></tr></table></figure>

<p>举个例子利用MRS MSR进行清bss (_bss_start, __bss_end定义在链接脚本):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">.global _bss_start</span><br><span class="line">.global _bss_end</span><br><span class="line"></span><br><span class="line">_bss_start:</span><br><span class="line">	.word __bss_start</span><br><span class="line">_bss_end:</span><br><span class="line">	.word __bss_end</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	<span class="comment">//disable watchdog, disable icache dcache</span></span><br><span class="line">	<span class="comment">//init_clk</span></span><br><span class="line">	<span class="comment">//enter svc mode</span></span><br><span class="line">	<span class="comment">/*clear bss*/</span></span><br><span class="line">	ldr r0, _bss_start</span><br><span class="line">	ldr r1, _bss_end</span><br><span class="line">	move r2, <span class="number">0</span></span><br><span class="line">clr_bss:</span><br><span class="line">	stmia r0!, &#123;r2&#125; <span class="comment">//复制一r2中的数据给r0, 并将指针r0增加4</span></span><br><span class="line">	cmp r0, r1</span><br><span class="line">	ble clr_bss <span class="comment">/*if r0&lt;r1, b clr_bss*/</span></span><br></pre></td></tr></table></figure>

<h3><span id="2-1-4-cps">2.1.4 CPS</span><a href="#2-1-4-cps" class="header-anchor">#</a></h3><p>特权模式下（除了用户模式，剩余的模式都是特权模式），可以通过CPS指令直接修改CPSR寄存器的M[4:0]，让处理器进入不同的模式。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/1.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPS #0x12 /*irq mode*/</span><br><span class="line">CPS #0x13 /*svc mode*/</span><br></pre></td></tr></table></figure>
<h2><span id="2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram">2.2 数据存取指令（访问存储器RAM）</span><a href="#2-2-shu-ju-cun-qu-zhi-ling-fang-wen-cun-chu-qi-ram" class="header-anchor">#</a></h2><h3><span id="2-2-1-ldr">2.2.1 LDR</span><a href="#2-2-1-ldr" class="header-anchor">#</a></h3><p>数据加载指令，从指定地址读取到cpu寄存器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">LDR R1, [R0] @读取地址 0X0209C004 中的数据到 R1 寄存器中</span><br></pre></td></tr></table></figure>
<h3><span id="2-2-2-str">2.2.2 STR</span><a href="#2-2-2-str" class="header-anchor">#</a></h3><p>数据存放指令，从cpu寄存器写入指定地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDR R0, =0X0209C004 @将寄存器地址 0X0209C004 加载到 R0 中，即 R0=0X0209C004</span><br><span class="line">LDR R1, =0X20000002 @R1 保存要写入到寄存器的值，即 R1=0X20000002</span><br><span class="line">STR R1, [R0] @将 R1 中的值写入到 R0 中所保存的地址中</span><br></pre></td></tr></table></figure>

<p>LDR 和 STR 都是按照4 byte进行读取和写入的，也就是操作的 32 位数据，如果要按照字节、半字进行操作的话可以在指令“LDR”后面加上 B 或 H，比如按字节操作的指令就是 LDRB 和STRB，按半字(16位)操作的指令就是 LDRH 和 STRH。</p>
<h3><span id="2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng">2.2.3 多寄存器加载存储指令LDMIA，STMIA等</span><a href="#2-2-3-duo-ji-cun-qi-jia-zai-cun-chu-zhi-ling-ldmia-stmia-deng" class="header-anchor">#</a></h3><p><strong>1.LDMIA指令、LDMIB指令、LDMDB指令、LDMDA指令</strong><br>LDM是LDR指令的增强型 ， 将连续的数据加载到多组寄存器。<br>DB （Decrement Before）栈指针先减小再操作、DA（Decrement After）栈指针先操作再减小。<br>IB（Increment Before）栈指针先增加再操作、IA（Increment After）栈指针先操作再增加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LDMIA指令，IA表示每次传送后地址加<span class="number">4</span></span><br><span class="line">LDMIB指令，IB表示每次传送前地址加<span class="number">4</span></span><br><span class="line">LDMDA指令，DA表示每次传送后地址减<span class="number">4</span></span><br><span class="line">LDMDB指令，DB表示每次传送前地址减<span class="number">4</span></span><br><span class="line"></span><br><span class="line">LDMIA R14，&#123;R0-R3，R12&#125; <span class="comment">/*从R14寄存器指向的地址取出5个32位数据分别存进到R0-R4以及R12*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等效于</span></span><br><span class="line"><span class="comment">//R0=*R14</span></span><br><span class="line"><span class="comment">//R1=*（R14+4）</span></span><br><span class="line"><span class="comment">//R2=*（R14+8）</span></span><br><span class="line"><span class="comment">//R3=*（R14+12）</span></span><br><span class="line"><span class="comment">//R12=*（R14+16）</span></span><br><span class="line"></span><br><span class="line">LDMIA R1！，&#123;R4-R11&#125; <span class="comment">/*从R1指向的地址取8个32位数据存入R4-R11, 每取一次，让R1指针加4，因此最后R1指针加了32*/</span></span><br></pre></td></tr></table></figure>

<p><strong>2.STMIA指令、STMIB指令、STMDB指令、STMDA指令</strong><br>同理，STM是STR指令的增强型 ， 将多组寄存器数据保存进连续地址空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMIA R13！，&#123;R0-R1&#125; /*将R0，R1寄存器中的数据存入R13指向的栈空间, r13指向的地址存入R0数据，再地址+4后存入R1的数据*/</span><br></pre></td></tr></table></figure>
<h2><span id="2-3-ru-zhan-chu-zhan-zhi-ling">2.3 入栈出栈指令</span><a href="#2-3-ru-zhan-chu-zhan-zhi-ling" class="header-anchor">#</a></h2><p>函调调用过程中离不开现场的保护和恢复。保存 <code>R0~R15</code> 寄存器的操作就叫做现场保护，恢复 R0~R15 寄存器的操作就叫做恢复现场。</p>
<h4><span id="2-3-1-push">2.3.1 PUSH</span><a href="#2-3-1-push" class="header-anchor">#</a></h4><p>比如要将 R0~R3 和 R12 这 5 个寄存器压栈，当前的 <code>SP （stack pointer）</code>指针指向 <code>0X80000000</code>，我们知道栈空间的地址是向下增长的，堆空间地址向上增长。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;R0~R3, R12&#125; @将 R0~R3 和 R12 压栈</span><br></pre></td></tr></table></figure>

<p>那么压栈完成以后的堆栈如下：入栈保护现场完这5个寄存器后，SP指向<code>0X7FFFFFEC</code>（每压栈一个寄存器，SP地址减4）<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/2.png" alt="image"><br>再次保存LR寄存器，进行压栈：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/3.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;LR&#125; @将 LR 进行压栈</span><br></pre></td></tr></table></figure>

<h4><span id="2-3-2-pop">2.3.2 POP</span><a href="#2-3-2-pop" class="header-anchor">#</a></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POP &#123;LR&#125; @先恢复 LR</span><br><span class="line">POP &#123;R0~R3,R12&#125; @在恢复 R0~R3,R12</span><br></pre></td></tr></table></figure>

<p>可以看出入栈出栈本质都是对SP指针进行加减，入栈减，出栈加，入栈把寄存器依次保存进SP指向的地址去，出栈从SP地址依次取出数据。</p>
<h3><span id="2-3-3-stmfd-he-ldmfd">2.3.3 STMFD和LDMFD</span><a href="#2-3-3-stmfd-he-ldmfd" class="header-anchor">#</a></h3><p>入栈出栈的另外一种写法是“STMFD SP！”和“LDMFD SP!”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STMFD SP!,&#123;R0~R3, R12&#125; @R0~R3,R12 入栈</span><br><span class="line">STMFD SP!,&#123;LR&#125; @LR 入栈</span><br><span class="line">bl xxx</span><br><span class="line">LDMFD SP!, &#123;LR&#125; @先恢复 LR</span><br><span class="line">LDMFD SP!, &#123;R0~R3, R12&#125; @再恢复 R0~R3, R12</span><br></pre></td></tr></table></figure>

<p>STMFD 可以分为两部分：STM 和 FD，同理，LDMFD 也可以分为 LDM 和 FD。前面我们讲了 LDR 和 STR，这两个是数据加载和存储指令，但是每次只能读写存储器中的一个数据。STM 和 LDM 就是多存储和多加载，可以连续的读写存储器中的多个连续数据。<br>FD 是 Full Descending 的缩写，即满递减的意思。根据 ATPCS 规则,ARM 使用的 FD 类型的堆栈，SP 指向最后一个入栈的数值，堆栈是由高地址向下增长的，也就是前面说的向下增长的堆栈，因此最常用的指令就是 STMFD 和 LDMFD。STM 和 LDM 的指令寄存器列表中编号小的对应低地址，编号高的对应高地址.</p>
<h2><span id="2-4-tiao-zhuan-zhi-ling">2.4 跳转指令</span><a href="#2-4-tiao-zhuan-zhi-ling" class="header-anchor">#</a></h2><h3><span id="2-4-1-b-zhi-ling">2.4.1 B 指令</span><a href="#2-4-1-b-zhi-ling" class="header-anchor">#</a></h3><p>B 指令会将 PC 寄存器的值设置为跳转目标地址，如果要调用的函数不会再返回到原来的执行处，那就可以用 B 指令.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_start:</span><br><span class="line">ldr sp,=0X80200000 @设置栈指针</span><br><span class="line">b main @跳转到 main 函数</span><br></pre></td></tr></table></figure>

<p>在汇编中初始化 C 运行环境，然后跳转到 C 文件的 main 函数中运行，上述代码只是初始化了 SP 指针，有些处理器还需要做其他的初始化，比如初始化 DDR 等等.</p>
<h3><span id="2-4-2-bl-zhi-ling">2.4.2 BL 指令</span><a href="#2-4-2-bl-zhi-ling" class="header-anchor">#</a></h3><p>有返回的跳转，跳转之前会在寄存器 LR(R14)中保存当前 PC 寄存器值，所以可以通过<strong>将 LR 寄存器中的值重新加载到 PC</strong> 中来继续从跳转之前的代码处运行，这是子程序调用一个基本但常用的手段。<br>比如 Cortex-A 处理器的 irq 中断服务函数都是汇编写的，主要用汇编来实现现场的保护和恢复、获取中断号等。但是具体的中断处理过程都是 C 函数，所以就会存在汇编中调用 C 函数的问题。而且当 C 语言版本的中断处理函数执行完成以后是需要返回到irq 汇编中断服务函数，因为还要处理其他的工作，一般是恢复现场。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push &#123;r0, r1&#125; @保存 r0,r1</span><br><span class="line">cps #0x13 @进入 SVC 模式，允许其他中断再次进去</span><br><span class="line"></span><br><span class="line">bl system_irqhandler @加载 C 语言中断处理函数到 r2 寄存器中</span><br><span class="line"></span><br><span class="line">cps #0x12 @进入 IRQ 模式</span><br><span class="line">pop &#123;r0, r1&#125; </span><br><span class="line">str r0, [r1, #0X10] @中断执行完成，写 EOIR</span><br></pre></td></tr></table></figure>

<p>跳转指令总结：<br>有多种跳转操作，比如：<br>①、直接使用跳转指令 B、BL、BX 等。<br>②、直接向 PC 寄存器里面写入数据。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/4.png" alt="image"></p>
<h2><span id="2-5-suan-shu-yun-suan-zhi-ling">2.5 算数运算指令</span><a href="#2-5-suan-shu-yun-suan-zhi-ling" class="header-anchor">#</a></h2><p>加减乘除，常用的运算指令用法：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/5.png" alt="image"></p>
<h2><span id="2-6-luo-ji-yun-suan-zhi-ling">2.6 逻辑运算指令</span><a href="#2-6-luo-ji-yun-suan-zhi-ling" class="header-anchor">#</a></h2><p>与或非指令用法：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/6.png" alt="image"><br>来看一个例子利用arm汇编进行初始化C语言环境。让arm进入svc模式，才能访问特殊寄存器如cpsr, spsr, sp指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">	/* 进入SVC模式 */</span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #0x1f  /* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 */</span><br><span class="line">	orr r0, r0, #0x13  /* r0或上0x13,表示使用SVC模式 */</span><br><span class="line">	msr cpsr, r0 /* 将r0 的数据写入到cpsr_c中 */</span><br><span class="line"></span><br><span class="line">	ldr sp, =0X80200000 /* 设置栈指针 */</span><br><span class="line">	b main /* 跳转到main函数 */</span><br></pre></td></tr></table></figure>

<h2><span id="2-7-nei-cun-ping-zhang-zhi-ling">2.7 内存屏障指令</span><a href="#2-7-nei-cun-ping-zhang-zhi-ling" class="header-anchor">#</a></h2><h3><span id="2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang">2.7.1 Data Memory Barrier(DMB)：数据内存屏障</span><a href="#2-7-1-data-memory-barrier-dmb-shu-ju-nei-cun-ping-zhang" class="header-anchor">#</a></h3><p>DMB指令确保在DMB之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的数据内存传输指令都将在DMB执行之后开始执行，否则有些数据传输指令可能会提前执行。保证了两个内存访问能按正确的顺序执行。<br>应用场景：<br>（1）DMA<br>在使用DMA控制器时，需要在CPU内存访问和DMA操作之间插入DMB屏障，以确保CPU当前的内存读写操作在DMA开始之前完成。</p>
<p>（2）多核系统中的信号量<br>在多核系统中，使用信号量进行核间同步。需要使用DMB来强制指定内存执行顺序，以避免潜在的竞态条件或数据不一致性。当一个核要访问共享资源之前，它会先检查信号量的状态。如果信号量已经被另一个核获取，当前核就必须等待，直到信号量状态变为可用。这个等待过程需要保证在一个核释放信号量之后，其他核能够立即看到信号量状态的变化，而不是因为处理器优化或缓存导致的无效读取而产生错误。</p>
<h3><span id="2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang">2.7.2 Data Synchronization Barrier(DSB)：数据同步屏障</span><a href="#2-7-2-data-synchronization-barrier-dsb-shu-ju-tong-bu-ping-zhang" class="header-anchor">#</a></h3><p>在多线程编程中，两个线程同时对共享的内存进行读写操作，由于读&#x2F;写操作的重排序，就会导致数据的不一致, DSB指令时，它确保在DSB之前的所有显式数据内存传输指令都已经在内存中读取或写入完成，同时确保任何后续的指令都将在DSB执行之后开始执行。<br>应用场景：<br>例如启用或禁用特定的中断、配置时钟、设置系统控制位等。为了确保对SCS的修改在下一条指令执行之前生效，需要使用DSB指令进行数据同步。一些特殊的指令如SVC(Supervisor Call，特权级调用)、WFI(Wait For Interrupt，等待中断）、WFE(Wait For Event，等待事件)等操作，涉及到特权级的转换或者等待系统事件发生，需要使用DSB指令。</p>
<h3><span id="2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang">2.7.3 Instruction Synchronization Barrier(ISB)：指令同步屏障</span><a href="#2-7-3-instruction-synchronization-barrier-isb-zhi-ling-tong-bu-ping-zhang" class="header-anchor">#</a></h3><p>插入ISB指令，处理器会将流水线中的指令全部刷新，从而确保之前的指令不会影响后续指令的执行，并且后续指令将从正确的上下文开始重新获取。<br>应用场景：<br>在进行异常进入之前，处理器会执行ISB操作。这样做的目的是刷新指令流水线，确保异常处理程序的指令是从正确的地址开始执行，避免异常之前的指令对异常处理程序造成干扰。<br>在进行异常返回之前，处理器同样会执行ISB操作。这样做的目的是刷新指令流水线，确保返回时从正确的地址重新获取指令，避免异常处理程序的指令对正常任务造成干扰。</p>
<h1><span id="3-arm-v7-cpu-yun-xing-mo-shi">3 arm-v7 cpu运行模式</span><a href="#3-arm-v7-cpu-yun-xing-mo-shi" class="header-anchor">#</a></h1><p>以前的 ARM 处理器有 7 中运行模型：User、FIQ、IRQ、Supervisor(SVC)、Abort、Undef和 System，其中 User 是非特权模式，其余 6 中都是特权模式。</p>
<p>到了Cortex-A7 处理器有 9 种处理模式:</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">User(USR)</td>
<td align="center">用户模式，非特权模式，大部分程序运行的时候就处于此模式。</td>
</tr>
<tr>
<td align="center">FIQ</td>
<td align="center">快速中断模式，进入 FIQ 中断异常</td>
</tr>
<tr>
<td align="center">IRQ</td>
<td align="center">一般中断模式。</td>
</tr>
<tr>
<td align="center">Supervisor(SVC)</td>
<td align="center">超级管理员模式，特权模式，供操作系统使用。</td>
</tr>
<tr>
<td align="center">Monitor(MON)</td>
<td align="center">监视模式？这个模式用于安全扩展模式。</td>
</tr>
<tr>
<td align="center">Abort(ABT)</td>
<td align="center">数据访问终止模式，用于虚拟存储以及存储保护。</td>
</tr>
<tr>
<td align="center">Hyp(HYP)</td>
<td align="center">Hyp(HYP) 超级监视模式？用于虚拟化扩展。</td>
</tr>
<tr>
<td align="center">Undef(UND)</td>
<td align="center">Undef(UND) 未定义指令终止模式。</td>
</tr>
<tr>
<td align="center">System(SYS)</td>
<td align="center">System(SYS) 系统模式，用于运行特权级的操作系统任务</td>
</tr>
</tbody></table>
<p>九种模式所对应的寄存器：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/7.png" alt="image"><br><a href="https://www.cnblogs.com/fuzidage/p/12066599.html" title="arm920t cpu模式">arm920t cpu模式</a>或者查看<a href="https://fuzidage.github.io/2024/04/16/s3c2440%E8%A3%B8%E6%9C%BA-%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD/">s3c2440裸机-异常中断 | Hexo (fuzidage.github.io)</a>的CPU模式。</p>
<h1><span id="4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi">4 arm-v7 cpu通用和特殊寄存器</span><a href="#4-arm-v7-cpu-tong-yong-he-te-shu-ji-cun-qi" class="header-anchor">#</a></h1><p>ARM 架构提供了 16 个 32 位的通用寄存器<code>(R0~R15)</code>供软件使用，前 15 个(<code>R0~R14</code>)可以用作通用的数据存储，R15 是程序计数器 PC，用来保存将要执行的指令。ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR，SPSR 寄存器就是 CPSR 寄存器的备份。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/8.png" alt="image"></p>
<h2><span id="4-1-tong-yong-ji-cun-qi">4.1 通用寄存器</span><a href="#4-1-tong-yong-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-1-1-tong-yong-ji-cun-qi-fen-lei">4.1.1 通用寄存器分类</span><a href="#4-1-1-tong-yong-ji-cun-qi-fen-lei" class="header-anchor">#</a></h3><p><code>R0~R15</code> 就是通用寄存器，通用寄存器可以分为以下三类：<br>①、未备份寄存器，即 <code>R0~R7</code>。<br>②、备份寄存器，即 <code>R8~R14</code>。<br>③、程序计数器 PC，即 R15。</p>
<h3><span id="4-1-2-wei-bei-fen-ji-cun-qi-r0-r7">4.1.2 未备份寄存器R0-R7</span><a href="#4-1-2-wei-bei-fen-ji-cun-qi-r0-r7" class="header-anchor">#</a></h3><p>未备份寄存器指的是 <code>R0~R7</code> 这 8 个寄存器，因为在所有的处理器模式下这 8 个寄存器都是同一个物理寄存器，在不同的模式下，这 8 个寄存器中的数据就会被破坏.</p>
<h3><span id="4-1-3-bei-fen-ji-cun-qi">4.1.3 备份寄存器</span><a href="#4-1-3-bei-fen-ji-cun-qi" class="header-anchor">#</a></h3><h4><span id="4-1-3-1-r8-r12">4.1.3.1 R8~R12</span><a href="#4-1-3-1-r8-r12" class="header-anchor">#</a></h4><p><code>R8~R12</code> 这 5 个寄存器有2种物理寄存器.在快速中断模式下<code>(FIQ)</code>它们对应着 <code>Rx_irq(x=8~12)</code>物理寄存器，其他模式下对应着 <code>Rx(8~12)</code>物理寄存器. <code>FIQ </code>模式下的 <code>R8~R12</code> 是独立的，因此中断处理程序可以不用执行保存和恢复中断现场的指令，从而加速中断的执行过程。</p>
<h4><span id="4-1-3-2-r13-sp">4.1.3.2 R13 (SP)</span><a href="#4-1-3-2-r13-sp" class="header-anchor">#</a></h4><p>R13 一共有 8 个物理寄存器，其中一个是用户模式<code>(User)</code>和系统模式<code>(Sys)</code>共用的，剩下的 7 个分别对应 7 种不同的模式。R13 也叫做 SP，用来做为栈指针。基本上每种模式<br>都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的初始化 SP 指针.</p>
<h4><span id="4-1-3-2-r14-lr">4.1.3.2 R14 (LR)</span><a href="#4-1-3-2-r14-lr" class="header-anchor">#</a></h4><p> R14 一共有 7 个物理寄存器，其中一个是用户模式(User)、系统模式(Sys)和超级监视模式<code>(Hyp)</code>所共有的，剩下的 6 个分别对应 6 种不同的模式.<br> LR被叫做链接寄存器:<br>①用来存放子函数的返回地址。<br> 在子函数中，将 R14(LR)中的值赋给 R15(PC)即可完成子函数返回，比如在子程序中可以使用如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV PC, LR</span><br></pre></td></tr></table></figure>
<p>②当异常发生以后，该异常模式对应的 R14寄存器被设置成该异常模式将要返回的地址.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subs pc, lr, #4				/* 将lr-4赋给pc */</span><br></pre></td></tr></table></figure>
<p>比如下面代码示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0X2000 MOV R1, R0 ;执行</span><br><span class="line">0X2004 MOV R2, R3 ;译指</span><br><span class="line">0X2008 MOV R4, R5 ;取值 PC</span><br></pre></td></tr></table></figure>
<p>当前正在执行 <code>0X2000</code>地址处的指令<code>MOV R1, R0</code>，但是 PC 里面已经保存了 <code>0X2008 </code>地址处的指令<code>MOV R4, R5</code>。假设此时发生了中断，中断发生的时候保存在 <code>lr </code>中的是 <code>pc</code> 的值，也就是地址<code> 0X2008</code>。</p>
<h4><span id="4-1-3-2-r15-pc">4.1.3.2 R15 (PC)</span><a href="#4-1-3-2-r15-pc" class="header-anchor">#</a></h4><p>R15 保存着当前执行的指令地址值加 8 个字节，这是因为 ARM的流水线机制导致的。ARM 处理器 3 级流水线：取指-&gt;译码-&gt;执行，这三级流水线循环执行，比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 <code>R15(PC)</code>中.<br>对于arm32位处理器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R15 (PC)值 = 当前执行的程序位置 + 8 个字节</span><br></pre></td></tr></table></figure>
<h2><span id="4-2-te-shu-ji-cun-qi">4.2 特殊寄存器</span><a href="#4-2-te-shu-ji-cun-qi" class="header-anchor">#</a></h2><h3><span id="4-2-1-cpsr">4.2.1 CPSR</span><a href="#4-2-1-cpsr" class="header-anchor">#</a></h3><p>当前程序状态寄存器<code>（current program status register）</code>，所有模式共用一个 <code>CPSR</code> 物理寄存器，因此 <code>CPSR </code>可以在任何模式下被访问。<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/9.png" alt="image"><br>N(bit31)：当两个补码表示的 有符号整数运算的时候，N&#x3D;1 表示运算对的结果为负数，N&#x3D;0表示结果为正数。<br>Z(bit30)：Z&#x3D;1 表示运算结果为零，Z&#x3D;0 表示运算结果不为零，对于 CMP 指令，Z&#x3D;1 表示进行比较的两个数大小相等。<br>C(bit29)：在加法指令中，当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢，其它情况下 C&#x3D;0。在减法指令中，当运算中发生借位，则 C&#x3D;0，表示无符号数运算发生下溢，其它情况下 C&#x3D;1。对于包含移位操作的非加&#x2F;减法运算指令，C 中包含最后一次溢出的位的数值，对于其它非加&#x2F;减运算指令，C 位的值通常不受影响。<br>V(bit28)：对于加&#x2F;减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时，V&#x3D;1 表示符号位溢出，通常其他位不影响 V 位。<br>Q(bit27)：仅 ARM v5TE_J 架构支持，表示饱和状态，Q&#x3D;1 表示累积饱和，Q&#x3D;0 表示累积不饱和。<br>IT<a href="bit26:25">1:0</a>：和 IT<a href="bit15:bit10">7:2</a>一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。<br>J(bit24)：仅 ARM_v5TE-J 架构支持，J&#x3D;1 表示处于 <code>Jazelle</code> 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集:</p>
<table>
<thead>
<tr>
<th>J</th>
<th>T</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>ARM</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Thumb</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>ThumbEE</td>
</tr>
</tbody></table>
<p>GE<a href="bit19:16">3:0</a>：SIMD 指令有效，大于或等于。<br>IT<a href="bit15:10">7:2</a>：参考 IT[1:0]。<br>E(bit9)：大小端控制位，E&#x3D;1 表示大端模式，E&#x3D;0 表示小端模式。<br>A(bit8)：禁止异步中断位，A&#x3D;1 表示禁止异步中断。<br>I(bit7)：I&#x3D;1 禁止 IRQ，I&#x3D;0 使能 IRQ。<br>F(bit6)：F&#x3D;1 禁止 FIQ，F&#x3D;0 使能 FIQ。<br>T(bit5)：控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。<br>M[4:0]：处理器模式控制位<br><code>cpsr</code>最常用就是来控制处理器模式</p>
<table>
<thead>
<tr>
<th>M[4:0]</th>
<th>处理器模式</th>
</tr>
</thead>
<tbody><tr>
<td>10000</td>
<td>User 模式</td>
</tr>
<tr>
<td>10001</td>
<td>FIQ 模式</td>
</tr>
<tr>
<td>10010</td>
<td>IRQ 模式</td>
</tr>
<tr>
<td>10011</td>
<td>Supervisor(SVC)模式</td>
</tr>
<tr>
<td>10110</td>
<td>Monitor(MON)模式</td>
</tr>
<tr>
<td>10111</td>
<td>Abort(ABT)模式</td>
</tr>
<tr>
<td>11010</td>
<td>Hyp(HYP)模式</td>
</tr>
<tr>
<td>11011</td>
<td>Undef(UND)模式</td>
</tr>
<tr>
<td>11111</td>
<td>System(SYS)模式</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">mrs r0, cpsr</span><br><span class="line">bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br></pre></td></tr></table></figure>
<h3><span id="4-2-2-spsr">4.2.2 SPSR</span><a href="#4-2-2-spsr" class="header-anchor">#</a></h3><p>除了 User 和 Sys 这两个模式以外，其他 7 个模式每个都配备了一个专用的物理状态寄存器，叫做 SPSR(备份程序状态寄存器)，当特定的异常中断发生时，SPSR 寄存器用来保存当前程序状态寄存器(CPSR)的值，当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。User 和 Sys 这两个模式不是异常模式，所以并没有配备 SPSR，因此不能在 User 和Sys 模式下访问 SPSR。</p>
<h1><span id="5-cp15-xie-chu-li-qi">5 CP15协处理器</span><a href="#5-cp15-xie-chu-li-qi" class="header-anchor">#</a></h1><p>CP15 协处理器一般用于存储系统管理，但是在中断中也会使用到，比如进入reset复位异常向量时，需要利用协处理器命令进行<code>ICache DCache</code>的开关。CP15 协处理器一共有16 个 32 位寄存器（C0-C15），MRC和MCR用来访问CP15协处理器。</p>
<h2><span id="5-1-xie-chu-li-qi-zhi-ling">5.1 协处理器指令</span><a href="#5-1-xie-chu-li-qi-zhi-ling" class="header-anchor">#</a></h2><p><strong>MRC</strong>: 将 CP15 协处理器中的寄存器数据读到 ARM 寄存器中。<br><strong>MCR</strong>: 将 ARM 寄存器的数据写入到 CP15 协处理器寄存器中。<br>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCR&#123;cond&#125; p15, &lt;opc1&gt;, &lt;Rt&gt;, &lt;CRn&gt;, &lt;CRm&gt;, &lt;opc2&gt;</span><br></pre></td></tr></table></figure>

<p><code>cond:</code>指令执行的条件码，如果忽略的话就表示无条件执行。<br><code>opc1：</code>协处理器要执行的操作码。<br><code>Rt：</code>ARM 源寄存器，要写入到 CP15 寄存器的数据就保存在此寄存器中。<br><code>CRn：</code>CP15 协处理器的目标寄存器。<br><code>CRm：</code>协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将CRm 设置为 C0，否则结果不可预测。<br><code>opc2：</code>可选的协处理器特定操作码，当不需要的时候要设置为 0</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 0, r0, c0, c0, 0 //将 CP15 中 C0 寄存器的值读取到 R0 寄存器</span><br></pre></td></tr></table></figure>

<h2><span id="5-2-c0-ji-cun-qi-midr">5.2 c0寄存器（MIDR）</span><a href="#5-2-c0-ji-cun-qi-midr" class="header-anchor">#</a></h2><p>使用 MRC 或者 MCR 指令访问<code>c0-c15</code>寄存器的时候，指令中的<code>CRn、opc1、CRm 和 opc2</code>通过不同的搭配，其得到的寄存器含义不同：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/10.png" alt="image"><br>当<code>CRn=c0，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时的 c0 就是 MIDR 寄存器，也就是主 ID 寄存器，这个也是 c0 的基本作用。来看下c0作为MDIR寄存器时的含义：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/11.png" alt="image"><br>bit31:24：厂商编号，0X41，ARM。<br>bit23:20：内核架构的主版本号，ARM 内核版本一般使用<code>rnpn</code>来表示，比如<code> r0p1</code>，其中 r0<br>后面的 0 就是内核架构主版本号。<br>bit19:16：架构代码，0XF，ARMv7 架构。<br>bit15:4：内核版本号，0XC07，<code>Cortex-A7 MPCore </code>内核。<br>bit3:0：内核架构的次版本号，<code>rnpn </code>中的 <code>pn</code>，比如<code>r0p1</code>中 <code>p1</code> 后面的 1 就是次版本号。</p>
<h2><span id="5-3-c1-ji-cun-qi-sctlr">5.3 c1寄存器（SCTLR）</span><a href="#5-3-c1-ji-cun-qi-sctlr" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/12.png" alt="image"><br><code>CRn=c1，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时的 c1 就是 SCTLR 寄存器，也就是系统控制寄存器，这个是 c1 的基本作用。<br><strong>SCTLR 寄存器主要是完成控制功能的，比如使能或者禁止 MMU、I&#x2F;D Cache 等。</strong>  SCTLR 寄存器展开如下：<br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/13.png" alt="image"></p>
<p>bit13：V , 中断向量表基地址选择位，为 0 的话中断向量表基地址为 <code>0X00000000</code>，软件可以使用<code>VBAR</code>来重映射此基地址，也就是中断向量表重定位。为 1 的话中断向量表基地址为<code>0XFFFF0000</code>，此基地址不能被重映射。<br>bit12：I，I Cache 使能位，为 0 的话关闭 I Cache，为 1 的话使能 I Cache。<br>bit11：Z，分支预测使能位，如果开启 MMU 的话，此位也会使能。<br>bit10：SW，SWP 和 SWPB 使能位，当为 0 的话关闭 SWP 和 SWPB 指令，当为 1 的时候就使能 SWP 和 SWPB 指令。<br>bit9:3：未使用，保留。<br>bit2：C，D Cache 和缓存一致性使能位，为 0 的时候禁止 D Cache 和缓存一致性，为 1 时使能。<br>bit1：A，内存对齐检查使能位，为 0 的时候关闭内存对齐检查，为 1 的时候使能内存对齐检查。<br>bit0：M，MMU 使能位，为 0 的时候禁止 MMU，为 1 的时候使能 MMU。<br>举个读写SCTLR的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 0, &lt;Rt&gt;, c1, c0, 0 ;读取 SCTLR 寄存器，数据保存到 Rt 中。</span><br><span class="line"></span><br><span class="line">MCR p15, 0, &lt;Rt&gt;, c1, c0, 0 ;将 Rt 中的数据写到 SCTLR(c1)寄存器中。</span><br></pre></td></tr></table></figure>

<p>再来一个关闭MMU,ICache,DCache的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br></pre></td></tr></table></figure>
<h2><span id="5-4-c12-ji-cun-qi-vbar">5.4 c12寄存器（VBAR）</span><a href="#5-4-c12-ji-cun-qi-vbar" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/14.png" alt="image"><br><code>CRn=c12，opc1=0，CRm=c0，opc2=0 </code>的时候就表示此时 c12 为 <code>VBAR </code>寄存器，也就是<strong>中断向量表基地址寄存器</strong>。</p>
<p>比如代码链接到DDR的某个位置作为起始地址，起始地址为<code>0X87800000</code>，而中断向量表肯定要放到最前面，也就是 <code>0X87800000</code> 这个地址处。所以就需要设置 <code>VBAR</code> 为 <code>0X87800000</code>，设置命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dsb</span><br><span class="line">isb</span><br><span class="line">ldr r0, =0x87800000 ; r0=0x87800000</span><br><span class="line">MCR p15, 0, r0, c12, c0, 0 ;将 r0 里面的数据写入到 c12 中，即 c12=0X87800000</span><br><span class="line">dsb</span><br><span class="line">isb</span><br></pre></td></tr></table></figure>
<h2><span id="5-5-c15-ji-cun-qi-cbar">5.5 c15寄存器（CBAR）</span><a href="#5-5-c15-ji-cun-qi-cbar" class="header-anchor">#</a></h2><p><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/15.png" alt="image"><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/16.png" alt="image"></p>
<p>CBAR寄存器中保存了<code>GIC（Generic Interrupt Controller）</code>的基地址。<code>GIC</code>基地址偏移<code>0x1000</code>是<code>分发器 block</code>, 偏移<code>0x2000</code>是CPU <code>接口端 block</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MRC p15, 4, r1, c15, c0, 0 ; 获取 GIC 基础地址，基地址保存在 r1 中</span><br></pre></td></tr></table></figure>
<h1><span id="6-arm-guan-fang-can-kao-lian-jie">6 arm官方参考链接</span><a href="#6-arm-guan-fang-can-kao-lian-jie" class="header-anchor">#</a></h1><h2><span id="6-1-armv7-yu-armv8-jia-gou">6.1 armv7与armv8架构</span><a href="#6-1-armv7-yu-armv8-jia-gou" class="header-anchor">#</a></h2><p>armv7都是32位处理器，典型的有<code>CorTex-A</code> A7 A8 A9 A15 A17。armv8采用64位处理器，典型的比如手机处理器，有Cortex A53 A76 A77都是64位架构。</p>
<h2><span id="6-2-armv7-can-kao-shou-ce">6.2 armv7参考手册</span><a href="#6-2-armv7-can-kao-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/ddi0406/cd?lang=en">https://developer.arm.com/documentation/ddi0406/cd?lang=en</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/17.png" alt="image"></p>
<h2><span id="6-3-armv7-bian-cheng-shou-ce">6.3 armv7 编程手册</span><a href="#6-3-armv7-bian-cheng-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/den0013/d/?lang=en">https://developer.arm.com/documentation/den0013/d/?lang=en</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/18.png" alt="image"></p>
<h2><span id="6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce">6.4 Cortex-A7 <code>MPCore</code> 技术参考手册</span><a href="#6-4-cortex-a7-mpcore-ji-zhu-can-kao-shou-ce" class="header-anchor">#</a></h2><p><a href="https://developer.arm.com/documentation/ddi0464/latest/">https://developer.arm.com/documentation/ddi0464/latest/</a><br><img src="/2024/05/03/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-arm%E6%B1%87%E7%BC%96/19.png" alt="image"></p>
<h1><span id="7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li">7 附件1：armv7裸机启动汇编示例：</span><a href="#7-fu-jian-1-armv7-luo-ji-qi-dong-hui-bian-shi-li" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.global _start  				<span class="comment">/* 全局标号 */</span></span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">	ldr pc, =Reset_Handler		<span class="comment">/* 复位中断 					*/</span>	</span><br><span class="line">	ldr pc, =Undefined_Handler	<span class="comment">/* 未定义中断 					*/</span></span><br><span class="line">	ldr pc, =SVC_Handler		<span class="comment">/* SVC(Supervisor)中断 		*/</span></span><br><span class="line">	ldr pc, =PrefAbort_Handler	<span class="comment">/* 预取终止中断 					*/</span></span><br><span class="line">	ldr pc, =DataAbort_Handler	<span class="comment">/* 数据终止中断 					*/</span></span><br><span class="line">	ldr	pc, =NotUsed_Handler	<span class="comment">/* 未使用中断					*/</span></span><br><span class="line">	ldr pc, =IRQ_Handler		<span class="comment">/* IRQ中断 					*/</span></span><br><span class="line">	ldr pc, =FIQ_Handler		<span class="comment">/* FIQ(快速中断)未定义中断 			*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位中断 */</span>	</span><br><span class="line">Reset_Handler:</span><br><span class="line"></span><br><span class="line">	cpsid i						<span class="comment">/* 关闭全局中断 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭I,DCache和MMU </span></span><br><span class="line"><span class="comment">	 * 采取读-改-写的方式。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mrc     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 读取CP15的C1寄存器到R0中       		        	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">12</span>)     <span class="comment">/* 清除C1寄存器的bit12位(I位)，关闭I Cache            	*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt;  <span class="number">2</span>)     <span class="comment">/* 清除C1寄存器的bit2(C位)，关闭D Cache    				*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x2</span>             <span class="comment">/* 清除C1寄存器的bit1(A位)，关闭对齐						*/</span></span><br><span class="line">    bic     r0,  r0, #(<span class="number">0x1</span> &lt;&lt; <span class="number">11</span>)     <span class="comment">/* 清除C1寄存器的bit11(Z位)，关闭分支预测					*/</span></span><br><span class="line">    bic     r0,  r0, #<span class="number">0x1</span>             <span class="comment">/* 清除C1寄存器的bit0(M位)，关闭MMU				       	*/</span></span><br><span class="line">    mcr     p15, <span class="number">0</span>, r0, c1, c0, <span class="number">0</span>     <span class="comment">/* 将r0寄存器中的值写入到CP15的C1寄存器中	 				*/</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 汇编版本设置中断向量表偏移 */</span></span><br><span class="line">	ldr r0, =<span class="number">0X87800000</span></span><br><span class="line"></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line">	mcr p15, <span class="number">0</span>, r0, c12, c0, <span class="number">0</span></span><br><span class="line">	dsb</span><br><span class="line">	isb</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 设置各个模式下的栈指针，</span></span><br><span class="line"><span class="comment">	 * 注意：IMX6UL的堆栈是向下增长的！</span></span><br><span class="line"><span class="comment">	 * 堆栈指针地址一定要是4字节地址对齐的！！！</span></span><br><span class="line"><span class="comment">	 * DDR范围:0X80000000~0X9FFFFFFF</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x12</span> 	<span class="comment">/* r0或上0x13,表示使用IRQ模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80600000</span>	<span class="comment">/* 设置IRQ模式下的栈首地址为0X80600000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入SYS模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* r0或上0x13,表示使用SYS模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0x80400000</span>	<span class="comment">/* 设置SYS模式下的栈首地址为0X80400000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 进入SVC模式 */</span></span><br><span class="line">	mrs r0, cpsr</span><br><span class="line">	bic r0, r0, #<span class="number">0x1f</span> 	<span class="comment">/* 将r0寄存器中的低5位清零，也就是cpsr的M0~M4 	*/</span></span><br><span class="line">	orr r0, r0, #<span class="number">0x13</span> 	<span class="comment">/* r0或上0x13,表示使用SVC模式					*/</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0 的数据写入到cpsr_c中 					*/</span></span><br><span class="line">	ldr sp, =<span class="number">0X80200000</span>	<span class="comment">/* 设置SVC模式下的栈首地址为0X80200000,大小为2MB */</span></span><br><span class="line"></span><br><span class="line">	cpsie i				<span class="comment">/* 打开全局中断 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* 使能IRQ中断 */</span></span><br><span class="line">	mrs r0, cpsr		<span class="comment">/* 读取cpsr寄存器值到r0中 			*/</span></span><br><span class="line">	bic r0, r0, #<span class="number">0x80</span>	<span class="comment">/* 将r0寄存器中bit7清零，也就是CPSR中的I位清零，表示允许IRQ中断 */</span></span><br><span class="line">	msr cpsr, r0		<span class="comment">/* 将r0重新写入到cpsr中 			*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	b main				<span class="comment">/* 跳转到main函数 			 	*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未定义中断 */</span></span><br><span class="line">Undefined_Handler:</span><br><span class="line">	ldr r0, =Undefined_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SVC中断 */</span></span><br><span class="line">SVC_Handler:</span><br><span class="line">	ldr r0, =SVC_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 预取终止中断 */</span></span><br><span class="line">PrefAbort_Handler:</span><br><span class="line">	ldr r0, =PrefAbort_Handler	</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数据终止中断 */</span></span><br><span class="line">DataAbort_Handler:</span><br><span class="line">	ldr r0, =DataAbort_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 未使用的中断 */</span></span><br><span class="line">NotUsed_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =NotUsed_Handler</span><br><span class="line">	bx r0</span><br><span class="line"></span><br><span class="line">IRQ_Handler:</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存lr地址 */</span></span><br><span class="line">	push &#123;r0-r3, r12&#125;			<span class="comment">/* 保存r0-r3，r12寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrs r0, spsr				<span class="comment">/* 读取spsr寄存器 */</span></span><br><span class="line">	push &#123;r0&#125;					<span class="comment">/* 保存spsr寄存器 */</span></span><br><span class="line"></span><br><span class="line">	mrc p15, <span class="number">4</span>, r1, c15, c0, <span class="number">0</span> <span class="comment">/* 从CP15的C0寄存器内的值到R1寄存器中</span></span><br><span class="line"><span class="comment">								* 参考文档ARM Cortex-A(armV7)编程手册V4.0.pdf P49</span></span><br><span class="line"><span class="comment">								* Cortex-A7 Technical ReferenceManua.pdf P68 P138</span></span><br><span class="line"><span class="comment">								*/</span>							</span><br><span class="line">	add r1, r1, #<span class="number">0X2000</span>			<span class="comment">/* GIC基地址加0X2000，也就是GIC的CPU接口端基地址 */</span></span><br><span class="line">	ldr r0, [r1, #<span class="number">0XC</span>]			<span class="comment">/* GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，</span></span><br><span class="line"><span class="comment">								 * GICC_IAR寄存器保存这当前发生中断的中断号，我们要根据</span></span><br><span class="line"><span class="comment">								 * 这个中断号来绝对调用哪个中断服务函数</span></span><br><span class="line"><span class="comment">								 */</span></span><br><span class="line">	push &#123;r0, r1&#125;				<span class="comment">/* 保存r0,r1 */</span></span><br><span class="line">	</span><br><span class="line">	cps #<span class="number">0x13</span>					<span class="comment">/* 进入SVC模式，允许其他中断再次进去 */</span></span><br><span class="line">	</span><br><span class="line">	push &#123;lr&#125;					<span class="comment">/* 保存SVC模式的lr寄存器 */</span></span><br><span class="line">	ldr r2, =system_irqhandler	<span class="comment">/* 加载C语言中断处理函数到r2寄存器中*/</span></span><br><span class="line">	blx r2						<span class="comment">/* 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* 执行完C语言中断服务函数，lr出栈 */</span></span><br><span class="line">	cps #<span class="number">0x12</span>					<span class="comment">/* 进入IRQ模式 */</span></span><br><span class="line">	pop &#123;r0, r1&#125;				</span><br><span class="line">	str r0, [r1, #<span class="number">0X10</span>]			<span class="comment">/* 中断执行完成，写EOIR */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0&#125;						</span><br><span class="line">	msr spsr_cxsf, r0			<span class="comment">/* 恢复spsr */</span></span><br><span class="line"></span><br><span class="line">	pop &#123;r0-r3, r12&#125;			<span class="comment">/* r0-r3,r12出栈 */</span></span><br><span class="line">	pop &#123;lr&#125;					<span class="comment">/* lr出栈 */</span></span><br><span class="line">	subs pc, lr, #<span class="number">4</span>				<span class="comment">/* 将lr-4赋给pc */</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">/* FIQ中断 */</span></span><br><span class="line">FIQ_Handler:</span><br><span class="line"></span><br><span class="line">	ldr r0, =FIQ_Handler	</span><br><span class="line">	bx r0</span><br></pre></td></tr></table></figure>
<h1><span id="8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi">8 附件2：GIC指令和寄存器定义（内联汇编方式）</span><a href="#8-fu-jian-2-gic-zhi-ling-he-ji-cun-qi-ding-yi-nei-lian-hui-bian-fang-shi" class="header-anchor">#</a></h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __CORTEX_CA7_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __CORTEX_CA7_H</span></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">文件名	: 	 core_ca7.h</span></span><br><span class="line"><span class="comment">描述	   : Cortex-A7内核通用文件。</span></span><br><span class="line"><span class="comment">其他	   : 本文件主要实现了对GIC操作函数</span></span><br><span class="line"><span class="comment">论坛 	   : www.wtmembed.com</span></span><br><span class="line"><span class="comment">***************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FORCEDINLINE  __attribute__((always_inline))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ASM            __asm                         	<span class="comment">/* GNU C语言内嵌汇编关键字 */</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INLINE         inline                      	<span class="comment">/* GNU内联关键字 */</span>             </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STATIC_INLINE  static inline					</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __IM     volatile const      <span class="comment">/* 只读 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __OM     volatile            <span class="comment">/* 只写 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     __IOM    volatile            <span class="comment">/* 读写 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STRINGIFY(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C语言实现MCR指令 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \</span></span><br><span class="line"><span class="meta">    __ASM volatile (<span class="string">&quot;MCR &quot;</span> __STRINGIFY(p##coproc) <span class="string">&quot;, &quot;</span> __STRINGIFY(opcode_1) <span class="string">&quot;, &quot;</span> \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;%0, &quot;</span> __STRINGIFY(c##CRn) <span class="string">&quot;, &quot;</span> __STRINGIFY(c##CRm) <span class="string">&quot;, &quot;</span>      \</span></span><br><span class="line"><span class="meta">                    __STRINGIFY(opcode_2)                                         \</span></span><br><span class="line"><span class="meta">                    : : <span class="string">&quot;r&quot;</span> (src) )</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C语言实现MRC指令 */</span>                    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __MRC(coproc, opcode_1, CRn, CRm, opcode_2)                               \</span></span><br><span class="line"><span class="meta">  (&#123;                                                                              \</span></span><br><span class="line"><span class="meta">    uint32_t __dst;                                                               \</span></span><br><span class="line"><span class="meta">    __ASM volatile (<span class="string">&quot;MRC &quot;</span> __STRINGIFY(p##coproc) <span class="string">&quot;, &quot;</span> __STRINGIFY(opcode_1) <span class="string">&quot;, &quot;</span> \</span></span><br><span class="line"><span class="meta">                    <span class="string">&quot;%0, &quot;</span> __STRINGIFY(c##CRn) <span class="string">&quot;, &quot;</span> __STRINGIFY(c##CRm) <span class="string">&quot;, &quot;</span>      \</span></span><br><span class="line"><span class="meta">                    __STRINGIFY(opcode_2)                                         \</span></span><br><span class="line"><span class="meta">                    : <span class="string">&quot;=r&quot;</span> (__dst) );                                             \</span></span><br><span class="line"><span class="meta">    __dst;                                                                        \</span></span><br><span class="line"><span class="meta">  &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他一些C语言内嵌汇编 */</span>  </span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_APSR(<span class="type">uint32_t</span> apsr)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MSR apsr, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (apsr) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">uint32_t</span> __get_CPSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MRS %0, cpsr&quot;</span> : <span class="string">&quot;=r&quot;</span> (result) )</span>;</span><br><span class="line">  <span class="keyword">return</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_CPSR(<span class="type">uint32_t</span> cpsr)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;MSR cpsr, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (cpsr) : <span class="string">&quot;cc&quot;</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">uint32_t</span> __get_FPEXC(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> result;</span><br><span class="line"></span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;VMRS %0, fpexc&quot;</span> : <span class="string">&quot;=r&quot;</span> (result) )</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__( ( always_inline ) ) __STATIC_INLINE <span class="type">void</span> __set_FPEXC(<span class="type">uint32_t</span> fpexc)</span><br><span class="line">&#123;</span><br><span class="line">  __ASM <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;VMSR fpexc, %0&quot;</span> : : <span class="string">&quot;r&quot;</span> (fpexc))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *        		一些内核寄存器定义和抽象</span></span><br><span class="line"><span class="comment">  定义如下几个内核寄存器:</span></span><br><span class="line"><span class="comment">  - CPSR</span></span><br><span class="line"><span class="comment">  - CP15</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CPSR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：ARM Cortex-A(armV7)编程手册V4.0.pdf P46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> M:<span class="number">5</span>;                        <span class="comment">/*!&lt; bit:  0.. 4  Mode field */</span></span><br><span class="line">    <span class="type">uint32_t</span> T:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      5  Thumb execution state bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> F:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      6  FIQ mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      7  IRQ mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      8  Asynchronous abort mask bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> E:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:      9  Endianness execution state bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> IT1:<span class="number">6</span>;                      <span class="comment">/*!&lt; bit: 10..15  If-Then execution state bits 2-7 */</span></span><br><span class="line">    <span class="type">uint32_t</span> GE:<span class="number">4</span>;                       <span class="comment">/*!&lt; bit: 16..19  Greater than or Equal flags */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">4</span>;               <span class="comment">/*!&lt; bit: 20..23  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> J:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     24  Jazelle bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> IT0:<span class="number">2</span>;                      <span class="comment">/*!&lt; bit: 25..26  If-Then execution state bits 0-1 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Q:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     27  Saturation condition flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> V:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     28  Overflow condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> C:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     29  Carry condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> Z:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     30  Zero condition code flag */</span></span><br><span class="line">    <span class="type">uint32_t</span> N:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     31  Negative condition code flag */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; CPSR_Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的SCTLR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P105</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> M:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     0  MMU enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     1  Alignment check enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> C:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     2  Cache enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 3.. 4  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> CP15BEN:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:     5  CP15 barrier enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:     6  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> B:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     7  Endianness model */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved2:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 8.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> SW:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    10  SWP and SWPB enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> Z:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    11  Branch prediction enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    12  Instruction cache enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> V:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    13  Vectors bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> RR:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    14  Round Robin select */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved3:<span class="number">2</span>;               <span class="comment">/*!&lt; bit:15..16  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> HA:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    17  Hardware Access flag enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved4:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    18  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> WXN:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    19  Write permission implies XN */</span></span><br><span class="line">    <span class="type">uint32_t</span> UWXN:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    20  Unprivileged write permission implies PL1 XN */</span></span><br><span class="line">    <span class="type">uint32_t</span> FI:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    21  Fast interrupts configuration enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> U:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:    22  Alignment model */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved5:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    23  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> VE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    24  Interrupt Vectors Enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> EE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    25  Exception Endianness */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved6:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    26  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> NMFI:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    27  Non-maskable FIQ (NMFI) support */</span></span><br><span class="line">    <span class="type">uint32_t</span> TRE:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    28  TEX remap enable. */</span></span><br><span class="line">    <span class="type">uint32_t</span> AFE:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    29  Access flag enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> TE:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    30  Thumb Exception enable */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved7:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; SCTLR_Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15 寄存器SCTLR各个位定义 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TE_Pos                     30U                                    <span class="comment">/*!&lt; SCTLR: TE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TE_Msk                     (1UL &lt;&lt; SCTLR_TE_Pos)                  <span class="comment">/*!&lt; SCTLR: TE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_AFE_Pos                    29U                                    <span class="comment">/*!&lt; SCTLR: AFE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_AFE_Msk                    (1UL &lt;&lt; SCTLR_AFE_Pos)                 <span class="comment">/*!&lt; SCTLR: AFE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TRE_Pos                    28U                                    <span class="comment">/*!&lt; SCTLR: TRE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_TRE_Msk                    (1UL &lt;&lt; SCTLR_TRE_Pos)                 <span class="comment">/*!&lt; SCTLR: TRE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_NMFI_Pos                   27U                                    <span class="comment">/*!&lt; SCTLR: NMFI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_NMFI_Msk                   (1UL &lt;&lt; SCTLR_NMFI_Pos)                <span class="comment">/*!&lt; SCTLR: NMFI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_EE_Pos                     25U                                    <span class="comment">/*!&lt; SCTLR: EE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_EE_Msk                     (1UL &lt;&lt; SCTLR_EE_Pos)                  <span class="comment">/*!&lt; SCTLR: EE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_VE_Pos                     24U                                    <span class="comment">/*!&lt; SCTLR: VE Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_VE_Msk                     (1UL &lt;&lt; SCTLR_VE_Pos)                  <span class="comment">/*!&lt; SCTLR: VE Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_U_Pos                      22U                                    <span class="comment">/*!&lt; SCTLR: U Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_U_Msk                      (1UL &lt;&lt; SCTLR_U_Pos)                   <span class="comment">/*!&lt; SCTLR: U Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_FI_Pos                     21U                                    <span class="comment">/*!&lt; SCTLR: FI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_FI_Msk                     (1UL &lt;&lt; SCTLR_FI_Pos)                  <span class="comment">/*!&lt; SCTLR: FI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_UWXN_Pos                   20U                                    <span class="comment">/*!&lt; SCTLR: UWXN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_UWXN_Msk                   (1UL &lt;&lt; SCTLR_UWXN_Pos)                <span class="comment">/*!&lt; SCTLR: UWXN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_WXN_Pos                    19U                                    <span class="comment">/*!&lt; SCTLR: WXN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_WXN_Msk                    (1UL &lt;&lt; SCTLR_WXN_Pos)                 <span class="comment">/*!&lt; SCTLR: WXN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_HA_Pos                     17U                                    <span class="comment">/*!&lt; SCTLR: HA Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_HA_Msk                     (1UL &lt;&lt; SCTLR_HA_Pos)                  <span class="comment">/*!&lt; SCTLR: HA Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_RR_Pos                     14U                                    <span class="comment">/*!&lt; SCTLR: RR Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_RR_Msk                     (1UL &lt;&lt; SCTLR_RR_Pos)                  <span class="comment">/*!&lt; SCTLR: RR Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_V_Pos                      13U                                    <span class="comment">/*!&lt; SCTLR: V Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_V_Msk                      (1UL &lt;&lt; SCTLR_V_Pos)                   <span class="comment">/*!&lt; SCTLR: V Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_I_Pos                      12U                                    <span class="comment">/*!&lt; SCTLR: I Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_I_Msk                      (1UL &lt;&lt; SCTLR_I_Pos)                   <span class="comment">/*!&lt; SCTLR: I Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_Z_Pos                      11U                                    <span class="comment">/*!&lt; SCTLR: Z Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_Z_Msk                      (1UL &lt;&lt; SCTLR_Z_Pos)                   <span class="comment">/*!&lt; SCTLR: Z Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_SW_Pos                     10U                                    <span class="comment">/*!&lt; SCTLR: SW Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_SW_Msk                     (1UL &lt;&lt; SCTLR_SW_Pos)                  <span class="comment">/*!&lt; SCTLR: SW Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_B_Pos                      7U                                     <span class="comment">/*!&lt; SCTLR: B Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_B_Msk                      (1UL &lt;&lt; SCTLR_B_Pos)                   <span class="comment">/*!&lt; SCTLR: B Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_CP15BEN_Pos                5U                                     <span class="comment">/*!&lt; SCTLR: CP15BEN Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_CP15BEN_Msk                (1UL &lt;&lt; SCTLR_CP15BEN_Pos)             <span class="comment">/*!&lt; SCTLR: CP15BEN Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_C_Pos                      2U                                     <span class="comment">/*!&lt; SCTLR: C Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_C_Msk                      (1UL &lt;&lt; SCTLR_C_Pos)                   <span class="comment">/*!&lt; SCTLR: C Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_A_Pos                      1U                                     <span class="comment">/*!&lt; SCTLR: A Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_A_Msk                      (1UL &lt;&lt; SCTLR_A_Pos)                   <span class="comment">/*!&lt; SCTLR: A Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_M_Pos                      0U                                     <span class="comment">/*!&lt; SCTLR: M Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCTLR_M_Msk                      (1UL &lt;&lt; SCTLR_M_Pos)                   <span class="comment">/*!&lt; SCTLR: M Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的ACTLR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料:Cortex-A7 Technical ReferenceManua.pdf P113</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 0.. 5  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> SMP:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:     6  Enables coherent requests to the processor */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">3</span>;               <span class="comment">/*!&lt; bit: 7.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> DODMBS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    10  Disable optimized data memory barrier behavior */</span></span><br><span class="line">    <span class="type">uint32_t</span> L2RADIS:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:    11  L2 Data Cache read-allocate mode disable */</span></span><br><span class="line">    <span class="type">uint32_t</span> L1RADIS:<span class="number">1</span>;                  <span class="comment">/*!&lt; bit:    12  L1 Data Cache read-allocate mode disable */</span></span><br><span class="line">    <span class="type">uint32_t</span> L1PCTL:<span class="number">2</span>;                   <span class="comment">/*!&lt; bit:13..14  L1 Data prefetch control */</span></span><br><span class="line">    <span class="type">uint32_t</span> DDVM:<span class="number">1</span>;                     <span class="comment">/*!&lt; bit:    15  Disable Distributed Virtual Memory (DVM) transactions */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved3:<span class="number">12</span>;              <span class="comment">/*!&lt; bit:16..27  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> DDI:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    28  Disable dual issue */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved7:<span class="number">3</span>;               <span class="comment">/*!&lt; bit:29..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; ACTLR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDI_Pos                    28U                                     <span class="comment">/*!&lt; ACTLR: DDI Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDI_Msk                    (1UL &lt;&lt; ACTLR_DDI_Pos)                  <span class="comment">/*!&lt; ACTLR: DDI Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDVM_Pos                   15U                                     <span class="comment">/*!&lt; ACTLR: DDVM Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DDVM_Msk                   (1UL &lt;&lt; ACTLR_DDVM_Pos)                 <span class="comment">/*!&lt; ACTLR: DDVM Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1PCTL_Pos                 13U                                     <span class="comment">/*!&lt; ACTLR: L1PCTL Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1PCTL_Msk                 (3UL &lt;&lt; ACTLR_L1PCTL_Pos)               <span class="comment">/*!&lt; ACTLR: L1PCTL Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1RADIS_Pos                12U                                     <span class="comment">/*!&lt; ACTLR: L1RADIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L1RADIS_Msk                (1UL &lt;&lt; ACTLR_L1RADIS_Pos)              <span class="comment">/*!&lt; ACTLR: L1RADIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L2RADIS_Pos                11U                                     <span class="comment">/*!&lt; ACTLR: L2RADIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_L2RADIS_Msk                (1UL &lt;&lt; ACTLR_L2RADIS_Pos)              <span class="comment">/*!&lt; ACTLR: L2RADIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DODMBS_Pos                 10U                                     <span class="comment">/*!&lt; ACTLR: DODMBS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_DODMBS_Msk                 (1UL &lt;&lt; ACTLR_DODMBS_Pos)               <span class="comment">/*!&lt; ACTLR: DODMBS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_SMP_Pos                    6U                                      <span class="comment">/*!&lt; ACTLR: SMP Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACTLR_SMP_Msk                    (1UL &lt;&lt; ACTLR_SMP_Pos)                  <span class="comment">/*!&lt; ACTLR: SMP Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的CPACR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P115</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">20</span>;              <span class="comment">/*!&lt; bit: 0..19  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> cp10:<span class="number">2</span>;                     <span class="comment">/*!&lt; bit:20..21  Access rights for coprocessor 10 */</span></span><br><span class="line">    <span class="type">uint32_t</span> cp11:<span class="number">2</span>;                     <span class="comment">/*!&lt; bit:22..23  Access rights for coprocessor 11 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">6</span>;               <span class="comment">/*!&lt; bit:24..29  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> D32DIS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    30  Disable use of registers D16-D31 of the VFP register file */</span></span><br><span class="line">    <span class="type">uint32_t</span> ASEDIS:<span class="number">1</span>;                   <span class="comment">/*!&lt; bit:    31  Disable Advanced SIMD Functionality */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; CPACR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_ASEDIS_Pos                 31U                                    <span class="comment">/*!&lt; CPACR: ASEDIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_ASEDIS_Msk                 (1UL &lt;&lt; CPACR_ASEDIS_Pos)              <span class="comment">/*!&lt; CPACR: ASEDIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_D32DIS_Pos                 30U                                    <span class="comment">/*!&lt; CPACR: D32DIS Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_D32DIS_Msk                 (1UL &lt;&lt; CPACR_D32DIS_Pos)              <span class="comment">/*!&lt; CPACR: D32DIS Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp11_Pos                   22U                                    <span class="comment">/*!&lt; CPACR: cp11 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp11_Msk                   (3UL &lt;&lt; CPACR_cp11_Pos)                <span class="comment">/*!&lt; CPACR: cp11 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp10_Pos                   20U                                    <span class="comment">/*!&lt; CPACR: cp10 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CPACR_cp10_Msk                   (3UL &lt;&lt; CPACR_cp10_Pos)                <span class="comment">/*!&lt; CPACR: cp10 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的DFSR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P128</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FS0:<span class="number">4</span>;                      <span class="comment">/*!&lt; bit: 0.. 3  Fault Status bits bit 0-3 */</span></span><br><span class="line">    <span class="type">uint32_t</span> Domain:<span class="number">4</span>;                   <span class="comment">/*!&lt; bit: 4.. 7  Fault on which domain */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">2</span>;               <span class="comment">/*!&lt; bit: 8.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> FS1:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    10  Fault Status bits bit 4 */</span></span><br><span class="line">    <span class="type">uint32_t</span> WnR:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    11  Write not Read bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> ExT:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    12  External abort type */</span></span><br><span class="line">    <span class="type">uint32_t</span> CM:<span class="number">1</span>;                       <span class="comment">/*!&lt; bit:    13  Cache maintenance fault */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">18</span>;              <span class="comment">/*!&lt; bit:14..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; DFSR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_CM_Pos                      13U                                    <span class="comment">/*!&lt; DFSR: CM Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_CM_Msk                      (1UL &lt;&lt; DFSR_CM_Pos)                   <span class="comment">/*!&lt; DFSR: CM Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Ext_Pos                     12U                                    <span class="comment">/*!&lt; DFSR: Ext Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Ext_Msk                     (1UL &lt;&lt; DFSR_Ext_Pos)                  <span class="comment">/*!&lt; DFSR: Ext Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_WnR_Pos                     11U                                    <span class="comment">/*!&lt; DFSR: WnR Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_WnR_Msk                     (1UL &lt;&lt; DFSR_WnR_Pos)                  <span class="comment">/*!&lt; DFSR: WnR Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS1_Pos                     10U                                    <span class="comment">/*!&lt; DFSR: FS1 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS1_Msk                     (1UL &lt;&lt; DFSR_FS1_Pos)                  <span class="comment">/*!&lt; DFSR: FS1 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Domain_Pos                  4U                                     <span class="comment">/*!&lt; DFSR: Domain Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_Domain_Msk                  (0xFUL &lt;&lt; DFSR_Domain_Pos)             <span class="comment">/*!&lt; DFSR: Domain Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS0_Pos                     0U                                     <span class="comment">/*!&lt; DFSR: FS0 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DFSR_FS0_Msk                     (0xFUL &lt;&lt; DFSR_FS0_Pos)                <span class="comment">/*!&lt; DFSR: FS0 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的IFSR寄存器 </span></span><br><span class="line"><span class="comment"> * 参考资料：Cortex-A7 Technical ReferenceManua.pdf P131</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> FS0:<span class="number">4</span>;                      <span class="comment">/*!&lt; bit: 0.. 3  Fault Status bits bit 0-3 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 4.. 9  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> FS1:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    10  Fault Status bits bit 4 */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">1</span>;               <span class="comment">/*!&lt; bit:    11  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> ExT:<span class="number">1</span>;                      <span class="comment">/*!&lt; bit:    12  External abort type */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved2:<span class="number">19</span>;              <span class="comment">/*!&lt; bit:13..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; IFSR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_ExT_Pos                     12U                                    <span class="comment">/*!&lt; IFSR: ExT Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_ExT_Msk                     (1UL &lt;&lt; IFSR_ExT_Pos)                  <span class="comment">/*!&lt; IFSR: ExT Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS1_Pos                     10U                                    <span class="comment">/*!&lt; IFSR: FS1 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS1_Msk                     (1UL &lt;&lt; IFSR_FS1_Pos)                  <span class="comment">/*!&lt; IFSR: FS1 Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS0_Pos                     0U                                     <span class="comment">/*!&lt; IFSR: FS0 Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IFSR_FS0_Msk                     (0xFUL &lt;&lt; IFSR_FS0_Pos)                <span class="comment">/*!&lt; IFSR: FS0 Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CP15的ISR寄存器</span></span><br><span class="line"><span class="comment"> * 参考资料：ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf P1640</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved0:<span class="number">6</span>;               <span class="comment">/*!&lt; bit: 0.. 5  Reserved */</span></span><br><span class="line">    <span class="type">uint32_t</span> F:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     6  FIQ pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> I:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     7  IRQ pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> A:<span class="number">1</span>;                        <span class="comment">/*!&lt; bit:     8  External abort pending bit */</span></span><br><span class="line">    <span class="type">uint32_t</span> _reserved1:<span class="number">23</span>;              <span class="comment">/*!&lt; bit:14..31  Reserved */</span></span><br><span class="line">  &#125; b;                                   <span class="comment">/*!&lt; Structure used for bit  access */</span></span><br><span class="line">  <span class="type">uint32_t</span> w;                            <span class="comment">/*!&lt; Type      used for word access */</span></span><br><span class="line">&#125; ISR_Type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_A_Pos                        13U                                    <span class="comment">/*!&lt; ISR: A Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_A_Msk                        (1UL &lt;&lt; ISR_A_Pos)                     <span class="comment">/*!&lt; ISR: A Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_I_Pos                        12U                                    <span class="comment">/*!&lt; ISR: I Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_I_Msk                        (1UL &lt;&lt; ISR_I_Pos)                     <span class="comment">/*!&lt; ISR: I Mask */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_F_Pos                        11U                                    <span class="comment">/*!&lt; ISR: F Position */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ISR_F_Msk                        (1UL &lt;&lt; ISR_F_Pos)                     <span class="comment">/*!&lt; ISR: F Mask */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask and shift a bit field value for use in a register bit range. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _VAL2FLD(field, value)    ((value &lt;&lt; field ## _Pos) &amp; field ## _Msk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mask and shift a register value to extract a bit filed value. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FLD2VAL(field, value)    ((value &amp; field ## _Msk) &gt;&gt; field ## _Pos)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *       			CP15 访问函数</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_SCTLR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_SCTLR(<span class="type">uint32_t</span> sctlr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, sctlr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_ACTLR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_ACTLR(<span class="type">uint32_t</span> actlr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, actlr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CPACR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_CPACR(<span class="type">uint32_t</span> cpacr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, cpacr, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBR0(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBR0(<span class="type">uint32_t</span> ttbr0)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbr0, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBR1(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBR1(<span class="type">uint32_t</span> ttbr1)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbr1, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_TTBCR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_TTBCR(<span class="type">uint32_t</span> ttbcr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ttbcr, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DACR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DACR(<span class="type">uint32_t</span> dacr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dacr, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DFSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DFSR(<span class="type">uint32_t</span> dfsr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dfsr, <span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_IFSR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_IFSR(<span class="type">uint32_t</span> ifsr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ifsr, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_DFAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_DFAR(<span class="type">uint32_t</span> dfar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, dfar, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_IFAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_IFAR(<span class="type">uint32_t</span> ifar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, ifar, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_VBAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_VBAR(<span class="type">uint32_t</span> vbar)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, vbar, <span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_ISR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_ISR(<span class="type">uint32_t</span> isr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, isr, <span class="number">12</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CONTEXTIDR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> __set_CONTEXTIDR(<span class="type">uint32_t</span> contextidr)</span><br><span class="line">&#123;</span><br><span class="line">  __MCR(<span class="number">15</span>, <span class="number">0</span>, contextidr, <span class="number">13</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> __get_CBAR(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __MRC(<span class="number">15</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment"> *                 GIC相关内容</span></span><br><span class="line"><span class="comment"> *有关GIC的内容，参考：ARM Generic Interrupt Controller(ARM GIC控制器)V2.0.pdf</span></span><br><span class="line"><span class="comment"> ******************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GIC寄存器描述结构体，</span></span><br><span class="line"><span class="comment"> * GIC分为分发器端和CPU接口端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED0[<span class="number">1024</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_CTLR;                 <span class="comment">/*!&lt; Offset: 0x1000 (R/W) Distributor Control Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_TYPER;                <span class="comment">/*!&lt; Offset: 0x1004 (R/ )  Interrupt Controller Type Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_IIDR;                 <span class="comment">/*!&lt; Offset: 0x1008 (R/ )  Distributor Implementer Identification Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED1[<span class="number">29</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_IGROUPR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1080 - 0x0BC (R/W) Interrupt Group Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED2[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISENABLER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1100 - 0x13C (R/W) Interrupt Set-Enable Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED3[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICENABLER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1180 - 0x1BC (R/W) Interrupt Clear-Enable Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED4[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISPENDR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1200 - 0x23C (R/W) Interrupt Set-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED5[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICPENDR[<span class="number">16</span>];          <span class="comment">/*!&lt; Offset: 0x1280 - 0x2BC (R/W) Interrupt Clear-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED6[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ISACTIVER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1300 - 0x33C (R/W) Interrupt Set-Active Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED7[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICACTIVER[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1380 - 0x3BC (R/W) Interrupt Clear-Active Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED8[<span class="number">16</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_IPRIORITYR[<span class="number">512</span>];      <span class="comment">/*!&lt; Offset: 0x1400 - 0x5FC (R/W) Interrupt Priority Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED9[<span class="number">128</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_ITARGETSR[<span class="number">512</span>];       <span class="comment">/*!&lt; Offset: 0x1800 - 0x9FC (R/W) Interrupt Targets Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED10[<span class="number">128</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> D_ICFGR[<span class="number">32</span>];            <span class="comment">/*!&lt; Offset: 0x1C00 - 0xC7C (R/W) Interrupt configuration registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED11[<span class="number">32</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PPISR;                <span class="comment">/*!&lt; Offset: 0x1D00 (R/ ) Private Peripheral Interrupt Status Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_SPISR[<span class="number">15</span>];            <span class="comment">/*!&lt; Offset: 0x1D04 - 0xD3C (R/ ) Shared Peripheral Interrupt Status Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED12[<span class="number">112</span>];</span><br><span class="line">  __OM  <span class="type">uint32_t</span> D_SGIR;                 <span class="comment">/*!&lt; Offset: 0x1F00 ( /W) Software Generated Interrupt Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED13[<span class="number">3</span>];</span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_CPENDSGIR[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1F10 - 0xF1C (R/W) SGI Clear-Pending Registers */</span></span><br><span class="line">  __IOM <span class="type">uint8_t</span>  D_SPENDSGIR[<span class="number">16</span>];        <span class="comment">/*!&lt; Offset: 0x1F20 - 0xF2C (R/W) SGI Set-Pending Registers */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED14[<span class="number">40</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR4;                <span class="comment">/*!&lt; Offset: 0x1FD0 (R/ ) Peripheral ID4 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR5;                <span class="comment">/*!&lt; Offset: 0x1FD4 (R/ ) Peripheral ID5 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR6;                <span class="comment">/*!&lt; Offset: 0x1FD8 (R/ ) Peripheral ID6 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR7;                <span class="comment">/*!&lt; Offset: 0x1FDC (R/ ) Peripheral ID7 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR0;                <span class="comment">/*!&lt; Offset: 0x1FE0 (R/ ) Peripheral ID0 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR1;                <span class="comment">/*!&lt; Offset: 0x1FE4 (R/ ) Peripheral ID1 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR2;                <span class="comment">/*!&lt; Offset: 0x1FE8 (R/ ) Peripheral ID2 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_PIDR3;                <span class="comment">/*!&lt; Offset: 0x1FEC (R/ ) Peripheral ID3 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR0;                <span class="comment">/*!&lt; Offset: 0x1FF0 (R/ ) Component ID0 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR1;                <span class="comment">/*!&lt; Offset: 0x1FF4 (R/ ) Component ID1 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR2;                <span class="comment">/*!&lt; Offset: 0x1FF8 (R/ ) Component ID2 Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> D_CIDR3;                <span class="comment">/*!&lt; Offset: 0x1FFC (R/ ) Component ID3 Register */</span></span><br><span class="line"></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_CTLR;                 <span class="comment">/*!&lt; Offset: 0x2000 (R/W) CPU Interface Control Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_PMR;                  <span class="comment">/*!&lt; Offset: 0x2004 (R/W) Interrupt Priority Mask Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_BPR;                  <span class="comment">/*!&lt; Offset: 0x2008 (R/W) Binary Point Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_IAR;                  <span class="comment">/*!&lt; Offset: 0x200C (R/ ) Interrupt Acknowledge Register */</span></span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_EOIR;                 <span class="comment">/*!&lt; Offset: 0x2010 ( /W) End Of Interrupt Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_RPR;                  <span class="comment">/*!&lt; Offset: 0x2014 (R/ ) Running Priority Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_HPPIR;                <span class="comment">/*!&lt; Offset: 0x2018 (R/ ) Highest Priority Pending Interrupt Register */</span></span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_ABPR;                 <span class="comment">/*!&lt; Offset: 0x201C (R/W) Aliased Binary Point Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_AIAR;                 <span class="comment">/*!&lt; Offset: 0x2020 (R/ ) Aliased Interrupt Acknowledge Register */</span></span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_AEOIR;                <span class="comment">/*!&lt; Offset: 0x2024 ( /W) Aliased End Of Interrupt Register */</span></span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_AHPPIR;               <span class="comment">/*!&lt; Offset: 0x2028 (R/ ) Aliased Highest Priority Pending Interrupt Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED15[<span class="number">41</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_APR0;                 <span class="comment">/*!&lt; Offset: 0x20D0 (R/W) Active Priority Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED16[<span class="number">3</span>];</span><br><span class="line">  __IOM <span class="type">uint32_t</span> C_NSAPR0;               <span class="comment">/*!&lt; Offset: 0x20E0 (R/W) Non-secure Active Priority Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED17[<span class="number">6</span>];</span><br><span class="line">  __IM  <span class="type">uint32_t</span> C_IIDR;                 <span class="comment">/*!&lt; Offset: 0x20FC (R/ ) CPU Interface Identification Register */</span></span><br><span class="line">        <span class="type">uint32_t</span> RESERVED18[<span class="number">960</span>];</span><br><span class="line">  __OM  <span class="type">uint32_t</span> C_DIR;                  <span class="comment">/*!&lt; Offset: 0x3000 ( /W) Deactivate Interrupt Register */</span></span><br><span class="line">&#125; GIC_Type;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * GIC初始化</span></span><br><span class="line"><span class="comment"> * 为了简单使用GIC的group0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> i;</span><br><span class="line">  <span class="type">uint32_t</span> irqRegs;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line"></span><br><span class="line">  irqRegs = (gic-&gt;D_TYPER &amp; <span class="number">0x1F</span>UL) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* On POR, all SPI is in group 0, level-sensitive and using 1-N model */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable all PPI, SGI and SPI */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; irqRegs; i++)</span><br><span class="line">    gic-&gt;D_ICENABLER[i] = <span class="number">0xFFFFFFFF</span>UL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make all interrupts have higher priority */</span></span><br><span class="line">  gic-&gt;C_PMR = (<span class="number">0xFF</span>UL &lt;&lt; (<span class="number">8</span> - __GIC_PRIO_BITS)) &amp; <span class="number">0xFF</span>UL;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* No subpriority, all priority level allows preemption */</span></span><br><span class="line">  gic-&gt;C_BPR = <span class="number">7</span> - __GIC_PRIO_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable group0 distribution */</span></span><br><span class="line">  gic-&gt;D_CTLR = <span class="number">1UL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable group0 signaling */</span></span><br><span class="line">  gic-&gt;C_CTLR = <span class="number">1UL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 使能指定的中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_EnableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_ISENABLER[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &gt;&gt; <span class="number">5</span>] = (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; (((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &amp; <span class="number">0x1F</span>UL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * 关闭指定的中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_DisableIRQ</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_ICENABLER[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &gt;&gt; <span class="number">5</span>] = (<span class="type">uint32_t</span>)(<span class="number">1UL</span> &lt;&lt; (((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn) &amp; <span class="number">0x1F</span>UL));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 返回中断号 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_AcknowledgeIRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	<span class="keyword">return</span> gic-&gt;C_IAR &amp; <span class="number">0x1FFF</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 向EOIR写入发送中断的中断号来释放中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_DeactivateIRQ</span><span class="params">(<span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;C_EOIR = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取运行优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetRunningPriority</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	<span class="keyword">return</span> gic-&gt;C_RPR &amp; <span class="number">0xFF</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置组优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_SetPriorityGrouping</span><span class="params">(<span class="type">uint32_t</span> PriorityGroup)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;C_BPR = PriorityGroup &amp; <span class="number">0x7</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取组优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetPriorityGrouping</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> gic-&gt;C_BPR &amp; <span class="number">0x7</span>UL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">void</span> <span class="title function_">GIC_SetPriority</span><span class="params">(IRQn_Type IRQn, <span class="type">uint32_t</span> priority)</span></span><br><span class="line">&#123;</span><br><span class="line">  	GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  	gic-&gt;D_IPRIORITYR[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn)] = (<span class="type">uint8_t</span>)((priority &lt;&lt; (<span class="number">8UL</span> - __GIC_PRIO_BITS)) &amp; (<span class="type">uint32_t</span>)<span class="number">0xFF</span>UL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FORCEDINLINE __STATIC_INLINE <span class="type">uint32_t</span> <span class="title function_">GIC_GetPriority</span><span class="params">(IRQn_Type IRQn)</span></span><br><span class="line">&#123;</span><br><span class="line">  GIC_Type *gic = (GIC_Type *)(__get_CBAR() &amp; <span class="number">0xFFFF0000</span>UL);</span><br><span class="line">  <span class="keyword">return</span>(((<span class="type">uint32_t</span>)gic-&gt;D_IPRIORITYR[((<span class="type">uint32_t</span>)(<span class="type">int32_t</span>)IRQn)] &gt;&gt; (<span class="number">8UL</span> - __GIC_PRIO_BITS)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2><span id="8-1-nei-lian-hui-bian-yuan-li">8.1 内联汇编原理</span><a href="#8-1-nei-lian-hui-bian-yuan-li" class="header-anchor">#</a></h2><p>先看一个错误的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov r1,r0&quot;</span>);</span><br><span class="line">    __asm__(<span class="string">&quot;mov r2,r1&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种操作可能产生负面的影响，因为 r0~r2 寄存器很可能正在被程序的其它部分使用而在这里被意外地修改。<br>这就需要使用到嵌入汇编的另一种表达形式：<br><code>asm(code : output operand list : input operand list : clobber list);</code><br>这种嵌入汇编的形式一共分为四个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* code</span><br><span class="line">* [attr]output operand list</span><br><span class="line">* [attr]input operand list</span><br><span class="line">* clobber list</span><br></pre></td></tr></table></figure>

<p><code>code</code>：汇编的操作代码，一条或者多条指令，如果是多条指令，需要在指令间使用<code>\n\t</code>隔开。<br>    与通用的汇编代码有一些不同：因为支持 C 变量的操作，所以在操作由第二、三部分提供<br>    的操作数时，使用 %n 来替代操作数。<br><code>output operand list</code>：表示输出的操作数，通常是一个或者多个 C 函数中的变量。<br><code>input operand list</code>：表示输入的操作数，通常是一个或者多个 C 函数中的变量，<code>attr</code>部分表示操作数的属性，以字符串的形式提供，是必须的参数。<br><code>clobber list</code>：被破坏的列表，这部分我们放到后面讨论。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> val1 = <span class="number">111</span>,val2 = <span class="number">222</span>;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot;mov %0,%1&quot;</span></span><br><span class="line">        :<span class="string">&quot;+r&quot;</span>(val1)</span><br><span class="line">        :<span class="string">&quot;r&quot;</span>(val2)</span><br><span class="line">        :);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;val1 = %d\n&quot;</span>,val1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func</code> 函数的输出结果为：<code>val1 = 222</code>.<br>分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输出操作数为 val1，属性为 &quot;=r&quot;。</span><br><span class="line">输入操作数为 val2，属性为 &quot;r&quot;</span><br><span class="line">code 部分为 mov %1,%0, %0 表示输入输出列表中的第一个操作数，</span><br><span class="line">	%1 表示操作数列表中提供的第二个操作数，以此类推，这条汇编指</span><br><span class="line">	令很明显就是将第二个操作数(val2)赋值给第一个操作数(val1),所以最后的结果为 val1 = 222.</span><br><span class="line"></span><br><span class="line">code 中的操作数命名顺序为输出操作书列表递增，输入操作数列表递增，比如增加一个操作数的代码为：</span><br><span class="line">	int val1 = 111,val2 = 222,val3=333;</span><br><span class="line">	asm(&quot;mov %0,%2&quot; :&quot;+r&quot;(val1) :&quot;r&quot;(val2),&quot;r&quot;(val3) :);</span><br></pre></td></tr></table></figure>

<h3><span id="8-1-1-cao-zuo-shu-shu-xing">8.1.1 操作数属性</span><a href="#8-1-1-cao-zuo-shu-shu-xing" class="header-anchor">#</a></h3><p>在上述的示例中，输入操作数和输出操作数都会使用到 <code>attr </code>字段，即操作数的属性，下面是其属性对应的列表:</p>
<ul>
<li>“&#x3D;” 表示只写，通常用于所有输出操作数的属性</li>
<li>“+” 表示读写，只能被列为输出操作数的属性，否则编译会报错。</li>
</ul>
<h3><span id="8-1-2-clobber-list">8.1.2 clobber list</span><a href="#8-1-2-clobber-list" class="header-anchor">#</a></h3><p>clobber 的意思为破坏，在这里的意思是：这段汇编指令将会破坏哪些寄存器的值。</p>
<p>在目前的 gcc 设计中，编译分为4个过程：<code>预编译、编译、汇编、链接</code>。  其中，编译就是将 C 代码编译成汇编代码，而通用的汇编代码在这个过程是不会处理的，也就是说，<code>嵌入汇编代码</code>的解析只涉及到输入输出操作数的替换，对于不包含输入输出操作数的部分不会解析，所以在编译阶段，编译器不会知道嵌入汇编代码中静态地使用到哪些寄存器，而是自顾自地编译 C 代码，从而导致 C 代码和嵌入汇编代码操作到同一个寄存器，而出现错误。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov lr,#1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>嵌入汇编代码过程</code>中，将<code>lr</code>的值修改为 1，当前函数返回的时候也就返回到 1 地址，不出意料: 程序出现段错误:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>解决办法是：将程序修改一下,用<code>clobber list</code>这种标准格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov lr,#1&quot;</span>:::<span class="string">&quot;lr&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步追求真相，我们来对比它们的反汇编代码:</p>
<p>不添加 clobber list 的反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000083f</span>4 &lt;func3&gt;:</span><br><span class="line">    <span class="number">83f</span>4:       b480            push    &#123;r7&#125;</span><br><span class="line">    <span class="number">83f</span>6:       af00            add     r7, sp, #<span class="number">0</span></span><br><span class="line">    <span class="number">83f</span>8:       f04f <span class="number">0e01</span>       mov.w   lr, #<span class="number">1</span></span><br><span class="line">    <span class="number">83f</span>c:       <span class="number">46b</span>d            mov     sp, r7</span><br><span class="line">    <span class="number">83f</span>e:       f85d <span class="number">7b</span>04       ldr.w   r7, [sp], #<span class="number">4</span></span><br><span class="line">    <span class="number">8402</span>:       <span class="number">4770</span>            bx      lr</span><br></pre></td></tr></table></figure>

<p>添加 clobber list 的反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">83f</span>4:       b580            push    &#123;r7, lr&#125;</span><br><span class="line">    <span class="number">83f</span>6:       af00            add     r7, sp, #<span class="number">0</span></span><br><span class="line">    <span class="number">83f</span>8:       f04f <span class="number">0e01</span>       mov.w   lr, #<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="number">83f</span>c:       bd80            pop     &#123;r7, pc&#125;</span><br><span class="line">    <span class="number">83f</span>e:       bf00            nop</span><br></pre></td></tr></table></figure>

<p>对比可以看出，对于不将<code>&quot;lr&quot;</code>添加到 <code>clobber list </code>中的代码，返回指令为<code> bx lr</code>，因为<code>lr</code>被修改为 1，所以返回一定出错.<br>第二个代码则不一样，在函数调用之初，就将<code>lr</code>寄存器使用 push 指令保存到了栈上，在最后返回的时候再将栈上的原 <code>lr </code>数据 pop 到 pc 指针中，其中<code>lr</code>的修改没有任何影响。</p>
<p>通常情况下，<code>clobber list </code>对应着寄存器的修改，所以我们只需要将寄存器的名字作为参数添加到<code>clobber list</code>中，比如<code>&quot;r0&quot; &quot;lr&quot;</code>等，有<strong>两个特殊的参数需要关注</strong>，就是 **<code>&quot;cc&quot; 和 &quot;memory&quot;</code>**。  </p>
<p><code>&quot;cc&quot; </code>对应的并非是普通寄存器，而是 CPU 的<code>状态寄存器</code>，如果某些指令将状态寄存器修改了，需要在<code>clobber list</code>中添加<code>&quot;cc&quot;</code>来声明这个事情。</p>
<p><code>&quot;memory&quot; </code>对应内存操作，这从名称也可以看出，当<code>clobber list</code>中包含<code>&quot;memory&quot;</code>时，表示嵌入汇编代码会对内存进行一些操作，gcc 生成的代码会将特定的寄存器的值写回到内存中以保证内存中的值是最新的，这样做的原因是 gcc 经常会将内存数据缓存在寄存器中，如果不及时写回，嵌入汇编代码读到的内存就是原来的值。</p>
]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>arm汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>通用裸机-传感器</title>
    <url>/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/</url>
    <content><![CDATA[<div class="toc">

<!-- toc -->

<ul>
<li><a href="#1-dht11-wen-shi-du-chuan-gan-qi">1 DHT11温湿度传感器</a><ul>
<li><a href="#1-1-shi-xu-jie-xi">1.1 时序解析</a><ul>
<li><a href="#1-1-1-shu-ju-ge-shi">1.1.1 数据格式</a></li>
<li><a href="#1-1-2-shi-xu-can-shu">1.1.2 时序参数</a></li>
<li><a href="#1-1-3-shu-ju-chuan-shu">1.1.3 数据传输</a></li>
</ul>
</li>
<li><a href="#1-1-4-dai-ma-shi-xian">1.1.4 代码实现</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h1><span id="1-dht11-wen-shi-du-chuan-gan-qi">1 DHT11温湿度传感器</span><a href="#1-dht11-wen-shi-du-chuan-gan-qi" class="header-anchor">#</a></h1><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/1.png" alt="img"></p>
<p>MCU通过一条数据线与DH11连接，MCU通过这条线发命令给DH11，DH11再通过这条线把数据发送给MCU。只需要一根GPIO就OK了。</p>
<p>核心就是MCU发给DH11的命令格式和DH11返回的数据格式。</p>
<h2><span id="1-1-shi-xu-jie-xi">1.1 时序解析</span><a href="#1-1-shi-xu-jie-xi" class="header-anchor">#</a></h2><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/2.png" alt="img"></p>
<ol>
<li><p>MCU发送一个开始信号S，这个开始信号是一个低脉冲，然后再拉高。等待DHT11应答。</p>
</li>
<li><p>DH11拉低，做出一个响应信号，再拉高，准备发送数据。</p>
</li>
<li><p>接着就是DH11返回的数据。</p>
</li>
</ol>
<h3><span id="1-1-1-shu-ju-ge-shi">1.1.1 数据格式</span><a href="#1-1-1-shu-ju-ge-shi" class="header-anchor">#</a></h3><p>这些数据一共有40bit,高位先出。（8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据+8bit校验和）</p>
<p>数据有40bit: 8bit湿度整数数据+8bit湿度小数数据+8bit温度整数数据+8bit温度小数数据+8bit校验和</p>
<h3><span id="1-1-2-shi-xu-can-shu">1.1.2 时序参数</span><a href="#1-1-2-shi-xu-can-shu" class="header-anchor">#</a></h3><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/3.png" alt="img"></p>
<p>MCU必须先拉低至少18ms, 然后再拉高20-40us, DH11再拉低80us以响应,最后再拉高80us。</p>
<h3><span id="1-1-3-shu-ju-chuan-shu">1.1.3 数据传输</span><a href="#1-1-3-shu-ju-chuan-shu" class="header-anchor">#</a></h3><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/4.png" alt="img"></p>
<p><strong>Bit0</strong>：1bit 50us开始后，DHT11拉低数据时间为30us以内。</p>
<p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/5.png" alt="img"></p>
<p><strong>Bit1</strong>: 1bit 50us开始后，DHT11拉低数据时间为超过70us。</p>
<h2><span id="1-1-4-dai-ma-shi-xian">1.1.4 代码实现</span><a href="#1-1-4-dai-ma-shi-xian" class="header-anchor">#</a></h2><p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/6.png" alt="img"></p>
<p><img src="/2024/05/12/%E9%80%9A%E7%94%A8%E8%A3%B8%E6%9C%BA-%E4%BC%A0%E6%84%9F%E5%99%A8/7.png" alt="img"></p>
<p>使用GPG5引脚:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_cfg_as_output</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">        GPGCON |= (<span class="number">1</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_cfg_as_input</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        GPGCON &amp;= ~(<span class="number">3</span>&lt;&lt;<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_data_set</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val)</span><br><span class="line">                GPGDAT |= (<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                GPGDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_data_get</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (GPGDAT &amp; (<span class="number">1</span>&lt;&lt;<span class="number">5</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DHT11操作：</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dht11_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dht11_data_cfg_as_output();</span><br><span class="line">    dht11_data_set(<span class="number">1</span>);</span><br><span class="line">    mdelay(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dht11_start</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    dht11_data_set(<span class="number">0</span>);</span><br><span class="line">    mdelay(<span class="number">20</span>);</span><br><span class="line">    dht11_data_cfg_as_input();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_wait_ack</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    udelay(<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> dht11_data_get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_recv_byte</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_wait_for_val(<span class="number">1</span>, <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for high data err!\n\r&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        udelay(<span class="number">40</span>);</span><br><span class="line">        data &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dht11_data_get() == <span class="number">1</span>)</span><br><span class="line">            data |= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dht11_wait_for_val(<span class="number">0</span>, <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for low data err!\n\r&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dht11_wait_for_val</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> timeout_us)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (timeout_us--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_data_get() == val)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* ok */</span></span><br><span class="line">        udelay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* err */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dht11_read</span><span class="params">(<span class="type">int</span> *hum, <span class="type">int</span> *temp)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> hum_m, hum_n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> temp_m, temp_n;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> check;        </span><br><span class="line">    </span><br><span class="line">    dht11_start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_ack()) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 not ack, err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_for_val(<span class="number">1</span>, <span class="number">1000</span>)) &#123; <span class="comment">/* 等待ACK变为高电平, 超时时间是1000us */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for ack high err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != dht11_wait_for_val(<span class="number">0</span>, <span class="number">1000</span>)) &#123; <span class="comment">/* 数据阶段: 等待低电平, 超时时间是1000us */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 wait for data low err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hum_m  = dht11_recv_byte();</span><br><span class="line">    hum_n  = dht11_recv_byte();</span><br><span class="line">    temp_m = dht11_recv_byte();</span><br><span class="line">    temp_n = dht11_recv_byte();</span><br><span class="line">    check  = dht11_recv_byte();</span><br><span class="line"></span><br><span class="line">    dht11_data_cfg_as_output();</span><br><span class="line">    dht11_data_set(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hum_m + hum_n + temp_m + temp_n == check) &#123;</span><br><span class="line">        *hum  = hum_m;</span><br><span class="line">        *temp = temp_m;</span><br><span class="line">        mdelay(<span class="number">2000</span>);  <span class="comment">/* 读取周期是2S, 不能读太频繁 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;dht11 checksum err!\n\r&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dht11_test</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hum, temp;</span><br><span class="line">    dht11_init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dht11_read(&amp;hum, &amp;temp) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\rdht11 read err!\n\r&quot;</span>);</span><br><span class="line">            dht11_init();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n\rDHT11 : %d humidity, %d temperature\n\r&quot;</span>, hum, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>arm裸机</tag>
        <tag>外设驱动</tag>
      </tags>
  </entry>
</search>
